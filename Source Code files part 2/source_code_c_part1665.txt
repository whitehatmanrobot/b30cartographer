MBLE_DIV != 0)
    BG_CHK(PAGE_PREAMBLE_DIV);
    // (uCount / PAGE_PREAMBLE_DIV) zeros will be sent in ModemSendMode
    uCount -= (uCount / (PAGE_PREAMBLE_DIV));
#endif // (PAGE_PREAMBLE_DIV != 0)


#if 0 // RSL
    // **DON'T** call RecvSilence here since it is a send-followed-by-send
    // case. _Only_ call RecvSilence in recv-followed-by-send cases
    if(!ModemSendSilence(pTG, pTG->Params.hModem, SEND_PHASEC_PAUSE, SHORT_SENDSILENCE_TIMEOUT))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "TCF SendSilence(%d, %d) FAILED!!!",
                        SEND_PHASEC_PAUSE,
                        SHORT_SENDSILENCE_TIMEOUT);
    }
#endif


#ifdef MDDI2
    return ModemSendTCF(pTG, pTG->Params.hModem, uCurMod, 1500);
#else //MDDI2
    if(!ModemSendMode(pTG, pTG->Params.hModem, uCurMod, FALSE, ifrTCF))
    {
        DebugPrintEx(DEBUG_ERR,"ModemSendMode failed in SendTCF");
        return FALSE;
    }
    if(!SendZeros(pTG, uCount, TRUE))                    // Send TCF zeros
    {
        DebugPrintEx(DEBUG_ERR,"TCF SendZeroes(uCount=%d) FAILED!!!", uCount);
        return FALSE;
    }
    DebugPrintEx(DEBUG_MSG,"TCF Send Done.....");
    return TRUE;
#endif //MDDI2
}

/***************************************************************************
        Name      :     SendRTC
        Purpose   :     SendRTC sends 6 eols, DLE-ETX, CR-LF asynchronously,
        Parameters:     none
        Returns   :     nothing
        Comment   :     Currently SendRTC sends packed EOLs, but some Fax cards may
                                require BYTE-aligned EOLs, so watch out. All receivers
                                should theoretically accept BYTE-aligned EOLs, but not
                                all machines are 100% to the spec.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------

***************************************************************************/

BOOL SendRTC(PThrdGlbl pTG, BOOL fFinal)
{
    BYTE    bBuf[13];
    USHORT  uEnc, uLen;

    DEBUG_FUNCTION_NAME(_T("SendRTC"));

    uEnc = ProtGetSendEncoding(pTG);
    BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);

    if(uEnc == MR_DATA)
    {
        DebugPrintEx(DEBUG_MSG,"Send MR RTC");
    
        // MR RTC is EOL+1 6 times. Data produced by Faxcodec end in a
        // byte-aligned EOL i.e. 0x80. So I need to put out (1 + EOL)
        // 6 times. Simplest is to send out (0x01 0x80) 6 times
        // bBuf[0] = 0x01;      bBuf[1] = 0x80; bBuf[2] = 0x01; bBuf[3] = 0x80;
        // bBuf[4] = 0x01;      bBuf[5] = 0x80; bBuf[6] = 0x01; bBuf[7] = 0x80;
        // bBuf[8] = 0x01;      bBuf[9] = 0x80; bBuf[10]= 0x01; bBuf[11]= 0x80;
        // bBuf[12] = 0;        // for debugging printouts
        // uLen = 12;
        // But Ricoh claims this is incorrect, so we need to send a compact
        // RTC, i.e. exactly 11 0s for each EOL. 1 + (eol+1)x5 is
        // 01 30 00 06 C0 00 18 00 03
        bBuf[0] = 0x01; bBuf[1] = 0x30; bBuf[2] = 0x00; bBuf[3] = 0x06;
        bBuf[4] = 0xC0; bBuf[5] = 0x00; bBuf[6] = 0x18; bBuf[7] = 0x00;
        bBuf[8] = 0x03; bBuf[9] = 0x00;
        uLen = 9;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"Send MH RTC");

        // bBuf[0] = 0x00;      bBuf[1] = 0x20; bBuf[2] = 0x00;
        // bBuf[3] = 0x02;      bBuf[4] = 0x20; bBuf[5] = 0x00;
        // bBuf[6] = 0x02;      bBuf[7] = 0x20; bBuf[8] = 0x00;
        // bBuf[9] = 0x02;      bBuf[10] = 0;   // for debugging printouts
        // uLen = 10;
        // But Ricoh claims this is incorrect, so we need to send a compact
        // RTC, i.e. exactly 11 0s for each EOL. (eol)x5 is
        // 00 08 80 00 08 80 00 08
        bBuf[0] = 0x00; bBuf[1] = 0x08; bBuf[2] = 0x80; bBuf[3] = 0x00;
        bBuf[4] = 0x08; bBuf[5] = 0x80; bBuf[6] = 0x00; bBuf[7] = 0x08;
        bBuf[8] = 0x00;
        uLen = 8;
    }

    PSSLogEntryHex(PSS_MSG, 2, bBuf, uLen, "send: RTC, %d bytes,", uLen);
    // no need to stuff
    return ModemSendMem(pTG, pTG->Params.hModem, bBuf, uLen, (USHORT)(fFinal ? SEND_FINAL : 0));
}


/***************************************************************************
        Name      :     GetTCF()
        Purpose   :     Receive a TCF signal, analyse it, recognize "good" or "bad"
        Parameters:     none

        Returns   :     1 if a "good" signal is received.
                                0 on error
                                -1 if too short TCF signal
                                -2 if too many errors

        Comment   :     The CCITT does not tell us what consitutes a good training,
                                so I'm playing blind here. If we are too stringent we'll fail
                                to ever sync. If we are too liberal, we'll end up with a high
                                error rate when we could have dropped baud rate & got a
                                perfectly good signal.

                                Emperically I observe bits of contigous trash at the
                                beginning and end of the training even on a perfectly good
                                line. (OK, I now know this is known as the turn-on and
                                turn-off sequence. So what we have now is
                                <turnon trash><1111s><0000s (training)><1111s><turnoff trash>

                                The turnon/turnoff trash & the marks (1111s) should not
                                interfere with recognizing a perfectly good training signal.
                                The trash is isolated from the 00s by FFs

                                Algo: Wait for the first good burst of zeros, then count
                                zeros, and randomly interspersed non-zero (these represent
                                real noise errors).     Stop counting when we get a burst of FFs.
                                Now make sure teh zero burst is long enough & the "real"
                                error rate is not too high.

                                Lots of parameters here:-

                                        flP_ERROR == keep Prob(error) below this. Between 0 and 1
                                        uwZEROmin == how many zeros before we start counting
                                        uwTURNOFFmin == how much consecutive trash before we
                                                                        ignore rest

                                Tune these parameters after real testing with real lines!!!
                                (maybe a phone line simulator with a lil white noise -- Yeah!!)

                                At the end of this function, (nZeros/nTotal) is an estimate
                                of the probability that a byte gets thru OK. Call this PB.
                                Then prob. that a line of average 30-40 bytes gets through
                                is PB^30. If we drop the expected number of OK lines as low
                                as 80% this still means that PB must be no lower than
                                the 30th root of 0.8, which is 0.9925. Therefore
                                flP_ERROR must be less than 0.75%

                                At PL=90%, PB rises to 0.9965 and flP_ERROR to 0.0035


        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

// We read the TCF in units of One-Tenth of nominal TCF length
// We discard the first 2 chunks (20%), examine the next 4 chunks (40%)
// discard the rest. If the length is between 6 & 13 chunks (60% to 130%)
// and the error rates in chunk 2 & 3 is below the threshold we declare
// it OK. This (a) accepts too-short TCFs (some Class2 modems), and
// too long ones. (b) ignores leading and trailing trash (c) Can afford
// to be pretty strict with the core of the TCF

USHORT OneTenthTCFLen[16] =
{
/* V27_2400             0 */    45,
/* V29_9600             1 */    180,
/* V27_4800             2 */    90,
/* V29_7200             3 */    135,
/* V33_14400            4 */    270,
                                                0,
/* V33_12000            6 */    225,
                                                0,
/* V17_14400            8 */    270,
/* V17_9600             9 */    180,
/* V17_12000            10 */   225,
/* V17_7200             11 */   135,
                                                0,
                                                0,
                                                0,
                                                0
};

#define RECV_TCFBUFSIZE         270             // must be >= max chunk in above table
#define MIN_TCFLEN              4               // measured in 10ths of the nominal length
#define MAX_TCFLEN              13              // measured in 10ths of the nominal length
#define CHECKTCF_START          2               // lowest 10th to measure (20% and up)
#define CHECKTCF_STOP           5               // highest 10th to measure (upto 59%)

#define MAX_ERRS_PER_1000       20              // Increased from 1% to 2%. Be more lax

#define RECVBUF_SLACK    3      // Class1 driver fills only > 3, and leaves 3 empty spaces


SWORD GetTCF(PThrdGlbl pTG)
{
    USHORT  uCurMod, uChunkSize, uLength, uMeasuredLength, uErrCount;
    USHORT  uPhase, uNumRead, uEOF, i;
    BYTE    bRecvTCF[RECV_TCFBUFSIZE + RECVBUF_SLACK];
    SWORD   swRet;

    DEBUG_FUNCTION_NAME(_T("GetTCF"));

    // uCurMod = ProtGetRecvMod();
    uCurMod = pTG->T30.uRecvTCFMod;
    BG_CHK((uCurMod & (~0x0F)) == 0);

    // *Don't* add ST_FLAG since we need long training for TCF
    pTG->T30.sRecvBufSize = 0;

    // Need a CritSection for receiving TCF. Must call Exit on every path out of here
    EnterPageCrit();        // start the GetTCF critsection

    if(ModemRecvMode(pTG, pTG->Params.hModem, uCurMod, FALSE, TCF_TIMEOUT, ifrTCF) != RECV_OK)
    {
        ExitPageCrit(); // end the GetTCF critsection
        swRet=  -1112;
        goto missedit;
    }

    pTG->CommCache.fReuse = 1;


    ExitPageCrit(); // end the GetTCF critsection
    DebugPrintEx(DEBUG_MSG,"Receiving TCF: Mod=%d", uCurMod);

// make it large, in case of large buffers & slow modems
#define READ_TIMEOUT    10000

    uChunkSize = OneTenthTCFLen[uCurMod];
    BG_CHK(uChunkSize+RECVBUF_SLACK <= sizeof(bRecvTCF));
    uErrCount = 0;
    uLength = 0;
    uMeasuredLength = 0;
    for(uPhase=0; ;uPhase++)
    {
        // read a whole chunk
        for(uNumRead=0; uNumRead<uChunkSize; )
        {
            USHORT uTemp = 0;
            uEOF = ModemRecvMem(pTG, pTG->Params.hModem, bRecvTCF+uNumRead, (USHORT) (uChunkSize-uNumRead+RECVBUF_SLACK), READ_TIMEOUT, &uTemp);
            BG_CHK(uTemp <= (uChunkSize-uNumRead));
            uNumRead+=uTemp;

            if(uEOF==RECV_EOF)
            {
                break;
            }
            else if(uEOF != RECV_OK)
            {
                swRet =  -1113;
                goto missedit;
            }
        }
        BG_CHK(uEOF==RECV_EOF || (uEOF==RECV_OK && uNumRead==uChunkSize));

        // ignore phases 0, 1, and 6 and above
        if(uPhase>=CHECKTCF_START && uPhase<=CHECKTCF_STOP)
        {
            for(i=0; i< uNumRead; i++)
            {
                if(bRecvTCF[i])
                {
                    uErrCount++;
                }
                uMeasuredLength++;
            }
        }
        uLength += uNumRead;

        if(uEOF==RECV_EOF)
            break;
    }
    // comes here on EOF only
    BG_CHK(uEOF==RECV_EOF);

    PSSLogEntry(PSS_MSG, 2, "recv:     TCF: %d errors in %d signifact bytes of %d total bytes",
                uErrCount, uMeasuredLength, uLength);

    // Official length must be at least 1.5s -10% = 1.35secs
    // We allow much more latitude because length variation
    // cannot be caused by line noise, only be bugs at the sender
    //
    // E.g. Fury DNE 1086 (German modem) sends a TCF that's too short
    // (sends 600 bytes at 4800 and 200 at 2400). This is less than
    // half of what we expect.
    // TCF with few errs (i.e. uErrCount==0) and is greater
    // that half of the min length we expect (i.e. longer
    // than 375 for 4800 and 172 for 2400) then accept it
    // (allow if uErr<=2 (arbitary small number))
    if(uPhase<MIN_TCFLEN || uPhase>MAX_TCFLEN)      // length<40% or >139%
    {
        DebugPrintEx(   DEBUG_ERR,
                        "BAD TCF length (%d), expected=%d, Min=%d Max=%d uPhase=%d",
                        uLength,
                        uChunkSize*10,
                        uChunkSize*MIN_TCFLEN, 
                        uChunkSize*MAX_TCFLEN, 
                        uPhase);
        swRet = -1000;  // too short or long
    }
    else
    {
            // Calc errors per 1000 = (uErrCount * 1000)/uMeasuredLength
            BG_CHK(uMeasuredLength);
            swRet = (SWORD)((((DWORD)uErrCount) * 1000L) / ((DWORD)uMeasuredLength));

            if(swRet > MAX_ERRS_PER_1000)
            {
                swRet = (-swRet);
                DebugPrintEx(   DEBUG_ERR,
                                "TOO MANY TCF ERRORS: swRet=%d uErrCount=%d uMeasured=%d"
                                " uLength=%d uPhase=%d",
                                swRet,
                                uErrCount, 
                                uMeasuredLength, 
                                uLength, 
                                uPhase);
            }
    }

    BG_CHK(swRet >= -1000);
    DebugPrintEx(DEBUG_MSG,"returning %d", swRet);
    return swRet;

missedit:
    DebugPrintEx(DEBUG_MSG,"MISSED IT!! returning %d", swRet);
    return swRet;
}

/***************************************************************************
        Name      :     DEBUG.C
        Comment   :     Factored out debug code
        Functions :     (see Prototypes just below)

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/

#ifdef DEBUG

#define PRINTFRAMEBUFSIZE       256

void D_PrintFrame(LPB lpb, UWORD cb)
{
    UWORD   uw, j;
    IFR             ifr;
    BYTE    b2[PRINTFRAMEBUFSIZE];

    DEBUG_FUNCTION_NAME(_T("D_PrintFrame"));

    for(ifr=1; ifr<ifrMAX; ifr++)
    {
        if(rgFrameInfo[ifr].bFCF1 ==(BYTE)(rgFrameInfo[ifr].fInsertDISBit ?
                  (lpb[2] & 0xFE) : lpb[2]))
                                break;
    }
    if(ifr == ifrMAX) ifr = 0;

    j = (UWORD)wsprintf((LPSTR)b2, "(%s) 0x%02x (", (LPSTR)(rgFrameInfo[ifr].szName), lpb[2]);

    for(uw=0; uw<cb;)
    {
        j += (UWORD)wsprintf((LPSTR)b2+j, "%02x ", (UWORD)lpb[uw++]);
    }

    j += (UWORD)wsprintf((LPSTR)b2+j, ")");

    DebugPrintEx(DEBUG_MSG,"%s", (LPSTR)b2);
}

#endif


USHORT ModemRecvBuf(PThrdGlbl pTG, HMODEM hModem, BOOL fECM, LPBUFFER far* lplpbf, ULONG ulTimeout)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME(_T("ModemRecvBuf"));

    BG_CHK(lplpbf);
    BG_CHK(pTG->T30.sRecvBufSize);
#ifdef IFK
    TstartTimeOut(pTG,  &pTG->T30.toBuf, WAITFORBUF_TIMEOUT);
    while(!(*lplpbf = MyAllocBuf(pTG, pTG->T30.sRecvBufSize)))
    {
        if(!TcheckTimeOut(pTG, &pTG->T30.toBuf))
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Giving up on BufAlloc in T30 after %ld millisecs",
                            (ULONG)WAITFORBUF_TIMEOUT);
            BG_CHK(FALSE);
            return RECV_ERROR;
        }
        DebugPrintEx(DEBUG_ERR,"BufAlloc failed in T30. Trying again");
        IFProcSleep(100);
    }
#else
    if(!(*lplpbf = MyAllocBuf(pTG, pTG->T30.sRecvBufSize)))
        return RECV_ERROR;
#endif

    DebugPrintEx(   DEBUG_MSG,
                    "In ModemRecvBuf allocated %d bytes",
                    pTG->T30.sRecvBufSize);


#ifdef SWECM
    if(fECM)
        uRet = SWECMRecvFrame(pTG, hModem, (*lplpbf)->lpbBegBuf,
                        (*lplpbf)->wLengthBuf, ulTimeout, &((*lplpbf)->wLengthData));
    else
#endif
        uRet = ModemRecvMem(pTG, hModem, (*lplpbf)->lpbBegBuf,
                        (*lplpbf)->wLengthBuf, ulTimeout, &((*lplpbf)->wLengthData));


    if(!((*lplpbf)->wLengthData))
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Got 0 bytes from ModemRecvMem--freeing Buf 0x%08lx",
                        *lplpbf);
        MyFreeBuf(pTG, *lplpbf);
        *lplpbf = NULL;
        BG_CHK(uRet != RECV_OK);
        // moved this error case handling out, since it's different for
        // ECM and non-ECM cases. In both cases want to ignore rather than
        // abort, so RECV_ERROR is not an appropriate return value
        // if(uRet==RECV_OK) uRet=RECV_ERROR;   // just in case. see bug#1492
    }

    if(*lplpbf)
    {
        DebugPrintEx(   DEBUG_MSG,
                        "Ex lpbf=%08lx uSize=%d uCount=%d uRet=%d",
                        *lplpbf, 
                        (*lplpbf)->wLengthBuf, 
                        (*lplpbf)->wLengthData, 
                        uRet);
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"Ex lpbf=null uRet=%d", uRet);
    }

    return uRet;
}

#ifdef PDUMP    // Protocol Dump

#include <protdump.h>



void RestartDump(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("RestartDump"));

    DebugPrintEx(   DEBUG_MSG,
                    "Restart Dump old=%d off=%d", 
                    pTG->fsDump.uNumFrames, 
                    pTG->fsDump.uFreeSpaceOff);
    pTG->fsDump.uNumFrames = 0;
    pTG->fsDump.uFreeSpaceOff = 0;
}


void DumpFrame(PThrdGlbl pTG, BOOL     fSend, IFR ifr, USHORT cbFIF, LPBYTE lpbFIF)
{
    LPFR lpfr;

    DEBUG_FUNCTION_NAME(_T("DumpFrame"));

    if( pTG->fsDump.uNumFrames >= MAXDUMPFRAMES ||
            pTG->fsDump.uFreeSpaceOff+cbFIF+sizeof(FRBASE) >= MAXDUMPSPACE)
    {
        DebugPrintEx(   DEBUG_WRN,
                        "Out of dump space num=%d size=%d",
                        pTG->fsDump.uNumFrames, 
                        pTG->fsDump.uFreeSpaceOff);
        return;
    }

    lpfr = (LPFR) (((LPBYTE)(pTG->fsDump.b)) + pTG->fsDump.uFreeSpaceOff);
    lpfr->ifr = ifr;
    if(fSend) lpfr->ifr |= 0x80;
    lpfr->cb = (BYTE) cbFIF;
    if(cbFIF)
    {
        _fmemcpy(lpfr->fif, lpbFIF, cbFIF);
    }

    pTG->fsDump.uFrameOff[pTG->fsDump.uNumFrames++] =
        (USHORT)((((LPBYTE)(lpfr)) - ((LPBYTE)(pTG->fsDump.b))));
    pTG->fsDump.uFreeSpaceOff += (cbFIF + sizeof(FRBASE));

    BG_CHK(pTG->fsDump.uNumFrames <= MAXDUMPFRAMES);
    BG_CHK(pTG->fsDump.uFreeSpaceOff <= MAXDUMPSPACE);
}



void PrintDump(PThrdGlbl pTG)
{
    int i, j;
    char szBuf[1000] = {0};

    DEBUG_FUNCTION_NAME(_T("PrintDump"));
    DebugPrintEx(   DEBUG_MSG,
                    "-*-*-*-*-*-*-*-* Print Protocol Dump -*-*-*-*-*-*-*-*-");

    for(i=0; i<(int)pTG->fsDump.uNumFrames; i++)
    {
        LPFR lpfr = (LPFR) (((LPBYTE)(pTG->fsDump.b)) + pTG->fsDump.uFrameOff[i]);
        IFR  ifr = (lpfr->ifr & 0x7F);
        BOOL fSend = (lpfr->ifr & 0x80);

        BG_CHK(ifr <= ifrMAX);
        DebugPrintEx(   DEBUG_MSG,
                        "%s: %s",
                        (LPSTR)(fSend ? "Sent" : "Recvd"),
                        (LPSTR)(ifr ? rgFrameInfo[ifr].szName : "???") );

        for(j=0; j<min(lpfr->cb,1000); j++)
                _stprintf(szBuf,"%02x ", (WORD)lpfr->fif[j]);

        DebugPrintEx(DEBUG_MSG, "(%s)",szBuf);
    }

    DebugPrintEx(DEBUG_MSG,
                "-*-*-*-*-*-*-*-* End Protocol Dump -*-*-*-*-*-*-*-*-");
}

#endif //PDUMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\errstat.c ===
/***************************************************************************
 Name     :     ERRSTAT.C
 Comment  :     Error logging and Status msgs

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "glbproto.h"
#include "t30gl.h"

#ifdef FAXWATCH
        char    szFailureLog[]          = "FAXWATCH.LOG";
        // sneaky look at BGT30's private data
#       ifndef TSK
                extern char szPhone[];
#       endif //TSK
#endif //FAXWATCH


// Currently in WIN32, logging (IFDbgPrintf) is provided by efaxrun.dll. This
// should later migrate to awkrnl32.dll.
struct {
        HFILE hfLog;
        BOOL  fInited;
        CRITICAL_SECTION crit;
} gLog = {HFILE_ERROR, FALSE};











void   ICommFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail)
{
        SetFailureCode(pTG, uT30Fail);

}




void SetFailureCode(PThrdGlbl pTG, T30FAILURECODE uT30Fail)
{
        if(!pTG->Inst.uFirstFailureCode)
                pTG->Inst.uFirstFailureCode = (USHORT)uT30Fail;
        else
                pTG->Inst.uLastFailureCode = (USHORT)uT30Fail;
}










void InitFailureCodes(PThrdGlbl pTG)
{
        pTG->Inst.uFirstFailureCode = pTG->Inst.uLastFailureCode = 0;
}





void   ICommStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3)
{

//        SetStatus(uT30Stat, uN1, uN2, uN3);

}






void SetStatus(PThrdGlbl pTG, T30STATUS uT30Stat, USHORT uN1, USHORT uN2, USHORT uN3)
{
#if 0 ///RSL   was ifdef STATUS
        ULONG lParam;

        BG_CHK((uT30Stat & 0xFF) == uT30Stat);
        BG_CHK((uN1 & 0xFF) == uN1);
        // when N2==Kbytes recvd this goes over 256K sometimes & so rolls
        // around to 0 again.
        // BG_CHK((uN2 & 0xFF) == uN2);
        BG_CHK((uN3 & 0xFF) == uN3);

        lParam = MAKELONG(MAKEWORD(uT30Stat, uN1), MAKEWORD(uN2, uN3));
        if(Inst.fSending || Inst.fInPollReq)
        {
                BG_CHK(Inst.hwndSend && Inst.aPhone);
                PostMessage(Inst.hwndSend, IF_FILET30_STATUS, Inst.aPhone, lParam);
        }
        else if(Inst.hwndStatus)
        {
                PostMessage(Inst.hwndStatus, IF_FILET30_STATUS, 0, lParam);
        }
#endif //STATUS
}




/*
 * MyIFDbgPrintf -- printf to the debugger console
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
void MyIFDbgPrintf (LPSTR format, ...)
{
    va_list       marker;
    char          String[512];
    char          c;
    UINT          i;
    UINT          u;
    DWORD         dwWritten;


    if ( (gT30.DbgLevel < LOG_ALL ) || (! gfFilePrint) ) {
        return;
    }

    u = 0;

    va_start(marker, format);
    u += wvsprintf(String+u, format, marker);



    //WriteFile(ghLogFile, String, u, &dwWritten, NULL);

/*
    // until I remove it completely
    {
        LPCTSTR faxDbgFunction="MyDebugPrint";
        String[strlen(String)-1] = 0;
        DebugPrintEx(DEBUG_MSG,"%s",String);
    }
*/

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\negot.c ===
/***************************************************************************
 Name     :     NEGOT.C
 Comment  :     Capability handling and negotiation

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"


#include "protocol.h"

#include "glbproto.h"

BOOL     glLoRes=0;  // Simulate LoRes from Remote when TX


#       define INST_ENCODING    pTG->Inst.awfi.Encoding
#       define INST_VSECURITY   pTG->Inst.awfi.vSecurity
#       define INST_RESOLUTION  pTG->Inst.awfi.AwRes
#       define INST_PAGEWIDTH   pTG->Inst.awfi.PageWidth
#       define INST_PAGELENGTH  pTG->Inst.awfi.PageLength



//////// Move these hardcoded values to an INI file ////////

#define CAPS_WIDTH              WIDTH_A4
#define ENCODE_CAPS             (MH_DATA | MR_DATA )  // RSL | MMR_DATA)

// Current suppored linearized verson +++ (change to vMSG_IFAX100 when we
//                      have enabled Linearized published images).
#define vMSG_WIN95              vMSG_IFAX100 // vMSG_SNOW

//#  define CAPS_RES 0

//#if 0
#ifdef DPI_400
#  define CAPS_RES  (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_200_200 | AWRES_300_300 | AWRES_mm080_154 | AWRES_160_154 | AWRES_400_400)
#else
#  define CAPS_RES  (AWRES_mm080_038 | AWRES_mm080_077 | AWRES_200_200 | AWRES_300_300)
#endif
//#endif



/********* These are the Ricoh thresholds--they're too simplistic *****
USHORT MaxBadLines[4][4] =
{
        {110, 220, 330, 440 },          // CheckLevel=1    10%
        { 82, 165, 248, 330 },          // CheckLevel=2    7.5%
        { 55, 110, 165, 220 },          // CheckLevel=3    5%
        { 27,  55,  83, 110 }           // CheckLevel=4    2.5%
};

USHORT MaxConsecBad[4][4] =
{
        { 6, 12, 18, 24 },                      // CheckLevel=1
        { 5, 10, 15, 20 },                      // CheckLevel=2
        { 4,  8, 12, 16 },                      // CheckLevel=3
        { 3,  6,  9, 12 }                       // CheckLevel=4
};
*****************/

////////////////////////////////////////////////////////////////
// Don't delete this -- these were my thresholds _before_ I talked to Ricoh
////////
// higher thresholds, tapering off, because
// at higher resolutions we want cleaner copy.
// USHORT MaxBadLines[4] = { 33, 66, 84, 99 }; // 3.5, 3, 2.5, 2.25 %bad
// USHORT MaxConsecBad[4] = { 5, 9, 12, 15 };    // 2/3rd of a 10pt char is 9,18,27,36 lines
////////////////////////////////////////////////////////////////

USHORT MaxBadLines[4][4] =
{
        { 77, 132, 165, 198 },  // CheckLevel=1  7, 6, 5, 4.5% bad
        { 58,  99, 124, 149 },  // CheckLevel=2  5.25, 4.5, 3.75, 3.375% bad
        { 39,  66,  83, 99 },   // CheckLevel=3  3.5, 3, 2.5, 2.25% bad
        { 19,  33,  41, 50 }    // CheckLevel=4  1.75, 1.5, 1.25, 1.125% bad
};

USHORT MaxConsecBad[4][4] =
{
        { 7, 13, 18, 23 },              // CheckLevel=1
        { 6, 11, 15, 19 },              // CheckLevel=2
        { 5,  9, 12, 15 },              // CheckLevel=3
        { 4,  7,  9, 11 }               // CheckLevel=4
};


        // lBad = DWORD with max. consecutive badlines in low word
        //                      and total number of bad lines in high word.
        // res==resolution (using ENCODE_ values)
        // i = vertical res index into table above (0=100, 1=200, 2=300 3=400)


/** Widths in pixels must be exactly correct for MH decoding to work.
        the width above are for NORMAL, FINE, 200dpi and SUPER resolutions.
        At 400dpi or SUPER_SUPER exactly twice as amny pixels must be supplied
        and at 300dpi exactly 1.5 times.

                                        A4                      B4                      A3
                200             1728/216        2048/256        2432/304
                300             2592/324        3072/384        3648/456
                400             3456/432        4096/512        4864/608
**/

// first index is 200/300/400dpi horiz res (inch or mm based)
// second index is width A4/B4/A3

USHORT ResWidthToBytes[3][3] =
{
        { 216, 256, 304 },
        { 324, 384, 456 },
        { 432, 512, 608 }
};

BYTE BestEncoding[8] =
{
        0,      // none (error)
        1,      // MH only
        2,      // MR only
        2,      // MR & MH
        4,      // MMR only
        4,      // MMR & MH
        4,      // MMR & MR
        4       // MMR & MR & MH
};

#define  SEND_RECODE_TO     INST_ENCODING


BOOL NegotiateCaps(PThrdGlbl pTG)
{
    USHORT Res;

    DEBUG_FUNCTION_NAME(_T("NegotiateCaps"));
    if (glLoRes) 
    {
        pTG->Inst.RemoteRecvCaps.Fax.AwRes = 0;
    }

    memset(&pTG->Inst.SendParams, 0, sizeof(pTG->Inst.SendParams));
    pTG->Inst.SendParams.bctype = SEND_PARAMS;
    // They should be set. This code here is correct--arulm
    // +++ Following three are not set in pcfax11
    pTG->Inst.SendParams.wBCSize = sizeof(BC);
    pTG->Inst.SendParams.wBCVer = VER_AWFXPROT100;
    pTG->Inst.SendParams.wTotalSize = sizeof(BC);

    // +++ Initialize ID from our own SendCaps...
    {
        char rgchID[MAXFHBIDLEN+2];
        GetTextId(&pTG->Inst.SendCaps, rgchID, MAXFHBIDLEN+1);
        PutTextId((LPBC)&pTG->Inst.SendParams, sizeof(pTG->Inst.SendParams),
                                rgchID, _fstrlen(rgchID), TEXTCODE_ASCII);
    }

    // RSL this should be set from fax UI??
    ////////////////////////////////////////////

    pTG->Inst.awfi.Encoding = ENCODE_CAPS;  // MR_DATA | MH_DATA;
    if (! pTG->SrcHiRes) 
    {
        pTG->Inst.awfi.AwRes = 0;
    }
    else 
    {
        pTG->Inst.awfi.AwRes = CAPS_RES;  // AWRES_200_200;
    }


////////////// Width, Length, Res & Enc /////////////////////////////


    /////// Encoding ///////

    BG_CHK(pTG->Inst.RemoteRecvCaps.Fax.Encoding && pTG->Inst.RemoteRecvCaps.Fax.Encoding < 8);
    // this next BG_CHK seems bogus...?
    // BG_CHK(pTG->Inst.ProtParams.fDisableECM ? (!(pTG->Inst.RemoteRecvCaps.Fax.Encoding & MMR_DATA)) : 1);

    BG_CHK(INST_ENCODING && INST_ENCODING < 8);
    BG_CHK(BestEncoding[INST_ENCODING] == INST_ENCODING); // check just 1 bit set

    // If pTG->Inst.fDisableG3ECM, we will refuse to send MMR
    if (pTG->Inst.fDisableG3ECM && (pTG->Inst.RemoteRecvCaps.Fax.Encoding & MMR_DATA))
    {
        DebugPrintEx(DEBUG_WRN,"fDisableG3ECM => NOT using MMR");
        pTG->Inst.RemoteRecvCaps.Fax.Encoding &= ~MMR_DATA;
    }

    if(!(pTG->Inst.SendParams.Fax.Encoding =
                    BestEncoding[(INST_ENCODING | SEND_RECODE_TO) &
                            pTG->Inst.RemoteRecvCaps.Fax.Encoding]))
    {
        // No matching Encoding not supported
        DebugPrintEx(   DEBUG_ERR,
                        "Negotiation failed: SendEnc %d CanRecodeTo %d"
                        " RecvCapsEnc %d. No match",
                        INST_ENCODING, 
                        SEND_RECODE_TO, 
                        pTG->Inst.RemoteRecvCaps.Fax.Encoding);
        SetFailureCode(pTG, T30FAILS_NEGOT_ENCODING);
        goto error;
    }

    // check just 1 bit set
    BG_CHK(BestEncoding[pTG->Inst.SendParams.Fax.Encoding]  ==
                     pTG->Inst.SendParams.Fax.Encoding);
    BG_CHK(pTG->Inst.SendParams.Fax.Encoding == INST_ENCODING);

    /////// Width ///////

    pTG->Inst.RemoteRecvCaps.Fax.PageWidth &= 0x0F;      // castrate all A5/A6 widths
    if(INST_PAGEWIDTH > 0x0F)
    {
        // A5 or A6. Can quit or send as A4
        // INST_PAGEWIDTH = WIDTH_A4;
        DebugPrintEx(DEBUG_ERR,"Negotiation failed: A5/A6 images not supported");
        SetFailureCode(pTG, T30FAILS_NEGOT_A5A6);
        goto error;
    }

    if(pTG->Inst.RemoteRecvCaps.Fax.PageWidth < INST_PAGEWIDTH)
    {
        // or do some scaling
        DebugPrintEx(DEBUG_ERR,"Negotiation failed: Image too wide");
        SetFailureCode(pTG, T30FAILS_NEGOT_WIDTH);
        goto error;
    }
    else
    {
        pTG->Inst.SendParams.Fax.PageWidth = INST_PAGEWIDTH;
    }

    /////// Length ///////

    if(pTG->Inst.RemoteRecvCaps.Fax.PageLength < INST_PAGELENGTH)
    {
        DebugPrintEx(DEBUG_ERR,"Negotiation failed: Image too long");
        SetFailureCode(pTG, T30FAILS_NEGOT_LENGTH);
        goto error;
    }
    else
    {
        pTG->Inst.SendParams.Fax.PageLength = INST_PAGELENGTH;
    }

    /////// Res ///////

    // pick best resolution
    pTG->Inst.HorizScaling = 0;
    pTG->Inst.VertScaling = 0;

    // test scaling to NORMAL
    // pTG->Inst.RemoteRecvCaps.Fax.AwRes = AWRES_mm080_038;

    Res = (USHORT) (INST_RESOLUTION & pTG->Inst.RemoteRecvCaps.Fax.AwRes);
    if(Res) // send native
    {
        pTG->Inst.SendParams.Fax.AwRes = Res;
    }
    else
    {
        BG_CHK(INST_RESOLUTION != AWRES_mm080_038);
        BG_CHK(pTG->Inst.RemoteRecvCaps.Fax.AwRes & AWRES_mm080_038);

        switch(INST_RESOLUTION)
        {
        case AWRES_mm160_154:
                if(AWRES_400_400 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_400_400;
                }
                else
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "Negotiation failed: 16x15.4 image and"
                                    " no horiz scaling");
                    SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                    goto error;
                }
                break;

        case AWRES_mm080_154:
#ifdef VS
                if(pTG->Inst.SendParams.Fax.Encoding == MMR_DATA)
#endif //VS
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "Negotiation failed: 8x15.4 image and"
                                    " no vert scaling");
                    SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                    goto error;
                }
#ifdef VS
                if(AWRES_mm080_077 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_077;
                    pTG->Inst.VertScaling = 2;
                }
                else if(AWRES_200_200 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_200_200;
                    pTG->Inst.VertScaling = 2;
                }
                else
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_038;
                    pTG->Inst.VertScaling = 4;
                }
#endif //VS
                break;

        case AWRES_mm080_077:
                if(AWRES_200_200 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_200_200;
                }
#ifdef VS
                else if(pTG->Inst.SendParams.Fax.Encoding == MMR_DATA)
#else //VS
                else
#endif //VS
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "Negotiation failed: 8x7.7 image and"
                                    " no vert scaling");
                    SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                    goto error;
                }
#ifdef VS
                else
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_038;
                    pTG->Inst.VertScaling = 2;
                }
#endif //VS
                break;

        case AWRES_400_400:
                if(AWRES_mm160_154 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_mm160_154;
                }
                else
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "Negotiation failed: 400dpi image and"
                                    " no horiz scaling");
                    SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                    goto error;
                }
                break;

        case AWRES_300_300:
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "Negotiation failed: 300dpi image and"
                                    " no non-integer scaling");
                    SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                    goto error;
                }
                break;

        case AWRES_200_200:
                if(AWRES_mm080_077 & pTG->Inst.RemoteRecvCaps.Fax.AwRes)
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_077;
                }
#ifdef VS
                else if(pTG->Inst.SendParams.Fax.Encoding == MMR_DATA)
#else //VS
                else
#endif //VS
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "Negotiation failed: 200dpi image and"
                                    " no vert scaling");
                    SetFailureCode(pTG, T30FAILS_NEGOT_RES);
                    goto error;
                }
#ifdef VS
                else
                {
                    pTG->Inst.SendParams.Fax.AwRes = AWRES_mm080_038;
                    pTG->Inst.VertScaling = 2;
                }
#endif //VS
                break;

        default:
                BG_CHK(FALSE);
        }
    }

#ifdef VS
    if(pTG->Inst.VertScaling)
    {
        BG_CHK(pTG->Inst.SendParams.Fax.Encoding != MMR_DATA);
        //RSL InitVertScale(pTG->Inst.VertScaling);
    }
#endif //VS


    DebugPrintEx(   DEBUG_MSG,
                    "Negotiation Succeeded: Res=%d PageWidth=%d Len=%d"
                    " Enc=%d HSc=%d VSc=%d HSc3=%d VSc3=%d",
                    pTG->Inst.SendParams.Fax.AwRes, 
                    pTG->Inst.SendParams.Fax.PageWidth, 
                    pTG->Inst.SendParams.Fax.PageLength,
                    pTG->Inst.SendParams.Fax.Encoding, 
                    pTG->Inst.HorizScaling, 
                    pTG->Inst.VertScaling,
                    pTG->Inst.HorizScaling300dpi, 
                    pTG->Inst.VertScaling300dpi);
    return TRUE;


error:
        return FALSE;
}


void InitCapsBC(PThrdGlbl pTG, LPBC lpbc, USHORT uSize, BCTYPE bctype)
{

    DEBUG_FUNCTION_NAME(_T("InitCapsBC"));

    memset(lpbc, 0, uSize);
    lpbc->bctype = bctype;
    // They should be set. This code here is correct--arulm
    // +++ Following three lines are not in pcfax11
    lpbc->wBCSize = sizeof(BC);
    lpbc->wBCVer = VER_AWFXPROT100;
    lpbc->wTotalSize = sizeof(BC);

    lpbc->Std.GroupNum              = GROUPNUM_STD;
    lpbc->Std.GroupLength   = sizeof(BCSTD);
    lpbc->Std.vMsgProtocol  = vMSG_WIN95;
    lpbc->Std.fBinaryData   = TRUE;
//      lpbc->Std.fInwardRouting        = FALSE;

    // NOSECURITY is defined for France build etc.
    lpbc->Std.vSecurity             = 0;

    lpbc->Std.OperatingSys  = OS_WIN16;
//      lpbc->Std.vShortFlags   = 0;
//      lpbc->Std.vInteractive  = 0;
//      lpbc->Std.DataSpeed             = 0;
//      lpbc->Std.DataLink              = 0;


//      lpbc->Fax.fPublicPoll = 0;
    if (! pTG->SrcHiRes) 
    {
        lpbc->Fax.AwRes = 0;
    }
    else 
    {
        lpbc->Fax.AwRes = CAPS_RES;
    }

    lpbc->Fax.Encoding      = ENCODE_CAPS;

    if (0) // RSL (pTG->Inst.fDisableMRRecv)
    {
        DebugPrintEx(DEBUG_WRN,"Disabling MR Receive capability");
        lpbc->Fax.Encoding      &= ~MR_DATA;
    }
    lpbc->Fax.PageWidth     = CAPS_WIDTH;           // can be upto A3
    lpbc->Fax.PageLength    = LENGTH_UNLIMITED;

    lpbc->Image.GroupNum            = GROUPNUM_IMAGE;
    lpbc->Image.GroupLength = sizeof(BCIMAGE);
    lpbc->Image.vRamboVer           = vRAMBO_VER1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\ecm.c ===
/***************************************************************************
 Name     :     ECM.C
 Comment  :     Contains the ECM T30 routines
 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"
#include "debug.h"

///RSL
#include "glbproto.h"

typedef enum
{
        ECMRECVOK_OK,
        ECMRECVOK_BADFR,
        ECMRECVOK_ABORT
}
ECMRECVOK;

/****************** begin prototypes from ecm.c *****************/
IFR RNR_RRLoop(PThrdGlbl pTG);
IFR CTC_RespRecvd(PThrdGlbl pTG, USHORT uBaud);
BOOL Recv_NotReadyLoop(PThrdGlbl pTG, IFR ifrFirst, IFR ifrLast);
BOOL FillInFrames(PThrdGlbl pTG, USHORT N, LONG sBufSize, USHORT uDataSize);
ECMRECVOK ECMRecvOK(PThrdGlbl pTG);
/***************** end of prototypes from ecm.c *****************/

BYTE RCP[3] = { 0xFF, 0x03, 0x86 };


ET30ACTION ECMPhaseC(PThrdGlbl pTG, BOOL fReTx)
{
    USHORT          uFrameNum, uFramesSent, uLim;
    SWORD           swRet;
    ULONG           lTotalLen=0;
    LPBYTE          lpPPRMask;
    LPBUFFER        lpbf=0;
    USHORT          uMod;

    /******** Transmitter ECM Phase C. Fig A-7/T.30 (sheet 1) ********/

    DEBUG_FUNCTION_NAME(_T("ECMPhaseC"));

    pTG->ECM.uFrameSize = ProtGetECMFrameSize(pTG);
    BG_CHK(pTG->ECM.uFrameSize==6 || pTG->ECM.uFrameSize==8);

    // already done in WhatNext
    // uSize = (1 << pTG->ECM.uFrameSize);
    // ICommSetSendMode(TRUE, uSize+ECM_EXTRA, uSize, TRUE);

    if(fReTx)
    {
        lpPPRMask = ProtGetRetransmitMask(pTG);
    }
    else
    {
        pTG->ECM.uPPRCount = 0;

        if(pTG->ECM.fEndOfPage)
        {
            pTG->ECM.SendPageCount++;
            pTG->ECM.SendBlockCount = 1;
            pTG->ECM.dwPageSize=0;

            DebugPrintEx(DEBUG_MSG,"Waiting for Startpage in ECM");

            // Callback to open file to send. Doesn't return any data
            if((swRet=GetSendBuf(pTG, 0, SEND_STARTPAGE)) != SEND_OK)
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Nonzero return %d from SendProc at Start Page",
                                swRet);
                // return actionDCN;
                return actionERROR;
            }

            DebugPrintEx(DEBUG_MSG,"Got Startpage in ECM");
        }
        else
        {
            pTG->ECM.SendBlockCount++;

            DebugPrintEx(DEBUG_MSG,"Waiting for Startblock");

            // Callback to open file to send. Doesn't return any data
            if((swRet=GetSendBuf(pTG, 0, SEND_STARTBLOCK)) != SEND_OK)
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Nonzero return %d from SendProc at Start Page",
                                swRet);
                // return actionDCN;
                return actionERROR;
            }

            DebugPrintEx(DEBUG_MSG,"Got Startblock in ECM");
        }
    }

    DebugPrintEx(   DEBUG_MSG,
                    "Starting ECM Partial Page SEND.......P=%d B=%d ReTx=%d",
                    pTG->ECM.SendPageCount, pTG->ECM.SendBlockCount, fReTx);
    if(fReTx)
    {
        ICommStatus(pTG, T30STATS_RESEND_ECM, pTG->ECM.SendPageCount, 0, pTG->ECM.SendBlockCount);
    }

    uMod = ProtGetSendMod(pTG);
    if(uMod >= V17_START && !pTG->ECM.fSentCTC)
        uMod |= ST_FLAG;

    pTG->ECM.fSentCTC = FALSE;

    // here we should use a small timeout (100ms?) and if it fails,
    // should go back to sending the previous V21 frame (which could be DCS
    // or MPS or whatever, which is why it gets complicated & we havn't
    // done it!). Meanwhile use a long timeout, ignore return value
    // and send anyway.

    if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_PHASEC_PAUSE, LONG_RECVSILENCE_TIMEOUT))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "ECM Pix RecvSilence(%d, %d) FAILED!!!",
                        RECV_PHASEC_PAUSE, LONG_RECVSILENCE_TIMEOUT);
    }

    if(!ModemSendMode(pTG, pTG->Params.hModem, uMod, TRUE, ifrECMPIX))
    {
        DebugPrintEx(DEBUG_ERR,"ModemSendMode failed in Tx ECM PhaseC");
        ICommFailureCode(pTG, T30FAILSE_SENDMODE_PHASEC);
        BG_CHK(FALSE);
        return actionERROR;
    }

#ifdef IFAX
    BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, (PSIFAX_SEND|PSIFAX_ECM|(fReTx ? PSIFAX_RESEND : 0)), (uMod & (~ST_FLAG)));
#endif
    DebugPrintEx(DEBUG_MSG,"SENDING ECM Page Data.....");
    FComCriticalNeg(pTG, FALSE);

    uLim = (fReTx ? pTG->ECM.SendFrameCount : 256);
    BG_CHK(uLim);
    BG_CHK(lpbf == 0);

    for(uFrameNum=0, uFramesSent=0, lTotalLen=0, swRet=0; uFrameNum<uLim; uFrameNum++)
    {
        if(!fReTx || (lpPPRMask[uFrameNum/8] & (1 << (uFrameNum%8))))
        {
            BG_CHK(uFrameNum < 256 && pTG->ECM.uFrameSize <=8);  // shift below won't ovf 16 bits
            BG_CHK(lpbf == 0);
            swRet = GetSendBuf(pTG, &lpbf, (fReTx ? ((SLONG)(uFrameNum << pTG->ECM.uFrameSize)) : SEND_SEQ));

            if(swRet == SEND_ERROR)
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Error return from SendProc in ECM retransmit");
                BG_CHK(lpbf == 0);
                // return actionDCN;    // goto NodeC;
                return actionERROR;
            }
            else if(swRet == SEND_EOF)
            {
                BG_CHK(lpbf == 0);
                if(!fReTx)
                    break;
                else
                {
                    BG_CHK(FALSE);
                    ICommFailureCode(pTG, T30FAILSE_PHASEC_RETX_EOF);
                    return actionDCN;
                }
            }
            BG_CHK(swRet == SEND_OK);

            BG_CHK(lpbf);
            BG_CHK(lpbf->lpbBegBuf+4 == lpbf->lpbBegData);

            lpbf->lpbBegBuf[0] = 0xFF;
            lpbf->lpbBegBuf[1] = 0x03;
            lpbf->lpbBegBuf[2] = 0x06;
            lpbf->lpbBegBuf[3] = (BYTE) uFrameNum;
            lpbf->lpbBegData -= 4;
            lpbf->wLengthData += 4;

            lTotalLen += lpbf->wLengthData;

            if(!ModemSendMem(pTG, pTG->Params.hModem, lpbf->lpbBegData, lpbf->wLengthData, SEND_ENDFRAME))
            {
                DebugPrintEx(DEBUG_ERR,"DataWrite Timeout in ECM Phase C");
                ICommFailureCode(pTG, T30FAILSE_MODEMSEND_PHASEC);
                BG_CHK(FALSE);
                return actionERROR;             // goto error;
            }

            if(!MyFreeBuf(pTG, lpbf))
            {
                DebugPrintEx(DEBUG_ERR,"FReeBuf failed in ECM Phase C");
                ICommFailureCode(pTG, T30FAILSE_FREEBUF_PHASEC);
                BG_CHK(FALSE);
                return actionERROR;             // goto error;
            }
            lpbf = 0;
            uFramesSent++;
        }
    }

    if( !ModemSendMem(pTG, pTG->Params.hModem, RCP, 3, SEND_ENDFRAME) ||
        !ModemSendMem(pTG, pTG->Params.hModem, RCP, 3, SEND_ENDFRAME) ||
        !ModemSendMem(pTG, pTG->Params.hModem, RCP, 3, SEND_ENDFRAME|SEND_FINAL))
    {
            DebugPrintEx(DEBUG_ERR,"DataWrite Timeout on RCPs");
            ICommFailureCode(pTG, T30FAILSE_MODEMSEND_ENDPHASEC);
            BG_CHK(FALSE);
            return actionERROR;             // goto error;
    }
/***
    if(!ModemDrain())
            return FALSE;
***/

    FComCriticalNeg(pTG, TRUE);

    DebugPrintEx(   DEBUG_MSG,
                    "Page Send Done.....len=(%ld, 0x%08x)",
                    lTotalLen, lTotalLen);

    pTG->ECM.FramesSent = uFramesSent;

    if(!fReTx)
    {
        BG_CHK(lTotalLen>=(ULONG)uFramesSent*4);
        pTG->ECM.dwPageSize+= (lTotalLen-uFramesSent*4); // 4-bytes of framing data
        pTG->ECM.SendFrameCount = uFrameNum;

        switch(GetSendBuf(pTG, 0, SEND_QUERYENDPAGE))
        {
        case SEND_OK:   pTG->ECM.fEndOfPage = FALSE;
                        break;
        case SEND_EOF:  pTG->ECM.fEndOfPage = TRUE;
                        break;
        default:        DebugPrintEx(   DEBUG_ERR,
                                        "Got SEND_ERROR from GetSendBuf at end of page");
                                        return actionERROR;
        }
    }
    if(!pTG->ECM.FramesSent)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Sent 0 frames--Bad PPR recvd or bad send file");
        ICommFailureCode(pTG, T30FAILSE_BADPPR);
        return actionERROR;
    }

    pTG->T30.fSendAfterSend = TRUE;      // ECM PhaseC/PIX--PPS-X
    return actionGONODE_V;
}

ET30ACTION ECMPhaseD(PThrdGlbl pTG)
{
    USHORT          uTryCount, i;
    ET30ACTION      action;
    BYTE            bPPSfif[3];
    LPBYTE          lpPPR;
    char szBuf[32]= {0};

    DEBUG_FUNCTION_NAME(_T("ECMPhaseD"));
    /******** Transmitter ECM Phase D. Fig A-8 to A-17/T.30 ********/

    if(!pTG->ECM.fEndOfPage)
    {
        pTG->T30.ifrSend = ifrPPS_NULL;
    }
    else
    {
        switch(action = pTG->Params.lpfnWhatNext(pTG, eventPOSTPAGE))
        {
        case actionSENDMPS:     pTG->T30.ifrSend = ifrPPS_MPS;
                                break;
        case actionSENDEOM:     pTG->T30.ifrSend = ifrPPS_EOM;
                                break;
        case actionSENDEOP:     pTG->T30.ifrSend = ifrPPS_EOP;
                                break;
#ifdef PRI
        case actionSENDPRIMPS:  pTG->T30.ifrSend = ifrPPS_PRI_MPS;
                                break;
        case actionSENDPRIEOM:  pTG->T30.ifrSend = ifrPPS_PRI_EOM;
                                break;
        case actionSENDPRIEOP:  pTG->T30.ifrSend = ifrPPS_PRI_EOP;
                                break;
#endif
        case actionERROR:       return action;  // goto PhaseLoop & exit
        default:                return BadAction(pTG, action);
        }
    }

    bPPSfif[0] = pTG->ECM.SendPageCount-1;
    bPPSfif[1] = pTG->ECM.SendBlockCount-1;
    BG_CHK(pTG->ECM.FramesSent && pTG->ECM.FramesSent<=256);
    // bPPSfif[2] = pTG->ECM.SendFrameCount-1;           // don't know which one..!!
    bPPSfif[2] = pTG->ECM.FramesSent-1;                  // this one! For sure

    for(uTryCount=0 ;;)
    {
        SendSingleFrame(pTG, pTG->T30.ifrSend, bPPSfif, 3, 1);

echoretry:
        pTG->T30.ifrResp = GetResponse(pTG, ifrPPSresponse);
        // if we hear our own frame, try to recv again. DONT retransmit!
        if(pTG->T30.ifrResp==pTG->T30.ifrSend)
        {
            ECHOMSG(pTG->T30.ifrResp);
            goto echoretry;
        }

        if(pTG->T30.ifrResp != ifrNULL && pTG->T30.ifrResp != ifrBAD)
                break;

        if(++uTryCount >= 3)
        {
            DebugPrintEx(DEBUG_ERR,"ECM 3 PostPages, No reply");
            ICommFailureCode(pTG, T30FAILSE_3POSTPAGE_NOREPLY);
            return actionDCN;
        }
    }

    switch(pTG->T30.ifrResp)
    {
      case ifrBAD:
      case ifrNULL: BG_CHK(FALSE);  // should never get here
                    ICommFailureCode(pTG, T30FAILSE_BUG2);
                    return actionERROR;     // in case they do :-)

      case ifrDCN:  DebugPrintEx(   DEBUG_ERR,
                                    "Got ifrDCN from GetResponse after sending"
                                    " post-page command");
                    ICommFailureCode(pTG, T30FAILSE_POSTPAGE_DCN);
                    return actionHANGUP;
      case ifrPPR:  DebugPrintEx(   DEBUG_MSG,
                                    "PPR (P=%d B=%d F=%d) Received: ",
                                    pTG->ECM.SendPageCount-1,
                                    pTG->ECM.SendBlockCount-1,
                                    pTG->ECM.FramesSent-1);
                    lpPPR = ProtGetRetransmitMask(pTG);
#ifdef DEBUG
                    for(i=0; i<32; i++)
                        _stprintf(&szBuf[i]," %02x", lpPPR[i]);
                    DebugPrintEx(DEBUG_MSG,"bytes? %s",szBuf);
#endif //DEBUG
                    if(++pTG->ECM.uPPRCount >= 4)
                        goto FourthPPR;
                    return actionGONODE_ECMRETRANSMIT;
      case ifrRNR:  if((pTG->T30.ifrResp=RNR_RRLoop(pTG)) == ifrDCN)
                    {
                        DebugPrintEx(DEBUG_ERR,"RR_RNR loop failed");
                        // ICommFailureCode already called in RR_RNRLoop()
                        return actionDCN;
                    }
                    DebugPrintEx(   DEBUG_MSG,
                                    "Got %d from RNR",
                                    pTG->T30.ifrResp);
                    break;
        }

        switch(pTG->T30.ifrResp)
        {
          case ifrPIP:
          case ifrPIN:
#ifdef PRI
                    return GONODE_E;
#else
                    DebugPrintEx(DEBUG_WRN,"Procedure interrupts not supported");
                    // return actionERROR;
                    // fallthru and treat like MCF
                    pTG->T30.ifrResp = ifrMCF;
#endif
          case ifrMCF:
                    {
                        WORD wSize = (WORD) (pTG->ECM.dwPageSize>>10); //Units are KB
                        ICommStatus(pTG, T30STATS_CONFIRM_ECM,
                                (USHORT) LOBYTE(wSize),
                                (USHORT) HIBYTE(wSize),
                                (USHORT)(pTG->ECM.SendPageCount&0xff));
                        DebugPrintEx(   DEBUG_MSG,
                                        "Sending T30STATS_CONFIRM_pTG->ECM. wSize=%u",
                                        (unsigned) wSize);

                    }
                    action=pTG->Params.lpfnWhatNext(    pTG, eventGOT_ECM_PPS_RESP,
                                                        (UWORD)pTG->T30.ifrResp,
                                                        ULongToPtr((DWORD)pTG->T30.ifrSend));
                    if(pTG->T30.ifrSend==ifrPPS_EOP && pTG->T30.ifrResp==ifrMCF && action==actionDCN)
                    {
                        ICommFailureCode(pTG, T30FAILSE_SUCCESS);
                        return actionDCN_SUCCESS;
                    }
                    else
                        return action;

          default:  DebugPrintEx(   DEBUG_ERR,
                                    "Got UNKNOWN from GetResponse after sending post-page command");
                    ICommFailureCode(pTG, T30FAILSE_POSTPAGE_UNKNOWN);
                    return actionDCN;
        }

FourthPPR:
    action = pTG->Params.lpfnWhatNext(pTG, event4THPPR, (WORD)pTG->ECM.SendFrameCount, (DWORD)pTG->ECM.FramesSent);
    switch(action)
    {
      case actionGONODE_ECMRETRANSMIT:
                    if(CTC_RespRecvd(pTG, ProtGetSendMod(pTG)) == ifrCTR)
                    {
                        pTG->ECM.uPPRCount = 0;
                        pTG->ECM.fSentCTC = TRUE;
                        return actionGONODE_ECMRETRANSMIT;
                    }
                    else
                    {
                        DebugPrintEx(DEBUG_ERR,"CTC-CTR failed");
                        // ICommFailureCode already called in CTC_RespRecvd(pTG)
                        return actionDCN;
                    }

      case actionSENDEOR_EOP:
      case actionDCN:
      case actionERROR:
                    return action;
      default:
                    return BadAction(pTG, action);
                    // none of the EOR stuff
                    // return actionDCN;
    }
}

ET30ACTION ECMSendEOR_EOP(PThrdGlbl pTG)
{
    // dont set new ICommFailure codes in this function. We have already
    // set the 'too many retries' code

    USHORT          uTryCount;

    DEBUG_FUNCTION_NAME(_T("ECMSendEOR_EOP"));

    for(uTryCount=0 ;;)
    {
        DebugPrintEx(DEBUG_WRN,"Sending EOR-EOP");

        pTG->T30.ifrSend = ifrEOR_EOP;
        SendEOR_EOP(pTG);

    echoretry:
        pTG->T30.ifrResp = GetResponse(pTG, ifrEORresponse);
        // if we hear our own frame, try to recv again. DONT retransmit!
        if(pTG->T30.ifrResp==pTG->T30.ifrSend)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Ignoring ECHO of %s(%d)",
                            (LPSTR)(rgFrameInfo[pTG->T30.ifrResp].szName),
                            pTG->T30.ifrResp);
            goto echoretry;
        }

        if(pTG->T30.ifrResp != ifrNULL && pTG->T30.ifrResp != ifrBAD)
            break;

        if(++uTryCount >= 3)
        {
            DebugPrintEx(DEBUG_ERR,"ECM 3 EORs, No reply");
            return actionDCN;
        }
    }

    switch(pTG->T30.ifrResp)
    {
      case ifrBAD:
      case ifrNULL: BG_CHK(FALSE);  // should never get here
                    return actionERROR;     // in case they do :-)

      case ifrDCN:  DebugPrintEx(   DEBUG_ERR,
                                    "Got ifrDCN from GetResponse after sending EOR");
                    return actionHANGUP;

      case ifrRNR:  DebugPrintEx(DEBUG_WRN,"Sent EOR-EOP, got RNR");
                    if((pTG->T30.ifrResp=RNR_RRLoop(pTG)) == ifrDCN)
                    {
                        DebugPrintEx(DEBUG_ERR,"RR_RNR loop failed");
                        // ICommFailureCode already called in RR_RNRLoop(pTG)
                        return actionDCN;
                    }
                    DebugPrintEx(DEBUG_MSG,"Got %d from RNR", pTG->T30.ifrResp);
                    break;
    }

    switch(pTG->T30.ifrResp)
    {
      case ifrERR:  DebugPrintEx(   DEBUG_WRN,
                                    "Sent EOR-EOP. Got ERR. Sending DCN");
                    return actionDCN;
      default:      DebugPrintEx(   DEBUG_ERR,
                                    "Got UNKNOWN from GetResponse after sending EOR");
                    return actionDCN;
    }
}

// reduce this so that when externally measured it always ends up less
// then the specified max of 65s, so we pass protocol conformance tests
#define T5_TIMEOUT              62000L                  // 60s + 5s

IFR RNR_RRLoop(PThrdGlbl pTG)
{
    /** Flowchart is:- Enter this on getting an RNR. Then start T5,
            send RR, get response (standard ResponseRecvd routine). If
            no response, send RR again. Repeat 3 times. If RNR response
            recvd, send RR again & repeat, until T5 expires, upon which
            send DCN & hangup.

            This routine returns ifrDCN, implying teh caller should
            go to NodeC, or ifrXXX, which is used as the response to be
            analysed further down the chart. Never returns ifrNULL
    **/

    UWORD   i;
    IFR     ifr;

    DEBUG_FUNCTION_NAME(_T("RNR_RRLoop"));

    TstartTimeOut(pTG, &(pTG->ECM.toT5), T5_TIMEOUT);
    do
    {
        for(i=0; i<3; i++)
        {
            if(!TcheckTimeOut(pTG, &(pTG->ECM.toT5)))
            {
                DebugPrintEx(DEBUG_ERR,"T5 timeout on Sender");
                ICommFailureCode(pTG, T30FAILSE_RR_T5);
                return ifrDCN;                                  // T5 timed out
            }

            SendRR(pTG);

        echoretry:
            ifr = GetResponse(pTG, ifrRRresponse);
            // if we hear our own frame, try to recv again. DONT retransmit!
            if(ifr==ifrRR)
            {
                DebugPrintEx(   DEBUG_WRN,
                                "Ignoring ECHO of %s(%d)",
                                (LPSTR)(rgFrameInfo[ifr].szName),
                                ifr);
                goto echoretry;
            }

            if(ifr!=ifrNULL && ifr!=ifrBAD)
                    break;
            // on ifrNULL (T4 timeout) we resend RR & try again -- 3 times
        }
    }
    while(ifr == ifrRNR);

    // BG_CHK(ifr!=ifrRNR && ifr!=ifrNULL && ifr!=ifrBAD && ifr!=ifrTIMEOUT);
    // can get BAD or NULL here when i=3
    BG_CHK(ifr!=ifrRNR && ifr!=ifrTIMEOUT);

    if(ifr == ifrDCN)
    {
        DebugPrintEx(DEBUG_ERR,"Got DCN in response to RR");
        ICommFailureCode(pTG, T30FAILSE_RR_DCN);
    }

    if(ifr==ifrBAD || ifr==ifrNULL)
    {
        BG_CHK(i==3);
        DebugPrintEx(DEBUG_ERR,"No response to RR 3 times");
        ICommFailureCode(pTG, T30FAILSE_RR_3xT4);
        ifr=ifrDCN;     // same as T5 timeout
    }
    return ifr;             // finally got a non-RNR response
                                    // return ifrDCN or ifrXXXX (not RNR)
}

IFR CTC_RespRecvd(PThrdGlbl pTG, USHORT uBaud)
{
    UWORD   i;
    IFR     ifr = ifrDCN;
    BYTE    bCTCfif[2];

    DEBUG_FUNCTION_NAME(_T("CTC_RespRecvd"));

    BG_CHK((uBaud & (~0x0F)) == 0);
    bCTCfif[0] = 0;
    bCTCfif[1] = (uBaud << 2);

    for(i=0; i<3; i++)
    {
        SendCTC (pTG, bCTCfif);

    echoretry:
        ifr = GetResponse(pTG, ifrCTCresponse);
        // if we hear our own frame, try to recv again. DONT retransmit!
        if(ifr==ifrCTC)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Ignoring ECHO of %s(%d)",
                            (LPSTR)(rgFrameInfo[ifr].szName), ifr);
            goto echoretry;
        }


        if(ifr!=ifrNULL && ifr!=ifrBAD)
                break;
        // on ifrNULL (T4 timeout) we resend RR & try again -- 3 times
    }

    if(ifr==ifrNULL || ifr==ifrBAD)
    {
        BG_CHK(i == 3);
        DebugPrintEx(DEBUG_ERR,"No response to CTC 3 times");
        ICommFailureCode(pTG, T30FAILSE_CTC_3xT4);
        ifr = ifrDCN;
    }
    else if(ifr != ifrCTR)
    {
        DebugPrintEx(DEBUG_ERR,"Bad response CTC");
        ICommFailureCode(pTG, T30FAILSE_CTC_UNKNOWN);
    }
    return ifr;             // return ifrDCN or ifrXXXX
}

ET30ACTION ECMRecvPhaseD ( PThrdGlbl pTG)
{
    DWORD           CurrPPS;
    ET30ACTION      action;

    DEBUG_FUNCTION_NAME(_T("ECMRecvPhaseD"));
    switch(pTG->T30.ifrCommand)
    {
    case ifrPRI_MPS:
    case ifrPRI_EOM:
    case ifrPRI_EOP:
#ifdef PRI
                        return actionGONODE_RECVPRIQ;
#else
                        pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPRI_MPS+ifrMPS;
                        break;
#endif

    case ifrPPS_PRI_MPS:
    case ifrPPS_PRI_EOM:
    case ifrPPS_PRI_EOP:
#ifdef PRI
                        goto RecvPPSPRIQ;
#else
                        pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPPS_PRI_MPS+ifrPPS_MPS;
                        break;
#endif

    case ifrEOR_PRI_MPS:
    case ifrEOR_PRI_EOM:
    case ifrEOR_PRI_EOP:
#ifdef PRI
                        goto RecvEORPRIQ;
#else
                        pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrEOR_PRI_MPS+ifrEOR_MPS;
                        break;
#endif
    }


UsePrevCommand:

    switch(pTG->T30.ifrCommand)
    {
    case ifrCTC:
            EnterPageCrit(); //start CTR--PAGE critsection
            pTG->ECM.fRecvdCTC = TRUE;
            SendCTR(pTG);
            ECHOPROTECT(ifrCTR, modeECMRETX);
            return actionGONODE_RECVECMRETRANSMIT;
    case ifrPPS_NULL:
    case ifrPPS_MPS:
    case ifrPPS_EOM:
    case ifrPPS_EOP:
            // saved for PPS--RNR--RR--MCF(missed)--RR--MCF sequences
            pTG->ECM.ifrPrevCommand = pTG->T30.ifrCommand;

            //////BugFix 396//////
            CurrPPS = ProtGetPPS(pTG);
            if(pTG->ECM.ifrPrevResponse==ifrMCF && _fmemcmp(pTG->ECM.bPrevPPS, (LPBYTE)(&CurrPPS), 4)==0)
                    goto GoSendMCF;
            _fmemcpy(pTG->ECM.bPrevPPS, (LPBYTE)(&CurrPPS), 4);
            pTG->ECM.ifrPrevResponse = 0;
            //////BugFix 396//////

            switch(ECMRecvOK(pTG))
            {
            default:
            case ECMRECVOK_ABORT:       return actionERROR;
            case ECMRECVOK_OK:          break;
            case ECMRECVOK_BADFR:
                                        EnterPageCrit(); //start PPR--PAGE critsection
                                        SendPPR(pTG, pTG->ECM.bRecvBadFrameMask);
                                        ECHOPROTECT(ifrPPR, modeECMRETX);
                                        return actionGONODE_RECVECMRETRANSMIT;
            }

            // now we can mark eop here
            // #ifdef PRI is on, this won't work (e.g. if the guy sends
            // PRI_MPS at end of page, then this needs to be called but it won't.

            if(pTG->T30.ifrCommand != ifrPPS_NULL
               && !pTG->ECM.fRecvEndOfPage)              // so we won't call this twice
            {
                // RECV_ENDDOC if PPS_EOP or PPS_EOM
                PutRecvBuf(pTG, NULL, ((pTG->T30.ifrCommand==ifrPPS_MPS) ? RECV_ENDPAGE : RECV_ENDDOC));
                // ignore error/abort. We'll catch it soon enough
                pTG->ECM.fRecvEndOfPage = TRUE;
            }

            if(!Recv_NotReadyLoop(pTG, ifrPPS_FIRST, ifrPPS_LAST))
            {
                ICommFailureCode(pTG, T30FAILRE_PPS_RNR_LOOP);
                return actionHANGUP;
            }

            if(pTG->T30.ifrCommand == ifrPPS_NULL)
            {
                action = actionSENDMCF;
            }
            else switch(action = pTG->Params.lpfnWhatNext(pTG, eventRECVPOSTPAGECMD,(WORD)pTG->T30.ifrCommand))
            {
              case actionSENDMCF:           break;
              case actionSENDRTN:
              case actionHANGUP:
              case actionERROR:
              default:                      return BadAction(pTG, action);
            }

#ifdef PRI
            if(pTG->T30.ifrCommand != ifrPPS_NULL)
            {
                    if((action = pTG->Params.lpfnWhatNext(pTG, eventQUERYLOCALINT))==actionTRUE)
                    {
                        ECHOPROTECT(ifrPIP, 0);
                        SendPIP(pTG);
                        break;
                    }
                    else if(action == actionERROR)
                        return action;
            }
#endif //PRI

GoSendMCF:
                pTG->ECM.ifrPrevResponse = ifrMCF;
                if(pTG->T30.ifrCommand == ifrPPS_NULL || pTG->T30.ifrCommand == ifrPPS_MPS)
                {
                        EnterPageCrit(); //start ECM MCF--PAGE critsection
                        ECHOPROTECT(ifrMCF, modeECM);
                        SendMCF(pTG);
                        return actionGONODE_RECVPHASEC;
                }
                ECHOPROTECT(ifrMCF, 0);
                SendMCF(pTG);
                if(pTG->T30.ifrCommand==ifrPPS_EOP)
                    return actionNODEF_SUCCESS;
                else
                    break;

    case ifrEOR_NULL:
    case ifrEOR_MPS:
    case ifrEOR_EOM:
    case ifrEOR_EOP:
                // saved for EOR--RNR--RR--ERR(missed)--RR--ERR sequences
                pTG->ECM.ifrPrevCommand = pTG->T30.ifrCommand;

                if(pTG->T30.ifrCommand!=ifrEOR_NULL
                   && !pTG->ECM.fRecvEndOfPage)              // so we won't call this twice
                {
                    // RECV_ENDDOC if EOR_EOP or EOR_EOM
                    PutRecvBuf(pTG, NULL, ((pTG->T30.ifrCommand==ifrEOR_MPS) ? RECV_ENDPAGE : RECV_ENDDOC));
                    // ignore error/abort. We'll catch it soon enough
                    pTG->ECM.fRecvEndOfPage = TRUE;
                }


                if(!Recv_NotReadyLoop(pTG, ifrEOR_FIRST, ifrEOR_LAST))
                {
                    ICommFailureCode(pTG, T30FAILRE_EOR_RNR_LOOP);
                    return actionHANGUP;
                }

#ifdef PRI
                if(pTG->T30.ifrCommand != ifrPPS_NULL)
                {
                    if((action = pTG->Params.lpfnWhatNext(pTG, eventQUERYLOCALINT))==actionTRUE)
                    {
                        ECHOPROTECT(ifrPIN, 0);
                        SendPIN(pTG);
                        break;
                    }
                    else if(action == actionERROR)
                        return action;
                }
#endif //PRI
                if(pTG->T30.ifrCommand == ifrEOR_NULL || pTG->T30.ifrCommand == ifrEOR_MPS)
                {
                    EnterPageCrit(); //start ERR--PAGE critsection
                    ECHOPROTECT(ifrERR, modeECM);
                    SendERR(pTG);
                    return actionGONODE_RECVPHASEC;
                }
                ECHOPROTECT(ifrERR, 0);
                SendERR(pTG);
                break;

    case ifrRR:
                if(pTG->ECM.ifrPrevCommand)
                {
                    pTG->T30.ifrCommand = pTG->ECM.ifrPrevCommand;
                    goto UsePrevCommand;
                }
                else
                {
                    DebugPrintEx(DEBUG_WRN,"ignoring ERR at weird time");
                    break;
                }

    default:
                DebugPrintEx(   DEBUG_WRN,
                                "Random Command frame received=%d",
                                pTG->T30.ifrCommand);
                break;  // ignore it
    }
    return actionGONODE_F;

#ifdef PRI
RecvPRIPPS:
    switch(ECMRecvOK(pTG))
    {
    default:
    ECMRECVOK_ABORT:        return actionERROR;
    ECMRECVOK_OK:           break;
    ECMRECVOK_BADFR:
            EnterPageCrit(); //start PRI PPR--PAGE critsection
            ECHOPROTECT(ifrPPR, modeECMRETX);
            SendPPR(pTG, pTG->ECM.bRecvBadFrameMask);
            return actionGONODE_RECVECMRETRANSMIT;
    }
RecvPRIEOR:
    switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTPRIQ, (WORD)pTG->T30.ifrCommand))
    {
      case actionERROR:             break;  // return to PhaseLoop
      case actionHANGUP:            break;
      case actionGONODE_F:          break;
      case actionSENDPIP:           pTG->T30.ifrSend=ifrPIP;
                                    return actionGOVOICE;
      case actionSENDPIN:           pTG->T30.ifrSend=ifrPIN;
                                    return actionGOVOICE;
      case actionGO_RECVPOSTPAGE:   if(pTG->T30.ifrCommand >= ifrPPS_PRI_FIRST && pTG->T30.ifrCommand <= ifrPPS_PRI_LAST)
                                    {
                                        pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPPS_PRI_MPS+ifrPPS_MPS;
                                        goto NodeVIIIa;
                                    }
                                    else if(pTG->T30.ifrCommand >= ifrEOR_PRI_FIRST && pTG->T30.ifrCommand <= ifrEOR_PRI_LAST)
                                    {
                                        pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrEOR_PRI_MPS+ifrEOR_MPS;
                                        goto NodeIXa;
                                    }
                                    else
                                    {
                                        BG_CHK(FALSE);
                                    }
    }
    return action;
#endif //PRI
}

BOOL Recv_NotReadyLoop(PThrdGlbl pTG, IFR ifrFirst, IFR ifrLast)
{
    IFR ifrCommand;
    // OBSOLETE:- (??)
    // this is wrong. We should exit only on DCN I think.
    // We should definitely loop again on BAD
    // dunno about TIMEOUT and NULL
    DEBUG_FUNCTION_NAME(_T("Recv_NotReadyLoop"));
    do
    {
        if(ICommRecvBufIsEmpty(pTG))
                return TRUE;

        // sleep for a while, to give FMTRES etc some CPU cycles to catch
        // up with us. Can sleep just before sending response, since sender
        // waits upto 3 (6?) secs for it.
#ifndef FILET30
        IFProcSleep(1000);
#endif

        SendRNR(pTG);

echoretry:
        ifrCommand = GetCommand(pTG, ifrRNRcommand);
        // if we hear our own frame, try to recv again. DONT retransmit!
        if(ifrCommand==ifrRNR)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Ignoring ECHO of %s(%d)",
                            (LPSTR)(rgFrameInfo[ifrCommand].szName), ifrCommand);
            goto echoretry;
        }
    }
    while(  ifrCommand==ifrNULL || ifrCommand==ifrBAD ||
                    ifrCommand == ifrRR     ||
                    (ifrCommand >= ifrFirst && ifrCommand <= ifrLast) );

    // This means we exit on any valid frame _except_ RR and the PPS-X
    // or EOR-X we were expecting. We also exit on ifrTIMEOUT which is
    // when the GetCommand() times out without getting any CONNECT.
    // Otherwise we'd end up sending an MCF after timing out which
    // Ricoh's protocol tester doesnt like. (Ricoh's bug numbbers B3-0106)

    return FALSE;   // just hangs up after this
}

ECMRECVOK ECMRecvOK(PThrdGlbl pTG)
{
    USHORT N, i;

    DEBUG_FUNCTION_NAME(("ECMRecvOK"));

    N = ProtGetRecvECMFrameCount(pTG);
    // N==actual number of frames, i.e. PPR value+1

    DebugPrintEx(DEBUG_MSG,"ECMRecvChk %d frames", N);
    if(!N || N>256)
    {
        BG_CHK(FALSE);
        return ECMRECVOK_ABORT;
    }

    for(i=0; i<N; i++)
    {
        if(pTG->ECM.bRecvBadFrameMask[i/8] & (1 << (i%8)))
        {
            DebugPrintEx(DEBUG_ERR,"bad fr=%d", i);
            return ECMRECVOK_BADFR;
        }
    }
    return ECMRECVOK_OK;
}

ET30ACTION ECMRecvPhaseC(PThrdGlbl pTG, BOOL fRetrans)
{
    /******** Receiver ECM Phase C. Fig A-7/T.30 (sheet 1) ********/

    ULONG           lTotalLen=0;
    USHORT          uRet, uFrameNum, uRCPCount, uSize;
    USHORT          uRecvFrame, uMod;
    LPBUFFER        lpbf;
    LPBUFFER        lpbfShort;

    DEBUG_FUNCTION_NAME(_T("ECMRecvPhaseC"));
    // There is a race between sending the CFR and sending out an
    // +FRM=xx command, so we want to do it ASAP.

    pTG->ECM.uFrameSize = ProtGetRecvECMFrameSize(pTG);
    BG_CHK(pTG->ECM.uFrameSize==6 || pTG->ECM.uFrameSize==8);
    uSize = (1 << pTG->ECM.uFrameSize);

    uMod = ProtGetRecvMod(pTG);
    if(uMod >= V17_START && !pTG->ECM.fRecvdCTC) uMod |= ST_FLAG;

    pTG->T30.sRecvBufSize = MY_ECMBUF_SIZE;

    if((uRet = ModemECMRecvMode(pTG, pTG->Params.hModem, uMod, PHASEC_TIMEOUT)) != RECV_OK)
    {
        ExitPageCrit();
        DebugPrintEx(DEBUG_WRN,"RecvMode ret=%d", uRet);

        if(!fRetrans)
        {
            // in case we miss the page entirely
            // and jump into PhaseD directly

            // init bad frame bitmask to all-bad
            memset(pTG->ECM.bRecvBadFrameMask, 0xFF, 32);        // all bad
            // init the status vars for the PPS/EOR--(RR-RNR)*--PPR/MCF loop
            pTG->ECM.ifrPrevCommand = 0;
            // reset the FrameInThisBlock count. Reset only on
            // non-retransmit. Set when first PPS is recvd
            ProtResetRecvECMFrameCount(pTG);

            if(pTG->ECM.fRecvEndOfPage)  // as opposed to end-of-block
                    uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTPAGE);
            else
                    uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTBLOCK);

            pTG->ECM.fRecvEndOfPage = FALSE;
            if(!uRet)
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Got Error from PutRecvBuf at StartPage/Block");
                return actionERROR;
            }
            pTG->EchoProtect.modePrevRecv = modeECM;
        }
        else
                pTG->EchoProtect.modePrevRecv = modeECMRETX;

        // set global flag if we got WRONGMODE
        pTG->EchoProtect.fGotWrongMode = (uRet==RECV_WRONGMODE);

        // elim flush--does no good & wastes 10ms
        // ModemFlush(pTG->Params.hModem);
        return actionGONODE_F;
        // try to get 300bps command instead
    }
    ExitPageCrit();

    // as soon as we get good carrier ZERO the pTG->EchoProtect state
    _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

    // reset this flag AFTER we successfully recv LONG_TRAIN. We may get an
    // echo of our last command, go to NodeF, reject the echo and loop back
    // here. In that case we want to retry LONG train, otherwise we always
    // croak after a CTC
    pTG->ECM.fRecvdCTC = FALSE;

#ifdef IFAX
    BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, (PSIFAX_RECV|PSIFAX_ECM|(fRetrans ? PSIFAX_RERECV : 0)), (uMod & (~ST_FLAG)));
#endif
    DebugPrintEx(DEBUG_MSG,"RECEIVING ECM Page.......");
    if(fRetrans)
        ICommStatus(pTG, T30STATR_RERECV_ECM, 0, 0, 0);

    // Turn yielding on *after* entering receive mode safely!
    FComCriticalNeg(pTG, FALSE);

/***
    switch(action = pTG->Params.lpfnWhatNext(eventSTARTRECV))
    {
      case actionCONTINUE:  break;
      case actionDCN:               ERRMSG((SZMOD "<<ERROR>> Got actionDCN from eventSTARTRECV\r\n"));
                                                    return actionDCN;               // goto NodeC;
      case actionHANGUP:    ERRMSG((SZMOD "<<ERROR>> Got actionHANGUP from eventSTARTRECV\r\n"));
                                                    return action;  // goto NodeB;
      case actionERROR:             return action;
      default:                              return BadAction(action);
    }
***/

    if(!fRetrans)
    {
        memset(pTG->ECM.bRecvBadFrameMask, 0xFF, 32);
        ProtResetRecvECMFrameCount(pTG);

        if(pTG->ECM.fRecvEndOfPage)  // as opposed to end-of-block
            uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTPAGE);
        else
            uRet = (USHORT)PutRecvBuf(pTG, NULL, RECV_STARTBLOCK);
        if(!uRet)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Got Error from PutRecvBuf at StartPage/Block");
            return actionERROR;
        }
    }
    pTG->ECM.ifrPrevCommand = 0;
    pTG->ECM.fRecvEndOfPage = FALSE;
    pTG->ECM.ifrPrevResponse = 0;

#ifdef DEBUG
    if (fRetrans)
        D_PSIFAXCheckMask(pTG, pTG->ECM.bRecvBadFrameMask);
#endif


// make it large, in case of large buffers & slow modems
#define READ_TIMEOUT    25000

    lpbfShort=0;
    for(uFrameNum=0, lpbf=0, lTotalLen=0, uRCPCount=0, uRet=RECV_OK; uRet!=RECV_EOF;)
    {
        if(lpbf)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Freeing leftover Buf 0x%08lx inside loop",
                            lpbf);

            MyFreeBuf(pTG,  lpbf);        // need to free after bad frames etc
        }

        lpbf = 0;
        uRet=ModemRecvBuf(pTG, pTG->Params.hModem, TRUE, &lpbf, READ_TIMEOUT);

        if(uRet == RECV_BADFRAME)
        {
            DebugPrintEx(DEBUG_WRN, "ModemRecvBuf returns BADFRAME");
            continue;
        }
        else if(uRet == RECV_EOF)
        {
            BG_CHK(lpbf == 0);
            if(lpbfShort)
            {
                lpbf = lpbfShort;
                lpbfShort = 0;

                if(fRetrans && ((USHORT)(lpbf->lpbBegData[3])+1 < ProtGetRecvECMFrameCount(pTG)))
                {
                    DebugPrintEx(   DEBUG_WRN,
                                    "DISCARDING Short but not-really-terminal"
                                    " FCD frame(N=%d). len=%d. PADDING to %d!!",
                                    lpbf->lpbBegData[3],
                                    lpbf->wLengthData,
                                    uSize+4);
                    IFBufFree(lpbf);
                    break;
                }
                else
                {
                    DebugPrintEx(   DEBUG_WRN,
                                    "Short Terminal FCD frame(N=%d)."
                                    " len=%d. PADDING to %d!!",
                                    lpbf->lpbBegData[3],
                                    lpbf->wLengthData,
                                    uSize+4);
                    BG_CHK(lpbf->wLengthBuf >= uSize+4);
                    _fmemset(lpbf->lpbBegData+lpbf->wLengthData, 0, (uSize+4-lpbf->wLengthData));
                    lpbf->wLengthData = uSize+4;
                    goto skipchks;
                }
            }
            else
            {
                break;
            }
        }
        else if(uRet != RECV_OK)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Got %d from RecvBuf in ECMREcvPhaseC",
                            uRet);
            break;
        }
        else if(lpbf==0)
        {
            // sometimes we get RECV_OK with no data. Treat same as bad frame
            continue;
        }

        BG_CHK(uRet==RECV_OK && lpbf && lpbf->lpbBegData);

        if(uRCPCount >= 3)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Got a good frame after %d RCP\r\n",
                            uRCPCount);
            continue;
        }

        if( lpbf->lpbBegData[0] != 0xFF ||
                lpbf->lpbBegData[1] != 0x03 ||
                (lpbf->lpbBegData[2] & 0x7F) != 0x06)
        {
                DebugPrintEx(   DEBUG_ERR,
                                "Bad frame (N=%d) not caught FCF=%02x!!",
                                uFrameNum,
                                lpbf->lpbBegData[2]);
                BG_CHK(FALSE);
                continue;
        }

        if(lpbf->lpbBegData[2] == 0x86)
        {
            // got RCP
            if(lpbf->wLengthData != 3)
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Bad RCP frame len=%d",
                                lpbf->wLengthData);
                BG_CHK(FALSE);
                continue;
            }
            uRCPCount++;
            DebugPrintEx(DEBUG_MSG,"Got %d RCP", uRCPCount);
            continue;
        }

        if(lpbfShort)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Short FCD frame(N=%d). len=%d DISCARDING",
                            lpbfShort->lpbBegData[3],
                            lpbfShort->wLengthData);
            MyFreeBuf(pTG, lpbfShort);
            lpbfShort = NULL;
        }
        if(lpbf->wLengthData > (uSize+4))
        {
            DebugPrintEx(   DEBUG_ERR,
                            "FCD frame too long(N=%d %d). len=%d. DISCARDING",
                            uFrameNum,
                            lpbf->lpbBegData[3],
                            lpbf->wLengthData);
            continue;
        }
        else if(lpbf->wLengthData < (uSize+4))
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Short FCD frame(N=%d %d). len=%d. Storing",
                            uFrameNum,
                            lpbf->lpbBegData[3],
                            lpbf->wLengthData);
            BG_CHK(lpbfShort==0);
            lpbfShort = lpbf;
            lpbf = NULL;
            continue;
        }

skipchks:
        BG_CHK(lpbf->lpbBegData[2] == 0x06);
        BG_CHK(lpbf->wLengthData == (uSize+4));

        uRecvFrame = lpbf->lpbBegData[3];
        lpbf->lpbBegData += 4;
        lpbf->wLengthData -= 4;

        if(!fRetrans)
        {
            if(uFrameNum > uRecvFrame)
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Out of order frame. Got %d Looking for %d",
                                uRecvFrame,
                                uFrameNum);
                BG_CHK(FALSE);
                // ignore this frame in non-debug mode
                continue;
            }
            else if(uFrameNum < uRecvFrame)
            {
                if(!FillInFrames(pTG, (USHORT)(uRecvFrame-uFrameNum), pTG->T30.sRecvBufSize, uSize))
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "Zero return from PutRecvBuf in FillInFrames");
                    return actionERROR;
                }
            }
            lTotalLen += lpbf->wLengthData;
        }
        uFrameNum = uRecvFrame;

        if(!fRetrans || (pTG->ECM.bRecvBadFrameMask[uFrameNum/8] & (1 << (uFrameNum%8))))
        {
            BG_CHK(uFrameNum < 256 && pTG->ECM.uFrameSize <=8); // shift below wont ovf 16 bits
            if(!PutRecvBuf(pTG, lpbf, (fRetrans ? ((SLONG)(uFrameNum << pTG->ECM.uFrameSize)) : RECV_SEQ)))
            {
                DebugPrintEx(DEBUG_ERR,"Zero return from PutRecvBuf in page");
                return actionERROR;
            }
            pTG->ECM.bRecvBadFrameMask[uFrameNum/8] &= ~(1 << (uFrameNum%8));
            uFrameNum++;
            lpbf = 0;
        }
    }


    if(lpbf)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Freeing leftover Buf 0x%08lx outside loop",
                        lpbf);
        MyFreeBuf(pTG, lpbf);        // need to free after bad frames etc
    }

    if(uRet == RECV_EOF)
    {
        FComCriticalNeg(pTG, TRUE);
        // cant mark end of page until we know if end of page or block etc.
        // PutRecvBuf(NULL, RECV_ENDPAGE);              // to mark end of Page
    }
    else
    {
        DebugPrintEx(   DEBUG_ERR,
                        "DataRead Timeout or Error=%d",
                        uRet);
        BG_CHK(FALSE);
        ICommFailureCode(pTG, T30FAILRE_MODEMRECV_PHASEC);
        return actionERROR;     // goto error;
    }

    DebugPrintEx(   DEBUG_MSG,
                    "ECM Page Recv Done.....len=(%ld, 0x%08x)",
                    lTotalLen,
                    lTotalLen);
    ECHOPROTECT(0, 0);
    return actionGONODE_F;  // goto NodeF;                  // get post-message command
}

BOOL FillInFrames(PThrdGlbl pTG, USHORT N, LONG sBufSize, USHORT uDataSize)
{
    USHORT i;
    LPBUFFER        lpbf;

    DEBUG_FUNCTION_NAME(_T("FillInFrames"));
    for(i=0; i<N; i++)
    {
#ifdef IFK
        TstartTimeOut(pTG, &pTG->T30.toBuf, WAITFORBUF_TIMEOUT);
        while(!(lpbf = MyAllocBuf(pTG, sBufSize)))
        {
            if(!TcheckTimeOut(pTG, &pTG->T30.toBuf))
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Giving up on BufAlloc in T30-ECM after %ld millisecs",
                                ((ULONG)WAITFORBUF_TIMEOUT));
                BG_CHK(FALSE);
                return FALSE;
            }
            DebugPrintEx(   DEBUG_ERR,
                            "BufAlloc failed in T30-pTG->ECM. Trying again");
            IFProcSleep(100);
        }
#else
        if(!(lpbf = MyAllocBuf( pTG, sBufSize)))
            return FALSE;
#endif

        lpbf->wLengthData = uDataSize;

        if(!PutRecvBuf(pTG, lpbf, RECV_SEQBAD))
        {
            DebugPrintEx(DEBUG_ERR,"Zero return from PutRecvBuf in page");
            return FALSE;
        }
    }
    return TRUE;
}

#ifdef SWECM

USHORT ModemECMRecvMode(PThrdGlbl pTG, HMODEM h, USHORT uMod, ULONG ulTimeout)
{
    if(!SWECMRecvSetup(pTG, TRUE))
    {
        BG_CHK(FALSE);
        return RECV_ERROR;
    }
    return ModemRecvMode(pTG, h, uMod, FALSE, ulTimeout, ifrPIX_SWECM);
}

#endif //SWECM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\memutil.c ===
/***************************************************************************
 Name     :     MEMUTIL.C
 Comment  :     Mem mgmnt and utilty functions

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#ifdef WIN32_LEAN_AND_MEAN              // for timeBeginPeriod and timeEndPeriod
#       include <mmsystem.h>
#endif

#include "glbproto.h"

void MyAllocInit(PThrdGlbl pTG)
{
    pTG->uCount=0;
    pTG->uUsed=0;
}

LPBUFFER MyAllocBuf(PThrdGlbl pTG, LONG sSize)
{
    LPBUFFER        lpbf;

    DEBUG_FUNCTION_NAME(_T("MyAllocBuf"));

    BG_CHK(sSize > 0);
    if(pTG->uCount >= STATICBUFCOUNT)
    {
        DebugPrintEx(DEBUG_ERR,"Already alloced %d bufs", pTG->uCount);
        BG_CHK(FALSE);
        return NULL;
    }
    else if(pTG->uUsed+sSize > STATICBUFSIZE)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Already alloced %d bytes out of %d. Want %d",
                        pTG->uUsed, 
                        STATICBUFSIZE, 
                        sSize);
        BG_CHK(FALSE);
        return NULL;
    }

    // init header
    // pTG->bfStaticBuf[pTG->uCount].lpbdBufData = NULL;
    // Initialize fields
    // pTG->bfStaticBuf[pTG->uCount].lpbdBufData->header.uRefCount = 1;
    pTG->bfStaticBuf[pTG->uCount].lpbCurPtr = pTG->bfStaticBuf[pTG->uCount].lpbBegData =
                                              pTG->bfStaticBuf[pTG->uCount].lpbBegBuf =
                                              pTG->bStaticBufData + pTG->uUsed;

    pTG->bfStaticBuf[pTG->uCount].wLengthBuf = (USHORT) sSize;
    pTG->uUsed += (USHORT) sSize;
    // pTG->bfStaticBuf[pTG->uCount].lpbfNextBuf = NULL;
    // pTG->bfStaticBuf[pTG->uCount].uReadOnly = FALSE;
    pTG->bfStaticBuf[pTG->uCount].wLengthData = 0;
    pTG->bfStaticBuf[pTG->uCount].dwMetaData = 0;

    lpbf = &(pTG->bfStaticBuf[pTG->uCount++]);

    // wsprintf(szTemp, "%d %d %x %08lx %08lx %08lx\r\n", sSize, pTG->uCount, pTG->uUsed, lpbf, lpbf->lpbBegBuf, lpbf->lpbBegData);
    // OutputDebugStr(szTemp);

    return lpbf;
}

BOOL MyFreeBuf(PThrdGlbl pTG, LPBUFFER lpbf)
{
    DEBUG_FUNCTION_NAME(_T("MyFreeBuf"));

    if(pTG->uCount==0 || lpbf!= &(pTG->bfStaticBuf[pTG->uCount-1]))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Not alloced or out-of-order free. Count=%d lpbf=%08lx bf=%08lx",
                        pTG->uCount,
                        lpbf, 
                        (LPBUFFER)&pTG->bfStaticBuf);
        BG_CHK(FALSE);
        return FALSE;
    }
    pTG->uCount--;
    BG_CHK(lpbf->lpbBegBuf == pTG->bStaticBufData+pTG->uUsed-lpbf->wLengthBuf);
    pTG->uUsed -= lpbf->wLengthBuf;
    return TRUE;
}

LPVOID IFMemAlloc (UINT fuAlloc, LONG lAllocSize, LPWORD lpwActualSize)
{
   DWORD dwSize;
   LPVOID  lpv = NULL;


   // Find the required size
   if (lAllocSize > 0)  
   {
       dwSize = (DWORD)lAllocSize;
   }
   else 
   {
       if (lAllocSize == RAW_DATA_SIZE)
       {
           dwSize=16000;
       }
       else if (lAllocSize == COMPRESS_DATA_SIZE)
       {
           dwSize=2000;
       }
       else if (lAllocSize == SMALL_HEADER_SIZE)
       {
           dwSize = sizeof(BUFFER);
       }
       else
       {
           return NULL;
       }
   }

   lpv = MemAlloc(dwSize);
   if (lpwActualSize) 
   {
       if (lpv) 
       {
           *lpwActualSize = (UINT) dwSize;
       }
       else 
       {
           *lpwActualSize = 0;
       }
   }

   return lpv;
}

BOOL IFMemFree (LPVOID lpvMem)
{
   MemFree(lpvMem);
   return 1;

}

////////////////////////////////////////////////////////
// from utils\runtime\buffers.c
////////////////////////////////////////////////////////

typedef struct _BUFFERDATA 
{
    // Private portion
    struct 
    {
        UINT    uRefCount;
        UINT    uFiller;        // maintain alignment
    } header;

    // public portion
    BYTE    rgbData[];      // Actual data
} BUFFERDATA;

BOOL IFBufFree (LPBUFFER lpbf)
{
    register BOOL bRetVal;

    if (lpbf->lpbdBufData && (!--lpbf->lpbdBufData->header.uRefCount)) 
    {
        // both header and data need to be freed
        bRetVal = IFMemFree(lpbf->lpbdBufData);
        bRetVal = bRetVal && IFMemFree(lpbf);
    }
    else 
    {
        // only the buffer header needs to be freed. Either the buffer only
        // contained metadata, or the data is still being referenced.
        bRetVal = IFMemFree(lpbf);
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\protapi.c ===
/***************************************************************************
 Name     :     PROTHELP.C
 Comment  :     Protocol Initialization & helper functions
 Functions:     (see Prototypes just below)

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"
#include "efaxcb.h"
#include "protocol.h"

///RSL
#include "glbproto.h"

BOOL WINAPI ET30ProtOpen(PThrdGlbl pTG, BOOL fCaller)
{
    DEBUG_FUNCTION_NAME(_T("ET30ProtOpen"));

    BG_CHK(sizeof(DIS) == 8);

    if(!pTG->ProtInst.fInUse)
    {
        memset(&pTG->ProtInst, 0, sizeof(PROT));

        pTG->ProtInst.RecvCaps.wTotalSize =
        pTG->ProtInst.RecvParams.wTotalSize =
        pTG->ProtInst.RecvPollReq.wTotalSize = sizeof(BC);

        pTG->ProtInst.SendCaps.wTotalSize =
        pTG->ProtInst.SendParams.wTotalSize =
        pTG->ProtInst.SendPollReq.wTotalSize = sizeof(BC);

        pTG->ProtInst.RecvCapsGuard  =
        pTG->ProtInst.RecvParamsGuard =
        pTG->ProtInst.RecvPollReqGuard = 0xA55A5AA5L;

        pTG->ProtInst.SendCapsGuard  =
        pTG->ProtInst.SendParamsGuard =
        pTG->ProtInst.SendPollReqGuard = 0xA55A5AA5L;

        pTG->ProtInst.fInUse = TRUE;

        _fmemset(&pTG->ProtParams, 0, sizeof(pTG->ProtParams));

#ifdef OEMNSF
        wLenOEMID = 0;
        wOEMFlags = 0;
        fUsingOEMProt = 0;

        if(lpfnOEMStartCall)
            wOEMFlags = lpfnOEMStartCall(fCaller, &wLenOEMID, rgbOEMID);
        if(wLenOEMID > 4) wLenOEMID = 4;
#endif //OEMNSF

        return TRUE;
    }
    else
    {
        BG_CHK(FALSE);
        return FALSE;
    }
}

BOOL  WINAPI ET30ProtClose(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("ET30ProtClose"));

    pTG->ProtInst.fInUse = FALSE;

    BG_CHK(pTG->ProtInst.RecvCapsGuard  == 0xA55A5AA5L);
    BG_CHK(pTG->ProtInst.RecvParamsGuard == 0xA55A5AA5L);
    BG_CHK(pTG->ProtInst.RecvPollReqGuard == 0xA55A5AA5L);
    BG_CHK(pTG->ProtInst.SendCapsGuard  == 0xA55A5AA5L);
    BG_CHK(pTG->ProtInst.SendParamsGuard == 0xA55A5AA5L);
    BG_CHK(pTG->ProtInst.SendPollReqGuard == 0xA55A5AA5L);

#ifdef DEBUG
    DebugPrintEx(DEBUG_MSG,"Sending Caps & Params");

    if(pTG->ProtInst.fRecvCapsGot)
        D_PrintBC((LPBC)&pTG->ProtInst.RecvCaps, 0, 0);

    if(pTG->ProtInst.fllRecvCapsGot)
        D_PrintBC(0, "RecvCaps", &pTG->ProtInst.llRecvCaps);

    if(pTG->ProtInst.fllSendParamsInited)
        D_PrintBC(0, "Send Negot Position", &pTG->ProtInst.llSendParams);

    if(pTG->ProtInst.fSendParamsInited)
        D_PrintBC((LPBC)&pTG->ProtInst.SendParams, 0, 0);

    if(pTG->ProtInst.fllNegotiated)
        D_PrintBC(0, "SendParams", &pTG->ProtInst.llNegot);

    DebugPrintEx(DEBUG_MSG,"Receiving Caps & Params");

    if(pTG->ProtInst.fSendCapsInited)
        D_PrintBC((LPBC)&pTG->ProtInst.SendCaps, 0, 0);

    if(pTG->ProtInst.fllSendCapsInited)
        D_PrintBC(0, "SendCaps", &pTG->ProtInst.llSendCaps);

    if(pTG->ProtInst.fRecvParamsGot)
        D_PrintBC((LPBC)&pTG->ProtInst.RecvParams, 0, 0);

    if(pTG->ProtInst.fllRecvParamsGot)
        D_PrintBC(0, "RecvParams", &pTG->ProtInst.llRecvParams);

    DebugPrintEx(DEBUG_MSG,  "Polling Caps & Params");

    if(pTG->ProtInst.fSendPollReqInited)
        D_PrintBC((LPBC)&pTG->ProtInst.SendPollReq, 0, 0);

    if(pTG->ProtInst.fRecvPollReqGot)
        D_PrintBC((LPBC)&pTG->ProtInst.RecvPollReq, 0, 0);
    
#endif //DEBUG

#ifdef OEMNSF
    if(wOEMFlags && lpfnOEMEndCall)
    {
        lpfnOEMEndCall();
        wOEMFlags = 0;
    }
#endif

    return TRUE;
}


// This function get the capabilities of the fax. 
// We are calling this function when we want to receive a fax, with type SEND_CAPS 
// (before we answer the call)
// and with the information in pTG->ProtInst.SendCaps we make the DIS.

BOOL ProtGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep)
{
    LPBC lpbc;
    USHORT uSpace;

    DEBUG_FUNCTION_NAME(_T("ProtGetBC"));

    DebugPrintEx(DEBUG_MSG,"In ProtGetBC: bctype=%d", bctype);

    lpbc = ICommGetBC(pTG, bctype, fSleep);

    if(lpbc)
    {
        BG_CHK(lpbc->wTotalSize >= sizeof(BC));
        switch(bctype)
        {
        case SEND_CAPS:
                BG_CHK(lpbc->bctype == SEND_CAPS);
                uSpace = sizeof(pTG->ProtInst.SendCaps);
                if(lpbc->wTotalSize > uSpace)
                        goto nospace;
                // Here we actually take the send-caps and copy it 
                // from pTG->Inst.SendCaps **to** pTG->ProtInst.SendCaps
                _fmemcpy(&pTG->ProtInst.SendCaps, lpbc, lpbc->wTotalSize); 
                pTG->ProtInst.fSendCapsInited = TRUE;
                break;
        case SEND_PARAMS:
                if(lpbc->bctype == SEND_PARAMS)
                {   
                    uSpace = sizeof(pTG->ProtInst.SendParams);
                    if(lpbc->wTotalSize > uSpace)
                            goto nospace;
                    // Here we actually take the send-caps and copy it 
                    // from pTG->Inst->SendParams **to** pTG->ProtInst.SendParams
                    _fmemcpy(&pTG->ProtInst.SendParams, lpbc, lpbc->wTotalSize);
                    pTG->ProtInst.fSendParamsInited = TRUE;
                }
                else if(lpbc->bctype == SEND_POLLREQ)
                {
                    uSpace = sizeof(pTG->ProtInst.SendPollReq);
                    if(lpbc->wTotalSize > uSpace)
                            goto nospace;
                    _fmemcpy(&pTG->ProtInst.SendPollReq, lpbc, lpbc->wTotalSize);
                    pTG->ProtInst.fSendPollReqInited = TRUE;
                }
                else
                {
                    // RSL  BG_CHK(FALSE);
                    // RSL  goto error;

                    uSpace = sizeof(pTG->ProtInst.SendParams);
                    if(lpbc->wTotalSize > uSpace)
                            goto nospace;
                   //  _fmemcpy(&pTG->ProtInst.SendParams, lpbc, lpbc->wTotalSize);
                    pTG->ProtInst.fSendParamsInited = TRUE;

                }

                break;
        default:
                BG_CHK(FALSE);
                goto error;
                break;
        }
        return TRUE;
    }
    else
    {
        BG_CHK(fSleep);
        DebugPrintEx(DEBUG_WRN,"Ex bctype=%d --> FAILED", bctype);
        return FALSE;
    }
nospace:
    DebugPrintEx(   DEBUG_ERR,
                    "BC too big size=%d space=%d",
                    lpbc->wTotalSize, 
                    uSpace);
error:

    DebugPrintEx(DEBUG_WRN,"ATTENTION: pTG->ProtInst.fAbort = TRUE");
    pTG->ProtInst.fAbort = TRUE;
    return FALSE;
}

#define SetupLL(npll, B, M, E, f64)             \
        (((npll)->Baud=(BYTE)(B)), ((npll)->MinScan=(BYTE)(M)), ((npll)->fECM=(BYTE)(E)), ((npll)->fECM64=(BYTE)(f64)))

BOOL WINAPI ET30ProtSetProtParams
(
    PThrdGlbl pTG, 
    LPPROTPARAMS lp, 
    USHORT uSendSpeeds, 
    USHORT uRecvSpeeds
)
{

    DEBUG_FUNCTION_NAME(_T("ET30ProtSetProtParams"));

    BG_CHK(uRecvSpeeds && uSendSpeeds);
    BG_CHK((uRecvSpeeds & ~BAUD_MASK) == 0);
    BG_CHK((uSendSpeeds & ~BAUD_MASK) == 0);

    BG_CHK(lp->uSize >= sizeof(pTG->ProtParams));
    _fmemcpy(&pTG->ProtParams, lp, min(sizeof(pTG->ProtParams), lp->uSize));

    // Hardware params
    SetupLL(&(pTG->ProtInst.llSendCaps), uRecvSpeeds, lp->uMinScan,
            !lp->DisableRecvECM, (lp->DisableRecvECM ? 0 : lp->Recv64ByteECM));
    pTG->ProtInst.fllSendCapsInited = TRUE;

    SetupLL(&(pTG->ProtInst.llSendParams), uSendSpeeds, MINSCAN_0_0_0,
            !lp->DisableSendECM, (lp->DisableSendECM ? 0 : lp->Send64ByteECM));
    pTG->ProtInst.fllSendParamsInited = TRUE;

    /*****
            pTG->ProtInst.llSendCaps.Baud = uRecvSpeeds;
            pTG->ProtInst.llSendCaps.MinScan = uMinScan;
            pTG->ProtInst.llSendParams.Baud = uSendSpeeds;
            pTG->ProtInst.llSendParams.MinScan = MINSCAN_0_0_0;
    ******/

    pTG->ProtInst.fHWCapsInited = TRUE;

    if(lp->HighestSendSpeed && lp->HighestSendSpeed != 0xFFFF)
    {
        pTG->ProtInst.HighestSendSpeed = lp->HighestSendSpeed;
    }
    else
    {
        pTG->ProtInst.HighestSendSpeed = 0;
    }

    if(lp->LowestSendSpeed && lp->LowestSendSpeed != 0xFFFF)
    {
        pTG->ProtInst.LowestSendSpeed = lp->LowestSendSpeed;
    }
    else
    {
        pTG->ProtInst.LowestSendSpeed = 0;
    }

    DebugPrintEx(DEBUG_MSG,"Done with HW caps (recv, send)");
    // OK to print -- not online
    D_PrintBC(0, "Recv HWCaps", &(pTG->ProtInst.llSendCaps));
    D_PrintBC(0, "Send HWCaps", &(pTG->ProtInst.llSendParams));
    DebugPrintEx(   DEBUG_MSG, 
                    "Highest=%d Lowest=%d",
                    pTG->ProtInst.HighestSendSpeed, 
                    pTG->ProtInst.LowestSendSpeed);

    return TRUE;
}

void GetRecvPageAck(PThrdGlbl pTG)
{
    USHORT uRet;

    DEBUG_FUNCTION_NAME(_T("GetRecvPageAck"));

    pTG->ProtInst.fPageOK = 0;
    switch(uRet = ICommGetRecvPageAck(pTG, TRUE))
    {
    case 0:
    case 1:     pTG->ProtInst.fPageOK = uRet;
                break;

    default:
                DebugPrintEx(   DEBUG_WRN, 
                                "ATTENTION: pTG->ProtInst.fAbort = TRUE");
                pTG->ProtInst.fAbort = TRUE;
                BG_CHK(FALSE);
                break;
    }
    DebugPrintEx(DEBUG_MSG,"return-->%d", uRet);
}

void  WINAPI ET30ProtAbort(PThrdGlbl pTG, BOOL fEnable)
{
    DEBUG_FUNCTION_NAME(_T("ET30ProtAbort"));
    // bug#696 -- sometimes on aborts this gets called with fEnable==0
    // even after ET30ProtClose has been called. This is harmless so
    // don't BG_CHK. But it must _not_ be called with fEnable==TRUE
    // if pTG->ProtInst.fInUse is 0, i.e. we're not inited

    BG_CHK(fEnable ? pTG->ProtInst.fInUse : TRUE);
    // ICommFailureCode already set

    DebugPrintEx(   DEBUG_WRN, 
                    "ATTENTION: pTG->ProtInst.fAbort=%d\n",
                    fEnable);
    pTG->ProtInst.fAbort = fEnable;
}

DWORD_PTR ProtExtFunction(PThrdGlbl pTG, USHORT uFunction)
{
    NPPROT  npProt = &pTG->ProtInst;

    DEBUG_FUNCTION_NAME(("ProtExtFunction"));

    BG_CHK(pTG->ProtInst.fInUse);

    switch(uFunction)
    {
    case GET_SEND_MOD:                      BG_CHK(npProt->fllNegotiated);
                                            return npProt->llNegot.Baud;
    case GET_RECV_MOD:                      BG_CHK(npProt->fllRecvParamsGot);
                                            return npProt->llRecvParams.Baud;
    case GET_ECM_FRAMESIZE:                 BG_CHK(npProt->fllNegotiated);
                                            return (npProt->llNegot.fECM64 ? 6 : 8);
    case GET_PPR_FIF:                       BG_CHK(npProt->fRecvdPPR);
                                            return (ULONG_PTR)((LPBYTE)npProt->bRemotePPR);
    case GET_WHATNEXT:                      return (ULONG_PTR)((LPWHATNEXTPROC)WhatNext);
    case GET_MINBYTESPERLINE:               BG_CHK(npProt->fllNegotiated);
                                            return MinScanToBytesPerLine(pTG, npProt->llNegot.MinScan, npProt->llNegot.Baud);
    case RECEIVING_ECM:                     if(!npProt->fllRecvParamsGot)
                                            {
                                                DebugPrintEx(   DEBUG_WRN,
                                                                "No RecvParams-"
                                                                "-assuming non-ECM");
                                                return FALSE;
                                            }
                                            else
                                            {
                                                return npProt->llRecvParams.fECM;
                                            }
    case GET_RECV_ECM_FRAMESIZE:            BG_CHK(npProt->fllRecvParamsGot);
                                            return (npProt->llRecvParams.fECM64 ? 6 : 8);
    case GET_RECVECMFRAMECOUNT:             BG_CHK(npProt->fRecvdPPS);
                                            BG_CHK(npProt->uFramesInThisBlock);
                                            BG_CHK(npProt->uFramesInThisBlock <= 256);
                                            return (DWORD)(npProt->uFramesInThisBlock);
    case GET_PPS:                           return *((DWORD*)(npProt->bRemotePPS));
    case RESET_RECVECMFRAMECOUNT:           npProt->uFramesInThisBlock=0;
                                            return 0;
    case RESET_RECVPAGEACK:                 npProt->fPageOK=FALSE;
                                            return 0;
    case GET_SEND_ENCODING:                 BG_CHK(npProt->fSendParamsInited);
                                            return npProt->SendParams.Fax.Encoding;
    case GET_RECV_ENCODING:                 BG_CHK(npProt->fRecvParamsGot);
                                            return npProt->RecvParams.Fax.Encoding;
    default:                                BG_CHK(FALSE); 
                                            return 0;
    }
}


#ifdef DEBUG

char* szBCTYPE[] = {
"NONE",
"SEND_CAPS",
"RECV_CAPS",
"SEND_PARAMS",
"RECV_PARAMS",
"SEND_POLLREQ",
"RECV_POLLREQ"
};

void D_PrintBC(LPBC lpbc, LPSTR szll, LPLLPARAMS lpll)
{
    int i;
    DEBUG_FUNCTION_NAME(_T("D_PrintBC"));

    if(lpbc)
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "%s: Std: l=%d n=%d vMsg=%d fBin=%d fIn=%d"
                        " vSec=%d vCmpr=%d OS=%d vFl=%d",
                        (LPSTR)(szBCTYPE[lpbc->bctype]), 
                        lpbc->Std.GroupLength, 
                        lpbc->Std.GroupNum,
                        lpbc->Std.vMsgProtocol, 
                        lpbc->Std.fBinaryData, 
                        lpbc->Std.fInwardRouting,
                        lpbc->Std.vSecurity, 
                        lpbc->Std.vMsgCompress, 
                        lpbc->Std.OperatingSys,
                        lpbc->Std.vShortFlags);

        DebugPrintEx(   DEBUG_MSG, 
                        "vInt=%d Dspd=%x Dlnk=%x Fax: fPol=%d Res=%x"
                        " Enc=%x Wid=%x Len=%x",
                        lpbc->Std.vInteractive, 
                        lpbc->Std.DataSpeed, 
                        lpbc->Std.DataLink,
                        lpbc->Fax.fPublicPoll,
                        (WORD)lpbc->Fax.AwRes, 
                        lpbc->Fax.Encoding, 
                        lpbc->Fax.PageWidth,
                        lpbc->Fax.PageLength);

        DebugPrintEx(   DEBUG_MSG,
                        "TextID: Code=%d Len=%d Id=%s",
                        lpbc->wTextEncoding, 
                        lpbc->wTextIdLen, 
                        (LPSTR)(lpbc->wszTextId ? OffToLP(lpbc, wszTextId) : "none") );

        DebugPrintEx(   DEBUG_MSG,
                        "NSS: l=%d n=%d vMsg=%d vInter=%d",
                        lpbc->NSS.GroupLength, 
                        lpbc->NSS.GroupNum,
                        lpbc->NSS.vMsgProtocol, 
                        lpbc->NSS.vInteractive);

        DebugPrintEx(   DEBUG_MSG,
                        "Image: len=%d num=%d Poll: len=%d num=%d fHi=%d fLo=%d",
                        lpbc->Image.GroupLength, 
                        lpbc->Image.GroupNum,
                        lpbc->PollCaps.GroupLength, 
                        lpbc->PollCaps.GroupNum,
                        lpbc->PollCaps.fHighSpeedPoll, 
                        lpbc->PollCaps.fLowSpeedPoll);
#ifdef NOCHALL
        DebugPrintEx(   DEBUG_MSG,
                        "PollReq: num=%d",
                        lpbc->wNumPollReq);
#else
        DebugPrintEx(   DEBUG_MSG,
                        "PollReq: num=%d ChallLen=%d",
                        lpbc->wNumPollReq, 
                        lpbc->wChallengeLen);
#endif

        for(i=0; i<(int)lpbc->wNumPollReq && i<MAXNSCPOLLREQ; i++)
        {
            LPBCPOLLREQ lp = (LPBCPOLLREQ)OffToLP(lpbc, rgwPollReq[i]);

            DebugPrintEx(   DEBUG_MSG,
                            "PollReq[%d]: len=%d num=%d fRet=%d type=%d Title=%s",
                            i, 
                            lp->GroupLength, 
                            lp->GroupNum, 
                            lp->fReturnControl, 
                            lp->PollType,
                            (LPSTR)(lp->b) );
        }
  }
  if(lpll)
  {
        BG_CHK(szll);
        DebugPrintEx(   DEBUG_MSG,
                        "%s: Baud=%x MinScan=%x ECM=%d 64=%d",
                        (LPSTR)szll,
                        lpll->Baud, 
                        lpll->MinScan, 
                        lpll->fECM, 
                        lpll->fECM64);
  }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\protocol.h ===
/***************************************************************************
 Name     :     PROTOCOL.H
 Comment  :     Data structure definitionc for protocol DLL

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include <fr.h>
#include "oemint.h"

/************************************
        This structure is meant to track the Group-3 FIF for DIS and DTC
        frames. The FIF is arranged so that the bits are numbered from
        1 upward in teh order they are received. Since Modem/Comm
        behaviour puts received bits in a byte from low to high
        and the bytes into memory at increasing addresses, the bits
        need to run in memory from lowest bit of first byte through
        the highest bit and then on to the next address.

        Need to watch out for sudden reversal of the high-low order
        of bits and of bytes.

        The MS C7 compiler puts bit-fields into BYTES from low
        to high, so this should correspond. Don't change the BYTEs
        below to WORD as then we'll run into high-low byte flipping
        nonsense.

        If a bit-field crosses a byte boundary we're in trouble.
*************************************/

#define fsFreePtr(pTG, npfs)         ((npfs)->b + (npfs)->uFreeSpaceOff)
#define fsFreeSpace(pTG, npfs)       (sizeof((npfs)->b) - (npfs)->uFreeSpaceOff)
#define fsStart(pTG, npfs)           ((npfs)->b)
#define fsLim(pTG, npfs)                     (((npfs)->b) + sizeof((npfs)->b))
#define fsSize(pTG, npfs)            (sizeof((npfs)->b))


#define BAUD_MASK               0xF             // 4 bits wide
#define WIDTH_SHIFT             4               // next item must be 2^this
#define WIDTH_MASK              0xF3    // top 4 and bottom 3
#define LENGTH_MASK             0x3

#define MINSCAN_SUPER_HALF      8
#define MINSCAN_MASK    0xF                     // actually 4 bits wide too











#ifdef UECM
#       define  NONEFAXECM      1
#else
#       define  NONEFAXECM      0
#endif


#define ZeroRFS(pTG, lp)     _fmemset(lp, 0, sizeof(RFS))


/****************** begin prototypes from sendfr.c *****************/
VOID BCtoNSFCSIDIS(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll);
VOID BCtoNSCCIGDTC(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll);
// void CreateSEPPWDFrames(NPRFS npfs, NPBC npbc);
void CreateNSForNSCorNSS(PThrdGlbl pTG, IFR ifr, NPRFS npfs, NPBC npbc, BOOL fSendID);
void CreateIDFrame(PThrdGlbl pTG, IFR ifr, NPRFS npfs, LPSTR, BOOL fStrip);
void CreateDISorDTC(PThrdGlbl pTG, IFR ifr, NPRFS npfs, NPBCFAX npbcFax, NPLLPARAMS npll);
VOID CreateNSSTSIDCS(PThrdGlbl pTG, NPPROT npProt, NPRFS npfs, USHORT uWhichDCS);
VOID CreateNSS(PThrdGlbl pTG, NPRFS npfs, NPBCSTD npbcStd);
void CreateDCS(PThrdGlbl pTG, NPRFS, NPBCFAX npbcFax, NPLLPARAMS npll);
/***************** end of prototypes from sendfr.c *****************/


/****************** begin prototypes from recvfr.c *****************/
BOOL AwaitSendParamsAndDoNegot(PThrdGlbl pTG, BOOL fSleep);
void GotRecvCaps(PThrdGlbl pTG);
void GotPollReq(PThrdGlbl pTG);
void GotRecvParams(PThrdGlbl pTG);
void AddNumIdToBC(PThrdGlbl pTG, LPSTR szId, LPBC lpbc, USHORT uMaxSize, BOOL fForce);
/***************** end of prototypes from recvfr.c *****************/

/****************** begin prototypes from dis.c *****************/
USHORT SetupDISorDCSorDTC(PThrdGlbl pTG, NPDIS npdis, NPBCFAX npbcFax, NPLLPARAMS npll, BOOL fECM, BOOL f64);
void ParseDISorDCSorDTC(PThrdGlbl pTG, NPDIS npDIS, NPBCFAX npbcFax, NPLLPARAMS npll, BOOL fParams);
USHORT MinScanToBytesPerLine(PThrdGlbl pTG, BYTE Minscan, BYTE Baud);
void NegotiateLowLevelParams(PThrdGlbl pTG, NPLLPARAMS npllRecv, NPLLPARAMS npllSend, DWORD AwRes, USHORT uEnc, NPLLPARAMS npllNegot);
USHORT GetStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2);
void CreateStupidReversedFIFs(PThrdGlbl pTG, LPSTR lpstr1, LPSTR lpstr2);
BOOL DropSendSpeed(PThrdGlbl pTG);
USHORT CopyFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr, USHORT uSize);
void CopyRevIDFrame(PThrdGlbl pTG, LPBYTE lpbDst, LPFR lpfr);
void EnforceMaxSpeed(PThrdGlbl pTG);

BOOL AreDCSParametersOKforDIS(LPDIS sendDIS, LPDIS recvdDCS);
/***************** end of prototypes from dis.c *****************/




/****************** begin prototypes from whatnext.c *****************/
ET30ACTION  __cdecl FAR WhatNext(PThrdGlbl pTG, ET30EVENT event,
                                                                WORD wArg1, DWORD_PTR lArg2, DWORD_PTR lArg3);
/***************** end of prototypes from whatnext.c *****************/


/****************** begin prototypes from protapi.c *****************/
void GetRecvPageAck(PThrdGlbl pTG);
/****************** end of prototypes from protapi.c *****************/

/****************** begin prototypes from oem.c *****************/
#ifdef OEMNSF
        WORD CreateOEMFrames(pTG, IFR ifr, WORD pos, NPBC npbcIn, NPLLPARAMS npllIn, NPRFS npfs);
#else
#       define CreateOEMFrames(pTG, ifr, pos, npbcIn, npllIn, npfs) (0)
#endif

/****************** end prototypes from oem.c *****************/


/**--------------------------- Debugging ------------------------**/

#define SZMOD                   "Eprot: "

#ifdef DEBUG
        extern DBGPARAM dpCurSettings;

#       define ZONE_PROTAPI             ((1L << 6) & dpCurSettings.ulZoneMask)
#       define ZONE_WHATNEXT    ((1L << 7) & dpCurSettings.ulZoneMask)
#       define ZONE_DIS                 ((1L << 8) & dpCurSettings.ulZoneMask)
#       define ZONE_RECVFR              ((1L << 9) & dpCurSettings.ulZoneMask)
#       define ZONE_SENDFR              ((1L << 10) & dpCurSettings.ulZoneMask)
#       define ZONE_OEM                 ((1L << 11) & dpCurSettings.ulZoneMask)
        extern void D_PrintBC(LPBC lpbc, LPSTR lpsz, LPLLPARAMS lpll);
#else
#       define D_PrintBC(x, y, z)
#endif



#define MODID                           MODID_AWT30

#define FILEID_DIS                      31
#define FILEID_PROTAPI          32
#define FILEID_RECVFR           33
#define FILEID_SENDFR           34
#define FILEID_WHATNEXT         35
#define FILEID_OEMNSF           36


#ifdef NSF_TEST_HOOKS

#       define BC_TO_NSX(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw) \
                ((NSFTestGetNSx(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw)) \
                 ? 0 : BCtoNSx(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw))

#       define NSX_TO_BC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC)\
                (NSFTestPutNSx(pTG, _ifr, _lpfr, _wcbfr, _npbc,  _wcbBC), \
                 NSxtoBC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC))

        BOOL NSFTestGetNSx (PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                                        LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame);
        BOOL NSFTestPutNSx(PThrdGlbl pTG, IFR ifr, LPLPFR rglpfr, WORD wNumFrame,
                                                LPBC lpbcOut, WORD wBCSize);

#else // !NSF_TEST_HOOKS

#       define BC_TO_NSX(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw) \
                 BCtoNSx(pTG, _ifr, _npbc, _ptr, _wcb,  _lpw)

#       define NSX_TO_BC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC)\
                 NSxtoBC(pTG, _ifr, _lpfr, _wcbfr, _npbc, _wcbBC)

#endif // !NSF_TEST_HOOKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\registry.c ===
/***************************************************************************
 Name     :     REGISTRY.C
 Comment  :     INIfile handling

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"


#include "debug.h"
#include "glbproto.h"
#include "faxreg.h"
             
             
             
#ifdef USE_REGISTRY
// The default database to us
#       define DATABASE_KEY   HKEY_LOCAL_MACHINE

        // These are NOT localizable items.
#       define szKEYPREFIX REGKEY_TAPIDEVICES
#       define szKEYCLASS  "DATA"
DWORD my_atoul(LPSTR lpsz);
#else   // !USE_REGISTRY
        BOOL expand_key(DWORD dwKey, LPSTR FAR *lplpszKey,
                                                LPSTR FAR *lplpszProfileName);
#endif  // !USE_REGISTRY


ULONG_PTR ProfileOpen(DWORD dwProfileID, LPSTR lpszSection, DWORD dwFlags)
{
    ULONG_PTR dwRet = 0;

#ifdef USE_REGISTRY
    char rgchKey[128];
    HKEY hKey=0;
    HKEY hBaseKey = DATABASE_KEY;
    LONG l;
    LPSTR lpszPrefix;
    DWORD sam=0;
    BG_CHK(sizeof(hKey)<=sizeof(ULONG_PTR));

    if (dwProfileID==OEM_BASEKEY)
    {
        hBaseKey = HKEY_LOCAL_MACHINE;
        lpszPrefix= ""; // we don't prepend szKEYPREFIX
        if (!lpszSection) goto failure;
    }
    else if (lpszSection)
    {
        lpszPrefix= szKEYPREFIX "\\";
    }
    else
    {
        lpszPrefix= szKEYPREFIX;
        lpszSection="";
    }

    if ((lstrlen(lpszPrefix)+lstrlen(lpszSection))>=sizeof(rgchKey))
            goto failure;
    lstrcpy(rgchKey, lpszPrefix);
    lstrcat(rgchKey, lpszSection);

    sam = 0;
    if (dwFlags &fREG_READ) sam |= KEY_READ;
    if (dwFlags &fREG_WRITE) sam |= KEY_WRITE;

    if (dwFlags & fREG_CREATE)
    {
        DWORD dwDisposition=0;
        DWORD dwOptions = (dwFlags & fREG_VOLATILE)
                            ?REG_OPTION_VOLATILE
                            :REG_OPTION_NON_VOLATILE;
        sam = KEY_READ | KEY_WRITE; // we force sam to this when creating.
        l = RegCreateKeyEx(
                           hBaseKey,        //  handle of open key
                           rgchKey,                     //  address of name of subkey to open
                           0,               //  reserved
                           szKEYCLASS,      //  address of class string
                           dwOptions,           // special options flag
                           sam,                         // desired security access
                           NULL,            // address of key security structure
                           &hKey,           // address of buffer for opened handle
                           &dwDisposition       // address of dispostion value buffer
                   );
    }
    else
    {
        l = RegOpenKeyEx(
                           hBaseKey,            //  handle of open key
                           rgchKey,                             //  address of name of subkey to open
                           0,                   //  reserved
                           sam ,                        // desired security access
                           &hKey                // address of buffer for opened handle
                   );
    }

    if (l!=ERROR_SUCCESS)
    {
        //LOG((_ERR, "RegCreateKeyEx returns error %ld\n", (long) l));
        goto failure;
    }

    dwRet = (ULONG_PTR) hKey;

#else   // !USE_REGISTRY

        LPSTR lpszFile= szINIFILE;
        ATOM aSection, aProfile;

        // NULL lpszSection not supported.
        if (!lpszSection) goto failure;

        if (!(aSection = GlobalAddAtom(lpszSection)))
                goto failure;
        if (!(aProfile = GlobalAddAtom(lpszFile)))
                {GlobalDeleteAtom(aSection); goto failure;}
        dwRet = MAKELONG(aSection, aProfile);

#endif  // !USE_REGISTRY

    BG_CHK(dwRet);
    return dwRet;

failure:
    return 0;
}

UINT   
ProfileListGetInt
(
    ULONG_PTR  KeyList[10],
    LPSTR     lpszValueName,
    UINT      uDefault
)          
{
    int       i;
    int       Num=0;
    UINT      uRet = uDefault;
    BOOL      fExist = 0;

    for (i=0; i<10; i++) 
    {
        if (KeyList[i] == 0)
        {
            Num = i-1;
            break;
        }
    }

    for (i=Num; i>=0; i--)  
    {
        uRet = ProfileGetInt (KeyList[i], lpszValueName, uDefault, &fExist);
        if (fExist) 
        {
            return uRet;
        }
    }

    return uRet;
}

UINT ProfileGetInt(ULONG_PTR dwKey, LPSTR lpszValueName, UINT uDefault, BOOL *fExist)
{
    UINT uRet = uDefault;
    char rgchBuf[128];
    DWORD dwType;
    DWORD dwcbSize=sizeof(rgchBuf);
    LONG l = RegQueryValueEx(
            (HKEY) dwKey,
            lpszValueName,
            0,
            &dwType,
            rgchBuf,
            &dwcbSize);

    if (fExist) 
    {
        *fExist = 0;
    }

    if (l!=ERROR_SUCCESS)
    {
            //LOG((_ERR, "RegQueryValueEx returned error %ld\n", (long) l));
            goto end;
    }

    if (fExist) 
    {
        *fExist = 1;
    }

    if (dwType != REG_SZ)
    {
            //LOG((_ERR, "RegQueryValueEx value type not string:0x%lx\n",
            //                       (unsigned long) dwType));
            goto end;
    }
    uRet = (UINT) my_atoul(rgchBuf);

end:
    return uRet;
}

DWORD   ProfileGetString
(
    ULONG_PTR dwKey, 
    LPSTR lpszValueName,
    LPSTR lpszDefault, 
    LPSTR lpszBuf , 
    DWORD dwcbMax
)
{
    DWORD dwRet = 0;

#ifdef USE_REGISTRY
    DWORD dwType;
    LONG l = RegQueryValueEx(
            (HKEY) dwKey,
            lpszValueName,
            0,
            &dwType,
            lpszBuf,
            &dwcbMax);

    if (l!=ERROR_SUCCESS)
    {
            //LOG((_ERR, "RegQueryValueEx returned error %ld\n", (long) l));
            goto copy_default;
    }

    if (dwType != REG_SZ)
    {
            //LOG((_ERR, "RegQueryValueEx value type not string:0x%lx\n",
                    //               (unsigned long) dwType));
            goto copy_default;
    }

    // Make sure we null-terminate the string and return the true string
    // length..
    if (dwcbMax) 
    {
        lpszBuf[dwcbMax-1]=0; 
        dwcbMax = (DWORD) lstrlen(lpszBuf);
    }
    dwRet = dwcbMax;
    goto end;

#else   // USE_REGISTRY

    LPSTR lpszKey;
    LPSTR lpszProfileName;
    if (!expand_key(dwKey, &lpszKey, &lpszProfileName)) 
        goto copy_default;

    dwRet = GetPrivateProfileString(lpszKey, lpszValueName,
            lpszDefault, lpszBuf , (INT) dwcbMax,
            lpszProfileName);
    goto end;

#endif // USE_REGISTRY

    BG_CHK(FALSE);

copy_default:

    dwRet = 0;
    if (!lpszDefault || !*lpszDefault)
    {
        if (dwcbMax) *lpszBuf=0;
    }
    else
    {
        UINT cb = _fstrlen(lpszDefault)+1;
        if (cb>(UINT)dwcbMax) cb=dwcbMax;
        if (cb)
        {
            _fmemcpy(lpszBuf, lpszDefault, cb);
            lpszBuf[cb-1]=0;
            dwRet = cb-1;
        }
    }
    // fall through...

end:
    return dwRet;
}

BOOL   
ProfileWriteString
(
    ULONG_PTR dwKey,
    LPSTR lpszValueName,
    LPSTR lpszBuf,
    BOOL  fRemoveCR
)
{
        // NOTE: If lpszValueName is null, delete the key. (can't do this in,
        //                              the registry, unfortunately).
        //           If lpszBuf is null pointer -- "delete" this value.
        BOOL fRet=FALSE;

#ifdef USE_REGISTRY
        LONG l;
        if (!lpszValueName) 
            goto end;

        if (!lpszBuf)
        {
            // delete value...
            l = RegDeleteValue((HKEY) dwKey, lpszValueName);
            if (l!=ERROR_SUCCESS) goto end;
        }
        else
        {
            if (fRemoveCR) 
            {
               RemoveCR (lpszBuf);
            }

            l = RegSetValueEx((HKEY) dwKey, lpszValueName, 0, REG_SZ,
                                    lpszBuf, lstrlen(lpszBuf)+1);
            if (l!=ERROR_SUCCESS)
            {
                //LOG((_ERR,
                //      "RegSetValueEx(\"%s\", \"%s\") returned error %ld\n",
                //              (LPSTR) lpszValueName,
                //              (LPSTR) lpszBuf,
                //              (long) l));
                goto end;
            }
        }
        fRet = TRUE;
        goto end;

#else   // !USE_REGISTRY
        LPSTR lpszKey;
        LPSTR lpszProfileName;
        if (!expand_key(dwKey, &lpszKey, &lpszProfileName)) goto end;

        fRet = WritePrivateProfileString(lpszKey, lpszValueName,
                                                lpszBuf, lpszProfileName);
        goto end;
#endif  // !USE_REGISTRY

        BG_CHK(FALSE);

end:
        return fRet;
}

void ProfileClose(ULONG_PTR dwKey)
{
#ifdef USE_REGISTRY
    if (RegCloseKey((HKEY)dwKey)!=ERROR_SUCCESS)
    {
        //LOG((_WRN, "Couldn't close registry key:%lu\n\r",
        //      (unsigned long) dwKey));
    }
#else
        BG_CHK(LOWORD(dwKey)); GlobalDeleteAtom(LOWORD(dwKey));
        BG_CHK(HIWORD(dwKey)); GlobalDeleteAtom(HIWORD(dwKey));
#endif
}

BOOL ProfileDeleteSection(DWORD dwProfileID, LPSTR lpszSection)
{

#ifdef USE_REGISTRY
    char rgchKey[128];
    LPSTR lpszPrefix= szKEYPREFIX "\\";

    if (dwProfileID==OEM_BASEKEY) goto failure; // Can't delete this

    if ((lstrlen(lpszPrefix)+lstrlen(lpszSection))>=sizeof(rgchKey))
            goto failure;
    lstrcpy(rgchKey, lpszPrefix);
    lstrcat(rgchKey, lpszSection);

    return (RegDeleteKey(DATABASE_KEY, rgchKey)==ERROR_SUCCESS);

failure:
    return FALSE;

#else   // !USE_REGISTRY

    return WritePrivateProfileString(lpszSection, NULL, NULL, szINIFILE);

#endif  // !USE_REGISTRY
}

BOOL 
ProfileCopyTree
(
    DWORD dwProfileIDTo,
    LPSTR lpszSectionTo,
    DWORD dwProfileIDFr,
    LPSTR lpszSectionFr
)
{
    BOOL    fRet=TRUE;
    char    SecTo[200];
    char    SecFr[200];

    //
    //  Since there is no CopyKeyWithAllSubkeys API, it is difficult to write generic tree-walking algorithm.
    //  We will hard-code the keys here.
    //
    
    // copy Fax key always

    ProfileCopySection(dwProfileIDTo,
                       lpszSectionTo,
                       dwProfileIDFr,
                       lpszSectionFr,
                       TRUE);

    
    // copy Fax/Class1 key if exists

    sprintf(SecTo, "%s\\Class1", lpszSectionTo);
    sprintf(SecFr, "%s\\Class1", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);

    // copy Fax/Class1/AdaptiveAnswer key if exists

    sprintf(SecTo, "%s\\Class1\\AdaptiveAnswer", lpszSectionTo);
    sprintf(SecFr, "%s\\Class1\\AdaptiveAnswer", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);


    // copy Fax/Class1/AdaptiveAnswer/Answer key if exists

    sprintf(SecTo, "%s\\Class1\\AdaptiveAnswer\\AnswerCommand", lpszSectionTo);
    sprintf(SecFr, "%s\\Class1\\AdaptiveAnswer\\AnswerCommand", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);

    // copy Fax/Class2 key if exists

    sprintf(SecTo, "%s\\Class2", lpszSectionTo);
    sprintf(SecFr, "%s\\Class2", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);


    // copy Fax/Class2/AdaptiveAnswer key if exists

    sprintf(SecTo, "%s\\Class2\\AdaptiveAnswer", lpszSectionTo);
    sprintf(SecFr, "%s\\Class2\\AdaptiveAnswer", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);


    // copy Fax/Class2/AdaptiveAnswer/Answer key if exists

    sprintf(SecTo, "%s\\Class2\\AdaptiveAnswer\\AnswerCommand", lpszSectionTo);
    sprintf(SecFr, "%s\\Class2\\AdaptiveAnswer\\AnswerCommand", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);

    // copy Fax/Class2_0 key if exists

    sprintf(SecTo, "%s\\Class2_0", lpszSectionTo);
    sprintf(SecFr, "%s\\Class2_0", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);

    // copy Fax/Class2_0/AdaptiveAnswer key if exists

    sprintf(SecTo, "%s\\Class2_0\\AdaptiveAnswer", lpszSectionTo);
    sprintf(SecFr, "%s\\Class2_0\\AdaptiveAnswer", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);


    // copy Fax/Class2/AdaptiveAnswer/Answer key if exists

    sprintf(SecTo, "%s\\Class2_0\\AdaptiveAnswer\\AnswerCommand", lpszSectionTo);
    sprintf(SecFr, "%s\\Class2_0\\AdaptiveAnswer\\AnswerCommand", lpszSectionFr);

    ProfileCopySection(dwProfileIDTo,
                       SecTo,
                       dwProfileIDFr,
                       SecFr,
                       FALSE);

   
    return fRet;
}

BOOL   
ProfileCopySection
(
      DWORD   dwProfileIDTo,
      LPSTR   lpszSectionTo,  
      DWORD   dwProfileIDFr,
      LPSTR   lpszSectionFr,
      BOOL    fCreateAlways
)
{

    BOOL    fRet=FALSE;
    DWORD   iValue=0;
    DWORD   cbValue, cbData, dwType;
    char    rgchValue[60], rgchData[256];
    HKEY    hkFr;
    HKEY    hkTo; 
     
    hkFr = (HKEY) ProfileOpen(dwProfileIDFr, lpszSectionFr, fREG_READ);

    if ( (!hkFr) && (!fCreateAlways) ) 
    {
       return fRet;
    }


    hkTo = (HKEY) ProfileOpen(  dwProfileIDTo, 
                                lpszSectionTo,
                                fREG_CREATE |fREG_READ|fREG_WRITE);

    if (!hkTo || !hkFr) 
        goto end;

    iValue=0;
    dwType=0;
    cbValue=sizeof(rgchValue);
    cbData=sizeof(rgchData);
    while(  RegEnumValue(   hkFr, 
                            iValue, 
                            rgchValue, 
                            &cbValue,
                            NULL, 
                            &dwType, 
                            rgchData, 
                            &cbData)==ERROR_SUCCESS)
    {
        if (RegQueryValueEx(    hkFr, 
                                rgchValue, 
                                NULL, 
                                &dwType, 
                                rgchData, 
                                &cbData)==ERROR_SUCCESS)
        {
            if (RegSetValueEx(  hkTo, 
                                rgchValue, 
                                0, 
                                dwType, 
                                rgchData, 
                                cbData)== ERROR_SUCCESS)
            {
                fRet=TRUE;
            }
        }
        iValue++;dwType=0;cbValue=sizeof(rgchValue);cbData=sizeof(rgchData);
    }

end:
    if (hkTo) RegCloseKey(hkTo);
    if (hkFr) RegCloseKey(hkFr);
    return fRet;

}

DWORD ProfileGetData
(
    ULONG_PTR dwKey, 
    LPSTR lpszValueName,
    LPBYTE lpbBuf,
    DWORD dwcbMax
)
{
#ifndef USE_REGISTRY
    return 0;
#else   // USE_REGISTRY
    DWORD dwType;
    LONG l = RegQueryValueEx(   (HKEY) dwKey,
                                lpszValueName,
                                0,
                                &dwType,
                                lpbBuf,
                                &dwcbMax);

    if (l!=ERROR_SUCCESS)
    {
        //LOG((_ERR, "RegQueryValueEx returned error %ld\n", (long) l));
        goto copy_default;
    }

    if (dwType != REG_BINARY)
    {
        goto copy_default;
    }

    return dwcbMax;

copy_default:
        return 0;

#endif  // USE_REGISTRY
}

BOOL ProfileWriteData
(
    ULONG_PTR dwKey, 
    LPSTR lpszValueName,
    LPBYTE lpbBuf, 
    DWORD dwcb
)
{
#ifndef USE_REGISTRY
    return 0;
#else   // USE_REGISTRY
    LONG l = ~(ERROR_SUCCESS);
    if (!lpszValueName) goto end;

    if (!lpbBuf)
    {
        // delete value...
        l = RegDeleteValue((HKEY) dwKey, lpszValueName);
    }
    else
    {
        l = RegSetValueEx(  (HKEY) dwKey, 
                            lpszValueName, 
                            0, 
                            REG_BINARY,
                            lpbBuf, 
                            dwcb);
    }

end:
    return (l==ERROR_SUCCESS);
#endif  // USE_REGISTRY
}

#ifdef USE_REGISTRY
DWORD my_atoul(LPSTR lpsz)
{
    unsigned i=8, c;
    unsigned long ul=0;
    while(i-- && (c=*lpsz++)) {
        ul*=10;
    switch(c) {
        case '0': break;
        case '1':ul+=1; break;
        case '2':ul+=2; break;
        case '3':ul+=3; break;
        case '4':ul+=4; break;
        case '5':ul+=5; break;
        case '6':ul+=6; break;
        case '7':ul+=7; break;
        case '8':ul+=8; break;
        case '9':ul+=9; break;
        default: goto end;
        }
    }
end:
    return ul;

}
#endif // USE_REGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\recvfr.c ===
/***************************************************************************
 Name     :     RECVFR.C
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"
#include "efaxcb.h"
#include "protocol.h"

///RSL
#include "glbproto.h"

// not called - this is dead code.
USHORT FindMSNSx(PThrdGlbl pTG, NPRFS npRecvd)
{
    USHORT  i;
    
    DEBUG_FUNCTION_NAME(("FindMSNSx"));

    for(i=0; i<npRecvd->uNumFrames; i++)
    {
        BG_CHK(i < MAXFRAMES);
        if(IsAtWorkNSx(npRecvd->rglpfr[i]->fif, npRecvd->rglpfr[i]->cb))
        {
            DebugPrintEx(DEBUG_MSG,"Found MS NSx!!");
            return i+1;
        }
    }
    return 0;
}

void GotRecvFrames
(
    PThrdGlbl pTG, 
    IFR ifr, 
    NPRFS npRecvd, 
    NPDIS npdis, 
    LPBYTE lpbRecvdID,
    LPBYTE lpbRecipSubAddr, 
    BCTYPE bctype, 
    NPBC npbc, 
    USHORT wBCSize,
    NPLLPARAMS npll
)
{
    USHORT uRet1=0, uRet2=0;

    DEBUG_FUNCTION_NAME(_T("GotRecvFrames"));

    InitBC(npbc, wBCSize, bctype);

    // RSL remove NSF processing.
    uRet1 = 0;

    if(npRecvd->uNumFrames) // recvd some NSXs
    {
        // scope out NSXs
        if(uRet1)                  // RSL = FindMSNSx(pTG, npRecvd))
        {
            // found MS NSXs
            BG_CHK((ifr!=ifrNSF) ? (pTG->ProtInst.llSendCaps.fECM && uRet1==1) : TRUE);
            // if we got MS NSCs or NSSs then we must be able to do ECM
            // and we can't get can't get other peoples NSSs/NSCs at same time

            // setup BC first
            npbc->bctype = bctype;

            // all short ptrs into DGROUP get correctly cast to LPs we hope...
            if(uRet2 = NSX_TO_BC(pTG, ifr, npRecvd->rglpfr, npRecvd->uNumFrames, npbc, wBCSize))
            {
                DebugPrintEx(   DEBUG_ERR,
                                "got error %d parsing NSX",
                                uRet2);
                // forget we got an NSX
                // zero out BC again
                InitBC( npbc, wBCSize, bctype);
                uRet1 = 0;
            }
#ifndef NOCHALL
            else
            {
                if(ifr==ifrNSF)
                {
                    USHORT uChallLen;
                    // Poll challenge string is the first POLL_CHALLENGE_LEN
                    // bytes (following the B5 00 76 signature) of the first
                    // MS NSF _received_ or the whole thing if it is shorter
                    // than that
                    BG_CHK(npRecvd->rglpfr[uRet1-1]->cb > 3);
                    uChallLen = min(npRecvd->rglpfr[uRet1-1]->cb-3, POLL_CHALLENGE_LEN);
                    AppendToBCLen( npbc, wBCSize, npRecvd->rglpfr[uRet1-1]->fif+3,
                                            uChallLen, wChallenge, wChallengeLen);
                }
                else if(ifr==ifrNSC)
                {
                    // for NSC append _our_ challenge string, i.e.
                    // first POLL_CHALLENGE_LEN bytes (following the B5 00 76
                    // signature) of the first MS NSF that _we_sent_out
                    // or the whole thing if it is shorter than that

                    AppendToBCLen(npbc, wBCSize, pTG->bSavedChallenge,
                            pTG->uSavedChallengeLen, wChallenge, wChallengeLen);
                }
                // for NSS wChallenge==NULL
            }
#endif //!NOCHALL
        }
#ifdef OEMNSF
        else if(wOEMFlags && lpfnOEMNSxToBC)
        {
#pragma message("WARNING: OEMNsxToBC: The code here for removing and restoring the FCS bytes hasn't been tested!!!")
            USHORT uRet3;
            USHORT iFrame;
                    // OEM NSX DLL exists --> do something  for(iFrame=0; iFrame<wNumFrame; iFrame++)

            for(iFrame=0; iFrame < npRecvd->uNumFrames; iFrame++)
                  npRecvd->rglpfr[iFrame]->cb -= 2;     // Subtract 2 to lop off the FCS

            if(!(uRet3 = lpfnOEMNSxToBC(ifr, npRecvd->rglpfr, npRecvd->uNumFrames, npbc, wBCSize, npll)))
            {
        //It might be a modem that doesn't pass us the FCS, try again
                for(iFrame=0; iFrame < npRecvd->uNumFrames; iFrame++)
                             npRecvd->rglpfr[iFrame]->cb += 2;     // Put  last two bytes back on
                            // zero out BC again
                InitBC(pTG, npbc, wBCSize, bctype);
                if(!(uRet3 = lpfnOEMNSxToBC(ifr, npRecvd->rglpfr, npRecvd->uNumFrames, npbc, wBCSize, npll)))
                {
                    DebugPrintEx(DEBUG_ERR,"got error parsing OEM NSF");
                    // zero out BC again
                    InitBC(pTG, npbc, wBCSize, bctype);
                }
            }
            else
            {
                DebugPrintEx(DEBUG_MSG,"Using OEM Protocol");
                fUsingOEMProt = TRUE;
                if(uRet3 & OEMNSF_IGNORE_DIS)
                        npdis = NULL;
                if(uRet3 & OEMNSF_IGNORE_CSI)
                        lpbRecvdID = NULL;
            }
        }
#endif
    }

    if(npdis)
    {
        // extract DIS caps     into BC and LL
        // Here we parse the DCS we got into npbc {= (NPBC)&pTG->ProtInst.RecvParams}
        ParseDISorDCSorDTC(pTG, npdis, &(npbc->Fax), npll, (ifr==ifrNSS ? TRUE : FALSE));
    }

    // If an ID is recvd in NSF/NSS/NSC the CSI/TSI/CIG should NOT overwrite it
    if(lpbRecvdID && !HasTextId(npbc))
    {
        PutTextId(npbc, wBCSize, lpbRecvdID, (int)_fstrlen(lpbRecvdID), TEXTCODE_ASCII);
        //PutNumId(npbc, wBCSize, lpbRecvdID, (int) _fstrlen(lpbRecvdID), TEXTCODE_ASCII);
    }

    // If a subaddress is recvd in NSF/NSS/NSC the SUB frame should NOT overwrite it
    if(lpbRecipSubAddr && !HasRecipSubAddr( npbc))
    {
        PutRecipSubAddr( npbc, wBCSize, lpbRecipSubAddr, (int)_fstrlen(lpbRecipSubAddr));
    }


    if(uRet1 > 0)
    {
        npll->fECM = TRUE;      // ignore ECM bit in DIS, if MS NSF present
    }
}

BOOL AwaitSendParamsAndDoNegot(PThrdGlbl pTG, BOOL fSleep)
{
    // This does actual negotiation & gets SENDPARAMS. It could potentially
    // return SEND_POLLREQ instead.

    DEBUG_FUNCTION_NAME(_T("AwaitSendParamsAndDoNegot"));

    if(!ProtGetBC(pTG, SEND_PARAMS, fSleep))
    {
        if(fSleep)
        {
            // ICommFailureCode already set
            DebugPrintEx(DEBUG_WRN,"ATTENTION: pTG->ProtInst.fAbort = TRUE");
            pTG->ProtInst.fAbort = TRUE;
        }
        return FALSE;
    }

    // negotiate low-level params here. (a) because this is where
    // high-level params are negotiated (b) because it's inefficient to
    // do it on each DCS (c) because RTN breaks otherwise--see bug#731

    // llRecvCaps and llSendParams are set only at startup
    // SendParams are set in ProtGetBC just above
    // llNegot is the return value. So this can be called
    // only at the end of this function

    // negot lowlevel params if we are sending and not polling
    if(!pTG->ProtInst.fAbort && pTG->ProtInst.fSendParamsInited)
    {
        NegotiateLowLevelParams(    pTG, 
                                    &pTG->ProtInst.llRecvCaps, 
                                    &pTG->ProtInst.llSendParams,
                                    pTG->ProtInst.SendParams.Fax.AwRes,
                                    pTG->ProtInst.SendParams.Fax.Encoding,
                                    &pTG->ProtInst.llNegot);

        pTG->ProtInst.fllNegotiated = TRUE;

        // This chnages llNegot->Baud according to the MaxSpeed settings
        EnforceMaxSpeed(pTG);
    }
    return TRUE;
}

void GotRecvCaps(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("GotRecvCaps"));

    BG_CHK(pTG->ProtInst.fRecvdDIS);

    if(!pTG->ProtInst.llSendParams.fECM)
    {
        // if we can't do ECM on send, ignore the received NSFs
        // zap the ECM bits of the received DTC
        pTG->ProtInst.RemoteDIS.ECM = 0;
        pTG->ProtInst.RemoteDIS.SmallFrame = 0;
    }

    GotRecvFrames(  pTG, 
                    ifrNSF, 
                    &pTG->ProtInst.RecvdNS,
                    (pTG->ProtInst.fRecvdDIS ? &pTG->ProtInst.RemoteDIS : NULL),
                    (pTG->ProtInst.fRecvdID  ?  pTG->ProtInst.bRemoteID : NULL),
                    (pTG->ProtInst.fRecvdSUB ?  pTG->ProtInst.bRecipSubAddr : NULL),
                    RECV_CAPS, 
                    (NPBC)&pTG->ProtInst.RecvCaps, 
                    sizeof(pTG->ProtInst.RecvCaps),
                    &pTG->ProtInst.llRecvCaps);

    pTG->ProtInst.fRecvCapsGot = TRUE;
    pTG->ProtInst.fllRecvCapsGot = TRUE;

#ifdef FILET30
    // Send up raw caps.
    ICommRawCaps(   pTG,
                    (LPBYTE) (pTG->ProtInst.fRecvdID ?  pTG->ProtInst.bRemoteID: NULL),
                    (LPBYTE) (pTG->ProtInst.fRecvdDIS ? (LPBYTE) (&(pTG->ProtInst.RemoteDIS)):NULL),
                    (USHORT) (pTG->ProtInst.fRecvdDIS ? pTG->ProtInst.uRemoteDISlen:0),
                    (LPFR FAR *) (pTG->ProtInst.RecvdNS.uNumFrames ? pTG->ProtInst.RecvdNS.rglpfr:NULL),
                    (USHORT) (pTG->ProtInst.RecvdNS.uNumFrames));

#endif

    // send off BC struct to higher level
    if(!ICommRecvCaps(pTG, (LPBC)&pTG->ProtInst.RecvCaps))
    {
        // ICommFailureCode already set
        DebugPrintEx(DEBUG_WRN,"ATTENTION:pTG->ProtInst.fAbort = TRUE");
        pTG->ProtInst.fAbort = TRUE;
    }

    // This need to be moved into whatnext.NodeA so that we can set
    // param to FALSE (no sleep) and do the stall thing
    AwaitSendParamsAndDoNegot(pTG, TRUE);
}

void GotPollReq(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("GotPollReq"));

    BG_CHK(pTG->ProtInst.fRecvdDTC);

    if(!pTG->ProtInst.llSendParams.fECM)
    {
        // if we can't do ECM on send, ignore the received NSFs
        // zap the ECM bits of the received DTC
        pTG->ProtInst.RemoteDTC.ECM = 0;
        pTG->ProtInst.RemoteDTC.SmallFrame = 0;
    }

    GotRecvFrames(  pTG, 
                    ifrNSC, 
                    &pTG->ProtInst.RecvdNS,
                    (pTG->ProtInst.fRecvdDTC ? &pTG->ProtInst.RemoteDTC : NULL),
                    (pTG->ProtInst.fRecvdID  ?  pTG->ProtInst.bRemoteID : NULL),
                    (pTG->ProtInst.fRecvdSUB ?  pTG->ProtInst.bRecipSubAddr : NULL),
                    RECV_POLLREQ, 
                    (NPBC)&pTG->ProtInst.RecvPollReq, 
                    sizeof(pTG->ProtInst.RecvPollReq),
                    &pTG->ProtInst.llRecvCaps);

    pTG->ProtInst.fRecvPollReqGot = TRUE;
    pTG->ProtInst.fllRecvCapsGot = TRUE;

    // send off BC struct to higher level
    if(!ICommRecvPollReq(pTG, (LPBC)&pTG->ProtInst.RecvPollReq))
    {
        // ICommFailureCode already set
        DebugPrintEx(DEBUG_WRN,"ATTENTION: pTG->ProtInst.fAbort = TRUE");
        pTG->ProtInst.fAbort = TRUE;
    }

    //
    // This need to be moved into whatnext.NodeA so that we can set
    // param to FALSE (no sleep) and do the stall thing
    AwaitSendParamsAndDoNegot(pTG, TRUE);
}

void GotRecvParams(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("GotRecvParams"));

    GotRecvFrames(  pTG, 
                    ifrNSS, 
                    &pTG->ProtInst.RecvdNS,
                    (pTG->ProtInst.fRecvdDCS ? (&pTG->ProtInst.RemoteDCS) : NULL),
                    (pTG->ProtInst.fRecvdID ? pTG->ProtInst.bRemoteID : NULL),
                    (pTG->ProtInst.fRecvdSUB ?  pTG->ProtInst.bRecipSubAddr : NULL),
                    RECV_PARAMS, 
                    (NPBC)&pTG->ProtInst.RecvParams, 
                    sizeof(pTG->ProtInst.RecvParams),
                    &pTG->ProtInst.llRecvParams);

    // If DCS has fECM set then we must've said we could do ECM
    BG_CHK(pTG->ProtInst.llRecvParams.fECM ? pTG->ProtInst.llSendCaps.fECM : 1);

    pTG->ProtInst.fRecvParamsGot = TRUE;
    pTG->ProtInst.fllRecvParamsGot = TRUE;

    if(!ICommRecvParams(pTG, (LPBC)&pTG->ProtInst.RecvParams)) 
    {
        DebugPrintEx(DEBUG_WRN, "ATTENTION: pTG->ProtInst.fAbort = TRUE");
        pTG->ProtInst.fAbort = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\psslog.c ===
/*++

Module Name:

    psslog.c
    
Abstract:

    Implementation of the fax service provider PSS log.
    
Author:

    Jonathan Barner (t-jonb)  Feb, 2001

Revision History:

--*/


#include "prep.h"
#include "faxreg.h"
#include "t30gl.h"      // for T30CritSection
#include <time.h>

#include "psslog.h"


/*++
Routine Description:
    Prints the log file header. It assumes that the log file is already open. On any
    unrecoverable error, the function closes the log file and falls back to no logging.

Arguments:
    pTG
    szDeviceName - pointer to device name to be included in the header
    eType - type of job (PSS_SEND or PSS_RECEIVE)

Return Value:
    None    
 --*/
#define LOG_HEADER_LINE_LEN           256
#define LOG_MAX_DATE                  256

void PrintPSSLogHeader(PThrdGlbl pTG, LPSTR szDeviceName, PSS_JOB_TYPE eType)
{
    TCHAR szHeader[LOG_HEADER_LINE_LEN*6] = {'\0'};  // Room for 6 lines
    TCHAR szDate[LOG_MAX_DATE] = {'\0'};
    int iDateRet = 0;
    LPSTR lpszUnimodemKeyEnd = NULL;
    DWORD dwCharIndex = 0;
    DWORD dwNumCharsWritten = 0;
    TCHAR szTimeBuff[10] = {'\0'};   // _tstrtime requires 9 chars
    BOOL fRet = FALSE;
    DEBUG_FUNCTION_NAME(_T("PrintPSSLogHeader"));

    iDateRet = GetY2KCompliantDate (LOCALE_USER_DEFAULT,
                                    0,
                                    NULL,
                                    szDate,
                                    LOG_MAX_DATE);
    if (0 == iDateRet)
    {
        DebugPrintEx(DEBUG_ERR, "GetY2KCompliantDate failed, LastError = %d, date will not be logged", GetLastError());
        szDate[0] = '\0';              // We continue with a blank date
    }

    dwCharIndex += _stprintf(&szHeader[dwCharIndex],
            TEXT("[%s %-8s]\r\n"), szDate, _tstrtime(szTimeBuff));
    dwCharIndex += _stprintf(&szHeader[dwCharIndex],
            TEXT("Device name: %s\r\n"), szDeviceName);
    dwCharIndex += _stprintf(&szHeader[dwCharIndex],
            TEXT("Permanent TAPI line ID: %8X\r\n"), pTG->dwPermanentLineID);

    lpszUnimodemKeyEnd = _tcsrchr(pTG->lpszUnimodemKey, _TEXT('\\'));
    if (NULL == lpszUnimodemKeyEnd)
    {
        lpszUnimodemKeyEnd = _TEXT("");
    }
    else
    {
        lpszUnimodemKeyEnd++;      // skip the actual '\'
    }
    dwCharIndex += _stprintf(&szHeader[dwCharIndex],
            TEXT("Unimodem registry key: %s\r\n"), lpszUnimodemKeyEnd);
            
    dwCharIndex += _stprintf(&szHeader[dwCharIndex],
            TEXT("Job type: %s\r\n"), (eType == PSS_SEND) ? TEXT("Send") : TEXT("Receive") );

    if (PSS_SEND == eType)
    {
        dwCharIndex += _stprintf(&szHeader[dwCharIndex],
                TEXT("Dialable number: %s\r\n"), pTG->lpszDialDestFax);
    }
    // blank line after header
    dwCharIndex += _stprintf(&szHeader[dwCharIndex],
            TEXT("\r\n"));

    fRet = WriteFile(pTG->hPSSLogFile,
                     szHeader, 
                     dwCharIndex * sizeof(szHeader[0]), 
                     &dwNumCharsWritten, 
                     NULL);
    if (FALSE == fRet)
    {
        DebugPrintEx(DEBUG_ERR,"Can't write log header, LastError = %d", GetLastError());
        ClosePSSLogFile(pTG);
        return;
    }
}


/*++
Routine Description:
    Reads from the registry whether logging should be enabled. If it should, determines
    the logging folder and log file number, advances the log file number, and creates
    the log file. On any unrecoverable error, the function falls back to no logging.

    Upon exit, if pTG->hPSSLogFile is set to NULL, there will be no logging

Arguments:
    pTG
    szDeviceName - pointer to device name to be included in the header
        note: this value is never saved in ThreadGlobal, which is why it is passed as
        a parameter.
    eType - type of job (PSS_SEND or PSS_RECEIVE)

Return Value:
    None    
 --*/
void OpenPSSLogFile(PThrdGlbl pTG, LPSTR szDeviceName, PSS_JOB_TYPE eType)
{
    DWORD dwType = 0;
    DWORD dwSize = 0;
    LONG  lError = 0;
    HKEY  hKey = NULL;
    DWORD dwLoggingEnabled = 0;

    DEBUG_FUNCTION_NAME(_T("OpenPSSLogFile"));

    _ASSERT(NULL == pTG->hPSSLogFile);

    lError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REGKEY_DEVICE_PROVIDER_KEY TEXT("\\") REGVAL_T30_PROVIDER_GUID_STRING,
                         0,              
                         KEY_READ | KEY_WRITE,       
                         &hKey);
    if (lError != ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_ERR, "Can't open registry key %s, lError = %d",
                REGKEY_DEVICE_PROVIDER_KEY TEXT("\\") REGVAL_T30_PROVIDER_GUID_STRING,
                lError);
        goto exit;
    }

    dwSize = sizeof(DWORD);
    lError = RegQueryValueEx(hKey,
                          REGVAL_LOGGINGENABLED,
                          0,
                          &dwType,
                          (LPBYTE)&dwLoggingEnabled,
                          &dwSize);
    // If LoggingEnabled is not found, fallback to no logging
    if (lError != ERROR_SUCCESS)
    {
        DebugPrintEx(DEBUG_WRN, "Can't read LoggingEnabled, lError = %d", lError);
        dwLoggingEnabled = 0;
    } 
    else if (dwType != REG_DWORD)
    {
        DebugPrintEx(DEBUG_WRN, "LoggingEnabled is not of type REG_DWORD, dwType = %d", dwType);
        dwLoggingEnabled = 0;
    }
     
    if (dwLoggingEnabled != 0)
    {
        #define FILE_NAME_LEN 13   // length of filename only, e.g. "\FSPR1234.log"

        TCHAR tchLoggingFolder[MAX_PATH] = {'\0'};  //LoggingFolder, as read from the registry
        TCHAR tchLogFileName[MAX_PATH + FILE_NAME_LEN] = {'\0'};
        DWORD dwCharNum = 0;
        DWORD dwLogFileNumber = 0;
        DWORD dwNextLogFileNumber = 0;

        dwSize = sizeof(tchLoggingFolder[0]) * MAX_PATH;
        lError = RegQueryValueEx(hKey,
                                 REGVAL_LOGGINGFOLDER,
                                 0,
                                 &dwType,
                                 (LPBYTE)tchLoggingFolder,
                                 &dwSize);
        // If can't read LoggingFolder, use default folder
        if (lError != ERROR_SUCCESS || (dwType != REG_EXPAND_SZ && dwType != REG_SZ))
        {
            DebugPrintEx(DEBUG_MSG, "Can't read LoggingFolder, using %s instead", DEFAULT_LOG_FOLDER);
            _tcscpy(tchLoggingFolder, DEFAULT_LOG_FOLDER);
        }

        // Using T30CritSection to ensure atomic read and write of the registry
        // value LogFileNumber
        EnterCriticalSection(&T30CritSection);

        dwSize = sizeof(DWORD);
        lError = RegQueryValueEx(hKey,
                                 REGVAL_LOGFILENUMBER,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwLogFileNumber,
                                 &dwSize);
        // If LogFileNumber is not found, default to 0 - and create the entry for next time
        if (lError != ERROR_SUCCESS)        
        {
            DebugPrintEx(DEBUG_WRN, "Can't read LogFileNumber, lError = %d - defaulting to 0", lError);
            dwLogFileNumber = 0;
        }
        else if (dwType != REG_DWORD)
        {
            DebugPrintEx(DEBUG_WRN, "LogFileNumber is not of type REG_DWORD - defaulting to 0");
            dwLogFileNumber = 0;
        }

        dwNextLogFileNumber = (dwLogFileNumber+1) % 1000;

        lError = RegSetValueEx(hKey,
                               REGVAL_LOGFILENUMBER,
                               0,
                               REG_DWORD,
                               (LPBYTE)&dwNextLogFileNumber,
                               sizeof(DWORD));
        if (lError != ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR, "Can't write LogFileNumber, lError = %d", lError);
        }
        
        LeaveCriticalSection(&T30CritSection);

        dwCharNum = ExpandEnvironmentStrings(tchLoggingFolder,
                                             tchLogFileName,
                                             MAX_PATH);
        if (dwCharNum == 0)
        {
            DebugPrintEx(DEBUG_ERR, "ExpandEnvironmentStrings failed, LastError = %d", GetLastError());
            goto exit;
        }
        if  (dwCharNum > MAX_PATH)
        {
            DebugPrintEx(DEBUG_ERR, "ExpandEnvironmentStrings failed, dwCharNum = %d", dwCharNum);
            goto exit;
        }

        // Add filename to directory name
        _stprintf(&tchLogFileName[_tcslen(tchLogFileName)],
                  TEXT("\\FSP%c%03d.log"),
                  (eType == PSS_SEND) ? TEXT('S') : TEXT('R'),
                  dwLogFileNumber % 1000);

        DebugPrintEx(DEBUG_MSG, "Creating log file %s", tchLogFileName);

        pTG->hPSSLogFile = CreateFile(tchLogFileName,
                                      GENERIC_WRITE,
                                      FILE_SHARE_READ,
                                      NULL,
                                      CREATE_ALWAYS,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
        if (INVALID_HANDLE_VALUE == pTG->hPSSLogFile)
        {
            DebugPrintEx(DEBUG_ERR, "Can't create log file, LastError = %d", GetLastError());
            pTG->hPSSLogFile = NULL;
            goto exit;
        }
    }

exit:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    if (NULL != pTG->hPSSLogFile)
    {
        PrintPSSLogHeader(pTG, szDeviceName, eType);
    }
}



/*++
Routine Description:
    Closes the log file, if logging was enabled.

Return Value:
    None    
 --*/
void ClosePSSLogFile(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("ClosePSSLogFile"));

    if (NULL != pTG->hPSSLogFile)
    {
        CloseHandle(pTG->hPSSLogFile);
        pTG->hPSSLogFile = NULL;
    }
}

/*++
Routine Description:
    Delete all '\n' and '\r' from a string.
Arguments:
    szDest - [out] pointer to output string
    szSource - [in] pointer to input string
Return Value:
    Length of new string, in TCHARs
Note: szDest and szSource can be the same string.
 --*/
int CopyStrNoNewLines(LPSTR szDest, LPCSTR szSource)
{
    int iCharRead = 0, iCharWrite = 0;
    while (szSource[iCharRead] != '\0')
    {
        if (szSource[iCharRead]!='\n' && szSource[iCharRead]!='\r')
        {
            szDest[iCharWrite] = szSource[iCharRead];
            iCharWrite++;
        }
        iCharRead++;
    }
    szDest[iCharWrite] = '\0';
    return iCharWrite;
}



#define MAX_MESSAGE_LEN 2048
#define INDENT_LEN  12
#define HEADER_LEN  38
/*++
Routine Description:
    Add an entry to the log, if logging is enabled. If disabled, do nothing.
    
Arguments:
    pTG
    nMessageType - message type (PSS_MSG_ERR, PSS_MSG_WRN, PSS_MSG_MSG)
    dwFileID - File ID, as set in the beginning of every file by #define FILE_ID
    dwLine - Line number
    dwIndent - Indent level in "tabs" (0 - leftmost)
    pcszFormat - Message text, with any format specifiers
    ... - Arguments for message format
Return Value:
    None    
--*/
void PSSLogEntry(
    PThrdGlbl pTG,
    PSS_MESSAGE_TYPE const nMessageType,
    DWORD const dwFileID,
    DWORD const dwLine,
    DWORD dwIndent,
    LPCTSTR pcszFormat,
    ... )
{
    TCHAR pcszMessage[MAX_MESSAGE_LEN] = {'\0'};
    va_list arg_ptr = NULL;
    LPTSTR lptstrMsgPrefix = NULL;
    TCHAR szTimeBuff[10] = {'\0'};
    int iHeaderIndex = 0;
    int iMessageIndex = 0;
    DWORD dwBytesWritten = 0;
    BOOL fRet = FALSE;
    
// DEBUG_FUNCTION_NAME(_T("PSSLogEntry"));
// hack: Want only one line in T30DebugLogFile
#ifdef ENABLE_LOGGING
    LPCTSTR faxDbgFunction=_T("PSSLogEntry");
#endif // ENABLE_LOGGING

    switch (nMessageType)
    {
        case PSS_MSG_MSG:
            lptstrMsgPrefix=TEXT("   ");
            break;
        case PSS_WRN_MSG:
            lptstrMsgPrefix=TEXT("WRN");
            break;
        case PSS_ERR_MSG:
            lptstrMsgPrefix=TEXT("ERR");
            break;
        default:
            _ASSERT(FALSE);
            lptstrMsgPrefix=TEXT("   ");
            break;
    }

    iHeaderIndex = _sntprintf(pcszMessage, 
                              MAX_MESSAGE_LEN,
                              TEXT("[%-8s][%09d][%4d%04d][%3s] %*c"),
                              _tstrtime(szTimeBuff),
                              GetTickCount(),
                              dwFileID,
                              dwLine % 10000,
                              lptstrMsgPrefix,
                              dwIndent * INDENT_LEN,
                              TEXT(' '));
    if (iHeaderIndex<0)
    {
        DebugPrintEx(DEBUG_ERR, "Message header too long, it will not be logged");
        return;
    }
    
    // Now comes the actual message
    va_start(arg_ptr, pcszFormat);
    iMessageIndex = _vsntprintf(
        &pcszMessage[iHeaderIndex],                                             
        MAX_MESSAGE_LEN - (iHeaderIndex + 3),          // +3 - room for "\r\n\0"
        pcszFormat,
        arg_ptr);
    if (iMessageIndex<0)
    {
        DebugPrintEx(DEBUG_ERR, "Message too long, it will not be logged");
        return;
    }
    // Kill all newline chars
    iMessageIndex = CopyStrNoNewLines(&pcszMessage[iHeaderIndex], &pcszMessage[iHeaderIndex]);

    DebugPrintEx(DEBUG_MSG, "PSSLog: %s", &pcszMessage[iHeaderIndex]);

    if (NULL == pTG->hPSSLogFile)
    {   
        return;
    }

    // End of line
    iMessageIndex += iHeaderIndex; 
    iMessageIndex += _stprintf( &pcszMessage[iMessageIndex],TEXT("\r\n"));

    fRet = WriteFile(pTG->hPSSLogFile,
                     pcszMessage,
                     iMessageIndex * sizeof(pcszMessage[0]),
                     &dwBytesWritten,
                     NULL);
    if (FALSE == fRet)
    {
        DebugPrintEx(DEBUG_ERR, "Writefile failed, this message will not be logged");
    }
}


/*++
Routine Description:
    Add an entry to the log, including a binary dump.    
Arguments:
    pTG
    nMessageType - message type (PSS_MSG_ERR, PSS_MSG_WRN, PSS_MSG_MSG)
    dwFileID - File ID, as set in the beginning of every file by #define FILE_ID
    dwLine - Line number      
    pcszFormat - Message text, no format specifiers allowed
    lpb - byte buffer to dump
    dwSize - number of bytes to dump
Return Value:
    None    
--*/

void PSSLogEntryHex(
    PThrdGlbl pTG,
    PSS_MESSAGE_TYPE const nMessageType,
    DWORD const dwFileID,
    DWORD const dwLine,
    DWORD dwIndent,

    LPB const lpb,
    DWORD const dwSize,

    LPCTSTR pcszFormat,
    ... )
{
    TCHAR pcszMessage[MAX_MESSAGE_LEN] = {'\0'};
    va_list arg_ptr = NULL;
    DWORD dwByte = 0;
    int iMessageIndex = 0;

// DEBUG_FUNCTION_NAME(_T("PSSLogEntryHex"));
// hack: Want only one line in T30DebugLogFile
#ifdef ENABLE_LOGGING
    LPCTSTR faxDbgFunction=_T("PSSLogEntryHex");
#endif // ENABLE_LOGGING

    // Now comes the actual message
    va_start(arg_ptr, pcszFormat);
    iMessageIndex = _vsntprintf(
        pcszMessage,
        sizeof(pcszMessage)/sizeof(pcszMessage[0]),
        pcszFormat,
        arg_ptr);

    if (iMessageIndex<0)
    {
        DebugPrintEx(DEBUG_ERR, "Message too long, it will not be logged");
        return;
    }
    
    for (dwByte=0; dwByte<dwSize; dwByte++)
    {
        iMessageIndex += _stprintf( &pcszMessage[iMessageIndex],TEXT(" %02x"), lpb[dwByte]);
        // -4 - room for "...",    -3  - room for "\r\n\0"
        if (iMessageIndex > (int)(MAX_MESSAGE_LEN - HEADER_LEN - dwIndent*INDENT_LEN - 4 - 3))
        {
            iMessageIndex += _stprintf( &pcszMessage[iMessageIndex],TEXT("..."));
            break;
        }
    }

    PSSLogEntry(pTG, nMessageType, dwFileID, dwLine, dwIndent, pcszMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\pssframe.c ===
/*++

Module Name:
    pssframe.c
    
Abstract:
    This module logs the content of DISs and DCSs into PSS log file.
    
Author:
    Jonathan Barner (t-jonb)  Mar, 2001

Revision History:

--*/

#include "prep.h"

#include "psslog.h"
#define FILE_ID FILE_ID_PSSFRAME


/*++
Routine Description:
    Logs DIS details to PSS log, using the supplied info.
Arguments:
    pTG
    lpszModulations, bFineRes, b2D, lpszPageWidth, lpszPageLength, lpszMinLineTime - info to log
Return Value:
    None    
 --*/
void LogDISDetails(PThrdGlbl pTG, 
                   LPSTR lpszModulations,
                   BOOL bFineRes,
                   BOOL b2D,
                   LPSTR lpszPageWidth,
                   LPSTR lpszPageLength,
                   LPSTR lpszMinLineTime)
{
    PSSLogEntry(PSS_MSG, 1, "- Supported Modulations: %s", lpszModulations);
    PSSLogEntry(PSS_MSG, 1, "- Ability to use fine resolution: %s", bFineRes ? _T("Yes") : _T("No"));
    PSSLogEntry(PSS_MSG, 1, "- Ability to use 2D coding: %s", b2D ? _T("Yes") : _T("No"));
    PSSLogEntry(PSS_MSG, 1, "- Supported Page Width: %s", lpszPageWidth);
    PSSLogEntry(PSS_MSG, 1, "- Supported Page Length: %s", lpszPageLength);
    PSSLogEntry(PSS_MSG, 1, "- Minimum scan line time: %s", lpszMinLineTime);
}


/*++
Routine Description:
    Logs DCS details to PSS log, using the supplied info.
Arguments:
    pTG
    lpszModulations, bFineRes, b2D, lpszPageWidth, lpszPageLength, lpszLineTime - info to log
Return Value:
    None    
 --*/
void LogDCSDetails(PThrdGlbl pTG, 
                   LPSTR lpszModulation,
                   BOOL bFineRes,
                   BOOL b2D,
                   DWORD dwPageWidth,
                   LPSTR lpszPageLength,
                   LPSTR lpszLineTime)
{
    PSSLogEntry(PSS_MSG, 1, "- Session Modulation is: %s", lpszModulation);
    PSSLogEntry(PSS_MSG, 1, "- Use fine resolution: %s", bFineRes ? _T("Yes") : _T("No"));
    PSSLogEntry(PSS_MSG, 1, "- Use 2D coding: %s", b2D ? _T("Yes") : _T("No"));
    PSSLogEntry(PSS_MSG, 1, "- Page width is %d", dwPageWidth);
    PSSLogEntry(PSS_MSG, 1, "- Page length is %s", lpszPageLength);
    PSSLogEntry(PSS_MSG, 1, "- Scan line time: %s", lpszLineTime);
}

// This table applies to both DIS and DCS, in both class1 and class2
LPSTR ppszMinLineTime[8] = {            // Bits 21-23 (leftmost is 23)
    _T("20"),                           // 000
    _T("40"),                           // 001
    _T("10"),                           // 010
    _T("5"),                            // 011
    _T("10&5"),                         // 100
    _T("20&10"),                        // 101
    _T("40&20"),                        // 110
    _T("0")                             // 111
};

// *************************** CLASS 1 ****************************

/*++
Routine Description:
    Logs DIS details to PSS log, using the supplied NPDIS.
Arguments:
    pTG
    npdis - DIS to log
Return Value:
    None    
 --*/
void LogClass1DISDetails(PThrdGlbl pTG, NPDIS npdis)
{
    static LPSTR ppszCapsDesc[16] = {       // Bits 11-14 (leftmost is 14)
        _T("V.27 ter fallback"),            // 0000
        _T("V.29"),                         // 0001
        _T("V.27 ter"),                     // 0010
        _T("V.27 ter, V.29"),               // 0011
        _T(""),                             // 0100
        _T(""),                             // 0101
        _T(""),                             // 0110
        _T("V.27 ter, V.29, V.33"),         // 0111
        _T(""),                             // 1000
        _T(""),                             // 1001
        _T(""),                             // 1010
        _T("V.27 ter, V.29, V.33, V.17"),   // 1011
        _T(""),                             // 1100
        _T(""),                             // 1101
        _T(""),                             // 1110
        _T("")                              // 1111
    };
    static LPSTR ppszWidthDesc[4] = {       // Bits 17-18 (leftmost is 18)
        _T("1728"),                         // 00
        _T("1728, 2048"),                   // 01
        _T("1728, 2048, 2432"),             // 10
        _T("invalid (interpreted as 1728, 2048, 2432)") //11
    };
    static LPSTR ppszLengthDesc[4] = {      // Bits 19-20 (leftmost is 20)
        _T("A4"),                           // 00
        _T("A4 and B4"),                    // 01
        _T("Unlimited"),                    // 10
        _T("invalid")                       // 11
    };

    if (npdis == NULL)
    {
        _ASSERT(FALSE);
        return;
    }
    LogDISDetails(pTG, 
                  ppszCapsDesc[npdis->Baud],
                  (npdis->ResFine_200 == 1),
                  (npdis->MR_2D == 1),
                  ppszWidthDesc[npdis->PageWidth],
                  ppszLengthDesc[npdis->PageLength],
                  ppszMinLineTime[npdis->MinScanCode]);
}


/*++
Routine Description:
    Logs DCS details to PSS log, using the supplied NPDIS.
Arguments:
    pTG
    npdis - DCS to log
Return Value:
    None    
 --*/
void LogClass1DCSDetails(PThrdGlbl pTG, NPDIS npdis)
{
    static LPSTR ppszDesc[16] = {           // Bits 11-14 (leftmost is 14)
        _T("2400 bps V.27 ter"),            // 0000
        _T("9600 bps V.29"),                // 0001
        _T("4800 bps V.27 ter"),            // 0010
        _T("7200 bps V.29"),                // 0011
        _T("14400 bps V.33"),               // 0100
        _T(""),                             // 0101
        _T("12000 bps V.33"),               // 0110
        _T(""),                             // 0111
        _T("14400 bps V.17"),               // 1000
        _T("9600 bps V.17"),                // 1001
        _T("12000 bps V.17"),               // 1010
        _T("7200 bps V.17"),                // 1011
        _T(""),                             // 1100
        _T(""),                             // 1101
        _T(""),                             // 1110
        _T("")                              // 1111
    };
    static DWORD dwWidthDesc[4] = {            
        1728,                               // 00
        2048,                               // 01
        2432,                               // 10
        2432                                // 11
    };
    static LPSTR lpszLengthDesc[4] = {
        _T("A4"),                           // 00
        _T("B4"),                           // 01
        _T("Unlimited"),                    // 10
        _T("invalid")                       // 11
    };

    if (npdis == NULL)
    {
        _ASSERT(FALSE);
        return;
    }
    LogDCSDetails(pTG,
                  ppszDesc[npdis->Baud],
                  (npdis->ResFine_200 == 1),
                  (npdis->MR_2D == 1),
                  dwWidthDesc[npdis->PageWidth],
                  lpszLengthDesc[npdis->PageLength],
                  ppszMinLineTime[npdis->MinScanCode]);
}

// *************************** CLASS 2 ****************************

#define GET_BOUNDED_ARRAY_ELEMENT(_array_, _val_, _maxval_, _default_)  \
    (((_val_)>=0 && (_val_)<(_maxval_)) ? _array_[(_val_)] : (_default_))

// These tables belongs to both DIS and DCS
LPSTR ppszCapsDesc[6] = {       
    _T("2400 bps V.27 ter"),            // 0
    _T("4800 bps V.27 ter"),            // 1
    _T("7200 bps V.29 or V.17"),        // 2
    _T("9600 bps V.29 or V.17"),        // 3
    _T("12000 bps V.17"),               // 4
    _T("14400 bps V.17"),               // 5
};
LPSTR ppszLengthDesc[3] = {
    _T("A4"),                           // 0
    _T("B4"),                           // 1
    _T("Unlimited"),                    // 2
};
    
LPSTR szInvalid = _T("Invalid");

/*++
Routine Description:
    Logs DIS details to PSS log, using the supplied PCB.
Arguments:
    pTG
    lpPcb - DIS to log
Return Value:
    None    
 --*/
void LogClass2DISDetails(PThrdGlbl pTG, LPPCB lpPcb)
{
    static LPSTR ppszWidthDesc[5] = {       
        _T("1728"),                         // 0
        _T("1728, 2048"),                   // 1
        _T("1728, 2048, 2432"),             // 2
        _T("1216"),                         // 3
        _T("864"),                          // 4
    };

    if (lpPcb == NULL)
    {
        _ASSERT(FALSE);
        return;
    }
    LogDISDetails(pTG, 
                  GET_BOUNDED_ARRAY_ELEMENT(ppszCapsDesc, lpPcb->Baud, 6, szInvalid),
                  lpPcb->Resolution & AWRES_mm080_038,
                  lpPcb->Encoding & MR_DATA,
                  GET_BOUNDED_ARRAY_ELEMENT(ppszWidthDesc, lpPcb->PageWidth, 5, szInvalid),
                  GET_BOUNDED_ARRAY_ELEMENT(ppszLengthDesc, lpPcb->PageLength, 3, szInvalid),
                  GET_BOUNDED_ARRAY_ELEMENT(ppszMinLineTime, lpPcb->MinScan, 8, szInvalid) );
}


/*++
Routine Description:
    Logs DCS details to PSS log, using the supplied PCB.
Arguments:
    pTG
    lpPcb - DCS to log
Return Value:
    None    
 --*/
void LogClass2DCSDetails(PThrdGlbl pTG, LPPCB lpPcb)
{
    static DWORD dwWidthDesc[5] = {       
        1728,                               // 0
        2048,                               // 1
        2432,                               // 2
        1216,                               // 3
        864                                 // 4
    };

    if (lpPcb == NULL)
    {
        _ASSERT(FALSE);
        return;
    }
    LogDCSDetails(pTG, 
                  GET_BOUNDED_ARRAY_ELEMENT(ppszCapsDesc, lpPcb->Baud, 6, szInvalid),
                  !(lpPcb->Resolution & AWRES_mm080_038),
                  lpPcb->Encoding & MR_DATA,
                  GET_BOUNDED_ARRAY_ELEMENT(dwWidthDesc, lpPcb->PageWidth, 5, 0),
                  GET_BOUNDED_ARRAY_ELEMENT(ppszLengthDesc, lpPcb->PageLength, 3, szInvalid),
                  GET_BOUNDED_ARRAY_ELEMENT(ppszMinLineTime, lpPcb->MinScan, 8, szInvalid) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\rx_thrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rx_thrd.c

Abstract:

    This module implements async. MR/MH page decoding in a separate thread.

Author:

    Rafael Lisitsa (RafaelL) 14-Aug-1996

Revision History:

--*/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"
#include "debug.h"

#include "tiff.h"
#include "..\..\..\tiff\src\fasttiff.h"

#include "glbproto.h"
#include "t30gl.h"


// 15 min.
#define WAIT_FOR_NEXT_STRIP_RX_TIMEOUT      900000
#define RET_NEXT_STRIP_RX_TIMEOUT           1

BOOL DecodeFaxPageAsync
(
    PThrdGlbl           pTG,
    DWORD               *RetFlags,
    char                *InFileName
);

DWORD PageAckThreadSafe(PThrdGlbl pTG)
{
    DWORD   RetCode;

    if (glT30Safe) 
    {
        __try 
        {
            RetCode = PageAckThread(pTG);

        } 
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
            //
            // Signal to the Main T.30 Thread that we crashed
            //
            return (FALSE);
        }
    }
    else  
    {
        RetCode = PageAckThread(pTG);
    }
    return (RetCode);
}

DWORD PageAckThread(PThrdGlbl pTG)
{
    DWORD             RetCode = FALSE;
    DWORD             RetFlags = 0;
    DWORD             ThrdDoneRetCode;
    char              InFileName[_MAX_FNAME];

    DEBUG_FUNCTION_NAME(_T("PageAckThread"));
    //
    // Set the appropriate PRTY for this thread
    // I/O threads run at 15. TIFF - at 9...11
    //

    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "SetThreadPriority HIGHEST failed le=%x",
                        GetLastError());
        SignalHelperError(pTG);
        goto error_exit;
    }

    // binary file has fixed name based on lineID; it is created and updated by T.30 RX I/O thread.
    _fmemcpy (InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
    _fmemcpy (&InFileName[gT30.dwLengthTmpDirectory], pTG->TiffConvertThreadParams.lpszLineID, 8);
    sprintf  (&InFileName[gT30.dwLengthTmpDirectory+8], ".RX");

    do 
    {
        RetFlags = 0;

        ThrdDoneRetCode = DecodeFaxPageAsync (  pTG,
                                                &RetFlags,
                                                InFileName);

        DebugPrintEx(   DEBUG_MSG,
                        "DecodeFaxPageAsync RetFlags=%d",
                        RetFlags);

        if ( RetFlags == RET_NEXT_STRIP_RX_TIMEOUT ) 
        {
            DebugPrintEx(   DEBUG_MSG,
                            "TimeOut. Trying to delete file%s",
                            InFileName);
            
            if (!DeleteFile(InFileName))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "Could not delete file %s, le = %x",
                                InFileName, 
                                GetLastError());
            }
            return (FALSE);
        }

        // Signal that we finish process the page.
        if (!SetEvent(pTG->ThrdDoneSignal))
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "SetEvent(0x%lx) returns failure code: %ld",
                            (ULONG_PTR)pTG->ThrdDoneSignal,
                            (long) GetLastError());
            RetCode = FALSE;
            goto error_exit;
        }

    } 
    while (! pTG->ReqTerminate); // Handle the next page

    
    if (!DeleteFile(InFileName))
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "Could not delete file %s, le = %x", 
                        InFileName, 
                        GetLastError());
    }
    
    DebugPrintEx(DEBUG_MSG,"Terminated");

    RetCode = TRUE;

error_exit:

    pTG->AckTerminate = 1;
    pTG->fOkToResetAbortReqEvent = 1;

    if (!SetEvent(pTG->ThrdAckTerminateSignal))
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "SetEvent(0x%lx) returns failure code: %ld",
                        (ULONG_PTR)pTG->ThrdAckTerminateSignal,
                        (long) GetLastError());
        RetCode = FALSE;
    }

    DebugPrintEx(DEBUG_MSG,"PageAckThread EXITs");

    return (RetCode);
}


BOOL DecodeFaxPageAsync
(
    PThrdGlbl           pTG,
    DWORD               *RetFlags,
    char                *InFileName
)
{
    HANDLE              InFileHandle;
    DWORD               i;
    DWORD               Lines;
    DWORD               BadFaxLines;
    DWORD               ConsecBadLines=0;

    DWORD               AllowedBadFaxLines = gT30.MaxErrorLinesPerPage;
    DWORD               AllowedConsecBadLines = gT30.MaxConsecErrorLinesPerPage;

    LPDWORD             EndPtr;
    LPDWORD             EndBuffer;

    LPDWORD             lpdwResPtr;
    LPDWORD             lpdwRead;
    BYTE                ResBit;
    BOOL                fTestLength;
    BOOL                fError;

    BOOL                fFirstRead;

    DWORD               Buffer[DECODE_BUFFER_SIZE / sizeof(DWORD)];
    DWORD               GoodStripSize = 0;
    BOOL                fLastReadBlockSync;   // needs to be sync. fetched, updated by RX I/O thrd.
    DWORD               BytesReuse;
    DWORD               BytesDelta;
    DWORD               BytesToRead;
    DWORD               BytesHaveRead;

    BOOL                f1D;

    DWORD               PageCount;
    BOOL                fAfterFirstEOL;
    DWORD               NumHandles=2;
    HANDLE              HandlesArray[2];
    DWORD               WaitResult;
    BOOL                ResScan;

    //
    // At Start of Page
    //

    DEBUG_FUNCTION_NAME(_T("DecodeFaxPageAsync"));

    HandlesArray[0] = pTG->AbortReqEvent;
    HandlesArray[1] = pTG->ThrdSignal;

    pTG->fTiffThreadRunning = 0;


    do 
    {
        WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_RX_TIMEOUT);

        if (WaitResult == WAIT_TIMEOUT) 
        {
            *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
            return FALSE;
        }

        if (WaitResult == WAIT_FAILED) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "WaitForMultipleObjects FAILED le=%lx",
                            GetLastError());
        }

        if ( pTG->ReqTerminate || ( WaitResult == WAIT_OBJECT_0) )   
        {
            DebugPrintEx(DEBUG_MSG, "wait for next page ABORTED") ;
            pTG->fOkToResetAbortReqEvent = 1;
            return TRUE;
        }

    } 
    while (pTG->fPageIsBad); // pTG->fPageIsBad become FALSE when we call to RECV_STARTPAGE to get new page.
    // The reason we wait for fPageIsBad: If the prev page was bad, we want to wait till clean-up was done.
    
    pTG->fTiffThreadRunning = 1;

    Lines = 0;
    BadFaxLines = 0;

    PageCount = pTG->PageCount;
    fAfterFirstEOL = 0;


    fLastReadBlockSync = pTG->fLastReadBlock;

    DebugPrintEx(   DEBUG_MSG, 
                    "waked up fLastReadBlockSync=%d",
                    fLastReadBlockSync);

    if ( ( InFileHandle = CreateFileA(InFileName, GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ,
                                       NULL, OPEN_EXISTING, 0, NULL) ) == INVALID_HANDLE_VALUE ) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "PAGE COULD NOT open %s",
                        InFileName);

        pTG->fPageIsBad = 1;
        return FALSE;
    }

    fFirstRead = 1;
    pTG->BytesOut = 0;

    // Buffer is DWORD aligned
    lpdwResPtr = Buffer;
    ResBit = 0;

    EndBuffer = Buffer + ( DECODE_BUFFER_SIZE / sizeof(DWORD) );

    //
    // loop thru all blocks
    //
    do 
    {
        //
        // Read the next RAW block prepared by main I/O thread
        //
        if (fFirstRead) 
        {
            lpdwRead = Buffer;
            BytesReuse = 0;
            BytesToRead = DECODE_BUFFER_SIZE;
            fTestLength = DO_NOT_TEST_LENGTH;
        }
        else 
        {
            BytesReuse = (DWORD)((EndBuffer - lpdwResPtr) * sizeof (DWORD));
            CopyMemory( (char *) Buffer, (char *) lpdwResPtr, BytesReuse);
            lpdwRead = Buffer + (BytesReuse / sizeof (DWORD) );
            BytesToRead = DECODE_BUFFER_SIZE -  BytesReuse;
            fTestLength = DO_TEST_LENGTH;
        }

        lpdwResPtr = Buffer;

        BytesDelta = pTG->BytesIn - pTG->BytesOut;

        if (BytesDelta < DECODE_BUFFER_SIZE) 
        {
            if (! fLastReadBlockSync) 
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "PAGE LOGIC. SYNC. file %s Bytes: IN:%d OUT:%d",
                                InFileName, 
                                pTG->BytesIn, 
                                pTG->BytesOut);

                pTG->fPageIsBad = 1;
                goto bad_exit;
            }
        }

        if (fLastReadBlockSync) 
        {
            if (BytesDelta < BytesToRead) 
            {
                BytesToRead = BytesDelta;
            }
        }

        if (! ReadFile(InFileHandle, lpdwRead, BytesToRead, &BytesHaveRead, NULL ) ) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "PAGE COULD NOT READ file %s Bytes: IN:%d"
                            " OUT:%d WANTED:%d LE=%x",
                            InFileName, 
                            pTG->BytesIn, 
                            pTG->BytesOut, 
                            BytesToRead, 
                            GetLastError());

            pTG->fPageIsBad = 1;
            goto bad_exit;
        }

        if (BytesHaveRead != BytesToRead) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "PAGE ReadFile count=%d WANTED=%d file %s"
                            " Bytes: IN:%d OUT:%d",
                            BytesHaveRead, 
                            BytesToRead, 
                            InFileName, 
                            pTG->BytesIn, 
                            pTG->BytesOut);

            pTG->fPageIsBad = 1;
            goto bad_exit;
        }


        if ( fLastReadBlockSync && (BytesToRead == BytesDelta) ) 
        {
            EndPtr = Buffer + ( (BytesReuse + BytesToRead) / sizeof(DWORD) );
        }
        else 
        {
            //
            // leave 1000*4 = 4000 bytes ahead if not final block to make sure
            // we always have one full line ahead.
            //
            EndPtr = EndBuffer - 1000;
        }

        pTG->BytesOut += BytesToRead;
        GoodStripSize += BytesToRead;


        DebugPrintEx(   DEBUG_MSG, 
                        "BytesIn=%d Out=%d Read=%d ResBit=%d StartPtr=%lx"
                        " EndPtr=%lx Reuse=%d",
                        pTG->BytesIn, 
                        pTG->BytesOut, 
                        BytesToRead, 
                        ResBit, 
                        Buffer, 
                        EndPtr, 
                        BytesReuse);

        //
        // find first EOL
        //

        f1D = 1;

        if (! FindNextEol (lpdwResPtr, ResBit, EndBuffer, &lpdwResPtr, &ResBit, fTestLength, &fError) ) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "Couldn't find EOL fTestLength=%d fError=%d",
                            fTestLength, 
                            fError);
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }

        fAfterFirstEOL = 1;

        //
        // Scan the next segment
        //

        __try 
        {
            // if those settings change from one page to the other
            // it has to be inside the loop, beause this thread
            // gets all the pages and then dies
            DWORD tiffCompression = pTG->TiffConvertThreadParams.tiffCompression;
            BOOL HiRes = pTG->TiffConvertThreadParams.HiRes;
            DebugPrintEx(   DEBUG_MSG,
                            "Calling %s with compression=%d and resolution=%d",
                            (tiffCompression == TIFF_COMPRESSION_MR)?"ScanMrSegment":"ScanMhSegment",
                            tiffCompression,HiRes);
            if (tiffCompression == TIFF_COMPRESSION_MR) 
            {
                ResScan = ScanMrSegment(&lpdwResPtr,
                                        &ResBit,
                                         EndPtr,
                                         EndBuffer,
                                        &Lines,
                                        &BadFaxLines,
                                        &ConsecBadLines,
                                         AllowedBadFaxLines,
                                         AllowedConsecBadLines,
                                        &f1D,
                                        pTG->TiffInfo.ImageWidth);
            }
            else
            {
                ResScan = ScanMhSegment(&lpdwResPtr,
                                         &ResBit,
                                         EndPtr,
                                         EndBuffer,
                                         &Lines,
                                         &BadFaxLines,
                                         &ConsecBadLines,
                                         AllowedBadFaxLines,
                                         AllowedConsecBadLines,
                                         pTG->TiffInfo.ImageWidth);
            }

            DebugPrintEx( DEBUG_MSG,
                            "%s returned: ResScan=%d  Lines=%d  " 
                            "BadFaxLines=%d  tAllowedBadFaxLines=%d  "
                            "ConsecBadLines=%d  AllowedConsecBadLines=%d  "
                            "tpImageWidth=%d",
                            (tiffCompression == TIFF_COMPRESSION_MR)?"ScanMrSegment":"ScanMhSegment",
                            ResScan, 
                            Lines, 
                            BadFaxLines, 
                            AllowedBadFaxLines, 
                            ConsecBadLines, 
                            AllowedConsecBadLines, 
                            pTG->TiffInfo.ImageWidth);

        } 
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
          //
          // try to use the Recovery data
          //

          DWORD      dwCkSum;
          int        fFound=0;
          PThrdGlbl  pTG;
          DWORD      dwThreadId = GetCurrentThreadId();

          fFound = 0;

          for (i=0; i<MAX_T30_CONNECT; i++) 
          {
              if ( (! T30Recovery[i].fAvail) && (T30Recovery[i].TiffThreadId == dwThreadId) ) 
              {
                  if ( ( dwCkSum = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                                    sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1) ) == T30Recovery[i].CkSum ) 
                  {
                      pTG = (PThrdGlbl) T30Recovery[i].pTG;
                      fFound = 1;
                      break;
                  }
              }
          }


          *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
          CloseHandle(InFileHandle);

          if (fFound == 1) 
          {
            pTG->fPageIsBad = 1;
          }

          return (FALSE);

        }



        if (ResScan == TIFF_SCAN_SUCCESS) 
        {
            goto good_exit;
        }
        else if (ResScan == TIFF_SCAN_FAILURE)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "ScanSegment returns TIFF_SCAN_FAILURE");
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }
        else if (ResScan != TIFF_SCAN_SEG_END) 
        {
            DebugPrintEx(   DEBUG_ERR,
                            "ScanSegment returns INVALID %d", 
                            ResScan);
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }

//lNextBlock:
        // here we make decision as to whether to do the next segment OR to block (not enough data avail).
        if (fLastReadBlockSync && (pTG->BytesOut == pTG->BytesIn) ) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "Didn't find RTC  Bad=%d ConsecBad=%d Good=%d",
                            BadFaxLines, 
                            ConsecBadLines, 
                            Lines);
            pTG->fPageIsBad = 1;
            goto bad_exit;
        }


        DebugPrintEx(   DEBUG_MSG,
                        "Done with next strip BytesIn=%d Out=%d"
                        " Lines=%d Bad=%d ConsecBad=%d Processed %d bytes \n",
                        pTG->BytesIn, 
                        pTG->BytesOut, 
                        Lines, 
                        BadFaxLines, 
                        ConsecBadLines,
                        (lpdwResPtr - Buffer) * sizeof(DWORD));

        fLastReadBlockSync = pTG->fLastReadBlock;

        if ( (pTG->BytesIn - pTG->BytesOut < DECODE_BUFFER_SIZE) && (! fLastReadBlockSync) )   
        {
            DebugPrintEx(DEBUG_MSG,"Waiting for next strip to be avail.");

            pTG->fTiffThreadRunning = 0;

            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_RX_TIMEOUT);

            if (WaitResult == WAIT_TIMEOUT) 
            {
                *RetFlags = RET_NEXT_STRIP_RX_TIMEOUT;
                goto bad_exit;
            }

            if (WaitResult == WAIT_FAILED) 
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "WaitForMultipleObjects FAILED le=%lx",
                                GetLastError());
            }

            if ( pTG->ReqTerminate || ( WaitResult == WAIT_OBJECT_0) )   
            {
                DebugPrintEx(DEBUG_MSG,"wait for next page ABORTED") ;
                goto bad_exit;
            }

            pTG->fTiffThreadRunning = 1;

            fLastReadBlockSync = pTG->fLastReadBlock;

            DebugPrintEx(   DEBUG_MSG, 
                            "Waked up with next strip. fLastReadBlockSync=%d"
                            " BytesIn=%d Out=%d",
                            fLastReadBlockSync,  
                            pTG->BytesIn, 
                            pTG->BytesOut);

        }

        fFirstRead = 0;

    } 
    while ( ! pTG->ReqTerminate );

    DebugPrintEx(DEBUG_ERR, "Got Terminate request");
    pTG->fPageIsBad = 1;

    goto bad_exit;

good_exit:
    CloseHandle(InFileHandle);
    return TRUE;



bad_exit:
    CloseHandle(InFileHandle);
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\recv.c ===
/***************************************************************************
 Name     :     RECV.C
 Comment  :     Receiver functions

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"


#include <comdevi.h>
#include <faxcodec.h>

#include "efaxcb.h"

//#include "debug.h"

#include "cas.h"
#include "bgt30.h"
//#include "dynload.h"

#include "awg3file.h"


#include "glbproto.h"
#include "t30gl.h"


#define RINGIGNORE_TIMEOUT      60000L
#define RINGINACTIVITY_TIMEOUT  15000L

BOOL ICommRecvParams(PThrdGlbl pTG, LPBC lpBC)
{
    BOOL    fLin;
    BOOL    fRet = FALSE;

    DEBUG_FUNCTION_NAME(_T("ICommRecvParams"));

    BG_CHK(lpBC);
    BG_CHK(lpBC->bctype == RECV_PARAMS);
    BG_CHK(lpBC->wTotalSize>=sizeof(BC));
    BG_CHK(lpBC->wTotalSize<=sizeof(pTG->Inst.RecvParams));

    if (pTG->fAbortRequested) 
    {
        DebugPrintEx(DEBUG_MSG, "got ABORT");
        fRet = FALSE;
        goto mutexit;
    }

    if(pTG->Inst.fAbort) // RecvParams
    {
        fRet = FALSE;
        goto mutexit;
    }

    if(pTG->Inst.state != BEFORE_RECVPARAMS)
    {
        // this will break if we send EOM...
        // then we should go back into RECV_CAPS state
        fRet = TRUE;
        goto mutexit;
    }

    _fmemset(&pTG->Inst.RecvParams, 0, sizeof(pTG->Inst.RecvParams));
    _fmemcpy(&pTG->Inst.RecvParams, lpBC, min(sizeof(pTG->Inst.RecvParams), lpBC->wTotalSize));

    // first try EFAX, then IFAX then G3
    // pTG->Inst.fG3 = FALSE;
    BG_CHK(lpBC->Std.GroupNum == 0);
    BG_CHK(lpBC->Std.GroupLength <= sizeof(BCHDR));

    if( lpBC->NSS.GroupNum == GROUPNUM_NSS &&
            lpBC->NSS.GroupLength >= sizeof(BCHDR) &&
            lpBC->NSS.vMsgProtocol != 0)
    {
        /***
        if(!lpBC->NSS.fBinaryData)      // vMsgProtocol != 0 && Binary
        {
            pTG->Inst.szFile[9]='I';     pTG->Inst.szFile[10]='F'; pTG->Inst.szFile[11]='X';
            fLin=TRUE;
        }
        else
        ***/
        // on recv don't know if binary files or not, so always assume
        {
            pTG->Inst.szFile[9]='E';
            pTG->Inst.szFile[10]='F';
            pTG->Inst.szFile[11]='X';
            fLin=TRUE;
        }
    }
    else    // not Msg Protocol must be G3
    {
        BG_CHK(lpBC->NSS.vMsgProtocol == 0);
        pTG->Inst.szFile[9]='M';
        pTG->Inst.szFile[10]='G';
        pTG->Inst.szFile[11]='3';
        fLin = FALSE;
    }

    wsprintf(pTG->Inst.szPath, "%s%s", (LPSTR)pTG->Inst.szFaxDir, (LPSTR)pTG->Inst.szFile);

    // make sure we don't have a file already open

    pTG->Inst.cbPage = 0;


#ifdef CHK
    pTG->Inst.fRecvChecking = FALSE;
#endif // CHK

    pTG->Inst.uNumBadPages = 0;
    BG_CHK(pTG->Inst.fReceiving || (!pTG->Inst.fReceiving));  ///RSL && uMyListen==2));
    pTG->Inst.fReceiving = TRUE; // we now do this in FileT30Answer as well...


   // BCtoAWFI(lpBC, &pTG->Inst.awfi);
   // WriteFileHeader(pTG->Inst.hfile, &pTG->Inst.awfi, fLin);
    pTG->Inst.awfi.fLin = fLin != FALSE;

    pTG->Inst.state = RECVDATA_BETWEENPAGES;
    fRet = TRUE;
    // fall through


mutexit:
    return fRet;
}

USHORT   ICommGetRecvPageAck(PThrdGlbl pTG, BOOL fSleep)
{
    USHORT uRet = 2;
    uRet = pTG->Inst.uRecvPageAck;
    return uRet;
}

BOOL ICommInitTiffThread(PThrdGlbl pTG)
{
    USHORT    uEnc;
    DWORD     TiffConvertThreadId;

    DEBUG_FUNCTION_NAME(_T("ICommInitTiffThread"));

    if (pTG->ModemClass != MODEM_CLASS1) 
    {
        if (pTG->Encoding == MR_DATA) 
        {
            pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MR;
        }
        else 
        {
            pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MH;
        }

        if (pTG->Resolution & (AWRES_mm080_077 |  AWRES_200_200) ) 
        {
            pTG->TiffConvertThreadParams.HiRes = 1;
        }
        else 
        {
            pTG->TiffConvertThreadParams.HiRes = 0;
        }
    }
    else 
    {

        uEnc = ProtGetRecvEncoding(pTG);
        BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);
       
        if (uEnc == MR_DATA) 
        {
            pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MR;
        }
        else 
        {
            pTG->TiffConvertThreadParams.tiffCompression =  TIFF_COMPRESSION_MH;
        }
       
        if (pTG->ProtInst.RecvParams.Fax.AwRes & (AWRES_mm080_077 |  AWRES_200_200) ) 
        {
            pTG->TiffConvertThreadParams.HiRes = 1;
        }
        else 
        {
            pTG->TiffConvertThreadParams.HiRes = 0;
        }
    }

    if (!pTG->fTiffThreadCreated) 
    {
        _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
        pTG->TiffConvertThreadParams.lpszLineID[8] = 0;

        DebugPrintEx(   DEBUG_MSG,
                        "Creating TIFF helper thread  comp=%d res=%d", 
                            pTG->TiffConvertThreadParams.tiffCompression, 
                            pTG->TiffConvertThreadParams.HiRes);

        pTG->hThread = CreateThread(
                      NULL,
                      0,
                      (LPTHREAD_START_ROUTINE) PageAckThreadSafe,
                      (LPVOID) pTG,
                      0,
                      &TiffConvertThreadId
                      );

        if (!pTG->hThread) 
        {
            DebugPrintEx(DEBUG_ERR,"TiffConvertThread create FAILED");
            return FALSE;
        }

        pTG->fTiffThreadCreated = 1;
        pTG->AckTerminate = 0;
        pTG->fOkToResetAbortReqEvent = 0;

        if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) ) 
        {
            T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
            T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum(
                                                            (LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                            sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

        }
    }
    return TRUE;
}

#define CLOSE_IN_FILE_HANDLE                            \
    if (pTG->InFileHandleNeedsBeClosed)                 \
    {                                                   \
        CloseHandle(pTG->InFileHandle);                 \
        pTG->InFileHandleNeedsBeClosed = 0;             \
    }


BOOL   ICommPutRecvBuf(PThrdGlbl pTG, LPBUFFER lpbf, SLONG slOffset)
{
    /**
            slOffset == RECV_STARTBLOCK        marks beginning of new block
            slOffset == RECV_STARTPAGE         marks beginning of new block *and* page
            slOffset == RECV_ENDPAGE           marks end of page
            slOffset == RECV_ENDDOC            marks end of document (close file etc.)
            slOffset == RECV_ENDDOC_FORCESAVE  marks end of document (close file etc.), but
                                               current RX file will be written to TIF file,
                                               whether it's bad or not. PhaseNodeF uses this
                                               option before returning actionHANGUP, because 
                                               there will be no chance to send RTN, so it's
                                               better to keep part of the last page than to lose it.
                                               
            (for all above no data supplied -- i.e lpbf == 0)

            slOffset == RECV_SEQ               means put buffer at current file position
            slOffset == RECV_FLUSH             means flush RX file buffers
            slOffset >= 0                      gives the offset in bytes from the last marked
                                               position (beginning of block) to put buffer

            pTG->Inst.cbBlockStart is always the file offset of start of current block
            pTG->Inst.cbBlockSize and cbPage are only used fro debugging
    **/

    BOOL    fRet = TRUE;
    DWORD   BytesWritten;
    DWORD   NumHandles=2;
    HANDLE  HandlesArray[2];
    DWORD   WaitResult = WAIT_TIMEOUT;
    CHAR    Buffer[DECODE_BUFFER_SIZE];
    BOOL    fEof;
    DWORD   BytesToRead;
    DWORD   BytesHaveRead;
    DWORD   BytesLeft;

    DEBUG_FUNCTION_NAME(_T("ICommPutRecvBuf"));

    HandlesArray[0] = pTG->AbortReqEvent;

    switch (slOffset)
    {
        case RECV_STARTBLOCK:
                DebugPrintEx(DEBUG_MSG, "called. Reason: RECV_STARTBLOCK");
                break;
        case RECV_STARTPAGE:
                DebugPrintEx(DEBUG_MSG,"called. Reason: RECV_STARTPAGE");
                break;
        case RECV_ENDPAGE:
                DebugPrintEx(DEBUG_MSG,"called. Reason: RECV_ENDPAGE");
                break;
        case RECV_ENDDOC:
                DebugPrintEx(DEBUG_MSG,"called. Reason: RECV_ENDDOC");
                break;
        case RECV_ENDDOC_FORCESAVE:
                DebugPrintEx(DEBUG_MSG,"called. Reason: RECV_ENDDOC_FORCESAVE");
                break;
        default:
                break;
    }


    if(slOffset==RECV_ENDPAGE || slOffset==RECV_ENDDOC || slOffset==RECV_ENDDOC_FORCESAVE)
    {
        BOOL fPageIsBadOrig;
        BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
        BG_CHK(lpbf == 0);

        pTG->Inst.uRecvPageAck = TRUE;


        //SetStatus((pTG->Inst.uRecvPageAck ? T30STATR_CONFIRM : T30STATR_REJECT), pTG->Inst.awfi.uNumPages, 0, 0);

        //////////// moved to ICommGetRecvPageAck() callback ////////////
        //      if(pTG->Inst.uModemClass==FAXCLASS1 || pTG->Inst.uModemClass == FAXCLASS0)
        //      {
        //              LPFNCHK(lpfnET30ProtRecvPageAck);
        //              lpfnET30ProtRecvPageAck(pTG->Inst.uRecvPageAck);
        //      }
        //      else
        //////////// moved to ICommGetRecvPageAck() callback ////////////

#if defined(CL2) || defined(CL2_0)
        //////////// moved to ICommGetRecvPageAck() callback ////////////
        //      if(pTG->Inst.uModemClass==FAXCLASS2 || pTG->Inst.uModemClass==FAXCLASS2_0)
        //      {
        //              LPFNCHK(lpfnClass2RecvPageAck);
        //              lpfnClass2RecvPageAck(pTG->Inst.uRecvPageAck);
        //      }
        ////////////// moved to ICommGetRecvPageAck() callback ////////////
#endif //CL2


        //here we need to wait until helper thread finishes with the page

        if (! pTG->fPageIsBad) 
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "EOP. Not bad yet. Start waiting for Rx_thrd to finish");

            HandlesArray[1] = pTG->ThrdDoneSignal;

            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, RX_ACK_THRD_TIMEOUT);

            if ( WAIT_FAILED == WaitResult) 
            {
                pTG->fPageIsBad = 1;
                DebugPrintEx(   DEBUG_ERR, 
                                "EOP. While trying to wait for RX thrd, Wait failed "
                                "Last error was %d ABORTING!" ,
                                GetLastError());
                CLOSE_IN_FILE_HANDLE;
                return FALSE; // There is no reason to continue trying to receive this fax
            } 
            else if (WAIT_TIMEOUT == WaitResult) 
            {
                pTG->fPageIsBad = 1;
                DebugPrintEx(DEBUG_ERR,"EOP. TimeOut, never waked up by Rx_thrd");
            } 
            else if (WAIT_OBJECT_0 == WaitResult) 
            {
                DebugPrintEx(DEBUG_MSG,"wait for next page ABORTED");
                CLOSE_IN_FILE_HANDLE;
                return FALSE;
            }
            else
            {
                DebugPrintEx(DEBUG_MSG,"EOP. Waked up by Rx_thrd");
            }
        }

        //
        // In some cases, we want to save bad pages too
        //
        fPageIsBadOrig = pTG->fPageIsBad;
        pTG->fPageIsBadOverride = FALSE;
        if (slOffset==RECV_ENDDOC_FORCESAVE)
        {
            if (pTG->fPageIsBad)
            {
                pTG->fPageIsBadOverride = TRUE;
                DebugPrintEx(DEBUG_MSG, "Overriding fPageIsBad (1->0) because of RECV_ENDDOC_FORCESAVE"); 
            }
            pTG->fPageIsBad = 0;
        }
        else if (pTG->ModemClass==MODEM_CLASS2_0)
        {
            pTG->fPageIsBad = (pTG->FPTSreport != 1);
            if (fPageIsBadOrig != pTG->fPageIsBad)
            {
                pTG->fPageIsBadOverride = TRUE;
                DebugPrintEx(DEBUG_MSG, "Overriding fPageIsBad (%d->%d) because of class 2.0", 
                     fPageIsBadOrig, pTG->fPageIsBad);
            }
        }

        //
        // If page is good then write it to a TIFF file.
        //

        if ((! pTG->fPageIsBad) || (slOffset == RECV_ENDDOC_FORCESAVE))
        {
            if ( ! TiffStartPage( pTG->Inst.hfile ) ) 
            {
                DebugPrintEx(DEBUG_ERR,"TiffStartPage failed");
                CLOSE_IN_FILE_HANDLE;
                return FALSE;
            }

            // Go to the begining of the RX file
            if ( SetFilePointer(pTG->InFileHandle, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER ) 
            { 
                DebugPrintEx(   DEBUG_ERR,
                                "SetFilePointer failed le=%ld",
                                GetLastError() );
                CLOSE_IN_FILE_HANDLE;
                return FALSE;
            }

            fEof = 0;
            BytesLeft = pTG->BytesIn;

            while (! fEof) 
            {
                if (BytesLeft <= DECODE_BUFFER_SIZE) 
                {
                    BytesToRead = BytesLeft;
                    fEof = 1;
                }
                else 
                {
                    BytesToRead = DECODE_BUFFER_SIZE;
                    BytesLeft  -= DECODE_BUFFER_SIZE;
                }

                if (! ReadFile(pTG->InFileHandle, Buffer, BytesToRead, &BytesHaveRead, NULL ) ) 
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "ReadFile failed le=%ld",
                                    GetLastError() );
                    CLOSE_IN_FILE_HANDLE;
                    return FALSE;
                }

                if (BytesToRead != BytesHaveRead) 
                {
                    DebugPrintEx(   DEBUG_ERR,  
                                    "ReadFile have read=%d wanted=%d",
                                    BytesHaveRead, 
                                    BytesToRead);
                    CLOSE_IN_FILE_HANDLE;
                    return FALSE;
                }

                if (! TiffWriteRaw( pTG->Inst.hfile, Buffer, BytesToRead ) ) 
                {
                    DebugPrintEx(DEBUG_ERR,"TiffWriteRaw failed");
                    CLOSE_IN_FILE_HANDLE;
                    return FALSE;
                }
                DebugPrintEx(DEBUG_MSG,"TiffWriteRaw done");
            }

            pTG->PageCount++;

            DebugPrintEx(   DEBUG_MSG,
                            "Calling TiffEndPage page=%d bytes=%d", 
                            pTG->PageCount, 
                            pTG->BytesIn);
            
            if (!TiffSetCurrentPageWidth(pTG->Inst.hfile, pTG->TiffInfo.ImageWidth))
            {
                DebugPrintEx(DEBUG_ERR,"TiffSetCurrentPageWidth failed");
            }
            if (! TiffEndPage( pTG->Inst.hfile ) ) 
            { 
                DebugPrintEx(DEBUG_ERR,"TiffEndPage failed");
                CLOSE_IN_FILE_HANDLE;
                return FALSE;
            }

        }

        CLOSE_IN_FILE_HANDLE;

        // This change solve bug #4925: 
        // "FAX: T30: If Fax server receives bad page as last page, then fax information (all pages) is lost"
        // t-jonb: If we're at the last page (=received EOP), but page was found to be bad,
        // NonECMRecvPhaseD will call here with RECV_ENDDOC, send RTN, and proceed to receive
        // the page again. Therefore, we don't want to close the TIF or terminate rx_thrd.
        // OTOH, if we're called with RECV_ENDDOC_FORCESAVE, it means we're about to hangup,
        // and should therefore close the TIF and terminate rx_thrd.
        if ((slOffset==RECV_ENDDOC && !pTG->fPageIsBad) || (slOffset == RECV_ENDDOC_FORCESAVE))
        {
            // if page was bad, mark it so in the return value for this call
            // (otherwise EFAXPUMP will not display "above received fax contains
            // errors). This is will only work if last page is bad. To be more
            // accurate we should count the bad pages and if they are non-zero
            // we should mark the recvd document as CALLFAIL.

            if ( pTG->fTiffOpenOrCreated ) 
            {
                DebugPrintEx(DEBUG_MSG,"Actually calling TiffClose");
                TiffClose( pTG->Inst.hfile );
                pTG->fTiffOpenOrCreated = 0;
            }

            // request Rx_thrd to terminate itself.
            pTG->ReqTerminate = 1;
            if (!SetEvent(pTG->ThrdSignal))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "SetEvent(0x%lx) returns failure code: %ld",
                                (ULONG_PTR)pTG->ThrdSignal,
                                (long) GetLastError());
                return FALSE;
            }

            pTG->Inst.state = BEFORE_RECVPARAMS;

        }
        else
        {
            pTG->Inst.state = RECVDATA_BETWEENPAGES;
        }

    }
    else if(slOffset == RECV_STARTPAGE)
    {
        // Fax Server wants to know when we start RX new page
        SignalStatusChange(pTG, FS_RECEIVING);

        BG_CHK(pTG->Inst.state == RECVDATA_BETWEENPAGES);
        BG_CHK(lpbf == 0);

        pTG->Inst.cbPage = 0;
        pTG->Inst.cbBlockSize = 0;
        pTG->Inst.state = RECVDATA_PHASE;
        pTG->Inst.awfi.lDataSize = 0;
        // awfi.lNextHeaderOffset here points to current header (starts at ptr to first pageheader in BCtoAWFI)
        // awfi.lDataOffset set to point to the actual data. NOT the count DWORD
        pTG->Inst.awfi.lDataOffset = pTG->Inst.awfi.lNextHeaderOffset + sizeof(AWG3HEADER) + 4;
        pTG->Inst.awfi.uNumPages++;

        ///ICommStatus(T30STATR_RECV, pTG->Inst.awfi.uNumPages, 0, 0);
        ///lOldRecvCount = 0;

        if( pTG->Inst.RecvParams.NSS.vMsgProtocol == 0 && // G3
                pTG->Inst.RecvParams.Fax.Encoding != MMR_DATA &&      // MH or MR only
                pTG->Inst.uCopyQualityCheckLevel)
        {

            // For Recvd T4 checking
            BG_CHK((pTG->Inst.RecvParams.Fax.Encoding == MH_DATA) ||
                             (pTG->Inst.RecvParams.Fax.Encoding == MR_DATA));
            BG_CHK(pTG->Inst.RecvParams.Fax.PageWidth <= WIDTH_MAX);
            // +++ 4/25/95 JosephJ WARNING -- we could be doing ecm-MH or
            // ecm-MR, so we really need to check if we're receiving ECM or
            // not. Unfortunately this information is currently not propogated
            // back up from T.30 and it's too late to that -- so (HACK)
            // we enable receive-checking here, but disable it later
            // if we get a RECV_STARTBLOCK or a >=0 lsOffset (later indicates
            // a resend. The proper fix for this is to propogate the
            // fact that we're doing ecm up from t.30.

        }


        // seek to right place, write out enough space for header
        // and place file ptr in the right place to write data


        //
        // start Helper thread once per session
        // re-set the resolution and encoding params
        if (!ICommInitTiffThread(pTG))
            return FALSE;

        _fmemcpy (pTG->InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
        _fmemcpy (&pTG->InFileName[gT30.dwLengthTmpDirectory], pTG->TiffConvertThreadParams.lpszLineID, 8);
        sprintf  (&pTG->InFileName[gT30.dwLengthTmpDirectory+8], "%s", ".RX");


        // We can't delete the file if the handle for the file is in use by the TIFF helper thread or 
        // is open by this function.
        if (pTG->InFileHandleNeedsBeClosed)
        {
            DebugPrintEx(   DEBUG_WRN, 
                            "RECV_STARTPAGE: The InFileHandle is still open,"
                            " trying CloseHandle." );
            // We have open the file but never close it. Scenario for that: We get ready to get the page into
            // *.RX file. We got EOF and go to NodeF. Instead of getting after page cmd (EOP or MPS) we get TCF.
            // Finally, we get ready for the page, but the handle is open.
            // Till now the handle was closed when we call this function with RECV_ENDPAGE or RECV_ENDDOC
            
            if (!CloseHandle(pTG->InFileHandle))
            {
                DebugPrintEx(   DEBUG_ERR,
                                "CloseHandle FAILED le=%lx",
                                GetLastError() );
            }
        }

      
        if (!DeleteFileA(pTG->InFileName))
        {
            DWORD lastError = GetLastError();
            DebugPrintEx(   DEBUG_WRN,
                            "DeleteFile %s FAILED le=%lx",
                            pTG->InFileName, 
                            lastError);
            
            if (ERROR_SHARING_VIOLATION == lastError)
            {   // If the problem is that the rx_thread have an open handle to *.RX file then:
                // Lets try to wait till the thread will close that handle
                // When the thread close the handle of the *.RX file, he will signal on ThrdDoneSignal event
                // usually RECV_ENDPAGE or RECV_ENDDOC wait for the rx_thread to finish.
                HandlesArray[1] = pTG->ThrdDoneSignal;
                if ( ( WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, RX_ACK_THRD_TIMEOUT) ) == WAIT_TIMEOUT) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "RECV_STARTPAGE. Never waked up by Rx_thrd");
                }             
                else 
                {
                    DebugPrintEx(   DEBUG_MSG,
                                    "RECV_STARTPAGE. Waked up by Rx_thrd or by abort");
                }
                // Anyhow - try to delete again the file
                if (!DeleteFileA(pTG->InFileName))    
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "DeleteFile %s FAILED le=%lx",
                                    pTG->InFileName, 
                                    GetLastError() );
                    return FALSE;
                }
            
            }
        }

        if ( ( pTG->InFileHandle = CreateFileA(pTG->InFileName, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ,
                                   NULL, OPEN_ALWAYS, 0, NULL) ) == INVALID_HANDLE_VALUE ) 
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Create file %s FAILED le=%lx",
                            pTG->InFileName, 
                            GetLastError() );
            return FALSE;
        }

        pTG->InFileHandleNeedsBeClosed = 1;

        // Reset control data for the new page ack, interface
        pTG->fLastReadBlock = 0;
        pTG->BytesInNotFlushed = 0;
        pTG->BytesIn = 0;
        pTG->BytesOut = 0;
        pTG->fPageIsBad = 0;
        if (!ResetEvent(pTG->ThrdDoneSignal))
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "ResetEvent(0x%lx) returns failure code: %ld",
                            (ULONG_PTR)pTG->ThrdDoneSignal,
                            (long) GetLastError());
            // this is bad but not fatal yet.
            // try to get the page anyway...
        }

        // get current offset
///                pTG->Inst.cbBlockStart = DosSeek(pTG->Inst.hfile, 0, 1);
    }
    else if(slOffset == RECV_STARTBLOCK)
    {
        BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
        BG_CHK(lpbf == 0);
#ifdef CHK
        BG_CHK(!pTG->Inst.fRecvChecking); // MUST NOT have Recv Checking in ECM
        // Above check will fail if encoding is MH or MR -- see
        // 4/25/95 JosephJ WARNING above -- we have a workaround -- see below
        // if (slOffset>=0)
#endif

        // seek to end of file (we may be arbitrarily in the middle)
        // and get file pos
///             pTG->Inst.cbBlockStart = DosSeek(pTG->Inst.hfile, 0, 2);
        pTG->Inst.cbBlockSize = 0;
    }
    else if(slOffset >= 0)
    {
        BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
#if 0 //RSL ifdef CHK
        if (pTG->Inst.fRecvChecking)
        {
            BG_CHK((pTG->Inst.RecvParams.Fax.Encoding == MH_DATA) ||
                             (pTG->Inst.RecvParams.Fax.Encoding == MR_DATA));
            // +++ Above should be BG_CHK(FALSE), but see
            // 4/25/95 JosephJ WARNING above.
            DebugPrintEx(   DEBUG_WRN,
                            "Disabling RecvChecking for MH/MR ECM recv");
            pTG->Inst.fRecvChecking=FALSE;
        }
#endif
        // This may not hold since we may not even have gotten the
        // whole block the first time around, so Size cannot be
        // accurately calculated
        // BG_CHK(slOffset <= pTG->Inst.cbBlockSize);
        BG_CHK(((ULONG)slOffset) <= (((ULONG)lpbf->wLengthData) << 8));
        if(slOffset >= pTG->Inst.cbBlockSize)
        {
                pTG->Inst.cbPage += (long)lpbf->wLengthData;
        }

        MyFreeBuf(pTG, lpbf);
    }
    else if (slOffset == RECV_FLUSH) 
    {
        if (! FlushFileBuffers (pTG->InFileHandle ) ) 
        {
            DebugPrintEx(   DEBUG_ERR,
                            "FlushFileBuffers FAILED LE=%lx",
                            GetLastError());

            return FALSE;
        }

        DebugPrintEx(DEBUG_MSG,"ThrdSignal FLUSH");

        pTG->BytesIn = pTG->BytesInNotFlushed;

        if (! pTG->fPageIsBad) 
        {
            if (!SetEvent(pTG->ThrdSignal))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "SetEvent(0x%lx) returns failure code: %ld",
                                (ULONG_PTR)pTG->ThrdSignal,
                                (long) GetLastError());
                return FALSE;
            }
        }

        return TRUE;

    }
    else // if(slOffset == RECV_SEQ)
    {
        BG_CHK(pTG->Inst.state == RECVDATA_PHASE);
        BG_CHK(slOffset==RECV_SEQ || slOffset==RECV_SEQBAD);

        DebugPrintEx(   DEBUG_MSG, 
                        "Write RAW Page ptr=%x; len=%d",
                        lpbf->lpbBegData, 
                        lpbf->wLengthData);

        if ( ! WriteFile( pTG->InFileHandle, lpbf->lpbBegData, lpbf->wLengthData, &BytesWritten, NULL ) ) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "WriteFile FAILED %s ptr=%x; len=%d LE=%d",
                            pTG->InFileName, 
                            lpbf->lpbBegData, 
                            lpbf->wLengthData, 
                            GetLastError());
            return FALSE;
        }

        if (BytesWritten != lpbf->wLengthData) 
        {
            DebugPrintEx(   DEBUG_ERR,
                            "WriteFile %s written ONLY %d ptr=%x; len=%d LE=%d",
                            pTG->InFileName, 
                            BytesWritten, 
                            lpbf->lpbBegData, 
                            lpbf->wLengthData, 
                            GetLastError());
            fRet = FALSE;
            return fRet;
        }

        pTG->BytesInNotFlushed += BytesWritten;

        // control helper thread
        if ( (!pTG->fTiffThreadRunning) || (pTG->fLastReadBlock) ) 
        {
            if ( (pTG->BytesInNotFlushed - pTG->BytesOut > DECODE_BUFFER_SIZE) || (pTG->fLastReadBlock) ) 
            {
                if (! FlushFileBuffers (pTG->InFileHandle ) ) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "FlushFileBuffers FAILED LE=%lx",
                                    GetLastError());
                    fRet = FALSE;
                    return fRet;
                }

                pTG->BytesIn = pTG->BytesInNotFlushed;

                if (! pTG->fPageIsBad) 
                {
                    DebugPrintEx(DEBUG_MSG,"ThrdSignal");
                    if (!SetEvent(pTG->ThrdSignal))
                    {
                        DebugPrintEx(   DEBUG_ERR, 
                                        "SetEvent(0x%lx) returns failure code: %ld",
                                        (ULONG_PTR)pTG->ThrdSignal,
                                        (long) GetLastError());
                        return FALSE;
                    }
                }
            }
        }

        pTG->Inst.cbPage += (long)lpbf->wLengthData;
        pTG->Inst.cbBlockSize += lpbf->wLengthData;

        ///if((pTG->Inst.cbPage - lOldRecvCount) >= 4000)
        {
                ///USHORT usKB = (USHORT) (LongShr8(pTG->Inst.cbPage) >> 2);
                ///SetStatus(T30STATR_RECV, pTG->Inst.awfi.uNumPages, LOBYTE(usKB), HIBYTE(usKB));
                ///lOldRecvCount = pTG->Inst.cbPage;
        }


        MyFreeBuf(pTG, lpbf);
    }
    fRet = TRUE;

    return fRet;
}

LPBC ICommGetBC(PThrdGlbl pTG, BCTYPE bctype, BOOL fSleep)
{
    LPBC    lpbc = NULL;

    BG_CHK(bctype==SEND_CAPS || bctype==SEND_PARAMS);

    if(bctype == SEND_CAPS)
    {
        BG_CHK(pTG->Inst.SendCaps.bctype == SEND_CAPS);
        lpbc = (LPBC)&pTG->Inst.SendCaps;
    }
    else
    {
#ifdef POLLREQ
        if(pTG->Inst.fInPollReq)
        {
            BG_CHK(pTG->Inst.SendPollReq.bctype == SEND_POLLREQ);
            lpbc = (LPBC)(&(pTG->Inst.SendPollReq));
        }
        else
#endif //POLLREQ
        {
            BG_CHK(pTG->Inst.SendParams.bctype == SEND_PARAMS);
            lpbc = (LPBC)(&(pTG->Inst.SendParams));
        }

        // in cases where DIS is received again after sending DCS-TCF,
        // this gets called multiple times & we need to return the same
        // SendParams BC each time
    }

    return lpbc;
}

BOOL ICommRecvPollReq(PThrdGlbl pTG, LPBC lpBC)
{
    BOOL fRet = FALSE;
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\t30.h ===
/***************************************************************************
 Name     :     T30.H
 Comment  :     Main include file for T30 driver.
                        All common structire defns etc.
 Functions:     (see Prototypes just below)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/

#include "timeouts.h"


/**---------------------- #define of sizes of things ---------------------

        Frames can be at most 2.55 secs (sent) or 3.45 secs (recvd) long, or
        2.55 * 300/8 = 96 bytes and 132 bytes long respectively

        For clumps of received frames, we collect them in a GlobalAlloced
        space for passing to teh WhatNext callback function. We arbitrarily
        decide to allow at most 10 frames and at most 500 bytes at a time.
        (500 bytes = 500/(300/8) = 13.33 secs, so that should be quite enough)

---------------------- #define of sizes of things ---------------------**/

//#define ECM_TOTALFRAMESIZE    (ECM_FRAME_SIZE + 4)


// Used for calling ModemSync(). The shorter one during calls,
// the longer one only on hangup and stuff
#define RESYNC_TIMEOUT1         1100
#define RESYNC_TIMEOUT2         500


// This are way too long. We have built-in delays anyway, so don't need
// the full time, and the recvrs have to recv from other fax machines
// so take it easy here
// #define PHASEC_PAUSE                 100     // how long to pause before TCF/phase C
#define RECV_PHASEC_PAUSE               55      // used by RecvSil() before TCF/phase C
#define SEND_PHASEC_PAUSE               75      // used by SendSil() before TCF/phase C
// ModemRecvSilence() always waits a bit longer than the amount requested
// so to get it right we ask for the minimum required, i.e. 55ms
// However ModemSendSilence() is pretty accurate, so ask for teh exact
// nominal amount, i.e. 75ms


// How long to try for AT+FRM before timing out and trying
// for an AT+FRH instead. Must be 100% *sure* to get page if there
// is one, because there's no recovery after missing that. But must
// also be sure to get the 2nd CTC if there is one.
// Other critical situations:- MCF is missed, and sender resends MPS
// We miss this because we're in FRM, but we mustn't miss the 3rd one!
// Ditto with DCS-TCF-missedCFR. Can't get 2nd, but we'll get 3rd
// #define PHASEC_TIMEOUT               2800L           // 2.8s
// increase this to 3200. Limit is 3550, but we need 200ms or so to restart
// receiving FRH=3
//#define PHASEC_TIMEOUT   3300L   // 3.3s
// increase this to 5 seconds
// it appears fax macines accept this delay before entering phase C
#define PHASEC_TIMEOUT   5000L   


// How long to try for AT+FRM in TCF before timing out and trying
// +FRH. Mustn't miss TCF, but if we do, must catch next DCS
// increase this to 3200. Limit is 3550, but we need 200ms or so to restart
// receiving FRH=3
#define TCF_TIMEOUT             3300L           // 3.3s


// don't need this one. Besides don't want to send it at startup when
// we're already transmitting HDLC. This can cause problems, if we already
// have a delay (example after TCF, sending CFR. Delay is now 115, it will
// become 180 or so).
// #define LOWSPEED_PAUSE               60              // how long to pause before HDLC
// reduce this too
#define RECV_LOWSPEED_PAUSE     55              // used by RecvSil() before HDLC
#define SEND_LOWSPEED_PAUSE     75              // used by SendSil() before HDLC
// ModemRecvSilence() always waits a bit longer than the amount requested
// so to get it right we ask for the minimum required, i.e. 55ms
// However ModemSendSilence() is pretty accurate, so ask for teh exact
// nominal amount, i.e. 75ms

// How long of silence to look for before sending V.21. (IFAX/MDDI only)
// Use LOWSPEED_PAUSE defined above.

// How long of silence to look for before sending PhaseC. (IFAX/MDDI only)
// use 40ms or more (want to be pretty sure we got silenec)
// ---> we use PHASEC_PAUSE which is OK

// How long to look for silence before sending high-speed.
// If this fails we go ahead and send anyway, so we don't want
// it too long. But we want to try pretty hard to get silence,
// because otherwise the other side will miss my training.
// 3secs is about how long a NSF-DIS takes. If we hit one
// we want to wait until it's done, not timeout??
#define LONG_RECVSILENCE_TIMEOUT        3000 // how long to wait for silence before send HDLC or PIX

// when sending DIS, DCS or DTC we may collide with DCS, DIS or DIS coming
// from the other side. This can be really long (preamble+2NSFs+CSI+DIS > 5secs)
// so wait for upto 6 secs (preamble + 150+ bytes)
#define REALLY_LONG_RECVSILENCE_TIMEOUT 6000 // how long to wait for silence before send DIS/DCS/DTC

// Used before TCF
#define SHORT_SENDSILENCE_TIMEOUT       100  // how long to wait for send-silence before TCF








#define ECHOPROTECT(ifr, mode)  { pTG->EchoProtect.ifrLastSent=ifr; pTG->EchoProtect.modePrevRecv=mode; pTG->EchoProtect.fGotWrongMode=0; }



/*****
// INI file settings related stuff
typedef struct
{
        USHORT  uIgnoreDIS;                     // non-zero==number of DIS to be ignored
        USHORT  uRecvT1Timer;           // 0==default otherwise==number of seconds
        USHORT  uSendT1Timer;           // 0==default otherwise==number of seconds

        // BOOL fTotalErrsOnly; // 0==burst 1==total
        // BOOL fNo999;                 // can't dial 999
        // USHORT       uCSICompare;    // 0==no compare 1==just existence of CSI
                                                        // 2==4 digits 3==8 digits
}
ET30INISETTINGS;
*****/

#define ECM_NEWPAGE             2
#define ECM_NEWBLOCK    1
#define ECM_RETRANSMIT  0





extern USHORT TCFLen[];



#define BadAction(pTG, a)            (ERRMSG((SZMOD "<<ERROR>> BadAction %d\r\n", a)), ICommFailureCode(pTG, T30FAIL_BUG0), BG_CHK(FALSE), actionERROR)
#define GetResponse(pTG, ifr)        GetCmdResp(pTG, FALSE, ifr)
#define GetCommand(pTG, ifr)         GetCmdResp(pTG, TRUE, ifr)

#define GetSendBuf(pTG, lplpbf, slOffset)    ICommGetSendBuf(pTG, lplpbf, slOffset)
#define PutRecvBuf(pTG, lpbf, slOffset)      ICommPutRecvBuf(pTG, lpbf, slOffset)


/****************** begin prototypes from ecm.c *****************/
ET30ACTION      ECMPhaseC(PThrdGlbl pTG, BOOL fReTx);
// ET30ACTION   ECMPhaseCRetrans(void);
ET30ACTION      ECMPhaseD(PThrdGlbl pTG);
ET30ACTION      ECMSendEOR_EOP(PThrdGlbl pTG);
ET30ACTION      ECMRecvPhaseD(PThrdGlbl pTG);
ET30ACTION      ECMRecvPhaseC(PThrdGlbl pTG, BOOL);
/***************** end of prototypes from ecm.c *****************/

/****************** begin prototypes from hdlc.c *****************/
USHORT ModemRecvBuf(PThrdGlbl pTG, HMODEM hModem, BOOL fECM, LPBUFFER far* lplpbf, ULONG ulTimeout);
/***************** end of prototypes from hdlc.c *****************/

/****************** begin prototypes from t30.c *****************/
IFR GetCmdResp(PThrdGlbl pTG, BOOL fCommand, USHORT ifrResp);
/***************** end of prototypes from t30.c *****************/



/****************** begin prototypes from t30main.c *****************/
USHORT T30MainBody(PThrdGlbl pTG, BOOL fCaller, ET30ACTION actionInitial, HLINE hLine, HMODEM hModem);
// BOOL GetDev(USHORT uPort);
// BOOL FreeDev(void);
/***************** end of prototypes from t30main.c *****************/




#define GetDevAndDial(pTG, port, phone)              (GetDev(pTG, port) && Dial(pTG, phone))
#define GetDevAndAnswer(pTG, port)                   (GetDev(pTG, port) && Answer(pTG))



#ifdef SWECM
#   pragma  message ("--------- WARNING: Software ECM ENABLED ----------")
        USHORT ModemECMRecvMode(PThrdGlbl pTG, HMODEM h, USHORT uMod, ULONG ulTimeout);
        BOOL SWECMSendSetup(PThrdGlbl pTG, BOOL fOn);
        BOOL SWECMRecvSetup(PThrdGlbl pTG, BOOL fOn);
        USHORT SWECMRecvFrame(PThrdGlbl pTG, HMODEM hModem, LPBYTE lpb, USHORT cbMax, ULONG ulTimeout, USHORT far* lpcbRecv);
        void D_HexPrint(LPB b1, UWORD incnt);
/***************** end of prototypes from swecm.c *****************/

#else
#       define ModemECMRecvMode(pTG, h, mod, t)      ModemRecvMode(pTG, h, mod, TRUE, t, ifrECMPIX)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\send.c ===
/***************************************************************************
 Name     :     SEND.C
 Comment  :     Sender functions

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"


#include <comdevi.h>
#include <faxcodec.h>

#include "efaxcb.h"

//#include "debug.h"

#include "cas.h"
#include "bgt30.h"
//#include "dynload.h"

#include "tiff.h"

#include "glbproto.h"

#include "t30gl.h"

SWORD ICommGetSendBuf(PThrdGlbl pTG, LPBUFFER far* lplpbf, SLONG slOffset)
{
    /**
            slOffset == SEND_STARTBLOCK     marks beginning of new block
            slOffset == SEND_STARTPAGE      marks beginning of new block *and* page
                                    (returns with data from the "appropriate" file offset).

            slOffset == SEND_QUERYENDPAGE cbecks if end of page

            slOffset == SEND_SEQ    means get buffer from current file position
            slOffset >= 0   gives the offset in bytes from the last marked position
                                            (beginning of block) to start reading from

            Inst.cbBlockStart is always file offset of start of current block
            Inst.cbBlockSize is bytes sent of current block in first transmission
            Inst.cbPage is bytes left to transmit in current page

            returns: SEND_ERROR     on error, SEND_EOF on eof, SEND_OK otherwise.
                             Does not return data on EOF or ERROR, i.e. *lplpbf==0
    **/

    SWORD           sRet = SEND_ERROR;
    LPBUFFER        lpbf;
    BOOL            HiRes=0;
    DWORD           dwBytesRead;

    DEBUG_FUNCTION_NAME(_T("ICommGetSendBuf"));

    if (pTG->fAbortRequested) 
    {
        DebugPrintEx(DEBUG_MSG,"got ABORT");
        sRet = SEND_ERROR;
        goto mutexit;
    }

    if(pTG->Inst.fAbort)         // GetSendBuf
    {
        // SetFailureCode already called
        sRet = SEND_ERROR;
        goto mutexit;
    }

    if(slOffset == SEND_QUERYENDPAGE)
    {
        DebugPrintEx(DEBUG_MSG,"SendBuf--query EndPage");

        BG_CHK(pTG->Inst.state == SENDDATA_PHASE || pTG->Inst.state == SENDDATA_BETWEENPAGES);
        if(pTG->Inst.cbPage == 0 || pTG->Inst.cbPage == -1)       // end of page
        {
            pTG->Inst.cbPage = -1;
            pTG->Inst.state = SENDDATA_BETWEENPAGES;
            sRet = SEND_EOF;
            goto mutexit;
        }
        else
        {
            sRet = SEND_OK; // no data returned
            goto mutexit;
        }
    }

    if(slOffset == SEND_STARTPAGE)
    {
        pTG->fTxPageDone = FALSE; // This to mark that we did not finish yet.
        if (pTG->T30.ifrResp == ifrRTN) 
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "Re-transmitting: We open again the file: %s", 
                            pTG->InFileName);            
            
            BG_CHK(pTG->InFileHandleNeedsBeClosed == FALSE); // Assure there is no handle to open file that we forgot to close
            if ( ( pTG->InFileHandle = CreateFileA(pTG->InFileName, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING, 0, NULL) ) == INVALID_HANDLE_VALUE ) 
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "OpenFile for Retranmit %s fails; CurrentOut=%d;"
                                " CurrentIn=%d",
                                pTG->InFileName, 
                                pTG->CurrentOut, 
                                pTG->CurrentIn);

                sRet = SEND_ERROR;
                goto mutexit;
            }

            pTG->InFileHandleNeedsBeClosed = TRUE;

            SignalStatusChange(pTG, FS_TRANSMITTING); // This will report the current status 

            BG_CHK(pTG->Inst.state == SENDDATA_BETWEENPAGES);
            BG_CHK(pTG->Inst.cbPage == -1);

            DebugPrintEx(   DEBUG_MSG, 
                            "SEND_STARTPAGE: Inst Data: cbPage=%d, cbBlockSize=%d,"
                            " cbBlockStart=%d",
                            pTG->Inst.cbPage, 
                            pTG->Inst.cbBlockSize, 
                            pTG->Inst.cbBlockStart);

            DebugPrintEx(   DEBUG_MSG, 
                            "SEND_STARTPAGE: CurrentOut=%d, FirstOut=%d,"
                            " LastOut=%d, CurrentIn=%d", 
                            pTG->CurrentOut, 
                            pTG->FirstOut, 
                            pTG->LastOut, 
                            pTG->CurrentIn);
            
        }
        else //First try for the current page
        {
            // Delete last successfully transmitted Tiff Page file.
            // Lets reset the counter of the retries. Attention: The speed remains the same.
            pTG->ProtParams.RTNNumOfRetries = 0; 
            _fmemcpy (pTG->InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
            _fmemcpy (&pTG->InFileName[gT30.dwLengthTmpDirectory], pTG->lpszPermanentLineID, 8);
            if (pTG->PageCount != 0)  
            {
                sprintf( &pTG->InFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  pTG->PageCount);
                if (! DeleteFileA (pTG->InFileName) ) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "file %s can't be deleted; le=%lx",
                                    pTG->InFileName, 
                                    GetLastError());
                }
                else 
                {
                    DebugPrintEx(   DEBUG_MSG,
                                    "SEND_STARTPAGE: Previous file %s deleted."
                                    " PageCount=%d, CurrentIn=%d",
			                        pTG->InFileName, 
                                    pTG->PageCount, 
                                    pTG->CurrentIn);
                }

            }

            pTG->PageCount++ ;
            pTG->CurrentIn++ ;

            DebugPrintEx(   DEBUG_MSG, 
                            "SendBuf: Starting New PAGE %d cbBlockSize=%ld"
                            " First=%d Last=%d time=%ld",
                            pTG->PageCount, 
                            pTG->Inst.cbBlockSize, 
                            pTG->FirstOut, 
                            pTG->LastOut);

            // Server wants to know when we start TX new page.
            SignalStatusChange(pTG, FS_TRANSMITTING);

            BG_CHK(pTG->Inst.state == SENDDATA_BETWEENPAGES);
            BG_CHK(pTG->Inst.cbPage == -1);
            
            DebugPrintEx(   DEBUG_MSG, 
                            "SEND_STARTPAGE: Inst Data: cbPage=%d, cbBlockSize=%d,"
                            " cbBlockStart=%d",
                            pTG->Inst.cbPage, 
                            pTG->Inst.cbBlockSize, 
                            pTG->Inst.cbBlockStart);

            DebugPrintEx(   DEBUG_MSG, 
                            "SEND_STARTPAGE (cont): CurrentOut=%d, FirstOut=%d,"
                            " LastOut=%d, CurrentIn=%d", 
                            pTG->CurrentOut, 
                            pTG->FirstOut, 
                            pTG->LastOut, 
                            pTG->CurrentIn);

            if (pTG->CurrentOut < pTG->CurrentIn ) 
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "TIFF PAGE hadn't been started CurrentOut=%d;",
                                " CurrentIn=%d",
                                pTG->CurrentOut, 
                                pTG->CurrentIn);

                sRet = SEND_ERROR;
                goto mutexit;
            }

            // some slack for 1st page
            if ( (pTG->CurrentOut == pTG->CurrentIn) && (pTG->CurrentIn == 1 ) ) 
            {
                DebugPrintEx(   DEBUG_MSG, 
                                "SEND: Wait for 1st page: CurrentOut=%d; In=%d",
                                pTG->CurrentOut, 
                                pTG->CurrentIn);

                if ( WaitForSingleObject(pTG->FirstPageReadyTxSignal, 5000)  == WAIT_TIMEOUT ) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "SEND: TIMEOUT ERROR Wait for 1st page:"
                                    " CurrentOut=%d; In=%d",
                                    pTG->CurrentOut, 
                                    pTG->CurrentIn);
                }

                DebugPrintEx(   DEBUG_MSG,
                                "SEND: Wakeup for 1st page: CurrentOut=%d; In=%d",
                                pTG->CurrentOut, 
                                pTG->CurrentIn);
            }

            // open the file created by tiff thread

            sprintf( &pTG->InFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  pTG->PageCount);

            if ( ( pTG->InFileHandle = CreateFileA(pTG->InFileName, GENERIC_READ, FILE_SHARE_READ,
                                               NULL, OPEN_EXISTING, 0, NULL) ) == INVALID_HANDLE_VALUE ) 
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "OpenFile %s fails; CurrentOut=%d;"
                                " CurrentIn=%d",
                                pTG->InFileName, 
                                pTG->CurrentOut, 
                                pTG->CurrentIn);

                sRet = SEND_ERROR;
                goto mutexit;
            }

            pTG->InFileHandleNeedsBeClosed = TRUE;

            if ( pTG->CurrentOut == pTG->CurrentIn ) 
            {
                DebugPrintEx(   DEBUG_WRN,
                                "CurrentOut=%d; CurrentIn=%d",
                                pTG->CurrentOut, 
                                pTG->CurrentIn);
            }

            //
            // Signal TIFF thread to start preparing new page if needed.
            //

            if  ( (! pTG->fTiffDocumentDone) && (pTG->LastOut - pTG->CurrentIn < 2) ) 
            {
                if (!ResetEvent(pTG->ThrdSignal))
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "ResetEvent(0x%lx) returns failure code: %ld",
                                    (ULONG_PTR)pTG->ThrdSignal,
                                    (long) GetLastError());
                    // this is bad, but not fatal yet.
                    // let's wait and see what happens with SetEvent...
                }
                pTG->ReqStartNewPage = 1;
                pTG->AckStartNewPage = 0;

                DebugPrintEx(    DEBUG_MSG, 
                                "SIGNAL NEW PAGE CurrentOut=%d; CurrentIn=%d",
                                pTG->CurrentOut, 
                                pTG->CurrentIn);

                if (!SetEvent(pTG->ThrdSignal))
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "SetEvent(0x%lx) returns failure code: %ld",
                                    (ULONG_PTR)pTG->ThrdSignal,
                                    (long) GetLastError());
                    sRet = SEND_ERROR;
                    goto mutexit;
                }
            }
        }

            // uOldPermilleDone = 0;
            // SetStatus(T30STATS_SEND, pTG->Inst.awfi.uNumPages, 0, 0);

        pTG->Inst.cbPage = pTG->Inst.awfi.lDataSize;                      // size of page
        pTG->Inst.cbBlockStart = pTG->Inst.awfi.lDataOffset;      // start of 1st block
        pTG->Inst.cbBlockSize = 0;                                           // current size of block

        pTG->Inst.state = SENDDATA_PHASE;
        sRet = SEND_OK;
        goto mutexit;
    }
    else if(slOffset == SEND_STARTBLOCK)
    {
            // called in ECM mode at start of each block. Not called
            // in the first block of each page (STARTPAGE) is called
            // instead. Therefore BlockStart and BlockSize can never
            // be 0

            DebugPrintEx(    DEBUG_ERR, 
                            "ECM SendBuf: Starting New BLOCK. cbBlockSize=%ld", 
                            pTG->Inst.cbBlockSize);
            sRet = SEND_ERROR;
            goto mutexit;
    }

    BG_CHK(lplpbf);
    *lplpbf=0;

    if(slOffset == SEND_SEQ) 
    {
        if (pTG->fTxPageDone) 
        { //In the last read from the file, we can tell that the page is over

            sRet = SEND_EOF;

            if (pTG->InFileHandleNeedsBeClosed) 
            {
                CloseHandle(pTG->InFileHandle); // If we close the file so rashly, open it again later
                pTG->InFileHandleNeedsBeClosed = FALSE;
            }
            goto mutexit;
        }

        lpbf = MyAllocBuf(pTG, pTG->Inst.sSendBufSize);
        BG_CHK(lpbf);
        BG_CHK(pTG->Inst.uSendDataSize <= lpbf->wLengthBuf-4);

        lpbf->lpbBegData = lpbf->lpbBegBuf+4;
        lpbf->dwMetaData = pTG->Inst.awfi.Encoding;

        lpbf->wLengthData = (unsigned) pTG->Inst.sSendBufSize;

        if ( ! ReadFile(pTG->InFileHandle, lpbf->lpbBegData, lpbf->wLengthData, &dwBytesRead, 0) )  
        {
            DebugPrintEx(    DEBUG_ERR, 
                            "Can't read %d bytes from %s. Last error:%d", 
                            lpbf->wLengthData, 
                            pTG->InFileName, 
                            GetLastError());
            MyFreeBuf (pTG, lpbf);
            sRet = SEND_ERROR;
            goto mutexit;
        }

        if ( lpbf->wLengthData != (unsigned) dwBytesRead )  
        {
            if (pTG->fTiffPageDone || (pTG->CurrentIn != pTG->CurrentOut) ) 
            {
                // actually reached EndOfPage
                lpbf->wLengthData = (unsigned) dwBytesRead;
                pTG->fTxPageDone = TRUE;
            }
            else 
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Wanted %d bytes but ONLY %d ready from %s",
                                 lpbf->wLengthData, 
                                 dwBytesRead, 
                                 pTG->InFileName);

                MyFreeBuf (pTG, lpbf);
                sRet = SEND_ERROR;
                goto mutexit;
            }
        }

        *lplpbf = lpbf;

        DebugPrintEx(DEBUG_MSG,"SEND_SEQ: length=%d", lpbf->wLengthData);
    }

    sRet = SEND_OK;

mutexit:

    return sRet;
}

void ICommRawCaps
(
    PThrdGlbl pTG, 
    LPBYTE lpbCSI, 
    LPBYTE lpbDIS, 
    USHORT cbDIS,
    LPFR FAR * rglpfrNSF, 
    USHORT wNumFrames
)
{
}

void ICommSetSendMode
(
    PThrdGlbl pTG, 
    BOOL fECM, 
    LONG sBufSize, 
    USHORT uDataSize, 
    BOOL fPad
)
{
    BG_CHK(sBufSize && uDataSize && uDataSize <= sBufSize-4);
    pTG->Inst.sSendBufSize = sBufSize;
    pTG->Inst.uSendDataSize = uDataSize;
    pTG->Inst.fSendPad      = fPad;
}

USHORT ICommNextSend(PThrdGlbl pTG)
{
    USHORT uRet = NEXTSEND_ERROR;

    DEBUG_FUNCTION_NAME(_T("ICommNextSend"));

    if (pTG->PageCount >= pTG->TiffInfo.PageCount) 
    {
        pTG->Inst.awfi.fLastPage = 1;
    }

    if(pTG->Inst.awfi.fLastPage)
    {
        uRet = NEXTSEND_EOP;
    }
    else
    {
        uRet = NEXTSEND_MPS;
    }

    DebugPrintEx(   DEBUG_MSG, 
                    "uRet=%d, fLastPage=%d", 
                    uRet,  
                    pTG->Inst.awfi.fLastPage);

    return uRet;
}

BOOL ICommSendPageAck(PThrdGlbl pTG, BOOL fAck)
{
    BOOL fRet = FALSE;

    BG_CHK(pTG->Inst.state == SENDDATA_BETWEENPAGES);

    if(fAck) 
    {
        SetStatus(pTG, T30STATS_CONFIRM, pTG->Inst.awfi.uNumPages, 0, 0);
        pTG->Inst.uPageAcks++;
        fRet = FALSE;
    }
    else // ifrRecv==ifrRTN
    {
        SetStatus(pTG, T30STATS_REJECT, pTG->Inst.awfi.uNumPages, 0, 0);
        fRet = TRUE; // This will signal to try do re-transmit.
    }

//mutexit:
    return fRet;
}

void ICommGotAnswer(PThrdGlbl pTG)
{
    BG_CHK(pTG->Inst.state == BEFORE_ANSWER);
    pTG->Inst.state = BEFORE_RECVCAPS;
}

BOOL ICommRecvCaps(PThrdGlbl pTG, LPBC lpBC)
{
    USHORT  uType;
    BOOL    fRet = FALSE;

    DEBUG_FUNCTION_NAME(_T("ICommRecvCaps"));
#if 0
    BG_CHK(lpBC);
    BG_CHK(lpBC->bctype == RECV_CAPS);
    BG_CHK(lpBC->wTotalSize>=sizeof(BC));
    BG_CHK(lpBC->wTotalSize<=sizeof(pTG->Inst.RemoteRecvCaps));
    BG_CHK(pTG->Inst.fSending || pTG->Inst.fInPollReq);
#endif

    if (pTG->fAbortRequested) 
    {
        DebugPrintEx(DEBUG_MSG,"got ABORT");
        fRet = FALSE;
        goto mutexit;
    }

    if(pTG->Inst.fAbort)         // recv caps
    {
        fRet = FALSE;
        goto mutexit;
    }

    if(pTG->Inst.state != BEFORE_RECVCAPS)
    {
        DebugPrintEx(DEBUG_WRN,"Got caps unexpectedly--ignoring");
        // this will break if we send EOM...
        // then we should go back into RECV_CAPS state
        fRet = TRUE;
//RSL       goto mutexit;
    }

    _fmemset(&pTG->Inst.RemoteRecvCaps, 0, sizeof(pTG->Inst.RemoteRecvCaps));
    _fmemcpy(&pTG->Inst.RemoteRecvCaps, lpBC, min(sizeof(pTG->Inst.RemoteRecvCaps), lpBC->wTotalSize));

    if(lpBC->Std.vMsgProtocol == 0) // not Msg Protocol must be G3
            uType = DEST_G3;
    else if(!lpBC->Std.fBinaryData) // vMsgProtocol != 0 && !Binary
            uType = DEST_IFAX;
    else
            uType = DEST_EFAX;


#if 0 // RSL
#ifdef USECAPI
    // update capabilities database.
    // Note: +++ assumes UpdateCapabilitiesEntry overhead is small...
    //       If not, we'll have to do this after the call is over...
    {
        char    szPhone[PHONENUMSIZE];
        BG_CHK(pTG->Inst.aCapsPhone);

        if (!GlobalGetAtomName(pTG->Inst.aCapsPhone, szPhone, sizeof(szPhone)))
        {
            BG_CHK(FALSE);
        }
        // +++ NYI First call normalizing function for phone...
        if (UpdateCapabilitiesEntry(szPhone,
                         lpBC->wTotalSize,
                         (LPBYTE) lpBC) != ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR, "Couldn't update remote caps");
        }
    }
#else // !USECAPI
    PostMessage(pTG->Inst.hwndSend, IF_FILET30_DESTTYPERES, pTG->Inst.aPhone,
                            (LPARAM)MAKELONG(MAKEWORD(uType, lpBC->Fax.AwRes),
                                                             MAKEWORD(lpBC->Fax.Encoding, lpBC->Std.vSecurity)));
#endif // !USECAPI


#ifdef POLLREQ
    if(pTG->Inst.fInPollReq)
    {
        BG_CHK(!pTG->Inst.fSending);
        fRet = DoPollReq(lpBC);
        goto mutexit;
    }
#endif

#ifdef TSK
    // must be before Negotiate caps
    if(!OpenSendFiles(pTG->Inst.aFileMG3, pTG->Inst.aFileIFX, pTG->Inst.aFileEFX))
    {
        DebugPrintEx(DEBUG_WRN/*???*/,"Can't open Send Files");
        SetFailureCode(T30FAILS_FILEOPEN);
        fRet = FALSE;
        goto mutexit;
    }
#endif //TSK
#endif // 0 RSL

    if(!NegotiateCaps(pTG))
    {
        _fmemset(&pTG->Inst.SendParams, 0, sizeof(pTG->Inst.SendParams));
        // SetFailureCode already called
        fRet = FALSE;
        goto mutexit;
    }



    ////////// Now done in the ICommGetBC callback ////////
    //      if(pTG->Inst.uModemClass==FAXCLASS1 || pTG->Inst.uModemClass == FAXCLASS0)
    //      {
    //              LPFNCHK(lpfniET30ProtSetBC);
    //              // Set Send Params
    //              if(!lpfniET30ProtSetBC((LPBC)&pTG->Inst.SendParams, SEND_PARAMS))
    //              {
    //                      // SetFailureCode already called
    //                      fRet = FALSE;
    //                      goto mutexit;
    //              }
    //      }
    //      else
    ////////// Now done in the ICommGetBC callback ////////

#if defined(CL2) || defined(CL2_0)
    ////////// Now done in the ICommGetBC callback ////////
    //      if(pTG->Inst.uModemClass==FAXCLASS2 || pTG->Inst.uModemClass==FAXCLASS2_0)
    //      {
    //              LPFNCHK(lpfnClass2SetBC);
    //              // Set CLASS2 Send Params
    //              if(!lpfnClass2SetBC((LPBC)&pTG->Inst.SendParams, SEND_PARAMS))
    //              {
    //                      // SetFailureCode already called
    //                      fRet = FALSE;
    //                      goto mutexit;
    //              }
    //      }
    ////////// Now done in the ICommGetBC callback ////////
#endif //CL2

    pTG->Inst.state = SENDDATA_BETWEENPAGES;

    pTG->Inst.uPageAcks = 0;
    pTG->Inst.cbPage = -1;
#       ifdef CHK
            pTG->Inst.fRecvChecking = FALSE;
#       endif // CHK

    fRet = TRUE;

mutexit:

    return fRet;


    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\t30.c ===
/***************************************************************************
 Name     :     T30.C
 Comment  :     Contains the main T30 routine, which drives this whole baby.
                        It calls the user-supplied protocol function to make all the
                        protocol decision functions. Thus in a sense this merely
                        a hollow shell.

                        This file should be read together with the appropriate
                        protocol function that is in use, and the T30 flowchart
                        (the enhanced one which includes ECM that is supplied in
                        T.30 Appendix-A). Ideally the (paper) copy of the chart
                        which I've annotated to chow which nodes are implemented
                        in the protocol callback function.

                        The other routines contained here implement the T.30
                        flowchart "subroutines" labelled "Response Received"
                        "Command Received", "RR Response Received" and "CTC
                        Response Received". All of which are called (only)
                        from ET30MainBody().

                        Most of teh real work is farmed out to HDLC.C (and macros
                        in HDLC.H), so the T30 routine is reasonably lucid.

                        It's organized as a block of statements with gotos between
                        them to closely mirror the T30 flowchart. (It's actually
                    uncannily close!)

 Functions:     (see Prototypes just below)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 06/14/92 arulm Created it in the new incarnation for the first time. The
                                T30Main() function is re-written to call WhatNext() at *all*
                                decision points. Some parts are simplified. It bears some
                                resemblance to the original. Command/ResponseReceived is
                                completely re-written.
 06/15/92 arulm Added ECM. Still havn't tried compiling it.
 06/16/92 arulm First successful compile.

***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"

#include "..\comm\modemint.h"
#include "..\comm\fcomint.h"
#include "..\comm\mdmcmds.h"


#include "debug.h"
#include "tiff.h"
#include "glbproto.h"
#include "t30gl.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_T30

#define SetStuffZERO(pTG, x)                          FComSetStuffZERO(pTG, x)
#define FilterSendMem(pTG, h, lpb, uCnt)      ModemSendMem(pTG, h, lpb, uCnt, 0)

/***************************************************************************
 Name     :     ET30MainBody
 Purpose  :     This is the main T30. It's main purpose is to faithfully
                        reproduce the flowchart on pages 100-103 of Fascicle VII.3
                        of the CCITT blue book, Recomendation T30.

                        It is to be called from the protocol module after a call has
                        been successfully placed or answered & the modem is in HDLC
                        receive or send mode respectively. It conducts the entire call,
                        making callbacks at all decision points to a protocol-supplied
                        callback function. It also calls protocol-supplied callback
                        functions to get data to send and to unload received data.

 Returns  :     When it returns, the phone is on hook & the modem reset.
                        It returns TRUE on successful call completion, and FALSE on
                        error. In all cases, GetLastError() will return the completion
                        status.


 Arguments:
 Comment  :     This function is supposed to mirror the brain-dead flowchart
                        so it is structured as a series of statement blocks and a rats
                        nest of Gotos. Yes I hate GOTOs too. Havn't used one in years,
                        but try to do this yourself sometime in a "structured" way.

                        The Labels used are the same as those used in the Flowchart, and
                        the blocks are arranged in approximately teh same order as in
                        the chart, so reading both together will be a pleasant surprise.
                        Make sure you use the chart in the __APPENDIX-A__ of the
                        **1988** (or Blue Book) CCITT specs. The chart in teh main body
                        of teh spec is (a) deceptively similar (b) out-of-date

 Calls    :     All of HDLC.C, some of MODEM.C, and a little of FCOM.C.
                        all the rest of the functions in this file.
 Called By:

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 06/15/92 arulm Adding ECM. Making it compilable
***************************************************************************/

#define T1_TIMEOUT       40000L  // 35s + 5s. On PCs be more lax


// #define T2_TIMEOUT   7000                    // 6s + 1s
#define T2_TIMEOUT              6000                    // 6s
#define T3_TIMEOUT              15000L                  // 10s + 5s
// #define T4_TIMEOUT   3450                    // 3s + 15%
#define T4_TIMEOUT              3000                    // 3s
// #define T4_TIMEOUT   2550                    // 3s - 15%

// if our DCS-TCF collides with the recvrs 2nd NSF-DIS or NSC-DTC
// then if the lengths are just right, we can end up in lock step
// after the first try, increase the TCF-response timeout so we
// get out of lock step! This is bug#6847
#define TCFRESPONSE_TIMEOUT_SLACK       500     // 0.5 secs


/****************** begin prototypes from t30.c *****************/
ET30ACTION PhaseNodeA(PThrdGlbl pTG);
ET30ACTION PhaseNodeT(PThrdGlbl pTG);
ET30ACTION PhaseNodeD(PThrdGlbl pTG, BOOL);
ET30ACTION NonECMPhaseC(PThrdGlbl pTG );
ET30ACTION NonECMPhaseD(PThrdGlbl pTG );
ET30ACTION RecvPhaseB(PThrdGlbl pTG, ET30ACTION action);
ET30ACTION PhaseNodeF(PThrdGlbl pTG, BOOL, BOOL);
ET30ACTION PhaseRecvCmd(PThrdGlbl pTG );
ET30ACTION PhaseGetTCF(PThrdGlbl pTG, IFR, BOOL);
ET30ACTION NonECMRecvPhaseC(PThrdGlbl pTG);
ET30ACTION NonECMRecvPhaseD(PThrdGlbl pTG);
/***************** end of prototypes from t30.c *****************/



USHORT T30MainBody
(
    PThrdGlbl pTG, 
    BOOL fCaller, 
    ET30ACTION actionInitial, 
    HLINE hLine, 
    HMODEM hModem 
)
{
    ET30ACTION              action;
    USHORT                  uRet;
    BOOL                    fEnteredHalfway;

    DEBUG_FUNCTION_NAME(_T("T30MainBody"));

    uRet = T30_CALLFAIL;

    FComCriticalNeg(pTG, TRUE);

    // zero-init the 3 global structs T30, ECM and Params. After this some
    // fields are inited to non-zero below. Rest are set approp elsewhere
    // in the code (hopefully before use :-)
    _fmemset(&pTG->Params, 0, sizeof(pTG->Params));
    _fmemset(&pTG->T30, 0, sizeof(pTG->T30));
    _fmemset(&pTG->ECM, 0, sizeof(pTG->ECM));
    _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

    pTG->Params.hModem = hModem;
    pTG->Params.hLine = hLine;
    pTG->Params.lpfnWhatNext = ProtGetWhatNext(pTG);

    // INI file settings related stuff
    pTG->T30.uSkippedDIS = 0;

    // Initialize this global. Very Important!! See HDLC.C for usage.
    pTG->T30.fReceivedDIS = FALSE;
    pTG->T30.fReceivedDTC = FALSE;
    pTG->T30.fReceivedEOM = FALSE;
    pTG->T30.uTrainCount = 0;
    pTG->T30.uRecvTCFMod = 0xFFFF;
    pTG->T30.ifrCommand = pTG->T30.ifrResp = pTG->T30.ifrSend = 0;

    pTG->ECM.ifrPrevResponse = 0;
    pTG->ECM.SendPageCount = 0;
    pTG->ECM.fEndOfPage = pTG->ECM.fRecvEndOfPage = TRUE;
    pTG->T30.fAtEndOfRecvPage = FALSE;

    pTG->ECM.fSentCTC = FALSE;
    pTG->ECM.fRecvdCTC = FALSE;

    pTG->T30.lpfs = (LPFRAMESPACE)pTG->bStaticRecvdFrameSpace;
    pTG->T30.Nframes = 0;

    fEnteredHalfway = FALSE;

    if(actionInitial != actionNULL)
    {
        DebugPrintEx(   DEBUG_WRN,
                        "Got Initial Action = %d",
                        actionInitial);
        action = actionInitial;
        fEnteredHalfway = TRUE;
        BG_CHK(action==actionGONODE_F || action==actionGONODE_D);
    }
    else if(fCaller)        // choose the right entry point
    {
            action = actionGONODE_T;
    }
    else
    {
            action = actionGONODE_R1;
            pTG->T30.fSendAfterSend = TRUE;      // CED--NSF/DIS
    }

    // fall through into PhaseLoop

    if (pTG->fAbortRequested)
    {
        goto error;
    }

    /******** Phase loop ********/

//PhaseLoop:
    for(;;)
    {
            /******************************************************************************
                    T = Start of Phase be for transmitter
                    R1 = Start of Phase B for callee
                    R2 = start of Phase B for poller
                    A = Poll/Send decision point
                    D =     Start of DCS/TCF
                    F = Recv Command loop
                    RecvCmd = Interpretation of pre-page cmds
                    RecvPhaseC = Start of Rx PhaseC (ECM and Non-pTG->ECM. New Page in ECM mode)

                    I = Start of Tx PhaseC (ECM & Non-pTG->ECM. New page in ECM mode)
                    II = Start of Tx Non-ECM PhaseD
                    III = Start of Rx Non-ECM PhaseD
                    IV = Start of Tx ECM PhaseC (Same page, new block)
                    V = Start of Tx ECM PhaseD (end of partial page)
                    VII = Start of Rx ECM PhaseD

                    RecvPRIQ = Handling of recvd PRI-Q commands
                    E = Handling of received PIP/PIN responses
            *******************************************************************************/

            switch(action)
            {
            case actionGONODE_T:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_T");
                                        PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");
                                        action = PhaseNodeT(pTG);
                                        break;
            case actionGONODE_D:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_D");
                                        action = PhaseNodeD(pTG, fEnteredHalfway);
                                        fEnteredHalfway = FALSE;
                                        break;
            case actionGONODE_A:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_A");
                                        action = PhaseNodeA(pTG);
                                        break;
            case actionGONODE_R1:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_R1");
                                        PSSLogEntry(PSS_MSG, 0, "Phase B - Negotiation");
                                        action = RecvPhaseB(pTG, action);
                                        break;
            // NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
            case actionGONODE_R2:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_R2");
                                        action = RecvPhaseB(pTG, action);
                                        break;
            // end this is never executed
            case actionNODEF_SUCCESS: 
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionNODEF_SUCCESS");
                                        action = PhaseNodeF(pTG, TRUE, FALSE);
                                        break;
            case actionGONODE_F:        
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_F");
                                        action = PhaseNodeF(pTG, FALSE, fEnteredHalfway);
                                        fEnteredHalfway = FALSE;
                                        break;
            case actionGONODE_RECVCMD:  
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_RECVCMD");
                                        action = PhaseRecvCmd(pTG);
                                        break;
            case actionGONODE_I:        
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_I");
                                        action = NonECMPhaseC(pTG);
                                        break;
            case actionGONODE_II:       
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_II");
                                        action = NonECMPhaseD(pTG);
                                        break;
            case actionGONODE_III:      
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_III");
                                        action = NonECMRecvPhaseD(pTG);
                                        break;
            case actionGONODE_IV:       
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_IV_New");
                                        action = ECMPhaseC(pTG, FALSE);      // ReTx
                                        break;
            case actionGONODE_ECMRETRANSMIT:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_ECMRETRANSMIT");
                                        action = ECMPhaseC(pTG, TRUE);       // ReTx
                                        break;
            case actionGONODE_V:        
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_V");
                                        action = ECMPhaseD(pTG);
                                        break;
            case actionSENDEOR_EOP: 
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionSENDEOR_EOP");
                                        action = ECMSendEOR_EOP(pTG);
                                        break;
            case actionGONODE_VII:  
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_VII");
                                        action = ECMRecvPhaseD(pTG);
                                        break;
            case actionGONODE_RECVPHASEC:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_RECVPHASEC");
                                        if(ProtReceivingECM(pTG))
                                        {
                                                action = ECMRecvPhaseC(pTG, FALSE);
                                        }
                                        else
                                        {
                                                action = NonECMRecvPhaseC(pTG);
                                        }
                                        break;
            case actionGONODE_RECVECMRETRANSMIT:
                                        BG_CHK(ProtReceivingECM(pTG));
                                        action = ECMRecvPhaseC(pTG, TRUE);
                                        break;
            case actionNULL:
                                        BG_CHK(FALSE);
                                        goto error;
            case actionDCN_SUCCESS: 
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionDCN_SUCCESS");
                                        uRet = T30_CALLDONE;
                                        goto NodeC;     // successful end of send call
            case actionHANGUP_SUCCESS:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionHANGUP_SUCCESS");
                                        uRet = T30_CALLDONE;
                                        goto NodeB;     // successful end of recv call
            case actionDCN:             
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionDCN");
                                        goto NodeC;
            case actionHANGUP:          
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionHANGUP");
                    // This should only be called on a _successful_ completion,
                    // otherwise we get either (a) a DCN that MSGHNDLR does not
                    // want OR (b) A fake EOJ posted to MSGHNDLR. See bug#4019
                                        goto NodeB;
            case actionERROR:           
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionERROR");
                                        // ICommStatus(T30STAT_ERROR, 0, 0, 0);
                                        goto error;

            default:
                                        BG_CHK(FALSE);
                                        goto error;

#ifdef PRI
            case actionGONODE_RECVPRIQ:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_RECVPRIQ");
                                        goto RecvPriQ;

            case actionGONODE_E:
                                        DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGONODE_E");
                                        goto NodeE;
            case actionGOVOICE:         DebugPrintEx(DEBUG_MSG,"EndPhase: Got actionGOVOICE");
                                        goto VoiceLine;
#endif
            }
    }

// ATTENTION 50 lines rem out!!!!!
// Also, there is no label PhaseLoop, so if this code would be active there will be an error


    /******** PRI-Q stuff (Rx side) ********/
#ifdef PRI
    // no fall through here
    BG_CHK(FALSE);
RecvPRIQ:
    switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTPRIQ, (WORD)pTG->T30.ifrCommand))
    {
      case actionSENDPIP:   pTG->T30.ifrSend=ifrPIP; 
                            goto VoiceLine;
      case actionSENDPIN:   pTG->T30.ifrSend=ifrPIN; 
                            goto VoiceLine;
      case actionGONODE_F:  CLEAR_MISSED_TCFS();    
                            break;
      case actionGO_RECVPOSTPAGE:
                            pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPRI_MPS+ifrMPS;
                            action = GONODE_III;
                            break;
      case actionHANGUP:    break;
      case actionERROR:     break;  // goto PhaseLoop & exit
////      default:                              return BadAction(action);
    }
    goto PhaseLoop;


    /******** PIP/PIN stuff (Tx side) ********/

    // no fall through here
    BG_CHK(FALSE);
NodeE:
    switch(action = pTG->Params.lpfnWhatNext(   pTG, 
                                                eventGOTPIPPIN,
                                                (WORD)pTG->T30.ifrResp, 
                                                (DWORD)pTG->T30.ifrSend))
    {
      case actionGOVOICE:   goto VoiceLine;
      case actionGONODE_A:  BG_CHK(FALSE);  // dunno what to do here
      case actionDCN:       DebugPrintEx(   DEBUG_ERR,  
                                            "Got actionDCN from eventGOTPIPPIN");
                            action = actionDCN;
                            break;
      case actionERROR:     break;  // goto PhaseLoop & exit
////      default:                              return BadAction(action);
    }
    goto PhaseLoop;
    // no fall through here

VoiceLine:
    SendSingleFrame(pTG, pTG->T30.ifrSend, 0, 0, 1);             // re-send PRI-Q or send PIP/PIN
    switch(action = pTG->Params.lpfnWhatNext(pTG, eventVOICELINE))
    {
      case actionHANGUP:    DebugPrintEx(   DEBUG_ERR,  
                                            "Got actionHANGUP from eventVOICELINE");
                            action = actionHANGUP;
                            break;
      case actionGONODE_T:
      case actionGONODE_R1:
      case actionGONODE_R2: break;
      case actionERROR:     break;  // goto PhaseLoop & exit
////      default:                              return BadAction(action);
    }
    goto PhaseLoop;
#endif




error:
    DebugPrintEx(   DEBUG_ERR,  
                    "=======******* USER ABORT or TRANSPORT FATAL ERROR *******========");

    // must call this always, because it's resets the Modem Driver's
    // global state (e.g. shuts down SW framing & filters if open,
    // resets the state variables etc (EndMode()))
    // Must call it before the SendDCN() because SendDCN causes
    // BG_CHKs if in strange state.

    ModemSync(pTG, pTG->Params.hModem, RESYNC_TIMEOUT1);

    if(pTG->T30.fReceivedDIS || pTG->T30.fReceivedDTC)
    {
        if(!SendDCN(pTG))
        {
            DebugPrintEx(DEBUG_ERR,"Could not send DCN");
        }
    }

    // hangup in T30Main
    // NCULink(pTG->Params.hLine, 0, 0, NCULINK_HANGUP);
    // already hungup?

    FComCriticalNeg(pTG, FALSE); //if NCR not defined then do nothing
    uRet = T30_CALLFAIL;
    goto done;


NodeC:
    PSSLogEntry(PSS_MSG, 0, "Phase E - Hang-up");
    
    // +++ 4/12/95 Win95 hack --  to prevent ModemSync from sending
    // an AT here.

    ModemSyncEx(pTG, pTG->Params.hModem, RESYNC_TIMEOUT1, fMDMSYNC_DCN);

    PSSLogEntry(PSS_MSG, 1, "Sending DCN");
    if(!SendDCN(pTG))
    {
        // We are the senders, so we should send DCN now.
        DebugPrintEx(DEBUG_ERR,"Could not send DCN");
    }
    // falls through here to receiving termination
NodeB:

    // call this here also??
    // ModemSync(pTG->Params.hModem, RESYNC_TIMEOUT1);

    // hangup in T30Main
    // NCULink(pTG->Params.hLine, 0, 0, NCULINK_HANGUP);

    FComCriticalNeg(pTG, FALSE);  //if NCR not defined then do nothing
    // fall through to done:

done:
    return uRet;
}
// End of T30 routine!!!!!!!!!



ET30ACTION PhaseNodeA(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("PhaseNodeA"));

    if(pTG->T30.ifrCommand == ifrDIS)
    {
        pTG->T30.fReceivedDIS = TRUE;
    }
    else if(pTG->T30.ifrCommand == ifrDTC)
    {
        pTG->T30.fReceivedDTC = TRUE;
    }

    return (pTG->Params.lpfnWhatNext) (pTG, eventNODE_A, (WORD)pTG->T30.ifrCommand);
}

ET30ACTION PhaseNodeT(PThrdGlbl pTG)
{
    DEBUG_FUNCTION_NAME(_T("PhaseNodeT"));


    /******** Transmitter Phase B. Fig A-7/T.30 (sheet 1) ********/
    // NodeT:

    // Have to redo this "DIS bit" everytime through PhaseB
    pTG->T30.fReceivedDIS = FALSE;
    // also the Received EOM stuff
    pTG->T30.fReceivedEOM = FALSE;
    // and teh received-DTC stuff
    pTG->T30.fReceivedDTC = FALSE;


    // INI file settings related stuff
    if(pTG->ProtParams.SendT1Timer)
        TstartTimeOut(pTG, &pTG->T30.toT1, pTG->ProtParams.SendT1Timer);
    else
        TstartTimeOut(pTG, &pTG->T30.toT1, T1_TIMEOUT);
    do
    {
        if(pTG->Params.lpfnWhatNext(pTG, eventNODE_T) == actionERROR)
                break;

        // no need for echo protection. We havnt transmitted anything!
        pTG->T30.ifrCommand = GetCommand(pTG, ifrPHASEBcommand);
        DebugPrintEx(   DEBUG_MSG,
                        "GetCommand returned %s",
                        ifr_GetIfrDescription(pTG->T30.ifrCommand));
        switch(pTG->T30.ifrCommand)
        {
          // ifrTIMEOUT means no flags before T2
          // ifrNULL means timeout, or loss of carrier, or no flags
          // or no frame. ifrBAD means *only* bad frames recvd.
          case ifrBAD:          
          case ifrTIMEOUT:
          case ifrNULL:         break;

          case ifrCSI:
          case ifrNSF:          if (!pTG->ProtInst.fRecvdDIS)
                                {
                                    DebugPrintEx(DEBUG_WRN,"Ignoring NSF/CSI without DIS");
                                    break;
                                }
                                // if we're here the NSF-CSI-DIS was received in wrong
                                // order (this is a violation of the T30 protocol
                                // but we accept it anyway...
                                // pretend it's a DIS
                                pTG->T30.ifrCommand = ifrDIS;
          case ifrDIS:          // INI file settings related stuff
                                if (pTG->ProtParams.IgnoreDIS && ((int)pTG->T30.uSkippedDIS < pTG->ProtParams.IgnoreDIS))
                                {
                                    DebugPrintEx(DEBUG_WRN,"Ignoring First DIS");
                                    pTG->T30.uSkippedDIS++;
                                    break;  // continue with T1 loop
                                }

          case ifrDTC:          return actionGONODE_A;  // got a valid frame

          default:              DebugPrintEx(   DEBUG_ERR,
                                                "Caller T1: Got random ifr=%d",
                                                pTG->T30.ifrCommand);
                                break;  // continue with T1 loop
        }
    }
    while(TcheckTimeOut(pTG, &pTG->T30.toT1));

    PSSLogEntry(PSS_ERR, 1, "Failed to receive DIS - aborting");
    ICommFailureCode(pTG, T30FAILS_T1);
    return actionHANGUP;
}

/*
    This node is transmitter side's TCF: Training Check Frame, known as 'phase B'.

*/

ET30ACTION PhaseNodeD(PThrdGlbl pTG, BOOL fEnteredHere)
{
    LPLPFR          lplpfr;
    USHORT          N;
    ET30ACTION      action;
    USHORT          uWhichDCS;      // 0=first, 1=after NoReply 2=afterFTT
    DWORD           TiffConvertThreadId;
    IFR             lastResp;       // The last respond from receiver

    /******** Transmitter Phase B2. Fig A-7/T.30 (sheet 1) ********/

    DEBUG_FUNCTION_NAME(_T("PhaseNodeD"));

    DebugPrintEx(   DEBUG_MSG,
                    "Now doing TCF, the last messages was: send=%d, receive=%d",
                    pTG->T30.ifrSend,
                    pTG->T30.ifrResp);

    // lets save the last received FSK, so we could know later that we have RTN in T30 Phase D (post page)
    // before this retrain phase (T30 Phase B)
    lastResp = pTG->T30.ifrResp;

    if (pTG->Inst.SendParams.Fax.Encoding == MR_DATA) 
    {
        pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MR;
    }
    else 
    {
        pTG->TiffConvertThreadParams.tiffCompression = TIFF_COMPRESSION_MH;
    }

    if (pTG->Inst.SendParams.Fax.AwRes & ( AWRES_mm080_077 | AWRES_200_200 ) ) 
    {
        pTG->TiffConvertThreadParams.HiRes = 1;
    }
    else 
    {
        pTG->TiffConvertThreadParams.HiRes = 0;

        // use LoRes TIFF file prepared by FaxSvc

        // pTG->lpwFileName[ wcslen(pTG->lpwFileName) - 1] = (unsigned short) ('$');
    }

    _fmemcpy (pTG->TiffConvertThreadParams.lpszLineID, pTG->lpszPermanentLineID, 8);
    pTG->TiffConvertThreadParams.lpszLineID[8] = 0;

    uWhichDCS = 0;


NodeD:
    N = 0;
    lplpfr = 0;
    action = pTG->Params.lpfnWhatNext(  pTG, 
                                        eventSENDDCS,
                                        (WORD)uWhichDCS,
                                        (ULONG_PTR)((LPUWORD)&N),
                                        (ULONG_PTR)((LPLPLPFR)&lplpfr));
    switch(action)
    {
      case actionDCN:               DebugPrintEx(   DEBUG_ERR,  
                                                    "Got actionDCN from eventSENDDCS(uWhichDCS=%d)",
                                                    uWhichDCS);
                                    return actionDCN;
      case actionSENDDCSTCF:        break;
      case actionSKIPTCF:           break;  // Ricoh hook
      case actionERROR:             return action;  // goto PhaseLoop & exit
      default:                      return BadAction(pTG, action);
    }

NodeDprime:     // used only by TCF--no reply



    // The WhatNext function check for User-Abort, in NodeD we call this function and now we don't have to
    // So we check here for hangup as WhatNext do and return actionERROR in case there was an User Abrot request

    if (pTG->fAbortRequested)
    {
        if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset))
        {
            DebugPrintEx(   DEBUG_MSG,
                            "(D-Prime)found that there was an Abort."
                            " RESETTING AbortReqEvent");
            pTG->fAbortReqEventWasReset = TRUE;
            if (!ResetEvent(pTG->AbortReqEvent))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "ResetEvent(0x%lx) returns failure code: %ld",
                                (ULONG_PTR)pTG->AbortReqEvent,
                                (long) GetLastError());
            }
        }

        DebugPrintEx(DEBUG_MSG,"ABORTing");
        return actionERROR;
    }

    // This function do nothing!! the call ProtGetSendMod do nothing as side effect, just return npProt->llNegot.Baud
    ICommStatus(pTG, T30STATS_TRAIN, ProtGetSendMod(pTG), (USHORT)(pTG->T30.uTrainCount+1), 0);

    PSSLogEntry(PSS_MSG, 1, "Sending TSI-DCS");

    // Check for the returned value, Maybe the receiver hang-up
    if (!SendManyFrames(pTG, lplpfr, N))
    {
        // The function print debug information
        // What else shall we do??
        PSSLogEntry(PSS_ERR, 1, "Failed to send TSI-DCS - aborting");
        return actionDCN;
    }

    if(action != actionSKIPTCF)             // Ricoh hook
    {
        if (!pTG->fTiffThreadCreated) 
        {
             DebugPrintEx(DEBUG_MSG,"Creating TIFF helper thread");
             pTG->hThread = CreateThread(
                           NULL,
                           0,
                           (LPTHREAD_START_ROUTINE) TiffConvertThreadSafe,
                           (LPVOID) pTG,
                           0,
                           &TiffConvertThreadId
                           );

             if (!pTG->hThread) 
             {
                 DebugPrintEx(DEBUG_ERR,"TiffConvertThread create FAILED");
                 return actionDCN;
             }

             pTG->fTiffThreadCreated = TRUE;
             pTG->AckTerminate = FALSE;
             pTG->fOkToResetAbortReqEvent = FALSE;

             if ( (pTG->RecoveryIndex >=0 ) && (pTG->RecoveryIndex < MAX_T30_CONNECT) ) 
             {
                 T30Recovery[pTG->RecoveryIndex].TiffThreadId = TiffConvertThreadId;
                 T30Recovery[pTG->RecoveryIndex].CkSum = ComputeCheckSum(
                                                                 (LPDWORD) &T30Recovery[pTG->RecoveryIndex].fAvail,
                                                                 sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1 );

             }
        }

        PSSLogEntry(PSS_MSG, 1, "Sending TCF...");
        
        if (!SendTCF(pTG))
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to send TCF - aborting");
            return actionDCN;
        }

        pTG->T30.uTrainCount++;
        PSSLogEntry(PSS_MSG, 1, "Successfully sent TCF");
    }

    // no need for echo protection? Wouldnt know what to do anyway!
    pTG->T30.ifrResp = GetResponse(pTG, ifrTCFresponse);

#ifdef RICOHAI
    if(fEnteredHere)
    {
        if(pTG->T30.ifrResp != ifrCFR && pTG->T30.ifrResp != ifrFTT)
        {
            DebugPrintEx(DEBUG_WRN,"Send-side AI protocol failed");
            fUsingOEMProt = FALSE;
            return actionGONODE_T;
        }
    }
#else
    BG_CHK(!fEnteredHere);
#endif

    // Before this switch check if there was an abort!!!
    switch(pTG->T30.ifrResp)
    {
      case ifrDCN:          PSSLogEntry(PSS_ERR, 1, "Recevied DCN - hanging up");
                            ICommFailureCode(pTG, T30FAILS_TCF_DCN);
                            return actionHANGUP;    // got DCN. Must hangup
      case ifrBAD:          // ifrBAD means *only* bad frames recvd. Treat like NULL
      case ifrNULL:         // timeout. May try again
                            if(pTG->T30.uTrainCount >= 3)
                            {
                                PSSLogEntry(PSS_ERR, 1, "Failed to receive response from TCF 3 times - aborting");
                                ICommFailureCode(pTG, T30FAILS_3TCFS_NOREPLY);
                                return actionDCN; // Maybe we should return here actionHANGUP
                            }
                            else
                            {
                                PSSLogEntry(PSS_WRN, 1, "Failed to receive response from TCF - sending TSI-DCS again");
                                uWhichDCS = 1;
                                // goto NodeD;                  // send new DCS??
                                goto NodeDprime;        // resend *same* DCS, same baudrate
                            }
      case ifrDIS:
      case ifrDTC:          if(pTG->T30.uTrainCount >= 3)
                            {
                                DebugPrintEx(DEBUG_ERR,"Got DIS/DTC after 3 TCFs");
                                ICommFailureCode(pTG, T30FAILS_3TCFS_DISDTC);
                                return actionDCN;
                            }
                            else
                            {
                                pTG->T30.ifrCommand = pTG->T30.ifrResp;
                                return actionGONODE_A;
                            }
      case ifrFTT:
                            // reset training count on FTT since we drop speed. Want to try
                            // 3 times _without_ a response (DIS DTC doesn't count) before
                            // giving up
                            PSSLogEntry(PSS_WRN, 1, "Received FTT - renegotiating");
                            pTG->T30.uTrainCount = 0;
                            uWhichDCS = 2;
                            goto NodeD;
      case ifrCFR: // This is the normal respond
                            pTG->T30.uTrainCount = 0;
                            PSSLogEntry(PSS_MSG, 1, "Received CFR");
                            switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTCFR))
                            {
                            case actionGONODE_I:                  // Non-ECM PhaseC
                                                    DebugPrintEx(   DEBUG_MSG, 
                                                                    "T30 PhaseB: Got CFR, Non-ECM PhaseC");
                            case actionGONODE_IV:                 // ECM PhaseC, new page
                                                    {
                                                        // This is an Hack. Now we got CFR, we should start transmitting the last page again
                                                        // We put back the RTN to 'ifrResp' so that T30 PhaseC will know to send the same page.
                                                        if (lastResp == ifrRTN) 
                                                        {
                                                            pTG->T30.ifrResp = ifrRTN;
                                                        }
                                                        return action;
                                                    }
                            case actionGONODE_D:
                                                    goto NodeD;                     // Ricoh hook
                            case actionERROR:
                                                    return action;  // goto PhaseLoop & exit
                            default:
                                                    return BadAction(pTG, action);
                            }
      default:
      {
            DebugPrintEx(DEBUG_ERR,"Unknown Reply to TCF");
            ICommFailureCode(pTG, T30FAILS_TCF_UNKNOWN);
            return actionDCN;
      }
    }
    BG_CHK(FALSE);
}

ET30ACTION NonECMPhaseC(PThrdGlbl pTG)
{
    /******** Transmitter Phase C. Fig A-7/T.30 (sheet 1) ********/

    LPBUFFER        lpbf=0;
    ULONG           lTotalLen=0;
    SWORD           swRet;
    USHORT          uMod, uEnc;

    DEBUG_FUNCTION_NAME(("NonECMPhaseC"));

/***
    switch(action = pTG->Params.lpfnWhatNext(eventSTARTSEND))
    {
      case actionCONTINUE:  break;
      case actionDCN:
      case actionHANGUP:    return action;
      case actionERROR:             return action;  // goto PhaseLoop & exit
      default:                              return BadAction(action);
    }
***/

    // already done in WhatNext
    // ICommSetSendMode(FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);

    // Callback to open file to send. Returns no data

    PSSLogEntry(PSS_MSG, 0, "Phase C - Page transmission");

    if((swRet=GetSendBuf(pTG, 0, SEND_STARTPAGE)) != SEND_OK)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Nonzero return %d from SendProc at Start Page",
                        swRet);
        // return actionDCN;
        return actionERROR;
    }

    DebugPrintEx(DEBUG_MSG, "Got Startpage in T30");

    uEnc = ProtGetSendEncoding(pTG);
    BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);
    uMod = ProtGetSendMod(pTG);
    // in non-ECM mode, PhaseC is ALWAYS with short-train.
    // Only TCF uses long-train
    if(uMod >= V17_START) uMod |= ST_FLAG;


    // **MUST** call RecvSilence here since it is recv-followed-by-send case
    // here we should use a small timeout (100ms?) and if it fails,
    // should go back to sending the previous V21 frame (which could be DCS
    // or MPS or whatever, which is why it gets complicated & we havn't
    // done it!). Meanwhile use a long timeout, ignore return value
    // and send anyway.
    if(!ModemRecvSilence(pTG, pTG->Params.hModem, RECV_PHASEC_PAUSE, LONG_RECVSILENCE_TIMEOUT))
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "Non-ECM PIX RecvSilence(%d, %d) FAILED!!!",
                        RECV_PHASEC_PAUSE, 
                        LONG_RECVSILENCE_TIMEOUT);
    }

    if(!ModemSendMode(pTG, pTG->Params.hModem, uMod, FALSE, (IFR)((uEnc==MR_DATA) ? ifrPIX_MR : ifrPIX_MH)))
    {
        DebugPrintEx(   DEBUG_ERR,  
                        "ModemSendMode failed in Tx PhaseC");
        ICommFailureCode(pTG, T30FAILS_SENDMODE_PHASEC);
        BG_CHK(FALSE);
        return actionERROR;
    }


    // need to send these quickly to avoid underrun (see bug842).
    // Also move the preamble/postamble into the ModemSendMode
    // and ModemSendMem(FINAL)
    // Already sent (in ModemSendMode)
    // SendZeros(PAGE_PREAMBLE, FALSE);      // Send some zeros to warm up....

    //  need to set line min zeros here. get from prot and call Modem
    SetStuffZERO(pTG, (ProtGetMinBytesPerLine(pTG)) );  // Enable ZERO stuffing

    // Start yielding *after* entering PhaseC and getting some stuff into the buffer
    FComCriticalNeg(pTG, FALSE);

    // DONT SEND an EOL here. See BUG#6441. We now make sure the EOL is
    // added by FAXCODEC. At this level we only append the RTC

#ifdef IFAX
    BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, PSIFAX_SEND, (uMod & (~ST_FLAG)));
#endif
    PSSLogEntry(PSS_MSG, 1, "Sending page %d data...", pTG->PageCount);

    lTotalLen = 0;
    BG_CHK(lpbf == 0);
    while((swRet=GetSendBuf(pTG, &lpbf, SEND_SEQ)) == SEND_OK)
    {
        BG_CHK(lpbf);
        if(!lpbf->wLengthData)
        {
            DebugPrintEx(DEBUG_ERR,"Got 0 bytes from GetSendBuf--freeing buf");
            MyFreeBuf(pTG, lpbf);
            continue;
        }

        lTotalLen += lpbf->wLengthData;

        if(!FilterSendMem(pTG, pTG->Params.hModem, lpbf->lpbBegData, lpbf->wLengthData))
        {
            PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
            ICommFailureCode(pTG, T30FAILS_MODEMSEND_PHASEC);
            BG_CHK(FALSE);
            return actionERROR;             // goto error;
        }

        if(!MyFreeBuf(pTG, lpbf))
        {
            DebugPrintEx(DEBUG_ERR,"FReeBuf failed in NON-ECM Phase C");
            ICommFailureCode(pTG, T30FAILS_FREEBUF_PHASEC);
            BG_CHK(FALSE);
            return actionERROR;             // goto error;
        }
        lpbf = 0;
    }
    BG_CHK(!lpbf);

    PSSLogEntry(PSS_MSG, 2, "send: page data, %d bytes", lTotalLen);

    if(swRet == SEND_ERROR)
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to send page data - aborting");
        // return actionDCN;
        return actionERROR;
    }
    BG_CHK(swRet == SEND_EOF);

    PSSLogEntry(PSS_MSG, 1, "Successfully sent page data - sending RTC");

    SetStuffZERO(pTG, 0);        // Disable ZERO stuffing BEFORE sending RTC!

    if(!SendRTC(pTG, FALSE))                     // RTC and final flag NOT set
    {
        PSSLogEntry(PSS_ERR, 1, "Failed to send RTC - aborting");
        BG_CHK(FALSE);
        ICommFailureCode(pTG, T30FAILS_MODEMSEND_ENDPHASEC);
        return actionERROR;                     // error return from ModemSendMem
    }

    PSSLogEntry(PSS_MSG, 1, "Successfully sent RTC");

    // Turn off yielding *before* the buffer completely drains
    FComCriticalNeg(pTG, TRUE);

#if (PAGE_POSTAMBLE_DIV != 0)
    BG_CHK(PAGE_POSTAMBLE_DIV);
    // Send zeros to cool off FINAL flag SET
    SendZeros(pTG, (USHORT)(TCFLen[uMod & 0x0F] / (PAGE_POSTAMBLE_DIV)), TRUE);
#else
    // Need this!! Need to send the SEND_EOF flag to modem driver
    SendZeros(pTG, 1, TRUE);             // sending 0 bytes is a bit unsafe....
#endif // (PAGE_POSTAMBLE_DIV != 0)


    // I think this can precede the SEND_FINAL code,
    // to be _very_ safe put it after the whole buffer has drained

    // need to set line min back to 0 here.
    //+++SetStuffZERO(0);   // Disable ZERO stuffing

    DebugPrintEx(   DEBUG_MSG,
                    "Page Send Done.....len=(%ld, 0x%08x)", 
                    lTotalLen, 
                    lTotalLen);
    pTG->T30.fSendAfterSend = TRUE;      // PhaseC/PIX--MPS/EOM/EOP
    return actionGONODE_II;
}

ET30ACTION NonECMPhaseD(PThrdGlbl pTG)
{
    USHORT          uTryCount;
    ET30ACTION      action;

    /******** Transmitter Phase D. Fig A-7/T.30 (sheet 2) ********/
    // NodeII:

    DEBUG_FUNCTION_NAME(_T("NonECMPhaseD"));

    PSSLogEntry(PSS_MSG, 0, "Phase D - Post message exchange");

    switch(action = pTG->Params.lpfnWhatNext(pTG, eventPOSTPAGE))
    {
        case actionSENDMPS:     pTG->T30.ifrSend = ifrMPS; 
                                break;
        case actionSENDEOM:     pTG->T30.ifrSend = ifrEOM; 
                                break;
        case actionSENDEOP:     pTG->T30.ifrSend = ifrEOP; 
                                break;
#ifdef PRI
        case actionSENDPRIMPS:  pTG->T30.ifrSend = ifrPRIMPS; 
                                break;
        case actionSENDPRIEOM:  pTG->T30.ifrSend = ifrPRIEOM; 
                                break;
        case actionSENDPRIEOP:  pTG->T30.ifrSend = ifrPRIEOP; 
                                break;
#endif
        case actionERROR:       return action;  // goto PhaseLoop & exit
        default:                return BadAction(pTG, action);
    }

    for(uTryCount=0;;)
    {
        DebugPrintEx(   DEBUG_MSG, 
                        "Sending postpage #=%d in T30",
                        pTG->T30.ifrSend);

        PSSLogEntry(PSS_MSG, 1, "Sending %s", rgFrameInfo[pTG->T30.ifrSend].szName);
                        
        // RSL dont sleep here
        SendSingleFrame(pTG, pTG->T30.ifrSend, 0, 0, 0);

    echoretry:
        pTG->T30.ifrResp = GetResponse(pTG, ifrPOSTPAGEresponse);
        // if we hear our own frame, try to recv again. DONT retransmit!
        if(pTG->T30.ifrResp==pTG->T30.ifrSend) 
        { 
            DebugPrintEx(   DEBUG_WRN,
                            "Ignoring ECHO of %s(%d)", 
                            (LPSTR)(rgFrameInfo[pTG->T30.ifrResp].szName), 
                            pTG->T30.ifrResp);
            goto echoretry;
        }

        DebugPrintEx(   DEBUG_MSG,
                        "Got postpage resp #=%d in T30", 
                        pTG->T30.ifrResp);

        if(pTG->T30.ifrResp != ifrNULL && pTG->T30.ifrResp != ifrBAD)
            break;

        if(++uTryCount >= 3)
        {
            PSSLogEntry(PSS_ERR, 1, "Received no response after 3 attempts - aborting");
            ICommFailureCode(pTG, T30FAILS_3POSTPAGE_NOREPLY);
            return actionDCN;
        }
        PSSLogEntry(PSS_WRN, 1, "Received no response - retrying");
    }

    PSSLogEntry(PSS_MSG, 1, "Received %s", rgFrameInfo[pTG->T30.ifrResp].szName);

    switch(pTG->T30.ifrResp)
    {
      case ifrBAD:      // ifrBAD means *only* bad frames recvd. Treat like NULL
      case ifrNULL:     BG_CHK(FALSE);          // these should never get here
                        ICommFailureCode(pTG, T30FAILS_BUG1);
                        return actionERROR;             // in case they do
      case ifrDCN:      DebugPrintEx(   DEBUG_ERR,  
                                        "Got ifrDCN from GetResponse after sending post-page command");
                        ICommFailureCode(pTG, T30FAILS_POSTPAGE_DCN);
                        return actionHANGUP;
      case ifrPIN:
      case ifrPIP:
#ifdef PRI
                        goto NodeE;
#else
                        DebugPrintEx(DEBUG_WRN,"Procedure interrupts not supported");
                        pTG->T30.ifrResp = pTG->T30.ifrResp - ifrPIP + ifrRTP;
                        // ICommFailureCode(T30FAILS_POSTPAGE_PIPPIN);
                        // return actionERROR;
                        // return actionDCN;
#endif
      // default: // fallthrough    --- MCF, RTN, RTP
    }

    action = pTG->Params.lpfnWhatNext(  pTG, 
                                        eventGOTPOSTPAGERESP,
                                        (WORD)pTG->T30.ifrResp, 
                                        (DWORD)pTG->T30.ifrSend);

    if(pTG->T30.ifrSend==ifrEOP &&
            (pTG->T30.ifrResp==ifrMCF || pTG->T30.ifrResp==ifrRTP)
                    && action==actionDCN)
    {
        ICommFailureCode(pTG, T30FAILS_SUCCESS);
        return actionDCN_SUCCESS;
    }
    else
    {
        return action;
    }
}

#define SKIP_TCF_TIME   1500

ET30ACTION RecvPhaseB(PThrdGlbl pTG, ET30ACTION action)
{
    LPLPFR          lplpfr;
    USHORT          N, i;

    /******** Receiver Phase B. Fig A-7/T.30 (sheet 1) ********/

    DEBUG_FUNCTION_NAME(_T("RecvPhaseB"));

    DebugPrintEx(   DEBUG_MSG, 
                    "T30: The last command from transmitter was ifrCommand=%d", 
                    pTG->T30.ifrCommand);

    if(action == actionGONODE_R1)
    {
        // NodeR1:
        // Have to redo this "DIS bit" everytime through PhaseB
        pTG->T30.fReceivedDIS = FALSE;       // set to FALSE when sending DIS
        // also the Received EOM stuff
        pTG->T30.fReceivedEOM = FALSE;
        // and teh received-DTC stuff
        pTG->T30.fReceivedDTC = FALSE;

        N = 0;
        lplpfr = 0;
        action = pTG->Params.lpfnWhatNext(  pTG, 
                                            eventSENDDIS,
                                            (WORD)0,
                                            (ULONG_PTR)((LPUWORD)&N),
                                            (ULONG_PTR)((LPLPLPFR)&lplpfr));
    }
    // NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
    else
    {
        // NodeR2:
        BG_CHK(action == actionGONODE_R2);
        // fix the Received EOM stuff
        pTG->T30.fReceivedEOM = FALSE;
        N = 0;
        lplpfr = 0;
        action = pTG->Params.lpfnWhatNext(  pTG, 
                                            eventSENDDTC,
                                            (WORD)0,
                                            (ULONG_PTR)((LPUWORD)&N),
                                            (ULONG_PTR)((LPLPLPFR)&lplpfr));
    }
    // end this is never executed
    switch(action)
    {
      case actionDCN:       DebugPrintEx(   DEBUG_ERR,
                                            "Got actionDCN from eventSENDDIS or SENDDTC");
                            return actionDCN;
      case actionSEND_DIS:
      case actionSEND_DTC:  break;
      case actionERROR:     return action;  // goto PhaseLoop & exit
      default:              return BadAction(pTG, action);
    }

    // INI file settings related stuff
    if(pTG->ProtParams.RecvT1Timer)
    {
        TstartTimeOut(pTG, &pTG->T30.toT1, pTG->ProtParams.RecvT1Timer);
    }
    else
    {
        TstartTimeOut(pTG, &pTG->T30.toT1, T1_TIMEOUT);
    }
    do // Until time-out, or an error occured
    {  
        // do nothing. Hook for abort in T1 loop
        if(pTG->Params.lpfnWhatNext(pTG, eventNODE_R) == actionERROR)
            break; 

        // The receiving speed is unknown now:
        pTG->T30.uRecvTCFMod = 0xFFFF;

        PSSLogEntry(PSS_MSG, 1, "Sending CSI-DIS");
        if (!SendManyFrames(pTG, lplpfr, N)) 
        {
            // We want to know about failure here.
            PSSLogEntry(PSS_ERR, 1, "Failed to send CSI-DIS");
        }
        else
        {
            PSSLogEntry(PSS_MSG, 1, "Successfully sent CSI-DIS - receiving response");
        }
        
echoretry:
        DebugPrintEx(DEBUG_MSG,"Getting Response");

        // Here we get the response for the NSF or DIS we send, or after EOM
        // There is no check for the validity of the returned frame
        
        pTG->T30.ifrCommand=GetResponse(pTG, ifrPHASEBresponse);

        DebugPrintEx(   DEBUG_MSG, 
                        "GetResponse returned %s",
                        ifr_GetIfrDescription(pTG->T30.ifrCommand));

        // if we hear our own frame, try to recv again. DONT retransmit!
        for(i=0; i<N; i++) // Notice that N=0 after EOM, so we skip this check
        {
            if(pTG->T30.ifrCommand == lplpfr[i]->ifr)
            {
                DebugPrintEx(   DEBUG_WRN, 
                                "Ignoring ECHO of %s(%d)", 
                                (LPSTR)(rgFrameInfo[pTG->T30.ifrCommand].szName), 
                                pTG->T30.ifrCommand);
                goto echoretry;
            }
        }
        
        // We decide what to do by checking the last received frame
        switch(pTG->T30.ifrCommand)
        {
          case ifrEOM:      // The last page was followed by EOM. The sender did not "hear" our MCF
                            if (!SendMCF(pTG))
                            {
                              DebugPrintEx(DEBUG_ERR,"Failed to SendMCF");
                            }
                            break;
          case ifrNSS:      // do same as for DCS
          case ifrDCS:      // If there are many frames and one of them is DCS, then pTG->T30.ifrCommand contains DCS
                            // This function will return if there was no DCS yet (the receive modiulation is not known)
                            return PhaseGetTCF(pTG, pTG->T30.ifrCommand, FALSE);
          case ifrBAD:      // ifrBAD means *only* bad frames recvd. Treat like NULL
          case ifrNULL:     // we expect to get a DCS in phase B
                            // which means the sender will follow it by a TCF
                            // the sender doesn't know we failed to get the DCS
                            // so the TCF will follow anyway
                            // we have to wait before re-sending NSF-DIS
                            // or we'll collide with TCF
                            Sleep(SKIP_TCF_TIME);
                            break;          // out of the switch() and continue with loop
          case ifrDCN:
                            DebugPrintEx(DEBUG_ERR,"Got DCN after DIS or DTC");
                            ICommFailureCode(pTG, T30FAILR_PHASEB_DCN);
                            return actionHANGUP;    //bugfix #478
          default:
                            return actionGONODE_RECVCMD;
        }
    }
    while(TcheckTimeOut(pTG, &(pTG->T30.toT1)));

    DebugPrintEx(DEBUG_ERR,"T1 timeout on Receiver");
    PSSLogEntry(PSS_ERR, 1, "Didn't receive any response from sender");
    ICommFailureCode(pTG, T30FAILR_T1);
    return actionDCN;
}



ET30ACTION PhaseNodeF(PThrdGlbl pTG, BOOL fEopMcf, BOOL fEnteredHere)
{
    USHORT  uFLoopCount;


    DEBUG_FUNCTION_NAME(_T("PhaseNodeF"));

    // PSSLogEntry(PSS_MSG, 0, "Phase D - Post message exchange");
    // PhaseNodeF can mark several different things - so don't PSSLog anything here
    // Instead, log before returning actionNODE_F to T30MainBody

// NodeF:
    uFLoopCount = 0;
NodeFprime:
    for(;;)
    {
        pTG->T30.uRecvTCFMod = 0xFFFF; // This mark that we don't know yet the rate (no DCS, yet)

echoretry:
        pTG->T30.ifrCommand = GetCommand(pTG, (USHORT)(pTG->EchoProtect.fGotWrongMode ? ifrNODEFafterWRONGMODE : ifrNODEFcommand));

        // reset the fGotWrongMode flag
        pTG->EchoProtect.fGotWrongMode = 0;

        // if we hear the last frame we sent, try to recv again. DONT retx!
        // bug--might have matched ifrNULL...
        // added: if ModemRecvMode() returns EOF then also retry. RecvMode
        // returns RECV_EOF only if we pass it the ifrNODEFafterWRONGMODE hint
        // and it senses silence (i.e. we saw a V21 echo but missed it). In
        // this case we want to retry the high speed PIX recv
        if(pTG->EchoProtect.ifrLastSent && (pTG->T30.ifrCommand==pTG->EchoProtect.ifrLastSent || pTG->T30.ifrCommand==ifrEOFfromRECVMODE))
        {
            DebugPrintEx(   DEBUG_WRN,
                            "Ignoring ECHO of %s(%d)", 
                            (LPSTR)(rgFrameInfo[pTG->T30.ifrCommand].szName), 
                            pTG->T30.ifrCommand);
            switch(pTG->EchoProtect.modePrevRecv)
            {
            default:
            case modeNONE:   goto echoretry;
            case modeNONECM: return actionGONODE_RECVPHASEC;
            case modeECM:    return actionGONODE_RECVPHASEC;
            case modeECMRETX:return actionGONODE_RECVECMRETRANSMIT;
            }
        }

        // as soon as we get anything else ZERO the pTG->EchoProtect state
        _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

        // reset this flag if we fail completely to train after a CTC. We may
        // get an echo of our last command, go to NodeF, reject the echo and
        // loop back to ECMRecvPhaseC. AT that point we need this flag STILL
        // set so we try to recv LONG train. HOWEVER should the ECMRecvPhaseC
        // fail for some OTHER reason than echo, this flag need to be reset
        // here or it may stay alive confusing something much later.
        pTG->ECM.fRecvdCTC = FALSE;

#ifdef RICOHAI
        if(fEnteredHere)
        {
            if(pTG->T30.ifrCommand!=ifrNSS)
            {
                DebugPrintEx(DEBUG_WRN,"Recv-side AI protocol failed");
                fUsingOEMProt = 0;
                return actionGONODE_R1;
            }
        }
#else
        BG_CHK(!fEnteredHere);
#endif

        switch(pTG->T30.ifrCommand)
        {
          // ifrNULL means T2 timeout, or loss of carrier, or no flags
          // or no frame. ifrBAD means *only* bad frame(s) recvd.

          case ifrNSS:          // do same as for DCS
          case ifrDCS:          return PhaseGetTCF(pTG, pTG->T30.ifrCommand, fEnteredHere);
                                // ifrDCS is highly time-critical!!
          case ifrBAD:          
          case ifrNULL:         break;          // Loop again, until timeout
          case ifrTIMEOUT:      goto T2Timeout;
                                // ifrTIMEOUT means T2 timed out without flags...
          case ifrDCN:          if(fEopMcf)
                                {
                                    ICommFailureCode(pTG, T30FAILR_SUCCESS);
                                    PSSLogEntry(PSS_MSG, 1, "Received DCN");
                                    return actionHANGUP_SUCCESS;
                                }
                                else
                                {
                                    PSSLogEntry(PSS_ERR, 1, "Received DCN unexpectedly");
                                    ICommFailureCode(pTG, T30FAILR_UNKNOWN_DCN1);

                                    // t-jonb: If we've already called PutRecvBuf(RECV_STARTPAGE),
                                    // but not PutRecvBuf(RECV_ENDPAGE / DOC), then
                                    // InFileHandleNeedsBeClosed==1, meaning there's a .RX file that
                                    // hasn't been copied to the .TIF file. Since the call was
                                    // disconnected, there will be no chance to send RTN. Therefore,
                                    // we call PutRecvBuf(RECV_ENDDOC_FORCESAVE) to keep the partial
                                    // page and tell rx_thrd to terminate.
                                    
                                    if (pTG->Operation==T30_RX && pTG->InFileHandleNeedsBeClosed)
                                    {
                                        PutRecvBuf(pTG, NULL, RECV_ENDDOC_FORCESAVE);
                                    }

                                    return actionHANGUP;
                                }
          default:              return actionGONODE_RECVCMD;
        }
    }

T2Timeout:
    DebugPrintEx(DEBUG_WRN,"T2 timed out");

    // restart PhaseB after T2 timeout IFF (a) EOM or PPS-EOM was recvd
    // AND (b) If we are in ECM mode, the last response sent was n MCF
    // This avoids us doing this after sending a CTR, RNR or PPR
    // Ricoh's protocol conformance tester doesnt like this. This is
    // Ricoh's bug numbbers B3-0142, 0143, 0144
    if(pTG->T30.fReceivedEOM && (ProtReceivingECM(pTG) ? (pTG->ECM.ifrPrevResponse==ifrMCF) : TRUE) )
    {
        return actionGONODE_R1;
    }
    else if(ProtReceivingECM(pTG) && ++uFLoopCount<3)
    {
        goto NodeFprime;
    }

#ifdef PRI
    else // no EOM && (no ECM || 3 times)
    {
        if((pTG->Params.lpfnWhatNext(pTG, eventQUERYLOCALINT))==actionTRUE)
        {
            goto NodeF;
        }
    }
#endif

    PSSLogEntry(PSS_ERR, 1, "Failed to receive command - aborting");
    ICommFailureCode(pTG, T30FAILR_T2);

    // t-jonb: If we've already called PutRecvBuf(RECV_STARTPAGE), but not 
    // PutRecvBuf(RECV_ENDPAGE / DOC), then InFileHandleNeedsBeClosed==1, meaning
    // there's a .RX file that hasn't been copied to the .TIF file. Since the
    // call was disconnected, there will be no chance to send RTN. Therefore, we call
    // PutRecvBuf(RECV_ENDDOC_FORCESAVE) to keep the partial page and tell 
    // rx_thrd to terminate.

    if (pTG->Operation==T30_RX && pTG->InFileHandleNeedsBeClosed)
    {
        PutRecvBuf(pTG, NULL, RECV_ENDDOC_FORCESAVE);
    }

    return actionHANGUP;
}

ET30ACTION PhaseRecvCmd(PThrdGlbl pTG)
{
    ET30ACTION action;

    DEBUG_FUNCTION_NAME(_T("PhaseRecvCmd"));

    if(pTG->T30.ifrCommand == ifrDCN)
    {
        DebugPrintEx(DEBUG_ERR,"Got DCN in GetCommand");
        ICommFailureCode(pTG, T30FAILR_UNKNOWN_DCN2);
        return actionHANGUP;
    }

    if( pTG->T30.ifrCommand==ifrDTC || pTG->T30.ifrCommand==ifrDCS ||
            pTG->T30.ifrCommand==ifrDIS || pTG->T30.ifrCommand==ifrNSS)
    {
        switch(action = pTG->Params.lpfnWhatNext(   pTG, 
                                                    eventRECVCMD, 
                                                    (WORD)pTG->T30.ifrCommand))
        {
          case actionGETTCF:    DebugPrintEx(DEBUG_ERR,"MainBody: Wrong Way to GETTCF");
                                ICommFailureCode(pTG, T30FAILR_BUG2);
                                BG_CHK(FALSE);
                                return actionERROR;
          case actionGONODE_A:  return actionGONODE_A;
          // NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
          case actionGONODE_D:  return action;
          // end this is never executed
          case actionHANGUP:    DebugPrintEx(DEBUG_ERR,"Got actionHANGUP from eventRECVCMD");
                                return action;
          case actionERROR:     return action;  // goto PhaseLoop & exit
          default:              return BadAction(pTG, action);
        }
    }

    if( pTG->T30.ifrCommand == ifrEOM           || 
        pTG->T30.ifrCommand == ifrPRI_EOM       ||
        pTG->T30.ifrCommand == ifrPPS_EOM       || 
        pTG->T30.ifrCommand == ifrPPS_PRI_EOM   ||
        pTG->T30.ifrCommand == ifrEOR_EOM       || 
        pTG->T30.ifrCommand == ifrEOR_PRI_EOM   )
    {
        pTG->T30.fReceivedEOM = TRUE;
    }

    if(ProtReceivingECM(pTG))
    {
        return actionGONODE_VII;
    }
    else if(pTG->T30.ifrCommand >= ifrPRI_FIRST && pTG->T30.ifrCommand <= ifrPRI_LAST)
    {
#ifdef PRI
        return actionGONODE_RECVPRIQ;
#else
        pTG->T30.ifrCommand = pTG->T30.ifrCommand-ifrPRI_MPS+ifrMPS;
        // fall thru to GONODEIII
#endif
    }

    if(pTG->T30.ifrCommand >= ifrMPS && pTG->T30.ifrCommand <= ifrEOP) // in {MPS, EOM, EOP}
    {
        PSSLogEntry(PSS_MSG, 1, "Received %s", rgFrameInfo[pTG->T30.ifrCommand].szName);
        return actionGONODE_III;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"Got UNKNOWN in GetCommand");
        ICommFailureCode(pTG, T30FAILR_UNKNOWN_UNKNOWN2);
        return actionHANGUP;
    }

/***
    else if(pTG->T30.ifrCommand >= ifrMPS && pTG->T30.ifrCommand <= ifrEOP)
            return actionGONODE_III;

    else if(pTG->T30.ifrCommand >= ifrECM_FIRST && ProtReceivingECM())
            return actionGONODE_VII;

#ifdef PRI
    else if(pTG->T30.ifrCommand >= ifrPRI_FIRST && pTG->T30.ifrCommand <= ifrPRI_LAST)
            return actionGONODE_RECVPRIQ;
#endif
***/
}

// We are here after we got the DCS (Digital Command Signal)
// Now, we suppose to get TCF. After that we should do some checking on the DCS parameters (eg.: PageWidth...)
// According to the protocol after the DCS we must get the TCF,
// and just after that we can say that the parameters were bad (FTT) are good (CFR)

ET30ACTION PhaseGetTCF(PThrdGlbl pTG, IFR ifr, BOOL fEnteredHere)
{
    SWORD   swRet;
    IFR             ifrDummy;
    ET30ACTION action;

    DEBUG_FUNCTION_NAME(_T("PhaseGetTCF"));

    if(pTG->T30.uRecvTCFMod == 0xFFFF)           // uninitialised
    {
        ECHOPROTECT(0, 0);
        CLEAR_MISSED_TCFS();
        action = actionGONODE_F;
        goto error;
    }
#ifdef OEMNSF
    else if(pTG->T30.uRecvTCFMod == 0xFF)
    {
        swRet = 0;
        goto sendcfr;
    }
#endif

    PSSLogEntry(PSS_MSG, 1, "Receiving TCF...");
    
    swRet = GetTCF(pTG);       // swRet = errs per 1000, +ve or 0 if we think its good
                                            // -ve if we think its bad. -1111 if other error
                                            // -1000 if too short

    if(swRet < -1000)
    {
        BG_CHK(swRet == -1112 || swRet == -1113);
        ECHOPROTECT(0, 0);

        pTG->T30.uMissedTCFs++;
        if (pTG->T30.uMissedTCFs >= MAX_MISSED_TCFS_BEFORE_FTT)
        {
            PSSLogEntry(PSS_WRN, 1, "Failed to receive TCF %u times - will be considered as bad TCF",
                        (unsigned) pTG->T30.uMissedTCFs);
            CLEAR_MISSED_TCFS();
            swRet = -1000; // We pretend we got a too-short TCF.
        }
        else
        {
            PSSLogEntry(PSS_WRN, 1, "Failed to receive TCF - receiving commands");
            action = actionGONODE_F;
            goto error;
        }
    }

#ifdef OEMNSF
sendcfr:
#endif

    // Here we can also signal the frames received before DCS!
    // Were no longer in time-critical mode, so call all the
    // callbacks we skipped. One for recording the received frames
    // and one for handling teh received command, i.e. DCS.
    // (the only options the protocol has is actionGETTCF or HANGUP)

    ifrDummy = ifr;


    // When we calling to WhatNext with eventGOTFRAMES, the DCS will be copied to pTG->ProtInst->RemoteDCS
    //
    action = pTG->Params.lpfnWhatNext(  pTG, 
                                        eventGOTFRAMES, 
                                        pTG->T30.Nframes,
                                        (ULONG_PTR)((LPLPFR)(pTG->T30.lpfs->rglpfr)), 
                                        (ULONG_PTR)((LPIFR)(&ifrDummy)));
    if(action == actionERROR)
        goto error;

    if(ifr != ifrDummy)
    {
        switch(ifrDummy)
        {
        case ifrNULL:
        case ifrBAD:
                        DebugPrintEx(DEBUG_ERR,"Got ifrBAD from whatnext after recv TCF");
                        ECHOPROTECT(0, 0);
                        CLEAR_MISSED_TCFS();
                        action = actionGONODE_F;
                        goto error;
        default:
                        BG_CHK(FALSE);
                        break;
        }
    }

    // BG_CHK(action == actionNULL);
    // BG_CHK(ifrDummy == ifr);


    // Now call teh callback to check the received TCF and
    // return either FTT or CFR

    switch(action = pTG->Params.lpfnWhatNext(pTG, eventGOTTCF,(WORD)swRet))
    {
      case actionSENDCFR:
                            PSSLogEntry(PSS_MSG, 1, "Received good TCF - sending CFR");
                            EnterPageCrit();                // start the CFR--PAGE critsection
                            SendCFR(pTG);              // after sending CFR we are again in a race
                            ECHOPROTECT(ifrCFR, 0); // dunno recv mode yet
                            PSSLogEntry(PSS_MSG, 1, "Successfully sent CFR");
                            return actionGONODE_RECVPHASEC;
      case actionSENDFTT:
                            PSSLogEntry(PSS_WRN, 1, "Received bad TCF - sending FTT");
                            SendFTT(pTG);
                            ECHOPROTECT(ifrFTT, 0);
                            CLEAR_MISSED_TCFS();
                            PSSLogEntry(PSS_MSG, 1, "Successfully sent FTT - receiving commands");
                            return actionGONODE_F;
      case actionERROR:
                            goto error;
      default:
                            action = BadAction(pTG, action);
                            goto error;
    }

error:
    // missed TCF or no NSS. Did _not_ reply to TCF
    // if we sent a reply, must _not_ come here

#ifdef RICOHAI
    if(fEnteredHere)
        return actionGONODE_R1;
#else
    BG_CHK(!fEnteredHere);
#endif

    return action;
}

ET30ACTION NonECMRecvPhaseC(PThrdGlbl pTG)
{
    /******** Receiver Phase C. Fig A-7/T.30 (sheet 1) ********/

    LPBUFFER        lpbf;
    ULONG           lTotalLen=0;
    USHORT          uRet, uMod, uEnc;
    DWORD           tiffCompression;
    LPSTR           lpsTemp;
    DWORD           HiRes;

    // There is a race between sending the CFR and sending out an
    // +FRM=xx command, so we want to do it ASAP.


    DEBUG_FUNCTION_NAME(_T("NonECMRecvPhaseC"));

    PSSLogEntry(PSS_MSG, 0, "Phase C - Receive page");

    uEnc = ProtGetRecvEncoding(pTG);
    BG_CHK(uEnc==MR_DATA || uEnc==MH_DATA);

    if (uEnc == MR_DATA) 
    {
        tiffCompression =  TIFF_COMPRESSION_MR;
    }
    else 
    {
        tiffCompression =  TIFF_COMPRESSION_MH;
    }

    if (pTG->ProtInst.RecvParams.Fax.AwRes & (AWRES_mm080_077 |  AWRES_200_200) ) 
    {
        HiRes = 1;
    }
    else 
    {
        HiRes = 0;
    }

    //
    // do it once per RX
    //

    if ( !pTG->fTiffOpenOrCreated) 
    {
        //
        // top 32bits of 64bit handle are guaranteed to be zero
        //
        pTG->Inst.hfile =  TiffCreateW ( pTG->lpwFileName,
                                         tiffCompression,
                                         pTG->TiffInfo.ImageWidth,
                                         FILLORDER_LSB2MSB,
                                         HiRes
                                         );

        if (! (pTG->Inst.hfile)) 
        {
#ifdef DEBUG
            lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
            DebugPrintEx(   DEBUG_ERR, 
                            "Can't create tiff file %s compr=%d",
                            lpsTemp,
                            tiffCompression);

            MemFree(lpsTemp);
#endif
            return actionERROR;
        }

#ifdef DEBUG

        lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);
        DebugPrintEx(   DEBUG_MSG,
                        "Tiff was created, file name %s compr=%d",
                        lpsTemp,
                        tiffCompression);

        MemFree(lpsTemp);
#endif

        pTG->fTiffOpenOrCreated = 1;

#ifdef DEBUG

        lpsTemp = UnicodeStringToAnsiString(pTG->lpwFileName);

        DebugPrintEx(   DEBUG_MSG, 
                        "Created tiff file %s compr=%d HiRes=%d",
                        lpsTemp,  
                        tiffCompression, 
                        HiRes);

        MemFree(lpsTemp);
#endif

    }

    uMod = ProtGetRecvMod(pTG);
    // in non-ECM mode, PhaseC is ALWAYS with short-train.
    // Only TCF uses long-train
    if(uMod >= V17_START) 
        uMod |= ST_FLAG;

    pTG->T30.sRecvBufSize = MY_BIGBUF_SIZE;
    if((uRet = ModemRecvMode(   pTG, 
                                pTG->Params.hModem, 
                                uMod, 
                                FALSE, 
                                PHASEC_TIMEOUT,
                                (IFR)((uEnc==MR_DATA) ? ifrPIX_MR : ifrPIX_MH))) != RECV_OK)
    {
        ExitPageCrit();

        // reset Page ack. In case we miss page completely
        ProtResetRecvPageAck(pTG);

        DebugPrintEx(DEBUG_WRN,"RecvMode returned %d", uRet);

        pTG->EchoProtect.modePrevRecv = modeNONECM;
        // set global flag if we got WRONGMODE
        pTG->EchoProtect.fGotWrongMode = (uRet==RECV_WRONGMODE);

        // elim flush--does no good & wastes 10ms
        // ModemFlush(pTG->Params.hModem);
        CLEAR_MISSED_TCFS();
        return actionGONODE_F;
        // try to get 300bps command
        // return actionHANGUP;
        // goto error instead. No way to recover from here!
    }
    ExitPageCrit();

    // as soon as we get good carrier ZERO the EchoProtect state
    _fmemset(&pTG->EchoProtect, 0, sizeof(pTG->EchoProtect));

#ifdef IFAX
    BroadcastMessage(pTG, IF_PSIFAX_DATAMODE, PSIFAX_RECV, (uMod & (~ST_FLAG)));
#endif

    // PageCount gets incremented only when the page was fully received, hence +1
    PSSLogEntry(PSS_MSG, 1, "Receiving page %d data...", pTG->PageCount+1);

    // reset Page ack
    ProtResetRecvPageAck(pTG);

    // Turn yielding on *after* entering receive mode safely!
    FComCriticalNeg(pTG, FALSE);

/***
    switch(action = pTG->Params.lpfnWhatNext(eventSTARTRECV))
    {
      case actionCONTINUE:  break;
      case actionDCN:               (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionDCN from eventSTARTRECV\r\n"));
                                                    return actionDCN;               // goto NodeC;
      case actionHANGUP:    (MyDebugPrint(pTG,  LOG_ERR,  "<<ERROR>> Got actionHANGUP from eventSTARTRECV\r\n"));
                                                    return actionHANGUP;    // goto NodeB;
      case actionERROR:             return action;  // goto PhaseLoop & exit
      default:                              return BadAction(action);
    }
***/

/***
    BG_CHK((BOOL)Comm.dcb.fOutX == FALSE);
    // Paranoia! Dont want to take ^Q/^S from modem to
    // be XON/XOFF in the receive data phase!!
    FComInFilterInit();
***/

    // to mark start of Page
    if(!PutRecvBuf(pTG, NULL, RECV_STARTPAGE))
    {
        DebugPrintEx(DEBUG_ERR,"Zero return from PutRecvBuf(start page)");
        return actionERROR;
    }

// make it large, in case of large buffers & slow modems
#define READ_TIMEOUT    25000

    lTotalLen = 0;
    do
    {
        uRet=ModemRecvBuf(pTG, pTG->Params.hModem, FALSE, &lpbf, READ_TIMEOUT);
        // lpbf==0 && uRet==RECV_OK just does nothing & loops back
        if (uRet == RECV_EOF) 
        {
            // indicate that this is actually last recv_seq (we've got dle/etx already).
            DebugPrintEx(DEBUG_MSG,"fLastReadBlock = 1");
            pTG->fLastReadBlock = 1;
        }

        if(lpbf)
        {
            lTotalLen += lpbf->wLengthData;
            if(!PutRecvBuf(pTG, lpbf, RECV_SEQ))
            {
                DebugPrintEx(DEBUG_ERR,"Zero return from PutRecvBuf in page");
                return actionERROR;
            }
            
            lpbf = 0;
        }
        else 
        {
            if ( pTG->fLastReadBlock == 1) 
            {
                PutRecvBuf(pTG, lpbf, RECV_FLUSH);
            }
        }
    }
    while(uRet == RECV_OK);

    PSSLogEntry(PSS_MSG, 2, "recv:     page data, %d bytes", lTotalLen);

    if(uRet == RECV_EOF)
    {
        FComCriticalNeg(pTG, TRUE);
        pTG->T30.fAtEndOfRecvPage = TRUE;
        // call this *after* getting MPS/EOM/EOP
        // PutRecvBuf(NULL, RECV_ENDPAGE);              // to mark end of Page
    }
    else
    {
        // Timeout from ModemRecvBuf
        DebugPrintEx(DEBUG_ERR,"DataRead Timeout or Error=%d", uRet);
        // BG_CHK(FALSE);
        PSSLogEntry(PSS_ERR, 1, "Failed to receive page data - aborting");
        
        ICommFailureCode(pTG, T30FAILR_MODEMRECV_PHASEC);
        return actionERROR;     // goto error;
    }

    PSSLogEntry(PSS_MSG, 1, "Successfully received page data");

    ECHOPROTECT(0, 0);
    CLEAR_MISSED_TCFS();

    PSSLogEntry(PSS_MSG, 0, "Phase D - Post message exchange");
    return actionGONODE_F;  // goto NodeF;                  // get post-message command
}

ET30ACTION NonECMRecvPhaseD(PThrdGlbl pTG)
{
    ET30ACTION      action;
    ET30ACTION      ret;

    DEBUG_FUNCTION_NAME(_T("NonECMRecvPhaseD"));

    /******** Receiver Phase D. Fig A-7/T.30 (sheet 2) ********/
    // NodeIII:

/** Here the T30 flowchart is all BS. Fundamentally relying on
    a +FCERROR response is not possible, so what we do here really
    depends on what we've got. (According to the T30 flowchart we
    return to NodeF after sending MCF/RTP/RTN, in all cases. What we
    now know is that,

            after MPS/MCF goto RecvPhaseC to get the next page
            after EOM/MCF goto NodeR1 and send NSF etc all over again
                    ***changed*** go back to NodeF, wait for T2 timeout
                    before sending DIS all over again.
            after EOP/MCF goto NodeF, where GetResponse() will get
                                      a DCN and we end up in NodeB (disconnect)

            after xxx/RTN or xxx/RTP, I don't know what to do, but my guess
                                      (looking at the Sender side of T30 flowchart) is:-

            after MPS/RTx goto NodeF        (sender goes to NodeD)
            after EOP/RTx goto NodeF        (sender goes to D or C)
            after EOM/RTx goto NodeR1       (sender goes to NodeT)
                    ***changed*** go back to NodeF, wait for T2 timeout
                    before sending DIS all over again.

****/

    // only MPS/EOM/EOP commands come here

    if(pTG->T30.fAtEndOfRecvPage)                // so we won't call this twice
    {
        // This calls ET30ProtRecvPageAck so that WhatNext can choose
        // MCF or RTN respectively. So it *must* be done before the
        // call to WhatNext below


        // If we got EOM then it's not the end of the document, it's just that we want to get back
        // to phase B (for negotiating).
        switch(pTG->T30.ifrCommand)
        {
        case ifrMPS:
            // There are more pages to come with the same parameters (so go back to phase C)
            DebugPrintEx(DEBUG_MSG,"Got MPS, Calling PutRecvBuf with RECV_ENDPAGE");
            if(!PutRecvBuf(pTG, NULL, RECV_ENDPAGE))
            {
                DebugPrintEx(DEBUG_ERR,"failed calling PutRecvBuf with RECV_ENDPAGE");
                return actionERROR;
            }
            break;
        case ifrEOP:
            // There are no more pages.
            DebugPrintEx(DEBUG_MSG,"Got EOP, Calling PutRecvBuf with RECV_ENDDOC");
            if(!PutRecvBuf(pTG, NULL, RECV_ENDDOC))
            {
                DebugPrintEx(DEBUG_ERR,"failed calling PutRecvBuf with RECV_ENDDOC");
                return actionERROR;
            }
            break;
        case ifrEOM:
            // More pages but with different params: width, res, encoding, modulation, etc.
            DebugPrintEx(DEBUG_MSG,"Got EOM, Calling PutRecvBuf with RECV_ENDPAGE");
            if(!PutRecvBuf(pTG, NULL, RECV_ENDPAGE))
            {
                DebugPrintEx(DEBUG_ERR,"failed calling PutRecvBuf with RECV_ENDPAGE");
                return actionERROR;
            }
            break;
        default:
            DebugPrintEx(   DEBUG_ERR,
                            "got unexpected command (ifr=%d)", 
                            pTG->T30.ifrCommand);
            if(!PutRecvBuf(pTG, NULL, RECV_ENDDOC)) // Mimic the former behavior
            {
                DebugPrintEx(DEBUG_ERR,"failed calling PutRecvBuf with RECV_ENDDOC");
                return actionERROR;
            }
        }
        pTG->T30.fAtEndOfRecvPage = FALSE;
    }

    // returns MCF if page was OK, or RTN if it was bad
    ret=actionGONODE_F;
    ECHOPROTECT(0, 0);
    CLEAR_MISSED_TCFS();
    switch(action = pTG->Params.lpfnWhatNext(   pTG, 
                                                eventRECVPOSTPAGECMD,
                                                (WORD)pTG->T30.ifrCommand))
    {
      /* LAST PAGE WAS OK, SEND CONFIRMATION */
      case actionSENDMCF:
                            switch(pTG->T30.ifrCommand)
                            {
                            case ifrMPS:
                                            EnterPageCrit(); //start MPS--PAGE critsection
                                            ECHOPROTECT(ifrMCF, modeNONECM);
                                            ret=actionGONODE_RECVPHASEC;
                                            break;
                            case ifrEOP:
                                            ECHOPROTECT(ifrMCF, 0);
                                            CLEAR_MISSED_TCFS();
                                            ret=actionNODEF_SUCCESS;
                                            break;
                            case ifrEOM:
                                            CLEAR_MISSED_TCFS();
                                            ret=actionGONODE_R1;
                                            break;
                            default:
                                            DebugPrintEx(   DEBUG_ERR, 
                                                            "Got unknown command not (MCF,EOM or MPS)");
                            }

                            PSSLogEntry(PSS_MSG, 1, "Page was good - sending MCF");
                            if (!SendMCF(pTG))
                            {
                                PSSLogEntry(PSS_ERR, 1, "Failed to send MCF");
                            }
                            else
                            {
                                PSSLogEntry(PSS_MSG, 1, "Successfully sent MCF");
                            }
                            
                            break;
      /* LAST PAGE WAS BAD, SEND RTN or DCN */
      case actionSENDRTN:
                            ECHOPROTECT(ifrRTN, 0);
                            // After that we will return actionGONODE_F
                            PSSLogEntry(PSS_WRN, 1, "Page was bad - sending RTN");
                            if (!SendRTN(pTG))
                            {
                                PSSLogEntry(PSS_ERR, 1, "Failed to send RTN");
                            }
                            else
                            {
                                PSSLogEntry(PSS_MSG, 1, "Successfully sent RTN");
                            }
                            break;
      case actionHANGUP:
                            DebugPrintEx(   DEBUG_ERR,
                                            "Got actionHANGUP from eventRECVPOSTPAGECMD");
                            ret=actionHANGUP;
                            break;
      // case actionSENDRTP: SendRTP(pTG); break;      // never send RTP
      case actionERROR:     ret=action; break;    // goto PhaseLoop & exit
      default:              return BadAction(pTG, action);
    }

    if (ret == actionNODEF_SUCCESS)
    {
        PSSLogEntry(PSS_MSG, 0, "Phase E - Hang up");
    }
    return ret;
}

/***************************************************************************
 Name     :     IFR GetCmdResp(BOOL fCommand)
 Purpose  :     Implement the "Command Received" and "Response Received"
                        subroutines in the T.30 flowchart. The following macros are
                        defined:-

                        #define GetResponse()   GetCmdResp(FALSE)
                        #define GetCommand()    GetCmdResp(TRUE)

                        where the first form results in a faithful implem.
                        of the "Response Received" subroutine, the 2nd one
                        changes two things (i) the timeout for getting falgs goes from
                        T4 to T2, and (ii) if the routine times out on the very
                        first frame without getting flags (i.e. T2 times out)
                        it returns ifrTIMEOUT. This results in the "Command Recvd"
                        and the enclosing T2 loop being implemented in this
                        routine.

                        Upon receiving a set of frames, this routine assembles them
                        into the ET30FR structs pointed to by rglpfr, and if any
                        of them have a non-null FIF, or if >1 frame are received, it
                        calls (*Callbacks.Callbacks.lpWhatNext)().

                        Finally it returns the ifr of the last frame received, if
                        all frames were good, or ifrBAD if *all* frames were bad.

                        The algorithm it implements is very close to the "Response
                        Received" flowchart, minus the "Transmit DCN" box & below.
                        It returns ifrNULL or ifrBAD corresponding to return via
                        Node 2, (i.e. ifrNULL for timeout and other errors), ifrBAD
                        for bad frames, *iff* it can resync and get 200ms of silence
                        following these. ifrERROR for Node 1 (i.e. any error or timeout
                        after which we cannot resync or get silence for 200ms),
                        and ifrDCN for Node 3 (i.e. DCN was received).
                        <<<Node1 (ifrERROR does not make sense, so we dont use it. On error
                        we immediately return BAD or NULL or TIMEOUT and allow retry>>>
                        The "Optional Response" box is replaced by a "Not final frame".
                        A "start T4" box is assumed at "Enter" and a "Reset T4" box
                        is assumed after "process optional response"

                        It also modifies the flowchart in that *all* the frames are got
                        until a final frame, even if an FCS error frame is recvd. This
                        is partly because after an erroneous frame we have absolutely
                        no idea how long to wait until we either get silence or timeout
                        and hangup. ALso it may be more robust. The main routine
                        throws away the entire set of frames if one is bad.

                        The     callback function is called before any return and it gets
                        a pointer to the desired return vakue, so it can modify this.


 Arguments:     whether it is called as "Command Received" or as
                        "Response Received"

 Returns  :     ifrNULL -- timeout
                        ifrTIMEOUT -- T2 timed out before first flag
                                                  (returns this if and only if fCommand==TRUE)
                        ifrBAD  -- all frames received were bad
                        ifrDCN -- DCN was received. The only valid action is "goto NodeB"
                        ifrXXXX -- last received frame
 Calls    :
 Called By:     GetResponse() GetCommand1() and GetCommand2() macros (ONLY!)
                        These are called only from ET30MainBody.
 Comment  :     Watch out for timeouts > 65535 (max UWORD)

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
 06/15/92 arulm Created for first time (completely from scratch)
***************************************************************************/


IFR GetCmdResp(PThrdGlbl pTG, BOOL fCommand, USHORT ifrHint)
{
    /*** we need to try for T4 to get a frame here. The way Class1 modems
             works, as long as no flags are received, the AT+FRH=3 command will
             time out and return ERROR. CONNECT is returned as soon as flags
             are received. Some modems return <CR><LF>OK<CR><LF><CR><LF>CONNECT
             which is still taken care of by our new ModemDialog which throws
             away blank lines and looks for the expected answer i.e. "CONNECT"
             in this case, in multi-line responses.
    ***/

    BYTE                    bRecv[MAXFRAMESIZE];
    BOOL                    fFinal, fNoFlags, fGotFIF, fGotBad;
    IFR                     ifr, ifrLastGood;
    USHORT                  uRet, uRecv, j;
    ET30ACTION              action;
    LPLPFR                  lplpfr;
    LPFR                    lpfrNext;
    BOOL                    fResync=0;
    ULONG                   ulTimeout;
    BOOL                    fGotEofFromRecvMode=0;

    DEBUG_FUNCTION_NAME(_T("GetCmdResp"));
    // need to init these first
    pTG->T30.Nframes = 0;
    fFinal = FALSE;
    fNoFlags = TRUE;
    fGotFIF = FALSE;
    fGotBad = FALSE;
    ifrLastGood = ifrNULL;

    // figure out the timeout
    if(fCommand)
    {
        ulTimeout = T2_TIMEOUT;
    }
    else
    {
        ulTimeout = T4_TIMEOUT;
    }
    // if we're sending DCS-TCF and waiting for CFR, we increase the timeout each time
    // we fail, to avoid getting an infinite collision. This fixes bug#6847
    if(ifrHint==ifrTCFresponse && pTG->T30.uTrainCount>1)
    {
        ulTimeout += TCFRESPONSE_TIMEOUT_SLACK;
        DebugPrintEx(   DEBUG_MSG,
                        "Get TCF response: traincount=%d timeout=%ld", 
                        pTG->T30.uTrainCount,
                        ulTimeout);
    }

    lplpfr = pTG->T30.lpfs->rglpfr;
    lpfrNext = (LPFR)(pTG->T30.lpfs->b);

    pTG->T30.sRecvBufSize = 0;
    uRet = ModemRecvMode(pTG, pTG->Params.hModem, V21_300, TRUE, ulTimeout, ifrHint);
    if(uRet == RECV_TIMEOUT || uRet == RECV_ERROR)
    {
        DebugPrintEx(DEBUG_WRN,"RecvMode failed=%d", uRet);
        fResync = TRUE;
        goto error;
    }
    else if(uRet == RECV_WRONGMODE)
    {
        // BG_CHK(FALSE);       // just so we know who gives it!!
        DebugPrintEx(DEBUG_ERR,"Got FCERROR from FRH=3");
        // treat like timeout
        // fReSync = FALSE;     // no need to resync
        goto error;
    }
    else if(uRet == RECV_EOF)
    {
        // ModemRecvMode() returns EOF then return ifrEOF immediately. RecvMode
        // returns RECV_EOF only if we pass it the ifrNODEFafterWRONGMODE hint
        // and it senses silence (i.e. we saw a V21 echo but missed it). In
        // this case we want to retry the high speed PIX recv again immediately
        DebugPrintEx(DEBUG_WRN,"ECHO--Got EOF from V21 RecvMode");
        fGotEofFromRecvMode=TRUE;
        goto error;
    }
    BG_CHK(uRet == RECV_OK);

    for( ;!fFinal; )
    {
        if((((LPB)lpfrNext+sizeof(FR)+30-(LPB)pTG->T30.lpfs) > TOTALRECVDFRAMESPACE)
                || (pTG->T30.Nframes >= MAXRECVFRAMES))
        {
            DebugPrintEx(DEBUG_ERR,"Out of space for received frames. Haaalp!!");
            pTG->T30.Nframes = 0;
            // fGotBad = TRUE;      // fGotBad = FALSE;
            lplpfr = pTG->T30.lpfs->rglpfr;
            lpfrNext = (LPFR)(pTG->T30.lpfs->b);
            // BG_CHK(FALSE);
            // fall through
        }

        DebugPrintEx(DEBUG_MSG,"Before  ModemRecvMem, timeout = %d",ulTimeout);
        uRet = ModemRecvMem(pTG, pTG->Params.hModem, bRecv, MAXFRAMESIZE, ulTimeout, &uRecv);
        DebugPrintEx(DEBUG_MSG,"After  ModemRecvMem, got %d",uRecv);

        if(uRet == RECV_TIMEOUT)
        {
            DebugPrintEx(DEBUG_WRN,"got RECV_TIMEOUT from ModemRecvMem");
            fResync = TRUE;
            goto error;                             // timeout in FRH=3
        }

        fNoFlags = FALSE;

        if(uRet == RECV_EOF)
        {
            DebugPrintEx(DEBUG_WRN,"Got NO CARRIER, but no final bit");
            BG_CHK(uRecv == 0);
            goto error;             // ignore good frames if we got any, because we
                                    // must've missed the last (most important) one
            // fFinal = TRUE;       // pretend we got fFinal
            // continue;
        }
        else if(uRet == RECV_ERROR)
        {
            DebugPrintEx(DEBUG_ERR,"Got RECV_ERROR at GetCmdResp!");
            fResync = TRUE;
            goto error;                             // error in FRH=3
        }

        /** Sometimes modems give use ERROR even when teh frame is good.
                Happens a lot from Though to PP144MT on CFR. So we ignore the
                BADFRAME response, and check the recvd data for ourselves.
                First stage--check the FF-03/13-FCF. If this is OK (i.e. got
                a known FCF) and no FIF reqd and data length is correct
                then accept it. But if the frame requires an FIF and we
                got a BADFRAME response then don't accept it even if it
                looks good--too dangerous.
                2nd-stage(NYI)--keep a table of CRCs for each fixed frame & check
                them ourselves.
        **/

        BG_CHK(uRet == RECV_OK || uRet==RECV_BADFRAME);
        // ST_FRAMES(D_HexPrint(bRecv, uRecv));

        /*** Got Valid OK Frame. Now analyse it. In general here we
                 want to be pretty lax in recognizing frames. Oftentimes
                 we have mucho garbage thrown in.
                 <CHANGE> Actually we're checking strictly now....

                 If we get a bad frame, we mark this in the lpfrfr[] array
                 and go on to try and get another frame.
                 <CHANGE> We've stopped saving bad frames
        ***/

        // AT&T modem gives us frames w/o CRC, so we get just 1 byte here!!
        // <CHNAGE> fixed that at driver level, so we always get 3 bytes here
        // IFF it is a valid frame
        if(uRecv < 3)
            goto badframe;

        if(bRecv[0] != 0xFF)
            goto badframe;

        if(bRecv[1] == 0x03)
        {
            fFinal = FALSE;
        }
        else if(bRecv[1] == 0x13)
        {
            fFinal = TRUE;
        }
        else
        {
            goto badframe;
        }

        for(ifr=1; ifr<ifrMAX; ifr++)
        {
            if(rgFrameInfo[ifr].fInsertDISBit)
            {
                // Mask off the DIS bit
                if(rgFrameInfo[ifr].bFCF1 != (BYTE)(bRecv[2] & 0xFE))
                        continue;
            }
            else
            {
                if(rgFrameInfo[ifr].bFCF1 != bRecv[2])
                        continue;
            }

            j=3; // Till now the size is 3: 0xFF 0x03/0x13 and the bFCF1
            if(rgFrameInfo[ifr].bFCF2)
            {
                // AT&T modem gives us frames w/o CRC, so we get just 1 byte frames!!
                if(uRecv < 4)
                    goto badframe;

                if((BYTE)(rgFrameInfo[ifr].bFCF2-1) != bRecv[3])
                    continue;
                j++;
            }
            BG_CHK(j <= uRecv);
            if(rgFrameInfo[ifr].wFIFLength == 0xFF) // var length FIF
            {
                // Var length frames
                // Cant accept it if the modem thought they it was bad
                // accept it IFF RECV_OK & FIFlen>0
                if(uRet==RECV_OK && (j < uRecv))
                {
                    fGotFIF = TRUE;
                }
                else
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "Discarding Bad Frame: uRet=%d FIFlen=%d Reqd=Var",
                                    uRet, 
                                    (uRecv-j));
                    goto badframe;
                }
            }
            else if(rgFrameInfo[ifr].wFIFLength) // fixed length FIF
            {
                // if frame length is exactly right then accept it
                // else if modem said frame was ok and length is
                // longer than expected then accept it too
                if((j+rgFrameInfo[ifr].wFIFLength) == uRecv)
                {
                    fGotFIF = TRUE;
                }
                else if(uRet==RECV_OK && (j+rgFrameInfo[ifr].wFIFLength < uRecv))
                {
                    fGotFIF = TRUE;
                }
                else
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "Discarding Bad Frame: uRet=%d FIFlen=%d Reqd=%d",
                                    uRet, 
                                    (uRecv-j), 
                                    rgFrameInfo[ifr].wFIFLength);
                    goto badframe;
                }
            }
            else    // no FIF reqd
            {
                if(j != uRecv)
                {
                    DebugPrintEx(   DEBUG_MSG,  
                                    "Weird frame(2) j=%d uRecv=%d",
                                    j,
                                    uRecv);
                    BG_CHK(j < uRecv);

                    // see the BADFRAME comment block above on why we do this
                    if(uRet != RECV_OK)
                        goto badframe;

                    // accept it even if wrong length *iff* uRet==RECV_OK
                    // goto badframe;

                    // **additional** reason to do this that 2 bytes of extra
                    // CRC may be present. This happens because of the AT&T and
                    // NEC modems that doen't give CRC, so we do no CRC lopping-off
                    // in the modem driver. So accept it anyway here.
                }
            }

            goto goodframe;
        }

        // fall through here when ifr == ifrMAX
        BG_CHK(ifr==ifrMAX);
badframe:
        DebugPrintEx(DEBUG_WRN,"IGNORING Bad Frame (Size=%d) -->", uRecv);

        //Protocol Dump
        DumpFrame(pTG, FALSE, 0, uRecv, bRecv);

        fGotBad = TRUE;                 // remember we got a bad frame

        // when we get a bad frame, the only excuse for going to the modem again
        // immediately is to get rid of the following frame (it it exists)
        // because we're going to dump the whole sequence anyway.
        // we don't want any terminating frame in a sequence to be considered
        // a stand alone frame.
        // so... let's shorten the timeout, not to catch the start of the next
        // batch (which will come in 3 seconds) and loop back to see if it's there.
        // if this was the last frame (or only frame) and it was bad, we 'waste'
        // 500ms waiting for another frame which won't come.
        // but anyway we're going to wait for the next round in 3 seconds.
        ulTimeout = 500;
        continue;
        // loop back here for the next frame

goodframe:
        // ST_T30_2(D_HexPrint(bRecv, uRecv));

        ifrLastGood = ifr;      // save last good ifr

        lpfrNext->ifr = ifr;
        if(uRecv > j)
        {
            lpfrNext->cb = uRecv-j;
            _fmemcpy(lpfrNext->fif, bRecv+j, uRecv-j);

            //Protocol Dump
            DumpFrame(pTG, FALSE, ifr, (USHORT)(uRecv-j), bRecv+j);
        }
        else
        {
            lpfrNext->cb = 0;
            BG_CHK(uRecv == j);

            //Protocol Dump
            DumpFrame(pTG, FALSE, ifr, 0, 0);
        }

        PSSLogEntry(PSS_MSG, 2, "frame is %s, %s frame", 
                ifr ? rgFrameInfo[ifr].szName : "???",
                fFinal ? "final" : "non-final");                

        lplpfr[pTG->T30.Nframes] = lpfrNext;
        pTG->T30.Nframes++;

        ///////////// back to NSS-DCS form ////////////
        if(ifr==ifrDCS) // The DCS could be followed by TSI (Fix bug #4672)
                        // "Fax: T.30: fax service cannot receive DCS(TSI) - some older fax machine send DCS(TSI)"
        {
            // Need to set receive speed, since bypass all callbacks
            // now and go straight to AT+FRM=xx
            DebugPrintEx(   DEBUG_MSG, 
                            "This is the received DCS:0x%02x - 0x%02x - 0x%02x",
                            (lpfrNext->fif[0]),
                            (lpfrNext->fif[1]),
                            (lpfrNext->fif[2]));
            pTG->T30.uRecvTCFMod = (((lpfrNext->fif[1])>>2) & 0x0F);
            DebugPrintEx(   DEBUG_MSG, 
                            "cmdresp-DCS fx sp=%d last ifr=%d", 
                            pTG->T30.uRecvTCFMod, 
                            ifr);
            // fastexit:
            BG_CHK(ifr==ifrDCS);
            return ifr;             // ifr of final/command frame
        }
#ifdef OEMNSF
        else if(ifr==ifrNSS && lpfnOEMGetBaudRate && fUsingOEMProt)
        {
            WORD wRet = lpfnOEMGetBaudRate(pTG, lpfrNext->fif, lpfrNext->cb, fFinal);
            if(wRet)
            {
                BG_CHK(fFinal);
                if(LOBYTE(wRet) == OEMNSF_GET_TCF)
                {
                    DebugPrintEx(   DEBUG_MSG,
                                    "cmdresp-NSS fx sp=%d", 
                                    pTG->T30.uRecvTCFMod);
                    pTG->T30.uRecvTCFMod = HIBYTE(wRet);
                    BG_CHK(ifr==ifrNSS);
                    return ifr;
                }
                else if(LOBYTE(wRet) == OEMNSF_NO_TCF)
                {
                    DebugPrintEx(   DEBUG_MSG,
                                    "cmdresp-NSS fx sp=%d", 
                                    pTG->T30.uRecvTCFMod);
                    pTG->T30.uRecvTCFMod = 0xFF;
                    BG_CHK(ifr==ifrNSS);
                    return ifr;
                }
            }
            else if(fFinal)
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "OEMGetBaudRate returned %d for FINAL frame."
                                " Using standard T30",
                                wRet);
                fUsingOEMProt = 0;
                return ifrNULL;
            }
        }
#endif


        lpfrNext++;                             // skips over only the base part of frame
        lpfrNext = (LPFR)((LPBYTE)lpfrNext + (uRecv-j));        // skips over FIF too

        if(ifr == ifrCRP)
        {
            fGotBad = TRUE;         // pretend we got a bad response (so the T30 chart says!)
            // fResync = FALSE;
            goto error;             // exit, but get 200ms of silence
                                    // caller will resend command
        }
        if(ifr == ifrDCN)
        {
            goto exit2;             // exit. Don't call callback function!
        }

        // loop back here for the next frame
    }
    BG_CHK(fFinal); // only reason we ever drop through here

    // let ifrDCN also come through here. No hurry, so we can report
    // it to the protocol module. If we got *only* bad frames, here we'll
    // return ifrBAD
//exit:
    if (    !pTG->T30.Nframes   ||          // we got no good frames
            (ifr != ifrLastGood)||          // final frame was bad
            fGotBad             )   
    {
        DebugPrintEx(   DEBUG_WRN,
                        "Got %d good frames. LastGood=%d Last=%d. Ignoring ALL",
                        pTG->T30.Nframes, 
                        ifrLastGood, 
                        ifr);
        // fResync = FALSE;
        goto error;
    }

    // ifr of final frame
    BG_CHK(ifr == ifrLastGood);
    if(pTG->T30.Nframes>1 || fGotFIF)
    {
        action=pTG->Params.lpfnWhatNext(    pTG, 
                                            eventGOTFRAMES, 
                                            pTG->T30.Nframes,
                                            (ULONG_PTR)lplpfr, 
                                            (ULONG_PTR)((LPIFR)&ifr));
        BG_CHK(action==actionNULL || action==actionERROR);
    }
exit2:
    // ifr can be changed by callback function (e.g. if bad FIFs)
    if(ifr==ifrDTC)
        pTG->T30.fReceivedDTC = TRUE;

    return ifr;             // ifr of final frame

error:
    // comes here on getting RECV_TIMEOUT, RECV_WRONGMODE, RECV_ERROR
    // and ifrCRP, or on getting no Frames
    // fReSync is set on RECV_TIMEOUT or RECV_ERROR

#ifdef DEBUG
    if(pTG->T30.Nframes>0 && ifr!=ifrCRP && ifrLastGood!=ifrCRP)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Got some good frames--Throwing away!! IFR=%d Last=%d",
                        ifr, 
                        ifrLastGood);
        // BG_CHK(FALSE);
    }
#endif

    if(fGotBad)
    {
        ifr = ifrBAD;           // caller can send CRP if desired
    }
    else
    {
        ifr = ifrNULL;          // caller can repeat command & try again
    }

    if(fCommand && fNoFlags) 
        ifr = ifrTIMEOUT;      // hook for "Command Recvd?"

    // may not need this on TIMEOUT since AT-OK has already been
    // called in ModemDialog. Probably need it on ERROR

    if(uRet==RECV_ERROR)
    {
        BG_CHK(fResync);
        ModemSync(pTG, pTG->Params.hModem, RESYNC_TIMEOUT2);
    }
    // eliminate Flush--serves no purpose
    // else if(uRet==RECV_WRONGMODE)
    // {
    //      ModemFlush(pTG->Params.hModem);
    // }

    // ModemRecvMode() returns EOF then return ifrEOF immediately. RecvMode
    // returns RECV_EOF only if we pass it the ifrNODEFafterWRONGMODE hint
    // and it senses silence (i.e. we saw a V21 echo but missed it). In
    // this case we want to retry the high speed PIX recv again immediately
    if(fGotEofFromRecvMode) 
        ifr=ifrEOFfromRECVMODE;

    BG_CHK(ifr==ifrBAD || ifr==ifrNULL || ifr==ifrTIMEOUT || ifr==ifrEOFfromRECVMODE);
    return ifr;

/*-----------------------------------------------------------------
 *      Don't want to return ifrERROR ever. Nobody wants to deal with it.
 *      Don't try to get the 200ms of silence, because it causes us to
 *      get badly out of sync, i.e. after a few bad frames we don't
 *      resync and we lose the call. Just do a local-resync (AT-OK)
 *      and try to recv again.
 * -----------------------------------------------------------------
 *
 *      if( !ModemSync(pTG->Params.hModem, RESYNC_TIMEOUT) ||
 *              !ModemRecvSilence(pTG->Params.hModem, 20, RESYNC_TIMEOUT))
 *      {
 *              // ifr = ifrERROR;
 *              // caller must send DCN and hangup
 *      }
 *      action=pTG->Params.lpfnWhatNext(eventGOTFRAMES, pTG->T30.Nframes,
 *                                      (DWORD)lplpfr, (DWORD)((LPIFR)&ifr));
 *      BG_CHK(action == actionNULL);
 *
 * -----------------------------------------------------------------
 *      and don't want to regsiter garbage frame sets. Nobody does anything
 *  but retry on BAD/NULL/TIMEOUT returns anyway
 *-----------------------------------------------------------------*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\t30api.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30api.c

Abstract:

    This is the interface with T.30 DLL

Author:

    Rafael Lisitsa (RafaelL) 2-Feb-1996


Revision History:
    Mooly Beery    (MoolyB)  Jun-2000

--*/

#define  DEFINE_T30_GLOBALS
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#define FS_UNSUPPORTED_CHAR      0x40000800

#include "prep.h"

#include <mcx.h>

#include "tiff.h"

#include "glbproto.h"

#include <faxext.h>


#include "faxreg.h"
///RSL Wes should export this.
#define  TAPI_VERSION       0x00020000
#include "t30gl.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_T30API

#define T30_DEBUG_LOG_FILE  _T("T30DebugLogFile.txt")

#define MAX_DEVICE_NAME_SIZE 256  

VOID pFaxDevCleanup(PThrdGlbl pTG,int RecoveryIndex);
VOID pFaxDevExceptionCleanup();
BOOL ReadExtensionConfiguration(PThrdGlbl pTG);

HRESULT
FaxExtInitializeConfig (
    PFAX_EXT_GET_DATA pfGetExtensionData,              // Pointer to FaxExtGetExtensionData in service
    PFAX_EXT_SET_DATA pfSetExtensionData,              // Pointer to FaxExtSetExtensionData in service
    PFAX_EXT_REGISTER_FOR_EVENTS pfRegisterForExtensionEvents,    // Pointer to FaxExtRegisterForExtensionEvents in service
    PFAX_EXT_UNREGISTER_FOR_EVENTS pfUnregisterForExtensionEvents,  // Pointer to FaxExtUnregisterForExtensionEvents in service
    PFAX_EXT_FREE_BUFFER                pfExtFreeBuffer  // Pointer to FaxExtFreeBuffer in service
)
{
    UNREFERENCED_PARAMETER(pfSetExtensionData);
    UNREFERENCED_PARAMETER(pfRegisterForExtensionEvents);
    UNREFERENCED_PARAMETER(pfUnregisterForExtensionEvents);

    Assert(pfGetExtensionData);
    Assert(pfSetExtensionData);
    Assert(pfRegisterForExtensionEvents);
    Assert(pfUnregisterForExtensionEvents);
    Assert(pfExtFreeBuffer);


    g_pfFaxGetExtensionData = pfGetExtensionData;
    g_pfFaxExtFreeBuffer = pfExtFreeBuffer;
    return S_OK;

}



///////////////////////////////////////////////////////////////////////////////////
VOID  CALLBACK
T30LineCallBackFunctionA(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    )

{
    LONG_PTR             i;
    PThrdGlbl           pTG = NULL;
    char                rgchTemp128[128];
    LPSTR               lpszMsg = "Unknown";

    DEBUG_FUNCTION_NAME(_T("T30LineCallBack"));

    DebugPrintEx(   DEBUG_MSG,
                    "hFax=%lx, dev=%lx, msg=%lx, dwInst=%lx,P1=%lx, P2=%lx, P3=%lx",
                    hFax, hDevice, dwMessage, dwInstance,
                    dwParam1, dwParam2, (unsigned long) dwParam3);

    // find the thread that this callback belongs to
    //----------------------------------------------

    i = (LONG_PTR) hFax;

    if (i < 1   ||   i >= MAX_T30_CONNECT)
    {
        DebugPrintEx(DEBUG_MSG,"wrong handle=%x", i);
        return;
    }


    if ( (! T30Inst[i].fAvail) && T30Inst[i].pT30)
    {
        pTG = (PThrdGlbl) T30Inst[i].pT30;
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"handle=%x invalid", i);
        return;
    }

    switch (dwMessage)
    {
    case LINE_LINEDEVSTATE:
                    lpszMsg = "LINE_LINEDEVSTATE";
                    if (dwParam1 == LINEDEVSTATE_RINGING)
                    {
                            DebugPrintEx(   DEBUG_MSG,
                                            "Ring Count = %lx",
                                            (unsigned long) dwParam3);
                    }
                    else if (dwParam1 == LINEDEVSTATE_REINIT)
                    {

                    }
                    break;
    case LINE_ADDRESSSTATE:
                    lpszMsg = "LINE_ADDRESSSTATE";
                    break;
    /* process state transition */
    case LINE_CALLSTATE:
                    lpszMsg = "LINE_CALLSTATE";
                    if (dwParam1 == LINECALLSTATE_CONNECTED)
                    {
                        pTG->fGotConnect = TRUE;
                    }
                    else if (dwParam1 == LINECALLSTATE_IDLE)
                    {
                        if (pTG->fDeallocateCall == 0)
                        {
                            pTG->fDeallocateCall = 1;
                        }
                    }
                    break;
    case LINE_CREATE:
                    lpszMsg = "LINE_CREATE";
                    break;
    case LINE_CLOSE:
                    lpszMsg = "LINE_CLOSE";
                    break; // LINE_CLOSE
    /* handle simple tapi request. */
    case LINE_REQUEST:
                    lpszMsg = "LINE_REQUEST";
                    break; // LINE_REQUEST
    /* handle the assync completion of TAPI functions
       lineMakeCall/lineDropCall */
    case LINE_REPLY:
                    lpszMsg = "LINE_REPLY";
                    if (!hDevice)
                    {
                        itapi_async_signal(pTG, (DWORD)dwParam1, (DWORD)dwParam2, dwParam3);
                    }
                    else
                    {
                        DebugPrintEx(   DEBUG_MSG,
                                        "Ignoring LINE_REPLY with nonzero device");
                    }
                    break;
    /* other messages that can be processed */
    case LINE_CALLINFO:
                    lpszMsg = "LINE_CALLINFO";
                    break;
    case LINE_DEVSPECIFIC:
                    lpszMsg = "LINE_DEVSPECIFIC";
                    break;
    case LINE_DEVSPECIFICFEATURE:
                    lpszMsg = "LINE_DEVSPECIFICFEATURE";
                    break;
    case LINE_GATHERDIGITS:
                    lpszMsg = "LINE_GATHERDIGITS";
                    break;
    case LINE_GENERATE:
                    lpszMsg = "LINE_GENERATE";
                    break;
    case LINE_MONITORDIGITS:
                    lpszMsg = "LINE_MONITORDIGITS";
                    break;
    case LINE_MONITORMEDIA:
                    lpszMsg = "LINE_MONITORMEDIA";
                    break;
    case LINE_MONITORTONE:
                    lpszMsg = "LINE_MONITORTONE";
                    break;
    } /* switch */

    _stprintf(rgchTemp128,
            "%s(p1=0x%lx, p2=0x%lx, p3=0x%lx)",
                    (LPTSTR) lpszMsg,
                    (unsigned long) dwParam1,
                    (unsigned long) dwParam2,
                    (unsigned long) dwParam3);

    DebugPrintEx(   DEBUG_MSG,
                    "Device:0x%lx; Message:%s",
                    (unsigned long) hDevice,
                    (LPTSTR) rgchTemp128);

} /* LineCallBackProc */

void debugReadFromRegistry()
{
#ifdef DEBUG
    DWORD dwLevelEx = DEBUG_WRN_MSG | DEBUG_ERR_MSG;
#else
    DWORD dwLevelEx = 0;
#endif
    DWORD dwFormatEx = DBG_PRNT_ALL_TO_FILE & ~DBG_PRNT_TIME_STAMP;
    DWORD dwContextEx = DEBUG_CONTEXT_T30_MAIN | DEBUG_CONTEXT_T30_CLASS1 | DEBUG_CONTEXT_T30_CLASS2;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_DEVICE_PROVIDER_KEY TEXT("\\") REGVAL_T30_PROVIDER_GUID_STRING,
                     &hkey);

    if (err != ERROR_SUCCESS)
        goto exit;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          REGVAL_DBGLEVEL_EX,
                          0,
                          &type,
                          (LPBYTE)&dwLevelEx,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
    {
    #ifdef DEBUG
        DWORD dwLevelEx = DEBUG_WRN_MSG | DEBUG_ERR_MSG;
    #else
        DWORD dwLevelEx = 0;
    #endif
        goto exit;
    }

    err = RegQueryValueEx(hkey,
                          REGVAL_DBGFORMAT_EX,
                          0,
                          &type,
                          (LPBYTE)&dwFormatEx,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
    {
        dwFormatEx = DBG_PRNT_ALL_TO_FILE & ~DBG_PRNT_TIME_STAMP;
        goto exit;
    }

    err = RegQueryValueEx(hkey,
                          REGVAL_DBGCONTEXT_EX,
                          0,
                          &type,
                          (LPBYTE)&dwContextEx,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
    {
        dwContextEx = DEBUG_CONTEXT_T30_MAIN | DEBUG_CONTEXT_T30_CLASS1;
        goto exit;
    }

    RegCloseKey(hkey);

exit:

    SET_DEBUG_PROPERTIES(dwLevelEx,dwFormatEx,dwContextEx);
}



/*++
Routine Description:
    Calls the TAPI functions lineGetID, lineGetDevConfig, lineGetDevCaps, reads
    the Unimodem registry, and sets the following vars accordingly:
    pTG->hComm
    pTG->dwSpeakerVolume
    pTG->dwSpeakerMode
    pTG->fBlindDial
    pTG->dwPermanentLineID
    pTG->lpszPermanentLineID
    pTG->lpszUnimodemKey
    pTG->lpszUnimodemFaxKey
    pTG->ResponsesKeyName
    pszDeviceName - a buffer to hold device name (for PSSLog)
    
Return Value:
    TRUE - success
    FALSE - failure
 --*/

BOOL GetModemParams(PThrdGlbl pTG, LPTSTR pszDeviceName, DWORD dwDeviceNameSize)
{
    DWORD                 dwNeededSize;
    LONG                  lRet=0;
    LPVARSTRING           lpVarStr=0;
    LPDEVICEID            lpDeviceID=0;
    LONG                  lResult=0;
    LPLINEDEVCAPS         lpLineDevCaps;
    BYTE                  buf[ sizeof(LINEDEVCAPS)+1000 ];
    LPMDM_DEVSPEC         lpDSpec;
    LPMODEMSETTINGS       lpModemSettings;
    LPDEVCFG              lpDevCfg;

    char                  rgchKey[256]={'\0'};
    HKEY                  hKey;
    DWORD                 dwType;
    DWORD                 dwSize;

    DEBUG_FUNCTION_NAME(_T("GetModemParams"));

    // get the handle to a Comm port
    //----------------------------------

    lpVarStr = (LPVARSTRING) MemAlloc(IDVARSTRINGSIZE);
    if (!lpVarStr)
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't allocate space for lpVarStr");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    _fmemset(lpVarStr, 0, IDVARSTRINGSIZE);
    lpVarStr->dwTotalSize = IDVARSTRINGSIZE;

    DebugPrintEx(DEBUG_MSG,"Calling lineGetId");

    lRet = lineGetID(pTG->LineHandle,
                     0,  // +++ addr
                     pTG->CallHandle,
                     LINECALLSELECT_CALL,   // dwSelect,
                     lpVarStr,              //lpDeviceID,
                     "comm/datamodem" );    //lpszDeviceClass

    if (lRet)
    {
         DebugPrintEx(  DEBUG_ERR,
                        "lineGetID returns error 0x%lx",
                        (unsigned long) lRet);

         pTG->fFatalErrorWasSignaled = 1;
         SignalStatusChange(pTG, FS_LINE_UNAVAILABLE);
         return FALSE;
    }
    DebugPrintEx(DEBUG_MSG,"lineGetId returned SUCCESS");

    // extract id
    if (lpVarStr->dwStringFormat != STRINGFORMAT_BINARY)
    {
        DebugPrintEx(DEBUG_ERR,"String format is not binary");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    if (lpVarStr->dwUsedSize<sizeof(DEVICEID))
    {
        DebugPrintEx(DEBUG_ERR,"linegetid : Varstring size too small");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    lpDeviceID = (LPDEVICEID) ((LPBYTE)(lpVarStr)+lpVarStr->dwStringOffset);

    DebugPrintEx(   DEBUG_MSG,
                    "lineGetID returns handle 0x%08lx, \"%s\"",
                    (ULONG_PTR) lpDeviceID->hComm,
                    (LPSTR) lpDeviceID->szDeviceName);
    pTG->hComm = lpDeviceID->hComm;

    if (NULL != lpDeviceID->szDeviceName)
    {
        // save device name - for PSSLog
        _tcsncpy(pszDeviceName, lpDeviceID->szDeviceName, dwDeviceNameSize); 
    }

    if (BAD_HANDLE(pTG->hComm))
    {
        DebugPrintEx(DEBUG_ERR,"lineGetID returns NULL hComm");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    // get the Modem configuration (speaker, etc.) from TAPI
    //------------------------------------------------------

    _fmemset(lpVarStr, 0, IDVARSTRINGSIZE);
    lpVarStr->dwTotalSize = IDVARSTRINGSIZE;

    lResult = lineGetDevConfig(pTG->DeviceId,
                               lpVarStr,
                               "comm/datamodem");

    if (lResult)
    {
        if (lpVarStr->dwTotalSize < lpVarStr->dwNeededSize)
        {
            dwNeededSize = lpVarStr->dwNeededSize;
            MemFree (lpVarStr);
            if ( ! (lpVarStr = (LPVARSTRING) MemAlloc(dwNeededSize) ) )
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Can't allocate %d bytes for lineGetDevConfig",
                                dwNeededSize);

                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                return FALSE;
            }

            _fmemset(lpVarStr, 0, dwNeededSize);
            lpVarStr->dwTotalSize = dwNeededSize;

            lResult = lineGetDevConfig(pTG->DeviceId,
                                       lpVarStr,
                                       "comm/datamodem");

            if (lResult)
            {
                DebugPrintEx(   DEBUG_ERR,
                                "lineGetDevConfig returns %x, le=%x",
                                lResult, GetLastError() );

                MemFree (lpVarStr);
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
                return FALSE;
            }
        }
        else
        {
            DebugPrintEx(   DEBUG_ERR,
                            "1st lineGetDevConfig returns %x, le=%x",
                            lResult, GetLastError() );

            MemFree (lpVarStr);

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            return FALSE;
        }
    }

    //
    // extract DEVCFG
    //
    if (lpVarStr->dwStringFormat != STRINGFORMAT_BINARY)
    {
        DebugPrintEx(DEBUG_ERR,"String format is not binary for lineGetDevConfig");

        MemFree (lpVarStr);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    if (lpVarStr->dwUsedSize<sizeof(DEVCFG))
    {
        DebugPrintEx(DEBUG_ERR,"lineGetDevConfig: Varstring size returned too small");

        MemFree (lpVarStr);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    lpDevCfg = (LPDEVCFG) ((LPBYTE)(lpVarStr)+lpVarStr->dwStringOffset);

    lpModemSettings = (LPMODEMSETTINGS) ( (LPBYTE) &(lpDevCfg->commconfig.wcProviderData) );

    pTG->dwSpeakerVolume = lpModemSettings->dwSpeakerVolume;
    pTG->dwSpeakerMode   = lpModemSettings->dwSpeakerMode;

    if ( lpModemSettings->dwPreferredModemOptions & MDM_BLIND_DIAL )
    {
        pTG->fBlindDial = 1;
    }
    else
    {
        pTG->fBlindDial = 0;
    }

    DebugPrintEx(   DEBUG_MSG,
                    "lineGetDevConfig returns SpeakerVolume=%x, "
                    "Mode=%x BlindDial=%d",
                    pTG->dwSpeakerVolume, pTG->dwSpeakerMode, pTG->fBlindDial);

    MemFree (lpVarStr);
    lpVarStr=0;

    // get dwPermanentLineID
    // ---------------------------

    lpLineDevCaps = (LPLINEDEVCAPS) buf;

    _fmemset(lpLineDevCaps, 0, sizeof (buf) );
    lpLineDevCaps->dwTotalSize = sizeof(buf);


    lResult = lineGetDevCaps(gT30.LineAppHandle,
                             pTG->DeviceId,
                             TAPI_VERSION,
                             0,
                             lpLineDevCaps);

    if (lResult)
    {
        DebugPrintEx(DEBUG_ERR,"lineGetDevCaps failed");

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    if (lpLineDevCaps->dwNeededSize > lpLineDevCaps->dwTotalSize)
    {
        DebugPrintEx(DEBUG_ERR,"lineGetDevCaps NOT enough MEMORY");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }

    // Save the permanent ID.
    //------------------------

    pTG->dwPermanentLineID = lpLineDevCaps->dwPermanentLineID;
    _stprintf (pTG->lpszPermanentLineID, "%08X\\Modem", pTG->dwPermanentLineID);
    DebugPrintEx(DEBUG_MSG,"Permanent Line ID=%s", pTG->lpszPermanentLineID);

    // Get the Unimodem key name for this device
    //------------------------------------------

    lpDSpec = (LPMDM_DEVSPEC) (  ( (LPBYTE) lpLineDevCaps) + lpLineDevCaps->dwDevSpecificOffset);

    if ( (lpLineDevCaps->dwDevSpecificSize < sizeof(MDM_DEVSPEC) ) ||
         (lpLineDevCaps->dwDevSpecificSize <= lpDSpec->dwKeyOffset) )
    {
          DebugPrintEx( DEBUG_ERR,
                        "Devspecifc caps size is only %lu",
                        (unsigned long) lpLineDevCaps->dwDevSpecificSize );

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        return FALSE;
    }
    else
    {
        UINT u = lpLineDevCaps->dwDevSpecificSize - lpDSpec->dwKeyOffset;
        if ( (lpDSpec->dwContents != 1) || (lpDSpec->dwKeyOffset != 8 ) )
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Nonstandard Devspecific: dwContents=%lu; "
                            "dwKeyOffset=%lu",
                            (unsigned long) lpDSpec->dwContents,
                            (unsigned long) lpDSpec->dwKeyOffset );

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            return FALSE;
        }

        if (u)
        {
            _fmemcpy(rgchKey, lpDSpec->rgby, u);
            if (rgchKey[u])
            {
                DebugPrintEx(DEBUG_ERR,"rgchKey not null terminated!");
                rgchKey[u-1]=0;
            }

            //
            // Get ResponsesKeyName
            //
            lRet = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            rgchKey,
                            0,
                            KEY_READ,
                            &hKey);

            if (lRet != ERROR_SUCCESS)
            {
               DebugPrintEx(DEBUG_ERR,"Can't read Unimodem key %s",rgchKey);

               pTG->fFatalErrorWasSignaled = 1;
               SignalStatusChange(pTG, FS_FATAL_ERROR);
               return FALSE;
            }

            dwSize = sizeof( pTG->ResponsesKeyName);

            lRet = RegQueryValueEx(
                    hKey,
                    "ResponsesKeyName",
                    0,
                    &dwType,
                    pTG->ResponsesKeyName,
                    &dwSize);

            RegCloseKey(hKey);

            if (lRet != ERROR_SUCCESS)
            {
               DebugPrintEx(    DEBUG_ERR,
                                "Can't read Unimodem key\\ResponsesKeyName %s",
                                rgchKey);

               pTG->fFatalErrorWasSignaled = 1;
               SignalStatusChange(pTG, FS_FATAL_ERROR);
               return FALSE;
            }

            lstrcpy(pTG->lpszUnimodemKey, rgchKey);

            //  Append  "\\Fax" to the key

            u = lstrlen(rgchKey);
            if (u)
            {
                lstrcpy(rgchKey+u, (LPSTR) "\\FAX");
            }

            lstrcpy(pTG->lpszUnimodemFaxKey, rgchKey);
            DebugPrintEx(   DEBUG_MSG,
                            "Unimodem Fax key=%s",
                            pTG->lpszUnimodemFaxKey);
        }
    }

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevInitializeA(
    IN  HLINEAPP                 LineAppHandle,
    IN  HANDLE                   HeapHandle,
    OUT PFAX_LINECALLBACK        *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK    FaxServiceCallback
    )

/*++

Routine Description:
    Device Provider Initialization.


Arguments:


Return Value:


--*/

{   int          i;
    LONG         lRet;
    TCHAR        LogFileLocation[256];
    HKEY         hKey;
    DWORD        dwType;
    DWORD        dwSizeNeed;
    int          iLen;

    OPEN_DEBUG_FILE(T30_DEBUG_LOG_FILE);
    {
        DEBUG_FUNCTION_NAME(_T("FaxDevInitializeA"));

        T30CritSectionInit = 0;
        T30RecoveryCritSectionInit = 0;

        debugReadFromRegistry();

        if (!LineAppHandle)
        {
            Assert(FALSE);
            DebugPrintEx(DEBUG_ERR,"called with INVALID_HANDLE_VALUE LineAppHandle");
            goto error;
        }

        if (HeapHandle==NULL || HeapHandle==INVALID_HANDLE_VALUE)
        {
            Assert(FALSE);
            DebugPrintEx(DEBUG_ERR,"called with NULL/INVALID_HANDLE_VALUE HeapHandle");
            goto error;
        }

        if (LineCallbackFunction==NULL)
        {
            Assert(FALSE);
            DebugPrintEx(DEBUG_ERR,"called with NULL LineCallbackFunction");
            goto error;
        }

        gT30.LineAppHandle = LineAppHandle;
        gT30.HeapHandle    = HeapHandle;
        gT30.fInit         = TRUE;

        *LineCallbackFunction =  T30LineCallBackFunction;

        for (i=1; i<MAX_T30_CONNECT; i++)
        {
            T30Inst[i].fAvail = TRUE;
            T30Inst[i].pT30   = NULL;
        }

        if (!InitializeCriticalSectionAndSpinCount (&T30CritSection, (DWORD)0x10000000))
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("InitializeCriticalSectionAndSpinCount(&T30CritSection) failed: err = %d"),
                ec);
            goto error;
        }
        T30CritSectionInit = 1;

        for (i=0; i<MAX_T30_CONNECT; i++)
        {
            T30Recovery[i].fAvail = TRUE;
        }

        if (!InitializeCriticalSectionAndSpinCount (&T30RecoveryCritSection, (DWORD)0x10000000))
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("InitializeCriticalSectionAndSpinCount(&T30RecoveryCritSection) failed: err = %d"),
                ec);
            goto error;
        }
        T30RecoveryCritSectionInit = 1;

        // debugging

        gfScrnPrint = 0;
        gfFilePrint = 1;     // leave it alone


         lRet = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REGKEY_DEVICE_PROVIDER_KEY TEXT("\\") REGVAL_T30_PROVIDER_GUID_STRING,
                        0,
                        KEY_READ,
                        &hKey);

        if (lRet == ERROR_SUCCESS)
        {
            dwSizeNeed = sizeof(int);

            lRet = RegQueryValueEx(
                                   hKey,
                                   "ModemLogLevel",
                                   0,
                                   &dwType,
                                   (LPBYTE) &gT30.DbgLevel,
                                   &dwSizeNeed);

            if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) )
            {
                gT30.DbgLevel = 0;
                gfFilePrint = 0;
            }

            ProfileGetString( (ULONG_PTR) hKey,
                               "ModemLogLocation",
                               "C:",
                               LogFileLocation,
                               sizeof(LogFileLocation) - 1);

            // RSL TEMP. to save RAW COM T4 data from the modem
            dwSizeNeed = sizeof(int);

            lRet = RegQueryValueEx(
                                   hKey,
                                   "T4LogLevel",
                                   0,
                                   &dwType,
                                   (LPBYTE) &gT30.T4LogLevel,
                                   &dwSizeNeed);

            if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) )
            {
                gT30.T4LogLevel = 0;
            }

            dwSizeNeed = sizeof(int);

            lRet = RegQueryValueEx(
                                   hKey,
                                   "MaxErrorLinesPerPage",
                                   0,
                                   &dwType,
                                   (LPBYTE) &gT30.MaxErrorLinesPerPage,
                                   &dwSizeNeed);

            if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) )
            {
                gT30.MaxErrorLinesPerPage = 110;
            }

            dwSizeNeed = sizeof(int);

            lRet = RegQueryValueEx(
                                   hKey,
                                   "MaxConsecErrorLinesPerPage",
                                   0,
                                   &dwType,
                                   (LPBYTE) &gT30.MaxConsecErrorLinesPerPage,
                                   &dwSizeNeed);

            if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) )
            {
                gT30.MaxConsecErrorLinesPerPage = 110;
            }

            //
            // Exception Handling enable / disable
            //

            dwSizeNeed = sizeof(int);

            lRet = RegQueryValueEx(
                                   hKey,
                                   "DisableEH",
                                   0,
                                   &dwType,
                                   (LPBYTE) &glT30Safe,
                                   &dwSizeNeed);

            if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) )
            {
                glT30Safe = 1;
            }

            dwSizeNeed = sizeof(DWORD);
            // Number of Re-transmittion retries before we start drop speed (default: 1)
            lRet = RegQueryValueEx(
                                   hKey,
                                   "RetriesBeforeDropSpeed",
                                   0,
                                   &dwType,
                                   (LPBYTE) &(gRTNRetries.RetriesBeforeDropSpeed),
                                   &dwSizeNeed);

            if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) )
            {
                DebugPrintEx(   DEBUG_MSG,
                                "Could not read RetriesBeforeDropSpeed from registry, "
                                "lret = %d , dwType = %d",
                                lRet, dwType);

                gRTNRetries.RetriesBeforeDropSpeed = DEF_RetriesBeforeDropSpeed;
            }

            dwSizeNeed = sizeof(DWORD);
            // Number of Re-transmittion retries before we do DCN (default: 3)
            lRet = RegQueryValueEx(
                                   hKey,
                                   "RetriesBeforeDCN",
                                   0,
                                   &dwType,
                                   (LPBYTE) &(gRTNRetries.RetriesBeforeDCN),
                                   &dwSizeNeed);

            if ( ( lRet != ERROR_SUCCESS) || (dwType != REG_DWORD) )
            {
                DebugPrintEx(   DEBUG_MSG,
                                "Could not read RetriesBeforeDCN from registry, "
                                "lret = %d , dwType = %d",
                                lRet, dwType);

                gRTNRetries.RetriesBeforeDCN = DEF_RetriesBeforeDCN;
            }

            if (gRTNRetries.RetriesBeforeDCN < gRTNRetries.RetriesBeforeDropSpeed)
            {
                // Should not be, so use default if it so
                gRTNRetries.RetriesBeforeDropSpeed = DEF_RetriesBeforeDropSpeed;
                gRTNRetries.RetriesBeforeDCN = DEF_RetriesBeforeDCN;
            }


        }
        else
        { // If there is no such entry in the registry, this vars must have values,
            BG_CHK(FALSE); // And we want to know that this is the case
            lstrcpy( LogFileLocation, "c:");
            gT30.DbgLevel = 0;
            gT30.T4LogLevel = 0;
            gRTNRetries.RetriesBeforeDropSpeed = DEF_RetriesBeforeDropSpeed;
            gRTNRetries.RetriesBeforeDCN = DEF_RetriesBeforeDCN;
        }

        DebugPrintEx(   DEBUG_MSG,
                        "Retries policy: RetriesBeforeDropSpeed = %d , "
                        "RetriesBeforeDCN  = %d",
                        gRTNRetries.RetriesBeforeDropSpeed,
                        gRTNRetries.RetriesBeforeDCN);

        lstrcat(LogFileLocation, "\\faxt30.log");

        if (gT30.DbgLevel == 0)
            gfFilePrint = 0;

        if (gfFilePrint)
        {
            if ( (ghLogFile = CreateFileA(LogFileLocation, GENERIC_WRITE, FILE_SHARE_READ,
                                       NULL, CREATE_ALWAYS, 0, NULL) ) == INVALID_HANDLE_VALUE ) {

                DebugPrintEx(DEBUG_ERR,"CANNOT CREATE faxt30.log");
            }
        }

        if (gT30.T4LogLevel)
        {
            iLen = lstrlen (LogFileLocation);
            LogFileLocation[iLen-3] = 'c';
            LogFileLocation[iLen-2] = 'o';
            LogFileLocation[iLen-1] = 'm';

            if ( (ghComLogFile = _lcreat (LogFileLocation, 0) ) == HFILE_ERROR )
            {
                DebugPrintEx(DEBUG_ERR,"CANNOT CREATE faxt30.com");
            }
        }

        // temp. directory

        gT30.dwLengthTmpDirectory = GetTempPathA (_MAX_FNAME - 15, gT30.TmpDirectory);
        if (gT30.dwLengthTmpDirectory > _MAX_FNAME - 15)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "GetTempPathA needs %d have %d bytes",
                            gT30.dwLengthTmpDirectory,
                            (_MAX_FNAME - 15) );
            goto error;
        }

        if (!gT30.dwLengthTmpDirectory)
        {
            DebugPrintEx(DEBUG_ERR,"GetTempPathA fails le=%x",GetLastError());
            goto error;
        }

        DebugPrintEx(   DEBUG_MSG,
                        "hLineApp=%x heap=%x TempDir=%s Len=%d at %ld",
                        LineAppHandle,
                        HeapHandle,
                        gT30.TmpDirectory,
                        gT30.dwLengthTmpDirectory,
                        GetTickCount() );

        gT30.Status = STATUS_OK;
        CLOSE_DEBUG_FILE;
        return (TRUE);
    }
error:

    if (T30CritSectionInit == 1)
    {
        DeleteCriticalSection(&T30CritSection);
        T30CritSectionInit = 0;
    }
    if (T30RecoveryCritSectionInit == 1)
    {
        DeleteCriticalSection(&T30RecoveryCritSection);
        T30RecoveryCritSectionInit = 0;
    }
    CLOSE_DEBUG_FILE;
    return (FALSE);
}

///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevStartJobA(
    HLINE           LineHandle,
    DWORD           DeviceId,
    PHANDLE         pFaxHandle,
    HANDLE          CompletionPortHandle,
    ULONG_PTR       CompletionKey
    )

/*++

Routine Description:
    Device Provider Initialization. Synopsis:
    * Allocate ThreadGlobal, find place in T30Inst
    * Initialize fields, CreateEvent(s)

Arguments:

Return Value:

--*/

{
    PThrdGlbl       pTG     = NULL;
    DWORD           i       = 0;
    BOOL            fFound  = FALSE;

    OPEN_DEBUG_FILE(T30_DEBUG_LOG_FILE);
    {
        DEBUG_FUNCTION_NAME(_T("FaxDevStartJobA"));

        if (!pFaxHandle)
        {
            Assert(FALSE);
            DebugPrintEx(DEBUG_ERR,"called with NULL pFaxHandle");
            return FALSE;
        }

        DebugPrintEx(
            DEBUG_MSG,
            "LineHandle=%x, DevID=%x, pFaxH=%x Port=%x, Key=%x at %ld",
            LineHandle,
            DeviceId,
            pFaxHandle,
            CompletionPortHandle,
            CompletionKey,
            GetTickCount()
            );

        if (InterlockedIncrement(&gT30.CntConnect) >= MAX_T30_CONNECT)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Exceeded # of connections (curr=%d, allowed=%d)",
                            gT30.CntConnect, MAX_T30_CONNECT );
            goto ErrorExit;
        }

        // Alloc memory for pTG, fill it with zeros.
        if ( (pTG =  (PThrdGlbl) T30AllocThreadGlobalData() ) == NULL )
        {
            DebugPrintEx(DEBUG_ERR,"can't malloc");
            goto ErrorExit;
        }

        EnterCriticalSection(&T30CritSection);

        for (i=1; i<MAX_T30_CONNECT; i++)
        {
            if (T30Inst[i].fAvail)
            {
                T30Inst[i].pT30     = (LPVOID) pTG;
                T30Inst[i].fAvail   = FALSE;
                *pFaxHandle         = ULongToHandle(i);
                fFound = TRUE;
                break;
            }
        }

        LeaveCriticalSection(&T30CritSection);

        if (!fFound)
        {
            DebugPrintEx(   DEBUG_ERR,
                            "can't find avail place in T30Inst "
                            "table. # of connections (curr=%d, allowed=%d)",
                            gT30.CntConnect, MAX_T30_CONNECT );
            goto ErrorExit;
        }

        pTG->LineHandle = LineHandle;
        pTG->DeviceId   = DeviceId;
        pTG->FaxHandle  = (HANDLE) pTG;
        pTG->CompletionPortHandle = CompletionPortHandle;
        pTG->CompletionKey = CompletionKey;

        // initialization
        //---------------------------

        if ((pTG->hevAsync = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            /////////////////////////////////////////////////////////////////////////////
            //  this is used to get notification from TAPI about the call
            //  the event is reset in itapi_async_setup
            //  we wait on the event is itapi_async_wait
            //  the event is set in itapi_async_signal when we get LINE_REPLY from TAPI
            /////////////////////////////////////////////////////////////////////////////
            goto ErrorExit;
        }

        if ((pTG->ThrdSignal = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            /////////////////////////////////////////////////////////////////////////////
            //  this is used to communicate between the send/receive operation and
            //  the threads that process the TIFF
            //  in case we're SENDING:
            //  the event is reset in ICommGetSendBuf
            //  we wait on the event in TiffConvertThread in order to prepare more pages
            //  the event is set in ICommGetSendBuf when we want more pages to be ready
            //  in case we're RECEIVING:
            //  the event is never explicitly reset
            //  we wait on the event in DecodeFaxPageAsync in order to dump the received
            //      strip on data to the TIFF file
            //  the event is set in ICommPutRecvBuf when a new strip has been received
            /////////////////////////////////////////////////////////////////////////////
            goto ErrorExit;
        }

        if ((pTG->ThrdDoneSignal = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            /////////////////////////////////////////////////////////////////////////////
            //  this is used to communicate between the receive operation and
            //  the thread that processes the TIFF (prepares the page)
            //  the event is reset in ICommPutRecvBuf when we get RECV_STARTPAGE
            //  we wait on the event in ICommPutRecvBuf to mark the end of prev page
            //      and to signal when it's ok to delete the intermediate files
            //  the event is set in PageAckThread when the page is prepared (TIFF file ok)
            /////////////////////////////////////////////////////////////////////////////
            goto ErrorExit;;
        }

        if ((pTG->ThrdAckTerminateSignal = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            /////////////////////////////////////////////////////////////////////////////
            //  this is used to communicate between the send/receive operation and
            //  the threads that process the TIFF
            //  in case we're SENDING:
            //  the event is never explicitly reset
            //  we wait on the event in FaxDevSendA to make sure the page is fully sent
            //  the event is set at the end of TiffConvertThread thread
            //  in case we're RECEIVING:
            //  the event is never explicitly reset
            //  we wait on the event in FaxDevReceiveA to make sure the page is fully in.
            //  the event is set at the end of PageAckThread thread
            /////////////////////////////////////////////////////////////////////////////
            goto ErrorExit;
        }

        if ((pTG->FirstPageReadyTxSignal = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            /////////////////////////////////////////////////////////////////////////////
            //  this is used to communicate between the send operation and
            //  the thread that processes the TIFF (prepares the data to be sent)
            //  the event is never explicitly reset
            //  we wait on the event in ICommGetSendBuf when we want some data to send
            //  the event is set in TiffConvertThread after each page is ready to send
            /////////////////////////////////////////////////////////////////////////////
            goto ErrorExit;
        }

        if ((pTG->AbortReqEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
        {
            /////////////////////////////////////////////////////////////////////////////
            //  this is used to signal an abort request came in
            //  the event is set in FaxDevAbortOperationA only
            //  we wait on the event in many places:    FComFilterFillCache
            //                                          FComFilterReadBuf
            //                                          FComGetOneChar
            //                                          ICommPutRecvBuf
            //                                          DecodeFaxPageAsync
            //                                          itapi_async_wait
            //                                          TiffConvertThread
            //  the event may be reset in all those places.
            //  THIS IS THE WAY THE ABORT WORKS:
            //  when we get an abort event, then we quit everything in general
            //  the exception is when we have permission to ignore the abort for a while
            //  this permission may be granted by setting the fOkToResetAbortReqEvent flag
            //  if it is set it means we're on the way out anyway so the abort is meaningless
            //  or that we're in a critical i/o operation that we don't want to abort.
            //  So if this flag is set, we reset the event and continue operation.
            //  The saga continues...
            //  since we ignored a legtimate abort request, we set fAbortReqEventWasReset
            //  flag to make sure that resetting the event is done only once.
            //  The actual abort operation is checked against the fAbortRequested flag
            //  This flag is used everywhere to check if we need to abort.
            //  the only excuse for the event is to help us escape long
            //  WaitForMultipleObject calls.
            //  When we have permission to reset the event, the fAbortRequested is still
            //  on (even though the event was reset) and the next piece of code
            //  which checks for an abort will decide that it's a true abort.
            //  The only thing left to complete this story is to describe when do we
            //  have permission to reset the event:
            //  1. when we're receiving we can always reset the abort event
            //  2. when we're sending we can reset it until the end of PhaseB
            //  3. when the imaging threads are done we can reset it (on the way out anyway)
            /////////////////////////////////////////////////////////////////////////////
            goto ErrorExit;
        }

        if ((pTG->AbortAckEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            /////////////////////////////////////////////////////////////////////////////
            //  this is used to communicate between the send/receive operation and
            //  the abort thread
            //  the event is reset
            //  we wait on the event in
            //  the event is set at the end of FaxDevSend and FaxDevReceice
            /////////////////////////////////////////////////////////////////////////////
            goto ErrorExit;
        }

        pTG->fWaitingForEvent = FALSE;

        pTG->fDeallocateCall = 0;

        MyAllocInit(pTG);

        pTG->StatusId     = 0;
        pTG->StringId     = 0;
        pTG->PageCount    = 0;
        pTG->CSI          = 0;
        pTG->CallerId[0]  = 0;
        pTG->RoutingInfo  = 0;

        // helper image threads sync. flags
        pTG->AckTerminate = 1;
        pTG->fOkToResetAbortReqEvent = TRUE;

        pTG->Inst.awfi.fLastPage = 0;

        CLOSE_DEBUG_FILE;
        return (TRUE);

ErrorExit:

        InterlockedDecrement(&gT30.CntConnect);

        if(pTG)
        {
            CloseHandle(pTG->hevAsync);
            CloseHandle(pTG->ThrdSignal);
            CloseHandle(pTG->ThrdDoneSignal);
            CloseHandle(pTG->ThrdAckTerminateSignal);
            CloseHandle(pTG->FirstPageReadyTxSignal);
            CloseHandle(pTG->AbortReqEvent);
            CloseHandle(pTG->AbortAckEvent);

            MemFree(pTG);
        }

        if (fFound) // So we have to free i entry.
        {
            EnterCriticalSection(&T30CritSection);

            T30Inst[i].fAvail   = TRUE; // Mark the entry as free.
            T30Inst[i].pT30     = NULL;

            LeaveCriticalSection(&T30CritSection);
        }

        CLOSE_DEBUG_FILE;
        return (FALSE);
    }
}




///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevEndJobA(HANDLE FaxHandle)
/*++

Routine Description:
    Device Provider Initialization.


Arguments:
    Device Provider Cleanup. Synopsis:
    * Find ThreadGlobal in T30Inst
    * CloseHandle(s), MemFree, etc.
    * Free entry in T30Inst

Return Value:

--*/
{

    PThrdGlbl  pTG=NULL;
    LONG_PTR    i;

    OPEN_DEBUG_FILE(T30_DEBUG_LOG_FILE);
    {
        DEBUG_FUNCTION_NAME(_T("FaxDevEndJobA"));

        DebugPrintEx(DEBUG_MSG,"FaxHandle=%x", FaxHandle);

        // find instance data
        //------------------------

        i = (LONG_PTR) FaxHandle;

        if (i < 1   ||  i >= MAX_T30_CONNECT)
        {
            DebugPrintEx(DEBUG_ERR,"got wrong FaxHandle=%d", i);
            CLOSE_DEBUG_FILE;
            return (FALSE);
        }

        if (T30Inst[i].fAvail)
        {
            DebugPrintEx(DEBUG_ERR,"got wrong FaxHandle (marked as free) %d", i);
            CLOSE_DEBUG_FILE;
            return (FALSE);
        }

        pTG = (PThrdGlbl) T30Inst[i].pT30;

        if (pTG->hevAsync)
        {
            CloseHandle(pTG->hevAsync);
        }

        if (pTG->StatusId == FS_NOT_FAX_CALL)
        {
            CloseHandle( (HANDLE)pTG->Comm.nCid );
        }

        if (pTG->ThrdSignal)
        {
            CloseHandle(pTG->ThrdSignal);
        }

        if (pTG->ThrdDoneSignal)
        {
            CloseHandle(pTG->ThrdDoneSignal);
        }

        if (pTG->ThrdAckTerminateSignal)
        {
            CloseHandle(pTG->ThrdAckTerminateSignal);
        }

        if (pTG->FirstPageReadyTxSignal)
        {
            CloseHandle(pTG->FirstPageReadyTxSignal);
        }

        if (pTG->AbortReqEvent)
        {
            CloseHandle(pTG->AbortReqEvent);
        }

        if (pTG->AbortAckEvent)
        {
            CloseHandle(pTG->AbortAckEvent);
        }

        if (pTG->hThread)
        {
            CloseHandle(pTG->hThread);
        }

        MemFree(pTG->lpwFileName);

        pTG->fRemoteIdAvail = 0;

        if (pTG->RemoteID)
        {
            MemFree(pTG->RemoteID);
        }

        CleanModemInfStrings(pTG);

        ClosePSSLogFile(pTG);

        MemFree(pTG);

        EnterCriticalSection(&T30CritSection);

        T30Inst[i].fAvail = TRUE;
        T30Inst[i].pT30   = NULL;
        gT30.CntConnect--;

        LeaveCriticalSection(&T30CritSection);

        DebugPrintEx(DEBUG_MSG,"Handle %d", FaxHandle);

        CLOSE_DEBUG_FILE;
        return (TRUE);
    }
}

///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevSendA(
    IN  HANDLE                 FaxHandle,
    IN  PFAX_SEND_A            FaxSend,
    IN  PFAX_SEND_CALLBACK     FaxSendCallback
    )

/*++

Routine Description:
    Device provider send. Synopsis:
    * Find ThreadGlobal in T30Inst
    * TAPI: lineMakeCall
    * itapi_async_wait (until LineCallBack sends TAPI message LINE_CALLSTATE)
    * Add entry to recovery area
    * GetModemParams
    * Convert the destination# to a dialable
      * If dial string contains special characters, check if the modem supports them
    * T30ModemInit
    * Open TIFF file to send
    * FaxSendCallback
    ****************** Send the fax
    * Delete remaining temp files
    * FaxDevCleanup

Arguments:

Return Value:


--*/

{

    LONG_PTR              i;
    PThrdGlbl             pTG=NULL;
    LONG                  lRet;
    DWORD                 dw;
    LPSTR                 lpszFaxNumber;
    LPLINECALLPARAMS      lpCallParams;
    HCALL                 CallHandle;
    BYTE                  rgby [sizeof(LINETRANSLATEOUTPUT)+64];
    LPLINETRANSLATEOUTPUT lplto1 = (LPLINETRANSLATEOUTPUT) rgby;
    LPLINETRANSLATEOUTPUT lplto;
    BOOL                  RetCode;
    int                   fFound=0;
    int                   RecoveryIndex = -1;
    BOOL                  bDialBilling  = FALSE;
    BOOL                  bDialQuiet    = FALSE;
    BOOL                  bDialDialTone = FALSE;
    LPCOMMPROP            lpCommProp    = NULL;
    TCHAR                 szDeviceName[MAX_DEVICE_NAME_SIZE] = {'\0'};    // used for PSSLog

    OPEN_DEBUG_FILE(T30_DEBUG_LOG_FILE);

__try
{
    DEBUG_FUNCTION_NAME(_T("FaxDevSendA"));

    DebugPrintEx(   DEBUG_MSG,
                    "FaxHandle=%x, FaxSend=%x, FaxSendCallback=%x at %ld",
                    FaxHandle, FaxSend, FaxSendCallback, GetTickCount() );

    // find instance data
    //------------------------

    i = (LONG_PTR) FaxHandle;

    if (i < 1   ||  i >= MAX_T30_CONNECT)
    {

        MemFree(FaxSend->FileName);
        MemFree(FaxSend->CallerName);
        MemFree(FaxSend->CallerNumber);
        MemFree(FaxSend->ReceiverName);
        MemFree(FaxSend->ReceiverNumber);

        CLOSE_DEBUG_FILE;
        return FALSE;
    }

    if (T30Inst[i].fAvail)
    {
        MemFree(FaxSend->FileName);
        MemFree(FaxSend->CallerName);
        MemFree(FaxSend->CallerNumber);
        MemFree(FaxSend->ReceiverName);
        MemFree(FaxSend->ReceiverNumber);

        CLOSE_DEBUG_FILE;
        return FALSE;
    }

    pTG = (PThrdGlbl) T30Inst[i].pT30;
    pTG->RecoveryIndex = -1;

    lpszFaxNumber = FaxSend->ReceiverNumber;

    pTG->Operation = T30_TX;

    // store LocalID
    if (FaxSend->CallerNumber == NULL)
    {
        pTG->LocalID[0] = 0;
    }
    else
    {
        _fmemcpy(pTG->LocalID, FaxSend->CallerNumber, min (_fstrlen(FaxSend->CallerNumber), sizeof(pTG->LocalID) - 1) );
        pTG->LocalID [ min (_fstrlen(FaxSend->CallerNumber), sizeof(pTG->LocalID) - 1) ] = 0;
    }

    // go to TAPI pass-through mode
    //-------------------------------

    lpCallParams = itapi_create_linecallparams();

    if (!itapi_async_setup(pTG))
    {
        DebugPrintEx(DEBUG_ERR,"itapi_async_setup failed");

        MemFree (lpCallParams);
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    lRet = lineMakeCall (pTG->LineHandle,
                         &CallHandle,
                         lpszFaxNumber,
                         0,
                         lpCallParams);

    if (lRet < 0)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "lineMakeCall returns ERROR value 0x%lx",
                        (unsigned long) lRet);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_LINE_UNAVAILABLE);

        MemFree (lpCallParams);

        RetCode = FALSE;
        goto l_exit;
    }
    else
    {
        DebugPrintEx(DEBUG_MSG,"lineMakeCall returns 0x%lx",(unsigned long)lRet);
    }

    if (!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT))
    {
        DebugPrintEx(DEBUG_ERR,"itapi_async_wait failed");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_LINE_UNAVAILABLE);

        MemFree (lpCallParams);

        RetCode = FALSE;
        goto l_exit;
    }

    // now we wait for the connected message
    //--------------------------------------

    for (dw=50; dw<10000; dw = dw*120/100)
    {
        Sleep(dw);
        if (pTG->fGotConnect)
             break;
    }

    if (!pTG->fGotConnect)
    {
         DebugPrintEx(DEBUG_ERR,"Failure waiting for CONNECTED message....");
         // We ignore... goto failure1;
    }

    MemFree (lpCallParams);

    pTG->CallHandle = CallHandle;

    //
    // Add entry to the Recovery Area.
    //
    fFound = 0;

    for (i=0; i<MAX_T30_CONNECT; i++)
    {
        if (T30Recovery[i].fAvail)
        {
            EnterCriticalSection(&T30RecoveryCritSection);

            T30Recovery[i].fAvail               = FALSE;
            T30Recovery[i].ThreadId             = GetCurrentThreadId();
            T30Recovery[i].FaxHandle            = FaxHandle;
            T30Recovery[i].pTG                  = (LPVOID) pTG;
            T30Recovery[i].LineHandle            = pTG->LineHandle;
            T30Recovery[i].CallHandle            = CallHandle;
            T30Recovery[i].DeviceId             = pTG->DeviceId;
            T30Recovery[i].CompletionPortHandle = pTG->CompletionPortHandle;
            T30Recovery[i].CompletionKey         = pTG->CompletionKey;
            T30Recovery[i].TiffThreadId          = 0;
            T30Recovery[i].TimeStart             = GetTickCount();
            T30Recovery[i].TimeUpdated           = T30Recovery[i].TimeStart;
            T30Recovery[i].CkSum                 = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                                                     sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1);

            LeaveCriticalSection(&T30RecoveryCritSection);
            fFound = 1;
            RecoveryIndex = (int)i;
            pTG->RecoveryIndex = (int)i;

            break;
        }
    }

    if (! fFound)
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't find available space for Recovery");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    RetCode = GetModemParams(pTG, szDeviceName, MAX_DEVICE_NAME_SIZE);
    if (!RetCode)
    {
        DebugPrintEx(DEBUG_ERR,"GetModemParams failed");
        goto l_exit;
    }
    
    // Convert the destination# to a dialable
    //--------------------------------------------

    // find out how big a buffer should be
    //
    _fmemset(rgby, 0, sizeof(rgby));
    lplto1->dwTotalSize = sizeof(rgby);

    lRet = lineTranslateAddress (gT30.LineAppHandle,
                                 pTG->DeviceId,
                                 TAPI_VERSION,
                                 lpszFaxNumber,
                                 0,      // dwCard
                                 LINETRANSLATEOPTION_CANCELCALLWAITING,
                                 lplto1);

    if (lRet)
    {
        DebugPrintEx(DEBUG_ERR,"Can't translate dest. address %s", lpszFaxNumber);
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    if (lplto1->dwNeededSize <= 0)
    {
        DebugPrintEx(DEBUG_ERR,"Can't dwNeededSize<0 for Fax# %s", lpszFaxNumber);
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    lplto = MemAlloc(lplto1->dwNeededSize);
    if (! lplto)
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't allocate space for lplto");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    lplto->dwTotalSize = lplto1->dwNeededSize;

    lRet = lineTranslateAddress (gT30.LineAppHandle,
                                 pTG->DeviceId,
                                 TAPI_VERSION,
                                 lpszFaxNumber,
                                 0,      // dwCard
                                 LINETRANSLATEOPTION_CANCELCALLWAITING,
                                 lplto);

    if (lRet)
    {
        DebugPrintEx(DEBUG_ERR,"Can't translate dest. address %s", lpszFaxNumber);
        MemFree(lplto);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    if ((lplto->dwNeededSize > lplto->dwTotalSize) || (lplto->dwDialableStringSize>=MAXPHONESIZE))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "NeedSize=%d > TotalSize=%d for Fax# %s",
                        lplto->dwNeededSize ,lplto->dwTotalSize, lpszFaxNumber);
        MemFree(lplto);

        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }


    _fmemcpy (pTG->lpszDialDestFax, ( (char *) lplto) + lplto->dwDialableStringOffset, lplto->dwDialableStringSize);
    DebugPrintEx(DEBUG_MSG,"Dialable Dest is %s", pTG->lpszDialDestFax);

    OpenPSSLogFile(pTG, szDeviceName, PSS_SEND);

    MemFree(lplto);

    // check if the dial string contains '$', '@' or 'W'
    if (_tcschr(pTG->lpszDialDestFax,_T('$'))!=NULL)
    {
        // the '$' means we're supposed to wait for a billing tone ('bong')
        bDialBilling = TRUE;
    }
    if (_tcschr(pTG->lpszDialDestFax,_T('@'))!=NULL)
    {
        // the '@' means we're supposed to wait for quiet before dialing
        bDialQuiet = TRUE;
    }
    if (_tcschr(pTG->lpszDialDestFax,_T('W'))!=NULL)
    {
        // the 'W' means we're supposed to wait for a dial tone before dialing
        bDialDialTone = TRUE;
    }
    if (bDialBilling || bDialQuiet || bDialDialTone)
    {
        LPMODEMDEVCAPS lpModemDevCaps = NULL;
        // dial string contains special characters, check if the modem supports them
        lpCommProp = (LPCOMMPROP)LocalAlloc(    LMEM_FIXED | LMEM_ZEROINIT,
                                                sizeof(COMMPROP) + sizeof(MODEMDEVCAPS));

        if (lpCommProp==NULL)
        {
            DebugPrintEx(DEBUG_ERR,"Couldn't allocate space for llpCommPropplto");
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }
        lpCommProp->wPacketLength = sizeof(COMMPROP) + sizeof(MODEMDEVCAPS);
        lpCommProp->dwProvSubType = PST_MODEM;
        lpCommProp->dwProvSpec1 = COMMPROP_INITIALIZED;
        if (!GetCommProperties(pTG->hComm,lpCommProp))
        {
            DebugPrintEx(DEBUG_ERR,"GetCommProperties failed (ec=%d)",GetLastError());

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }
        // since dwProvSubType == PST_MODEM, lpCommProp->wcProvChar contains a MODEMDEVCAPS struct
        lpModemDevCaps = (LPMODEMDEVCAPS)lpCommProp->wcProvChar;
        if ((bDialBilling   && !(lpModemDevCaps->dwDialOptions & DIALOPTION_BILLING))  ||
            (bDialQuiet     && !(lpModemDevCaps->dwDialOptions & DIALOPTION_QUIET))    ||
            (bDialDialTone  && !(lpModemDevCaps->dwDialOptions & DIALOPTION_DIALTONE)) )
        {
            // modem does not support special char, but char was specified, fail job
            DebugPrintEx(DEBUG_ERR,"Unsupported char in dial string");

            pTG->fFatalErrorWasSignaled = 1;
            pTG->StringId = IDS_UNSUPPORTED_CHARACTER;
            SignalStatusChange(pTG, FS_UNSUPPORTED_CHAR);
            RetCode = FALSE;
            goto l_exit;

        }
    }

    /// RSL -revisit, may decrease prty during computation
    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL) )
    {
        DebugPrintEx(   DEBUG_ERR,
                        "SetThreadPriority TIME CRITICAL failed le=%x",
                        GetLastError() );
    }

    //
    // initialize modem
    //--------------------

    if ( T30ModemInit(pTG, pTG->hComm, 0, LINEID_TAPI_PERMANENT_DEVICEID,
                      DEF_BASEKEY, pTG->lpszPermanentLineID, fMDMINIT_ANSWER)
          != INIT_OK )
    {
        DebugPrintEx(DEBUG_ERR,"can't do T30ModemInit");
        pTG->fFatalErrorWasSignaled = TRUE;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    pTG->Inst.ProtParams.uMinScan = MINSCAN_0_0_0;
    ET30ProtSetProtParams(pTG, &pTG->Inst.ProtParams, pTG->FComModem.CurrMdmCaps.uSendSpeeds, pTG->FComModem.CurrMdmCaps.uRecvSpeeds);

    InitCapsBC( pTG, (LPBC) &pTG->Inst.SendCaps, sizeof(pTG->Inst.SendCaps), SEND_CAPS);

    // store the TIFF filename
    //-------------------------

    pTG->lpwFileName = AnsiStringToUnicodeString(FaxSend->FileName);

    if ( !pTG->fTiffOpenOrCreated)
    {
        pTG->Inst.hfile =  TiffOpenW (pTG->lpwFileName,
                                                  &pTG->TiffInfo,
                                                  TRUE);

        if (!(pTG->Inst.hfile))
        {
            DebugPrintEx(DEBUG_ERR,"Can't open tiff file %s", pTG->lpwFileName);
            // pTG->StatusId = FS_TIFF_SRC_BAD
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }

        if (pTG->TiffInfo.YResolution == 98)
        {
            pTG->SrcHiRes = 0;
        }
        else
        {
            pTG->SrcHiRes = 1;
        }

        pTG->fTiffOpenOrCreated = 1;

        DebugPrintEx(   DEBUG_MSG,
                        "Successfully opened TIFF Yres=%d HiRes=%d",
                        pTG->TiffInfo.YResolution, pTG->SrcHiRes);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,"tiff file %s is OPENED already", pTG->lpwFileName);
        DebugPrintEx(DEBUG_ERR,"Can't open tiff file %s", pTG->lpwFileName);
        // pTG->StatusId = FS_TIFF_SRC_BAD
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    // Fax Service Callback
    //----------------------

    if (!FaxSendCallback(FaxHandle,
                         CallHandle,
                         0,
                         0) )
    {
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }


    // Send the Fax
    //-----------------------------------------------------------------------


    // here we already know what Class we will use for a particular modem.
    //-------------------------------------------------------------------


    if (pTG->ModemClass == MODEM_CLASS2)
    {
       Class2Init(pTG);
       RetCode = T30Cl2Tx (pTG, pTG->lpszDialDestFax);
    }
    else if (pTG->ModemClass == MODEM_CLASS2_0)
    {
       Class20Init(pTG);
       RetCode = T30Cl20Tx (pTG, pTG->lpszDialDestFax);
    }
    else if (pTG->ModemClass == MODEM_CLASS1)
    {
       RetCode = T30Cl1Tx(pTG, pTG->lpszDialDestFax);
    }

    // delete all the files that are left

    _fmemcpy (pTG->InFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
    _fmemcpy (&pTG->InFileName[gT30.dwLengthTmpDirectory], pTG->lpszPermanentLineID, 8);

    for (dw = pTG->CurrentIn; dw <= pTG->LastOut; dw++)
    {
        sprintf( &pTG->InFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  dw);
        if (! DeleteFileA (pTG->InFileName) )
        {
            DWORD dwLastError = GetLastError();
            if (dwLastError==ERROR_SHARING_VIOLATION && pTG->InFileHandleNeedsBeClosed)
            {   // t-jonb: This can happen if the job is FaxDevAborted
                DebugPrintEx(DEBUG_WRN,
                             "file %s can't be deleted; le = ERROR_SHARING_VIOLATION; trying to close InFileHandle",
                             pTG->InFileName);
                CloseHandle(pTG->InFileHandle);
                pTG->InFileHandleNeedsBeClosed = 0;
                if (! DeleteFileA (pTG->InFileName) )
                {
                    DebugPrintEx(DEBUG_ERR,
                                 "file %s still can't be deleted; le=%lx",
                                pTG->InFileName, GetLastError());
                }

            }
            else
            {
                DebugPrintEx(   DEBUG_ERR,
                                "file %s can't be deleted; le=%lx",
                                pTG->InFileName, dwLastError);
            }
        }
    }

l_exit:

    pFaxDevCleanup(pTG,RecoveryIndex);

    if (RetCode) 
    {
        PSSLogEntry(PSS_MSG, 0, "Fax was sent successfully");
    }
    else
    {
        PSSLogEntry(PSS_ERR, 0, "Failed send");
    }
        
    MemFree(FaxSend->FileName);
    FaxSend->FileName = NULL;
    MemFree(FaxSend->CallerName);
    FaxSend->CallerName = NULL;
    MemFree(FaxSend->CallerNumber);
    FaxSend->CallerNumber = NULL;
    MemFree(FaxSend->ReceiverName);
    FaxSend->ReceiverName = NULL;
    MemFree(FaxSend->ReceiverNumber);
    FaxSend->ReceiverNumber = NULL;

    if (lpCommProp)
    {
        LocalFree(lpCommProp);
        lpCommProp = NULL;
    }

    if ( (RetCode == FALSE) && (pTG->StatusId == FS_COMPLETED) )
    {
       DebugPrintEx(DEBUG_ERR,"exit success but later failed");
       RetCode = TRUE;
    }

    CLOSE_DEBUG_FILE;
    if (!RetCode)
    {
        SetLastError(ERROR_FUNCTION_FAILED);
    }
    return (RetCode);
}
__except (EXCEPTION_EXECUTE_HANDLER)
    {
        pFaxDevExceptionCleanup();

        MemFree(FaxSend->FileName);
        FaxSend->FileName = NULL;
        MemFree(FaxSend->CallerName);
        FaxSend->CallerName = NULL;
        MemFree(FaxSend->CallerNumber);
        FaxSend->CallerNumber = NULL;
        MemFree(FaxSend->ReceiverName);
        FaxSend->ReceiverName = NULL;
        MemFree(FaxSend->ReceiverNumber);
        FaxSend->ReceiverNumber = NULL;

        if (lpCommProp)
        {
            LocalFree(lpCommProp);
            lpCommProp = NULL;
        }
        CLOSE_DEBUG_FILE;
        return (FALSE);
    }
}

///////////////////////////////////////////////////////////////////////////////////
VOID pFaxDevCleanup(PThrdGlbl pTG,int RecoveryIndex)
{
    LONG lRet = 0;

    DEBUG_FUNCTION_NAME(_T("pFaxDevCleanup"));

    if (pTG->fTiffOpenOrCreated)
    {
        TiffClose( pTG->Inst.hfile);
        pTG->fTiffOpenOrCreated = 0;
    }

    if (pTG->FComStatus.fModemInit)
    {
        if(!iModemClose(pTG))
        {
            DebugPrintEx(DEBUG_ERR,"iModemClose failed!");
        }
    }
    else
    {
        // the modem was not initialized, so the job failed or was aborted before
        // we got to T30ModemInit, but it also means that lineGetID was called
        // and there's a good chance this handle is still open.
        // in order to recover from pass throuhg mode, we have to attemp to close this
        // handle, no matter what...
        if (pTG->hComm)
        {
            DebugPrintEx(DEBUG_WRN,"Trying to close comm for any case...");
            if (!CloseHandle((HANDLE)pTG->hComm))
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Close Handle pTG->hComm failed (ec=%d)",
                                GetLastError());
            }
        }
    }

#ifdef ADAPTIVE_ANSWER

    if (pTG->Comm.fEnableHandoff &&  pTG->Comm.fDataCall)
    {
        DebugPrintEx(DEBUG_WRN,"DataCall dont hangup");
    }
    else
#endif
    {
        // release the line
        //-----------------------------

        if (pTG->fDeallocateCall == 0)
        {
            //
            // line never was signalled IDLE, need to lineDrop first
            //
            if (!itapi_async_setup(pTG))
            {
                DebugPrintEx(DEBUG_ERR,"lineDrop itapi_async_setup failed");
                if (!pTG->fFatalErrorWasSignaled)
                {
                    pTG->fFatalErrorWasSignaled = 1;
                    SignalStatusChange(pTG, FS_FATAL_ERROR);
                }
            }
            lRet = 0;
            if (pTG->CallHandle)
                lRet = lineDrop (pTG->CallHandle, NULL, 0);

            if (lRet < 0)
            {
                DebugPrintEx(DEBUG_ERR,"lineDrop failed %lx", lRet);
            }
            else
            {
                DebugPrintEx(DEBUG_MSG,"lineDrop returns request %d", lRet);
                if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_SHORT_TIMEOUT))
                {
                    DebugPrintEx(DEBUG_ERR,"itapi_async_wait failed on lineDrop");
                }
                DebugPrintEx(DEBUG_MSG,"lineDrop SUCCESS");
            }
            //
            //deallocating call
            //

            // it took us some time since first test
            if (pTG->fDeallocateCall == 0)
            { // Here we know that pTG->fDeallocateCall == 0 is true...
                pTG->fDeallocateCall = 1;
            }
        }
    }
    if ( (RecoveryIndex >= 0) && (RecoveryIndex < MAX_T30_CONNECT) )
    {
        T30Recovery[RecoveryIndex].fAvail = TRUE;
    }

    /// RSL -revisit, may decrease prty during computation
    if (!SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL) )
    {
        DebugPrintEx(   DEBUG_ERR,
                        "SetThreadPriority Normal failed le=%x",
                        GetLastError() );
    }

    if (pTG->InFileHandleNeedsBeClosed)
    {
        CloseHandle(pTG->InFileHandle);
        pTG->InFileHandleNeedsBeClosed = 0;
    }

    if (!pTG->AckTerminate)
    {
        if (WaitForSingleObject(pTG->ThrdAckTerminateSignal, TX_WAIT_ACK_TERMINATE_TIMEOUT)  == WAIT_TIMEOUT)
        {
            DebugPrintEx(DEBUG_WRN,"Never got AckTerminate");
        }
    }

    DebugPrintEx(DEBUG_MSG,"Got AckTerminate OK");

    if (!SetEvent(pTG->AbortAckEvent))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "SetEvent(0x%lx) returns failure code: %ld",
                        (ULONG_PTR)pTG->AbortAckEvent,
                        (long) GetLastError());
    }
}
///////////////////////////////////////////////////////////////////////////////////
VOID pFaxDevExceptionCleanup()
{
    //
    // try to use the Recovery data
    //
    // Each function that will fail here will stop the line closing sequence.
    //

    DWORD       dwCkSum;
    HCALL       CallHandle;
    HANDLE      CompletionPortHandle;
    ULONG_PTR   CompletionKey;
    PThrdGlbl   pTG = NULL;
    DWORD       dwThreadId = GetCurrentThreadId();
    int         fFound=0,i;
    long        lRet;

    DEBUG_FUNCTION_NAME(_T("pFaxDevExceptionCleanup"));

    fFound = FALSE;

    SetLastError(ERROR_FUNCTION_FAILED);

    DebugPrintEx(DEBUG_WRN,"Trying to find Recovery Information after catch exception.");
    for (i=0; i<MAX_T30_CONNECT; i++)
    {
        if ( (! T30Recovery[i].fAvail) && (T30Recovery[i].ThreadId == dwThreadId) )
        {
            if ( ( dwCkSum = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                              sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1) ) == T30Recovery[i].CkSum )
            {
                CallHandle           = T30Recovery[i].CallHandle;
                CompletionPortHandle = T30Recovery[i].CompletionPortHandle;
                CompletionKey        = T30Recovery[i].CompletionKey;
                pTG                  = (PThrdGlbl) T30Recovery[i].pTG;

                fFound = TRUE;
                T30Recovery[i].fAvail = TRUE;
                break;
            }
        }
    }

    if (!fFound)
    {
        //
        // Need to indicate that FaxT30 couldn't recover by itself.
        //
        DebugPrintEx(DEBUG_ERR,"Have not found the recovery information");
        return;
    }

    //
    // get out of Pass-through
    //
    if (pTG->FComStatus.fModemInit)
    {
        if(!iModemClose(pTG))
        {
            DebugPrintEx(DEBUG_ERR,"iModemClose failed!");
        }
    }
    else
    {
        // the modem was not initialized, so the job failed or was aborted before
        // we got to T30ModemInit, but it also means that lineGetID was called
        // and there's a good chance this handle is still open.
        // in order to recover from pass throuhg mode, we have to attemp to close this
        // handle, no matter what...
        if (pTG->hComm)
        {
            DebugPrintEx(DEBUG_WRN,"Trying to close comm for any case...");
            if (!CloseHandle((HANDLE)pTG->hComm))
            {
                DebugPrintEx(   DEBUG_ERR,
                                "Close Handle pTG->hComm failed (ec=%d)",
                                GetLastError());
            }
        }
    }

    if (!itapi_async_setup(pTG))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Failed in itapi_async_setup, before lineSetCallParams"
                        " ,ec = %d",
                        GetLastError());
        return;
    }

    lRet = lineSetCallParams(CallHandle,
                             LINEBEARERMODE_VOICE,
                             0,
                             0xffffffff,
                             NULL);


    if (lRet < 0)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "lineSetCallParams failed, Return value is %d",
                        lRet);
        return;
    }
    else
    {
        if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT))
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Failed in itapi_async_wait, after"
                            " lineSetCallParams ,ec = %d",
                            GetLastError());
            return;
        }
    }

    //
    // hang up
    //

    if (!itapi_async_setup(pTG))
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Failed in itapi_async_setup, before lineDrop"
                        " ,ec = %d",
                        GetLastError());
        return;
    }

    lRet = lineDrop (CallHandle, NULL, 0);

    if (lRet < 0)
    {
        DebugPrintEx(   DEBUG_ERR,
                        "Failed in lineDrop ,Return value is = %d",
                        lRet);
        return;
    }
    else
    {
        if(!itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT))
        {
            DebugPrintEx(   DEBUG_ERR,
                            "Failed in itapi_async_wait, after lineDrop"
                            " ,ec = %d",
                            GetLastError());
            return;
        }
        // SignalRecoveryStatusChange(  &T30Recovery[i] );
    }

    SignalRecoveryStatusChange( &T30Recovery[i] );

    if (pTG->InFileHandleNeedsBeClosed)
    {
        CloseHandle(pTG->InFileHandle);
    }

    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_NORMAL);

}

///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReceiveA(
    HANDLE              FaxHandle,
    HCALL               CallHandle,
    PFAX_RECEIVE_A      FaxReceive
    )

/*++

Routine Description:
    Device provider receive. Synopsis:
    * Find ThreadGlobal in T30Inst
    * Add entry to recovery area
    * TAPI: lineSetCallParams
    * itapi_async_wait (until LineCallBack sends TAPI message LINE_CALLSTATE)
    * GetModemParams
    * ReadExtensionConfiguration (Reads T30 extension config, i.e. "adaptive answering enabled")
    * T30ModemInit
    * GetCallerIDFromCall
    ****************** Receive the fax
    * FaxDevCleanup

Arguments:

Return Value:

--*/

{

    LONG_PTR             i;
    PThrdGlbl           pTG=NULL;
    long                lRet;
    DWORD               dw;
    BOOL                RetCode;
    int                 fFound=0;
    BOOL                bBlindReceive = FALSE;
    int                 RecoveryIndex = -1;
    TCHAR               szDeviceName[MAX_DEVICE_NAME_SIZE] = {'\0'};    // used for PSSLog

    OPEN_DEBUG_FILE(T30_DEBUG_LOG_FILE);

__try
    {
    DEBUG_FUNCTION_NAME(_T("FaxDevReceiveA"));

    DebugPrintEx(   DEBUG_MSG,
                    "FaxHandle=%x, CallHandle=%x, FaxReceive=%x at %ld",
                    FaxHandle, CallHandle, FaxReceive, GetTickCount() );

    // find instance data
    //------------------------

    i = (LONG_PTR) FaxHandle;

    if (i < 1   ||  i >= MAX_T30_CONNECT)
    {
        MemFree(FaxReceive->FileName);
        MemFree(FaxReceive->ReceiverName);
        MemFree(FaxReceive->ReceiverNumber);

        DebugPrintEx(   DEBUG_ERR,
                        "FaxHandle=%x, CallHandle=%x, FaxReceive=%x at %ld",
                        FaxHandle, CallHandle, FaxReceive, GetTickCount() );
        CLOSE_DEBUG_FILE;
        return (FALSE);
    }

    if (T30Inst[i].fAvail)
    {
        MemFree(FaxReceive->FileName);
        MemFree(FaxReceive->ReceiverName);
        MemFree(FaxReceive->ReceiverNumber);

        DebugPrintEx(   DEBUG_ERR,
                        "AVAIL FaxHandle=%x, CallHandle=%x, FaxReceive=%x at %ld",
                        FaxHandle, CallHandle, FaxReceive, GetTickCount() );
        CLOSE_DEBUG_FILE;
        return (FALSE);
    }

    pTG = (PThrdGlbl) T30Inst[i].pT30;

    pTG->CallHandle = CallHandle;

    //
    // Add entry to the Recovery Area.
    //

    fFound = 0;

    for (i=0; i<MAX_T30_CONNECT; i++)
    {
        if (T30Recovery[i].fAvail)
        {
            EnterCriticalSection(&T30RecoveryCritSection);

            T30Recovery[i].fAvail               = FALSE;
            T30Recovery[i].ThreadId             = GetCurrentThreadId();
            T30Recovery[i].FaxHandle            = FaxHandle;
            T30Recovery[i].pTG                  = (LPVOID) pTG;
            T30Recovery[i].LineHandle           = pTG->LineHandle;
            T30Recovery[i].CallHandle           = CallHandle;
            T30Recovery[i].DeviceId             = pTG->DeviceId;
            T30Recovery[i].CompletionPortHandle = pTG->CompletionPortHandle;
            T30Recovery[i].CompletionKey        = pTG->CompletionKey;
            T30Recovery[i].TiffThreadId         = 0;
            T30Recovery[i].TimeStart            = GetTickCount();
            T30Recovery[i].TimeUpdated          = T30Recovery[i].TimeStart;
            T30Recovery[i].CkSum                = ComputeCheckSum( (LPDWORD) &T30Recovery[i].fAvail,
                                                                     sizeof ( T30_RECOVERY_GLOB ) / sizeof (DWORD) - 1);

            LeaveCriticalSection(&T30RecoveryCritSection);
            fFound = 1;
            RecoveryIndex = (int)i;
            pTG->RecoveryIndex = (int)i;

            break;
        }
    }

    if (! fFound)
    {
        DebugPrintEx(DEBUG_ERR,"Couldn't find available space for Recovery");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    pTG->Operation = T30_RX;

    // store LocalID
    if (FaxReceive->ReceiverNumber == NULL)
    {
        pTG->LocalID[0] = 0;
    }
    else
    {
        _fmemcpy(pTG->LocalID, FaxReceive->ReceiverNumber, min (_fstrlen(FaxReceive->ReceiverNumber), sizeof(pTG->LocalID) - 1) );
        pTG->LocalID [ min (_fstrlen(FaxReceive->ReceiverNumber), sizeof(pTG->LocalID) - 1) ] = 0;
    }

    // tiff
    //-----------------------------------------------

    pTG->lpwFileName = AnsiStringToUnicodeString(FaxReceive->FileName);
    pTG->SrcHiRes = 1;

    pTG->fGotConnect = FALSE;

    if (!itapi_async_setup(pTG))
    {
        DebugPrintEx(DEBUG_ERR,"itapi_async_setup failed");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }

    if (0 == CallHandle)
    {
        //
        // Special case - blind receive mode
        // This happens when we use the blind-receive (reciveing a fax without a ring / offer from TAPI).
        //
        // We must use lineMakeCall (hLine, &hCall, NULL, 0, LINEBEARERMODE_PASSTHROUGH)
        // to get the initial hCall.
        //
        LPLINECALLPARAMS lpCallParams = itapi_create_linecallparams();
        if (!lpCallParams)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("itapi_create_linecallparams failed with %ld"),
                         GetLastError ());
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }
        lRet = lineMakeCall (pTG->LineHandle,               // TAPI line
                             &CallHandle,                   // New call handle
                             NULL,                          // No address
                             0,                             // No country code
                             lpCallParams);                 // Line call params
        MemFree (lpCallParams);
        if (lRet < 0)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("lineMakeCall returns ERROR value 0x%lx"),
                         (unsigned long)lRet);
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
        }
        else
        {
             DebugPrintEx(  DEBUG_MSG,
                            "lineMakeCall returns ID %ld",
                            (long) lRet);
        }
        bBlindReceive = TRUE;
    }
    else
    {
        // Normal case.
        //
        // take line over from TAPI
        //--------------------------
        //
        // initiate passthru
        //
        lRet = lineSetCallParams(CallHandle,
                                 LINEBEARERMODE_PASSTHROUGH,
                                 0,
                                 0xffffffff,
                                 NULL);

        if (lRet < 0)
        {
            DebugPrintEx(DEBUG_ERR,"lineSetCallParams failed");

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);

            RetCode = FALSE;
            goto l_exit;
        }
        else
        {
             DebugPrintEx(  DEBUG_MSG,
                            "lpfnlineSetCallParams returns ID %ld",
                            (long) lRet);
        }
    }
    //
    // Wait for a successful LINE_REPLY message
    //
    if(!itapi_async_wait(pTG, (DWORD)lRet, &lRet, NULL, ASYNC_TIMEOUT))
    {
        DebugPrintEx(DEBUG_ERR,"itapi_async_wait failed");
        pTG->fFatalErrorWasSignaled = 1;
        SignalStatusChange(pTG, FS_FATAL_ERROR);

        RetCode = FALSE;
        goto l_exit;
    }
    if (bBlindReceive)
    {
        //
        // Only now, after we got the LINE_REPLY from lineMakeCall, we can start using the call handle
        //
        pTG->CallHandle = CallHandle;
    }
    // now we wait for the connected message
    //--------------------------------------

    for (dw=50; dw<10000; dw = dw*120/100)
    {
        Sleep(dw);
        if (pTG->fGotConnect)
        {
            break;
        }
    }

    if (!pTG->fGotConnect)
    {
         DebugPrintEx(DEBUG_ERR,"Failure waiting for CONNECTED message....");
         // We ignore...
    }

    RetCode = GetModemParams(pTG, szDeviceName, MAX_DEVICE_NAME_SIZE);
    if (!RetCode)
    {
        DebugPrintEx(DEBUG_ERR,"GetModemParams failed");
        goto l_exit;
    }

    OpenPSSLogFile(pTG, szDeviceName, PSS_RECEIVE);

    /// RSL -revisit, may decrease prty during computation
    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL) )
    {
        DebugPrintEx(   DEBUG_ERR,
                        "SetThreadPriority TIME CRITICAL failed le=%x",
                        GetLastError() );
    }

    //
    // Read extension configuration
    //

    if (!ReadExtensionConfiguration(pTG))
    {
            DebugPrintEx(
                DEBUG_ERR,
                "ReadExtensionConfiguration() failed for device id: %ld (ec: %ld)",
                pTG->dwPermanentLineID,
                GetLastError()
                );

            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
            RetCode = FALSE;
            goto l_exit;
    }

    // initialize modem
    //--------------------

    if ( T30ModemInit(pTG, pTG->hComm, 0, LINEID_TAPI_PERMANENT_DEVICEID,
                      DEF_BASEKEY, pTG->lpszPermanentLineID, fMDMINIT_ANSWER)
         != INIT_OK )
    {
        DebugPrintEx(DEBUG_ERR, "can't do T30ModemInit");
        pTG->fFatalErrorWasSignaled = TRUE;
        SignalStatusChange(pTG, FS_FATAL_ERROR);
        RetCode = FALSE;
        goto l_exit;
    }

    pTG->Inst.ProtParams.uMinScan = MINSCAN_0_0_0;
    ET30ProtSetProtParams(pTG, &pTG->Inst.ProtParams, pTG->FComModem.CurrMdmCaps.uSendSpeeds, pTG->FComModem.CurrMdmCaps.uRecvSpeeds);

    InitCapsBC( pTG, (LPBC) &pTG->Inst.SendCaps, sizeof(pTG->Inst.SendCaps), SEND_CAPS);

    // answer the call and receive a fax
    //-----------------------------------
    if (GetCallerIDFromCall(pTG->CallHandle,pTG->CallerId,sizeof(pTG->CallerId)))
    {
        DebugPrintEx(DEBUG_MSG, "Caller ID is %s",pTG->CallerId);
    }
    else
    {
        DebugPrintEx(DEBUG_ERR, "GetCallerIDFromCall failed");
    }

    // here we already know what Class we will use for a particular modem.
    //-------------------------------------------------------------------

    if (pTG->ModemClass == MODEM_CLASS2)
    {
       Class2Init(pTG);
       RetCode = T30Cl2Rx (pTG);
    }
    else if (pTG->ModemClass == MODEM_CLASS2_0)
    {
       Class20Init(pTG);
       RetCode = T30Cl20Rx (pTG);
    }
    else if (pTG->ModemClass == MODEM_CLASS1)
    {
       RetCode = T30Cl1Rx(pTG);
    }

l_exit:

    pFaxDevCleanup(pTG,RecoveryIndex);

    if ( (RetCode == FALSE) && (pTG->StatusId == FS_COMPLETED) )
    {
       DebugPrintEx(DEBUG_ERR,"exit success but later failed");
       RetCode = TRUE;
    }

    if (RetCode) 
    {
        PSSLogEntry(PSS_MSG, 0, "Fax was received successfully");
    }
    else
    {
        PSSLogEntry(PSS_ERR, 0, "Failed receive");
    }

    MemFree(FaxReceive->FileName);
    FaxReceive->FileName = NULL;
    MemFree(FaxReceive->ReceiverName);
    FaxReceive->ReceiverName = NULL;
    MemFree(FaxReceive->ReceiverNumber);
    FaxReceive->ReceiverNumber = NULL;

    DebugPrintEx(DEBUG_MSG,"returns %d",RetCode);
    CLOSE_DEBUG_FILE;

    if (!RetCode)
    {
        SetLastError(ERROR_FUNCTION_FAILED);
    }
    return (RetCode);

}
__except (EXCEPTION_EXECUTE_HANDLER)
    {
        pFaxDevExceptionCleanup();

        MemFree(FaxReceive->FileName);
        FaxReceive->FileName = NULL;
        MemFree(FaxReceive->ReceiverName);
        FaxReceive->ReceiverName = NULL;
        MemFree(FaxReceive->ReceiverNumber);
        FaxReceive->ReceiverNumber = NULL;
        CLOSE_DEBUG_FILE;
        return (FALSE);
    }
}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReportStatusA(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    LONG_PTR         i;
    PThrdGlbl       pTG;
    LPWSTR          lpwCSI;   // inside the FaxStatus struct.
    LPWSTR          lpwCallerId = NULL;
    LPBYTE          lpTemp;

    DEBUG_FUNCTION_NAME(_T("FaxDevReportStatusA"));

    *FaxStatusSizeRequired = sizeof (FAX_DEV_STATUS);

    __try
    {
        if (FaxStatusSize < *FaxStatusSizeRequired )
        {
            DebugPrintEx(   DEBUG_WRN,
                            "wrong size passed=%d, expected not less than %d",
                            FaxStatusSize,
                            *FaxStatusSizeRequired);
            goto failure;
        }

        if (FaxHandle == NULL)
        {
            // means global status
            DebugPrintEx(   DEBUG_ERR,
                            "EP: FaxDevReportStatus NULL FaxHandle; "
                            "gT30.Status=%d",
                            gT30.Status);

            if (gT30.Status == STATUS_FAIL)
            {
                goto failure;
            }
            else
            {
                return (TRUE);
            }
        }
        else
        {
            // find instance data
            //------------------------

            i = (LONG_PTR) FaxHandle;

            if (i < 1   ||  i >= MAX_T30_CONNECT)
            {
                DebugPrintEx(DEBUG_ERR,"got wrong FaxHandle=%d", i);
                goto failure;
            }

            if (T30Inst[i].fAvail)
            {
                DebugPrintEx(DEBUG_ERR,"got wrong FaxHandle (marked as free) %d", i);
                goto failure;
            }

            pTG = (PThrdGlbl) T30Inst[i].pT30;

            FaxStatus->SizeOfStruct = sizeof(FAX_DEV_STATUS);
            FaxStatus->StatusId    = pTG->StatusId;
            FaxStatus->StringId    = pTG->StringId;
            FaxStatus->PageCount   = pTG->PageCount;

            lpTemp = (LPBYTE) FaxStatus;
            lpTemp += sizeof(FAX_DEV_STATUS);

            if (pTG->fRemoteIdAvail)
            {
                lpwCSI = (LPWSTR) lpTemp;
                wcscpy(lpwCSI, pTG->RemoteID);
                FaxStatus->CSI = (LPWSTR) lpwCSI;
                lpTemp += ((wcslen(FaxStatus->CSI)+1)*sizeof(WCHAR));
            }
            else
            {
                FaxStatus->CSI         = NULL;
            }

            FaxStatus->CallerId = (LPWSTR) lpTemp;
            lpwCallerId = (LPWSTR) AnsiStringToUnicodeString(pTG->CallerId);
            if (lpwCallerId)
            {
                wcscpy(FaxStatus->CallerId, lpwCallerId);
                MemFree(lpwCallerId);
            }
            else
            {
                FaxStatus->CallerId = NULL;
            }

            FaxStatus->RoutingInfo = NULL; // (char *) AnsiStringToUnicodeString(pTG->RoutingInfo);

            DebugPrintEx(DEBUG_MSG,"returns %lx", pTG->StatusId);

            return (TRUE);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DebugPrintEx(DEBUG_ERR,"crashed accessing data");
        SetLastError(ERROR_FUNCTION_FAILED);
        return (FALSE);
    }

    DebugPrintEx(DEBUG_ERR, "wrong return");
    return (TRUE);


failure:
    SetLastError(ERROR_FUNCTION_FAILED);
    return (FALSE);

}

///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevAbortOperationA(
    HANDLE              FaxHandle
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    DWORD           waitResult;
    LONG_PTR        i;
    PThrdGlbl       pTG=NULL;
    long            lRet;

    OPEN_DEBUG_FILE(T30_DEBUG_LOG_FILE);
    {
        DEBUG_FUNCTION_NAME(_T("FaxDevAbortOperationA"));

        DebugPrintEx(DEBUG_MSG,"FaxHandle=%x",FaxHandle);

        // find instance data
        //------------------------

        i = (LONG_PTR) FaxHandle;

        if (i < 1   ||  i >= MAX_T30_CONNECT)
        {
            DebugPrintEx(DEBUG_ERR, "got wrong FaxHandle=%d", i);
            CLOSE_DEBUG_FILE;
            return (FALSE);
        }

        if (T30Inst[i].fAvail)
        {
            DebugPrintEx(DEBUG_ERR,"got wrong FaxHandle (marked as free) %d", i);
            return (FALSE);
        }

        pTG = (PThrdGlbl) T30Inst[i].pT30;

        if (pTG->fAbortRequested)
        {
            DebugPrintEx(DEBUG_ERR, "ABORT request had been POSTED already");
            return (FALSE);
        }

        if (pTG->StatusId == FS_NOT_FAX_CALL)
        {
            DebugPrintEx( DEBUG_MSG,"Abort on DATA called");

            if (!itapi_async_setup(pTG))
            {
                DebugPrintEx(DEBUG_ERR,"itapi_async_setup failed");
                return (FALSE);
            }

            lRet = lineDrop(pTG->CallHandle, NULL, 0);

            if (lRet < 0)
            {
                DebugPrintEx(DEBUG_ERR, "lineDrop failed %x", lRet);
                return (FALSE);
            }

            if( !itapi_async_wait(pTG, (DWORD)lRet, (LPDWORD)&lRet, NULL, ASYNC_TIMEOUT))
            {
                DebugPrintEx(DEBUG_ERR, "async_wait lineDrop failed");
                return (FALSE);
            }

            DebugPrintEx( DEBUG_MSG, "finished SUCCESS");
            return (TRUE);
        }

        //
        // real ABORT request.
        //

        DebugPrintEx( DEBUG_MSG,"ABORT requested");

        pTG->fFatalErrorWasSignaled = TRUE;
        if (pTG->fShutdownInProgress)
        {
            // mark as FS_SYSTEM_ABORT to prevent the service from deleting the job.
            SignalStatusChange(pTG, FS_SYSTEM_ABORT);
        }
        else
        {
            SignalStatusChange(pTG, FS_USER_ABORT);
        }

        // set the global abort flag for pTG
        pTG->fAbortRequested = TRUE;

        // set the abort flag for imaging threads
        pTG->ReqTerminate = TRUE;

        PSSLogEntry(PSS_WRN, 0, "User abort");

        // signal manual-reset event to everybody waiting on multiple objects
        if (! SetEvent(pTG->AbortReqEvent) )
        {
            DebugPrintEx(DEBUG_ERR,"SetEvent FAILED le=%lx", GetLastError());
        }

        DebugPrintEx( DEBUG_MSG, "finished SUCCESS");
    }
    CLOSE_DEBUG_FILE;
    return (TRUE);
}


BOOL ReadExtensionConfiguration(PThrdGlbl pTG)
/*++

Routine Description:
    Reads the T30 Configuration Data using the fax configuration
    persistence mechanism and places it in the pTG.
    This currently include only an indication if adaptive answerign was enabled
    by the administrator.

    If the configuration is not found the default configuration is used.
    If another error occurs the function fails.


Arguments:
    pTG

Return Value:
    TRUE if the function succeeded. This means that either the information was read
      or it was not found and defaults were used.

    FALSE for any other error. Use GetLastError() to get extended error information.
--*/

{
    DWORD ec = ERROR_SUCCESS;
    LPT30_EXTENSION_DATA lpExtData = NULL;
    DWORD dwExtDataSize = 0;

    DEBUG_FUNCTION_NAME(_T("ReadExtensionConfiguration"));

    memset(&pTG->ExtData,0,sizeof(T30_EXTENSION_DATA));
    pTG->ExtData.bAdaptiveAnsweringEnabled = FALSE;

    Assert(g_pfFaxGetExtensionData);
    ec = g_pfFaxGetExtensionData(
            pTG->dwPermanentLineID,
            DEV_ID_SRC_TAPI, // TAPI device id
            GUID_T30_EXTENSION_DATA_W,
            (LPBYTE *)&lpExtData,
            &dwExtDataSize);
    if (ERROR_SUCCESS != ec)
    {
        if (ERROR_FILE_NOT_FOUND == ec)
        {
            DebugPrintEx(
                DEBUG_WRN,
                "can't find extension configuration information"
                " for device id : 0x%08X. Using defaults.",
                pTG->dwPermanentLineID);
            //
            // We are going to use the defaults.
            //
            ec = ERROR_SUCCESS;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                "Get extension configuration information"
                " for device id : 0x%08X failed with ec: %ld",
                pTG->dwPermanentLineID,
                ec);
        }
    }
    else
    {
        if (sizeof(T30_EXTENSION_DATA) != dwExtDataSize)
        {
            DebugPrintEx(
                DEBUG_ERR,
                "Extension configuration data size mismatch"
                " for device id: 0x%08X. Expected: %ld - Got: %ld",
                sizeof(T30_EXTENSION_DATA),
                pTG->dwPermanentLineID,
                dwExtDataSize);

            ec = ERROR_BAD_FORMAT;
        }
        else
        {
            memcpy(&pTG->ExtData,lpExtData,sizeof(T30_EXTENSION_DATA));
        }
    }

    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    if (lpExtData)
    {
        Assert(g_pfFaxExtFreeBuffer);
        g_pfFaxExtFreeBuffer(lpExtData);
    }

    return (ERROR_SUCCESS == ec);
}

///////////////////////////////////////////////////////////////////////////////////
#define WAIT_ALL_ABORT_TIMEOUT  20000

HRESULT WINAPI
FaxDevShutdownA()
{
    PThrdGlbl pTG = NULL;
    PThrdGlbl pTGArray[MAX_T30_CONNECT];
    HANDLE HandlesArray[MAX_T30_CONNECT] = {INVALID_HANDLE_VALUE};
    DWORD iCountForceAbortJobs = 0;
    DWORD i = 0;

    OPEN_DEBUG_FILE(T30_DEBUG_LOG_FILE);
    {
        DEBUG_FUNCTION_NAME(_T("FaxDevShutdownA"));

        if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL) )
        {
            DebugPrintEx(   DEBUG_ERR,
                            "SetThreadPriority TIME CRITICAL failed le=%x",
                            GetLastError() );
        }

        EnterCriticalSection(&T30CritSection);

        for (i=1; i<MAX_T30_CONNECT; i++)
        {
            if (!T30Inst[i].fAvail)
            {
                // this is bad.
                // it means someone is shutting down the service when a job
                // is somewhere in the pipe here.
                // first let's post an abort requset
                pTG = (PThrdGlbl)T30Inst[i].pT30;
                pTG->fShutdownInProgress = TRUE;
                if (!FaxDevAbortOperationA(ULongToHandle(i)))
                {
                    DebugPrintEx(DEBUG_WRN,"Posting Abort request failed");
                }
                pTGArray[iCountForceAbortJobs] = pTG;
                HandlesArray[iCountForceAbortJobs] = pTG->AbortAckEvent;
                iCountForceAbortJobs++;
            }
        }

        LeaveCriticalSection(&T30CritSection);

        if (iCountForceAbortJobs)
        {
            DebugPrintEx(   DEBUG_WRN,
                            "We have %d jobs to abort brutally",
                            iCountForceAbortJobs);

            WaitForMultipleObjects(iCountForceAbortJobs,HandlesArray,TRUE,WAIT_ALL_ABORT_TIMEOUT);
            DebugPrintEx( DEBUG_MSG, "Finished waiting");
            // regardless of the return value of WaitForMultipleObjects...
            // there might be some modems off-hook, tapi lines allocated and so on...
            // so, now i'm shutting everything down brutally.
            for (i=0; i<iCountForceAbortJobs; i++)
            {
                pTG = pTGArray[i];
                if (pTG->FComStatus.fModemInit)
                {
                    // this is unfortunate...
                    // it means the abort request wasn't fulfilled
                    // so let's close the modem anyhow to make it
                    // work when the service comes back to life
                    if(!iModemClose(pTG))
                    {
                        DebugPrintEx(DEBUG_ERR,"iModemClose failed!");
                    }
                    DebugPrintEx(DEBUG_MSG,"finished Shutdown of Job %d...",i+1);
                }
            }
        }

        DeleteCriticalSection(&T30CritSection);
        T30CritSectionInit = 0;
        DeleteCriticalSection(&T30RecoveryCritSection);
        T30RecoveryCritSectionInit = 0;
        
        if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL) )
        {
            DebugPrintEx(   DEBUG_ERR,
                            "SetThreadPriority TIME CRITICAL failed le=%x",
                            GetLastError() );
        }
        DebugPrintEx(DEBUG_MSG,"Exit FaxDevShutdownA");
    }
    CLOSE_DEBUG_FILE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\sendfr.c ===
/***************************************************************************
 Name     :     SENDFR.C
 Comment  :
 Functions:     (see Prototypes just below)

        Copyright (c) 1993 Microsoft Corp.

 Revision Log
 Date     Name  Description
 -------- ----- ---------------------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "efaxcb.h"

#include "protocol.h"

///RSL
#include "glbproto.h"

#define FILEID          FILEID_SENDFR

#include "psslog.h"
#define FILE_ID     FILE_ID_SENDFR
#include "pssframe.h"


VOID BCtoNSFCSIDIS(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll)
{
    // Use bigger buf. Avoid truncating Id before stripping alphas
    char    szCSI[MAXTOTALIDLEN + 2];

    //BG_CHK(npbc->bctype==SEND_CAPS);
    //BG_CHK(npbc->wTotalSize >= sizeof(BC));

    ZeroRFS(pTG, npfs);

    // extract ID
    // GetTextId(npbc, szCSI, MAXTOTALIDLEN+1);

    if (pTG->LocalID) 
    {
        strcpy (szCSI, pTG->LocalID);
    }


#ifdef OEMNSF
    CreateOEMFrames(pTG, ifrNSF, OEMNSF_POSBEFORE, npbc, npll, npfs);
#endif

    // RSL no NSF
#if 0
    // Send MS NSFs IFF ECM is enabled
    if (1) /// RSL (pTG->ProtInst.llSendCaps.fECM)
    {
        // Now create MS NSx
        CreateNSForNSCorNSS(pTG, ifrNSF, npfs, npbc, FALSE); // NO id in NSF
    }
    else
    {
        // zap MMR out of our DIS
        npbc->Fax.Encoding &= (~MMR_DATA);
    }
#endif

#ifdef OEMNSF
    CreateOEMFrames(pTG, ifrNSF, OEMNSF_POSAFTER, npbc, npll, npfs);
#endif

    if(_fstrlen(szCSI))
    {
        PSSLogEntry(PSS_MSG, 1, "CSI is \"%s\"", szCSI);
        CreateIDFrame(pTG, ifrCSI, npfs, szCSI, FALSE); // RSL: DON'T strip non-numerics for CSI
    }

    CreateDISorDTC(pTG, ifrDIS, npfs, &npbc->Fax, npll);
}

// NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
VOID BCtoNSCCIGDTC(PThrdGlbl pTG, NPRFS npfs, NPBC npbc, NPLLPARAMS npll)
{
    // Use bigger buf. Avoid truncating Id before stripping alphas
    char    szCIG[MAXTOTALIDLEN + 2];
    BOOL    fSkipDTC;
    BOOL    fSkipCIG;

    BG_CHK(npbc->bctype==SEND_POLLREQ);
    BG_CHK(npbc->wTotalSize >= sizeof(BC));

    ZeroRFS(pTG, npfs);

    fSkipDTC = 0;
    fSkipCIG = 0;

    // extract ID
    GetTextId(npbc, szCIG, MAXTOTALIDLEN+1);

#ifdef OEMNSF
    if(fUsingOEMProt)
    {
        WORD    wFlags;

        BG_CHK(wOEMFlags);
        wFlags = CreateOEMFrames(pTG, ifrNSC, OEMNSF_POSBEFORE, npbc, npll, npfs);

        fSkipDTC = ((wFlags & OEMNSF_DONTSEND_DCS) != 0);
        fSkipCIG = ((wFlags & OEMNSF_DONTSEND_TSI) != 0);
    }
    else
#endif
    {
        if(npbc->wNumPollReq)
        {
            // if we have NSC poll reqs send NSC _with_ our ID. This is reqd
            // for return addressing of response. See bug#6224 and 6675. In
            // this case CIG is redundant so dont send it.
            // NOTE: The real check we want to do is to see if we are polling
            // another AtWork amchine or a G3. This test is just a proxy. The
            // result is a residual bug that G3/blind-polls from IFAX-to-IFAX
            // will NOT be routed correctly, even though they could/should.
            // G3/Blind-polls from IFAX-to-G3 will never be routed correctly
            // so long as we rely on the pollee to do the routing, but IFAX
            // to G3 blind polls wil work if we replace the
            //              if(wNumPollReq)
            // test with a
            //              if(pollee is AtWork)
            //
            CreateNSForNSCorNSS(pTG, ifrNSC, npfs, npbc, TRUE);  // ID in NSC with poll req
            fSkipCIG = TRUE;
        }
        else
        {
            // no NSC poll reqs, so only send our basic NSC
            // (ie. to advert capabilities) if we have ECM
            // Dont send our ID in this case. CIG is good enough
            if(pTG->ProtInst.llSendCaps.fECM)
                    CreateNSForNSCorNSS(pTG, ifrNSC, npfs, npbc, FALSE); // no id in NSC w/o poll req
        }
    }

    if(!pTG->ProtInst.llSendCaps.fECM)
    {
        // zap MMR out of our DTC
        npbc->Fax.Encoding &= (~MMR_DATA);
    }

    if(!fSkipCIG && _fstrlen(szCIG))
        CreateIDFrame(pTG, ifrCIG, npfs, szCIG, TRUE);
    // Strip non-numerics for CIG. Our FULL ID (used for addressing the
    // response) is sent in the NSC if we have NSC poll requests, so the
    // CIG is only for G3 display purposes. Strip alphas to conform
    // to spec & cut it down to size

    if(!fSkipDTC)
        CreateDISorDTC(pTG, ifrDTC, npfs, &npbc->Fax, npll);
}
// end this is never executed

// NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
void CreateNSForNSCorNSS(PThrdGlbl pTG, IFR ifr, NPRFS npfs, NPBC npbc, BOOL fSendID)
{
    WORD    wNumFrames;
    USHORT  uRet;
    int     i;
    // be sure to init these to zero
    WORD    wsz=0, wEnc=0, wLen=0;

    DEBUG_FUNCTION_NAME(_T("CreateNSForNSCorNSS"));
#ifdef DEBUG
    // check BCtype first
    switch(ifr)
    {
      case ifrNSF:  /* RSL BG_CHK(npbc->bctype == SEND_CAPS); */ break;
      case ifrNSS:  BG_CHK(npbc->bctype == SEND_PARAMS); break;
      case ifrNSC:  BG_CHK(npbc->bctype == SEND_POLLREQ); break;
    }
#endif //DEBUG
    // RSL BG_CHK(npbc->wTotalSize >= sizeof(BC));


    if(!fSendID)
    {
        // if we dont want to send the ID, save the ptrs/params of text id
        // and zap it out of the BC struct before calling AWNSF
        // We restore everything before exiting this function
        wsz = npbc->wszTextId;
        wLen = npbc->wTextIdLen;
        wEnc = npbc->wTextEncoding;
        npbc->wszTextId = npbc->wTextIdLen = npbc->wTextEncoding = 0;
    }

    if(uRet = BC_TO_NSX(pTG, ifr, npbc, fsFreePtr(pTG, npfs), (WORD) fsFreeSpace(pTG, npfs), &wNumFrames))
    {
        DebugPrintEx(DEBUG_ERR,"BCtoNSx returned error %d", uRet);
        // go restore pointers if neccesary
        goto done;
    }
    else if(wNumFrames)
    {
        LPLPFR rglpfr = (LPLPFR)fsFreePtr(pTG, npfs);
        LPBYTE lpbLim = (LPBYTE)fsFreePtr(pTG, npfs);

        for(i=0; i<(int)wNumFrames; i++)
        {
            DebugPrintEx(DEBUG_MSG,"Created NSF/NSC, len=%d", rglpfr[i]->cb);
            BG_CHK((LPBYTE)(rglpfr[i]) >= fsStart(pTG, npfs));
            BG_CHK(rglpfr[i]->fif+rglpfr[i]->cb <= fsLim(pTG, npfs));

#ifndef NOCHALL
            if(ifr==ifrNSF && i==0)
            {
                BG_CHK(rglpfr[i]->cb > 3);
                pTG->uSavedChallengeLen = min(rglpfr[i]->cb-3, POLL_CHALLENGE_LEN);
                _fmemcpy(pTG->bSavedChallenge, rglpfr[i]->fif+3, pTG->uSavedChallengeLen);
            }
#endif //!NOCHALL

            if(npfs->uNumFrames < MAXFRAMES)
            {
                npfs->rglpfr[npfs->uNumFrames++] = rglpfr[i];
                lpbLim = max(lpbLim, rglpfr[i]->fif+rglpfr[i]->cb);
            }
            else 
            { 
                BG_CHK(FALSE); 
                break; 
            }
        }
        npfs->uFreeSpaceOff = (USHORT)(lpbLim - ((LPBYTE)(npfs->b)));
        BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);
    }
    else 
    { 
        BG_CHK(FALSE); 
    }

done:
    // restore TextId in BC, if we had zapped it out!
    if(wsz)  
        npbc->wszTextId = wsz;

    if(wLen) 
        npbc->wTextIdLen = wLen;

    if(wEnc) 
        npbc->wTextEncoding = wEnc;
    return;
}
// end this is never executed

void CreateIDFrame(PThrdGlbl pTG, IFR ifr, NPRFS npfs, LPSTR szId, BOOL fStrip)
{

    BYTE szTemp[IDFIFSIZE+2];
    USHORT i, j;
    NPFR    npfr;

    DEBUG_FUNCTION_NAME(("CreateIDFrame"));

    npfr = (NPFR) fsFreePtr(pTG, npfs);
    if( fsFreeSpace(pTG, npfs) <= (sizeof(FRBASE)+IDFIFSIZE) ||
            npfs->uNumFrames >= MAXFRAMES)
    {
        BG_CHK(FALSE);
        return;
    }

    if(fStrip)
    {
        // CreateID strips non-numeric parts. Must send TSI when
        // we do EFAX-to-EFAX in G3 mode. See bug#771

        for(i=0, j=0; szId[i] && j<IDFIFSIZE; i++)
        {
            // copy over all numerics and NON-LEADING blanks
            // throw away all leading blanks
            if( (szId[i] >= '0' && szId[i] <= '9') ||
                    (szId[i] == ' ' && j != 0))
            {
                    szTemp[j++] = szId[i];
            }
            // send + and - as space. At other end, when we get a
            // single leading space convert that to +. Leave other spaces
            // unmolested. This is so that EFAX-to-EFAX in G3 mode
            // with canonical numbers, reply will work correctly
            // see bug#771
            if(szId[i] == '+' || szId[i] == '-')
            {
                    szTemp[j++] = ' ';
            }
        }
        szTemp[j++] = 0;
    }
    else
    {
        _fmemcpy(szTemp, szId, IDFIFSIZE);
        szTemp[IDFIFSIZE] = 0;
    }

    DebugPrintEx(DEBUG_MSG,"Got<%s> Sent<%s>", (LPSTR)szId, (LPSTR)szTemp);

    if(_fstrlen(szTemp))
    {
        CreateStupidReversedFIFs(pTG, npfr->fif, szTemp);

        npfr->ifr = ifr;
        npfr->cb = IDFIFSIZE;
        npfs->rglpfr[npfs->uNumFrames++] = npfr;
        npfs->uFreeSpaceOff += IDFIFSIZE+sizeof(FRBASE);
        BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);
    }
    else
    {
        DebugPrintEx(   DEBUG_WRN,
                        "%s ID is EMPTY. Not sending",
                        (LPSTR)(fStrip ? "STRIPPED" : "ORIGINAL") );
    }
}

void CreateDISorDTC
(
    PThrdGlbl pTG, 
    IFR ifr, 
    NPRFS npfs, 
    NPBCFAX npbcFax, 
    NPLLPARAMS npll
)
{
    USHORT  uLen;
    NPFR    npfr;

    if( fsFreeSpace(pTG, npfs) <= (sizeof(FRBASE)+sizeof(DIS)) ||
            npfs->uNumFrames >= MAXFRAMES)
    {
        BG_CHK(FALSE);
        return;
    }
    npfr = (NPFR) fsFreePtr(pTG, npfs);

    uLen = SetupDISorDCSorDTC(pTG, (NPDIS)npfr->fif, npbcFax, npll, 0, npll->fECM64);
    BG_CHK(uLen >= 3 && uLen <= 8);
    // BG_CHK(npfr->fif[uLen-1] == 0);      // send a final 0 byte

    npfr->ifr = ifr;
    npfr->cb = (BYTE) uLen;
    npfs->rglpfr[npfs->uNumFrames++] = npfr;
    npfs->uFreeSpaceOff += uLen+sizeof(FRBASE);
    BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);
}


VOID CreateNSSTSIDCS(PThrdGlbl pTG, NPPROT npProt, NPRFS npfs, USHORT uWhichDCS)
{
    // uWhichDCS:: 0==1st DCS  1==after NoReply  2==afterFTT

    NPBC    npbc = (NPBC)&(npProt->SendParams);
    BOOL    fEfax;
    // Use bigger buf. Avoid truncating Id before stripping alphas
    char    szTSI[MAXTOTALIDLEN + 2];

    BG_CHK(npProt->fSendParamsInited);
    BG_CHK(npbc->bctype==SEND_PARAMS);
    BG_CHK(npbc->wTotalSize >= sizeof(BC));

    BG_CHK(npProt->fllRecvCapsGot);
    BG_CHK(npProt->fllSendParamsInited);
    BG_CHK(npProt->fHWCapsInited);

/********** moved to the RECVCAPS point. see bug#731 ********************
    if(uWhichDCS==0)                        // don't renegotiate after NoRely or FTT
    {
            NegotiateLowLevelParams(&npProt->llRecvCaps, &npProt->llSendParams,
                    npbc->Fax.AwRes, npbc->Fax.Encoding, &npProt->llNegot);
            npProt->fllNegotiated = TRUE;
            EnforceMaxSpeed(npProt);
    }
*************************************************************************/

    BG_CHK(npProt->fllNegotiated);

    // don't print -- too slow
    // (MyDebugPrint(pTG,  "In CreateNSSTSIDCS after negotiation\r\n"));
    // D_PrintBC(npbc, &npProt->llNegot);

    ZeroRFS(pTG, npfs);

    // Send only TSI-DCS or NSS-DCS. Never a need to send TSI with NSS
    // (can bundle ID into message)

    // extract ID

    // GetTextId(npbc, szTSI, MAXTOTALIDLEN+1);
    if (pTG->LocalID) 
    {
        strcpy (szTSI, pTG->LocalID);
    }


#ifdef OEMNSF
    if(fUsingOEMProt)       // using OEM, not MS At Work NSSs
    {
        WORD wFlags;

        BG_CHK(wOEMFlags);

        wFlags = CreateOEMFrames(pTG, ifrNSS, 0, npbc, &npProt->llNegot, npfs);
        BG_CHK(wFlags);

        if(!(wFlags & OEMNSF_DONTSEND_TSI))
            CreateIDFrame(pTG, ifrTSI, npfs, szTSI, TRUE); //STRIP alphas in TSI

        if(!(wFlags & OEMNSF_DONTSEND_DCS))
            CreateDCS(pTG, npfs, &(npbc->Fax), &npProt->llNegot);
    }
    else
#endif //OEMNSF
    {
        fEfax = (npbc->NSS.vMsgProtocol != 0);

        // RSL no NSF
        if(0)
        {
            // must be TRUE otheriwse we have negotaited ourselves into a corner here
            BG_CHK(npProt->llNegot.fECM);
            CreateNSForNSCorNSS(pTG, ifrNSS, npfs, npbc, FALSE); // no ID in NSS
        }
        else
        {
            // CreateID strips non-numeric parts. Must send TSI when
            // we do EFAX-to-EFAX in G3 mode. See bug#771
            if(_fstrlen(szTSI))
            {
                    PSSLogEntry(PSS_MSG, 1, "TSI is \"%s\"", szTSI);

                    // This is for Snowball, as per bug#771
                    CreateIDFrame(pTG, ifrTSI, npfs, szTSI, FALSE); //RSL: DON'T STRIP alphas in TSI
            }
        }

        CreateDCS(pTG, npfs, &(npbc->Fax), &npProt->llNegot);

        BG_CHK((npbc->NSS.vMsgProtocol == 0) ||
                    (!npbc->Fax.AwRes && !npbc->Fax.Encoding));
    }
}

void CreateDCS(PThrdGlbl pTG, NPRFS npfs, NPBCFAX npbcFax, NPLLPARAMS npll)
{
    USHORT  uLen;
    NPFR    npfr;

    if( fsFreeSpace(pTG, npfs) <= (sizeof(FRBASE)+sizeof(DIS)) ||
            npfs->uNumFrames >= MAXFRAMES)
    {
        BG_CHK(FALSE);
        return;
    }
    npfr = (NPFR) fsFreePtr(pTG, npfs);

    BG_CHK(npbcFax->fPublicPoll==0);
    npbcFax->fPublicPoll = 0;
            // the G3Poll bit *has* to be 0 in DCS
            // else the OMNIFAX G77 and GT croak
            // the PWD/SEP/SUB bits *have* to be 0 in DCS
            // Baud rate, ECM and ECM frame size according to lowlevel negotiation
            // everything else according to high level negotiation

    uLen = SetupDISorDCSorDTC(  pTG, 
                                (NPDIS)npfr->fif, 
                                npbcFax,
                                npll, 
                                npll->fECM, 
                                npll->fECM64);

    BG_CHK(uLen >= 3 && uLen <= 8);
    // BG_CHK(npfr->fif[uLen-1] == 0);      // send a final 0 byte
    // make sure that DCS we send is no longer than the DIS we receive.
    // This should automatically be so
    BG_CHK(pTG->ProtInst.uRemoteDISlen ? (uLen-1 <= pTG->ProtInst.uRemoteDISlen) : TRUE);
    BG_CHK(pTG->ProtInst.uRemoteDTClen ? (uLen-1 <= pTG->ProtInst.uRemoteDTClen) : TRUE);

    // If DCS is longer than the recvd DIS truncate the DCS to the same
    // length as the DIS. (It should never be more than 1byte longer --
    // because of the extra 0).

    if(pTG->ProtInst.uRemoteDISlen && (pTG->ProtInst.uRemoteDISlen < uLen))
            uLen = pTG->ProtInst.uRemoteDISlen;
    else if(pTG->ProtInst.uRemoteDTClen && (pTG->ProtInst.uRemoteDTClen < uLen))
            uLen = pTG->ProtInst.uRemoteDTClen;

    npfr->ifr = ifrDCS;
    npfr->cb = (BYTE) uLen;
    npfs->rglpfr[npfs->uNumFrames++] = npfr;
    npfs->uFreeSpaceOff += uLen+sizeof(FRBASE);
    BG_CHK(npfs->uFreeSpaceOff <= fsSize(pTG, npfs) && npfs->uNumFrames <= MAXFRAMES);

    PSSLogEntry(PSS_MSG, 1, "DCS Composed as follows:");
    LogClass1DCSDetails(pTG, (NPDIS)npfr->fif);
}

#ifdef NSF_TEST_HOOKS

#pragma message("<<WARNING>> INCLUDING NSF TEST HOOKS")

BOOL NSFTestGetNSx (PThrdGlbl pTG, IFR ifr, LPBC lpbcIn,
                      LPBYTE lpbOut, WORD wMaxOut, LPWORD lpwNumFrame)
{
        BOOL fRet=FALSE;
        DWORD_PTR dwKey=ProfileOpen(DEF_BASEKEY, szNSFTEST, fREG_READ);
        char rgchTmp32[32];
        LPSTR lpsz=NULL;
        UINT ucb,ucb0;

        DEBUG_FUNCTION_NAME(_T("NSFTestGetNSx"));

        if (!dwKey) 
            goto end;

        switch(ifr)
        {
          case ifrNSF:  lpsz = "NSF";
                        break;
          case ifrNSS:  lpsz = "NSS";   
                        break;
          case ifrNSC:  lpsz = "NSC";   
                        break;
          default:      BG_CHK(FALSE);          
                        goto end;
        }

        wsprintf(rgchTmp32, "Send%sFrameCount", (LPSTR) lpsz);
        *lpwNumFrame = (WORD) ProfileGetInt(dwKey, rgchTmp32, 0, NULL);

        if(!*lpwNumFrame) 
            goto end;

        // Save space for frame pointer array
        ucb=sizeof(LPFR) * *lpwNumFrame;
        if (wMaxOut <= ucb) 
            goto end;

        wsprintf(rgchTmp32, "Send%sFrames", (LPSTR) lpsz);
        ucb0=ProfileGetData(dwKey, rgchTmp32, lpbOut+ucb, wMaxOut-ucb);
        if (!ucb0) goto end;

#ifdef DEBUG
        {
            char rgchTmp64[64];
            UINT u,v;
            DebugPrintEx(   DEBUG_ERR, 
                            "TEST-NSF: Dump  of %u send frame(s):",
                            (unsigned) *lpwNumFrame);
            rgchTmp64[0]=0;
            for (u=0,v=0;u<ucb0;u++)
            {
              v += wsprintf(rgchTmp64+v, " %02x", (unsigned) lpbOut[ucb+u]);
              if ((v+8) >= sizeof(rgchTmp64))
              {
                    DebugPrintEx(DEBUG_ERR,  "%s", (LPSTR) rgchTmp64);
                    v=0;
                    rgchTmp64[0]=0;
              }
            }
            DebugPrintEx(DEBUG_ERR,"%s", (LPSTR) rgchTmp64);
        }
#endif
        // Initialize frame pointer array
        {
            UINT u;
            UINT ucbtot = ucb+ucb0;
            for (u=0;u<*lpwNumFrame;u++)
            {
                LPFR lpfr = (LPFR) (lpbOut+ucb);
                DebugPrintEx(   DEBUG_ERR, 
                                "NSFTest: u=%lu, ifr=%lu, cb=%lu, ucb=%lu",
                                (unsigned long) u,
                                (unsigned long) lpfr->ifr,
                                (unsigned long) lpfr->cb,
                                (unsigned long) ucb);
                if (lpfr->ifr!=ifr) goto bad_frames;
                if (lpfr->cb>100) // awnsfapi.h says max frame size=70.
                        goto bad_frames;
                if ((ucb+sizeof(FRBASE)+lpfr->cb)>ucbtot)
                        goto bad_frames;

                ((LPFR *)(lpbOut))[u] = lpfr;
                ucb+=sizeof(FRBASE)+lpfr->cb;
            }
        }

        fRet=TRUE;
        goto end;

bad_frames:
        DebugPrintEx(DEBUG_ERR, "TEST-NSF: Bad frames from registry");
        // fall through..

end:
        if (dwKey) ProfileClose(dwKey);

        if (!fRet) 
        {
            DebugPrintEx(DEBUG_WRN,"NSFTestGetNSx FAILS!");
        }

        return fRet;
}

BOOL NSFTestPutNSx
(
    PThrdGlbl pTG, 
    IFR ifr, 
    LPLPFR rglpfr, 
    WORD wNumFrame,
    LPBC lpbcOut, 
    WORD wBCSize
)
{
    BOOL fRet=FALSE;
    DWORD_PTR dwKey=ProfileOpen(DEF_BASEKEY, szNSFTEST, fREG_CREATE|fREG_WRITE);
    char rgchTmp32[32];
    char rgchTmp10[10];
    BYTE rgbTmp256[256];
    LPSTR lpsz=NULL;
    UINT    u;
    UINT ucb=0;

    DEBUG_FUNCTION_NAME(_T("NSFTestPutNSx"));

    if (!dwKey) 
        goto end;

    switch(ifr)
    {
      case ifrNSF:  lpsz = "NSF";   
                    break;
      case ifrNSS:  lpsz = "NSS";   
                    break;
      case ifrNSC:  lpsz = "NSC";       
                    break;
      default:      BG_CHK(FALSE);          
                    goto end;
    }

    // Tack frames together...
    ucb=0;
    for(u=0; u<wNumFrame; u++)
    {
            UINT    uLen = sizeof(FRBASE)+rglpfr[u]->cb;

            if ((ucb+uLen) > sizeof(rgbTmp256))
            {
                DebugPrintEx(DEBUG_WRN,"NSFTEST: Out of space!");
                break;
            }
            _fmemcpy(rgbTmp256+ucb, (LPBYTE)rglpfr[u], uLen);
            ucb+=uLen;
    }

    if(u)
    {
        wsprintf(rgchTmp32, "Recvd%sFrames", (LPSTR) lpsz);
        if (!ProfileWriteData(dwKey, rgchTmp32, rgbTmp256, ucb)) 
            goto end;
    }

    wsprintf(rgchTmp32, "Recvd%sFrameCount", (LPSTR) lpsz);
    wsprintf(rgchTmp10, "%u", (unsigned) (u&0xff));
    if (!ProfileWriteString(dwKey, rgchTmp32, rgchTmp10, FALSE)) 
        goto end;

    fRet=TRUE;

end:
    if (dwKey) ProfileClose(dwKey);

    if (!fRet) 
    {
        DebugPrintEx(DEBUG_ERR,"NSFTestPutNSx FAILS!");
    }

    return fRet;
}

#endif // NSF_TEST_HOOKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\t30main.c ===
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"
#include "oemint.h"
#include "t30.h"
#include "efaxcb.h"
#include "debug.h"
///RSL
#include "glbproto.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_T30MAIN

BOOL T30Cl1Rx(PThrdGlbl pTG)
{
    BOOL           fOpen = 0,                     //CHKCHK - need to assign a value
                   fImmediate = 1;
    USHORT         uLine = 5,                     // LINE_NUM,
                   uModem = 5;                    // MODEM_NUM;
    USHORT         uRet1, uRet2, uFlags;
    HMODEM         hModem;
    HLINE          hLine;
    ET30ACTION     actionInitial = actionNULL;
    BOOL           RetCode = FALSE;

    DEBUG_FUNCTION_NAME(_T("T30Cl1Rx - Answering"));

    PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");

    SignalStatusChange(pTG, FS_ANSWERED);

    // first get SEND_CAPS (before answering)
    if (!ProtGetBC(pTG, SEND_CAPS, TRUE)) // sleep until we get it
    {
            uRet1 = T30_CALLFAIL;
            uRet2 = 0;      // need err value here
            goto done;
    }


    uFlags = NCULINK_RX;
    if (fOpen || fImmediate)
    {
        uFlags |= NCULINK_IMMEDIATE;
        DebugPrintEx(DEBUG_MSG,"IMMEDIATE ANSWER");
    }
    // when MDDI is not defined, hLine==uLine and hModem==uModem
    // when MDDI is defined, if fOpen is TRUE, then also hLine==uLine and hModem==uModem
    hLine = (HLINE)uLine;
    hModem = (HMODEM)uModem;

    PSSLogEntry(PSS_MSG, 1, "Answering...");

    if ((uRet2 = NCULink(pTG, hLine, hModem, 0, uFlags)) != CONNECT_OK)
    {
            uRet1 = T30_ANSWERFAIL;
            goto done;
    }

#ifdef RICOHAI
            fUsingOEMProt = FALSE;
            BG_CHK(RICOHAI_MODE == RICOHAI_ENABLE);
            uRet2 = ModemConnectRx(pTG, hModem, (wOEMFlags & RICOHAI_ENABLE));
            if (uRet2 == CONNECT_ESCAPE)
            {
                    fUsingOEMProt = TRUE;
                    actionInitial = actionGONODE_F;
            }
            else if (uRet2 != CONNECT_OK)
            {
                    uRet1 = T30_ANSWERFAIL;
                    goto done;
            }

#endif //!RICOHAI


    // Protocol Dump
    RestartDump(pTG);

#ifdef IFK
    // Call counter
    IFNvramSetCounterValue(RXCALL_COUNTER, 1, 0,
            (COUNTER_ADDVALUE|COUNTER_TIMESTAMP|PROCESS_CONTEXT));
#endif

    uRet1 = T30MainBody(pTG, FALSE, actionInitial, hLine, hModem);
    BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
    uRet2 = 0;

    // Protocol Dump
    PrintDump(pTG);

done:

    if (uRet1==T30_CALLDONE)
    {
        SignalStatusChange(pTG, FS_COMPLETED);

        RetCode = TRUE;
        DebugPrintEx(DEBUG_MSG,"SUCCESSFUL RECV");
    }
    else if (pTG->StatusId == FS_NOT_FAX_CALL) 
    {
        RetCode = FALSE;
        DebugPrintEx(   DEBUG_ERR,
                        "DATA CALL attempt HANDOVER (0x%04x)",
                        MAKEWORD(uRet1, uRet2));
    }
    else 
    {
        if (!pTG->fFatalErrorWasSignaled) 
        {
            pTG->fFatalErrorWasSignaled = 1;
            SignalStatusChange(pTG, FS_FATAL_ERROR);
        }

        RetCode = FALSE;
        DebugPrintEx(   DEBUG_ERR,
                        "FAILED RECV (0x%04x)",
                        MAKEWORD(uRet1, uRet2));
    }

    ICommStatus(pTG, ((uRet1==T30_CALLDONE) ? T30STATR_SUCCESS : T30STATR_FAIL), 0, 0, 0);

// Dont do this!! The Modem driver queues up commands for later execution, so the
// DCN we just sent is probably in the queue. Doing a sync here causes that send
// to be aborted, so the recvr never gets a DCN and thinks teh recv failed. This
// is bug#6803
    NCULink(pTG, hLine, 0, 0, NCULINK_HANGUP);
    pTG->lEarliestDialTime = GetTickCount() + MIN_CALL_SEPERATION;

    BG_CHK((uRet1 & 0xFF) == uRet1);
    BG_CHK((uRet2 & 0xFF) == uRet2);

    return (RetCode);
}

BOOL T30Cl1Tx(PThrdGlbl pTG,LPSTR szPhone)
{
        BOOL    fOpen = 0;                     //CHKCHK - need to assign a value
        USHORT  uRet1, uRet2;
        ULONG   ulTimeout;
        USHORT         uLine = 5,              // LINE_NUM,
                       uModem = 5;             // MODEM_NUM;
        HLINE   hLine;
        HMODEM  hModem;
        ET30ACTION actionInitial;
        WORD    wFlags;
        BOOL           RetCode = FALSE;

        DEBUG_FUNCTION_NAME(_T("T30Cl1Tx"));
        
        PSSLogEntry(PSS_MSG, 0, "Phase A - Call establishment");

// Ricoh doesnt like this to go over 60secs, so give ourselves some buffer here
#define DIAL_TIMEOUT    58000L

        ulTimeout = DIAL_TIMEOUT;
/**
        if((uLen = _fstrlen(szPhone)) > 7)
                ulTimeout += (((ULONG)(uLen - 7)) << 12);       //mult by 4096
**/

        // when MDDI is not defined, hLine==uLine and hModem==uModem
        // when MDDI is defined, if fOpen is TRUE, then also hLine==uLine and hModem==uModem
        hLine = (HLINE)uLine;
        hModem = (HMODEM)uModem;

        actionInitial = actionNULL;
        wFlags = 0;


        // for non-manual calls only, wait until a min. time has elapsed
        // since the last hangup. Beware of wraparound
        if (!fOpen && szPhone)   //fOpen==on-hook-dial, szPhone=NULL: handset dial
        {
                DWORD   lNow, lSleep;

                lNow = GetTickCount();
                if(lNow < pTG->lEarliestDialTime)
                        lSleep = pTG->lEarliestDialTime-lNow;

                DebugPrintEx(   DEBUG_MSG,
                                "Seperation: Now=%ld Earliest=%ld "
                                "Seperation=%ld Sleep=%ld",
                                lNow, pTG->lEarliestDialTime,
                                (DWORD)(MIN_CALL_SEPERATION), lSleep);

                if (lSleep <= MIN_CALL_SEPERATION)
                        Sleep(lSleep);
        }
        DebugPrintEx(DEBUG_MSG,"Going to change the state to FS_DIALING");

        SignalStatusChange(pTG, FS_DIALING);

        if( pTG->fAbortRequested)
        {
            goto done;
        }

        uRet2 = CONNECT_OK;
        if (szPhone)
        {
            PSSLogEntry(PSS_MSG, 1, "Dialing %s", szPhone);
        
            DebugPrintEx(DEBUG_MSG, "Enter into NCUDial");
            uRet2 = NCUDial(pTG, hLine, szPhone);
            if (uRet2!=CONNECT_OK)
            {
                DebugPrintEx(DEBUG_ERR,"Problem at NCUDial. Jump to done");
                uRet1 = T30_DIALFAIL;
                goto done;
            }
        }

        // Protocol Dump
        RestartDump(pTG); // Reset the offsets

        DebugPrintEx(DEBUG_MSG,"Enter to main body");

        uRet1 = T30MainBody(pTG, TRUE, actionInitial, hLine, hModem);
        BG_CHK(uRet1==T30_CALLDONE || uRet1==T30_CALLFAIL);
        uRet2 = 0;

#ifdef RICOHAI
        RicohAIEnd();
#endif

        // Protocol Dump
        PrintDump(pTG);

done:

        if (uRet1==T30_CALLDONE) 
        {
                SignalStatusChange(pTG, FS_COMPLETED);

                RetCode = TRUE;
                DebugPrintEx(DEBUG_MSG,"SUCCESSFUL SEND");
        }
        else 
        {
            if (!pTG->fFatalErrorWasSignaled) 
            {
                pTG->fFatalErrorWasSignaled = 1;
                SignalStatusChange(pTG, FS_FATAL_ERROR);
            }

                RetCode = FALSE;
                DebugPrintEx(   DEBUG_ERR,
                                "FAILED SEND (0x%04x)",
                                MAKEWORD(uRet1, uRet2));
        }

        ICommStatus(pTG, ((uRet1==T30_CALLDONE) ? T30STATS_SUCCESS : T30STATS_FAIL), 0, 0, 0);

// Dont do this!! The Modem driver queues up commands for later execution, so the
// DCN we just sent is probably in the queue. Doing a sync here causes that send
// to be aborted, so the recvr never gets a DCN and thinks teh recv failed. This
// is bug#6803
        
        DebugPrintEx(DEBUG_MSG,"Calling to NCULink to do NCULINK_HANGUP");
        NCULink(pTG, hLine, 0, 0, NCULINK_HANGUP);
        pTG->lEarliestDialTime = GetTickCount() + MIN_CALL_SEPERATION;

        BG_CHK((uRet1 & 0xFF) == uRet1);
        BG_CHK((uRet2 & 0xFF) == uRet2);
        return (RetCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\timeouts.h ===
#include "fcomapi.h"

#define TstartTimeOut(pTG, lpto, ulTime)             startTimeOut(pTG, lpto, ulTime)
#define TcheckTimeOut(pTG, lpto)                     checkTimeOut(pTG, lpto)

#define WAITFORBUF_TIMEOUT      60000L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\t30util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30util.c

Abstract:

    Utilities for t30

Author:

    Rafael Lisitsa (RafaelL) 2-Feb-1996


Revision History:

--*/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"


#include "glbproto.h"
#include "t30gl.h"

#define IDVARSTRINGSIZE     (sizeof(VARSTRING)+128)
#define BAD_HANDLE(h)       (!(h) || (h)==INVALID_HANDLE_VALUE)


///////////////////////////////////////////////////////////////////////////////////
PVOID
T30AllocThreadGlobalData(VOID)
{
    PVOID   pTG;

    pTG = MemAlloc (sizeof(ThrdGlbl) );
    if(NULL != pTG)
    {
        FillMemory (pTG, sizeof(ThrdGlbl), 0);
    }

    return (pTG);
}

/////////////////////////////////////////////////////////////

BOOL itapi_async_setup(PThrdGlbl pTG)
{
    BOOL bRetVal = TRUE;
    DEBUG_FUNCTION_NAME(_T("itapi_async_setup"));

    EnterCriticalSection(&T30CritSection);

    if (pTG->fWaitingForEvent) 
    {
        DebugPrintEx(DEBUG_ERR,"Already waiting for event!");
    }

    if (pTG->dwSignalledRID) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "Nonzero old NONZERO ID 0x%lx",
                        (unsigned long) pTG->dwSignalledRID);
    }

    pTG->fWaitingForEvent=TRUE;
    if (!ResetEvent(pTG->hevAsync))
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "ResetEvent(0x%lx) returns failure code: %ld",
                        (ULONG_PTR)pTG->hevAsync,
                        (long) GetLastError());

        bRetVal = FALSE;
    }
    LeaveCriticalSection(&T30CritSection);
    return bRetVal;
}

// This function wait till tapi will send message LINE_REPLY.
// dwRequestID - The request we want to get reply for

BOOL itapi_async_wait
(
    PThrdGlbl pTG,
  DWORD dwRequestID,
  PDWORD lpdwParam2,
  PDWORD_PTR lpdwParam3,
  DWORD dwTimeout
)
{

    DWORD                 NumHandles=2;
    HANDLE                HandlesArray[2];
    DWORD                 WaitResult;

    DEBUG_FUNCTION_NAME(("itapi_async_wait"));

    if (!pTG->fWaitingForEvent) 
    {
        DebugPrintEx(DEBUG_ERR,"Not waiting for event!");
        // ASSERT(FALSE);
        // There are always time-outs that will take us out of here
    }

    HandlesArray[1] = pTG->AbortReqEvent;
    //
    // We want to be able to un-block ONCE only from waiting on I/O when the AbortReqEvent is signaled.
    //
    if (pTG->fAbortRequested) 
    {
        if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
        {
            DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
            pTG->fAbortReqEventWasReset = TRUE;
            if (!ResetEvent(pTG->AbortReqEvent))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "ResetEvent(0x%lx) returns failure code: %ld",
                                (ULONG_PTR)pTG->AbortReqEvent,
                                (long) GetLastError());

            }
        }

        pTG->fUnblockIO = TRUE;
    }

    HandlesArray[0] = pTG->hevAsync;

    NumHandles = 1;

    WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, dwTimeout);

    if (WaitResult == WAIT_FAILED) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "WaitForMultipleObjects FAILED le=%lx",
                        GetLastError());
    }

    switch( WaitResult ) 
    {
        case (WAIT_OBJECT_0):  
                            {
                            // This happen when TAPI send LINE_REPLY. (The working thread call itapi_async_signal)
                            BOOL fRet=TRUE;

                            EnterCriticalSection(&T30CritSection);
                            // Check that the Request ID we got is the ID we are waiting for
                            if(pTG->dwSignalledRID == dwRequestID) 
                            {
                                 pTG->dwSignalledRID = 0;
                                 pTG->fWaitingForEvent = FALSE;
                            }
                            else 
                            {
                                 DebugPrintEx(  DEBUG_ERR, 
                                                "Request ID mismatch. Input:0x%p; Curent:0x%p",
                                                 dwRequestID,
                                                 pTG->dwSignalledRID);
                                 fRet=FALSE;
                            }

                            LeaveCriticalSection(&T30CritSection);

                            if (!fRet)
                                goto failure;
                        }
                        break;
        case WAIT_TIMEOUT:
                        DebugPrintEx(   DEBUG_ERR, 
                                        "Wait timed out. RequestID=0x%p",
                                        dwRequestID);
                        goto failure;
        default:
                        DebugPrintEx(   DEBUG_ERR, 
                                        "Wait returns error. GetLastError=%ld",
                                        (long) GetLastError());
                        goto failure;
        }


        if (lpdwParam2)
            *lpdwParam2 = pTG->dwSignalledParam2;

        if (lpdwParam3)
            *lpdwParam3 = pTG->dwSignalledParam3;

        return TRUE;



failure:
    EnterCriticalSection(&T30CritSection);

    if(pTG->dwSignalledRID==dwRequestID) 
    {
        pTG->dwSignalledRID=0;
        pTG->fWaitingForEvent=FALSE;
    }

    LeaveCriticalSection(&T30CritSection);

    return FALSE;
}


BOOL itapi_async_signal
(
    PThrdGlbl pTG,
    DWORD dwRequestID,
    DWORD dwParam2,
    DWORD_PTR dwParam3
)
{
    BOOL fRet=FALSE;

    DEBUG_FUNCTION_NAME(_T("itapi_async_signal"));

    EnterCriticalSection(&T30CritSection);

    if (!pTG->fWaitingForEvent) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "Not waiting for event, ignoring ID=0x%lx",
                        (unsigned long) dwRequestID);
        goto end;
    }

    if (pTG->dwSignalledRID) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "Nonzero old NONZERO ID 0x%lx. New ID=0x%lx",
                        (unsigned long) pTG->dwSignalledRID,
                        (unsigned long) dwRequestID);
    }

    pTG->dwSignalledRID=dwRequestID;
    pTG->dwSignalledParam2= 0;
    pTG->dwSignalledParam3= 0;

    if (!SetEvent(pTG->hevAsync)) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "SetEvent(0x%lx) returns failure code: %ld",
                        (ULONG_PTR) pTG->hevAsync,
                        (long) GetLastError());
        fRet=FALSE;
        goto end;
    }

    pTG->dwSignalledParam2= dwParam2;
    pTG->dwSignalledParam3= dwParam3;

    fRet=TRUE;
end:
    LeaveCriticalSection(&T30CritSection);
    return fRet;
}


#define CALLPARAMS_SIZE (sizeof(LINECALLPARAMS)+512)


LPLINECALLPARAMS itapi_create_linecallparams(void)
{
     UINT cb = CALLPARAMS_SIZE;
     LPLINECALLPARAMS lpParams = MemAlloc(cb);

     if (!lpParams)
          goto end;

     _fmemset(lpParams,0, cb);
     lpParams->dwTotalSize= cb;

    lpParams->dwBearerMode = LINEBEARERMODE_PASSTHROUGH;
    lpParams->dwMediaMode = LINEMEDIAMODE_DATAMODEM; // Unimodem only accepts


    lpParams->dwCallParamFlags = 0;
    lpParams->dwAddressMode = LINEADDRESSMODE_ADDRESSID;
    lpParams->dwAddressID = 0; // +++ assumes addreddid 0.
    lpParams->dwCalledPartySize = 0; // +++
    lpParams->dwCalledPartyOffset = 0; // +++

end:
    return lpParams;
}

BOOL
SignalStatusChange
(
    PThrdGlbl   pTG,
    DWORD       StatusId
)
{

    FAX_DEV_STATUS  *pFaxStatus = NULL;
    LPWSTR          lpwCSI;       // inside the FaxStatus struct.
    LPBYTE          lpTemp;
    LPWSTR          lpwCallerId = NULL;

    DEBUG_FUNCTION_NAME(_T("SignalStatusChange"));
    //
    // If Aborting OR completed then do NOT override the statusId
    //

    if ( (pTG->StatusId == FS_USER_ABORT) || 
         (pTG->StatusId == FS_COMPLETED)  ||
         (pTG->StatusId == FS_SYSTEM_ABORT) ) 
    {
        // allow changing the status from FS_****_ABORT to FS_COMPLETED only
        if (StatusId!=FS_COMPLETED)
        {
            return (TRUE);
        }
    }

    pTG->StatusId = StatusId;

    // should use HeapAlloc because FaxSvc frees it.
    pFaxStatus = HeapAlloc(gT30.HeapHandle , HEAP_ZERO_MEMORY,  sizeof(FAX_DEV_STATUS) + 4096 );

    if (!pFaxStatus) 
    {
        DebugPrintEx(DEBUG_ERR, "SignalStatusChange HeapAlloc failed");
        goto failure;
    }

    pFaxStatus->SizeOfStruct = sizeof (FAX_DEV_STATUS);
    pFaxStatus->StatusId = pTG->StatusId;
    pFaxStatus->StringId = pTG->StringId;

    if (pTG->StatusId == FS_RECEIVING) 
    {
        pFaxStatus->PageCount = pTG->PageCount + 1;
    }
    else 
    {
        pFaxStatus->PageCount = pTG->PageCount;
    }

    lpTemp = (LPBYTE) pFaxStatus;
    lpTemp += sizeof(FAX_DEV_STATUS);

    if (pTG->fRemoteIdAvail)
    {
        lpwCSI = (LPWSTR) lpTemp;
        wcscpy(lpwCSI, pTG->RemoteID);
        pFaxStatus->CSI = (LPWSTR) lpwCSI;
        lpTemp += ((wcslen(pFaxStatus->CSI)+1)*sizeof(WCHAR));
    }
    else
    {
        pFaxStatus->CSI         = NULL;
    }

    pFaxStatus->CallerId = (LPWSTR) lpTemp;
    lpwCallerId = (LPWSTR) AnsiStringToUnicodeString(pTG->CallerId);
    if (lpwCallerId)
    {
        wcscpy(pFaxStatus->CallerId, lpwCallerId);
        MemFree(lpwCallerId);
    }
    else
    {
        pFaxStatus->CallerId = NULL;
    }

    // do we want to put something here? currently there's no support for Routing Info.
    pFaxStatus->RoutingInfo = NULL;


    if (! PostQueuedCompletionStatus(pTG->CompletionPortHandle,
                                     sizeof (FAX_DEV_STATUS),
                                     pTG->CompletionKey,
                                     (LPOVERLAPPED) pFaxStatus) )  
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "PostQueuedCompletionStatus failed LE=%x",
                        GetLastError());
        goto failure;
    }

    DebugPrintEx(   DEBUG_MSG,
                    "ID=%x Page=%d", 
                    pTG->StatusId, 
                    pTG->PageCount);

    return (TRUE);

failure:

    if (pFaxStatus)
    {
        HeapFree(gT30.HeapHandle,0,pFaxStatus);
    }
    return (FALSE);
}





BOOL
SignalRecoveryStatusChange
(
    T30_RECOVERY_GLOB       *Recovery
)
{

    FAX_DEV_STATUS  *pFaxStatus = NULL;


    // should use HeapAlloc because FaxSvc frees it.
    pFaxStatus = HeapAlloc(gT30.HeapHandle , HEAP_ZERO_MEMORY,  sizeof(FAX_DEV_STATUS) + 4096 );

    if (!pFaxStatus) 
    {
        goto failure;
    }

    pFaxStatus->SizeOfStruct = sizeof (FAX_DEV_STATUS) + 4096;
    pFaxStatus->StatusId = FS_FATAL_ERROR;   // RSL better: FS_FSP_EXCEPTION_HANDLED;
    pFaxStatus->StringId = 0;

    pFaxStatus->PageCount = 0;

    pFaxStatus->CSI         = NULL;

    pFaxStatus->CallerId = NULL;
    pFaxStatus->RoutingInfo = NULL;


    if (! PostQueuedCompletionStatus(Recovery->CompletionPortHandle,
                                     sizeof (FAX_DEV_STATUS),
                                     Recovery->CompletionKey,
                                     (LPOVERLAPPED) pFaxStatus) )  
    {
        goto failure;
    }

    return (TRUE);

failure:

    if (pFaxStatus)
    {
        HeapFree(gT30.HeapHandle,0,pFaxStatus);
    }
    return (FALSE);
}



DWORD
ComputeCheckSum
(
    LPDWORD     BaseAddr,
    DWORD       NumDwords
)
{
    DWORD   RetValue = 0;
    DWORD   i;

    for (i=0; i<NumDwords; i++) 
    {
        RetValue += *(BaseAddr+i);
    }

    return (RetValue);
}



static LPCTSTR sgActionDescriptionTable[actionNUM_ACTIONS] = 
{
    "actionNULL",
    "actionFALSE",      
    "actionTRUE",
    "actionERROR",
    "actionHANGUP",
    "actionDCN",
    "actionGONODE_T",
    "actionGONODE_R1",
    "actionGONODE_R2",
    "actionGONODE_A",       
    "actionGONODE_D",       
    "actionGONODE_E",
    "actionGONODE_F",
    "actionGONODE_I",       
    "actionGONODE_II",  
    "actionGONODE_III",
    "actionGONODE_IV",  
    "actionGONODE_V",       
    "actionGONODE_VII",
    "actionGONODE_RECVCMD",
    "actionGONODE_ECMRETRANSMIT",
    "actionGONODE_RECVPHASEC",
    "actionGONODE_RECVECMRETRANSMIT",
    "actionSEND_DIS",       
    "actionSEND_DTC",       
    "actionSEND_DCS",
    "actionSENDMPS",        
    "actionSENDEOM",        
    "actionSENDEOP",
    "actionSENDMCF",        
    "actionSENDRTP",        
    "actionSENDRTN",
    "actionSENDFTT",        
    "actionSENDCFR",        
    "actionSENDEOR_EOP",
    "actionGETTCF",     
    "actionSKIPTCF",    
    "actionSENDDCSTCF", 
    "actionDCN_SUCCESS",    
    "actionNODEF_SUCCESS",
    "actionHANGUP_SUCCESS",
#ifdef PRI
    "actionGONODE_RECVPRIQ",
    "actionGOVOICE",
    "actionSENDPIP",
    "actionSENDPIN",
#endif
#ifdef IFP
    "actionGONODE_IFP_SEND",    
    "actionGONODE_IFP_RECV",
#endif
};

LPCTSTR action_GetActionDescription(ET30ACTION action)
{
    Assert(action<actionNUM_ACTIONS);
    if (action>=actionNUM_ACTIONS)
        return NULL;

    return sgActionDescriptionTable[action];
}

static LPCTSTR sgEventDescriptionTable[eventNUM_EVENTS] = 
{
    "eventNULL",
    "eventGOTFRAMES",
    "eventNODE_A",
    "eventSENDDCS",
    "eventGOTFTT",
    "eventGOTCFR",
    "eventSTARTSEND",
    "eventPOSTPAGE",
    "eventGOTPOSTPAGERESP",
    "eventGOT_ECM_PPS_RESP",
    "eventSENDDIS",
    "eventSENDDTC",
    "eventRECVCMD",
    "eventGOTTCF",
    "eventSTARTRECV",
    "eventRECVPOSTPAGECMD",
    "eventECM_POSTPAGE",
    "event4THPPR",
    "eventNODE_T",
    "eventNODE_R",
#ifdef PRI
    "eventGOTPINPIP",
    "eventVOICELINE",
    "eventQUERYLOCALINT",
#endif

};

LPCTSTR event_GetEventDescription(ET30EVENT event)
{
    Assert(event<eventNUM_EVENTS);
    if (event>=eventNUM_EVENTS)
        return NULL;

    return sgEventDescriptionTable[event];
}

static LPCTSTR sgIfrDescriptionTable[] = 
{
    "ifrNULL",
    "ifrDIS",
    "ifrCSI",
    "ifrNSF",
    "ifrDTC",
    "ifrCIG",
    "ifrNSC",
    "ifrDCS",
    "ifrTSI",
    "ifrNSS",
    "ifrCFR",
    "ifrFTT",
    "ifrMPS",
    "ifrEOM",
    "ifrEOP",
    "ifrPWD",
    "ifrSEP",
    "ifrSUB",
    "ifrMCF",
    "ifrRTP",
    "ifrRTN",
    "ifrPIP",
    "ifrPIN",
    "ifrDCN",
    "ifrCRP",
    "ifrPRI_MPS",
    "ifrPRI_EOM",
    "ifrPRI_EOP",
    "ifrCTC",
    "ifrCTR",
    "ifrRR",
    "ifrPPR",
    "ifrRNR",
    "ifrERR",
    "ifrPPS_NULL",
    "ifrPPS_MPS",
    "ifrPPS_EOM",
    "ifrPPS_EOP",
    "ifrPPS_PRI_MPS",
    "ifrPPS_PRI_EOM",
    "ifrPPS_PRI_EOP",
    "ifrEOR_NULL",
    "ifrEOR_MPS",
    "ifrEOR_EOM",
    "ifrEOR_EOP",
    "ifrEOR_PRI_MPS",
    "ifrEOR_PRI_EOM",
    "ifrEOR_PRI_EOP",
    "ifrMAX",
    "ifrBAD",
    "ifrTIMEOUT",
};

static const int ifrNUM_IFR = sizeof(sgIfrDescriptionTable)/sizeof(sgIfrDescriptionTable[0]);

LPCTSTR ifr_GetIfrDescription(BYTE ifr)
{
    Assert(ifr<=ifrNUM_IFR);
    if (ifr>ifrNUM_IFR)
        return NULL;

    return sgIfrDescriptionTable[ifr];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\tx_thrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    tx_thrd.c

Abstract:

    This module implements MMR->MR and MMR->MH conversion in a separate thread.

Author:

    Rafael Lisitsa (RafaelL) 14-Aug-1996

Revision History:

--*/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"

#include "efaxcb.h"
#include "t30.h"
#include "hdlc.h"
#include "debug.h"

#include "tiff.h"

#include "glbproto.h"
#include "t30gl.h"

// 10 min.
#define WAIT_FOR_NEXT_STRIP_TX_TIMEOUT      600000


DWORD
TiffConvertThreadSafe
(
    PThrdGlbl   pTG
)
{
    DWORD   RetCode;


    if (glT30Safe) 
    {

        __try 
        {
            RetCode = TiffConvertThread(pTG);
        } 
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
            //
            // Signal to the Main T.30 Thread that we crashed
            //
            return (FALSE);
        }
    }
    else  
    {
        RetCode = TiffConvertThread(pTG);
    }

    return (RetCode);
}


DWORD
TiffConvertThread
(
    PThrdGlbl   pTG
)
{
    DWORD                  tiffCompression = pTG->TiffConvertThreadParams.tiffCompression;
    BOOL                   NegotHiRes = pTG->TiffConvertThreadParams.HiRes;
    BOOL                   SrcHiRes = pTG->SrcHiRes;
    char                   OutFileName[_MAX_FNAME];
    HANDLE                 OutFileHandle;
    DWORD                 *lpdwOutputBuffer;
    DWORD                  dwBytesWritten;
    DWORD                  dwSizeOutputBuffer = 500000;
    DWORD                  dwUsedSizeOutputBuffer;
    DWORD                  MaxNeedOutSize;
    DWORD                  StripDataSize;
    DWORD                  NumHandles=2;
    HANDLE                 HandlesArray[2];
    DWORD                  WaitResult;
    DWORD                  RetCode = FALSE;
    BOOL                   fOutFileNeedsBeClosed = 0;
    BOOL                   fOutBufferNeedsBeFreed = 0;

    DEBUG_FUNCTION_NAME(_T("TiffConvertThread"));

    HandlesArray[0] = pTG->AbortReqEvent;
    HandlesArray[1] = pTG->ThrdSignal;

    lpdwOutputBuffer = (DWORD *) VirtualAlloc(
        NULL,
        dwSizeOutputBuffer,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (! lpdwOutputBuffer) 
    {
        DebugPrintEx(DEBUG_ERR, "lpdwOutputBuffer can't VirtualAlloc");
        SignalHelperError(pTG);
        goto l_exit;
    }

    fOutBufferNeedsBeFreed = 1;

    //
    // Set the appropriate PRTY for this thread
    // I/O threads run at 15. TIFF - at 9...11
    //

    DebugPrintEx(   DEBUG_MSG,
                    "NegotHiRes=%d SrcHiRes=%d Started",
                    NegotHiRes, 
                    SrcHiRes);

    if (! SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ) 
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "SetThreadPriority HIGHEST failed le=%x", 
                        GetLastError() );
        SignalHelperError(pTG);
        goto l_exit;
    }

    // need test below to make sure that pTG is still valid
    if (pTG->ReqTerminate) 
    {
        goto l_exit;
    }

    //
    // TIFF file was already opened in FaxDevSendA
    // in order to get the YResolution tag to negotiate resolution.
    //
    pTG->CurrentOut = 1;

    //
    //  loop thru all pages
    //

    do 
    {
        pTG->fTiffPageDone = 0;

        _fmemcpy (OutFileName, gT30.TmpDirectory, gT30.dwLengthTmpDirectory);
        _fmemcpy (&OutFileName[gT30.dwLengthTmpDirectory], pTG->TiffConvertThreadParams.lpszLineID, 8);
        sprintf( &OutFileName[gT30.dwLengthTmpDirectory+8], ".%03d",  pTG->CurrentOut);

        if ( ( OutFileHandle = CreateFileA( OutFileName, 
                                            GENERIC_WRITE, 
                                            FILE_SHARE_READ,
                                            NULL, 
                                            CREATE_ALWAYS, 
                                            0, 
                                            NULL) ) == INVALID_HANDLE_VALUE ) 
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "ec: %lx  CREATING file %s",
                            GetLastError(), 
                            OutFileName);
            SignalHelperError(pTG);
            goto l_exit;
        }

        fOutFileNeedsBeClosed = 1;

        DebugPrintEx(   DEBUG_MSG,
                        "Page %d started",
                        pTG->CurrentOut);

        if (! TiffSeekToPage( pTG->Inst.hfile, pTG->CurrentOut, FILLORDER_LSB2MSB ) ) 
        {
            DebugPrintEx(DEBUG_ERR, "seeking to page");
            SignalHelperError(pTG);
            goto l_exit;
        }
        else 
        {
            DebugPrintEx(DEBUG_MSG, "TIFF_TX: Tiff seeking to page -OK");
        }

        __try 
        {

            //
            // check the current page dimensions. Add memory if needed.
            //

            TiffGetCurrentPageData(  pTG->Inst.hfile,
                                     NULL,
                                     &StripDataSize,
                                     NULL,
                                     NULL
                                     );

            if (StripDataSize > 1500000) 
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "Tiff CONVERTING %d page StripSize = %d", 
                                pTG->CurrentOut, 
                                StripDataSize);
                SignalHelperError(pTG);
                goto l_exit;
            }

            if (tiffCompression == TIFF_COMPRESSION_MR) 
            {
                MaxNeedOutSize = StripDataSize * 3 / 2;
            }
            else 
            {
                MaxNeedOutSize = StripDataSize * 2;
            }

            if (MaxNeedOutSize > dwSizeOutputBuffer) 
            {
                if (MaxNeedOutSize > 1000000) 
                {
                    dwSizeOutputBuffer = 1500000;
                }
                else 
                {
                    dwSizeOutputBuffer = 1000000;
                }

                VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);

                lpdwOutputBuffer = (DWORD *) VirtualAlloc(
                    NULL,
                    dwSizeOutputBuffer,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

                if (! lpdwOutputBuffer) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "lpdwOutputBuffer can't VirtualAlloc %d", 
                                    dwSizeOutputBuffer);
                    SignalHelperError(pTG);
                    goto l_exit;
                }

                fOutBufferNeedsBeFreed = 1;
            }

            dwUsedSizeOutputBuffer = dwSizeOutputBuffer;

            if (tiffCompression == TIFF_COMPRESSION_MR) 
            {
                if (NegotHiRes == SrcHiRes) 
                {
                    if (! ConvMmrPageToMrSameRes (  pTG->Inst.hfile,
                                                    lpdwOutputBuffer,
                                                    &dwUsedSizeOutputBuffer,
                                                    NegotHiRes) ) 
                    {
                        DebugPrintEx(   DEBUG_ERR, 
                                        "CONVERTING %d page",
                                        pTG->CurrentOut);
                        SignalHelperError(pTG);
                        goto l_exit;
                    }
                }
                else 
                {
                    if (! ConvMmrPageHiResToMrLoRes ( pTG->Inst.hfile,
                                                    lpdwOutputBuffer,
                                                    &dwUsedSizeOutputBuffer) ) 
                    {
                        DebugPrintEx(   DEBUG_ERR, 
                                        "CONVERTING %d page", 
                                        pTG->CurrentOut);
                        SignalHelperError(pTG);
                        goto l_exit;
                    }
                }
            }
            else 
            {
                if (! ConvMmrPageToMh ( pTG->Inst.hfile,
                                                lpdwOutputBuffer,
                                                &dwUsedSizeOutputBuffer,
                                                NegotHiRes,
                                                SrcHiRes) ) 
                {
                    DebugPrintEx(   DEBUG_ERR, 
                                    "CONVERTING %d page", 
                                    pTG->CurrentOut);
                    SignalHelperError(pTG);
                    goto l_exit;
                }
            }

        }
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
            //
            // Signal to the Main T.30 Thread that we crashed
            //

            if (fOutBufferNeedsBeFreed) 
            {
                VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);
            }

            CloseHandle(OutFileHandle);

            return (FALSE);
        }


        if ( ( ! WriteFile(OutFileHandle, (BYTE *) lpdwOutputBuffer, dwUsedSizeOutputBuffer, &dwBytesWritten, NULL) ) ||
             (dwUsedSizeOutputBuffer != dwBytesWritten ) )  
        {
            DebugPrintEx(DEBUG_ERR, "Tiff writing file %s", OutFileName);
            SignalHelperError(pTG);
            goto l_exit;
        }

        if ( ! CloseHandle(OutFileHandle) ) 
        {
            fOutFileNeedsBeClosed = 0;
            DebugPrintEx(DEBUG_ERR, "Tiff closing file %s", OutFileName);
            SignalHelperError(pTG);
            goto l_exit;
        }

        fOutFileNeedsBeClosed = 0;

        pTG->fTiffPageDone = 1;

        if (!SetEvent(pTG->FirstPageReadyTxSignal))
        {
            DebugPrintEx(   DEBUG_ERR, 
                            "SetEvent(0x%lx) returns failure code: %ld",
                            (ULONG_PTR)pTG->FirstPageReadyTxSignal,
                            (long) GetLastError());
            RetCode = FALSE;
            goto l_exit;
        }

        DebugPrintEx(   DEBUG_MSG,
                        "Done page %d size=%d", 
                        pTG->CurrentOut, 
                        dwUsedSizeOutputBuffer);

        if (!pTG->FirstOut) 
        {
            pTG->FirstOut = 1;
        }

        pTG->LastOut++;

        //
        // check to see if we are done
        //
        if (pTG->LastOut >= pTG->TiffInfo.PageCount) 
        {
            DebugPrintEx(   DEBUG_MSG, 
                            "Done whole document Last page %d size=%d", 
                            pTG->CurrentOut, 
                            dwUsedSizeOutputBuffer);
            pTG->fTiffDocumentDone = 1;

            goto good_exit;
        }

        //
        // we want to maintain 2 pages ahead
        //

        if (pTG->LastOut - pTG->CurrentIn >= 2) 
        {
            WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_TX_TIMEOUT);

            if (WaitResult == WAIT_TIMEOUT) 
            {
                DebugPrintEx(DEBUG_ERR, "WaitForMultipleObjects TIMEOUT");
                goto l_exit;
            }

            if (WaitResult == WAIT_FAILED) 
            {
                DebugPrintEx(   DEBUG_ERR,
                                "WaitForMultipleObjects FAILED le=%lx",
                                GetLastError());
            }

            if (pTG->ReqTerminate) 
            {
                DebugPrintEx(DEBUG_MSG,"Received TERMINATE request");
                goto good_exit;
            }
            else if (pTG->ReqStartNewPage)  
            {
                DebugPrintEx(DEBUG_MSG,"Received START NEW PAGE request");
                pTG->AckStartNewPage = 1;
                pTG->ReqStartNewPage = 0;
            }
            else 
            {
                DebugPrintEx(DEBUG_ERR,"Received WRONG request");
                WaitResult = WaitForMultipleObjects(NumHandles, HandlesArray, FALSE, WAIT_FOR_NEXT_STRIP_TX_TIMEOUT);

                if (WaitResult == WAIT_TIMEOUT) 
                {
                    DebugPrintEx(DEBUG_ERR,"WaitForMultipleObjects TIMEOUT");
                    goto l_exit;
                }

                if (WaitResult == WAIT_FAILED) 
                {
                    DebugPrintEx(   DEBUG_ERR,
                                    "WaitForMultipleObjects FAILED le=%lx",
                                    GetLastError());
                }
            }
        }

        pTG->CurrentOut++;
        DebugPrintEx(DEBUG_MSG,"Start page %d", pTG->CurrentOut);

    } 
    while (1);

good_exit:
    if (pTG->fTiffOpenOrCreated) 
    {
        TiffClose( pTG->Inst.hfile);
        pTG->fTiffOpenOrCreated = 0;
    }

    RetCode = TRUE;


l_exit:

    if (fOutFileNeedsBeClosed) 
    {
        CloseHandle(OutFileHandle);
    }

    if (fOutBufferNeedsBeFreed) 
    {
        VirtualFree(lpdwOutputBuffer, 0 , MEM_RELEASE);
    }

    pTG->AckTerminate = 1;
    pTG->fOkToResetAbortReqEvent = 1;

    if (!SetEvent(pTG->ThrdAckTerminateSignal))
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "SetEvent(0x%lx) returns failure code: %ld",
                        (ULONG_PTR)pTG->ThrdAckTerminateSignal,
                        (long) GetLastError());
        RetCode = FALSE;
    }
    if (!SetEvent(pTG->FirstPageReadyTxSignal))
    {
        DebugPrintEx(   DEBUG_ERR, 
                        "SetEvent(0x%lx) returns failure code: %ld",
                        (ULONG_PTR)pTG->FirstPageReadyTxSignal,
                        (long) GetLastError());
        RetCode = FALSE;
    }

    DebugPrintEx(DEBUG_MSG,"EXITs");
    return (RetCode);
}

VOID
SignalHelperError
(
    PThrdGlbl   pTG
)
{
    pTG->ThreadFatalError = 1;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\t30u.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    t30u.c

Abstract:

    This is the interface with T.30 DLL

Author:

    Rafael Lisitsa (RafaelL) 2-Feb-1996


Revision History:

--*/


#define UNICODE
#define _UNICODE


#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"


#include "tiff.h"

#include "glbproto.h"

#include "t30gl.h"



///////////////////////////////////////////////////////////////////////////////////
VOID  CALLBACK
T30LineCallBackFunction(
    HANDLE              hFax,
    DWORD               hDevice,
    DWORD               dwMessage,
    DWORD_PTR           dwInstance,
    DWORD_PTR           dwParam1,
    DWORD_PTR           dwParam2,
    DWORD_PTR           dwParam3
    )

{

T30LineCallBackFunctionA(
    hFax,
    hDevice,
    dwMessage,
    dwInstance,
    dwParam1,
    dwParam2,
    dwParam3
    );


} /* LineCallBackProc */











///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevInitialize(
    IN  HLINEAPP                  LineAppHandle,
    IN  HANDLE                    HeapHandle,
    OUT PFAX_LINECALLBACK        *LineCallbackFunction,
    IN  PFAX_SERVICE_CALLBACK     FaxServiceCallback
    )
{


return(
FaxDevInitializeA(
    LineAppHandle,
    HeapHandle,
    LineCallbackFunction,
    FaxServiceCallback
    ));

}



///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevStartJob(
    HLINE           LineHandle,
    DWORD           DeviceId,
    PHANDLE         pFaxHandle,
    HANDLE          CompletionPortHandle,
    ULONG_PTR        CompletionKey
    )

{

return(
FaxDevStartJobA(
    LineHandle,
    DeviceId,
    pFaxHandle,
    CompletionPortHandle,
    CompletionKey
    ));



}




///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevEndJob(
    HANDLE          FaxHandle
    )

{

return(
FaxDevEndJobA(
    FaxHandle
    ));


}




///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevSend(
    IN  HANDLE FaxHandle,
    IN  PFAX_SEND FaxSend,
    IN  PFAX_SEND_CALLBACK FaxSendCallback
    )

{


    FAX_SEND_A      NewFaxSend;

    NewFaxSend.SizeOfStruct = FaxSend->SizeOfStruct;
    NewFaxSend.FileName = UnicodeStringToAnsiString (FaxSend->FileName);
    NewFaxSend.CallerName = UnicodeStringToAnsiString (FaxSend->CallerName);
    NewFaxSend.CallerNumber = UnicodeStringToAnsiString (FaxSend->CallerNumber);
    NewFaxSend.ReceiverName = UnicodeStringToAnsiString (FaxSend->ReceiverName);
    NewFaxSend.ReceiverNumber = UnicodeStringToAnsiString (FaxSend->ReceiverNumber);




return(
FaxDevSendA(
    FaxHandle,
    &NewFaxSend,
    FaxSendCallback
    ));


}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReceive(
    HANDLE              FaxHandle,
    HCALL               CallHandle,
    PFAX_RECEIVE        FaxReceive
    )


{


    FAX_RECEIVE_A       NewFaxReceive;


    NewFaxReceive.SizeOfStruct = FaxReceive->SizeOfStruct;
    NewFaxReceive.FileName = UnicodeStringToAnsiString(FaxReceive->FileName);
    NewFaxReceive.ReceiverName = UnicodeStringToAnsiString(FaxReceive->ReceiverName);
    NewFaxReceive.ReceiverNumber = UnicodeStringToAnsiString(FaxReceive->ReceiverNumber);



    return(
        FaxDevReceiveA(
            FaxHandle,
            CallHandle,
            &NewFaxReceive
            ));


}


///////////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevReportStatus(
    IN  HANDLE FaxHandle OPTIONAL,
    OUT PFAX_DEV_STATUS FaxStatus,
    IN  DWORD FaxStatusSize,
    OUT LPDWORD FaxStatusSizeRequired
    )


{

return(
FaxDevReportStatusA(
    FaxHandle,
    FaxStatus,
    FaxStatusSize,
    FaxStatusSizeRequired
    ));

}

///////////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI FaxDevShutdown()
{
    return FaxDevShutdownA();
}


////////////////////////////////////////////////////////////////////////////
BOOL WINAPI
FaxDevAbortOperation(
    HANDLE              FaxHandle
    )


{


return(
FaxDevAbortOperationA(
    FaxHandle
    ));


}


////////////////////////////////////////////////////////////////////////////




HANDLE
TiffCreateW(
    LPWSTR FileName,
    DWORD  CompressionType,
    DWORD  ImageWidth,
    DWORD  FillOrder,
    DWORD  HiRes
    )

{



return(
TiffCreate(
    FileName,
    CompressionType,
    ImageWidth,
    FillOrder,
    HiRes
    ));

}





HANDLE
TiffOpenW(
    LPWSTR FileName,
    PTIFF_INFO TiffInfo,
    BOOL ReadOnly
    )


{

return (
TiffOpen(
    FileName,
    TiffInfo,
    ReadOnly,
    FILLORDER_LSB2MSB
    ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\provider\t30\main\whatnext.c ===
/***************************************************************************
        Name      :     WHATNEXT.C
        Comment   :     T30 Decision-point Callback function

        Copyright (c) 1993 Microsoft Corp.

        Revision Log
        Num   Date      Name     Description
        --- -------- ---------- -----------------------------------------------
***************************************************************************/
#define USE_DEBUG_CONTEXT   DEBUG_CONTEXT_T30_MAIN

#include "prep.h"



#include "efaxcb.h"
#include "protocol.h"


///RSL
#include "glbproto.h"

#include "t30gl.h"

#include "psslog.h"
#define FILE_ID     FILE_ID_WHATNEXT
#include "pssframe.h"


#define         FILEID                  FILEID_WHATNEXT


// used in eventPOSTPAGERESPONSE
// first index got from ifrSend (MPS=0, EOM=1, EOP=2, EOMwithFastTurn=3)
// second index got from ifrRecv (MCF=0, RTP=1, RTN=2)
ET30ACTION PostPageAction[4][3] =
{
    { actionGONODE_I,      actionGONODE_D, actionGONODE_D },
    { actionGONODE_T,      actionGONODE_T, actionGONODE_T }, 
    { actionDCN,           actionDCN,      actionGONODE_D },
    { actionGONODE_A,      actionGONODE_A, actionGONODE_D }
};


DWORD PageWidthInPixelsFromDCS[] = 
{ // This is width page in DCS
    1728, 
    2048, 
    2432,
    2432
};
    

void CopyFrToRFS(PThrdGlbl pTG, NPRFS npRecvd, LPFR lpfr)
{
    USHORT uLen;

    BG_CHK(MAXFRAMES == (sizeof(npRecvd->rglpfr) / sizeof(LPFR)));
    if(npRecvd->uNumFrames >= (sizeof(npRecvd->rglpfr) / sizeof(LPFR)))
    {
        BG_CHK(FALSE);
        return;
    }
    uLen = sizeof(FRBASE) + lpfr->cb;
    if(npRecvd->uFreeSpaceOff + uLen >= sizeof(npRecvd->b))
    {
        BG_CHK(FALSE);
        return;
    }
    _fmemcpy(npRecvd->b + npRecvd->uFreeSpaceOff, lpfr, uLen);
    npRecvd->rglpfr[npRecvd->uNumFrames++] = (LPFR)(npRecvd->b + npRecvd->uFreeSpaceOff);
    npRecvd->uFreeSpaceOff += uLen;

    BG_CHK(npRecvd->uNumFrames <= MAXFRAMES);
    BG_CHK(npRecvd->uFreeSpaceOff <= MAXSPACE);
}



/***-------------- Warning. This is called as a Vararg function --------***/

ET30ACTION  __cdecl FAR
WhatNext    
(
    PThrdGlbl pTG,
    ET30EVENT event,
    WORD wArg1,
    DWORD_PTR lArg2,
    DWORD_PTR lArg3
)
{
    ET30ACTION              action = actionERROR;
    NPPROT                  npProt = &pTG->ProtInst;

    DEBUG_FUNCTION_NAME(_T("WhatNext"));

    DebugPrintEx(   DEBUG_MSG,
                    "Called with %s. args %d, %d, %d",
                    event_GetEventDescription(event),
                    wArg1,
                    lArg2,
                    lArg3);

    // program bug. failure will cause a GP fault
    BG_CHK(pTG->ProtInst.fInUse);

    if (pTG->fAbortRequested) 
    {
        if (pTG->fOkToResetAbortReqEvent && (!pTG->fAbortReqEventWasReset)) 
        {
            DebugPrintEx(DEBUG_MSG,"RESETTING AbortReqEvent");
            pTG->fAbortReqEventWasReset = TRUE;
            if (!ResetEvent(pTG->AbortReqEvent))
            {
                DebugPrintEx(   DEBUG_ERR, 
                                "ResetEvent(0x%lx) returns failure code: %ld",
                                (ULONG_PTR)pTG->AbortReqEvent,
                                (long) GetLastError());

            }
        }
        DebugPrintEx(DEBUG_MSG,"ABORTing");
        return actionERROR;
    }

    if(npProt->fAbort)
    {
        DebugPrintEx(DEBUG_ERR,"Aborting");
        // ICommFailureCode already set
        return actionERROR;
    }

    switch(event)
    {
      case eventGOTFRAMES:
      {
            /* uCount=wArg1. This is the number of frames received.
             *
             * lplpfr=(LPLPET30FR)lArg2. Pointer to an array of pointers to
             *                the received frames, each in an ET30FR structure whose
             *                format is defined in ET30defs.H
             *
             * return must be actionNULL
             */

            USHORT  uCount = wArg1;
            LPLPFR  lplpfr = (LPLPFR)lArg2;
            LPIFR   lpifr  = (LPIFR)lArg3; // pointer to IFR that the "Response Recvd"
                                                             // routine will return to the main body
                                                             // can be modified, for example, if a bad
                                                             // franes is deciphered.
            LPFR    lpfr;
            USHORT  i;
            BOOL    fGotRecvCaps=FALSE, fGotRecvParams=FALSE, fGotPollReq=FALSE;

            /***
                    Each time we enter here we have an entire block of frames
                    that were sent as one "command" or "response". For frames
                    that can be multiple (NSF/NSS/NSC), we want to be sure that
                    _iff_ we have new ones, we throw away the old ones. Therefore
                    on the _first_ occurence of NSF, NSC and NSS resp. in the
                    loop below, zap npProt->uNumRecvdNS?s to 0. This may hold
                    good for SEP/PWD/SUB also.
            ***/

            BOOL    fZappedNSxCount=0;
            // fZappedSEPPWDCount=0;
            // BOOL fWaitingForPWD=0;

            if(*lpifr == ifrBAD)
            {
                DebugPrintEx(DEBUG_WRN,"Callback on Bad Frame. Ignoring ALL");
                action = actionNULL;    // only allowed response to eventGOTFRAMES
                break;
            }

            DebugPrintEx(DEBUG_MSG,"Got %d frames",uCount);

            for(i=0; i<uCount; i++)
            {
            ///////////////////////////////////////////////////////////////
            // Prepare to get trash (upto 2 bytes) at end of every frame //
            ///////////////////////////////////////////////////////////////
                lpfr = lplpfr[i];
                DebugPrintEx(   DEBUG_MSG,
                                "Frame %d is %s",
                                i,
                                ifr_GetIfrDescription(lpfr->ifr));

                switch(lpfr->ifr)
                {
                case ifrBAD:    DebugPrintEx(DEBUG_ERR,"Bad Frame not caught");
                                BG_CHK(FALSE);
                                // ignore it
                                break;
                case ifrCSI:    
                case ifrTSI:
                case ifrCIG:    CopyRevIDFrame(pTG, npProt->bRemoteID, lpfr);
                                // trailing-trash removed by length limit IDFIFSIZE
                                npProt->fRecvdID = TRUE;

                                PSSLogEntry(PSS_MSG, 1, "%s is \"%s\"",
                                            (lpfr->ifr==ifrCSI) ? "CSI" : "TSI", npProt->bRemoteID);
                                
                                // prepare CSID for logging by FaxSvc
                                // Here we get the Remote Station ID eg. 972 4 8550306
                                pTG->RemoteID = AnsiStringToUnicodeString(pTG->ProtInst.bRemoteID);
                                if (pTG->RemoteID) 
                                {
                                    pTG->fRemoteIdAvail = TRUE;
                                }
                                break;
                case ifrDIS:    npProt->uRemoteDISlen = CopyFrame(pTG, (LPBYTE)(&npProt->RemoteDIS), lpfr, sizeof(DIS));
                                // trailing-trash removed in ParseDISDTCDCS
                                    npProt->fRecvdDIS = TRUE;
                                fGotRecvCaps = TRUE;
                                break;
                case ifrDCS:    npProt->uRemoteDCSlen = CopyFrame(pTG, (LPBYTE)(&npProt->RemoteDCS), lpfr, sizeof(DIS));
                                // trailing-trash removed in ParseDISDTCDCS
                                npProt->fRecvdDCS = TRUE;
                                fGotRecvParams = TRUE;

                                PSSLogEntry(PSS_MSG, 1, "Received DCS is as follows:");
                                LogClass1DCSDetails(pTG, (NPDIS)(&lpfr->fif));
                                
                                // We save the Image Width from the DCS we got
                                pTG->TiffInfo.ImageWidth = PageWidthInPixelsFromDCS[npProt->RemoteDCS.PageWidth];
                                // We save the Image YResolution from the DCS we got
                                pTG->TiffInfo.YResolution = (npProt->RemoteDCS.ResFine_200) ? TIFFF_RES_Y : TIFFF_RES_Y_DRAFT;
                                // Also lets save the CompressionType from the fresh DCS
                                pTG->TiffInfo.CompressionType = (npProt->RemoteDCS.MR_2D) ? TIFF_COMPRESSION_MR : TIFF_COMPRESSION_MH;
                                break;
                case ifrDTC:    npProt->uRemoteDTClen = CopyFrame(pTG, (LPBYTE)(&npProt->RemoteDTC), lpfr, sizeof(DIS));
                                // trailing-trash removed in ParseDISDTCDCS
                                npProt->fRecvdDTC = TRUE;
                                fGotPollReq = TRUE;
                                break;
                case ifrNSS:    fGotRecvParams = TRUE; //some OEMs send NSS w/o DCS
                                goto DoRecvNSx;
                case ifrNSC:    fGotPollReq = TRUE;    //some OEMs send NSC w/o DTC
                                goto DoRecvNSx;
                case ifrNSF:    goto DoRecvNSx;
DoRecvNSx:
                                if(!fZappedNSxCount)
                                {
                                    ZeroRFS(pTG, &npProt->RecvdNS);
                                    fZappedNSxCount = TRUE;
                                }
                                CopyFrToRFS(pTG, &npProt->RecvdNS, lpfr);
                                break;
                case ifrCFR:            
                case ifrFTT:
                case ifrEOM:            
                case ifrMPS:            
                case ifrEOP:
                case ifrPRI_EOM:        
                case ifrPRI_MPS:        
                case ifrPRI_EOP:
                case ifrMCF:            
                case ifrRTP:            
                case ifrRTN:
                case ifrPIP:            
                case ifrPIN:
                case ifrDCN:
                case ifrCRP:
                                                /*** ECM frames below ***/
                case ifrCTR:            
                case ifrERR:
                case ifrRR:             
                case ifrRNR:
                case ifrEOR_NULL:
                case ifrEOR_MPS:        
                case ifrEOR_PRI_MPS:
                case ifrEOR_EOM:        
                case ifrEOR_PRI_EOM:
                case ifrEOR_EOP:        
                case ifrEOR_PRI_EOP:
                                //      These have no FIF
                                DebugPrintEx(   DEBUG_WRN,
                                                "These are not supposed to be signalled");
                                // bad frame. ignore it
                                // BG_CHK(FALSE);
                                break;

                /********* New T.30 frames ******************************/

                case ifrSUB:    CopyRevIDFrame(pTG, npProt->bRecipSubAddr, lpfr);
                                npProt->fRecvdSUB = TRUE;
                                break;


/**
                case ifrSEP:
                case ifrPWD:
                        if(!fZappedSEPPWDCount)
                        {
                                ZeroRFS(pTG, &npProt->RecvdSEPPWD);
                                fZappedSEPPWDCount = TRUE;
                        }
                        CopyFrToRFS(pTG, &npProt->RecvdSEPPWD, lpfr);
                        break;
**/




                /********* ECM stuff starts here. T.30 section A.4 ******/

                //      These have FIFs
                case ifrPPR:    if(lpfr->cb < 32)
                                {
                                    // bad frame. FORCE A RETRANSMIT!!
                                    DebugPrintEx(DEBUG_ERR,"Bad PPR length!!");
                                    *lpifr = ifrNULL;
                                    break;
                                }
                                _fmemcpy(npProt->bRemotePPR, lpfr->fif, 32);
                                // trailing-trash removed by length limit 32
                                npProt->fRecvdPPR = TRUE;
                                break;
                case ifrPPS_NULL:
                case ifrPPS_EOM:
                case ifrPPS_MPS:
                case ifrPPS_EOP:
                case ifrPPS_PRI_EOM:
                case ifrPPS_PRI_MPS:
                case ifrPPS_PRI_EOP:
                                if(lpfr->cb < 3)
                                {
                                    // bad frame. FORCE A RETRANSMIT!!
                                    DebugPrintEx(DEBUG_ERR,"Bad PPS length!!");
                                    *lpifr = ifrNULL;
                                    break;
                                }
                                _fmemset(npProt->bRemotePPS, 0, 4);
                                _fmemcpy(npProt->bRemotePPS, lpfr->fif, 3);
                                // trailing-trash removed by length limit 3
                                npProt->fRecvdPPS = TRUE;
                                // only set this on first PPS in a block
                                if(!npProt->uFramesInThisBlock)
                                        npProt->uFramesInThisBlock = (USHORT)(npProt->bRemotePPS[2]) + 1; //3rd byte of fif
                                break;
                case ifrCTC:
                                BG_CHK(npProt->fllRecvParamsGot);
                                if(lpfr->cb < 2)
                                {
                                    // bad frame. FORCE A RETRANSMIT!!
                                    DebugPrintEx(DEBUG_ERR,"Bad CTC length!!");
                                    *lpifr = ifrNULL;
                                    break;
                                }
                                npProt->llRecvParams.Baud = ((LPDIS)(&(lpfr->fif)))->Baud;
                                // trailing-trash removed by length limit 2
                                break;
                } // End of 'switch(lpfr->ifr)'
            } // handle the next frame

            if(fGotRecvCaps)
            {
                // program bug. Failure may cause some random (non fatal) results
                BG_CHK(!fGotRecvParams && !fGotPollReq);

                PSSLogEntry(PSS_MSG, 1, "DIS specified the following capabilities:");
                LogClass1DISDetails(pTG, &npProt->RemoteDIS);
                
                GotRecvCaps(pTG);
            }
            if(fGotRecvParams)
            {
                // program bug. Failure may cause some random (non fatal) results
                BG_CHK(!fGotRecvCaps && !fGotPollReq);
                GotRecvParams(pTG);
            }
            if(fGotPollReq)
            {
                // program bug. Failure may cause some random (non fatal) results
                BG_CHK(!fGotRecvCaps && !fGotRecvParams);
                GotPollReq(pTG);
            }
            action = actionNULL;    // only allowed response to eventGOTFRAMES
            break;
      }

    /****** Transmitter Phase B. Fig A-7/T.30 (sheet 1) ******/

      case eventNODE_T:     // do nothing. Hook for abort in T1 loop
                            action=actionNULL; break;
      case eventNODE_R:     // do nothing. Hook for abort in T1 loop
                            action=actionNULL; break;


      case eventNODE_A:
                      {
                            IFR ifrRecv = (IFR)wArg1;       // last received frame
                            // lArg2 & lArg3 missing

                            if(ifrRecv != ifrDIS && ifrRecv != ifrDTC)
                            {
                                DebugPrintEx(DEBUG_ERR,"Unknown frames at NodeA");
                                ICommFailureCode(pTG, T30FAIL_NODEA_UNKNOWN);
                                action = actionHANGUP;          // G3 only
                            }
                            else if(npProt->fSendParamsInited)
                            {
                                BG_CHK(npProt->SendParams.bctype == SEND_PARAMS);
                                action = actionGONODE_D;                // sends DCS/NSS (in response to DIS or DTC)
                            }
                            // NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
                            else if(npProt->fSendPollReqInited)
                            {
                                BG_CHK(npProt->SendPollReq.bctype == SEND_POLLREQ);
                                // BG_CHK(ifrRecv == ifrDIS);   // no need. DTC can follow DTC for Stalling
                                action = actionGONODE_R2;               // sends DTC/NSC (in response to DIS only)
                            }
                            // end this is never executed
                            else
                            {
                                DebugPrintEx(DEBUG_ERR,"NodeA: No more work...!!");
                                ICommFailureCode(pTG, T30FAILS_NODEA_NOWORK);
                                action = actionDCN;                     // hangs up (sends DCN)
                            }
                            break;
                      }
      case eventSENDDCS:
                      {
                            // 0==1st DCS  1==after NoReply  2==afterFTT
                            USHORT uWhichDCS = (UWORD)wArg1;

                            // where to return the number of frames returned
                            LPUWORD lpuwN = (LPUWORD)lArg2;
                            // where to return a pointer to an array of pointers to
                            // return frames
                            LPLPLPFR lplplpfr = (LPLPLPFR)lArg3;
                            USHORT   uSize = 0;

                            if(uWhichDCS == 2)      // got FTT
                            {
                                if(!DropSendSpeed(pTG))
                                {
                                    DebugPrintEx(DEBUG_ERR, "FTT: Can't Drop speed any lower");
                                    ICommFailureCode(pTG, T30FAILS_FTT_FALLBACK);
                                    action = actionDCN;
                                    break;
                                }
                            }

                            CreateNSSTSIDCS(pTG, npProt, &pTG->rfsSend, uWhichDCS);

                            BG_CHK(npProt->fllNegotiated);
                            if(npProt->llNegot.fECM)
                            {
                                uSize = (1 << (ProtGetECMFrameSize(pTG)));
                                BG_CHK(uSize==64 || uSize==256);
                                ICommSetSendMode(pTG, TRUE, MY_ECMBUF_SIZE, uSize, TRUE);
                            }
                            else
                            {
                                ICommSetSendMode(pTG, FALSE, MY_BIGBUF_SIZE, MY_BIGBUF_ACTUALSIZE-4, FALSE);
                            }

                            *lpuwN = pTG->rfsSend.uNumFrames;
                            *lplplpfr = pTG->rfsSend.rglpfr;

                            action = actionSENDDCSTCF;

                #ifdef OEMNSF
                            if(wOEMFlags && lpfnOEMNextAction)
                            {
                                switch(lpfnOEMNextAction())
                                {
                                case OEMNSF_SENDDCN:    action = actionDCN; 
                                                        break;
                                case OEMNSF_SKIPTCF:    action = actionSKIPTCF; 
                                                        break;
                                }
                            }
                #endif

                            break;

                            // Could also return DCN if not compatible
                            // or SKIPTCF for Ricoh hook
                      }

      case eventGOTCFR:
                      {
                            // wArg1, lArg2 & lArg3 are all missing

                            // Can return GONODE_D (Ricoh hook)
                            // or GONODE_I (Non ECM) or GONODE_IV (ECM)

                            BG_CHK(npProt->fllNegotiated);
                            if(npProt->llNegot.fECM)
                            {
                                action = actionGONODE_IV;
                            }
                            else
                            {
                                action = actionGONODE_I;
                            }
                            break;
                      }
    /****** Transmitter Phase C. Fig A-7/T.30 (sheet 1) ******/

    /***
      case eventSTARTSEND:
      {
            if(!StartNextSendPage(pTG))
            {
                    ERRMSG((SZMOD "<<ERROR>> PhaseC: No more pages\r\n"));
                    ICommFailureCode(T30FAILS_BUG3);
                    action = actionDCN;
            }
            else
                    action = actionCONTINUE;
            break;
      }
    ***/

    /****** Transmitter ECM and non-ECM Phase D1. Fig A-7/T.30 (sheet 2) ******/

      case eventECM_POSTPAGE:
      case eventPOSTPAGE:
                      {
                            USHORT uNextSend;

                            // wArg1, lArg2 & lArg3 are all missing

                            // Can turn Zero stuffing off here, or wait for next page....
                            // ET30ExtFunction(npProt->het30, ET30_SET_ZEROPAD, 0);
                            // Don't turn it off!! It is used only for Page Send
                            // and is set only on sending a DCS, so it is set once
                            // before a multi-page send.

                            uNextSend = ICommNextSend(pTG);
                            switch(uNextSend)
                            {
                            case NEXTSEND_MPS:  action = actionSENDMPS; 
                                                break;
                            case NEXTSEND_EOM:  action = actionSENDEOM; 
                                                break;
                            case NEXTSEND_EOP:  action = actionSENDEOP; 
                                                break;
                            case NEXTSEND_ERROR:
                            default:            action = actionSENDEOP; 
                                                break;
                            }
                            break;
                            // also possible -- GOPRIEOP, PRIMPS or PRIEOM
                      }

    /****** Transmitter Phase D2. Fig A-7/T.30 (sheet 2) ******/

      case eventGOTPOSTPAGERESP:
                      {
                            IFR ifrRecv = (IFR)wArg1;       // last received frame
                            IFR ifrSent = (IFR)lArg2;
                                    // the IFR was simply cast to DWORD and then to LPVOID
                                    // lArg3 is missing
                            USHORT i, j;

                            // change PRI commands to ordinary ones
                            if(ifrSent >= ifrPRI_FIRST && ifrSent <= ifrPRI_LAST)
                                    ifrSent = (ifrSent + ifrMPS - ifrPRI_MPS);

                            BG_CHK(ifrSent==ifrMPS || ifrSent==ifrEOM || ifrSent==ifrEOP);
                            if(ifrRecv!=ifrMCF && ifrRecv!=ifrRTP && ifrRecv!=ifrRTN)
                            {
                                // can't BG_CHK cause we can get any garbage response anytime
                                DebugPrintEx(   DEBUG_ERR,
                                                "Unexpected Response %d", 
                                                ifrRecv);
                                ICommFailureCode(pTG, T30FAILS_POSTPAGE_UNKNOWN);
                                action = actionDCN;
                                break;
                            }

                            i = ifrSent - ifrMPS;   //i: 0=MPS, 1=EOM, 2=EOP
                            j = ifrRecv - ifrMCF;   //j: 0=MCF, 1=RTP, 2=RTN

#ifdef FASTTURN
                            if(ifrSent == ifrEOM)
                            {
                                    BG_CHK(i==1);
                                    i = 3;                  //i: 3==EOM with fast turn
                            }
#endif

                            // Report status + Check whether we do re-transmit
            
                            if (ICommSendPageAck(pTG, ifrRecv!=ifrRTN))
                            {
                                BG_CHK(j==2);
                                pTG->ProtParams.RTNNumOfRetries++; //  increment by one the number of re-transmittions
                                DebugPrintEx(   DEBUG_MSG, 
                                                "RTN: Try# %d", 
                                                pTG->ProtParams.RTNNumOfRetries);
                                if (pTG->ProtParams.RTNNumOfRetries <= gRTNRetries.RetriesBeforeDropSpeed) 
                                { 
                                    // Number of retries before we start to drop speed.
                                    // Just change the number of retries, do not drop speed yet
                                    DebugPrintEx(   DEBUG_MSG, 
                                                    "Got RTN, Resend same page with same speed");
                                }
                                else // We should first try to drop speed or hangup
                                {
                                    if(pTG->ProtParams.RTNNumOfRetries > gRTNRetries.RetriesBeforeDCN) // Exceed the allowed re-transmittions.
                                    {
                                        DebugPrintEx(   DEBUG_MSG, 
                                                        "RTN: Tried to resend same page"
                                                        " %d times. Giving up (HANG-UP)",
                                                        (pTG->ProtParams.RTNNumOfRetries-1));
                                        ICommFailureCode(pTG, T30FAILS_RTN_FALLBACK);
                                        action = actionDCN;
                                        break;                  // set action to DCN and return
                                    } 
                                    else
                                    { 
                                        DebugPrintEx(   DEBUG_MSG, 
                                                        "Got RTN, now try to drop speed one notch");
                                        if(!DropSendSpeed(pTG))
                                        {
                                            DebugPrintEx(   DEBUG_ERR,
                                                            "RTN: Can't Drop speed any lower,"
                                                            " trying again in same speed");
                                        }
                                    }
                                }
                            }
                            BG_CHK((i >= 0) && (i <= 3) && (j >= 0) && (j <= 2)); 
                            action = PostPageAction[i][j];
            
                            if(action == actionDCN)
                            {
                                DebugPrintEx(DEBUG_MSG,"PostPage --> Game over");
                                ICommFailureCode(pTG, T30FAILS_POSTPAGE_OVER);
                            }
                            break;

                            // Can also return GO_D, GO_R1, GO_R2. Only restriction is
                            // that GO_I is the only valid response to MPS sent followed
                            // by MCF
                      }

    /****** Transmitter ECM Phase D2. Fig A-7/T.30 (sheet 2) ******/

      case eventGOT_ECM_PPS_RESP:
                      {
                            IFR ifrRecv = (IFR)wArg1;       // last received frame
                            IFR ifrSent = (IFR)lArg2;
                                    // the IFR was simply cast to DWORD
                                    // lArg3 is missing

                            // program bug. Failure may cause some random (non fatal) results
                            BG_CHK(ifrRecv == ifrMCF);              // only valid response in ECM mode

                            if(ifrSent != ifrPPS_NULL)                      // not end-of-block(i.e. midpage)
                                    ICommSendPageAck(pTG, TRUE);

                            switch(ifrSent)
                            {
                              case ifrPPS_NULL:             action = actionGONODE_IV;       // Same page. New block
                                                            break;
                              case ifrPPS_MPS:
                              case ifrPPS_PRI_MPS:          action = actionGONODE_IV;       // New page
                                                            break;
                              case ifrPPS_EOM:
                              case ifrPPS_PRI_EOM:          // After sending EOM, Receiver always goes
                                                            // back to sending NSF etc so we have to go
                                                            // back to NodeT to receive all that junk.
                                                            action = actionGONODE_T;
                                                            break;
                              case ifrPPS_EOP:
                              case ifrPPS_PRI_EOP:
                                                            // action = actionSUCCESS;
                                                            DebugPrintEx(   DEBUG_MSG,
                                                                            "ECM -- Send Done");
                                                            ICommFailureCode(pTG, T30FAILSE_ECM_NOPAGES);
                                                            action = actionDCN;
                                                            break;
                              default:
                                                            DebugPrintEx(   DEBUG_ERR,
                                                                            "Dunno what we sent %d",
                                                                            ifrSent);
                                                            // program bug. hangup
                                                            BG_CHK(FALSE);
                                                            ICommFailureCode(pTG, T30FAILSE_BUG4);
                                                            action = actionDCN;
                                                            break;
                            }
                            // Can also return GO_D, GO_R1, GO_R2. Only restriction is
                            // that GO_I is the only valid response to MPS sent followed
                            // by MCF

                            break;
                      }

    /****** Transmitter Phase D (PIN/PIN stuff). Fig A-7/T.30 (sheet 2) ******/

#ifdef PRI
      case eventGOTPINPIP:
                      {
                            IFR ifrRecv = (IFR)wArg1;       // last received frame
                            IFR ifrSent = (IFR)lArg2;       // the IFR was simply cast to DWORD
                            // lArg3 is missing

                            DebugPrintEx(DEBUG_ERR,"Can't deal with PIN PIP");
                            ICommFailureCode(pTG, T30FAIL_BUG5);
                            action = actionDCN;
                            break;

                            // must alert operator, check that handset has been lifted
                            // and then return actionGOVOICE. If handest is not lifted
                            // within T3 must return GO_A (???) or maybe GO_DCN (???) or
                            // GO_D. Not sure what.
                      }
      case eventVOICELINE:
                      {
                            // All Args are missing

                            DebugPrintEx(DEBUG_ERR,"Can't deal with VOICELINE");
                            ICommFailureCode(pTG, T30FAIL_BUG6);
                            action = actionDCN;
                            break;
                            // must connect handset to phone line, wait until operator
                            // finishes talking. Then return HANGUP, GO_T, GO_R1 (??)
                            // or GO_R2 (??)
                      }
#endif

    /****** Receiver Phase B. Fig A-7/T.30 (sheet 1) ******/

      case eventSENDDIS:
                          {
                                // wArg1 is 0
                                // where to return the number of frames returned
                                LPUWORD lpuwN = (LPUWORD)lArg2;
                                // where to return a pointer to an array of pointers to
                                // return frames
                                LPLPLPFR lplplpfr = (LPLPLPFR)lArg3;


                                // CreateNSFCSIDIS(npProt, lpuwN, lplplpfr);
                                BG_CHK(npProt->fSendCapsInited);
                                BG_CHK(npProt->fllSendCapsInited);
                                BG_CHK(npProt->fHWCapsInited);
                                BCtoNSFCSIDIS(pTG, &pTG->rfsSend, (NPBC)&npProt->SendCaps, &npProt->llSendCaps);
            
                                // We save OUR DIS in the LocalDIS.
                                // This will help us when we want to check the DCS we got against the DIS we send.
            
                                npProt->uLocalDISlen = CopyFrame(pTG, (LPBYTE)(&npProt->LocalDIS), 
                                    pTG->rfsSend.rglpfr[pTG->rfsSend.uNumFrames - 1], // The DIS is always the last frame
                                    sizeof(DIS));
                                npProt->fLocalDIS = TRUE;  

                                PSSLogEntry(PSS_MSG, 1, "Composing DIS with the following capabilities:");
                                LogClass1DISDetails(pTG, &npProt->LocalDIS);

                                *lpuwN = pTG->rfsSend.uNumFrames;
                                *lplplpfr = pTG->rfsSend.rglpfr;

                                action = actionSEND_DIS;
                                break;
                          }
      // NTRAID#EDGEBUGS-9691-2000/07/24-moolyb - this is never executed
      case eventSENDDTC:
                          {
                                // wArg1 is 0
                                // where to return the number of frames returned
                                LPUWORD lpuwN = (LPUWORD)lArg2;
                                // where to return a pointer to an array of pointers to
                                // return frames
                                LPLPLPFR lplplpfr = (LPLPLPFR)lArg3;


                                // CreateNSCCIGDTC(npProt, lpuwN, lplplpfr);
                                BG_CHK(npProt->fSendPollReqInited);
                                BG_CHK(npProt->fllSendCapsInited);
                                BG_CHK(npProt->fHWCapsInited);
                                BCtoNSCCIGDTC(pTG, &pTG->rfsSend, (NPBC)&npProt->SendPollReq, &npProt->llSendCaps);
                                *lpuwN = pTG->rfsSend.uNumFrames;
                                *lplplpfr = pTG->rfsSend.rglpfr;

                                action = actionSEND_DTC;
                                break;
                          }
        // end this is never executed

#ifdef PRI
      case eventQUERYLOCALINT:
                          {
                                // all Args are missing
                                // return actionTRUE if a local interrupt is pending, else actionFALSE
                                action = actionFALSE;
                                break;
                          }
#endif // PRI

    /*** Receiver Phase B. Main Command Loop. Fig A-7/T.30 (sheet 1&2) ***/

      case eventRECVCMD:
                      {
                            IFR ifrRecv = (IFR)wArg1;       // last received frame
                            // lArg2 & lArg3 missing

                        switch(ifrRecv)
                            {
                              case ifrDTC:
                                    // flow chart says Goto D, but actually we need to decide if we
                                    // have anything to send. So goto NodeA first
                                    // return GONODE_D;
                                    action = actionGONODE_A;
                                    break;

                              case ifrDIS:
                                    action = actionGONODE_A;
                                    break;
                              case ifrDCS:
                              {
                                    // Check the received DCS for compatibility with us
                                    // set Recv Baud rate--no need. TCF already recvd by this time
                                    // ET30ExtFunction(npProt->het30, ET30_SET_RECVDATASPEED, npProt->RemoteDCS.Baud);
                                    action = actionGETTCF;
                                    // only other valid action is HANGUP
                                    break;
                              }
                              case ifrNSS:
                              {
                                    // Check the received NSS for compatibility with us
                                    // set Recv Baud rate--no need. TCF already recvd by this time
                                    // ET30ExtFunction(npProt->het30, ET30_SET_RECVDATASPEED, npProt->RemoteDCS.Baud);
                                    action = actionGETTCF;
                                    // only other valid action is HANGUP
                                    break;
                              }
                              default:
                                    // program bug. hangup
                                    BG_CHK(FALSE);
                                    ICommFailureCode(pTG, T30FAIL_BUG7);
                                    action = actionHANGUP;
                                    break;
                            }
                            break;
                      }

      case eventGOTTCF:
                      {
                            SWORD swErr = (SWORD)wArg1;     // errors per 1000
                            // lArg2 & lArg3 missing

                            DebugPrintEx(   DEBUG_MSG, 
                                            "GOTTCF num of errors = %d",
                                            swErr);

                            BG_CHK(pTG->ProtInst.fRecvdDCS && pTG->ProtInst.fLocalDIS);
                            if ((swErr >= 0) // The TCF was OK
                                && AreDCSParametersOKforDIS(&pTG->ProtInst.LocalDIS, &pTG->ProtInst.RemoteDCS)) 
                            {
                                    // very important!! Re-init the fPageOK flag in case we miss
                                    // the page entirely, and jump into PhaseD this must be FALSE
                                    // npProt->fPageOK = FALSE;
                                    // done at start of PhaseC by calling ProtResetRecvPageAck()

                                    action = actionSENDCFR; // just going along
                            }
                            else
                                    action = actionSENDFTT;
                            break;
                      }

    /****** Receiver Phase C. Fig A-7/T.30 (sheet 1) ******/

    /***
      case eventSTARTRECV:
      {
            if(!StartNextRecvPage())
            {
                    ICommFailureCode(T30FAILR_BUG8);
                    action = actionDCN;
            }
            else
                    action = actionCONTINUE;
            break;
      }
    ***/

    /****** Receiver Phase D. Fig A-7/T.30 (sheet 1) ******/

#ifdef PRI
      case eventPRIQ:
                      {
                            IFR ifrRecv = (IFR)wArg1;       // last received frame
                            // lArg2 & lArg3 missing

                            /**
                                    ifrRecv can be PRI-Q, PPS-PRI-Q, EOR-PRI-Q
                                    alert operator etc.
                                    can return SENDPIP, SENDPIN, GONODE_F, GO_RECVPOSTPAGE
                                    If PPS-PRIQ can send only PIP not PIN
                                    If EOR-PRIQ can send only PIN not PIP
                                    or HANGUP. Have to combine the stuff on Fig A-18/T.30
                                    (RHS) and on LHS of FigA-7/T.30 (sheet 2) (below node III)
                            **/

                            // not implemented
                            BG_CHK(FALSE);
                            break;
                      }
#endif
      case eventRECVPOSTPAGECMD:
                      {
                            // IFR  ifrRecv = (IFR)wArg1;   // last received frame
                            // lArg2 & lArg3 missing

                            GetRecvPageAck(pTG);
                            if( ! pTG->fPageIsBad)
                              action = actionSENDMCF;       // quality fine
                            else
                              action = actionSENDRTN;       // quality unacceptable

                            // can also return actionSENDPIP or actionSENDPIN in a local
                            // interrupt is pending
                            break;
                      }

    /**----------------------- Exclusively ECM ----------------------------**/

      case event4THPPR:
                      {
                            USHORT  uFramesInBlock = (USHORT)wArg1;
                            USHORT  uFramesSent = (USHORT)lArg2;
                            USHORT  uNumBad, i, j;

                            // program bug. Failure may cause some random (non fatal) results
                            BG_CHK(npProt->fRecvdPPR);

                            for(uNumBad=0, i=0; i<=uFramesInBlock; i++)
                            {
                                j = (1 << (i % 8));
                                if(npProt->bRemotePPR[i/8] & j)
                                uNumBad++;
                            }
                            DebugPrintEx(   DEBUG_MSG,
                                            "4thPPR: FrameCount=%d FramesSent=%d NumBad=%d",
                                            uFramesInBlock, 
                                            uFramesSent, 
                                            uNumBad);

                            if(pTG->ProtParams.CTCAction == 1)
                            {
                                DebugPrintEx(DEBUG_ERR,"PPR: Too many bad frames");
                                ICommFailureCode(pTG, T30FAILS_4PPR_ERRORS);
                                action = actionSENDEOR_EOP;     // give up
                                // No need for EOR stuff. If we give up on a file, we can't
                                // transmit the next page. Doesn't make sense.
                            }
                            else
                            {
                                    // drop speed
                                    if(DropSendSpeed(pTG) != TRUE)
                                    {
                                        DebugPrintEx(DEBUG_ERR,"PPR: Can't Drop speed any lower");
                                        ICommFailureCode(pTG, T30FAILS_4PPR_FALLBACK);
                                        action = actionSENDEOR_EOP;
                                    }
                                    else
                                            action = actionGONODE_ECMRETRANSMIT;
                            }
                            break;
                      }

      default:
                      {
                            DebugPrintEx(DEBUG_ERR,"Unknown Event = %d", event);
                            ICommFailureCode(pTG, T30FAIL_BUG9);
                            break;
                      }
    }

//done:
    DebugPrintEx(   DEBUG_MSG,  
                    "event %s returned %s", 
                    event_GetEventDescription(event), 
                    action_GetActionDescription(action));
    return action;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\assert.h ===
/***
*assert.h - define the assert macro
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the assert(exp) macro.
*   [ANSI/System V]
*
****/

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#undef  assert

#ifdef NDEBUG

#define assert(exp) ((void)0)

#else 
#ifdef __cplusplus
extern "C" {
#endif 
void __cdecl _assert(void *, void *, unsigned);
#ifdef __cplusplus
}
#endif 

#define assert(exp) \
    ( (exp) ? (void) 0 : _assert(#exp, __FILE__, __LINE__) )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\bios.h ===
/***
*bios.h - declarations for bios interface functions and supporting definitions
*
*   Copyright (c) 1987-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file declares the constants, structures, and functions
*   used for accessing and using various BIOS interfaces.
*
****/

#ifndef _INC_BIOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _MT

/* manifest constants for BIOS serial communications (RS-232) support */

/* serial port services */

#define _COM_INIT   0   /* init serial port */
#define _COM_SEND   1   /* send character */
#define _COM_RECEIVE    2   /* receive character */
#define _COM_STATUS 3   /* get serial port status */

/* serial port initializers.  One and only one constant from each of the
 * following four groups - character size, stop bit, parity, and baud rate -
 * must be specified in the initialization byte.
 */

/* character size initializers */

#define _COM_CHR7   2   /* 7 bits characters */
#define _COM_CHR8   3   /* 8 bits characters */

/* stop bit values - on or off */

#define _COM_STOP1  0   /* 1 stop bit */
#define _COM_STOP2  4   /* 2 stop bits */

/*  parity initializers */

#define _COM_NOPARITY   0   /* no parity */
#define _COM_ODDPARITY  8   /* odd parity */
#define _COM_EVENPARITY 24  /* even parity */

/*  baud rate initializers */

#define _COM_110    0   /* 110 baud */
#define _COM_150    32  /* 150 baud */
#define _COM_300    64  /* 300 baud */
#define _COM_600    96  /* 600 baud */
#define _COM_1200   128 /* 1200 baud */
#define _COM_2400   160 /* 2400 baud */
#define _COM_4800   192 /* 4800 baud */
#define _COM_9600   224 /* 9600 baud */


/* manifest constants for BIOS disk support */

/* disk services */

#define _DISK_RESET 0   /* reset disk controller */
#define _DISK_STATUS    1   /* get disk status */
#define _DISK_READ  2   /* read disk sectors */
#define _DISK_WRITE 3   /* write disk sectors */
#define _DISK_VERIFY    4   /* verify disk sectors */
#define _DISK_FORMAT    5   /* format disk track */

/* struct used to send/receive information to/from the BIOS disk services */

#ifndef _DISKINFO_T_DEFINED
#pragma pack(2)

struct _diskinfo_t {
    unsigned drive;
    unsigned head;
    unsigned track;
    unsigned sector;
    unsigned nsectors;
    void __far *buffer;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskinfo_t _diskinfo_t
#endif 

#pragma pack()
#define _DISKINFO_T_DEFINED
#endif 


/* manifest constants for BIOS keyboard support */

/* keyboard services */

#define _KEYBRD_READ        0   /* read next character from keyboard */
#define _KEYBRD_READY       1   /* check for keystroke */
#define _KEYBRD_SHIFTSTATUS 2   /* get current shift key status */

/* services for enhanced keyboards */

#define _NKEYBRD_READ       0x10    /* read next character from keyboard */
#define _NKEYBRD_READY      0x11    /* check for keystroke */
#define _NKEYBRD_SHIFTSTATUS    0x12    /* get current shift key status */


/* manifest constants for BIOS printer support */

/* printer services */

#define _PRINTER_WRITE  0   /* write character to printer */
#define _PRINTER_INIT   1   /* intialize printer */
#define _PRINTER_STATUS 2   /* get printer status */


/* manifest constants for BIOS time of day support */

/* time of day services */

#define _TIME_GETCLOCK  0   /* get current clock count */
#define _TIME_SETCLOCK  1   /* set current clock count */


#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* function prototypes */

#ifndef _WINDOWS
unsigned __cdecl _bios_disk(unsigned, struct _diskinfo_t *);
#endif 
unsigned __cdecl _bios_equiplist(void);
#ifndef _WINDOWS
unsigned __cdecl _bios_keybrd(unsigned);
#endif 
unsigned __cdecl _bios_memsize(void);
#ifndef _WINDOWS
unsigned __cdecl _bios_printer(unsigned, unsigned, unsigned);
unsigned __cdecl _bios_serialcom(unsigned, unsigned, unsigned);
#endif 
unsigned __cdecl _bios_timeofday(unsigned, long *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#endif 

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_BIOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\cderr.h ===
/*****************************************************************************\
*                                                                             *
* cderr.h -     Common dialog error return codes                              *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CDERR
#define _INC_CDERR

#define CDERR_DIALOGFAILURE   0xFFFF

#define CDERR_GENERALCODES     0x0000
#define CDERR_STRUCTSIZE       0x0001
#define CDERR_INITIALIZATION   0x0002
#define CDERR_NOTEMPLATE       0x0003
#define CDERR_NOHINSTANCE      0x0004
#define CDERR_LOADSTRFAILURE   0x0005
#define CDERR_FINDRESFAILURE   0x0006
#define CDERR_LOADRESFAILURE   0x0007
#define CDERR_LOCKRESFAILURE   0x0008
#define CDERR_MEMALLOCFAILURE  0x0009
#define CDERR_MEMLOCKFAILURE   0x000A
#define CDERR_NOHOOK           0x000B
#define CDERR_REGISTERMSGFAIL  0x000C

#define PDERR_PRINTERCODES     0x1000
#define PDERR_SETUPFAILURE     0x1001
#define PDERR_PARSEFAILURE     0x1002
#define PDERR_RETDEFFAILURE    0x1003
#define PDERR_LOADDRVFAILURE   0x1004
#define PDERR_GETDEVMODEFAIL   0x1005
#define PDERR_INITFAILURE      0x1006
#define PDERR_NODEVICES        0x1007
#define PDERR_NODEFAULTPRN     0x1008
#define PDERR_DNDMMISMATCH     0x1009
#define PDERR_CREATEICFAILURE  0x100A
#define PDERR_PRINTERNOTFOUND  0x100B
#define PDERR_DEFAULTDIFFERENT 0x100C

#define CFERR_CHOOSEFONTCODES  0x2000
#define CFERR_NOFONTS          0x2001
#define CFERR_MAXLESSTHANMIN   0x2002

#define FNERR_FILENAMECODES    0x3000
#define FNERR_SUBCLASSFAILURE  0x3001
#define FNERR_INVALIDFILENAME  0x3002
#define FNERR_BUFFERTOOSMALL   0x3003

#define FRERR_FINDREPLACECODES 0x4000
#define FRERR_BUFFERLENGTHZERO 0x4001

#define CCERR_CHOOSECOLORCODES 0x5000

#endif  /* !_INC_CDERR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\cmacros.inc ===
comment $
cmacros - assembly macros for interfacing to hlls
(C)Copyright Microsoft Corp. 1984-1988
$
.xcref
.xcref ??_out
??_out macro t
ifndef ?QUIET
%out t
endif
endm
outif macro name,defval,onmsg,offmsg
ifndef name
ifb <defval>
name=0
else
name=defval
endif
endif
if name
name=1
ifnb <onmsg>
??_out <! onmsg>
endif
else
ifnb <offmsg>
??_out <! offmsg>
endif
endif
endm
.xcref ??error
??error macro msg
e r r o r ----- msg
.err
endm
.xcref ASMpass
.xcref memS,memM,memL,memC,memH,memMOD,sizec,sized
if1
ASMpass=1
ifdef ?SMALL
memS=1
endif
ifdef ?MEDIUM
memM=1
endif
ifdef ?COMPACT
memC=1
endif
ifdef ?LARGE
memL=1
endif
ifdef ?HUGE
memH=1
endif
??_out <cMacros Version 5.20 - Copyright (c) Microsoft Corp. 1984-1988>
outif memS,0,<Small model>
outif memM,0,<Medium model>
outif memL,0,<Large model>
outif memC,0,<Compact model>
outif memH,0,<Huge model>
memMOD= memS + memM + memL + memC + memH
if memMOD ne 1
if memMOD eq 0
memS = 1
else
??error <more than 1 memory model selected>
endif
endif
sizec= memM + memL + memH
sized= memL + memC + (memH*2)
outif ?DF,0,<No segments or groups will be defined>
outif ?TF,0,<Epilog sequences assume valid SP>
outif ?WIN,1,<Windows support>
ifdef PMODE
?pmd=1
??_out <! 286 protect mode>
else
?pmd=0
endif
ifdef ?386regs
if ?386regs
??_out <! 386 registers enabled>
endif
else
?386regs=0
endif
if ?WIN eq 1
outif ?PLM,1,<>
else
outif ?PLM,1,<Pascal calling convention>
endif
ifndef ?NODATA
?nodata1=0
else
?nodata1=1
??_out <! NODATA module>
endif
ifndef ?CHKSTK
?chkstk1=0
else
?chkstk1=1
ifdef ?CHKSTKPROC
??_out <! Private stack checking enabled>
else
??_out <! Stack checking enabled>
endif
endif
ifndef DOS5
?DOS5=0
else
?DOS5=1
??_out <! DOS5 module>
endif
ifdef ?PROFILE
??_out <! Native profiling enabled>
endif
else
ASMpass=2
endif
ifdef ?pmd
.286p
endif
if ?386regs
.xcref ?n,?ax,?eax,?bx,?ebx
.xcref ?cx,?ecx,?dx,?edx
.xcref ?si,?esi,?di,?edi,?es,?ds,?fs
.xcref ?gs
else
.xcref ?n,?ax,?ah,?al,?bx,?bh
.xcref ?bl,?cx,?ch,?cl,?dx,?dh
.xcref ?dl,?si,?di,?es,?ds,?bp
.xcref ?sp,?ss,?cs
endif
.xcref ?rsl,?cpd,?argl,?argc,?ba
.xcref ?acb,???,?po
.xcref ?pas,?pc
.xcref uconcat,mpush,mpop
.xcref ?ri,?pp,?pp1,?al1
.xcref ?ad,?ap,?atal,?dd,?dd1,?dd2
.xcref ?pg,?pg1,?aloc,?cs1,?cs2
.xcref ?DF,?TF,?ff,?PLM,?WIN,?ia,?pu,?adj
.xcref ?uf,?rp,?nx,?nd,?nodata1,?chkstk1,?DOS5,?pmd,?lds,?exp
.xcref ?wfp,arg,cCall,cProc,assumes,?cs3,?cs2,?cs1
.xcref defgrp,addseg,createSeg
.xcref save,outif,errnz,errn$,errnz1
.xcref ?PLMPrevParm,?gcc
.xcref ?cCall1,?pcc
?rsl = 0
?cpd = 0
?argl = 0
?argc = 0
?ba = 0
?acb = 0
??? = 0
?po = 0
?pas = 0
?pc = 0
?ia = 0
?pu = 0
?adj = 0
?rp = 0
?uf = 0
?nd = 0
?nx = 0
?wfp = 0
?lds = 0
?exp = 0
?ff = 0
?dd2 = 0
?cCall1 = 0
?pcc = 0
?PLMPrevParm = 0
.xcref ?casen
if1
?casen = 0
endif
if ?386regs
?n = 0000000000000000b
?ax = 0000000000000001b
?eax = 0000000000000010b
?bx = 0000000000000100b
?ebx = 0000000000001000b
?cx = 0000000000010000b
?ecx = 0000000000100000b
?dx = 0000000001000000b
?edx = 0000000010000000b
?si = 0000000100000000b
?esi = 0000001000000000b
?di = 0000010000000000b
?edi = 0000100000000000b
?ds = 0001000000000000b
?es = 0010000000000000b
?fs = 0100000000000000b
?gs = 1000000000000000b
else
?n = 0000000000000000b
?ax = 0000000000000011b
?ah = 0000000000000001b
?al = 0000000000000010b
?bx = 0000000000001100b
?bh = 0000000000000100b
?bl = 0000000000001000b
?cx = 0000000000110000b
?ch = 0000000000010000b
?cl = 0000000000100000b
?dx = 0000000011000000b
?dh = 0000000001000000b
?dl = 0000000010000000b
?si = 0000000100000000b
?di = 0000001000000000b
?es = 0000010000000000b
?ds = 0000100000000000b
?bp = 0001000000000000b
?sp = 0010000000000000b
?ss = 0100000000000000b
?cs = 1000000000000000b
endif
.cref
uconcat macro a,b,c,d,e,f,g
a&b c&d e&f&g
endm
if ?386regs
mpush macro r
irp x,<ax,eax,bx,ebx,cx,ecx,dx,edx,si,esi,di,edi,ds,es,fs,gs>
if (r and ?&&x)
	push	x
endif
endm
endm
else
mpush macro r
irp x,<ax,bx,cx,dx,si,di,es,ds,bp,sp,ss,cs>
if (r and ?&&x)
	push	x
endif
endm
endm
endif
if ?386regs
mpop macro r
irp x,<gs,fs,es,ds,edi,di,esi,si,edx,dx,ecx,cx,ebx,bx,eax,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
else
mpop macro r
irp x,<cs,ss,sp,bp,ds,es,di,si,dx,cx,bx,ax>
if (r and ?&&x)
	pop	x
endif
endm
endm
endif
save macro r
?rsl=0
?ri ?rsl,<r>
endm
?ri macro n,r
irp x,<r>
.ERRNDEF ?&&x
n=n or ?&&x
endm
endm
.xcref
.xcref parmB,parmW,parmD,parmQ,parmT,parmCP,parmDP
.cref
parmB macro n
?pp <n>,<byte>,2,1
endm
parmW macro n
?pp <n>,<word>,2,2
endm
parmD macro n
ife ?PLM
irp x,<n>
?pp <&&x>,<dword>,0,4
?pp <off_&&x>,<word>,2,2
?pp <seg_&&x>,<word>,2,2
endm
else
irp x,<n>
?pp <seg_&&x>,<word>,2,2
?pp <off_&&x>,<word>,2,2
?pp <&&x>,<dword>,0,4
endm
endif
endm
parmQ macro n
?pp <n>,<qword>,8,8
endm
parmT macro n
?pp <n>,<tbyte>,10,10
endm
if sizec
parmCP macro n
parmD <n>
endm
else
parmCP macro n
parmW <n>
endm
endif
if sized
parmDP macro n
parmD <n>
endm
else
parmDP macro n
parmW <n>
endm
endif
?pp macro n,t,l,s
if ?cpd
.xcref
irp x,<n>
.xcref ?t&&x
?t&&x=s
ife ?PLM
?pp1 x,<t>,,,%(?po+?adj)
?po=?po+l
else
?PLMPrevParm=?PLMPrevParm+1
?po=?po+l
?pp1 x,<t>,%?po,%?adj,,%?PLMPrevParm,%(?PLMPrevParm-1)
endif
endm
.cref
else
??error <parm(s) "&n" declared outside proc def>
endif
endm
?pp1 macro n,t,o,a,b,cpc,ppc
ife ?PLM
n equ (t ptr [bp+b])
else
.xcref
.xcref ?PLMParm&cpc
.cref
?PLMParm&cpc &macro po
uconcat <n>,,<equ>,,<(t ptr [bp+>,%(a+po-o),<])>
?PLMParm&ppc po
purge ?PLMParm&cpc
&endm
endif
endm
ifndef ?NOPARMR
if ?pmd
parmR macro n,r,r2
??error <Sorry: ParmR can't be used with PMODE=1>
endm
else
.xcref
.xcref ?pr,parmR
.cref
parmR macro n,r,r2
?pr n,r,r2,%?rp,%(?ia+2)
endm
?pr macro n,r,r2,i,o
.xcref
ifnb <r2>
parmR seg_&n,r
parmR off_&n,r2
n equ (dword ptr [bp-o-2])
.xcref ?t&n
?t&n=4
else
.xcref ?rp&i
?rp&i=0
ifdef ?&r
?rp&i=?&r
endif
if ??? or (?cpd eq 0) or (?rp&i eq 0)
??error <invalid parmR encountered: &n,&r>
exitm
endif
n equ (word ptr [bp-o])
?t&n=2
irp x,<bh,ch,dh,bl,cl,dl,ah,al>
if ?&&x eq ?&r
n equ (byte ptr [bp-o])
?t&n=1
exitm
endif
endm
?ia=?ia+2
?rp=?rp+1
endif
.cref
endm
endif
endif
.xcref
.xcref localB,localW,localD,localQ,localT,localCP,localDP,localV
.cref
localB macro n
?aloc <n>,<byte ptr>,1,1,0
endm
localW macro n
?aloc <n>,<word ptr>,2,2,1
endm
localD macro n
irp x,<n>
?aloc <seg_&&x>,<word ptr>,2,2,1
?aloc <off_&&x>,<word ptr>,2,2,1
?aloc <&&x>,<dword ptr>,0,4,1
endm
endm
localQ macro n
?aloc <n>,<qword ptr>,8,8,1
endm
localT macro n
?aloc <n>,<tbyte ptr>,10,10,1
endm
if sizec
localCP macro n
localD <n>
endm
else
localCP macro n
localW <n>
endm
endif
if sized
localDP macro n
localD <n>
endm
else
localDP macro n
localW <n>
endm
endif
localV macro n,a
?aloc <n>,,%(a),0,1
endm
?aloc macro n,t,l,s,a
if ?cpd
.xcref
irp x,<n>
???=???+l
if a
???=((??? + 1) and 0fffeh)
endif
?al1 x,<t>,%(???+?ia)
.xcref ?t&&x
?t&&x=s
endm
.cref
else
??error <locals "&n" declared outside procedure def>
endif
endm
?al1 macro n,t,o
n equ (t [bp-o])
endm
?gcc macro s,i,cc
s = i
ifnb <cc>
ifidn <cc>,<C>
s=0
endif
ifidn <cc>,<PLM>
s=1
endif
ifidn <cc>,<PASCAL>
s=1
endif
endif
endm
ifndef ?NOGLOBAL
.xcref
.xcref globalB,globalW,globalD,globalQ,globalT,globalCP,globalDP
.cref
globalB macro n,i,s,c
?ad <n>,1
?dd n,1,<byte>,<db>,<i>,<s>,<c>
endm
globalW macro n,i,s,c
?ad <n>,2
?dd n,1,<word>,<dw>,<i>,<s>,<c>
endm
globalD macro n,i,s,c
?ad <n>,4
?dd n,1,<dword>,<dd>,<i>,<s>,<c>
off_&n equ n
seg_&n equ n[2]
endm
globalQ macro n,i,s,c
?ad <n>,8
?dd n,1,<qword>,<dq>,<i>,<s>,<c>
endm
globalT macro n,i,s,c
?ad <n>,10
?dd n,1,<tbyte>,<dt>,<i>,<s>,<c>
endm
if sizec
globalCP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalCP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
if sized
globalDP macro n,i,s,c
globalD n,<i>,<s>,<c>
endm
else
globalDP macro n,i,s,c
globalW n,<i>,<s>,<c>
endm
endif
endif
ifndef ?NOSTATIC
.xcref
.xcref staticB,staticW,staticD,staticQ,staticT,staticCP,staticDP
.cref
staticB macro n,i,s
?ad <n>,1
?dd n,0,<byte>,<db>,<i>,<s>,<PLM>
endm
staticW macro n,i,s
?ad <n>,2
?dd n,0,<word>,<dw>,<i>,<s>,<PLM>
endm
staticD macro n,i,s
?ad <n>,4
?dd n,0,<dword>,<dd>,<i>,<s>,<PLM>
endm
staticQ macro n,i,s
?ad <n>,8
?dd n,0,<qword>,<dq>,<i>,<s>,<PLM>
endm
staticT macro n,i,s
?ad <n>,10
?dd n,0,<tbyte>,<dt>,<i>,<s>,<PLM>
endm
if sizec
staticCP macro n,i,s
staticD n,<i>,<s>
endm
else
staticCP macro n,i,s
staticW n,<i>,<s>
endm
endif
if sized
staticDP macro n,i,s
staticD n,<i>,<s>
endm
else
staticDP macro n,i,s
staticW n,<i>,<s>
endm
endif
endif
?dd macro n,p,t,d,i,s,c
?gcc ?dd2,%?PLM,<c>
ife ?dd2
n label t
?dd1 _&n,p,<d>,<i>,<s>
else
?dd1 n,p,<d>,<i>,<s>
endif
endm
?dd1 macro n,p,d,i,s
if p
public n
endif
ifb <s>
n d i
else
ifb <i>
n d s dup (?)
else
n d s dup (i)
endif
endif
endm
ifndef ?NOEXTERN
.xcref
.xcref ?ex1,?ex2,externB,externW,externD,externQ,externT
.xcref externNP,externFP,externP,externCP,externDP,externA
.cref
?ex2 = 0
externA macro n,c
?ex1 <n>,40h,<abs>,<c>,<>
endm
externB macro n,c
?ex1 <n>,1,<byte>,<c>,<>
endm
externW macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
externD macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
externQ macro n,c
?ex1 <n>,8,<qword>,<c>,<>
endm
externT macro n,c
?ex1 <n>,10,<tbyte>,<c>,<>
endm
externNP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
externFP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
if sizec
externP macro n,c
?ex1 <n>,4,<far>,<c>,<cc>
endm
else
externP macro n,c
?ex1 <n>,2,<near>,<c>,<cc>
endm
endif
if sizec
externCP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externCP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
if sized
externDP macro n,c
?ex1 <n>,4,<dword>,<c>,<>
endm
else
externDP macro n,c
?ex1 <n>,2,<word>,<c>,<>
endm
endif
?ex1 macro n,s,d,c,scv
?gcc ?ex2,%?PLM,<c>
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?ex2
extrn _&&x:&d
x equ _&&x
else
extrn x:&d
endif
ifidn <scv>,<cc>
.xcref
.xcref ?CC&&x
.cref
?CC&&x=?ex2
endif
endm
endm
endif
ifndef ?NOLABEL
.xcref
.xcref ?lb1,?lblpu,?lb2
.xcref labelB,labelW,labelD,labelQ,labelT
.xcref labelNP,labelFP,labelP,labelCP,labelDP
.cref
?lblpu = 0
?lb2 = 0
labelB macro n,c
?lb1 <n>,1,<byte>,<c>
endm
labelW macro n,c
?lb1 <n>,2,<word>,<c>
endm
labelD macro n,c
?lb1 <n>,4,<dword>,<c>
endm
labelQ macro n,c
?lb1 <n>,8,<qword>,<c>
endm
labelT macro n,c
?lb1 <n>,10,<tbyte>,<c>
endm
labelNP macro n,c
?lb1 <n>,2,<near>,<c>
endm
labelFP macro n,c
?lb1 <n>,4,<far>,<c>
endm
if sizec
labelP macro n,c
?lb1 <n>,4,<far>,<c>
endm
else
labelP macro n,c
?lb1 <n>,2,<near>,<c>
endm
endif
if sizec
labelCP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelCP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
if sized
labelDP macro n,c
?lb1 <n>,4,<dword>,<c>
endm
else
labelDP macro n,c
?lb1 <n>,2,<word>,<c>
endm
endif
?lb1 macro n,s,d,c
?gcc ?lb2,%?PLM,<c>
?lblpu=0
irp x,<n>
ifidn <x>,<PUBLIC>
?lblpu=1
else
.xcref
.xcref ?t&&x
.cref
?t&&x=s
ife ?lb2
if ?lblpu
public _&&x
endif
_&&x label &d
x equ _&&x
else
if ?lblpu
public x
endif
x label &d
endif
endif
endm
endm
endif
ifndef ?NODEF
.xcref
.xcref defB,defW,defD,defQ,defT,defCP,defDP
.cref
defB macro n
?ad <n>,1
endm
defW macro n
?ad <n>,2
endm
defD macro n
?ad <n>,4
endm
defQ macro n
?ad <n>,8
endm
defT macro n
?ad <n>,10
endm
if sizec
defCP macro n
defD <n>
endm
else
defCP macro n
defW <n>
endm
endif
if sized
defDP macro n
defD <n>
endm
else
defDP macro n
defW <n>
endm
endif
endif
?ad macro n,s
irp x,<n>
.xcref
.xcref ?t&&x
.cref
?t&&x=s
endm
endm
ifndef ?NOPTR
.xcref
.xcref regPtr,farPtr
.cref
regPtr macro n,s,o
farPtr n,s,o
endm
farPtr macro n,s,o
.xcref
.xcref ?t&n
.cref
n &macro
	push	s
	push	o
&endm
?t&n=80h
endm
endif
arg macro a
irp x,<a>
?argc=?argc+1
?atal <x>,%?argc
endm
endm
?atal macro n,i
.xcref
.xcref ?ali&i
.cref
?ali&i &macro
?ap n
&endm
endm
?ap macro n
?argl=?argl+2
ifdef ?t&n
ife ?t&n-1
	push	word ptr (n)
exitm
endif
ife ?t&n-2
	push	n
exitm
endif
ife ?t&n-4
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+2
exitm
endif
ife ?t&n-8
	push	word ptr (n)[6]
	push	word ptr (n)[4]
	push	word ptr (n)[2]
	push	word ptr (n)
?argl=?argl+6
exitm
endif
if ?t&n and 80h
n
?argl=?argl+2
exitm
endif
ife ?t&n
	push	word ptr (n)
exitm
endif
endif
	push	n
endm
cCall macro n,a,c
ifnb <a>
arg <a>
endif
mpush %?rsl
ifdef ?CC&n
?cCall1=?CC&n
else
?cCall1=?PLM
endif
ifnb <c>
?gcc ?cCall1,%?cCall1,<c>
endif
?argl=0
ife ?cCall1
?acb=?argc
else
?acb=1
endif
rept ?argc
uconcat <?ali>,%?acb
uconcat <purge>,,<?ali>,%?acb
ife ?cCall1
?acb=?acb-1
else
?acb=?acb+1
endif
endm
	call	n
if ((?cCall1 eq 0) and (?argl ne 0))
	add	sp,?argl
endif
mpop %?rsl
?rsl=0
?argc= 0
?argl= 0
endm
cProc macro n,cf,a
if ?cpd
?utpe
endif
?cpd=1
???=0
?argc=0
?ba=0
?po=0
?pu=0
?ia=0
?adj=4
?rp=0
?uf=0
?wfp=?WIN
?ff=0
?pas=0
?pcc=?PLM
?lds=0
?exp=0
ifnb <a>
?ri ?pas,<a>
endif
?pc=sizec
?nd=?nodata1
?nx=0
irp x,<cf>
ifidn <x>,<FAR>
?pc=1
endif
ifidn <x>,<NEAR>
?pc=0
endif
ifidn <x>,<PUBLIC>
?pu=1
endif
ifidn <x>,<SMALL>
?uf=1
endif
ifidn <x>,<DATA>
?nd=0
endif
ifidn <x>,<NODATA>
?nd=1
endif
ifidn <x>,<ATOMIC>
?nx=1
endif
ifidn <x>,<C>
?pcc=0
endif
ifidn <x>,<PLM>
?pcc=1
endif
ifidn <x>,<PASCAL>
?pcc=1
endif
ifidn <x>,<WIN>
?wfp=1
endif
ifidn <x>,<NONWIN>
?wfp=0
endif
ifidn <x>,<LOADDS>
?lds=1
endif
ifidn <x>,<EXPORTED>
?exp=1
endif
endm
if ?pcc
?PLMPrevParm=0
.xcref
.xcref ?PLMParm0
.cref
?PLMParm0 &macro
purge ?PLMParm0
&endm
endif
.xcref
.xcref ?CC&n
.cref
?CC&n=?pcc
if (?nx eq 1) and (?nd eq 0)
?nx = 0
??error <ATOMIC specified without NODATA - ATOMIC ignored>
endif
if ?pc
if ?wfp+?exp+?lds
ife ?nx
ife ?pmd
?ia=2
endif
?pas = ?pas and (not ?ds)
endif
endif
?adj=?adj+2
else
?wfp=0
endif
ife ?386regs
?pas = ?pas and (not (?sp+?cs+?ss))
endif
if ?uf
if ?386regs
?pas = ?pas and (not (?si+?di))
else
?pas = ?pas and (not (?bp+?si+?di))
endif
endif
ife ?pcc
?pg <_&n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
else
?pg <n>,%?pu,%?pc,%?pas,%?wfp,<n>,%?pcc
endif
endm
?pg macro n,p,c,a,w,nnu,cc
.xcref
if ?uf
if ?nd
??error <NODATA encountered in &n - user frame ignored>
?uf=0
endif
endif
.xcref cBegin
cBegin &macro g
.xcref
if cc
uconcat <?PLMParm>,%?PLMPrevParm,%?po
endif
if ?uf
if ?rp
??error <parmR encountered in &n - user frame ignored>
?uf=0
endif
endif
?pg1 <n>,c,a,%?po,w,%?uf,%?nd,%?rp,cc
?cpd=0
?argc=0
?ba=1
???=(???+1) and 0fffeh
if p
public n
endif
ife c
n proc near
else
n proc far
endif
ife cc
nnu equ n
endif
ifidn <g>,<nogen>
if ???+?po+a+?rp
??_out <cBegin - possible invalid use of nogen>
endif
else
if ?uf
?mf c,%???,%?po
mpush a
else
if w+?exp+?lds
if ?pmd
ife ?nd
if ?lds
mov ax,_DATA
else
if ?exp
mov ax,ds
nop
endif
endif
endif
ife ?nx
if ???+?po
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
push ds
if ?lds+?exp
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
else
ife ?nd
	mov	ax,ds
	nop
endif
ife ?nx
ife ?DOS5
	inc	bp
endif
	push	bp
	mov	bp,sp
	push	ds
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
ife ?nd
	mov	ds,ax
endif
endif
else
if ?pmd
if ?exp
mov ax,ds
nop
else
if ?lds
mov ax,_DATA
endif
endif
if ?ff+???+?po+?rp
if ?chkstk1
push bp
mov bp,sp
else
if ???
enter ???,0
else
push bp
mov bp,sp
endif
endif
endif
if ?exp+?lds
push ds
mov ds,ax
endif
else
if ?ff+???+?po+?rp
	push	bp
	mov	bp,sp
endif
endif
endif
if ?rp
?uf=0
rept ?rp
uconcat mpush,,?rp,%?uf
?uf=?uf+1
endm
endif
if ???
if ?chkstk1
ifdef ?CHKSTKPROC
?CHKSTKPROC %???
else
	mov	ax,???
ife cc
	call	_chkstk
else
	call	chkstk
endif
endif
else
ife ?pmd
	sub	sp,???
endif
endif
endif
mpush a
endif
ifdef ?PROFILE
if c
	call	StartNMeas
endif
endif
endif
.cref
purge cBegin
&endm
.xcref ?utpe
?utpe &macro
??error <unterminated procedure definition: "&n">
&endm
.cref
endm
?pg1 macro n,c,a,o,w,f,d,r,cc
.xcref
.xcref cEnd
cEnd &macro g
.xcref
?ba=0
ifidn <g>,<nogen>
if o+a+r
??_out <cEnd - possible invalid use of nogen>
endif
else
ifdef ?PROFILE
if c
call StopNMeas
endif
endif
mpop a
if f
	db	0c3h
else
if w+?exp+?lds
if ?pmd
ife ?nx
pop ds
endif
ife ?nx
if ?chkstk1+???+?po
leave
endif
else
if ?ff+???+?po+?rp
leave
endif
endif
else
ife ?nx
if (?TF eq 0) or (???+?rp)
	lea	sp,-2[bp]
endif
	pop	ds
	pop	bp
ife ?DOS5
	dec	bp
endif
else
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
if ???+?po+?rp
	pop	bp
endif
endif
endif
else
if ?pmd
if ?ff+???+?po+?rp
leave
endif
else
if ?ff+???+?po+?rp
if (?TF eq 0) or (???+?rp)
	mov	sp,bp
endif
	pop	bp
endif
endif
endif
ife cc
	ret
else
	ret	o
endif
endif
endif
n endp
.cref
purge cEnd
&endm
.cref
endm
assumes macro s,ln
ifndef ln&_assumes
assume s:ln
else
ln&_assumes s
endif
endm
createSeg macro n,ln,a,co,cl,grp
ifnb <grp>
addseg grp,n
else
ln&OFFSET equ offset n:
ln&BASE equ n
?cs3 <ln>,<n>
endif
ifnb <cl>
n segment a co '&cl'
else
n segment a co
endif
n ends
?cs1 <ln>,<n>
endm
addseg macro grp,seg
.xcref
.xcref grp&_def
.cref
ifndef grp&_def
grp&_def=0
endif
if grp&_def ne ASMpass
.xcref
.xcref grp&_add
.cref
grp&_add &macro s
grp&_in <seg>,s
&endm
.xcref
.xcref grp&_in
.cref
grp&_in &macro sl,s
ifb <s>
grp group sl
else
grp&_add &macro ns
grp&_in <sl,s>,ns
&endm
endif
&endm
grp&_def=ASMpass
else
grp&_add seg
endif
endm
defgrp macro grp,ln
addseg grp
ifnb <ln>
irp x,<ln>
?cs3 <&x>,<grp>
x&&OFFSET equ offset grp:
x&&BASE equ grp
endm
endif
endm
?cs1 macro ln,n
.xcref
.xcref ln&_sbegin
.cref
ln&_sbegin &macro
.xcref
.xcref ?mf
.cref
?mf &&macro c,l,p
if c
	extrn	n&_FARFRAME:near
	call	n&_FARFRAME
else
	extrn	n&_NEARFRAME:near
	call	n&_NEARFRAME
endif
	db	l shr 1
	db	p shr 1
&&endm
?cs2 <ln>,<n>
n segment
&endm
endm
?cs2 macro ln,n
.xcref
.xcref sEnd
.cref
sEnd &macro
n ends
purge ?mf
purge sEnd
&endm
endm
?cs3 macro ln,n
.xcref
.xcref ln&_assumes
.cref
ln&_assumes &macro s
assume s:&n
&endm
endm
.xcref
.xcref sBegin
.cref
sBegin macro ln
ln&_sbegin
endm
ife ?DF
createSeg _TEXT,Code,word,public,CODE
ife ?nodata1
createSeg _DATA,Data,word,public,DATA,DGROUP
defgrp DGROUP,Data
endif
if ?chkstk1
ifndef ?CHKSTKPROC
externp <chkstk>
endif
endif
endif
errnz macro x
if2
if x
errnz1 <x>,%(x)
endif
endif
endm
errnz1 macro x1,x2
= *errnz* x1 = x2
.err
endm
errn$ macro l,x
errnz <offset $ - offset l x>
endm
ifdef ?PROFILE
externFP <StartNMeas,StopNMeas>
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\coguid.h ===
/*****************************************************************************\
*                                                                             *
* coguid.h -    Master definition of GUIDs for compobj.dll                    *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage 
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense 
   that part of the GUID range owned by OLE was used to define them.  
   
   NOTE: The second byte of all of these GUIDs is 0.
*/
   

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* interface to inform object of number of external connections */
DEFINE_OLEGUID(IID_IExternalConnection, 0x00000019L, 0, 0);

/* NOTE: LSB 0x1a through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\cobjps.h ===
/*****************************************************************************\
*                                                                             *
* cobjps.h -    Definitions for writing standard proxies and stubs			  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _COBJPS_H_ )
#define _COBJPS_H_


/****** IRpcChannel Interface ***********************************************/

interface IRpcChannel : IUnknown 
{
    STDMETHOD(GetStream)(REFIID iid, int iMethod, BOOL fSend,
                     BOOL fNoWait, DWORD size, IStream FAR* FAR* ppIStream) = 0;
    STDMETHOD(Call)(IStream FAR* pIStream) = 0;
    STDMETHOD(GetDestCtx)(DWORD FAR* lpdwDestCtx, LPVOID FAR* lplpvDestCtx) = 0;
    STDMETHOD(IsConnected)(void) = 0;
};


/****** IRpcProxy Interface *************************************************/

// IRpcProxy is an interface implemented by proxy objects.  A proxy object has
// exactly the same interfaces as the real object in addition to IRpcProxy.
//

interface IRpcProxy : IUnknown 
{
    STDMETHOD(Connect)(IRpcChannel FAR* pRpcChannel) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
};


/****** IRpcStub Interface **************************************************/

// IRpcStub is an interface implemented by stub objects.  
//

interface IRpcStub : IUnknown
{
    STDMETHOD(Connect)(IUnknown FAR* pUnk) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
    STDMETHOD(Invoke)(REFIID iid, int iMethod, IStream FAR* pIStream,
            DWORD dwDestCtx, LPVOID lpvDestCtx) = 0;
    STDMETHOD_(BOOL, IsIIDSupported)(REFIID iid) = 0;
    STDMETHOD_(ULONG, CountRefs)(void) = 0;
};


/****** IPSFactory Interface ************************************************/

// IPSFactory - creates proxies and stubs
//

interface IPSFactory : IUnknown
{
    STDMETHOD(CreateProxy)(IUnknown FAR* pUnkOuter, REFIID riid, 
        IRpcProxy FAR* FAR* ppProxy, void FAR* FAR* ppv) = 0;
    STDMETHOD(CreateStub)(REFIID riid, IUnknown FAR* pUnkServer,
        IRpcStub FAR* FAR* ppStub) = 0;
};

#endif // _COBJPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\conio.h ===
/***
*conio.h - console and port I/O declarations
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   the MS C V2.03 compatible console and port I/O routines.
*
****/

#ifndef _INC_CONIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* function prototypes */

#ifndef _WINDOWS
char * __cdecl _cgets(char *);
int __cdecl _cprintf(const char *, ...);
int __cdecl _cputs(const char *);
int __cdecl _cscanf(const char *, ...);
int __cdecl _getch(void);
int __cdecl _getche(void);
#endif 
int __cdecl _inp(unsigned);
unsigned __cdecl _inpw(unsigned);
#ifndef _WINDOWS
int __cdecl _kbhit(void);
#endif 
int __cdecl _outp(unsigned, int);
unsigned __cdecl _outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl _putch(int);
int __cdecl _ungetch(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _WINDOWS
char * __cdecl cgets(char *);
int __cdecl cprintf(const char *, ...);
int __cdecl cputs(const char *);
int __cdecl cscanf(const char *, ...);
int __cdecl getch(void);
int __cdecl getche(void);
#endif 
int __cdecl inp(unsigned);
unsigned __cdecl inpw(unsigned);
#ifndef _WINDOWS
int __cdecl kbhit(void);
#endif 
int __cdecl outp(unsigned, int);
unsigned __cdecl outpw(unsigned, unsigned);
#ifndef _WINDOWS
int __cdecl putch(int);
int __cdecl ungetch(int);
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CONIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\colordlg.h ===
/*****************************************************************************\
*                                                                             *
* colordlg.h -  Common dialog color dialog's control id numbers               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COLORDLG
#define _INC_COLORDLG

#define DLG_COLOR          10

#define COLOR_HUESCROLL   700	       /* color dialog */
#define COLOR_SATSCROLL   701
#define COLOR_LUMSCROLL   702
#define COLOR_HUE         703
#define COLOR_SAT         704
#define COLOR_LUM         705
#define COLOR_RED         706
#define COLOR_GREEN       707
#define COLOR_BLUE        708
#define COLOR_CURRENT     709
#define COLOR_RAINBOW     710
#define COLOR_SAVE        711
#define COLOR_ADD         712
#define COLOR_SOLID       713
#define COLOR_TUNE        714
#define COLOR_SCHEMES     715
#define COLOR_ELEMENT     716
#define COLOR_SAMPLES     717
#define COLOR_PALETTE     718
#define COLOR_MIX         719
#define COLOR_BOX1        720
#define COLOR_CUSTOM1     721

#define COLOR_HUEACCEL    723
#define COLOR_SATACCEL    724
#define COLOR_LUMACCEL    725
#define COLOR_REDACCEL    726
#define COLOR_GREENACCEL  727
#define COLOR_BLUEACCEL   728

#define NUM_BASIC_COLORS   48
#define NUM_CUSTOM_COLORS  16

#endif  /* !_INC_COLORDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\commdlg.h ===
/*****************************************************************************\
*                                                                             *
* commdlg.h -   Common dialog functions, types, and definitions               *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMMDLG
#define _INC_COMMDLG

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

typedef struct tagOFN
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HINSTANCE hInstance;
    LPCSTR  lpstrFilter;
    LPSTR   lpstrCustomFilter;
    DWORD   nMaxCustFilter;
    DWORD   nFilterIndex;
    LPSTR   lpstrFile;
    DWORD   nMaxFile;
    LPSTR   lpstrFileTitle;
    DWORD   nMaxFileTitle;
    LPCSTR  lpstrInitialDir;
    LPCSTR  lpstrTitle;
    DWORD   Flags;
    UINT    nFileOffset;
    UINT    nFileExtension;
    LPCSTR  lpstrDefExt;
    LPARAM  lCustData;
    UINT    (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
}   OPENFILENAME;
typedef OPENFILENAME FAR* LPOPENFILENAME;

BOOL    WINAPI GetOpenFileName(OPENFILENAME FAR*);
BOOL    WINAPI GetSaveFileName(OPENFILENAME FAR*);
int     WINAPI GetFileTitle(LPCSTR, LPSTR, UINT);

#define OFN_READONLY                 0x00000001
#define OFN_OVERWRITEPROMPT          0x00000002
#define OFN_HIDEREADONLY             0x00000004
#define OFN_NOCHANGEDIR              0x00000008
#define OFN_SHOWHELP                 0x00000010
#define OFN_ENABLEHOOK               0x00000020
#define OFN_ENABLETEMPLATE           0x00000040
#define OFN_ENABLETEMPLATEHANDLE     0x00000080
#define OFN_NOVALIDATE               0x00000100
#define OFN_ALLOWMULTISELECT         0x00000200
#define OFN_EXTENSIONDIFFERENT       0x00000400
#define OFN_PATHMUSTEXIST            0x00000800
#define OFN_FILEMUSTEXIST            0x00001000
#define OFN_CREATEPROMPT             0x00002000
#define OFN_SHAREAWARE               0x00004000
#define OFN_NOREADONLYRETURN         0x00008000
#define OFN_NOTESTFILECREATE         0x00010000

/* Return values for the registered message sent to the hook function
 * when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
 * filename to be accepted, OFN_SHARENOWARN rejects the name but puts
 * up no warning (returned when the app has already put up a warning
 * message), and OFN_SHAREWARN puts up the default warning message
 * for sharing violations.
 *
 * Note:  Undefined return values map to OFN_SHAREWARN, but are
 *        reserved for future use.
 */

#define OFN_SHAREFALLTHROUGH     2
#define OFN_SHARENOWARN          1
#define OFN_SHAREWARN            0

typedef struct tagCHOOSECOLOR
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HWND    hInstance;
    COLORREF rgbResult;
    COLORREF FAR* lpCustColors;
    DWORD   Flags;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpTemplateName;
} CHOOSECOLOR;
typedef CHOOSECOLOR FAR *LPCHOOSECOLOR;

BOOL    WINAPI ChooseColor(CHOOSECOLOR FAR*);

#define CC_RGBINIT               0x00000001
#define CC_FULLOPEN              0x00000002
#define CC_PREVENTFULLOPEN       0x00000004
#define CC_SHOWHELP              0x00000008
#define CC_ENABLEHOOK            0x00000010
#define CC_ENABLETEMPLATE        0x00000020
#define CC_ENABLETEMPLATEHANDLE  0x00000040

typedef struct tagFINDREPLACE
{
    DWORD    lStructSize;            /* size of this struct 0x20 */
    HWND     hwndOwner;              /* handle to owner's window */
    HINSTANCE hInstance;             /* instance handle of.EXE that
                                      * contains cust. dlg. template
                                      */
    DWORD    Flags;                  /* one or more of the FR_?? */
    LPSTR    lpstrFindWhat;          /* ptr. to search string    */
    LPSTR    lpstrReplaceWith;       /* ptr. to replace string   */
    UINT     wFindWhatLen;           /* size of find buffer      */
    UINT     wReplaceWithLen;        /* size of replace buffer   */
    LPARAM   lCustData;              /* data passed to hook fn.  */
    UINT    (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
                                     /* ptr. to hook fn. or NULL */
    LPCSTR   lpTemplateName;         /* custom template name     */
} FINDREPLACE;
typedef FINDREPLACE FAR *LPFINDREPLACE;

#define FR_DOWN 			0x00000001
#define FR_WHOLEWORD			0x00000002
#define FR_MATCHCASE			0x00000004
#define FR_FINDNEXT			0x00000008
#define FR_REPLACE			0x00000010
#define FR_REPLACEALL			0x00000020
#define FR_DIALOGTERM			0x00000040
#define FR_SHOWHELP			0x00000080
#define FR_ENABLEHOOK			0x00000100
#define FR_ENABLETEMPLATE		0x00000200
#define FR_NOUPDOWN			0x00000400
#define FR_NOMATCHCASE			0x00000800
#define FR_NOWHOLEWORD			0x00001000
#define FR_ENABLETEMPLATEHANDLE 	0x00002000
#define FR_HIDEUPDOWN			0x00004000
#define FR_HIDEMATCHCASE		0x00008000
#define FR_HIDEWHOLEWORD		0x00010000

HWND    WINAPI FindText(FINDREPLACE FAR*);
HWND    WINAPI ReplaceText(FINDREPLACE FAR*);

typedef struct tagCHOOSEFONT
{
    DWORD	    lStructSize;	/* */
    HWND	    hwndOwner;		/* caller's window handle   */
    HDC 	    hDC;		/* printer DC/IC or NULL    */
    LOGFONT FAR*    lpLogFont;          /* ptr. to a LOGFONT struct */
    int		    iPointSize;		/* 10 * size in points of selected font */
    DWORD	    Flags;		/* enum. type flags	    */
    COLORREF        rgbColors;          /* returned text color      */
    LPARAM          lCustData;          /* data passed to hook fn.  */
    UINT (CALLBACK* lpfnHook)(HWND, UINT, WPARAM, LPARAM);
					/* ptr. to hook function    */
    LPCSTR          lpTemplateName;     /* custom template name     */
    HINSTANCE       hInstance;          /* instance handle of.EXE that
					 * contains cust. dlg. template
					 */
    LPSTR	    lpszStyle;		/* return the style field here 
					 * must be LF_FACESIZE or bigger */
    UINT            nFontType;          /* same value reported to the EnumFonts
					 * call back with the extra FONTTYPE_ 
					 * bits added */
    int		    nSizeMin;		/* minimum pt size allowed & */
    int		    nSizeMax;		/* max pt size allowed if    */
					/* CF_LIMITSIZE is used      */
} CHOOSEFONT;
typedef CHOOSEFONT FAR *LPCHOOSEFONT;

BOOL WINAPI ChooseFont(CHOOSEFONT FAR*);

#define CF_SCREENFONTS		     0x00000001
#define CF_PRINTERFONTS 	     0x00000002
#define CF_BOTH 		     (CF_SCREENFONTS | CF_PRINTERFONTS)
#define CF_SHOWHELP		     0x00000004L
#define CF_ENABLEHOOK		     0x00000008L
#define CF_ENABLETEMPLATE	     0x00000010L
#define CF_ENABLETEMPLATEHANDLE      0x00000020L
#define CF_INITTOLOGFONTSTRUCT       0x00000040L
#define CF_USESTYLE		     0x00000080L
#define CF_EFFECTS		     0x00000100L
#define CF_APPLY		     0x00000200L
#define CF_ANSIONLY		     0x00000400L
#define CF_NOVECTORFONTS	     0x00000800L
#define CF_NOOEMFONTS		     CF_NOVECTORFONTS
#define CF_NOSIMULATIONS	     0x00001000L
#define CF_LIMITSIZE		     0x00002000L
#define CF_FIXEDPITCHONLY	     0x00004000L
#define CF_WYSIWYG		     0x00008000L /* must also have CF_SCREENFONTS & CF_PRINTERFONTS */
#define CF_FORCEFONTEXIST	     0x00010000L
#define CF_SCALABLEONLY		     0x00020000L
#define CF_TTONLY		     0x00040000L
#define CF_NOFACESEL		     0x00080000L
#define CF_NOSTYLESEL		     0x00100000L
#define CF_NOSIZESEL		     0x00200000L

/* these are extra nFontType bits that are added to what is returned to the
 * EnumFonts callback routine */

#define SIMULATED_FONTTYPE	0x8000
#define PRINTER_FONTTYPE	0x4000
#define SCREEN_FONTTYPE		0x2000
#define BOLD_FONTTYPE		0x0100
#define ITALIC_FONTTYPE		0x0200
#define REGULAR_FONTTYPE	0x0400

#define WM_CHOOSEFONT_GETLOGFONT	(WM_USER + 1)


/* strings used to obtain unique window message for communication
 * between dialog and caller
 */
#define LBSELCHSTRING  "commdlg_LBSelChangedNotify"
#define SHAREVISTRING  "commdlg_ShareViolation"
#define FILEOKSTRING   "commdlg_FileNameOK"
#define COLOROKSTRING  "commdlg_ColorOK"
#define SETRGBSTRING   "commdlg_SetRGBColor"
#define FINDMSGSTRING  "commdlg_FindReplace"
#define HELPMSGSTRING  "commdlg_help"

/* HIWORD values for lParam of commdlg_LBSelChangeNotify message */
#define CD_LBSELNOITEMS -1
#define CD_LBSELCHANGE   0
#define CD_LBSELSUB      1
#define CD_LBSELADD      2

typedef struct tagPD
{
    DWORD   lStructSize;
    HWND    hwndOwner;
    HGLOBAL hDevMode;
    HGLOBAL hDevNames;
    HDC     hDC;
    DWORD   Flags;
    UINT    nFromPage;
    UINT    nToPage;
    UINT    nMinPage;
    UINT    nMaxPage;
    UINT    nCopies;
    HINSTANCE hInstance;
    LPARAM  lCustData;
    UINT    (CALLBACK* lpfnPrintHook)(HWND, UINT, WPARAM, LPARAM);
    UINT    (CALLBACK* lpfnSetupHook)(HWND, UINT, WPARAM, LPARAM);
    LPCSTR  lpPrintTemplateName;
    LPCSTR  lpSetupTemplateName;
    HGLOBAL hPrintTemplate;
    HGLOBAL hSetupTemplate;
} PRINTDLG;
typedef PRINTDLG  FAR* LPPRINTDLG;

BOOL    WINAPI PrintDlg(PRINTDLG FAR*);

#define PD_ALLPAGES                  0x00000000
#define PD_SELECTION                 0x00000001
#define PD_PAGENUMS                  0x00000002
#define PD_NOSELECTION               0x00000004
#define PD_NOPAGENUMS                0x00000008
#define PD_COLLATE                   0x00000010
#define PD_PRINTTOFILE               0x00000020
#define PD_PRINTSETUP                0x00000040
#define PD_NOWARNING                 0x00000080
#define PD_RETURNDC                  0x00000100
#define PD_RETURNIC                  0x00000200
#define PD_RETURNDEFAULT             0x00000400
#define PD_SHOWHELP                  0x00000800
#define PD_ENABLEPRINTHOOK           0x00001000
#define PD_ENABLESETUPHOOK           0x00002000
#define PD_ENABLEPRINTTEMPLATE       0x00004000
#define PD_ENABLESETUPTEMPLATE       0x00008000
#define PD_ENABLEPRINTTEMPLATEHANDLE 0x00010000
#define PD_ENABLESETUPTEMPLATEHANDLE 0x00020000
#define PD_USEDEVMODECOPIES          0x00040000
#define PD_DISABLEPRINTTOFILE        0x00080000
#define PD_HIDEPRINTTOFILE           0x00100000

typedef struct tagDEVNAMES
{
    UINT wDriverOffset;
    UINT wDeviceOffset;
    UINT wOutputOffset;
    UINT wDefault;
} DEVNAMES;
typedef DEVNAMES FAR* LPDEVNAMES;

#define DN_DEFAULTPRN      0x0001

DWORD   WINAPI CommDlgExtendedError(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_COMMDLG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\compobj.h ===
/*****************************************************************************\
*                                                                             *
* compobj.h - 	Component object model definitions							  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _COMPOBJ_H_ )
#define _COMPOBJ_H_

/****** Linkage Definitions *************************************************/

/*
 *      These are macros for declaring methods/functions.  They exist so that
 *      control over the use of keywords (CDECL, PASCAL, __export,
 *      extern "C") resides in one place, and because this is the least
 *      intrusive way of writing function declarations that do not have
 *      to be modified in order to port to the Mac.
 *
 *      The macros without the trailing underscore are for functions/methods
 *      which a return value of type HRESULT; this is by far the most common
 *      case in OLE. The macros with a trailing underscore take a return
 *      type as a parameter.
 *
 * WARNING: STDAPI is hard coded into the LPFNGETCLASSOBJECT typedef below.
 */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _MAC
#define STDMETHODCALLTYPE
#define STDAPICALLTYPE          pascal

#define STDAPI                  EXTERN_C STDAPICALLTYPE HRESULT
#define STDAPI_(type)           EXTERN_C STDAPICALLTYPE type

#else   //  !_MAC

#ifdef WIN32
#define STDMETHODCALLTYPE       __export __cdecl
#define STDAPICALLTYPE          __export __stdcall

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#else
#define STDMETHODCALLTYPE       __export FAR CDECL
#define STDAPICALLTYPE          __export FAR PASCAL

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#endif

#endif //!_MAC

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE


/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */


#if defined(__cplusplus) && !defined(CINTERFACE)
#ifdef __TURBOC__
#define interface               struct huge
#else
#define interface               struct FAR
#endif
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface

#else
#define interface               struct

#ifdef _MAC

#define STDMETHOD(method)       long    method##pad;\
                                HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) long    method##pad;\
                                type (STDMETHODCALLTYPE * method)

#else // _MAC

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)

#endif // !_MAC

#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)

#endif


/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT   
#endif  // __cplusplus
#endif  // FARSTRUCT


#ifndef WINAPI          /* If not included with 3.1 headers... */

#ifdef WIN32
#define FAR
#define PASCAL          __stdcall
#define CDECL
#else
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#endif

#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;

typedef long LONG;
typedef unsigned long DWORD;


typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

typedef unsigned int HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name

DECLARE_HANDLE(HMODULE);
DECLARE_HANDLE(HINSTANCE);
DECLARE_HANDLE(HLOCAL);
DECLARE_HANDLE(HGLOBAL);
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HWND);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HTASK);

#ifndef NULL
#define NULL 0
#endif


typedef void FAR *      LPVOID;
typedef WORD FAR *      LPWORD;
typedef DWORD FAR *     LPDWORD;
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;
typedef void FAR*       LPLOGPALETTE;
typedef void FAR*       LPMSG;
//typedef struct tagMSG FAR *LPMSG;

typedef HANDLE FAR *LPHANDLE;
typedef struct tagRECT FAR *LPRECT;

typedef struct FARSTRUCT tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;


#endif  /* WINAPI */


typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;


#ifndef HUGEP
#ifdef WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP

typedef WORD WCHAR;

#ifndef WIN32
typedef struct FARSTRUCT _LARGE_INTEGER {
    DWORD LowPart;
    LONG  HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif
#define LISet32(li, v) ((li).HighPart = ((LONG)(v)) < 0 ? -1 : 0, (li).LowPart = (v))

#ifndef WIN32
typedef struct FARSTRUCT _ULARGE_INTEGER {
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
#endif
#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))

#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif

#ifdef WIN32
#define HTASK DWORD
#endif

#include "scode.h"



// *********************** Compobj errors **********************************

#define CO_E_NOTINITIALIZED         (CO_E_FIRST + 0x0)
// CoInitialize has not been called and must be

#define CO_E_ALREADYINITIALIZED     (CO_E_FIRST + 0x1)
// CoInitialize has already been called and cannot be called again (temporary)

#define CO_E_CANTDETERMINECLASS     (CO_E_FIRST + 0x2)
// can't determine clsid (e.g., extension not in reg.dat)

#define CO_E_CLASSSTRING            (CO_E_FIRST + 0x3)
// the string form of the clsid is invalid (including ole1 classes)

#define CO_E_IIDSTRING              (CO_E_FIRST + 0x4)
// the string form of the iid is invalid

#define CO_E_APPNOTFOUND            (CO_E_FIRST + 0x5)
// application not found

#define CO_E_APPSINGLEUSE           (CO_E_FIRST + 0x6)
// application cannot be run more than once

#define CO_E_ERRORINAPP             (CO_E_FIRST + 0x7)
// some error in the app program file

#define CO_E_DLLNOTFOUND            (CO_E_FIRST + 0x8)
// dll not found

#define CO_E_ERRORINDLL             (CO_E_FIRST + 0x9)
// some error in the dll file

#define CO_E_WRONGOSFORAPP          (CO_E_FIRST + 0xa)
// app written for other version of OS or other OS altogether

#define CO_E_OBJNOTREG              (CO_E_FIRST + 0xb)
// object is not registered

#define CO_E_OBJISREG               (CO_E_FIRST + 0xc)
// object is already registered

#define CO_E_OBJNOTCONNECTED        (CO_E_FIRST + 0xd)
// handler is not connected to server

#define CO_E_APPDIDNTREG            (CO_E_FIRST + 0xe)
// app was launched, but didn't registered a class factory


// ********************* ClassObject errors ********************************

#define CLASS_E_NOAGGREGATION       (CLASSFACTORY_E_FIRST + 0x0)
// class does not support aggregation (or class object is remote)

#define CLASS_E_CLASSNOTAVAILABLE   (CLASSFACTORY_E_FIRST + 0x1)
// dll doesn't support that class (returned from DllGetClassObject)


// *********************** Reg.dat errors **********************************

#define REGDB_E_READREGDB           (REGDB_E_FIRST + 0x0)
// some error reading the registration database

#define REGDB_E_WRITEREGDB          (REGDB_E_FIRST + 0x1)
// some error reading the registration database

#define REGDB_E_KEYMISSING          (REGDB_E_FIRST + 0x2)
// some error reading the registration database

#define REGDB_E_INVALIDVALUE        (REGDB_E_FIRST + 0x3)
// some error reading the registration database

#define REGDB_E_CLASSNOTREG         (REGDB_E_FIRST + 0x4)
// some error reading the registration database

#define REGDB_E_IIDNOTREG           (REGDB_E_FIRST + 0x5)
// some error reading the registration database


// *************************** RPC errors **********************************

#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)

// call was rejected by callee, either by MF::HandleIncomingCall or
#define RPC_E_CALL_REJECTED             (RPC_E_FIRST + 0x1)         

// call was canceld by call - returned by MessagePending
// this code only occurs if MessagePending return cancel
#define RPC_E_CALL_CANCELED             (RPC_E_FIRST + 0x2)         

// the caller is dispatching an intertask SendMessage call and 
// can NOT call out via PostMessage
#define RPC_E_CANTPOST_INSENDCALL       (RPC_E_FIRST + 0x3)             

// the caller is dispatching an asynchronus call can NOT 
// make an outgoing call on behalf of this call
#define RPC_E_CANTCALLOUT_INASYNCCALL   (RPC_E_FIRST + 0x4)         

// the caller is not in a state where an outgoing call can be made
// this is the case if the caller has an outstandig call and
// another incoming call was excepted by HIC; now the caller is
// not allowed to call out again
#define RPC_E_CANTCALLOUT_INEXTERNALCALL (RPC_E_FIRST + 0x5)                

// the connection terminated or is in a bogus state
// and can not be used any more. Other connections
// are still valid.
#define RPC_E_CONNECTION_TERMINATED     (RPC_E_FIRST + 0x6)         

// the callee (server [not server application]) is not available 
// and disappeared; all connections are invalid
#define RPC_E_SERVER_DIED               (RPC_E_FIRST + 0x7)         

// the caller (client ) disappeared while the callee (server) was 
// processing a call 
#define RPC_E_CLIENT_DIED               (RPC_E_FIRST + 0x8)         

// the date paket with the marshalled parameter data is
// incorrect 
#define RPC_E_INVALID_DATAPACKET        (RPC_E_FIRST + 0x9)         

// the call was not transmitted properly; the message queue 
// was full and was not emptied after yielding
#define RPC_E_CANTTRANSMIT_CALL         (RPC_E_FIRST + 0xa)         

// the client (caller) can not marshall the parameter data 
// or unmarshall the return data - low memory etc.
#define RPC_E_CLIENT_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xb)         
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xc)         

// the server (caller) can not unmarshall the parameter data
// or marshall the return data - low memory
#define RPC_E_SERVER_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xd)         
#define RPC_E_SERVER_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xe)         

// received data are invalid; can be server or 
// client data
#define RPC_E_INVALID_DATA              (RPC_E_FIRST + 0xf)         

// a particular parameter is invalid and can not be un/marshalled
#define RPC_E_INVALID_PARAMETER         (RPC_E_FIRST + 0x10)

// DDE conversation - no second outgoing call on same channel
#define RPC_E_CANTCALLOUT_AGAIN			(RPC_E_FIRST + 0x11)         

// a internal error occured 
#define RPC_E_UNEXPECTED                (RPC_E_FIRST + 0xFFFF)


/****** Globally Unique Ids *************************************************/
 
#ifdef __cplusplus

struct FAR GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];

    BOOL operator==(const GUID& iidOther) const

#ifdef WIN32
        { return !memcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#else        
        { return !_fmemcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#endif
    BOOL operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};

#else
typedef struct GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
} GUID;
#endif

typedef                GUID FAR* LPGUID;


// macros to define byte pattern for a GUID.  
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including compobj.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in compobj.dll.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of compobj.h and then include initguid.h 
// after compobj.h followed by one or more of the guid defintion files.


#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


// Interface ID are just a kind of GUID
typedef GUID IID;
typedef                IID FAR* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)


// Class ID are just a kind of GUID
typedef GUID CLSID;
typedef              CLSID FAR* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


#if defined(__cplusplus)
#define REFGUID             const GUID FAR&
#define REFIID              const IID FAR&
#define REFCLSID            const CLSID FAR&
#else
#define REFGUID             const GUID FAR* const
#define REFIID              const IID FAR* const
#define REFCLSID            const CLSID FAR* const
#endif


#ifndef INITGUID
#include "coguid.h"
#endif

/****** Other value types ***************************************************/

// memory context values; passed to CoGetMalloc
typedef enum tagMEMCTX
{
    MEMCTX_TASK = 1,            // task (private) memory
    MEMCTX_SHARED = 2,          // shared memory (between processes)
#ifdef _MAC
    MEMCTX_MACSYSTEM = 3,       // on the mac, the system heap
#endif 

    // these are mostly for internal use...
    MEMCTX_UNKNOWN = -1,        // unknown context (when asked about it)
    MEMCTX_SAME = -2,           // same context (as some other pointer)
} MEMCTX;



// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 1,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 2,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 4     // server exe (runs on same machine; diff proc)
} CLSCTX;

#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
								// and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
								// context.

	// NOTE: CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE is the same as
	// (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER), REGCLS_MULTI_SEPARATE, but
	// not the same as CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE.
} REGCLS;


// interface marshaling definitions
#define MARSHALINTERFACE_MIN 40 // minimum number of bytes for interface marshl

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2     // doesn't hold object alive; still must release
} MSHLFLAGS;

// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
} MSHCTX;


// call type used by IMessageFilter::HandleIncommingMessage
typedef enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,      // toplevel call - no outgoing call 
    CALLTYPE_NESTED   = 2,      // callback on behalf of previous outgoing call - should always handle
    CALLTYPE_ASYNC    = 3,      // aysnchronous call - can NOT be rejected
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,  // new toplevel call with new LID
    CALLTYPE_ASYNC_CALLPENDING    = 5   // async call - can NOT be rejected
} CALLTYPE;

typedef struct tagINTERFACEINFO 
{               
    interface IUnknown FAR *pUnk;       // the pointer to the object
    IID      			iid;            // interface id
    WORD        		wMethod;        // interface methode
} INTERFACEINFO, FAR * LPINTERFACEINFO;

// status of server call - returned by IMessageFilter::HandleIncommingCall
// and passed to  IMessageFilter::RetryRejectedCall
typedef enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED    = 0,
    SERVERCALL_REJECTED     = 1,
    SERVERCALL_RETRYLATER   = 2         
} SERVERCALL;


// Pending type indicates the level of nesting
typedef enum tagPENDINGTYPE
{   
    PENDINGTYPE_TOPLEVEL = 1,       // toplevel call
    PENDINGTYPE_NESTED   = 2,       // nested call
} PENDINGTYPE;

// return values of MessagePending
typedef enum tagPENDINGMSG
{   
    PENDINGMSG_CANCELCALL  = 0, // cancel the outgoing call
    PENDINGMSG_WAITNOPROCESS  = 1, // wait for the return and don't dispatch the message
    PENDINGMSG_WAITDEFPROCESS = 2  // wait and dispatch the message 
    
} PENDINGMSG;


// bit flags for IExternalConnection
typedef enum tagEXTCONN 
{
	EXTCONN_STRONG		= 0x0001	// strong connection
} EXTCONN;


/****** IUnknown Interface **************************************************/


#undef  INTERFACE
#define INTERFACE   IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
};

typedef        IUnknown FAR* LPUNKNOWN;


/****** Class Factory Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IClassFactory

DECLARE_INTERFACE_(IClassFactory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_ LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject) PURE;
    STDMETHOD(LockServer) (THIS_ BOOL fLock) PURE;

};
typedef       IClassFactory FAR* LPCLASSFACTORY;


/****** Memory Allocation Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ ULONG cb) PURE;
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, ULONG cb) PURE;
    STDMETHOD_(void, Free) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(ULONG, GetSize) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(void, HeapMinimize) (THIS) PURE;
};
typedef       IMalloc FAR* LPMALLOC;


/****** IMarshal Interface ************************************************/

// forward declaration for IStream; must include storage.h later to use
#ifdef __cplusplus
interface IStream;
#else
typedef interface IStream IStream;
#endif
typedef         IStream FAR* LPSTREAM;


#undef  INTERFACE
#define INTERFACE   IMarshal

DECLARE_INTERFACE_(IMarshal, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPCLSID pCid) PURE;
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPDWORD pSize) PURE;
    STDMETHOD(MarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags) PURE;
    STDMETHOD(UnmarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID FAR* ppv) PURE;
    STDMETHOD(ReleaseMarshalData)(THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved) PURE;
};
typedef         IMarshal FAR* LPMARSHAL;


#undef  INTERFACE
#define INTERFACE   IStdMarshalInfo

DECLARE_INTERFACE_(IStdMarshalInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStdMarshalInfo methods ***
    STDMETHOD(GetClassForHandler)(THIS_ DWORD dwDestContext, 
                        LPVOID pvDestContext, LPCLSID pClsid) PURE;
};
typedef         IStdMarshalInfo FAR* LPSTDMARSHALINFO;


/****** Message Filter Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IMessageFilter

DECLARE_INTERFACE_(IMessageFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMessageFilter methods ***
    STDMETHOD_(DWORD, HandleInComingCall) (THIS_ DWORD dwCallType,
                                HTASK htaskCaller, DWORD dwTickCount,
                                DWORD dwReserved ) PURE;
    STDMETHOD_(DWORD, RetryRejectedCall) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwRejectType ) PURE;
    STDMETHOD_(DWORD, MessagePending) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount, 
                                DWORD dwPendingType  ) PURE; 
};
typedef       IMessageFilter FAR* LPMESSAGEFILTER;


/****** External Connection Information ***********************************/

#undef  INTERFACE
#define INTERFACE   IExternalConnection

DECLARE_INTERFACE_(IExternalConnection, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExternalConnection methods ***
    STDMETHOD_(DWORD, AddConnection) (THIS_ DWORD extconn, DWORD reserved) PURE;
    STDMETHOD_(DWORD, ReleaseConnection) (THIS_ DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses) PURE;
};
typedef       IExternalConnection FAR* LPEXTERNALCONNECTION;


/****** Enumerator Interfaces *********************************************/

/*
 *  Since we don't use parametrized types, we put in explicit declarations
 *  of the enumerators we need.
 */


#undef  INTERFACE
#define INTERFACE   IEnumString

DECLARE_INTERFACE_(IEnumString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, 
                       LPSTR FAR* rgelt, 
                       ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumString FAR* FAR* ppenm) PURE;
};
typedef      IEnumString FAR* LPENUMSTRING;


#undef  INTERFACE
#define INTERFACE   IEnumUnknown

DECLARE_INTERFACE_(IEnumUnknown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUnknown methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPUNKNOWN FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumUnknown FAR* FAR* ppenm) PURE;
};
typedef         IEnumUnknown FAR* LPENUMUNKNOWN;


/****** STD Object API Prototypes *****************************************/

STDAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

STDAPI  CoInitialize(LPMALLOC pMalloc);
STDAPI_(void)  CoUninitialize(void);
STDAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
STDAPI_(DWORD) CoGetCurrentProcess(void);
STDAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/* register/revoke/get class objects */

STDAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
STDAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
STDAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
STDAPI CoReleaseMarshalData(LPSTREAM pStm);
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk, 
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

STDAPI_(HINSTANCE) CoLoadLibrary(LPSTR lpszLibName, BOOL bAutoFree);
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst);
STDAPI_(void) CoFreeAllLibraries(void);
STDAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */
STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2);
STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz);
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid);
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz);
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid);
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
STDAPI ProgIDFromCLSID (REFCLSID clsid, LPSTR FAR* lplpszProgID);
STDAPI CLSIDFromProgID (LPCSTR lpszProgID, LPCLSID lpclsid);
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPSTR lpsz, int cbMax);

STDAPI CoCreateGuid(GUID FAR *pguid);

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
STDAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


STDAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at 
 * the same time.
 */

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#endif


STDAPI  DllCanUnloadNow(void);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNCANUNLOADNOW)(void);
#endif


/****** Debugging Helpers *************************************************/

#ifdef _DEBUG
// writes to the debug port and displays a message box
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
#endif  //  _DEBUG

#endif // _COMPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\cpl.h ===
/*****************************************************************************\
*                                                                             *
* cpl.h -       Control panel extension DLL definitions                       *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
******************************************************************************
*  General rules for being installed in the Control Panel:
*
*      1) The DLL must export a function named CPlApplet which will handle
*         the messages discussed below.
*      2) If the applet needs to save information in CONTROL.INI minimize
*         clutter by using the application name [MMCPL.appletname].
*      2) If the applet is refrenced in CONTROL.INI under [MMCPL] use
*         the following form:
*              ...
*              [MMCPL]
*              uniqueName=c:\mydir\myapplet.dll
*              ...
*
*
*  The order applet DLL's are loaded by CONTROL.EXE is:
*
*      1) MAIN.CPL is loaded from the windows system directory.
*
*      2) Installable drivers that are loaded and export the
*         CplApplet() routine.
*
*      3) DLL's specified in the [MMCPL] section of CONTROL.INI.
*
*      4) DLL's named *.CPL from windows system directory.
*
*/
#ifndef _INC_CPL
#define _INC_CPL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * CONTROL.EXE will answer this message and launch an applet
 *
 * WM_CPL_LAUNCH
 *
 *      wParam      - window handle of calling app
 *      lParam      - LPSTR of name of applet to launch
 *
 * WM_CPL_LAUNCHED
 *
 *      wParam      - TRUE/FALSE if applet was launched
 *      lParam      - NULL
 *
 * CONTROL.EXE will post this message to the caller when the applet returns
 * (ie., when wParam is a valid window handle)
 *
 */
#define WM_CPL_LAUNCH   (WM_USER+1000)
#define WM_CPL_LAUNCHED (WM_USER+1001)

/* A function prototype for CPlApplet() */

typedef LRESULT (CALLBACK *APPLET_PROC)(HWND hwndCpl, UINT msg, LPARAM lParam1, LPARAM lParam2);

/* The data structure CPlApplet() must fill in. */

typedef struct tagCPLINFO
{
    int     idIcon;     /* icon resource id, provided by CPlApplet() */
    int     idName;     /* name string res. id, provided by CPlApplet() */
    int     idInfo;     /* info string res. id, provided by CPlApplet() */
    LONG    lData;      /* user defined data */
} CPLINFO, *PCPLINFO, FAR *LPCPLINFO;

typedef struct tagNEWCPLINFO
{
    DWORD       dwSize;         /* similar to the commdlg */
    DWORD	dwFlags;
    DWORD       dwHelpContext;  /* help context to use */
    LONG        lData;          /* user defined data */
    HICON       hIcon;          /* icon to use, this is owned by CONTROL.EXE (may be deleted) */
    char        szName[32];     /* short name */
    char        szInfo[64];     /* long name (status line) */
    char        szHelpFile[128];/* path to help file to use */
} NEWCPLINFO, *PNEWCPLINFO, FAR *LPNEWCPLINFO;


/* The messages CPlApplet() must handle: */

#define CPL_INIT        1
/*  This message is sent to indicate CPlApplet() was found. */
/*  lParam1 and lParam2 are not defined. */
/*  Return TRUE or FALSE indicating whether the control panel should proceed. */


#define CPL_GETCOUNT    2
/*  This message is sent to determine the number of applets to be displayed. */
/*  lParam1 and lParam2 are not defined. */
/*  Return the number of applets you wish to display in the control */
/*  panel window. */


#define CPL_INQUIRE     3
/*  This message is sent for information about each applet. */
/*  lParam1 is the applet number to register, a value from 0 to */
/*  (CPL_GETCOUNT - 1).  lParam2 is a far ptr to a CPLINFO structure. */
/*  Fill in CPL_INFO's idIcon, idName, idInfo and lData fields with */
/*  the resource id for an icon to display, name and description string ids, */
/*  and a long data item associated with applet #lParam1. */


#define CPL_SELECT      4
/*  This message is sent when the applet's icon has been clicked upon. */
/*  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */


#define CPL_DBLCLK      5
/*  This message is sent when the applet's icon has been double-clicked */
/*  upon.  lParam1 is the applet number which was selected.  lParam2 is the */
/*  applet's lData value. */
/*  This message should initiate the applet's dialog box. */


#define CPL_STOP        6
/*  This message is sent for each applet when the control panel is exiting. */
/*  lParam1 is the applet number.  lParam2 is the applet's lData  value. */
/*  Do applet specific cleaning up here. */


#define CPL_EXIT        7
/*  This message is sent just before the control panel calls FreeLibrary. */
/*  lParam1 and lParam2 are not defined. */
/*  Do non-applet specific cleaning up here. */


#define CPL_NEWINQUIRE	8
/* this is the same as CPL_INQUIRE execpt lParam2 is a pointer to a */
/* NEWCPLINFO structure.  this will be sent before the CPL_INQUIRE */
/* and if it is responed to (return != 0) CPL_INQUIRE will not be sent */


#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CPL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ctype.h ===
/***
*ctype.h - character conversion macros and ctype macros
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines macros for character classification/conversion.
*   [ANSI/System V]
*
****/

#ifndef _INC_CTYPE

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/*
 * This declaration allows the user access to the ctype look-up
 * array _ctype defined in ctype.obj by simply including ctype.h
 */

extern unsigned char __near __cdecl _ctype[];

/* set bit masks for the possible character types */

#define _UPPER      0x1 /* upper case letter */
#define _LOWER      0x2 /* lower case letter */
#define _DIGIT      0x4 /* digit[0-9] */
#define _SPACE      0x8 /* tab, carriage return, newline, */
                /* vertical tab or form feed */
#define _PUNCT      0x10    /* punctuation character */
#define _CONTROL    0x20    /* control character */
#define _BLANK      0x40    /* space char */
#define _HEX        0x80    /* hexadecimal digit */

/* character classification function prototypes */

#ifndef _CTYPE_DEFINED
int __cdecl isalpha(int);
int __cdecl isupper(int);
int __cdecl islower(int);
int __cdecl isdigit(int);
int __cdecl isxdigit(int);
int __cdecl isspace(int);
int __cdecl ispunct(int);
int __cdecl isalnum(int);
int __cdecl isprint(int);
int __cdecl isgraph(int);
int __cdecl iscntrl(int);
int __cdecl toupper(int);
int __cdecl tolower(int);
int __cdecl _tolower(int);
int __cdecl _toupper(int);
int __cdecl __isascii(int);
int __cdecl __toascii(int);
int __cdecl __iscsymf(int);
int __cdecl __iscsym(int);
#define _CTYPE_DEFINED
#endif 

#ifdef _INTL
int __cdecl __isleadbyte(int);
#endif 

/* the character classification macro definitions */

#define isalpha(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER) )
#define isupper(_c) ( (_ctype+1)[_c] & _UPPER )
#define islower(_c) ( (_ctype+1)[_c] & _LOWER )
#define isdigit(_c) ( (_ctype+1)[_c] & _DIGIT )
#define isxdigit(_c)    ( (_ctype+1)[_c] & _HEX )
#define isspace(_c) ( (_ctype+1)[_c] & _SPACE )
#define ispunct(_c) ( (_ctype+1)[_c] & _PUNCT )
#define isalnum(_c) ( (_ctype+1)[_c] & (_UPPER|_LOWER|_DIGIT) )
#define isprint(_c) ( (_ctype+1)[_c] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define isgraph(_c) ( (_ctype+1)[_c] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define iscntrl(_c) ( (_ctype+1)[_c] & _CONTROL )
#ifndef __STDC__
#define toupper(_c) ( (islower(_c)) ? _toupper(_c) : (_c) )
#define tolower(_c) ( (isupper(_c)) ? _tolower(_c) : (_c) )
#endif 
#define _tolower(_c)    ( (_c)-'A'+'a' )
#define _toupper(_c)    ( (_c)-'a'+'A' )
#define __isascii(_c)   ( (unsigned)(_c) < 0x80 )
#define __toascii(_c)   ( (_c) & 0x7f )

#ifndef isleadbyte
#ifdef _INTL
#define isleadbyte(_c)  __isleadbyte(_c)
#else 
#define isleadbyte(_c)  (0)
#endif 
#endif 

/* extended ctype macros */

#define __iscsymf(_c)   (isalpha(_c) || ((_c) == '_'))
#define __iscsym(_c)    (isalnum(_c) || ((_c) == '_'))

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#ifndef _CTYPE_DEFINED
int __cdecl isascii(int);
int __cdecl toascii(int);
int __cdecl iscsymf(int);
int __cdecl iscsym(int);
#else 
#define isascii __isascii
#define toascii __toascii
#define iscsymf __iscsymf
#define iscsym  __iscsym
#endif 
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_CTYPE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\custcntl.h ===
/*****************************************************************************\
*                                                                             *
* custcntl.h -  Custom Control Library header file                            *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_CUSTCNTL
#define _INC_CUSTCNTL

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

/*
 * Every custom control DLL must have three functions present,
 * and they must be exported by the following ordinals.
 */
#define CCINFOORD       2       /* information function ordinal */
#define CCSTYLEORD      3       /* styles function ordinal */
#define CCFLAGSORD      4       /* translate flags function ordinal */

/* general size definitions */
#define CTLTYPES        12      /* max number of control types */
#define CTLDESCR        22      /* max size of description */
#define CTLCLASS        20      /* max size of class name */
#define CTLTITLE        94      /* max size of control text */

/*
 * CONTROL STYLE DATA STRUCTURE
 *
 * This data structure is used by the class style dialog function
 * to set and/or reset various control attributes.
 *
 */
typedef struct tagCTLSTYLE
{
    UINT    wX;                 /* x origin of control */
    UINT    wY;                 /* y origin of control */
    UINT    wCx;                /* width of control */
    UINT    wCy;                /* height of control */
    UINT    wId;                /* control child id */
    DWORD   dwStyle;            /* control style */
    char    szClass[CTLCLASS];  /* name of control class */
    char    szTitle[CTLTITLE];  /* control text */
} CTLSTYLE;
typedef CTLSTYLE *      PCTLSTYLE;
typedef CTLSTYLE FAR*   LPCTLSTYLE;

/*
 * CONTROL DATA STRUCTURE
 *
 * This data structure is returned by the control options function
 * when inquiring about the capabilities of a particular control.
 * Each control may contain various types (with predefined style
 * bits) under one general class.
 *
 * The width and height fields are used to provide the host
 * application with a suggested size.  The values in these fields
 * are in rc coordinates.
 *
 */
typedef struct tagCTLTYPE
{
    UINT    wType;              /* type style */
    UINT    wWidth;             /* suggested width */
    UINT    wHeight;            /* suggested height */
    DWORD   dwStyle;            /* default style */
    char    szDescr[CTLDESCR];  /* description */
} CTLTYPE;

typedef struct tagCTLINFO
{
    UINT    wVersion;           /* control version */
    UINT    wCtlTypes;          /* control types */
    char    szClass[CTLCLASS];  /* control class name */
    char    szTitle[CTLTITLE];  /* control title */
    char    szReserved[10];     /* reserved for future use */
    CTLTYPE Type[CTLTYPES];     /* control type list */
} CTLINFO;
typedef CTLINFO *       PCTLINFO;
typedef CTLINFO FAR*    LPCTLINFO;

/* These two function prototypes are used by the dialog editor */
#ifdef STRICT
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPCSTR);
#else
typedef DWORD   (CALLBACK* LPFNSTRTOID)(LPSTR);
#endif
typedef UINT    (CALLBACK* LPFNIDTOSTR)(UINT, LPSTR, UINT);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_CUSTCNTL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\dde.h ===
/*****************************************************************************\
*                                                                             *
* dde.h -       Dynamic Data Exchange structures and definitions              *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DDE
#define _INC_DDE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* DDE window messages */

#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	    (WM_DDE_FIRST+4)
#define WM_DDE_DATA	    (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	    (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	    (WM_DDE_FIRST+8)

/****************************************************************************\
*       DDEACK structure
*
*       Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
*       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
*       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
*
\****************************************************************************/

typedef struct tagDDEACK
{
    WORD    bAppReturnCode:8,
            reserved:6,
            fBusy:1,
            fAck:1;
} DDEACK;

/****************************************************************************\
*       DDEADVISE structure
*
*       WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
*
\****************************************************************************/

typedef struct tagDDEADVISE
{
    WORD    reserved:14,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDEADVISE;

/****************************************************************************\
*       DDEDATA structure
*
*       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEDATA
{
    WORD    unused:12,
            fResponse:1,
            fRelease:1,
            reserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE     Value[1];
} DDEDATA;


/****************************************************************************\
*       DDEPOKE structure
*
*       WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
*       The actual size of this structure depends on the size of
*       the Value array.
*
\****************************************************************************/

typedef struct tagDDEPOKE
{
    WORD    unused:13,  /* Earlier versions of DDE.H incorrectly */
                        /* 12 unused bits.                       */
            fRelease:1,
            fReserved:2;
    short   cfFormat;
    BYTE    Value[1];   /* This member was named rgb[1] in previous */
                        /* versions of DDE.H                        */

} DDEPOKE;

/****************************************************************************\
* The following typedef's were used in previous versions of the Windows SDK.
* They are still valid.  The above typedef's define exactly the same structures
* as those below.  The above typedef names are recommended, however, as they
* are more meaningful.
*
* Note that the DDEPOKE structure typedef'ed in earlier versions of DDE.H did
* not correctly define the bit positions.
\****************************************************************************/

typedef struct tagDDELN
{
    WORD    unused:13,
            fRelease:1,
            fDeferUpd:1,
            fAckReq:1;
    short   cfFormat;
} DDELN;

typedef struct tagDDEUP
{
    WORD    unused:12,
            fAck:1,
            fRelease:1,
            fReserved:1,
            fAckReq:1;
    short   cfFormat;
    BYTE    rgb[1];
} DDEUP;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_DDE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\direct.h ===
/***
*direct.h - function declarations for directory handling/creation
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the library
*   functions related to directory handling and creation.
*
****/

#ifndef _INC_DIRECT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* function prototypes */

int __cdecl _chdir(const char *);
int __cdecl _chdrive(int);
char * __cdecl _getcwd(char *, int);
char * __cdecl _getdcwd(int, char *, int);
int __cdecl _getdrive(void);
int __cdecl _mkdir(const char *);
int __cdecl _rmdir(const char *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl chdir(const char *);
char * __cdecl getcwd(char *, int);
int __cdecl mkdir(const char *);
int __cdecl rmdir(const char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DIRECT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ddeml.h ===
/*****************************************************************************\
*                                                                             *
*  ddeml.h -    DDEML API header file                                         *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/
#ifndef _INC_DDEML
#define _INC_DDEML

#ifndef RC_INVOKED
#pragma pack(1)
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef _INC_WINDOWS    /* If not included with 3.1 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifndef DECLARE_HANDLE32
#ifdef STRICT
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ _far* name
#else   /* STRICT */
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */
#endif  /* !DECLARE_HANDLE32 */

#define EXPENTRY    WINAPI

/******** public types ********/

DECLARE_HANDLE32(HCONVLIST);
DECLARE_HANDLE32(HCONV);
DECLARE_HANDLE32(HSZ);
DECLARE_HANDLE32(HDDEDATA);

/* the following structure is for use with XTYP_WILDCONNECT processing. */

typedef struct tagHSZPAIR
{
    HSZ hszSvc;
    HSZ hszTopic;
} HSZPAIR;
typedef HSZPAIR FAR *PHSZPAIR;

/* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. */

typedef struct tagCONVCONTEXT
{
    UINT        cb;             /* set to sizeof(CONVCONTEXT) */
    UINT        wFlags;         /* none currently defined. */
    UINT        wCountryID;     /* country code for topic/item strings used. */
    int         iCodePage;      /* codepage used for topic/item strings. */
    DWORD       dwLangID;       /* language ID for topic/item strings. */
    DWORD       dwSecurity;     /* Private security code. */
} CONVCONTEXT;
typedef CONVCONTEXT FAR *PCONVCONTEXT;

/* The following structure is used by DdeQueryConvInfo(): */

typedef struct tagCONVINFO
{
    DWORD   cb;            /* sizeof(CONVINFO)  */
    DWORD   hUser;         /* user specified field  */
    HCONV   hConvPartner;  /* hConv on other end or 0 if non-ddemgr partner  */
    HSZ     hszSvcPartner; /* app name of partner if obtainable  */
    HSZ     hszServiceReq; /* AppName requested for connection  */
    HSZ     hszTopic;      /* Topic name for conversation  */
    HSZ     hszItem;       /* transaction item name or NULL if quiescent  */
    UINT    wFmt;          /* transaction format or NULL if quiescent  */
    UINT    wType;         /* XTYP_ for current transaction  */
    UINT    wStatus;       /* ST_ constant for current conversation  */
    UINT    wConvst;       /* XST_ constant for current transaction  */
    UINT    wLastError;    /* last transaction error.  */
    HCONVLIST hConvList;   /* parent hConvList if this conversation is in a list */
    CONVCONTEXT ConvCtxt;  /* conversation context */
} CONVINFO;
typedef CONVINFO FAR *PCONVINFO;

/***** conversation states (usState) *****/

#define     XST_NULL              0  /* quiescent states */
#define     XST_INCOMPLETE        1
#define     XST_CONNECTED         2
#define     XST_INIT1             3  /* mid-initiation states */
#define     XST_INIT2             4
#define     XST_REQSENT           5  /* active conversation states */
#define     XST_DATARCVD          6
#define     XST_POKESENT          7
#define     XST_POKEACKRCVD       8
#define     XST_EXECSENT          9
#define     XST_EXECACKRCVD      10
#define     XST_ADVSENT          11
#define     XST_UNADVSENT        12
#define     XST_ADVACKRCVD       13
#define     XST_UNADVACKRCVD     14
#define     XST_ADVDATASENT      15
#define     XST_ADVDATAACKRCVD   16

/* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... */
#define     CADV_LATEACK         0xFFFF

/***** conversation status bits (fsStatus) *****/

#define     ST_CONNECTED        0x0001
#define     ST_ADVISE           0x0002
#define     ST_ISLOCAL          0x0004
#define     ST_BLOCKED          0x0008
#define     ST_CLIENT           0x0010
#define     ST_TERMINATED       0x0020
#define     ST_INLIST           0x0040
#define     ST_BLOCKNEXT        0x0080
#define     ST_ISSELF           0x0100

/* DDE constants for wStatus field */

#define DDE_FACK	  	0x8000
#define DDE_FBUSY	  	0x4000
#define DDE_FDEFERUPD		0x4000
#define DDE_FACKREQ	        0x8000
#define DDE_FRELEASE  		0x2000
#define DDE_FREQUESTED		0x1000
#define DDE_FACKRESERVED	0x3ff0
#define DDE_FADVRESERVED	0x3fff
#define DDE_FDATRESERVED	0x4fff
#define DDE_FPOKRESERVED	0xdfff
#define DDE_FAPPSTATUS		0x00ff
#define DDE_FNOTPROCESSED   0x0000

/***** message filter hook types *****/

#define     MSGF_DDEMGR             0x8001

/***** codepage constants ****/

#define CP_WINANSI      1004    /* default codepage for windows & old DDE convs. */

/***** transaction types *****/

#define     XTYPF_NOBLOCK            0x0002  /* CBR_BLOCK will not work */
#define     XTYPF_NODATA             0x0004  /* DDE_FDEFERUPD */
#define     XTYPF_ACKREQ             0x0008  /* DDE_FACKREQ */

#define     XCLASS_MASK              0xFC00
#define     XCLASS_BOOL              0x1000
#define     XCLASS_DATA              0x2000
#define     XCLASS_FLAGS             0x4000
#define     XCLASS_NOTIFICATION      0x8000

#define     XTYP_ERROR              (0x0000 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK )
#define     XTYP_ADVDATA            (0x0010 | XCLASS_FLAGS         )
#define     XTYP_ADVREQ             (0x0020 | XCLASS_DATA | XTYPF_NOBLOCK )
#define     XTYP_ADVSTART           (0x0030 | XCLASS_BOOL          )
#define     XTYP_ADVSTOP            (0x0040 | XCLASS_NOTIFICATION)
#define     XTYP_EXECUTE            (0x0050 | XCLASS_FLAGS         )
#define     XTYP_CONNECT            (0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK)
#define     XTYP_CONNECT_CONFIRM    (0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_XACT_COMPLETE      (0x0080 | XCLASS_NOTIFICATION  )
#define     XTYP_POKE               (0x0090 | XCLASS_FLAGS         )
#define     XTYP_REGISTER           (0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_REQUEST            (0x00B0 | XCLASS_DATA          )
#define     XTYP_DISCONNECT         (0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_UNREGISTER         (0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)
#define     XTYP_WILDCONNECT        (0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK)

#define     XTYP_MASK                0x00F0
#define     XTYP_SHIFT               4  /* shift to turn XTYP_ into an index */

/***** Timeout constants *****/

#define     TIMEOUT_ASYNC           -1L

/***** Transaction ID constants *****/

#define     QID_SYNC                -1L

/****** public strings used in DDE ******/

#define SZDDESYS_TOPIC          "System"
#define SZDDESYS_ITEM_TOPICS    "Topics"
#define SZDDESYS_ITEM_SYSITEMS  "SysItems"
#define SZDDESYS_ITEM_RTNMSG    "ReturnMessage"
#define SZDDESYS_ITEM_STATUS    "Status"
#define SZDDESYS_ITEM_FORMATS   "Formats"
#define SZDDESYS_ITEM_HELP      "Help"
#define SZDDE_ITEM_ITEMLIST     "TopicItemList"


/****** API entry points ******/

typedef HDDEDATA CALLBACK FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv,
        HSZ hsz1, HSZ hsz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2);
typedef FNCALLBACK *PFNCALLBACK;

#define     CBR_BLOCK                0xffffffffL

/* DLL registration functions */

UINT    WINAPI DdeInitialize(DWORD FAR* pidInst, PFNCALLBACK pfnCallback,
                DWORD afCmd, DWORD ulRes);

/*
 * Callback filter flags for use with standard apps.
 */

#define     CBF_FAIL_SELFCONNECTIONS     0x00001000
#define     CBF_FAIL_CONNECTIONS         0x00002000
#define     CBF_FAIL_ADVISES             0x00004000
#define     CBF_FAIL_EXECUTES            0x00008000
#define     CBF_FAIL_POKES               0x00010000
#define     CBF_FAIL_REQUESTS            0x00020000
#define     CBF_FAIL_ALLSVRXACTIONS      0x0003f000

#define     CBF_SKIP_CONNECT_CONFIRMS    0x00040000
#define     CBF_SKIP_REGISTRATIONS       0x00080000
#define     CBF_SKIP_UNREGISTRATIONS     0x00100000
#define     CBF_SKIP_DISCONNECTS         0x00200000
#define     CBF_SKIP_ALLNOTIFICATIONS    0x003c0000

/*
 * Application command flags
 */
#define     APPCMD_CLIENTONLY            0x00000010L
#define     APPCMD_FILTERINITS           0x00000020L
#define     APPCMD_MASK                  0x00000FF0L

/*
 * Application classification flags
 */
#define     APPCLASS_STANDARD            0x00000000L
#define     APPCLASS_MASK                0x0000000FL


BOOL    WINAPI DdeUninitialize(DWORD idInst);

/* conversation enumeration functions */

HCONVLIST WINAPI DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic,
            HCONVLIST hConvList, CONVCONTEXT FAR* pCC);
HCONV   WINAPI DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
BOOL    WINAPI DdeDisconnectList(HCONVLIST hConvList);

/* conversation control functions */

HCONV   WINAPI DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic,
            CONVCONTEXT FAR* pCC);
BOOL    WINAPI DdeDisconnect(HCONV hConv);
HCONV   WINAPI DdeReconnect(HCONV hConv);

UINT    WINAPI DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, CONVINFO FAR* pConvInfo);
BOOL    WINAPI DdeSetUserHandle(HCONV hConv, DWORD id, DWORD hUser);

BOOL    WINAPI DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);


/* app server interface functions */

BOOL    WINAPI DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);
BOOL    WINAPI DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);

#define EC_ENABLEALL            0
#define EC_ENABLEONE            ST_BLOCKNEXT
#define EC_DISABLE              ST_BLOCKED
#define EC_QUERYWAITING         2

HDDEDATA WINAPI DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

#define DNS_REGISTER        0x0001
#define DNS_UNREGISTER      0x0002
#define DNS_FILTERON        0x0004
#define DNS_FILTEROFF       0x0008

/* app client interface functions */

HDDEDATA WINAPI DdeClientTransaction(void FAR* pData, DWORD cbData,
        HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType,
        DWORD dwTimeout, DWORD FAR* pdwResult);

/* data transfer functions */

HDDEDATA WINAPI DdeCreateDataHandle(DWORD idInst, void FAR* pSrc, DWORD cb,
            DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);
HDDEDATA WINAPI DdeAddData(HDDEDATA hData, void FAR* pSrc, DWORD cb, DWORD cbOff);
DWORD   WINAPI DdeGetData(HDDEDATA hData, void FAR* pDst, DWORD cbMax, DWORD cbOff);
BYTE FAR* WINAPI DdeAccessData(HDDEDATA hData, DWORD FAR* pcbDataSize);
BOOL    WINAPI DdeUnaccessData(HDDEDATA hData);
BOOL    WINAPI DdeFreeDataHandle(HDDEDATA hData);

#define     HDATA_APPOWNED          0x0001



UINT WINAPI DdeGetLastError(DWORD idInst);

#define     DMLERR_NO_ERROR                    0       /* must be 0 */

#define     DMLERR_FIRST                       0x4000

#define     DMLERR_ADVACKTIMEOUT               0x4000
#define     DMLERR_BUSY                        0x4001
#define     DMLERR_DATAACKTIMEOUT              0x4002
#define     DMLERR_DLL_NOT_INITIALIZED         0x4003
#define     DMLERR_DLL_USAGE                   0x4004
#define     DMLERR_EXECACKTIMEOUT              0x4005
#define     DMLERR_INVALIDPARAMETER            0x4006
#define     DMLERR_LOW_MEMORY                  0x4007
#define     DMLERR_MEMORY_ERROR                0x4008
#define     DMLERR_NOTPROCESSED                0x4009
#define     DMLERR_NO_CONV_ESTABLISHED         0x400a
#define     DMLERR_POKEACKTIMEOUT              0x400b
#define     DMLERR_POSTMSG_FAILED              0x400c
#define     DMLERR_REENTRANCY                  0x400d
#define     DMLERR_SERVER_DIED                 0x400e
#define     DMLERR_SYS_ERROR                   0x400f
#define     DMLERR_UNADVACKTIMEOUT             0x4010
#define     DMLERR_UNFOUND_QUEUE_ID            0x4011

#define     DMLERR_LAST                        0x4011

HSZ     WINAPI DdeCreateStringHandle(DWORD idInst, LPCSTR psz, int iCodePage);
DWORD   WINAPI DdeQueryString(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
BOOL    WINAPI DdeFreeStringHandle(DWORD idInst, HSZ hsz);
BOOL    WINAPI DdeKeepStringHandle(DWORD idInst, HSZ hsz);
int     WINAPI DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);


#ifndef NODDEMLSPY
/* */
/* DDEML public debugging header file info */
/* */

typedef struct tagMONMSGSTRUCT
{
    UINT    cb;
    HWND    hwndTo;
    DWORD   dwTime;
    HANDLE  hTask;
    UINT    wMsg;
    WPARAM  wParam;
    LPARAM  lParam;
} MONMSGSTRUCT;

typedef struct tagMONCBSTRUCT
{
    UINT   cb;
    WORD   wReserved;
    DWORD  dwTime;
    HANDLE hTask;
    DWORD  dwRet;
    UINT   wType;
    UINT   wFmt;
    HCONV  hConv;
    HSZ    hsz1;
    HSZ    hsz2;
    HDDEDATA hData;
    DWORD  dwData1;
    DWORD  dwData2;
} MONCBSTRUCT;

typedef struct tagMONHSZSTRUCT
{
    UINT   cb;
    BOOL   fsAction;    /* MH_ value */
    DWORD  dwTime;
    HSZ    hsz;
    HANDLE hTask;
    WORD   wReserved;
    char   str[1];
} MONHSZSTRUCT;

#define MH_CREATE   1
#define MH_KEEP     2
#define MH_DELETE   3
#define MH_CLEANUP  4


typedef struct tagMONERRSTRUCT
{
    UINT    cb;
    UINT    wLastError;
    DWORD   dwTime;
    HANDLE  hTask;
} MONERRSTRUCT;

typedef struct tagMONLINKSTRUCT
{
    UINT    cb;
    DWORD   dwTime;
    HANDLE  hTask;
    BOOL    fEstablished;
    BOOL    fNoData;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HSZ     hszItem;
    UINT    wFmt;
    BOOL    fServer;
    HCONV   hConvServer;
    HCONV   hConvClient;
} MONLINKSTRUCT;

typedef struct tagMONCONVSTRUCT
{
    UINT    cb;
    BOOL    fConnect;
    DWORD   dwTime;
    HANDLE  hTask;
    HSZ     hszSvc;
    HSZ     hszTopic;
    HCONV   hConvClient;
    HCONV   hConvServer;
} MONCONVSTRUCT;

#define     MAX_MONITORS            4
#define     APPCLASS_MONITOR        0x00000001L
#define     XTYP_MONITOR            (0x00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK)

/*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 */
#define     MF_HSZ_INFO                  0x01000000
#define     MF_SENDMSGS                  0x02000000
#define     MF_POSTMSGS                  0x04000000
#define     MF_CALLBACKS                 0x08000000
#define     MF_ERRORS                    0x10000000
#define     MF_LINKS                     0x20000000
#define     MF_CONV                      0x40000000

#define     MF_MASK                      0xFF000000
#endif /* NODDEMLSPY */

#ifdef __cplusplus
}
#endif

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif /* _INC_DDEML */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\dlgs.h ===
/*****************************************************************************\
*                                                                             *
* dlgs.h -      Common dialog's dialog element ID numbers                     *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_DLGS
#define _INC_DLGS

#define ctlFirst    0x0400
#define ctlLast     0x04ff
    /* Push buttons */
#define psh1        0x0400
#define psh2        0x0401
#define psh3        0x0402
#define psh4        0x0403
#define psh5        0x0404
#define psh6        0x0405
#define psh7        0x0406
#define psh8        0x0407
#define psh9        0x0408
#define psh10       0x0409
#define psh11       0x040a
#define psh12       0x040b
#define psh13       0x040c
#define psh14       0x040d
#define psh15       0x040e
#define pshHelp     psh15
#define psh16       0x040f
    /* Checkboxes */
#define chx1        0x0410
#define chx2        0x0411
#define chx3        0x0412
#define chx4        0x0413
#define chx5        0x0414
#define chx6        0x0415
#define chx7        0x0416
#define chx8        0x0417
#define chx9        0x0418
#define chx10       0x0419
#define chx11       0x041a
#define chx12       0x041b
#define chx13       0x041c
#define chx14       0x041d
#define chx15       0x041e
#define chx16       0x041f
    /* Radio buttons */
#define rad1        0x0420
#define rad2        0x0421
#define rad3        0x0422
#define rad4        0x0423
#define rad5        0x0424
#define rad6        0x0425
#define rad7        0x0426
#define rad8        0x0427
#define rad9        0x0428
#define rad10       0x0429
#define rad11       0x042a
#define rad12       0x042b
#define rad13       0x042c
#define rad14       0x042d
#define rad15       0x042e
#define rad16       0x042f
    /* Groups, frames, rectangles, and icons */
#define grp1        0x0430
#define grp2        0x0431
#define grp3        0x0432
#define grp4        0x0433
#define frm1        0x0434
#define frm2        0x0435
#define frm3        0x0436
#define frm4        0x0437
#define rct1        0x0438
#define rct2        0x0439
#define rct3        0x043a
#define rct4        0x043b
#define ico1        0x043c
#define ico2        0x043d
#define ico3        0x043e
#define ico4        0x043f
    /* Static text */
#define stc1        0x0440
#define stc2        0x0441
#define stc3        0x0442
#define stc4        0x0443
#define stc5        0x0444
#define stc6        0x0445
#define stc7        0x0446
#define stc8        0x0447
#define stc9        0x0448
#define stc10       0x0449
#define stc11       0x044a
#define stc12       0x044b
#define stc13       0x044c
#define stc14       0x044d
#define stc15       0x044e
#define stc16       0x044f
#define stc17       0x0450
#define stc18       0x0451
#define stc19       0x0452
#define stc20       0x0453
#define stc21       0x0454
#define stc22       0x0455
#define stc23       0x0456
#define stc24       0x0457
#define stc25       0x0458
#define stc26       0x0459
#define stc27       0x045a
#define stc28       0x045b
#define stc29       0x045c
#define stc30       0x045d
#define stc31       0x045e
#define stc32       0x045f
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
#define lst3        0x0462
#define lst4        0x0463
#define lst5        0x0464
#define lst6        0x0465
#define lst7        0x0466
#define lst8        0x0467
#define lst9        0x0468
#define lst10       0x0469
#define lst11       0x046a
#define lst12       0x046b
#define lst13       0x046c
#define lst14       0x046d
#define lst15       0x046e
#define lst16       0x046f
    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
#define cmb3        0x0472
#define cmb4        0x0473
#define cmb5        0x0474
#define cmb6        0x0475
#define cmb7        0x0476
#define cmb8        0x0477
#define cmb9        0x0478
#define cmb10       0x0479
#define cmb11       0x047a
#define cmb12       0x047b
#define cmb13       0x047c
#define cmb14       0x047d
#define cmb15       0x047e
#define cmb16       0x047f
    /* Edit controls */
#define edt1        0x0480
#define edt2        0x0481
#define edt3        0x0482
#define edt4        0x0483
#define edt5        0x0484
#define edt6        0x0485
#define edt7        0x0486
#define edt8        0x0487
#define edt9        0x0488
#define edt10       0x0489
#define edt11       0x048a
#define edt12       0x048b
#define edt13       0x048c
#define edt14       0x048d
#define edt15       0x048e
#define edt16       0x048f
    /* Scroll bars */
#define scr1        0x0490
#define scr2        0x0491
#define scr3        0x0492
#define scr4        0x0493
#define scr5        0x0494
#define scr6        0x0495
#define scr7        0x0496
#define scr8        0x0497

/* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 */
#define FILEOPENORD      1536
#define MULTIFILEOPENORD 1537
#define PRINTDLGORD      1538
#define PRNSETUPDLGORD   1539
#define FINDDLGORD       1540
#define REPLACEDLGORD    1541
#define FONTDLGORD       1542
#define FORMATDLGORD31   1543
#define FORMATDLGORD30   1544

#endif  /* !_INC_DLGS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\drivinit.h ===
/* OBSOLETE: Use print.h instead */
#include <print.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\dispatch.h ===
/*** 
*dispatch.h - OLE Automation definitions.
*
*  Copyright (C) 1992-1993, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*  This file defines the Ole Automation interfaces and APIs.
*
*Implementation Notes:
*  This file requires ole2.h
*
*****************************************************************************/

#ifndef _DISPATCH_H_
#define _DISPATCH_H_

#include "variant.h"

#ifndef BEGIN_INTERFACE
# define BEGIN_INTERFACE
#endif

#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
# define UNION_NAME(X) X
#else
# define UNION_NAME(X)
#endif


DEFINE_OLEGUID(IID_IDispatch,		0x00020400L, 0, 0);
DEFINE_OLEGUID(IID_IEnumVARIANT,	0x00020404L, 0, 0);
DEFINE_OLEGUID(IID_ITypeInfo,		0x00020401L, 0, 0);
DEFINE_OLEGUID(IID_ITypeLib,		0x00020402L, 0, 0);
DEFINE_OLEGUID(IID_ITypeComp,		0x00020403L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeInfo,	0x00020405L, 0, 0);
DEFINE_OLEGUID(IID_ICreateTypeLib,	0x00020406L, 0, 0);
DEFINE_OLEGUID(IID_StdOle,		0x00020430L, 0, 0);


/* forward declarations */
#ifdef __cplusplus

  interface IDispatch;
  interface IEnumVARIANT;
  interface ITypeInfo;
  interface ITypeLib;
  interface ITypeComp;
  interface ICreateTypeInfo;
  interface ICreateTypeLib;
  
#else

  typedef interface IDispatch IDispatch;
  typedef interface IEnumVARIANT IEnumVARIANT;
  typedef interface ITypeInfo ITypeInfo;
  typedef interface ITypeLib ITypeLib;
  typedef interface ITypeComp ITypeComp;
  typedef interface ICreateTypeInfo ICreateTypeInfo;
  typedef interface ICreateTypeLib ICreateTypeLib;
  
#endif


/* IDispatch related error codes */

#define DISP_ERROR(X) MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, X)

#define DISP_E_UNKNOWNINTERFACE		DISP_ERROR(1)
#define DISP_E_MEMBERNOTFOUND		DISP_ERROR(3)
#define DISP_E_PARAMNOTFOUND		DISP_ERROR(4)
#define DISP_E_TYPEMISMATCH		DISP_ERROR(5)
#define DISP_E_UNKNOWNNAME		DISP_ERROR(6)
#define DISP_E_NONAMEDARGS		DISP_ERROR(7)
#define DISP_E_BADVARTYPE		DISP_ERROR(8)
#define DISP_E_EXCEPTION		DISP_ERROR(9)
#define DISP_E_OVERFLOW			DISP_ERROR(10)
#define DISP_E_BADINDEX			DISP_ERROR(11)
#define DISP_E_UNKNOWNLCID		DISP_ERROR(12)
#define DISP_E_ARRAYISLOCKED		DISP_ERROR(13)
#define DISP_E_BADPARAMCOUNT		DISP_ERROR(14)
#define DISP_E_PARAMNOTOPTIONAL		DISP_ERROR(15)
#define DISP_E_BADCALLEE		DISP_ERROR(16)
#define DISP_E_NOTACOLLECTION		DISP_ERROR(17)


#define TYPE_ERROR(X) MAKE_SCODE(SEVERITY_ERROR, FACILITY_DISPATCH, X)

#define TYPE_E_BUFFERTOOSMALL		TYPE_ERROR(32790)
#define TYPE_E_INVDATAREAD		TYPE_ERROR(32792)
#define TYPE_E_UNSUPFORMAT		TYPE_ERROR(32793)
#define TYPE_E_REGISTRYACCESS		TYPE_ERROR(32796)
#define TYPE_E_LIBNOTREGISTERED 	TYPE_ERROR(32797)
#define TYPE_E_UNDEFINEDTYPE		TYPE_ERROR(32807)
#define TYPE_E_QUALIFIEDNAMEDISALLOWED	TYPE_ERROR(32808)
#define TYPE_E_INVALIDSTATE		TYPE_ERROR(32809)
#define TYPE_E_WRONGTYPEKIND		TYPE_ERROR(32810)
#define TYPE_E_ELEMENTNOTFOUND		TYPE_ERROR(32811)
#define TYPE_E_AMBIGUOUSNAME		TYPE_ERROR(32812)
#define TYPE_E_NAMECONFLICT		TYPE_ERROR(32813)
#define TYPE_E_UNKNOWNLCID		TYPE_ERROR(32814)
#define TYPE_E_DLLFUNCTIONNOTFOUND	TYPE_ERROR(32815)
#define TYPE_E_BADMODULEKIND		TYPE_ERROR(35005)
#define TYPE_E_SIZETOOBIG		TYPE_ERROR(35013)
#define TYPE_E_DUPLICATEID		TYPE_ERROR(35014)
#define TYPE_E_TYPEMISMATCH		TYPE_ERROR(36000)
#define TYPE_E_OUTOFBOUNDS		TYPE_ERROR(36001)
#define TYPE_E_IOERROR			TYPE_ERROR(36002)
#define TYPE_E_CANTCREATETMPFILE	TYPE_ERROR(36003)
#define TYPE_E_CANTLOADLIBRARY		TYPE_ERROR(40010)
#define TYPE_E_INCONSISTENTPROPFUNCS	TYPE_ERROR(40067)
#define TYPE_E_CIRCULARTYPE		TYPE_ERROR(40068)


/* if not already picked up from olenls.h */
#ifndef _LCID_DEFINED
typedef unsigned long LCID;
# define _LCID_DEFINED
#endif



/*---------------------------------------------------------------------*/
/*                            BSTR API                                 */
/*---------------------------------------------------------------------*/

STDAPI_(BSTR) SysAllocString(const TCHAR FAR*);
STDAPI_(int)  SysReAllocString(BSTR FAR*, const TCHAR FAR*);
STDAPI_(BSTR) SysAllocStringLen(const TCHAR FAR*, unsigned int);
STDAPI_(int)  SysReAllocStringLen(BSTR FAR*, const TCHAR FAR*, unsigned int);
STDAPI_(void) SysFreeString(BSTR);  
STDAPI_(unsigned int) SysStringLen(BSTR);


  
/*---------------------------------------------------------------------*/
/*                            Time API                                 */
/*---------------------------------------------------------------------*/

STDAPI_(int)
DosDateTimeToVariantTime(
    unsigned short wDosDate,
    unsigned short wDosTime,
    double FAR* pvtime);

STDAPI_(int)
VariantTimeToDosDateTime(
    double vtime,
    unsigned short FAR* pwDosDate,
    unsigned short FAR* pwDosTime);


/*---------------------------------------------------------------------*/
/*                          SafeArray API                              */
/*---------------------------------------------------------------------*/

STDAPI
SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY FAR* FAR* ppsaOut);

STDAPI SafeArrayAllocData(SAFEARRAY FAR* psa);

STDAPI_(SAFEARRAY FAR*)
SafeArrayCreate(
    VARTYPE vt,
    unsigned int cDims,
    SAFEARRAYBOUND FAR* rgsabound);

STDAPI SafeArrayDestroyDescriptor(SAFEARRAY FAR* psa);

STDAPI SafeArrayDestroyData(SAFEARRAY FAR* psa);

STDAPI SafeArrayDestroy(SAFEARRAY FAR* psa);

STDAPI SafeArrayRedim(SAFEARRAY FAR* psa, SAFEARRAYBOUND FAR* psaboundNew);

STDAPI_(unsigned int) SafeArrayGetDim(SAFEARRAY FAR* psa);

STDAPI_(unsigned int) SafeArrayGetElemsize(SAFEARRAY FAR* psa);

STDAPI
SafeArrayGetUBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plUbound);

STDAPI
SafeArrayGetLBound(SAFEARRAY FAR* psa, unsigned int nDim, long FAR* plLbound);

STDAPI SafeArrayLock(SAFEARRAY FAR* psa);

STDAPI SafeArrayUnlock(SAFEARRAY FAR* psa);

STDAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData);

STDAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);

STDAPI
SafeArrayGetElement(
    SAFEARRAY FAR* psa,
    long FAR* rgIndices,
    void FAR* pv);

STDAPI
SafeArrayPutElement(
    SAFEARRAY FAR* psa,
    long FAR* rgIndices,
    void FAR* pv);

STDAPI
SafeArrayCopy(
    SAFEARRAY FAR* psa,
    SAFEARRAY FAR* FAR* ppsaOut);


/*---------------------------------------------------------------------*/
/*                           VARIANT API                               */
/*---------------------------------------------------------------------*/

STDAPI_(void)
VariantInit(VARIANTARG FAR* pvarg);

STDAPI
VariantClear(VARIANTARG FAR* pvarg);

STDAPI
VariantCopy(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvargSrc);

STDAPI
VariantCopyInd(
    VARIANT FAR* pvarDest,
    VARIANTARG FAR* pvargSrc);

STDAPI
VariantChangeType(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvarSrc,
    unsigned short wFlags,
    VARTYPE vt);

STDAPI
VariantChangeTypeEx(
    VARIANTARG FAR* pvargDest,
    VARIANTARG FAR* pvarSrc,
    LCID lcid,	    
    unsigned short wFlags,
    VARTYPE vt);

#define VARIANT_NOVALUEPROP 1


/*---------------------------------------------------------------------*/
/*                     VARTYPE Coercion API                            */
/*---------------------------------------------------------------------*/

/* Note: The routines that convert *from* a string are defined
 * to take a char* rather than a BSTR because no allocation is
 * required, and this makes the routines a bit more generic.
 * They may of course still be passed a BSTR as the strIn param.
 */

/* Mac Note: Due to a bug in the MPW C compiler having to do with
 * passing floats by value, all of the Var*FromR4 routines take
 * the fltIn param as a double instead of a float on the mac.
 */

/* Any of the coersion functions that converts either from or to a string
 * takes an additional lcid and dwFlags arguments. The lcid argument allows
 * locale specific parsing to occur.  The dwFlags allow additional function
 * specific condition to occur.  All function that accept the dwFlags argument
 * can include either 0 or LOCALE_NOUSEROVERRIDE flag. In addition, the
 * VarDateFromStr functions also accepts the VAR_TIMEVALUEONLY and 
 * VAR_DATEVALUEONLY flags
 */	 

#define VAR_TIMEVALUEONLY            0x0001    /* return time value */
#define VAR_DATEVALUEONLY            0x0002    /* return date value */

   
STDAPI VarI2FromI4(long lIn, short FAR* psOut);
#ifdef _MAC
STDAPI VarI2FromR4(double fltIn, short FAR* psOut);
#else
STDAPI VarI2FromR4(float fltIn, short FAR* psOut);
#endif
STDAPI VarI2FromR8(double dblIn, short FAR* psOut);
STDAPI VarI2FromCy(CY cyIn, short FAR* psOut);
STDAPI VarI2FromDate(DATE dateIn, short FAR* psOut);
STDAPI VarI2FromStr(TCHAR FAR* strIn, LCID lcid, unsigned long dwFlags, short FAR* psOut);
STDAPI VarI2FromDisp(IDispatch FAR* pdispIn, LCID lcid, short FAR* psOut);
STDAPI VarI2FromBool(VARIANT_BOOL boolIn, short FAR* psOut);

STDAPI VarI4FromI2(short sIn, long FAR* plOut);
#ifdef _MAC
STDAPI VarI4FromR4(double fltIn, long FAR* plOut);
#else
STDAPI VarI4FromR4(float fltIn, long FAR* plOut);
#endif
STDAPI VarI4FromR8(double dblIn, long FAR* plOut);
STDAPI VarI4FromCy(CY cyIn, long FAR* plOut);
STDAPI VarI4FromDate(DATE dateIn, long FAR* plOut);
STDAPI VarI4FromStr(TCHAR FAR* strIn, LCID lcid, unsigned long dwFlags, long FAR* plOut);
STDAPI VarI4FromDisp(IDispatch FAR* pdispIn, LCID lcid, long FAR* plOut);
STDAPI VarI4FromBool(VARIANT_BOOL boolIn, long FAR* plOut);

STDAPI VarR4FromI2(short sIn, float FAR* pfltOut);
STDAPI VarR4FromI4(long lIn, float FAR* pfltOut);
STDAPI VarR4FromR8(double dblIn, float FAR* pfltOut);
STDAPI VarR4FromCy(CY cyIn, float FAR* pfltOut);
STDAPI VarR4FromDate(DATE dateIn, float FAR* pfltOut);
STDAPI VarR4FromStr(TCHAR FAR* strIn, LCID lcid, unsigned long dwFlags, float FAR* pfltOut);
STDAPI VarR4FromDisp(IDispatch FAR* pdispIn, LCID lcid, float FAR* pfltOut);
STDAPI VarR4FromBool(VARIANT_BOOL boolIn, float FAR* pfltOut);

STDAPI VarR8FromI2(short sIn, double FAR* pdblOut);
STDAPI VarR8FromI4(long lIn, double FAR* pdblOut);
#ifdef _MAC
STDAPI VarR8FromR4(double fltIn, double FAR* pdblOut);
#else
STDAPI VarR8FromR4(float fltIn, double FAR* pdblOut);
#endif
STDAPI VarR8FromCy(CY cyIn, double FAR* pdblOut);
STDAPI VarR8FromDate(DATE dateIn, double FAR* pdblOut);
STDAPI VarR8FromStr(TCHAR FAR* strIn, LCID lcid, unsigned long dwFlags, double FAR* pdblOut);
STDAPI VarR8FromDisp(IDispatch FAR* pdispIn, LCID lcid, double FAR* pdblOut);
STDAPI VarR8FromBool(VARIANT_BOOL boolIn, double FAR* pdblOut);

STDAPI VarDateFromI2(short sIn, DATE FAR* pdateOut);
STDAPI VarDateFromI4(long lIn, DATE FAR* pdateOut);
#ifdef _MAC
STDAPI VarDateFromR4(double fltIn, DATE FAR* pdateOut);
#else
STDAPI VarDateFromR4(float fltIn, DATE FAR* pdateOut);
#endif
STDAPI VarDateFromR8(double dblIn, DATE FAR* pdateOut);
STDAPI VarDateFromCy(CY cyIn, DATE FAR* pdateOut);
STDAPI VarDateFromStr(TCHAR FAR* strIn, LCID lcid, unsigned long dwFlags, DATE FAR* pdateOut);
STDAPI VarDateFromDisp(IDispatch FAR* pdispIn, LCID lcid, DATE FAR* pdateOut);
STDAPI VarDateFromBool(VARIANT_BOOL boolIn, DATE FAR* pdateOut);

STDAPI VarCyFromI2(short sIn, CY FAR* pcyOut);
STDAPI VarCyFromI4(long lIn, CY FAR* pcyOut);
#ifdef _MAC
STDAPI VarCyFromR4(double fltIn, CY FAR* pcyOut);
#else
STDAPI VarCyFromR4(float fltIn, CY FAR* pcyOut);
#endif
STDAPI VarCyFromR8(double dblIn, CY FAR* pcyOut);
STDAPI VarCyFromDate(DATE dateIn, CY FAR* pcyOut);
STDAPI VarCyFromStr(TCHAR FAR* strIn, LCID lcid, unsigned long dwFlags, CY FAR* pcyOut);
STDAPI VarCyFromDisp(IDispatch FAR* pdispIn, LCID lcid, CY FAR* pcyOut);
STDAPI VarCyFromBool(VARIANT_BOOL boolIn, CY FAR* pcyOut);

STDAPI VarBstrFromI2(short iVal, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
STDAPI VarBstrFromI4(long lIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
#ifdef _MAC
STDAPI VarBstrFromR4(double fltIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
#else
STDAPI VarBstrFromR4(float fltIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
#endif
STDAPI VarBstrFromR8(double dblIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
STDAPI VarBstrFromCy(CY cyIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
STDAPI VarBstrFromDate(DATE dateIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
STDAPI VarBstrFromDisp(IDispatch FAR* pdispIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);
STDAPI VarBstrFromBool(VARIANT_BOOL boolIn, LCID lcid, unsigned long dwFlags, BSTR FAR* pbstrOut);

STDAPI VarBoolFromI2(short sIn, VARIANT_BOOL FAR* pboolOut);
STDAPI VarBoolFromI4(long lIn, VARIANT_BOOL FAR* pboolOut);
#ifdef _MAC
STDAPI VarBoolFromR4(double fltIn, VARIANT_BOOL FAR* pboolOut);
#else
STDAPI VarBoolFromR4(float fltIn, VARIANT_BOOL FAR* pboolOut);
#endif
STDAPI VarBoolFromR8(double dblIn, VARIANT_BOOL FAR* pboolOut);
STDAPI VarBoolFromDate(DATE dateIn, VARIANT_BOOL FAR* pboolOut);
STDAPI VarBoolFromCy(CY cyIn, VARIANT_BOOL FAR* pboolOut);
STDAPI VarBoolFromStr(TCHAR FAR* strIn, LCID lcid, unsigned long dwFlags, VARIANT_BOOL FAR* pboolOut);
STDAPI VarBoolFromDisp(IDispatch FAR* pdispIn, LCID lcid, VARIANT_BOOL FAR* pboolOut);



/*---------------------------------------------------------------------*/
/*                             ITypeLib                                */
/*---------------------------------------------------------------------*/


typedef long DISPID;
typedef DISPID MEMBERID;

#define MEMBERID_NIL DISPID_UNKNOWN
#define ID_DEFAULTINST  -2

typedef enum tagSYSKIND {
      SYS_WIN16
    , SYS_WIN32
    , SYS_MAC
#ifdef _MAC
    , SYS_FORCELONG = 2147483647
#endif
} SYSKIND;

typedef enum tagLIBFLAGS {
      LIBFLAG_FRESTRICTED = 1
#ifdef _MAC
    , LIBFLAG_FORCELONG  = 2147483647
#endif
} LIBFLAGS;

typedef struct FARSTRUCT tagTLIBATTR {
    GUID guid;			/* globally unique library id */
    LCID lcid;			/* locale of the TypeLibrary */
    SYSKIND syskind;
    unsigned short wMajorVerNum;/* major version number	*/
    unsigned short wMinorVerNum;/* minor version number	*/
    unsigned short wLibFlags;	/* library flags */
} TLIBATTR, FAR* LPTLIBATTR;

typedef enum tagTYPEKIND {
      TKIND_ENUM = 0
    , TKIND_RECORD
    , TKIND_MODULE
    , TKIND_INTERFACE
    , TKIND_DISPATCH
    , TKIND_COCLASS
    , TKIND_ALIAS
    , TKIND_UNION
    , TKIND_MAX			/* end of enum marker */
#ifdef _MAC
    , TKIND_FORCELONG = 2147483647
#endif
} TYPEKIND;

#undef  INTERFACE
#define INTERFACE ITypeLib

DECLARE_INTERFACE_(ITypeLib, IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
    STDMETHOD_(unsigned long, Release)(THIS) PURE;

    /* ITypeLib methods */
    STDMETHOD_(unsigned int,GetTypeInfoCount)(THIS) PURE;

    STDMETHOD(GetTypeInfo)(THIS_
      unsigned int index, ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetTypeInfoType)(THIS_
      unsigned int index, TYPEKIND FAR* ptypekind) PURE;

    STDMETHOD(GetTypeInfoOfGuid)(THIS_
      REFGUID guid, ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetLibAttr)(THIS_
      TLIBATTR FAR* FAR* pptlibattr) PURE;

    STDMETHOD(GetTypeComp)(THIS_
      ITypeComp FAR* FAR* pptcomp) PURE;

    STDMETHOD(GetDocumentation)(THIS_
      int index,
      BSTR FAR* pbstrName,
      BSTR FAR* pbstrDocString,
      unsigned long FAR* pdwHelpContext,
      BSTR FAR* pbstrHelpFile) PURE;

    STDMETHOD(IsName)(THIS_ 
      TCHAR FAR* szNameBuf,
      unsigned long lHashVal,
      int FAR* lpfName) PURE;

    STDMETHOD(FindName)(THIS_
      TCHAR FAR* szNameBuf,
      unsigned long lHashVal,
      ITypeInfo FAR* FAR* rgptinfo,
      MEMBERID FAR* rgmemid,
      unsigned short FAR* pcFound) PURE;

    STDMETHOD_(void, ReleaseTLibAttr)(THIS_ TLIBATTR FAR* ptlibattr) PURE;
};

typedef ITypeLib FAR* LPTYPELIB;



/*---------------------------------------------------------------------*/
/*                            ITypeInfo                                */
/*---------------------------------------------------------------------*/

typedef unsigned long HREFTYPE;


typedef struct FARSTRUCT tagTYPEDESC {
    union {
      /* VT_PTR - the pointed-at type */
      struct FARSTRUCT tagTYPEDESC FAR* lptdesc;

      /* VT_CARRAY */
      struct FARSTRUCT tagARRAYDESC FAR* lpadesc;

      /* VT_USERDEFINED - this is used to get a TypeInfo for the UDT */
      HREFTYPE hreftype;

    }UNION_NAME(u);
    VARTYPE vt;
} TYPEDESC;

typedef struct FARSTRUCT tagARRAYDESC {
    TYPEDESC tdescElem;		/* element type */
    unsigned short cDims;	/* dimension count */
    SAFEARRAYBOUND rgbounds[1];	/* variable length array of bounds */
} ARRAYDESC;

typedef struct FARSTRUCT tagIDLDESC {
    BSTR bstrIDLInfo;
    unsigned short wIDLFlags;	/* IN, OUT, etc */
} IDLDESC, FAR* LPIDLDESC;


#define IDLFLAG_NONE	0
#define IDLFLAG_FIN	0x1
#define IDLFLAG_FOUT	0x2

typedef struct FARSTRUCT tagELEMDESC {
    TYPEDESC tdesc;		/* the type of the element */
    IDLDESC idldesc;		/* info for remoting the element */ 
} ELEMDESC, FAR* LPELEMDESC;


typedef struct FARSTRUCT tagTYPEATTR {
    GUID guid;			/* the GUID of the TypeInfo */
    LCID lcid;			/* locale of member names and doc strings */
    unsigned long dwReserved;
    MEMBERID memidConstructor;	/* ID of constructor, MEMBERID_NIL if none */
    MEMBERID memidDestructor;	/* ID of destructor, MEMBERID_NIL if none */
    TCHAR FAR* lpstrSchema;	/* reserved for future use */
    unsigned long cbSizeInstance;/* the size of an instance of this type */
    TYPEKIND typekind;		/* the kind of type this typeinfo describes */
    unsigned short cFuncs;	/* number of functions */
    unsigned short cVars;	/* number of variables / data members */
    unsigned short cImplTypes;	/* number of implemented interfaces */
    unsigned short cbSizeVft;	/* the size of this types virtual func table */
    unsigned short cbAlignment;	/* the alignment for an instance of this type */
    unsigned short wTypeFlags;
    unsigned short wMajorVerNum;/* major version number */
    unsigned short wMinorVerNum;/* minor version number */
    TYPEDESC tdescAlias;	/* if typekind == TKIND_ALIAS this specifies
				   the type for which this type is an alias */
    IDLDESC idldescType;        /* IDL attributes of the described type */
} TYPEATTR, FAR* LPTYPEATTR;

typedef struct FARSTRUCT tagDISPPARAMS{
    VARIANTARG FAR* rgvarg;
    DISPID FAR* rgdispidNamedArgs;
    unsigned int cArgs;
    unsigned int cNamedArgs;
} DISPPARAMS;

typedef struct FARSTRUCT tagEXCEPINFO {
    unsigned short wCode;             /* An error code describing the error. */
				      /* Either (but not both) the wCode or */
				      /* scode fields must be set */
    unsigned short wReserved;

    BSTR bstrSource;	    /* A textual, human readable name of the
			       source of the exception. It is up to the
			       IDispatch implementor to fill this in.
			       Typically this will be an application name. */

    BSTR bstrDescription;   /* A textual, human readable description of the
			       error. If no description is available, NULL
			       should be used. */

    BSTR bstrHelpFile;      /* Fully qualified drive, path, and file name
			       of a help file with more information about
			       the error.  If no help is available, NULL
			       should be used. */

    unsigned long dwHelpContext;
			    /* help context of topic within the help file. */

    void FAR* pvReserved;

    /* Use of this field allows an application to defer filling in
       the bstrDescription, bstrHelpFile, and dwHelpContext fields
       until they are needed.  This field might be used, for example,
       if loading the string for the error is a time-consuming
       operation. If deferred fill-in is not desired, this field should
       be set to NULL. */
#ifdef _MAC
# ifdef _MSC_VER
    HRESULT (STDAPICALLTYPE FAR* pfnDeferredFillIn)(struct tagEXCEPINFO FAR*);
# else
    STDAPICALLTYPE HRESULT (FAR* pfnDeferredFillIn)(struct tagEXCEPINFO FAR*);
# endif
#else
    HRESULT (STDAPICALLTYPE FAR* pfnDeferredFillIn)(struct tagEXCEPINFO FAR*);
#endif

    SCODE scode;		/* An SCODE describing the error. */

} EXCEPINFO, FAR* LPEXCEPINFO;

typedef enum tagCALLCONV {
      CC_CDECL = 1
    , CC_MSCPASCAL
    , CC_PASCAL = CC_MSCPASCAL
    , CC_MACPASCAL
    , CC_STDCALL
    , CC_RESERVED
    , CC_SYSCALL
    , CC_MAX			/* end of enum marker */
#ifdef _MAC
    , CC_FORCELONG = 2147483647
#endif
} CALLCONV;

typedef enum tagFUNCKIND {
      FUNC_VIRTUAL
    , FUNC_PUREVIRTUAL
    , FUNC_NONVIRTUAL
    , FUNC_STATIC
    , FUNC_DISPATCH
#ifdef _MAC
    , FUNC_FORCELONG = 2147483647
#endif
} FUNCKIND;

/* Flags for IDispatch::Invoke */
#define DISPATCH_METHOD		0x1
#define DISPATCH_PROPERTYGET	0x2
#define DISPATCH_PROPERTYPUT	0x4
#define DISPATCH_PROPERTYPUTREF	0x8

typedef enum tagINVOKEKIND {
      INVOKE_FUNC = DISPATCH_METHOD
    , INVOKE_PROPERTYGET = DISPATCH_PROPERTYGET
    , INVOKE_PROPERTYPUT = DISPATCH_PROPERTYPUT
    , INVOKE_PROPERTYPUTREF = DISPATCH_PROPERTYPUTREF
#ifdef _MAC
    , INVOKE_FORCELONG = 2147483647
#endif
} INVOKEKIND;

typedef struct FARSTRUCT tagFUNCDESC {
    MEMBERID memid;
    SCODE FAR* lprgscode;
    ELEMDESC FAR* lprgelemdescParam;  /* array of parameter types */
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    short cParams;
    short cParamsOpt;
    short oVft;
    short cScodes;
    ELEMDESC elemdescFunc;
    unsigned short wFuncFlags;
} FUNCDESC, FAR* LPFUNCDESC;

typedef enum tagVARKIND {
      VAR_PERINSTANCE
    , VAR_STATIC
    , VAR_CONST
    , VAR_DISPATCH
#ifdef _MAC
    , VAR_FORCELONG = 2147483647
#endif
} VARKIND;

typedef struct FARSTRUCT tagVARDESC {
    MEMBERID memid;
    TCHAR FAR* lpstrSchema;		/* reserved for future use */
    union {
      /* VAR_PERINSTANCE - the offset of this variable within the instance */
      unsigned long oInst;

      /* VAR_CONST - the value of the constant */
      VARIANT FAR* lpvarValue;

    }UNION_NAME(u);
    ELEMDESC elemdescVar;
    unsigned short wVarFlags;
    VARKIND varkind;
} VARDESC, FAR* LPVARDESC;

typedef enum tagTYPEFLAGS {
      TYPEFLAG_FAPPOBJECT = 1
    , TYPEFLAG_FCANCREATE = 2
#ifdef _MAC
    , TYPEFLAG_FORCELONG  = 2147483647
#endif
} TYPEFLAGS;

typedef enum tagFUNCFLAGS {
      FUNCFLAG_FRESTRICTED= 1
#ifdef _MAC
    , FUNCFLAG_FORCELONG  = 2147483647
#endif
} FUNCFLAGS;

typedef enum tagVARFLAGS {
      VARFLAG_FREADONLY   = 1
#ifdef _MAC
    , VARFLAG_FORCELONG   = 2147483647
#endif
} VARFLAGS;

/* IMPLTYPE Flags */
#define IMPLTYPEFLAG_FDEFAULT		0x1
#define IMPLTYPEFLAG_FSOURCE		0x2
#define IMPLTYPEFLAG_FRESTRICTED	0x4

#undef  INTERFACE
#define INTERFACE ITypeInfo

DECLARE_INTERFACE_(ITypeInfo, IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
    STDMETHOD_(unsigned long, Release)(THIS) PURE;

    /* ITypeInfo methods */
    STDMETHOD(GetTypeAttr)(THIS_ TYPEATTR FAR* FAR* pptypeattr) PURE;

    STDMETHOD(GetTypeComp)(THIS_ ITypeComp FAR* FAR* pptcomp) PURE;

    STDMETHOD(GetFuncDesc)(THIS_
      unsigned int index, FUNCDESC FAR* FAR* ppfuncdesc) PURE;

    STDMETHOD(GetVarDesc)(THIS_
      unsigned int index, VARDESC FAR* FAR* ppvardesc) PURE;

    STDMETHOD(GetNames)(THIS_
      MEMBERID memid,
      BSTR FAR* rgbstrNames,
      unsigned int cMaxNames,
      unsigned int FAR* pcNames) PURE;

    STDMETHOD(GetRefTypeOfImplType)(THIS_
      unsigned int index, HREFTYPE FAR* phreftype) PURE;

    STDMETHOD(GetImplTypeFlags)(THIS_
      unsigned int index, int FAR* pimpltypeflags) PURE;

    STDMETHOD(GetIDsOfNames)(THIS_
      TCHAR FAR* FAR* rgszNames,
      unsigned int cNames,
      MEMBERID FAR* rgmemid) PURE;

    STDMETHOD(Invoke)(THIS_
      void FAR* pvInstance,
      MEMBERID memid,
      unsigned short wFlags,
      DISPPARAMS FAR *pdispparams,
      VARIANT FAR *pvarResult,
      EXCEPINFO FAR *pexcepinfo,
      unsigned int FAR *puArgErr) PURE;

    STDMETHOD(GetDocumentation)(THIS_
      MEMBERID memid,
      BSTR FAR* pbstrName,
      BSTR FAR* pbstrDocString,
      unsigned long FAR* pdwHelpContext,
      BSTR FAR* pbstrHelpFile) PURE;

    STDMETHOD(GetDllEntry)(THIS_
      MEMBERID memid,
      INVOKEKIND invkind, 
      BSTR FAR* pbstrDllName,
      BSTR FAR* pbstrName,
      unsigned short FAR* pwOrdinal) PURE;

    STDMETHOD(GetRefTypeInfo)(THIS_
      HREFTYPE hreftype, ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(AddressOfMember)(THIS_
      MEMBERID memid, INVOKEKIND invkind, void FAR* FAR* ppv) PURE;

    STDMETHOD(CreateInstance)(THIS_
      IUnknown FAR* punkOuter,
      REFIID riid,
      void FAR* FAR* ppvObj) PURE;

    STDMETHOD(GetMops)(THIS_ MEMBERID memid, BSTR FAR* pbstrMops) PURE;

    STDMETHOD(GetContainingTypeLib)(THIS_
      ITypeLib FAR* FAR* pptlib, unsigned int FAR* pindex) PURE;

    STDMETHOD_(void, ReleaseTypeAttr)(THIS_ TYPEATTR FAR* ptypeattr) PURE;
    STDMETHOD_(void, ReleaseFuncDesc)(THIS_ FUNCDESC FAR* pfuncdesc) PURE;
    STDMETHOD_(void, ReleaseVarDesc)(THIS_ VARDESC FAR* pvardesc) PURE;
};

typedef ITypeInfo FAR* LPTYPEINFO;


/*---------------------------------------------------------------------*/
/*                            ITypeComp                                */
/*---------------------------------------------------------------------*/

typedef enum tagDESCKIND {
      DESCKIND_NONE = 0
    , DESCKIND_FUNCDESC
    , DESCKIND_VARDESC
    , DESCKIND_TYPECOMP
    , DESCKIND_IMPLICITAPPOBJ
    , DESCKIND_MAX		/* end of enum marker */
#ifdef _MAC
    , DESCKIND_FORCELONG = 2147483647
#endif
} DESCKIND;

typedef union tagBINDPTR {
    FUNCDESC FAR* lpfuncdesc;
    VARDESC FAR* lpvardesc;
    ITypeComp FAR* lptcomp;
} BINDPTR, FAR* LPBINDPTR;


#undef  INTERFACE
#define INTERFACE ITypeComp

DECLARE_INTERFACE_(ITypeComp, IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
    STDMETHOD_(unsigned long, Release)(THIS) PURE;

    /* ITypeComp methods */
    STDMETHOD(Bind)(THIS_
      TCHAR FAR* szName,
      unsigned long lHashVal,
      unsigned short wflags,
      ITypeInfo FAR* FAR* pptinfo,
      DESCKIND FAR* pdesckind,
      BINDPTR FAR* pbindptr) PURE;

    STDMETHOD(BindType)(THIS_
      TCHAR FAR* szName,
      unsigned long lHashVal,
      ITypeInfo FAR* FAR* pptinfo,
      ITypeComp FAR* FAR* pptcomp) PURE;
};

typedef ITypeComp FAR* LPTYPECOMP;



/*---------------------------------------------------------------------*/
/*                         ICreateTypeLib                              */
/*---------------------------------------------------------------------*/


#undef  INTERFACE
#define INTERFACE ICreateTypeLib

DECLARE_INTERFACE_(ICreateTypeLib, IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
    STDMETHOD_(unsigned long, Release)(THIS) PURE;

    /* ICreateTypeLib methods */
    STDMETHOD(CreateTypeInfo)(THIS_
      TCHAR FAR* szName,
      TYPEKIND tkind,
      ICreateTypeInfo FAR* FAR* lplpictinfo) PURE;

    STDMETHOD(SetName)(THIS_ TCHAR FAR* szName) PURE;

    STDMETHOD(SetVersion)(THIS_
      unsigned short wMajorVerNum, unsigned short wMinorVerNum) PURE;

    STDMETHOD(SetGuid) (THIS_ REFGUID guid) PURE;

    STDMETHOD(SetDocString)(THIS_ TCHAR FAR* szDoc) PURE;

    STDMETHOD(SetHelpFileName)(THIS_ TCHAR FAR* szHelpFileName) PURE;

    STDMETHOD(SetHelpContext)(THIS_ unsigned long dwHelpContext) PURE;

    STDMETHOD(SetLcid)(THIS_ LCID lcid) PURE;

    STDMETHOD(SetLibFlags)(THIS_ unsigned int uLibFlags) PURE;

    STDMETHOD(SaveAllChanges)(THIS) PURE;
};

typedef ICreateTypeLib FAR* LPCREATETYPELIB;



/*---------------------------------------------------------------------*/
/*                         ICreateTypeInfo                             */
/*---------------------------------------------------------------------*/

#undef  INTERFACE
#define INTERFACE ICreateTypeInfo

DECLARE_INTERFACE_(ICreateTypeInfo, IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
    STDMETHOD_(unsigned long, Release)(THIS) PURE;

    /* ICreateTypeInfo methods */
    STDMETHOD(SetGuid)(THIS_ REFGUID guid) PURE;

    STDMETHOD(SetTypeFlags)(THIS_ unsigned int uTypeFlags) PURE;

    STDMETHOD(SetDocString)(THIS_ TCHAR FAR* pstrDoc) PURE;

    STDMETHOD(SetHelpContext)(THIS_ unsigned long dwHelpContext) PURE;

    STDMETHOD(SetVersion)(THIS_
      unsigned short wMajorVerNum, unsigned short wMinorVerNum) PURE;

    STDMETHOD(AddRefTypeInfo)(THIS_
      ITypeInfo FAR* ptinfo, HREFTYPE FAR* phreftype) PURE;

    STDMETHOD(AddFuncDesc)(THIS_
      unsigned int index, FUNCDESC FAR* pfuncdesc) PURE;

    STDMETHOD(AddImplType)(THIS_
      unsigned int index, HREFTYPE hreftype) PURE;

    STDMETHOD(SetImplTypeFlags)(THIS_
      unsigned int index, int impltypeflags) PURE;

    STDMETHOD(SetAlignment)(THIS_ unsigned short cbAlignment) PURE;

    STDMETHOD(SetSchema)(THIS_ TCHAR FAR* lpstrSchema) PURE;

    STDMETHOD(AddVarDesc)(THIS_
      unsigned int index, VARDESC FAR* pvardesc) PURE;

    STDMETHOD(SetFuncAndParamNames)(THIS_
      unsigned int index, TCHAR FAR* FAR* rgszNames, unsigned int cNames) PURE;

    STDMETHOD(SetVarName)(THIS_
      unsigned int index, TCHAR FAR* szName) PURE;

    STDMETHOD(SetTypeDescAlias)(THIS_
      TYPEDESC FAR* ptdescAlias) PURE;

    STDMETHOD(DefineFuncAsDllEntry)(THIS_
      unsigned int index, TCHAR FAR* szDllName, TCHAR FAR* szProcName) PURE;

    STDMETHOD(SetFuncDocString)(THIS_
      unsigned int index, TCHAR FAR* szDocString) PURE;

    STDMETHOD(SetVarDocString)(THIS_
      unsigned int index, TCHAR FAR* szDocString) PURE;

    STDMETHOD(SetFuncHelpContext)(THIS_
      unsigned int index, unsigned long dwHelpContext) PURE;

    STDMETHOD(SetVarHelpContext)(THIS_
      unsigned int index, unsigned long dwHelpContext) PURE;

    STDMETHOD(SetMops)(THIS_
      unsigned int index, BSTR bstrMops) PURE;

    STDMETHOD(SetTypeIdldesc)(THIS_
      IDLDESC FAR* pidldesc) PURE;

    STDMETHOD(LayOut)(THIS) PURE;
};

typedef ICreateTypeInfo FAR* LPCREATETYPEINFO;



/*---------------------------------------------------------------------*/
/*                         TypeInfo APIs                               */
/*---------------------------------------------------------------------*/
/* compute a 32bit hash value for the given name  based on the lcid and system kind
 */
STDAPI_(unsigned long)
LHashValOfNameSys(SYSKIND syskind, LCID lcid, TCHAR FAR* szName);

/* Macro to compute a 32bit hash value for the given name based on the LCID
 */
#ifdef _MAC
#define LHashValOfName(lcid, szName) \
	LHashValOfNameSys(SYS_MAC, lcid, szName)
#else
#define LHashValOfName(lcid, szName) \
	LHashValOfNameSys(SYS_WIN32, lcid, szName)
#endif

/* compute a 16bit hash value from 32 bit hash value
 */
#define WHashValOfLHashVal(lhashval) \
	 ((unsigned short) (0x0000ffff & (lhashval)))

/* Check if the hash values are compatible.
*/
#define IsHashValCompatible(lhashval1, lhashval2) \
	((BOOL) ((0x00ff0000 & (lhashval1)) == (0x00ff0000 & (lhashval2))))

/* load the typelib from the file with the given filename
 */
STDAPI
LoadTypeLib(TCHAR FAR* szFile, ITypeLib FAR* FAR* pptlib);

/* load registered typelib
 */
STDAPI
LoadRegTypeLib(
    REFGUID rguid,
    unsigned short wVerMajor,
    unsigned short wVerMinor,
    LCID lcid,
    ITypeLib FAR* FAR* pptlib);

/* get path to registered typelib
 */
STDAPI
QueryPathOfRegTypeLib(
    REFGUID guid,
    unsigned short wMaj,
    unsigned short wMin,
    LCID lcid,
    LPBSTR lpbstrPathName);

/* add typelib to registry
 */
STDAPI
RegisterTypeLib(
    ITypeLib FAR* ptlib,
    TCHAR FAR* szFullPath,
    TCHAR FAR* szHelpDir);

STDAPI
CreateTypeLib(SYSKIND syskind, LPSTR szFile, ICreateTypeLib FAR* FAR* ppctlib);



/*---------------------------------------------------------------------*/
/*                          IEnumVARIANT                               */
/*---------------------------------------------------------------------*/

#undef  INTERFACE
#define INTERFACE IEnumVARIANT

DECLARE_INTERFACE_(IEnumVARIANT, IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
    STDMETHOD_(unsigned long, Release)(THIS) PURE;

    /* IEnumVARIANT methods */
    STDMETHOD(Next)(
      THIS_ unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched) PURE;
    STDMETHOD(Skip)(THIS_ unsigned long celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone)(THIS_ IEnumVARIANT FAR* FAR* ppenum) PURE;
};

typedef IEnumVARIANT FAR* LPENUMVARIANT;


/*---------------------------------------------------------------------*/
/*                             IDispatch                               */
/*---------------------------------------------------------------------*/


#undef  INTERFACE
#define INTERFACE IDispatch

DECLARE_INTERFACE_(IDispatch, IUnknown)
{
    BEGIN_INTERFACE

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void FAR* FAR* ppvObj) PURE;
    STDMETHOD_(unsigned long, AddRef)(THIS) PURE;
    STDMETHOD_(unsigned long, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ unsigned int FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      unsigned int itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      TCHAR FAR* FAR* rgszNames,
      unsigned int cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      unsigned short wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      unsigned int FAR* puArgErr) PURE;
};

typedef IDispatch FAR* LPDISPATCH;


/* DISPID reserved for the standard "value" property */
#define DISPID_VALUE	0

/* DISPID reserved to indicate an "unknown" name */
#define DISPID_UNKNOWN	-1

/* The following DISPID is reserved to indicate the param
 * that is the right-hand-side (or "put" value) of a PropertyPut
 */
#define DISPID_PROPERTYPUT -3

/* DISPID reserved for the standard "NewEnum" method */
#define DISPID_NEWENUM	-4

/* DISPID reserved for the standard "Evaluate" method */
#define DISPID_EVALUATE	-5


/*---------------------------------------------------------------------*/
/*                   IDispatch implementation support                  */
/*---------------------------------------------------------------------*/

typedef struct FARSTRUCT tagPARAMDATA {
    TCHAR FAR* szName;		/* parameter name */
    VARTYPE vt;			/* parameter type */
} PARAMDATA, FAR* LPPARAMDATA;

typedef struct FARSTRUCT tagMETHODDATA {
    TCHAR FAR* szName;		/* method name */
    PARAMDATA FAR* ppdata;	/* pointer to an array of PARAMDATAs */
    DISPID dispid;		/* method ID */
    unsigned int iMeth;		/* method index */
    CALLCONV cc;		/* calling convention */
    unsigned int cArgs;		/* count of arguments */
    unsigned short wFlags;	/* same wFlags as on IDispatch::Invoke() */
    VARTYPE vtReturn;
} METHODDATA, FAR* LPMETHODDATA;

typedef struct FARSTRUCT tagINTERFACEDATA {
    METHODDATA FAR* pmethdata;	/* pointer to an array of METHODDATAs */
    unsigned int cMembers;	/* count of members */
} INTERFACEDATA, FAR* LPINTERFACEDATA;



/* Locate the parameter indicated by the given position, and
 * return it coerced to the given target VARTYPE (vtTarg).
 */
STDAPI
DispGetParam(
    DISPPARAMS FAR* pdispparams,
    unsigned int position,
    VARTYPE vtTarg,
    VARIANT FAR* pvarResult,
    unsigned int FAR* puArgErr);

/* Automatic TypeInfo driven implementation of IDispatch::GetIDsOfNames()
 */ 
STDAPI
DispGetIDsOfNames(
    ITypeInfo FAR* ptinfo,
    TCHAR FAR* FAR* rgszNames,
    unsigned int cNames,
    DISPID FAR* rgdispid);

/* Automatic TypeInfo driven implementation of IDispatch::Invoke()
 */
STDAPI
DispInvoke(
    void FAR* _this,
    ITypeInfo FAR* ptinfo,
    DISPID dispidMember,
    unsigned short wFlags,
    DISPPARAMS FAR* pparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr);

/* Construct a TypeInfo from an interface data description
 */
STDAPI
CreateDispTypeInfo(
    INTERFACEDATA FAR* pidata,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo);

/* Create an instance of the standard TypeInfo driven IDispatch
 * implementation.
 */
STDAPI
CreateStdDispatch(
    IUnknown FAR* punkOuter,
    void FAR* pvThis,
    ITypeInfo FAR* ptinfo,
    IUnknown FAR* FAR* ppunkStdDisp);



/*---------------------------------------------------------------------*/
/*                    Active Object Registration API                   */
/*---------------------------------------------------------------------*/

STDAPI
RegisterActiveObject(
    IUnknown FAR* punk,
    REFCLSID rclsid,
    void FAR* pvReserved,
    unsigned long FAR* pdwRegister);

STDAPI
RevokeActiveObject(
    unsigned long dwRegister,
    void FAR* pvReserved);

STDAPI
GetActiveObject(
    REFCLSID rclsid,
    void FAR* pvReserved,
    IUnknown FAR* FAR* ppunk);


#undef UNION_NAME

#endif /* _DISPATCH_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\errno.h ===
/***
*errno.h - system wide error numbers (set by system calls)
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the system-wide error numbers (set by
*   system calls).  Conforms to the XENIX standard.  Extended
*   for compatibility with Uniforum standard.
*   [ANSI/System V]
*
****/

#ifndef _INC_ERRNO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* declare reference to errno */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 

/* Error Codes */

#define EZERO       0
#define EPERM       1
#define ENOENT      2
#define ESRCH       3
#define EINTR       4
#define EIO     5
#define ENXIO       6
#define E2BIG       7
#define ENOEXEC     8
#define EBADF       9
#define ECHILD      10
#define EAGAIN      11
#define ENOMEM      12
#define EACCES      13
#define EFAULT      14
#define ENOTBLK     15
#define EBUSY       16
#define EEXIST      17
#define EXDEV       18
#define ENODEV      19
#define ENOTDIR     20
#define EISDIR      21
#define EINVAL      22
#define ENFILE      23
#define EMFILE      24
#define ENOTTY      25
#define ETXTBSY     26
#define EFBIG       27
#define ENOSPC      28
#define ESPIPE      29
#define EROFS       30
#define EMLINK      31
#define EPIPE       32
#define EDOM        33
#define ERANGE      34
#define EUCLEAN     35
#define EDEADLOCK   36

#ifdef __cplusplus
}
#endif 

#define _INC_ERRNO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\dos.h ===
/***
*dos.h - definitions for MS-DOS interface routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Defines the structs and unions used for the direct DOS interface
*   routines; includes macros to access the segment and offset
*   values of far pointers, so that they may be used by the routines; and
*   provides function prototypes for direct DOS interface functions.
*
****/

#ifndef _INC_DOS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __interrupt _interrupt
#define __near      _near
#endif 

#ifndef _REGS_DEFINED

/* word registers */

struct _WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

/* byte registers */

struct _BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

/* general purpose registers union -
 *  overlays the corresponding word and byte registers.
 */

union _REGS {
    struct _WORDREGS x;
    struct _BYTEREGS h;
    };

/* segment registers */

struct _SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */

struct WORDREGS {
    unsigned int ax;
    unsigned int bx;
    unsigned int cx;
    unsigned int dx;
    unsigned int si;
    unsigned int di;
    unsigned int cflag;
    };

struct BYTEREGS {
    unsigned char al, ah;
    unsigned char bl, bh;
    unsigned char cl, ch;
    unsigned char dl, dh;
    };

union REGS {
    struct WORDREGS x;
    struct BYTEREGS h;
    };

struct SREGS {
    unsigned int es;
    unsigned int cs;
    unsigned int ss;
    unsigned int ds;
    };

#endif 

#define _REGS_DEFINED
#endif 


/* dosexterror structure */

#ifndef _DOSERROR_DEFINED
#pragma pack(2)

struct _DOSERROR {
    int exterror;
    char errclass;
    char action;
    char locus;
    };

#if ((!defined (__STDC__)) && (!defined (__cplusplus)))
/* Non-ANSI name for compatibility */
struct DOSERROR {
    int exterror;
    char class;
    char action;
    char locus;
    };
#endif 

#pragma pack()
#define _DOSERROR_DEFINED
#endif 


/* _dos_findfirst structure */

#ifndef _FIND_T_DEFINED
#pragma pack(2)

struct _find_t {
    char reserved[21];
    char attrib;
    unsigned wr_time;
    unsigned wr_date;
    long size;
    char name[13];
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define find_t _find_t
#endif 

#pragma pack()
#define _FIND_T_DEFINED
#endif 


/* _dos_getdate/_dossetdate and _dos_gettime/_dos_settime structures */

#ifndef _DATETIME_T_DEFINED
#pragma pack(2)

struct _dosdate_t {
    unsigned char day;      /* 1-31 */
    unsigned char month;        /* 1-12 */
    unsigned int year;      /* 1980-2099 */
    unsigned char dayofweek;    /* 0-6, 0=Sunday */
    };

struct _dostime_t {
    unsigned char hour; /* 0-23 */
    unsigned char minute;   /* 0-59 */
    unsigned char second;   /* 0-59 */
    unsigned char hsecond;  /* 0-99 */
    };

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define dosdate_t _dosdate_t
#define dostime_t _dostime_t
#endif 

#pragma pack()
#define _DATETIME_T_DEFINED
#endif 


/* _dos_getdiskfree structure */

#ifndef _DISKFREE_T_DEFINED

struct _diskfree_t {
    unsigned total_clusters;
    unsigned avail_clusters;
    unsigned sectors_per_cluster;
    unsigned bytes_per_sector;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define diskfree_t _diskfree_t
#endif 

#define _DISKFREE_T_DEFINED
#endif 


/* manifest constants for _hardresume result parameter */

#define _HARDERR_IGNORE     0   /* Ignore the error */
#define _HARDERR_RETRY      1   /* Retry the operation */
#define _HARDERR_ABORT      2   /* Abort program issuing Interrupt 23h */
#define _HARDERR_FAIL       3   /* Fail the system call in progress */
                    /* _HARDERR_FAIL is not supported on DOS 2.x */

/* File attribute constants */

#define _A_NORMAL   0x00    /* Normal file - No read/write restrictions */
#define _A_RDONLY   0x01    /* Read only file */
#define _A_HIDDEN   0x02    /* Hidden file */
#define _A_SYSTEM   0x04    /* System file */
#define _A_VOLID    0x08    /* Volume ID file */
#define _A_SUBDIR   0x10    /* Subdirectory */
#define _A_ARCH     0x20    /* Archive file */

/* macros to break C "far" pointers into their segment and offset components
 */

#define _FP_SEG(fp) (*((unsigned __far *)&(fp)+1))
#define _FP_OFF(fp) (*((unsigned __far *)&(fp)))

/* macro to construct a far pointer from segment and offset values
 */

#define _MK_FP(seg, offset) (void __far *)(((unsigned long)seg << 16) \
    + (unsigned long)(unsigned)offset)

/* external variable declarations */

extern unsigned int __near __cdecl _osversion;


/* function prototypes */

#ifndef _MT
int __cdecl _bdos(int, unsigned int, unsigned int);
#ifndef _WINDOWS
void __cdecl _chain_intr(void (__cdecl __interrupt __far *)());
#endif 
void __cdecl _disable(void);
#ifndef _WINDOWS
unsigned __cdecl _dos_allocmem(unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_close(int);
unsigned __cdecl _dos_commit(int);
unsigned __cdecl _dos_creat(const char *, unsigned, int *);
unsigned __cdecl _dos_creatnew(const char *, unsigned, int *);
unsigned __cdecl _dos_findfirst(const char *, unsigned, struct _find_t *);
unsigned __cdecl _dos_findnext(struct _find_t *);
#ifndef _WINDOWS
unsigned __cdecl _dos_freemem(unsigned);
#endif 
void __cdecl _dos_getdate(struct _dosdate_t *);
void __cdecl _dos_getdrive(unsigned *);
unsigned __cdecl _dos_getdiskfree(unsigned, struct _diskfree_t *);
unsigned __cdecl _dos_getfileattr(const char *, unsigned *);
unsigned __cdecl _dos_getftime(int, unsigned *, unsigned *);
void __cdecl _dos_gettime(struct _dostime_t *);
void (__cdecl __interrupt __far * __cdecl _dos_getvect(unsigned))();
#ifndef _WINDOWS
void __cdecl _dos_keep(unsigned, unsigned);
#endif 
unsigned __cdecl _dos_lock(int, int, unsigned long, unsigned long);
unsigned __cdecl _dos_open(const char *, unsigned, int *);
unsigned __cdecl _dos_read(int, void __far *, unsigned, unsigned *);
unsigned long __cdecl _dos_seek(int, unsigned long, int);
#ifndef _WINDOWS
unsigned __cdecl _dos_setblock(unsigned, unsigned, unsigned *);
#endif 
unsigned __cdecl _dos_setdate(struct _dosdate_t *);
void __cdecl _dos_setdrive(unsigned, unsigned *);
unsigned __cdecl _dos_setfileattr(const char *, unsigned);
unsigned __cdecl _dos_setftime(int, unsigned, unsigned);
unsigned __cdecl _dos_settime(struct _dostime_t *);
#ifndef _WINDOWS
void __cdecl _dos_setvect(unsigned, void (__cdecl __interrupt __far *)());
#endif 
unsigned __cdecl _dos_write(int, const void __far *, unsigned, unsigned *);
int __cdecl _dosexterr(struct _DOSERROR *);
void __cdecl _enable(void);
#ifndef _WINDOWS
void __cdecl _harderr(void (__far __cdecl *)(unsigned, unsigned,
    unsigned __far *));
void __cdecl _hardresume(int);
void __cdecl _hardretn(int);
#endif 
int __cdecl _intdos(union _REGS *, union _REGS *);
int __cdecl _intdosx(union _REGS *, union _REGS *, struct _SREGS *);
int __cdecl _int86(int, union _REGS *, union _REGS *);
int __cdecl _int86x(int, union _REGS *, union _REGS *, struct _SREGS *);
#endif 

void __cdecl _segread(struct _SREGS *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define FP_SEG     _FP_SEG
#define FP_OFF     _FP_OFF
#define MK_FP      _MK_FP

#ifndef _MT
int __cdecl bdos(int, unsigned int, unsigned int);
int __cdecl intdos(union REGS *, union REGS *);
int __cdecl intdosx(union REGS *, union REGS *, struct SREGS *);
int __cdecl int86(int, union REGS *, union REGS *);
int __cdecl int86x(int, union REGS *, union REGS *, struct SREGS *);
#ifndef __cplusplus
int __cdecl dosexterr(struct DOSERROR *);
#endif 
#endif 
void __cdecl segread(struct SREGS *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_DOS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\float.h ===
/***
*float.h - constants for floating point values
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains defines for a number of implementation dependent
*   values which are commonly used by sophisticated numerical (floating
*   point) programs.
*   [ANSI]
*
****/

#ifndef _INC_FLOAT

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#define DBL_DIG     15          /* # of decimal digits of precision */
#define DBL_EPSILON 2.2204460492503131e-016 /* smallest such that 1.0+DBL_EPSILON != 1.0 */
#define DBL_MANT_DIG    53          /* # of bits in mantissa */
#define DBL_MAX     1.7976931348623158e+308 /* max value */
#define DBL_MAX_10_EXP  308         /* max decimal exponent */
#define DBL_MAX_EXP 1024            /* max binary exponent */
#define DBL_MIN     2.2250738585072014e-308 /* min positive value */
#define DBL_MIN_10_EXP  (-307)          /* min decimal exponent */
#define DBL_MIN_EXP (-1021)         /* min binary exponent */
#define _DBL_RADIX  2           /* exponent radix */
#define _DBL_ROUNDS 1           /* addition rounding: near */

#define FLT_DIG     6           /* # of decimal digits of precision */
#define FLT_EPSILON 1.192092896e-07F    /* smallest such that 1.0+FLT_EPSILON != 1.0 */
#define FLT_GUARD   0
#define FLT_MANT_DIG    24          /* # of bits in mantissa */
#define FLT_MAX     3.402823466e+38F    /* max value */
#define FLT_MAX_10_EXP  38          /* max decimal exponent */
#define FLT_MAX_EXP 128         /* max binary exponent */
#define FLT_MIN     1.175494351e-38F    /* min positive value */
#define FLT_MIN_10_EXP  (-37)           /* min decimal exponent */
#define FLT_MIN_EXP (-125)          /* min binary exponent */
#define FLT_NORMALIZE   0
#define FLT_RADIX   2           /* exponent radix */
#define FLT_ROUNDS  1           /* addition rounding: near */

#define LDBL_DIG    18          /* # of decimal digits of precision */
#define LDBL_EPSILON    1.084202172485504434e-019L /* smallest such that 1.0+LDBL_EPSILON != 1.0 */
#define LDBL_MANT_DIG   64          /* # of bits in mantissa */
#define LDBL_MAX    1.189731495357231765e+4932L /* max value */
#define LDBL_MAX_10_EXP 4932            /* max decimal exponent */
#define LDBL_MAX_EXP    16384           /* max binary exponent */
#define LDBL_MIN    3.3621031431120935063e-4932L /* min positive value */
#define LDBL_MIN_10_EXP (-4931)         /* min decimal exponent */
#define LDBL_MIN_EXP    (-16381)        /* min binary exponent */
#define _LDBL_RADIX 2           /* exponent radix */
#define _LDBL_ROUNDS    1           /* addition rounding: near */


/*
 *  8087/80287 math control information
 */


/* User Control Word Mask and bit definitions.
 * These definitions match the 8087/80287
 */

#define _MCW_EM     0x003f      /* interrupt Exception Masks */
#define _EM_INVALID 0x0001      /*   invalid */
#define _EM_DENORMAL    0x0002      /*   denormal */
#define _EM_ZERODIVIDE  0x0004      /*   zero divide */
#define _EM_OVERFLOW    0x0008      /*   overflow */
#define _EM_UNDERFLOW   0x0010      /*   underflow */
#define _EM_INEXACT 0x0020      /*   inexact (precision) */

#define _MCW_IC     0x1000      /* Infinity Control */
#define _IC_AFFINE  0x1000      /*   affine */
#define _IC_PROJECTIVE  0x0000      /*   projective */

#define _MCW_RC     0x0c00      /* Rounding Control */
#define _RC_CHOP    0x0c00      /*   chop */
#define _RC_UP      0x0800      /*   up */
#define _RC_DOWN    0x0400      /*   down */
#define _RC_NEAR    0x0000      /*   near */

#define _MCW_PC     0x0300      /* Precision Control */
#define _PC_24      0x0000      /*    24 bits */
#define _PC_53      0x0200      /*    53 bits */
#define _PC_64      0x0300      /*    64 bits */


/* initial Control Word value */

#define _CW_DEFAULT ( _IC_AFFINE + _RC_NEAR + _PC_64 + _EM_DENORMAL + _EM_UNDERFLOW + _EM_INEXACT )


/* user Status Word bit definitions */

#define _SW_INVALID 0x0001  /* invalid */
#define _SW_DENORMAL    0x0002  /* denormal */
#define _SW_ZERODIVIDE  0x0004  /* zero divide */
#define _SW_OVERFLOW    0x0008  /* overflow */
#define _SW_UNDERFLOW   0x0010  /* underflow */
#define _SW_INEXACT 0x0020  /* inexact (precision) */


/* invalid subconditions (_SW_INVALID also set) */

#define _SW_UNEMULATED      0x0040  /* unemulated instruction */
#define _SW_SQRTNEG     0x0080  /* square root of a neg number */
#define _SW_STACKOVERFLOW   0x0200  /* FP stack overflow */
#define _SW_STACKUNDERFLOW  0x0400  /* FP stack underflow */


/*  Floating point error signals and return codes */

#define _FPE_INVALID        0x81
#define _FPE_DENORMAL       0x82
#define _FPE_ZERODIVIDE     0x83
#define _FPE_OVERFLOW       0x84
#define _FPE_UNDERFLOW      0x85
#define _FPE_INEXACT        0x86

#define _FPE_UNEMULATED     0x87
#define _FPE_SQRTNEG        0x88
#define _FPE_STACKOVERFLOW  0x8a
#define _FPE_STACKUNDERFLOW 0x8b

#define _FPE_EXPLICITGEN    0x8c    /* raise( SIGFPE ); */


/* function prototypes */

unsigned int __cdecl _clear87(void);
unsigned int __cdecl _control87(unsigned int, unsigned int);
void __cdecl _fpreset(void);
unsigned int __cdecl _status87(void);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DBL_RADIX       _DBL_RADIX
#define DBL_ROUNDS      _DBL_ROUNDS

#define LDBL_RADIX      _LDBL_RADIX
#define LDBL_ROUNDS     _LDBL_ROUNDS

#define MCW_EM          _MCW_EM
#define EM_INVALID      _EM_INVALID
#define EM_DENORMAL     _EM_DENORMAL
#define EM_ZERODIVIDE       _EM_ZERODIVIDE
#define EM_OVERFLOW     _EM_OVERFLOW
#define EM_UNDERFLOW        _EM_UNDERFLOW
#define EM_INEXACT      _EM_INEXACT

#define MCW_IC          _MCW_IC
#define IC_AFFINE       _IC_AFFINE
#define IC_PROJECTIVE       _IC_PROJECTIVE

#define MCW_RC          _MCW_RC
#define RC_CHOP         _RC_CHOP
#define RC_UP           _RC_UP
#define RC_DOWN         _RC_DOWN
#define RC_NEAR         _RC_NEAR

#define MCW_PC          _MCW_PC
#define PC_24           _PC_24
#define PC_53           _PC_53
#define PC_64           _PC_64

#define CW_DEFAULT      _CW_DEFAULT

#define SW_INVALID      _SW_INVALID
#define SW_DENORMAL     _SW_DENORMAL
#define SW_ZERODIVIDE       _SW_ZERODIVIDE
#define SW_OVERFLOW     _SW_OVERFLOW
#define SW_UNDERFLOW        _SW_UNDERFLOW
#define SW_INEXACT      _SW_INEXACT

#define SW_UNEMULATED       _SW_UNEMULATED
#define SW_SQRTNEG      _SW_SQRTNEG
#define SW_STACKOVERFLOW    _SW_STACKOVERFLOW
#define SW_STACKUNDERFLOW   _SW_STACKUNDERFLOW

#define FPE_INVALID     _FPE_INVALID
#define FPE_DENORMAL        _FPE_DENORMAL
#define FPE_ZERODIVIDE      _FPE_ZERODIVIDE
#define FPE_OVERFLOW        _FPE_OVERFLOW
#define FPE_UNDERFLOW       _FPE_UNDERFLOW
#define FPE_INEXACT     _FPE_INEXACT

#define FPE_UNEMULATED      _FPE_UNEMULATED
#define FPE_SQRTNEG     _FPE_SQRTNEG
#define FPE_STACKOVERFLOW   _FPE_STACKOVERFLOW
#define FPE_STACKUNDERFLOW  _FPE_STACKUNDERFLOW

#define FPE_EXPLICITGEN     _FPE_EXPLICITGEN

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_FLOAT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\fcntl.h ===
/***
*fcntl.h - file control options used by open()
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines constants for the file control options used
*   by the open() function.
*   [System V]
*
****/

#ifndef _INC_FCNTL

#define _O_RDONLY   0x0000  /* open for reading only */
#define _O_WRONLY   0x0001  /* open for writing only */
#define _O_RDWR     0x0002  /* open for reading and writing */
#define _O_APPEND   0x0008  /* writes done at eof */

#define _O_CREAT    0x0100  /* create and open file */
#define _O_TRUNC    0x0200  /* open and truncate */
#define _O_EXCL     0x0400  /* open only if file doesn't already exist */

/* _O_TEXT files have <cr><lf> sequences translated to <lf> on read()'s,
** and <lf> sequences translated to <cr><lf> on write()'s
*/

#define _O_TEXT     0x4000  /* file mode is text (translated) */
#define _O_BINARY   0x8000  /* file mode is binary (untranslated) */

/* macro to translate the C 2.0 name used to force binary mode for files */

#define _O_RAW  _O_BINARY

/* Open handle inherit bit */

#define _O_NOINHERIT    0x0080  /* child process doesn't inherit file */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define O_RDONLY    _O_RDONLY
#define O_WRONLY    _O_WRONLY
#define O_RDWR      _O_RDWR
#define O_APPEND    _O_APPEND
#define O_CREAT     _O_CREAT
#define O_TRUNC     _O_TRUNC
#define O_EXCL      _O_EXCL
#define O_TEXT      _O_TEXT
#define O_BINARY    _O_BINARY
#define O_NOINHERIT _O_NOINHERIT
#endif 

#define _INC_FCNTL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\dvobj.h ===
/*****************************************************************************\
*                                                                             *
* dvobj.h -		Data/View object definitions								  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _DVOBJ_H_ )
#define _DVOBJ_H_

/****** DV value types ******************************************************/

//      forward type declarations
#if defined(__cplusplus)
interface IStorage;
interface IStream;
interface IAdviseSink;
interface IMoniker;
#else 
typedef interface IStorage IStorage;
typedef interface IStream IStream;
typedef interface IAdviseSink IAdviseSink;
typedef interface IMoniker IMoniker;
#endif

typedef            IStorage FAR* LPSTORAGE;
typedef             IStream FAR* LPSTREAM;
typedef         IAdviseSink FAR* LPADVISESINK;
typedef             IMoniker FAR* LPMONIKER;


#if !defined(_MAC)
typedef WORD CLIPFORMAT;
#else
typedef unsigned long CLIPFORMAT;            // ResType
#endif
typedef  CLIPFORMAT FAR* LPCLIPFORMAT;


// Data/View aspect; specifies the desired aspect of the object when 
// drawing or getting data.
typedef enum tagDVASPECT
{
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;


// Data/View target device; determines the device for drawing or gettting data
typedef struct FARSTRUCT tagDVTARGETDEVICE
{
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    BYTE tdData[1];
} DVTARGETDEVICE;


// Format, etc.; completely specifices the kind of data desired, including tymed
typedef struct FARSTRUCT tagFORMATETC
{
    CLIPFORMAT          cfFormat;
    DVTARGETDEVICE FAR* ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC, FAR* LPFORMATETC;


// TYpes of storage MEDiums; determines how data is stored or passed around
typedef enum tagTYMED
{
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_NULL = 0
} TYMED;


// DATA format DIRection
typedef enum tagDATADIR
{
    DATADIR_GET = 1,
    DATADIR_SET = 2,
} DATADIR;


// SToraGe MEDIUM; a block of data on a particular medium 
typedef struct FARSTRUCT tagSTGMEDIUM
{
    DWORD   tymed;
    union
    {
        HANDLE  hGlobal;
        LPSTR   lpszFileName;
        IStream FAR* pstm;
        IStorage FAR* pstg;
    }
#ifdef NONAMELESSUNION
    u       // add a tag when name less unions not supported
#endif
    ;
    IUnknown FAR* pUnkForRelease;
} STGMEDIUM, FAR* LPSTGMEDIUM;


// Advise Flags
typedef enum tagADVF
{
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
} ADVF;


// Stats for data; used by several enumerations and by at least one 
// implementation of IDataAdviseHolder; if a field is not used, it
// will be NULL.
typedef struct FARSTRUCT tagSTATDATA
{                                   // field used by:
    FORMATETC formatetc;            // EnumAdvise, EnumData (cache), EnumFormats
    DWORD advf;                     // EnumAdvise, EnumData (cache)
    IAdviseSink FAR* pAdvSink;      // EnumAdvise
    DWORD dwConnection;             // EnumAdvise
} STATDATA;
    
typedef  STATDATA FAR* LPSTATDATA;



/****** DV Interfaces ***************************************************/


#undef  INTERFACE
#define INTERFACE   IEnumFORMATETC

DECLARE_INTERFACE_(IEnumFORMATETC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumFORMATETC FAR* FAR* ppenum) PURE;
};
typedef        IEnumFORMATETC FAR* LPENUMFORMATETC;


#undef  INTERFACE
#define INTERFACE   IEnumSTATDATA

DECLARE_INTERFACE_(IEnumSTATDATA, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IEnumSTATDATA methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATDATA FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATDATA FAR* FAR* ppenum) PURE;
};
typedef        IEnumSTATDATA FAR* LPENUMSTATDATA;



#undef  INTERFACE
#define INTERFACE   IDataObject

#define DATA_E_FORMATETC        DV_E_FORMATETC
#define DATA_S_SAMEFORMATETC    (DATA_S_FIRST + 0)

DECLARE_INTERFACE_(IDataObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(GetData) (THIS_ LPFORMATETC pformatetcIn,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(GetDataHere) (THIS_ LPFORMATETC pformatetc,
                            LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(QueryGetData) (THIS_ LPFORMATETC pformatetc ) PURE;
    STDMETHOD(GetCanonicalFormatEtc) (THIS_ LPFORMATETC pformatetc,
                            LPFORMATETC pformatetcOut) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
    STDMETHOD(EnumFormatEtc) (THIS_ DWORD dwDirection,
                            LPENUMFORMATETC FAR* ppenumFormatEtc) PURE;

    STDMETHOD(DAdvise) (THIS_ FORMATETC FAR* pFormatetc, DWORD advf, 
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(DUnadvise) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumDAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
};                 
typedef      IDataObject FAR* LPDATAOBJECT;



#undef  INTERFACE
#define INTERFACE   IViewObject

#define VIEW_E_DRAW             (VIEW_E_FIRST)
#define E_DRAW                  VIEW_E_DRAW

#define VIEW_S_ALREADY_FROZEN   (VIEW_S_FIRST)

DECLARE_INTERFACE_(IViewObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    LPCRECTL lprcBounds, 
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
};
typedef      IViewObject FAR* LPVIEWOBJECT;


#undef  INTERFACE
#define INTERFACE   IViewObject2

DECLARE_INTERFACE_(IViewObject2, IViewObject)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    LPCRECTL lprcBounds, 
                    LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
					
    // *** IViewObject2 methods ***
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    DVTARGETDEVICE FAR * ptd, LPSIZEL lpsizel) PURE;
					
};
typedef      IViewObject2 FAR* LPVIEWOBJECT2;


#undef  INTERFACE
#define INTERFACE   IAdviseSink

DECLARE_INTERFACE_(IAdviseSink, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;
};
typedef      IAdviseSink FAR* LPADVISESINK;



#undef  INTERFACE
#define INTERFACE   IAdviseSink2

DECLARE_INTERFACE_(IAdviseSink2, IAdviseSink)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc, 
                            STGMEDIUM FAR* pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;

    // *** IAdviseSink2 methods ***
    STDMETHOD_(void,OnLinkSrcChange)(THIS_ LPMONIKER pmk) PURE;
};
typedef      IAdviseSink2 FAR* LPADVISESINK2;



#undef  INTERFACE
#define INTERFACE   IDataAdviseHolder

DECLARE_INTERFACE_(IDataAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDataAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPDATAOBJECT pDataObject, FORMATETC FAR* pFetc, 
            DWORD advf, LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnDataChange)(THIS_ LPDATAOBJECT pDataObject, DWORD dwReserved, DWORD advf) PURE;
};
typedef      IDataAdviseHolder FAR* LPDATAADVISEHOLDER;



#undef  INTERFACE
#define INTERFACE   IOleCache

#define CACHE_E_NOCACHE_UPDATED         (CACHE_E_FIRST)

#define CACHE_S_FORMATETC_NOTSUPPORTED  (CACHE_S_FIRST)
#define CACHE_S_SAMECACHE               (CACHE_S_FIRST+1)
#define CACHE_S_SOMECACHES_NOTUPDATED   (CACHE_S_FIRST+2)


DECLARE_INTERFACE_(IOleCache, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;
};
typedef         IOleCache FAR* LPOLECACHE;



// Cache update Flags

#define	UPDFCACHE_NODATACACHE			0x00000001
#define UPDFCACHE_ONSAVECACHE			0x00000002
#define	UPDFCACHE_ONSTOPCACHE			0x00000004
#define	UPDFCACHE_NORMALCACHE			0x00000008
#define	UPDFCACHE_IFBLANK				0x00000010
#define UPDFCACHE_ONLYIFBLANK			0x80000000

#define UPDFCACHE_IFBLANKORONSAVECACHE	(UPDFCACHE_IFBLANK | UPDFCACHE_ONSAVECACHE )
#define UPDFCACHE_ALL					(~UPDFCACHE_ONLYIFBLANK)
#define UPDFCACHE_ALLBUTNODATACACHE		(UPDFCACHE_ALL & ~UPDFCACHE_NODATACACHE)


// IOleCache2::DiscardCache options
typedef enum tagDISCARDCACHE
{
	DISCARDCACHE_SAVEIFDIRTY =	0,	// Save all dirty cache before discarding
	DISCARDCACHE_NOSAVE		 =	1	// Don't save dirty caches before 
									// discarding
} DISCARDCACHE;


#undef  INTERFACE
#define INTERFACE   IOleCache2

DECLARE_INTERFACE_(IOleCache2, IOleCache)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_ LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_ LPFORMATETC pformatetc, STGMEDIUM FAR * pmedium,
                            BOOL fRelease) PURE;

    // *** IOleCache2 methods ***							
    STDMETHOD(UpdateCache) (THIS_ LPDATAOBJECT pDataObject, DWORD grfUpdf, 
							LPVOID pReserved) PURE;
    STDMETHOD(DiscardCache) (THIS_ DWORD dwDiscardOptions) PURE;
						
};
typedef      IOleCache2 FAR* LPOLECACHE2;


#undef  INTERFACE
#define INTERFACE   IOleCacheControl

DECLARE_INTERFACE_(IOleCacheControl, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(OnRun) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(OnStop) (THIS) PURE;
};                 
typedef      IOleCacheControl FAR* LPOLECACHECONTROL;



/****** DV APIs ***********************************************************/


STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

STDAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
					REFIID iid, LPVOID FAR* ppv);
					
#endif // _DVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\graph.h ===
/***
*graph.h - declare constants, functions, and macros for graphics library
*
*   Copyright (c) 1987 - 1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file declares the graphics library functions and the
*   structures and manifest constants that are used with them.
*
***************************************************************************/

#ifndef	_WINDOWS
/* Force graphics.lib to be linked in if graph.h used */
#pragma comment(lib,"graphics.lib")
#endif

#ifdef __cplusplus
extern "C" {			/* allow use with C++ */
#endif

#if (_MSC_VER <= 600)
#define	__cdecl	_cdecl
#define	__far	_far
#define	__huge	_huge
#endif

/* force word packing to avoid possible -Zp override */
#pragma pack(2)


/* user-visible declarations for Quick-C Graphics Library */

#ifndef _VIDEOCONFIG_DEFINED
/* structure for _getvideoconfig() as visible to user */
struct _videoconfig {
	short numxpixels;	/* number of pixels on X axis */
	short numypixels;	/* number of pixels on Y axis */
	short numtextcols;	/* number of text columns available */
	short numtextrows;	/* number of text rows available */
	short numcolors;	/* number of actual colors */
	short bitsperpixel;	/* number of bits per pixel */
	short numvideopages;	/* number of available video pages */
	short mode;		/* current video mode */
	short adapter;		/* active display adapter */
	short monitor;		/* active display monitor */
	short memory;		/* adapter video memory in K bytes */
};
#define _VIDEOCONFIG_DEFINED
#endif

#ifndef _XYCOORD_DEFINED
/* return value of _setvieworg(), etc. */
struct _xycoord {
	short xcoord;
	short ycoord;
};
#define _XYCOORD_DEFINED
#endif

/* structure for text position */
#ifndef _RCCOORD_DEFINED
struct _rccoord {
	short row;
	short col;
};
#define _RCCOORD_DEFINED
#endif

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define videoconfig	_videoconfig
#define xycoord		_xycoord
#define rccoord		_rccoord
#endif


/* ERROR HANDLING */
short __far __cdecl _grstatus(void);

/* Error Status Information returned by _grstatus() */

/* successful */
#define	_GROK                        0

/* errors */
#define _GRERROR                    (-1)
#define	_GRMODENOTSUPPORTED	    (-2)
#define	_GRNOTINPROPERMODE          (-3)
#define _GRINVALIDPARAMETER         (-4)
#define	_GRFONTFILENOTFOUND         (-5)
#define	_GRINVALIDFONTFILE          (-6)
#define _GRCORRUPTEDFONTFILE        (-7)
#define _GRINSUFFICIENTMEMORY       (-8)
#define _GRINVALIDIMAGEBUFFER       (-9)

/* warnings */
#define _GRNOOUTPUT                  1
#define _GRCLIPPED                   2
#define _GRPARAMETERALTERED          3
#define _GRTEXTNOTSUPPORTED          4


/* SETUP AND CONFIGURATION */

short __far __cdecl _setvideomode(short);
short __far __cdecl _setvideomoderows(short,short); /* return rows; 0 if error */

/* arguments to _setvideomode() */
#define _MAXRESMODE	(-3)	/* graphics mode with highest resolution */
#define _MAXCOLORMODE	(-2)	/* graphics mode with most colors */
#define _DEFAULTMODE	(-1)	/* restore screen to original mode */
#define _TEXTBW40	0	/* 40-column text, 16 grey */
#define _TEXTC40	1	/* 40-column text, 16/8 color */
#define _TEXTBW80	2	/* 80-column text, 16 grey */
#define _TEXTC80	3	/* 80-column text, 16/8 color */
#define _MRES4COLOR	4	/* 320 x 200, 4 color */
#define _MRESNOCOLOR	5	/* 320 x 200, 4 grey */
#define _HRESBW		6	/* 640 x 200, BW */
#define _TEXTMONO	7	/* 80-column text, BW */
#define _HERCMONO	8	/* 720 x 348, BW for HGC */
#define _MRES16COLOR	13	/* 320 x 200, 16 color */
#define _HRES16COLOR	14	/* 640 x 200, 16 color */
#define _ERESNOCOLOR	15	/* 640 x 350, BW */
#define _ERESCOLOR	16	/* 640 x 350, 4 or 16 color */
#define _VRES2COLOR	17	/* 640 x 480, BW */
#define _VRES16COLOR	18	/* 640 x 480, 16 color */
#define _MRES256COLOR	19	/* 320 x 200, 256 color */
#define _ORESCOLOR	64	/* 640 x 400, 1 of 16 colors (Olivetti only) */

/* the following 8 modes require VESA SuperVGA BIOS extensions */
#define	_ORES256COLOR	0x0100	/* 640 x 400, 256 color */
#define	_VRES256COLOR	0x0101	/* 640 x 480, 256 color */

/* WARNING: DO NOT attempt to set the following modes without ensuring that
   your monitor can safely handle that resolution.  Otherwise, you may risk
   damaging your display monitor!  Consult your owner's manual for details.
   Note: _MAXRESMODE and _MAXCOLORMODE never select SRES, XRES, or ZRES modes */

/* requires NEC MultiSync 3D or equivalent, or better */
#define	_SRES16COLOR	0x0102	/* 800 x 600, 16 color */
#define	_SRES256COLOR	0x0103	/* 800 x 600, 256 color */

/* requires NEC MultiSync 4D or equivalent, or better */
#define	_XRES16COLOR	0x0104	/* 1024 x 768, 16 color */
#define	_XRES256COLOR	0x0105	/* 1024 x 768, 256 color */

/* requires NEC MultiSync 5D or equivalent, or better */
#define	_ZRES16COLOR	0x0106	/* 1280 x 1024, 16 color */
#define	_ZRES256COLOR	0x0107	/* 1280 x 1024, 256 color */


short __far __cdecl _setactivepage(short);
short __far __cdecl _setvisualpage(short);
short __far __cdecl _getactivepage(void);
short __far __cdecl _getvisualpage(void);

/* _videoconfig adapter values */
/* these manifest constants can be used to determine the type of the active  */
/* adapter, using either simple comparisons or the bitwise-AND operator (&)  */
#define _MDPA		0x0001	/* Monochrome Display Adapter	      (MDPA) */
#define _CGA		0x0002	/* Color Graphics Adapter	      (CGA)  */
#define _EGA		0x0004	/* Enhanced Graphics Adapter	      (EGA)  */
#define _VGA		0x0008	/* Video Graphics Array		      (VGA)  */
#define _MCGA		0x0010	/* MultiColor Graphics Array	      (MCGA) */
#define _HGC		0x0020	/* Hercules Graphics Card	      (HGC)  */
#define _OCGA		0x0042	/* Olivetti Color Graphics Adapter    (OCGA) */
#define _OEGA		0x0044	/* Olivetti Enhanced Graphics Adapter (OEGA) */
#define _OVGA		0x0048	/* Olivetti Video Graphics Array      (OVGA) */
#define _SVGA		0x0088	/* Super VGA with VESA BIOS support   (SVGA) */

/* _videoconfig monitor values */
/* these manifest constants can be used to determine the type of monitor in */
/* use, using either simple comparisons or the bitwise-AND operator (&) */
#define _MONO		0x0001	/* Monochrome */
#define _COLOR		0x0002	/* Color (or Enhanced emulating color) */
#define _ENHCOLOR	0x0004	/* Enhanced Color */
#define _ANALOGMONO	0x0008	/* Analog Monochrome only */
#define _ANALOGCOLOR	0x0010	/* Analog Color only */
#define _ANALOG		0x0018	/* Analog Monochrome and Color modes */

struct _videoconfig __far * __far __cdecl _getvideoconfig(struct _videoconfig __far *);


/* COORDINATE SYSTEMS */

struct _xycoord __far __cdecl _setvieworg(short, short);
#define _setlogorg _setvieworg		/* obsolescent */

struct _xycoord __far __cdecl _getviewcoord(short, short);
#define _getlogcoord _getviewcoord	/* obsolescent */

struct _xycoord __far __cdecl _getphyscoord(short, short);

void __far __cdecl _setcliprgn(short, short, short, short);
void __far __cdecl _setviewport(short, short, short, short);


/* OUTPUT ROUTINES */

/* control parameters for _ellipse, _rectangle, _pie and _polygon */
#define _GBORDER	2	/* draw outline only */
#define _GFILLINTERIOR	3	/* fill using current fill mask */

/* parameters for _clearscreen */
#define _GCLEARSCREEN	0
#define _GVIEWPORT	1
#define _GWINDOW	2

void __far __cdecl _clearscreen(short);

struct _xycoord __far __cdecl _moveto(short, short);
struct _xycoord __far __cdecl _getcurrentposition(void);

short __far __cdecl _lineto(short, short);
short __far __cdecl _rectangle(short, short, short, short, short);
short __far __cdecl _polygon(short, const struct _xycoord __far *, short);
short __far __cdecl _arc(short, short, short, short, short, short, short, short);
short __far __cdecl _ellipse(short, short, short, short, short);
short __far __cdecl _pie(short, short, short, short, short, short, short, short, short);

short __far __cdecl _getarcinfo(struct _xycoord __far *, struct _xycoord __far *, struct _xycoord __far *);

short __far __cdecl _setpixel(short, short);
short __far __cdecl _getpixel(short, short);
short __far __cdecl _floodfill(short, short, short);


/* PEN COLOR, LINE STYLE, WRITE MODE, FILL PATTERN */

short __far __cdecl _setcolor(short);
short __far __cdecl _getcolor(void);

void __far __cdecl _setlinestyle(unsigned short);
unsigned short __far __cdecl _getlinestyle(void);

short __far __cdecl _setwritemode(short);
short __far __cdecl _getwritemode(void);

void __far __cdecl _setfillmask(const unsigned char __far *);
unsigned char __far * __far __cdecl _getfillmask(unsigned char __far *);


/* COLOR SELECTION */

long __far __cdecl _setbkcolor(long);
long __far __cdecl _getbkcolor(void);

long __far __cdecl _remappalette(short, long);
short __far __cdecl _remapallpalette(const long __far *);
short __far __cdecl _selectpalette(short);


/* TEXT */
/* parameters for _displaycursor */
#define _GCURSOROFF	0
#define _GCURSORON	1

/* parameters for _wrapon */
#define _GWRAPOFF	0
#define _GWRAPON	1


/* direction parameters for _scrolltextwindow */
#define _GSCROLLUP	1
#define _GSCROLLDOWN	(-1)

/* request maximum number of rows in _settextrows and _setvideomoderows */
#define _MAXTEXTROWS	(-1)

short __far __cdecl _settextrows(short); /* returns # rows set; 0 if error */
void __far __cdecl _settextwindow(short, short, short, short);
void __far __cdecl _gettextwindow(short __far *, short __far *, short __far *, short __far *);
void __far __cdecl _scrolltextwindow(short);
void __far __cdecl _outmem(const char __far *, short);
void __far __cdecl _outtext(const char __far *);
short __far __cdecl _inchar(void);
short __far __cdecl _wrapon(short);

short __far __cdecl _displaycursor(short);
short __far __cdecl _settextcursor(short);
short __far __cdecl _gettextcursor(void);

struct _rccoord __far __cdecl _settextposition(short, short);
struct _rccoord __far __cdecl _gettextposition(void);

short __far __cdecl _settextcolor(short);
short __far __cdecl _gettextcolor(void);


/* SCREEN IMAGES */

void __far __cdecl _getimage(short, short, short, short, char __huge *);
void __far __cdecl _putimage(short, short, char __huge *, short);
long __far __cdecl _imagesize(short, short, short, short);

/* "action verbs" for _putimage() and _setwritemode() */
#define _GPSET		3
#define _GPRESET	2
#define _GAND		1
#define _GOR		0
#define _GXOR		4


/* Color values are used with _setbkcolor in graphics modes and also by
   _remappalette and _remapallpalette.  Also known as palette colors.
   Not to be confused with color indices (aka. color attributes).  */

/* universal color values (all color modes): */
#define _BLACK		0x000000L
#define _BLUE		0x2a0000L
#define _GREEN		0x002a00L
#define _CYAN		0x2a2a00L
#define _RED		0x00002aL
#define _MAGENTA	0x2a002aL
#define _BROWN		0x00152aL
#define _WHITE		0x2a2a2aL
#define _GRAY		0x151515L
#define _LIGHTBLUE	0x3F1515L
#define _LIGHTGREEN	0x153f15L
#define _LIGHTCYAN	0x3f3f15L
#define _LIGHTRED	0x15153fL
#define _LIGHTMAGENTA	0x3f153fL
#define _YELLOW		0x153f3fL
#define _BRIGHTWHITE	0x3f3f3fL

/* the following is obsolescent and defined only for backward compatibility */
#define _LIGHTYELLOW	_YELLOW

/* mono mode F (_ERESNOCOLOR) color values: */
#define _MODEFOFF	0L
#define _MODEFOFFTOON	1L
#define _MODEFOFFTOHI	2L
#define _MODEFONTOOFF	3L
#define _MODEFON	4L
#define _MODEFONTOHI	5L
#define _MODEFHITOOFF	6L
#define _MODEFHITOON	7L
#define _MODEFHI	8L

/* mono mode 7 (_TEXTMONO) color values: */
#define _MODE7OFF	0L
#define _MODE7ON	1L
#define _MODE7HI	2L


/* Warning:  these '_xy' entrypoints are undocumented.
   They may or may not be supported in future versions. */
struct _xycoord __far __cdecl _moveto_xy(struct _xycoord);
short __far __cdecl _lineto_xy(struct _xycoord);
short __far __cdecl _rectangle_xy(short,struct _xycoord,struct _xycoord);
short __far __cdecl _arc_xy(struct _xycoord, struct _xycoord, struct _xycoord, struct _xycoord);
short __far __cdecl _ellipse_xy(short, struct _xycoord, struct _xycoord);
short __far __cdecl _pie_xy(short, struct _xycoord, struct _xycoord, struct _xycoord, struct _xycoord);
short __far __cdecl _getpixel_xy(struct _xycoord);
short __far __cdecl _setpixel_xy(struct _xycoord);
short __far __cdecl _floodfill_xy(struct _xycoord, short);
void __far __cdecl _getimage_xy(struct _xycoord,struct _xycoord, char __huge *);
long __far __cdecl _imagesize_xy(struct _xycoord,struct _xycoord);
void __far __cdecl _putimage_xy(struct _xycoord, char __huge *, short);


/* WINDOW COORDINATE SYSTEM */

#ifndef _WXYCOORD_DEFINED
/* structure for window coordinate pair */
struct _wxycoord {
	double wx;	/* window x coordinate */
	double wy;	/* window y coordinate */
	};
#define _WXYCOORD_DEFINED
#endif


/* define real coordinate window - returns non-zero if successful */
short __far __cdecl _setwindow(short,double,double,double,double);

/* convert from view to window coordinates */
struct _wxycoord __far __cdecl _getwindowcoord(short,short);
struct _wxycoord __far __cdecl _getwindowcoord_xy(struct _xycoord);

/* convert from window to view coordinates */
struct _xycoord __far __cdecl _getviewcoord_w(double,double);
struct _xycoord __far __cdecl _getviewcoord_wxy(const struct _wxycoord __far *);

/*	return the window coordinates of the current graphics output
	position as an _wxycoord structure. no error return. */
struct _wxycoord __far __cdecl _getcurrentposition_w(void);


/* window coordinate entry points for graphics output routines */

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _arc_w(double, double, double, double, double, double, double, double);
short __far __cdecl _arc_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _ellipse_w(short, double, double, double, double);
short __far __cdecl _ellipse_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _floodfill_w(double, double, short);

/*	returns pixel value at given point; -1 if unsuccessful. */
short __far __cdecl _getpixel_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _lineto_w(double, double);

/*	returns the view coordinates of the previous output
	position as a _wxycoord structure. no error return */
struct _wxycoord __far __cdecl _moveto_w(double, double);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _pie_w(short, double, double, double, double, double, double, double, double);
short __far __cdecl _pie_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _rectangle_w(short, double, double, double, double);
short __far __cdecl _rectangle_wxy(short, const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	returns nonzero if successful; otherwise 0	*/
short __far __cdecl _polygon_w(short, const double __far *, short);
short __far __cdecl _polygon_wxy(short, const struct _wxycoord __far *, short);

/*	returns previous color; -1 if unsuccessful */
short __far __cdecl _setpixel_w(double, double);


/* window coordinate image routines */

/*	no return value */
void __far __cdecl _getimage_w(double, double, double, double, char __huge *);
void __far __cdecl _getimage_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *, char __huge *);

/*	returns the image's storage size in bytes */
long __far __cdecl _imagesize_w(double, double, double, double);
long __far __cdecl _imagesize_wxy(const struct _wxycoord __far *, const struct _wxycoord __far *);

/*	no return value */
void __far __cdecl _putimage_w(double, double ,char __huge * ,short);


/* FONTS */

#ifndef _FONTINFO_DEFINED
/* structure for _getfontinfo() */
struct _fontinfo {
	int	type;		/* b0 set = vector,clear = bit map	*/
	int	ascent;		/* pix dist from top to baseline	*/
	int	pixwidth;	/* character width in pixels, 0=prop	*/
	int	pixheight;	/* character height in pixels		*/
	int	avgwidth;	/* average character width in pixels	*/
	char	filename[81];	/* file name including path		*/
	char	facename[32];	/* font name				*/
};
#define _FONTINFO_DEFINED
#endif


/* font function prototypes */
short	__far __cdecl	_registerfonts( const char __far *);
void	__far __cdecl	_unregisterfonts( void );
short	__far __cdecl	_setfont( const char __far * );
short	__far __cdecl	_getfontinfo( struct _fontinfo __far * );
void	__far __cdecl	_outgtext( const char __far * );
short	__far __cdecl	_getgtextextent( const char __far * );
struct _xycoord __far __cdecl _setgtextvector( short, short );
struct _xycoord __far __cdecl _getgtextvector(void);


#ifdef _WINDOWS
/* QuickWin graphics extension prototypes */
int __far __cdecl _wgclose( int );
int __far __cdecl _wggetactive( void );
int __far __cdecl _wgopen( char __far * );
int __far __cdecl _wgsetactive( int );
#endif


/* restore default packing */
#pragma pack()

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -	Definitions for controlling GUID initialization				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This 
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#pragma error "initguid: must include compobj.h first."
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\iomanip.h ===
/***
*iomanip.h - definitions/declarations for iostream's parameterized manipulators
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the iostream classes' paramterized manipulators.
*   [AT&T C++]
*
****/

#ifndef _INC_IOMANIP
#define _INC_IOMANIP
#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

// CONSIDER: use macro to define these
// #define __MKMANIP(X) \#define X##(T) __##X##_ \#\# T
// __MKMANIP(SMANIP);
// __MKMANIP(SAPP);
// __MKMANIP(IMANIP);
// __MKMANIP(IAPP);
// __MKMANIP(OMANIP);
// __MKMANIP(OAPP);
// __MKMANIP(IOMANIP);
// __MKMANIP(IOAPP);

#define SMANIP(T) __SMANIP_##T
#define SAPP(T) __SAPP_##T
#define IMANIP(T) __IMANIP_##T
#define IAPP(T) __IAPP_##T
#define OMANIP(T) __OMANIP_##T
#define OAPP(T) __OAPP_##T
#define IOMANIP(T) __IOMANIP_##T
#define IOAPP(T) __IOAPP_##T

#define IOMANIPdeclare(T)  \
class SMANIP(T) { \
public: \
    SMANIP(T)(ios& (*f)(ios&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(istream& s, SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
    friend ostream& operator<<(ostream& s, SMANIP(T) & sm) { (*(sm._fp))(s,sm._tp); return s; } \
private:    \
    ios& (* _fp)(ios&,T); \
    T _tp; \
};  \
class SAPP(T) { \
public: \
    SAPP(T)( ios& (*f)(ios&,T)) { _fp = f; }    \
    SMANIP(T) operator()(T t) { return SMANIP(T)(_fp,t); }  \
private:    \
    ios& (* _fp)(ios&,T); \
};  \
class IMANIP(T) { \
public: \
    IMANIP(T)(istream& (*f)(istream&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(istream& s, IMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    istream& (* _fp)(istream&,T); \
    T _tp;  \
};  \
class IAPP(T) { \
public: \
    IAPP(T)( istream& (*f)(istream&,T)) { _fp = f; }    \
    IMANIP(T) operator()(T t) { return IMANIP(T)(_fp,t); }  \
private:    \
    istream& (* _fp)(istream&,T); \
};  \
class OMANIP(T) { \
public: \
    OMANIP(T)(ostream& (*f)(ostream&,T), T t) { _fp = f; _tp = t; } \
    friend ostream& operator<<(ostream& s, OMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    ostream& (* _fp)(ostream&,T); \
    T _tp; \
};  \
class OAPP(T) { \
public: \
    OAPP(T)(ostream& (*f)(ostream&,T)) { _fp = f; } \
    OMANIP(T) operator()(T t) { return OMANIP(T)(_fp,t); } \
private:    \
    ostream& (* _fp)(ostream&,T); \
};  \
\
class IOMANIP(T) { \
public: \
    IOMANIP(T)(iostream& (*f)(iostream&,T), T t) { _fp = f; _tp = t; } \
    friend istream& operator>>(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
    friend ostream& operator<<(iostream& s, IOMANIP(T) & sm) { (*sm._fp)(s,sm._tp); return s; } \
private:    \
    iostream& (* _fp)(iostream&,T); \
    T _tp; \
};  \
class IOAPP(T) {    \
public: \
    IOAPP(T)( iostream& (*f)(iostream&,T)) { _fp = f; } \
    IOMANIP(T) operator()(T t) { return IOMANIP(T)(_fp,t); }    \
private:    \
    iostream& (* _fp)(iostream&,T); \
}; \


IOMANIPdeclare(int)

IOMANIPdeclare(long)

inline ios& __resetiosflags(ios& s, long _flg) { s.setf(0,_flg); return s; }
inline ios& __setfill(ios& s, int _fc) { s.fill((char)_fc); return s; }
inline ios& __setiosflags(ios& s, long _flg) { s.setf(_flg); return s; }
inline ios& __setprecision(ios& s, int _pre) { s.precision(_pre); return s; }
inline ios& __setw(ios& s, int _wid) { s.width(_wid); return s; }

inline SMANIP(long) resetiosflags(long _l) { return SMANIP(long)(__resetiosflags, _l); }
inline SMANIP(int)  setfill(int _m) {return SMANIP(int)(__setfill, _m); }
inline SMANIP(long) setiosflags(long _l) {return SMANIP(long)(__setiosflags, _l); }
inline SMANIP(int)  setprecision(int _p) {return SMANIP(int)(__setprecision, _p); }
inline SMANIP(int)  setw(int _w) { return SMANIP(int)(__setw, _w); }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\fstream.h ===
/***
*fstream.h - definitions/declarations for filebuf and fstream classes
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the filebuf and fstream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_FSTREAM
#define _INC_FSTREAM

#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef int filedesc;

class filebuf : public streambuf {
public:
static  const int   openprot;   // default share/prot mode for open

// optional share values for 3rd argument (prot) of open or constructor
static  const int   sh_compat;  // compatibility share mode
static  const int   sh_none;    // exclusive mode no sharing
static  const int   sh_read;    // allow read sharing
static  const int   sh_write;   // allow write sharing
// use (sh_read | sh_write) to allow both read and write sharing

// options for setmode member function
static  const int   binary;
static  const int   text;

            filebuf();
            filebuf(filedesc);
            filebuf(filedesc, char _HFAR_ *, int);
            ~filebuf();

    filebuf*    attach(filedesc);
    filedesc    fd() const { return (x_fd==-1) ? EOF : x_fd; }
    int     is_open() const { return (x_fd!=-1); }
    filebuf*    open(const char _HFAR_ *, int, int = filebuf::openprot);
    filebuf*    close();
    int     setmode(int = filebuf::text);

virtual int     overflow(int=EOF);
virtual int     underflow();

virtual streambuf*  setbuf(char _HFAR_ *, int);
virtual streampos   seekoff(streamoff, ios::seek_dir, int);
// virtual  streampos   seekpos(streampos, int);
virtual int     sync();

private:
    filedesc    x_fd;
    int     x_fOpened;
};

class ifstream : public istream {
public:
    ifstream();
    ifstream(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    ifstream(filedesc);
    ifstream(filedesc, char _HFAR_ *, int);
    ~ifstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::in, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class ofstream : public ostream {
public:
    ofstream();
    ofstream(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    ofstream(filedesc);
    ofstream(filedesc, char _HFAR_ *, int);
    ~ofstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ios::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int =ios::out, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

class fstream : public iostream {
public:
    fstream();
    fstream(const char _HFAR_ *, int, int = filebuf::openprot);
    fstream(filedesc);
    fstream(filedesc, char _HFAR_ *, int);
    ~fstream();

    streambuf * setbuf(char _HFAR_ *, int);
    filebuf* rdbuf() const { return (filebuf*) ostream::rdbuf(); }

    void attach(filedesc);
    filedesc fd() const { return rdbuf()->fd(); }

    int is_open() const { return rdbuf()->is_open(); }
    void open(const char _HFAR_ *, int, int = filebuf::openprot);
    void close();
    int setmode(int mode = filebuf::text) { return rdbuf()->setmode(mode); }
};

// manipulators to dynamically change file access mode (filebufs only)
inline  ios& binary(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::binary); return _fstrm; }
inline  ios& text(ios& _fstrm) \
   { ((filebuf*)_fstrm.rdbuf())->setmode(filebuf::text); return _fstrm; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ios.h ===
/***
*ios.h - definitions/declarations for the ios class.
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ios class.
*   [AT&T C++]
*
****/

#ifndef _INC_IOS
#define _INC_IOS


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class streambuf;
class ostream;

class ios {

public:
    enum io_state {  goodbit = 0x00,
             eofbit  = 0x01,
             failbit = 0x02,
             badbit  = 0x04 };

    enum open_mode { in        = 0x01,
             out       = 0x02,
             ate       = 0x04,
             app       = 0x08,
             trunc     = 0x10,
             nocreate  = 0x20,
             noreplace = 0x40,
             binary    = 0x80 };    // CONSIDER: not in latest spec.

    enum seek_dir { beg=0, cur=1, end=2 };

    enum {  skipws     = 0x0001,
        left       = 0x0002,
        right      = 0x0004,
        internal   = 0x0008,
        dec        = 0x0010,
        oct        = 0x0020,
        hex        = 0x0040,
        showbase   = 0x0080,
        showpoint  = 0x0100,
        uppercase  = 0x0200,
        showpos    = 0x0400,
        scientific = 0x0800,
        fixed      = 0x1000,
        unitbuf    = 0x2000,
        stdio      = 0x4000
                 };

    static const long basefield;    // dec | oct | hex
    static const long adjustfield;  // left | right | internal
    static const long floatfield;   // scientific | fixed

    ios(streambuf*);            // differs from ANSI
    virtual ~ios();

    inline long flags() const;
    inline long flags(long _l);

    inline long setf(long _f,long _m);
    inline long setf(long _l);
    inline long unsetf(long _l);

    inline int width() const;
    inline int width(int _i);

    inline ostream* tie(ostream* _os);
    inline ostream* tie() const;

    inline char fill() const;
    inline char fill(char _c);

    inline int precision(int _i);
    inline int precision() const;

    inline int rdstate() const;
    inline void clear(int _i = 0);

//  inline operator void*() const;
    operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
    inline int operator!() const;

    inline int  good() const;
    inline int  eof() const;
    inline int  fail() const;
    inline int  bad() const;

    inline streambuf* rdbuf() const;

    inline long _HFAR_ & iword(int) const;
    inline void _HFAR_ * _HFAR_ & pword(int) const;

    static long bitalloc();
    static int xalloc();
    static void sync_with_stdio();

protected:
    ios();
    ios(const ios&);            // treat as private
    ios& operator=(const ios&);
    void init(streambuf*);

    enum { skipping, tied };
    streambuf*  bp;

    int     state;
    int     ispecial;           // not used
    int     ospecial;           // not used
    int     isfx_special;       // not used
    int     osfx_special;       // not used
    int     x_delbuf;           // if set, rdbuf() deleted by ~ios

    ostream* x_tie;
    long    x_flags;
    int     x_precision;
    int     x_width;
    char    x_fill;

    static void (*stdioflush)();    // not used
public:
    int delbuf() const { return x_delbuf; }
    void    delbuf(int _i) { x_delbuf = _i; }

private:
    static long x_maxbit;
    static long _HFAR_ * x_statebuf;  // used by xalloc()
    static int x_curindex;
// consider: make interal static to ios::sync_with_stdio()
    static int sunk_with_stdio;     // make sure sync_with done only once
};

inline ios& dec(ios& _strm) { _strm.setf(ios::dec,ios::basefield); return _strm; }
inline ios& hex(ios& _strm) { _strm.setf(ios::hex,ios::basefield); return _strm; }
inline ios& oct(ios& _strm) { _strm.setf(ios::oct,ios::basefield); return _strm; }

inline long ios::flags() const { return x_flags; }
inline long ios::flags(long _l){ long _lO; _lO = x_flags; x_flags = _l; return _lO; }

inline long ios::setf(long _l,long _m){ long _lO; _lO = x_flags; x_flags = (_l&_m) | (x_flags&(~_m)); return _lO; }
inline long ios::setf(long _l){ long _lO; _lO = x_flags; x_flags |= _l; return _lO; }
inline long ios::unsetf(long _l){ long _lO; _lO = x_flags; x_flags &= (~_l); return _lO; }

inline int ios::width() const { return x_width; }
inline int ios::width(int _i){ int _iO; _iO = (int)x_width; x_width = _i; return _iO; }

inline ostream* ios::tie(ostream* _os){ ostream* _osO; _osO = x_tie; x_tie = _os; return _osO; }
inline ostream* ios::tie() const { return x_tie; }
inline char ios::fill() const { return x_fill; }
inline char ios::fill(char _c){ char _cO; _cO = x_fill; x_fill = _c; return _cO; }
inline int ios::precision(int _i){ int _iO; _iO = (int)x_precision; x_precision = _i; return _iO; }
inline int ios::precision() const { return x_precision; }

inline int ios::rdstate() const { return state; }

// inline ios::operator void *() const { if(state&(badbit|failbit) ) return 0; return (void *)this; }
inline int ios::operator!() const { return state&(badbit|failbit); }

inline int  ios::bad() const { return state & badbit; }
inline void ios::clear(int _i){ state = _i; }
inline int  ios::eof() const { return state & eofbit; }
inline int  ios::fail() const { return state & (badbit | failbit); }
inline int  ios::good() const { return state == 0; }

inline streambuf* ios::rdbuf() const { return bp; }

inline long _HFAR_ & ios::iword(int _i) const { return x_statebuf[_i] ; }
inline void _HFAR_ * _HFAR_ & ios::pword(int _i) const { return (void _HFAR_ * _HFAR_ &)x_statebuf[_i]; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\limits.h ===
/***
*limits.h - implementation dependent values
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains defines for a number of implementation dependent values
*   which are commonly used in C programs.
*   [ANSI]
*
****/

#ifndef _INC_LIMITS

#define CHAR_BIT      8     /* number of bits in a char */
#define SCHAR_MIN   (-127)      /* minimum signed char value */
#define SCHAR_MAX     127       /* maximum signed char value */
#define UCHAR_MAX     0xff      /* maximum unsigned char value */
#ifndef _CHAR_UNSIGNED
#define CHAR_MIN    SCHAR_MIN   /* mimimum char value */
#define CHAR_MAX    SCHAR_MAX   /* maximum char value */
#else 
#define CHAR_MIN      0
#define CHAR_MAX    UCHAR_MAX
#ifndef __cplusplus
unsigned int _charmax;          /* unsigned CHAR_MAX value */
#else 
extern "C" unsigned int _charmax;   /* unsigned CHAR_MAX value */
static unsigned int *_char_max = &_charmax;
#endif 
#endif 
#define MB_LEN_MAX    2     /* max. # bytes in multibyte char */
#define SHRT_MIN    (-32767)    /* minimum (signed) short value */
#define SHRT_MAX      32767     /* maximum (signed) short value */
#define USHRT_MAX     0xffff    /* maximum unsigned short value */
#define INT_MIN     (-32767)    /* minimum (signed) int value */
#define INT_MAX       32767     /* maximum (signed) int value */
#define UINT_MAX      0xffff    /* maximum unsigned int value */
#define LONG_MIN    (-2147483647)   /* minimum (signed) long value */
#define LONG_MAX      2147483647    /* maximum (signed) long value */
#define ULONG_MAX     0xffffffff    /* maximum unsigned long value */

#define _INC_LIMITS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\iostream.h ===
/***
*iostream.h - definitions/declarations for iostream classes
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the iostream classes.
*   [AT&T C++]
*
****/

#ifndef _INC_IOSTREAM
#define _INC_IOSTREAM

typedef long streamoff, streampos;

#include <ios.h>        // Define ios.

#include <streamb.h>        // Define streambuf.

#include <istream.h>        // Define istream.

#include <ostream.h>        // Define ostream.

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

class iostream : public istream, public ostream {
public:
    iostream(streambuf*);
    virtual ~iostream();
protected:
// consider: make private??
    iostream();
    iostream(const iostream&);
inline iostream& operator=(streambuf*);
inline iostream& operator=(iostream&);
private:
    iostream(ios&);
    iostream(istream&);
    iostream(ostream&);
};

inline iostream& iostream::operator=(streambuf* _sb) { istream::operator=(_sb); ostream::operator=(_sb); return *this; }

inline iostream& iostream::operator=(iostream& _strm) { return operator=(_strm.rdbuf()); }

class Iostream_init {
public:
    Iostream_init();
    Iostream_init(ios &, int =0);   // treat as private
    ~Iostream_init();
};

// used internally
// static Iostream_init __iostreaminit; // initializes cin/cout/cerr/clog

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\istream.h ===
/***
*istream.h - definitions/declarations for the istream class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the istream class.
*   [AT&T C++]
*
****/

#ifndef _INC_ISTREAM
#define _INC_ISTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class istream : virtual public ios {

public:
    istream(streambuf*);
    virtual ~istream();

    int  ipfx(int =0);
    void isfx() { }

    inline istream& operator>>(istream& (*_f)(istream&));
    inline istream& operator>>(ios& (*_f)(ios&));
    istream& operator>>(char _HFAR_ *);
    inline istream& operator>>(unsigned char _HFAR_ *);
    inline istream& operator>>(signed char _HFAR_ *);
    istream& operator>>(char _HFAR_ &);
    inline istream& operator>>(unsigned char _HFAR_ &);
    inline istream& operator>>(signed char _HFAR_ &);
    istream& operator>>(short _HFAR_ &);
    istream& operator>>(unsigned short _HFAR_ &);
    istream& operator>>(int _HFAR_ &);
    istream& operator>>(unsigned int _HFAR_ &);
    istream& operator>>(long _HFAR_ &);
    istream& operator>>(unsigned long _HFAR_ &);
    istream& operator>>(float _HFAR_ &);
    istream& operator>>(double _HFAR_ &);
    istream& operator>>(long double _HFAR_ &);
    istream& operator>>(streambuf*);

    int get();
    istream& get(char _HFAR_ *,int,char ='\n');
    inline istream& get(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& get(signed char _HFAR_ *,int,char ='\n');
    istream& get(char _HFAR_ &);
    inline istream& get(unsigned char _HFAR_ &);
    inline istream& get(signed char _HFAR_ &);
    istream& get(streambuf&,char ='\n');
    inline istream& getline(char _HFAR_ *,int,char ='\n');
    inline istream& getline(unsigned char _HFAR_ *,int,char ='\n');
    inline istream& getline(signed char _HFAR_ *,int,char ='\n');

    inline istream& ignore(int =1,int =EOF);
    istream& read(char _HFAR_ *,int);
    inline istream& read(unsigned char _HFAR_ *,int);
    inline istream& read(signed char _HFAR_ *,int);

    int gcount() const { return x_gcount; }
    int peek();
    istream& putback(char);
    int sync();

    istream& seekg(streampos);
    istream& seekg(streamoff,ios::seek_dir);
    streampos tellg();

    void eatwhite();    // consider: protect and friend with manipulator ws
protected:
    istream();
    istream(const istream&);    // treat as private
    istream& operator=(streambuf* _isb); // treat as private
    istream& operator=(const istream& _is) { return operator=(_is.rdbuf()); }
    int do_ipfx(int);

private:
    istream(ios&);
    int getint(char _HFAR_ *);
    int getdouble(char _HFAR_ *, int);
    int _fGline;
    int x_gcount;
};

    inline istream& istream::operator>>(istream& (*_f)(istream&)) { (*_f)(*this); return *this; }
    inline istream& istream::operator>>(ios& (*_f)(ios&)) { (*_f)(*this); return *this; }

    inline istream& istream::operator>>(unsigned char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }
    inline istream& istream::operator>>(signed char _HFAR_ * _s) { return operator>>((char _HFAR_ *)_s); }

    inline istream& istream::operator>>(unsigned char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }
    inline istream& istream::operator>>(signed char _HFAR_ & _c) { return operator>>((char _HFAR_ &) _c); }

    inline istream& istream::get(unsigned char _HFAR_ * b, int lim ,char delim) { return get((char _HFAR_ *)b, lim, delim); }
    inline istream& istream::get(signed char _HFAR_ * b, int lim, char delim) { return get((char _HFAR_ *)b, lim, delim); }

    inline istream& istream::get(unsigned char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }
    inline istream& istream::get(signed char _HFAR_ & _c) { return get((char _HFAR_ &)_c); }

    inline istream& istream::getline(char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get(_b, _lim, _delim); }
    inline istream& istream::getline(unsigned char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }
    inline istream& istream::getline(signed char _HFAR_ * _b,int _lim,char _delim) { _fGline++; return get((char _HFAR_ *)_b, _lim, _delim); }

    inline istream& istream::ignore(int _n,int delim) { _fGline++; return get((char _HFAR_ *)0, _n+1, (char)delim); }

    inline istream& istream::read(unsigned char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }
    inline istream& istream::read(signed char _HFAR_ * _ptr, int _n) { return read((char _HFAR_ *) _ptr, _n); }

class istream_withassign : public istream {
    public:
        istream_withassign();
        istream_withassign(streambuf*);
        ~istream_withassign();
    istream& operator=(const istream& _is) { return istream::operator=(_is); }
    istream& operator=(streambuf* _isb) { return istream::operator=(_isb); }
};

#ifndef _WINDLL
extern istream_withassign cin;
#endif 

inline istream& ws(istream& _ins) { _ins.eatwhite(); return _ins; }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\io.h ===
/***
*io.h - declarations for low-level file handling and I/O functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the low-level
*   file handling and I/O functions.
*
****/

#ifndef _INC_IO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };

#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

int __cdecl _access(const char *, int);
int __cdecl _chmod(const char *, int);
int __cdecl _chsize(int, long);
int __cdecl _close(int);
int __cdecl _commit(int);
int __cdecl _creat(const char *, int);
int __cdecl _dup(int);
int __cdecl _dup2(int, int);
int __cdecl _eof(int);
long __cdecl _filelength(int);
int __cdecl _isatty(int);
int __cdecl _locking(int, int, long);
long __cdecl _lseek(int, long, int);
char * __cdecl _mktemp(char *);
int __cdecl _open(const char *, int, ...);
int __cdecl _read(int, void *, unsigned int);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
int __cdecl _setmode(int, int);
int __cdecl _sopen(const char *, int, int, ...);
long __cdecl _tell(int);
int __cdecl _umask(int);
int __cdecl _unlink(const char *);
int __cdecl _write(int, const void *, unsigned int);
#ifdef _WINDOWS
#ifndef _WINDLL
int __cdecl _wabout(char *);
int __cdecl _wclose(int, int);
int __cdecl _wgetexit(void);
int __cdecl _wgetfocus(void);
long __cdecl _wgetscreenbuf(int);
int __cdecl _wgetsize(int, int, struct _wsizeinfo *);
int __cdecl _wmenuclick(int);
int __cdecl _wopen(struct _wopeninfo *, struct _wsizeinfo *, int);
int __cdecl _wsetexit(int);
int __cdecl _wsetfocus(int);
int __cdecl _wsetscreenbuf(int, long);
int __cdecl _wsetsize(int, struct _wsizeinfo *);
void __cdecl _wyield(void);
#endif 
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */
int __cdecl access(const char *, int);
int __cdecl chmod(const char *, int);
int __cdecl chsize(int, long);
int __cdecl close(int);
int __cdecl creat(const char *, int);
int __cdecl dup(int);
int __cdecl dup2(int, int);
int __cdecl eof(int);
long __cdecl filelength(int);
int __cdecl isatty(int);
int __cdecl locking(int, int, long);
long __cdecl lseek(int, long, int);
char * __cdecl mktemp(char *);
int __cdecl open(const char *, int, ...);
int __cdecl read(int, void *, unsigned int);
int __cdecl setmode(int, int);
int __cdecl sopen(const char *, int, int, ...);
long __cdecl tell(int);
int __cdecl umask(int);
int __cdecl unlink(const char *);
int __cdecl write(int, const void *, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_IO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\locale.h ===
/***
*locale.h - definitions/declarations for localization routines
*
*   Copyright (c) 1988-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the localization routines.
*   [ANSI]
*
****/

#ifndef _INC_LOCALE

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* Locale categories */

#define LC_ALL      0
#define LC_COLLATE  1
#define LC_CTYPE    2
#define LC_MONETARY 3
#define LC_NUMERIC  4
#define LC_TIME     5

#define LC_MIN      LC_ALL
#define LC_MAX      LC_TIME


/* Locale convention structure */

#ifndef _LCONV_DEFINED
struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    };
#define _LCONV_DEFINED
#endif 

/* function prototypes */

char * __cdecl setlocale(int, const char *);
struct lconv * __cdecl localeconv(void);

#ifdef __cplusplus
}
#endif 

#define _INC_LOCALE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\lzdos.h ===
/* OBSOLETE: Replaced by #define LIB/#include <lzexpand.h> */
#ifndef LIB
#define LIB
#endif
#include <lzexpand.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\mapi.h ===
/*
 *  m a p i . h
 *    
 *  Messaging Applications Programming Interface.
 *    
 *  Copyright (c) 1992, Microsoft Corporation.  All rights reserved.
 *    
 *  Purpose:
 *    This file defines the structures and constants used by
 *    that subset of the messaging applications programming
 *    interface which will be supported under Windows by
 *    Microsoft Mail for PC Networks vesion 3.0.
 */



/*
 *  Types.
 */



typedef unsigned long       ULONG;
typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;
typedef unsigned long		LHANDLE, FAR *LPLHANDLE;
#define	lhSessionNull	((LHANDLE)0)

typedef struct
  {
    ULONG ulReserved;    /* Reserved for future use (must be 0) */
	ULONG flFlags;		 /* Flags */
    ULONG nPosition;     /* character in text to be replaced by attachment */
    LPSTR lpszPathName;  /* Full path name of attachment file */
    LPSTR lpszFileName;  /* Original file name (optional) */
    LPVOID lpFileType;   /* Attachment file type (optional) */
  } MapiFileDesc, FAR * lpMapiFileDesc;

#define	MAPI_OLE						0x00000001
#define	MAPI_OLE_STATIC					0x00000002




typedef struct
  {
    ULONG ulReserved;           /* Reserved for future use */
    ULONG ulRecipClass;         /* Recipient class */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG */
    LPSTR lpszName;             /* Recipient name */
    LPSTR lpszAddress;          /* Recipient address (optional) */
    ULONG ulEIDSize;	        /* Count in bytes of size of pEntryID */
    LPVOID lpEntryID;           /* System-specific recipient reference */
  } MapiRecipDesc, FAR * lpMapiRecipDesc;

#define MAPI_ORIG   0           /* Recipient is message originator */
#define MAPI_TO     1           /* Recipient is a primary recipient */
#define MAPI_CC     2           /* Recipient is a copy recipient */
#define MAPI_BCC    3           /* Recipient is blind copy recipient */



typedef struct
  {
    ULONG ulReserved;                   /* Reserved for future use (M.B. 0) */
    LPSTR lpszSubject;                  /* Message Subject */
    LPSTR lpszNoteText;                 /* Message Text */
    LPSTR lpszMessageType;              /* Message Class */
    LPSTR lpszDateReceived;             /* in YYYY/MM/DD HH:MM format    */
	LPSTR lpszConversationID;			/* conversation thread ID */
    FLAGS flFlags;                      /* unread,return receipt */
    lpMapiRecipDesc lpOriginator;       /* Originator descriptor */
    ULONG nRecipCount;                  /* Number of recipients */
    lpMapiRecipDesc lpRecips;           /* Recipient descriptors */
    ULONG nFileCount;                   /* # of file attachments */
    lpMapiFileDesc lpFiles;             /* Attachment descriptors */
  } MapiMessage, FAR * lpMapiMessage;

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004



/*
 *  Entry points.
 */



#define MAPI_LOGON_UI                   0x00000001  /* Display logon UI */
#define MAPI_NEW_SESSION                0x00000002  /* Do not use default. */
#define MAPI_DIALOG                     0x00000008  /* Display a send note UI */
#define MAPI_UNREAD_ONLY                0x00000020  /* Only unread messages */
#define MAPI_ENVELOPE_ONLY              0x00000040  /* Only header information */
#define MAPI_PEEK                       0x00000080  /* Do not mark as read. */
#define MAPI_GUARANTEE_FIFO				0x00000100	/* use date order */
#define	MAPI_BODY_AS_FILE				0x00000200
#define MAPI_AB_NOMODIFY				0x00000400	/* Don't allow mods of AB entries */
#define	MAPI_SUPPRESS_ATTACH			0x00000800	/* header + body, no files */
#define	MAPI_FORCE_DOWNLOAD				0x00001000	/* force download of new mail during MAPILogon */

ULONG FAR PASCAL MAPILogon(ULONG ulUIParam, LPSTR lpszName, LPSTR lpszPassword,
                           FLAGS flFlags, ULONG ulReserved,
                           LPLHANDLE lplhSession);

ULONG FAR PASCAL MAPILogoff(LHANDLE lhSession, ULONG ulUIParam, FLAGS flFlags,
                            ULONG ulReserved);

ULONG FAR PASCAL MAPISendMail(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessage lpMessage, FLAGS flFlags,
                              ULONG ulReserved);

ULONG FAR PASCAL MAPISendDocuments(ULONG ulUIParam, LPSTR lpszDelimChar,
                                   LPSTR lpszFilePaths, LPSTR lpszFileNames,
                                   ULONG ulReserved);

ULONG FAR PASCAL MAPIFindNext(LHANDLE lhSession, ULONG ulUIParam,
                              LPSTR lpszMessageType, LPSTR lpszSeedMessageID,
                              FLAGS flFlags, ULONG ulReserved,
                              LPSTR lpszMessageID);

ULONG FAR PASCAL MAPIReadMail(LHANDLE lhSession, ULONG ulUIParam,
                              LPSTR lpszMessageID, FLAGS flFlags,
                              ULONG ulReserved, lpMapiMessage FAR *lppMessageOut);

ULONG FAR PASCAL MAPISaveMail(LHANDLE lhSession, ULONG ulUIParam,
                              lpMapiMessage pMessage, FLAGS flFlags,
                              ULONG ulReserved, LPSTR lpszMessageID);

ULONG FAR PASCAL MAPIDeleteMail(LHANDLE lhSession, ULONG ulUIParam,
                                LPSTR lpszMessageID, FLAGS flFlags,
                                ULONG ulReserved);

ULONG FAR PASCAL MAPIFreeBuffer( LPVOID pv );
							
ULONG FAR PASCAL MAPIAddress(LHANDLE lhSession, ULONG ulUIParam,
					LPSTR plszCaption, ULONG nEditFields,
					LPSTR lpszLabels, ULONG nRecips,
					lpMapiRecipDesc lpRecips, FLAGS flFlags, ULONG ulReserved, 
					LPULONG lpnNewRecips, lpMapiRecipDesc FAR *lppNewRecips);

ULONG FAR PASCAL MAPIDetails(LHANDLE lhSession, ULONG ulUIParam,
					lpMapiRecipDesc lpRecip, FLAGS flFlags, ULONG ulReserved);

ULONG FAR PASCAL MAPIResolveName(LHANDLE lhSession, ULONG ulUIParam,
						LPSTR lpszName, FLAGS flFlags,
						ULONG ulReserved, lpMapiRecipDesc FAR *lppRecip);



#define SUCCESS_SUCCESS                     0
#define MAPI_USER_ABORT                     1
#define MAPI_E_FAILURE                      2
#define MAPI_E_LOGIN_FAILURE                3
#define MAPI_E_DISK_FULL                    4
#define MAPI_E_INSUFFICIENT_MEMORY          5
#define MAPI_E_ACCESS_DENIED				6
#define MAPI_E_TOO_MANY_SESSIONS            8
#define MAPI_E_TOO_MANY_FILES               9
#define MAPI_E_TOO_MANY_RECIPIENTS          10
#define MAPI_E_ATTACHMENT_NOT_FOUND         11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE      12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE     13
#define MAPI_E_UNKNOWN_RECIPIENT            14
#define MAPI_E_BAD_RECIPTYPE                15
#define MAPI_E_NO_MESSAGES                  16
#define MAPI_E_INVALID_MESSAGE              17
#define MAPI_E_TEXT_TOO_LARGE               18
#define	MAPI_E_INVALID_SESSION				19
#define	MAPI_E_TYPE_NOT_SUPPORTED			20
#define	MAPI_E_AMBIGUOUS_RECIPIENT			21
#define MAPI_E_MESSAGE_IN_USE				22
#define MAPI_E_NETWORK_FAILURE				23
#define	MAPI_E_INVALID_EDITFIELDS			24
#define	MAPI_E_INVALID_RECIPS				25
#define	MAPI_E_NOT_SUPPORTED				26
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\lzexpand.h ===
/*****************************************************************************\
*                                                                             *
* lzexpand.h    Public interfaces for LZEXPAND.DLL.                           *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               NOTE: windows.h must be included first if LIB is NOT #defined *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with LZEXP?.LIB (default is for LZEXPAND.DLL)
*                 NOTE: Not compatible with windows.h if LIB is #defined
*
\*****************************************************************************/

#ifndef _INC_LZEXPAND
#define _INC_LZEXPAND

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#define LZAPI       _pascal

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#endif  /* WINAPI */

#else   /* LIB */

#define LZAPI       _far _pascal

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/****** Error return codes ***************************************************/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of range */
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */

/****** Public functions *****************************************************/

int     LZAPI LZStart(void);
void    LZAPI LZDone(void);
LONG    LZAPI CopyLZFile(HFILE, HFILE);
LONG    LZAPI LZCopy(HFILE, HFILE);
HFILE   LZAPI LZInit(HFILE);
int     LZAPI GetExpandedName(LPCSTR, LPSTR);
HFILE   LZAPI LZOpenFile(LPCSTR, OFSTRUCT FAR*, UINT);
LONG    LZAPI LZSeek(HFILE, LONG, int);
int     LZAPI LZRead(HFILE, void FAR*, int);
void    LZAPI LZClose(HFILE);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#endif  /* _INC_LZEXPAND */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\malloc.h ===
/***
*malloc.h - declarations and definitions for memory allocation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for memory allocation functions;
*   also defines manifest constants and types used by the heap routines.
*   [System V]
*
****/

#ifndef _INC_MALLOC

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __based     _based
#define __cdecl     _cdecl
#define __far       _far
#define __huge      _huge
#define __near      _near
#define __segment   _segment
#endif 

/* constants for based heap routines */

#define _NULLSEG    ((__segment)0)
#define _NULLOFF    ((void __based(void) *)0xffff)

/* constants for _heapchk/_heapset/_heapwalk routines */

#define _HEAPEMPTY  (-1)
#define _HEAPOK     (-2)
#define _HEAPBADBEGIN   (-3)
#define _HEAPBADNODE    (-4)
#define _HEAPEND    (-5)
#define _HEAPBADPTR (-6)
#define _FREEENTRY  0
#define _USEDENTRY  1

/* maximum heap request that can ever be honored */

#ifdef _WINDOWS
#define _HEAP_MAXREQ    0xFFE6
#else 
#define _HEAP_MAXREQ    0xFFE8
#endif 

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _HEAPINFO_DEFINED
typedef struct _heapinfo {
    int __far * _pentry;
    size_t _size;
    int _useflag;
    } _HEAPINFO;
#define _HEAPINFO_DEFINED
#endif 


/* external variable declarations */

extern unsigned int __near __cdecl _amblksiz;


/* based heap function prototypes */

void __based(void) * __cdecl _bcalloc(__segment, size_t, size_t);
void __based(void) * __cdecl _bexpand(__segment,
    void __based(void) *, size_t);
void __cdecl _bfree(__segment, void __based(void) *);
int __cdecl _bfreeseg(__segment);
int __cdecl _bheapadd(__segment, void __based(void) *, size_t);
int __cdecl _bheapchk(__segment);
int __cdecl _bheapmin(__segment);
__segment __cdecl _bheapseg(size_t);
int __cdecl _bheapset(__segment, unsigned int);
int __cdecl _bheapwalk(__segment, _HEAPINFO *);
void __based(void) * __cdecl _bmalloc(__segment, size_t);
size_t __cdecl _bmsize(__segment, void __based(void) *);
void __based(void) * __cdecl _brealloc(__segment,
    void __based(void) *, size_t);


/* function prototypes */

void * __cdecl _alloca(size_t);
void * __cdecl calloc(size_t, size_t);
void * __cdecl _expand(void *, size_t);
void __far * __cdecl _fcalloc(size_t, size_t);
void __far * __cdecl _fexpand(void __far *, size_t);
void __cdecl _ffree(void __far *);
int __cdecl _fheapchk(void);
int __cdecl _fheapmin(void);
int __cdecl _fheapset(unsigned int);
int __cdecl _fheapwalk(_HEAPINFO *);
void __far * __cdecl _fmalloc(size_t);
size_t __cdecl _fmsize(void __far *);
void __far * __cdecl _frealloc(void __far *, size_t);
unsigned int __cdecl _freect(size_t);
void __cdecl free(void *);
void __huge * __cdecl _halloc(long, size_t);
void __cdecl _hfree(void __huge *);
#ifndef _WINDOWS
int __cdecl _heapadd(void __far *, size_t);
int __cdecl _heapchk(void);
#endif 
int __cdecl _heapmin(void);
#ifndef _WINDOWS
int __cdecl _heapset(unsigned int);
int __cdecl _heapwalk(_HEAPINFO *);
#endif 
void * __cdecl malloc(size_t);
size_t __cdecl _memavl(void);
size_t __cdecl _memmax(void);
size_t __cdecl _msize(void *);
void __near * __cdecl _ncalloc(size_t, size_t);
void __near * __cdecl _nexpand(void __near *, size_t);
void __cdecl _nfree(void __near *);
#ifndef _WINDOWS
int __cdecl _nheapchk(void);
#endif 
int __cdecl _nheapmin(void);
#ifndef _WINDOWS
int __cdecl _nheapset(unsigned int);
int __cdecl _nheapwalk(_HEAPINFO *);
#endif 
void __near * __cdecl _nmalloc(size_t);
size_t __cdecl _nmsize(void __near *);
void __near * __cdecl _nrealloc(void __near *, size_t);
void * __cdecl realloc(void *, size_t);
size_t __cdecl _stackavail(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl alloca(size_t);
void __huge * __cdecl halloc(long, size_t);
void __cdecl hfree(void __huge *);
size_t __cdecl stackavail(void);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MALLOC
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\memory.h ===
/***
*memory.h - declarations for buffer (memory) manipulation routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for the
*   buffer (memory) manipulation routines.
*   [System V]
*
****/

#ifndef _INC_MEMORY

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 


/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
void * __cdecl memcpy(void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_MEMORY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\mmsystem.h ===
/****************************************************************************/
/*                                                                          */
/*        MMSYSTEM.H - Include file for Multimedia APIs                     */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/



/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *      MMNODRV          - Installable driver support
 *      MMNOSOUND        - Sound support
 *      MMNOWAVE         - Waveform support
 *      MMNOMIDI         - MIDI support
 *      MMNOAUX          - Auxiliary audio support
 *      MMNOTIMER        - Timer support
 *      MMNOJOY          - Joystick support
 *      MMNOMCI          - MCI support
 *      MMNOMMIO         - Multimedia file I/O support
 *      MMNOMMSYSTEM     - General MMSYSTEM functions
 */

#ifndef _INC_MMSYSTEM
#define _INC_MMSYSTEM   /* #defined if mmsystem.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */


/****************************************************************************

                    General constants and data types

****************************************************************************/

/* general constants */
#define MAXPNAMELEN      32     /* max product name length (including NULL) */
#define MAXERRORLENGTH   128    /* max error text length (including NULL) */

/* general data types */
typedef WORD    VERSION;        /* major (high byte), minor (low byte) */

/* MMTIME data structure */
typedef struct mmtime_tag {
    UINT    wType;              /* indicates the contents of the union */
    union {
        DWORD ms;               /* milliseconds */
        DWORD sample;           /* samples */
        DWORD cb;               /* byte count */
        struct {                /* SMPTE */
            BYTE hour;          /* hours */
            BYTE min;           /* minutes */
            BYTE sec;           /* seconds */
            BYTE frame;         /* frames  */
            BYTE fps;           /* frames per second */
            BYTE dummy;         /* pad */
            } smpte;
        struct {                /* MIDI */
            DWORD songptrpos;   /* song pointer position */
            } midi;
        } u;
    } MMTIME;
typedef MMTIME       *PMMTIME;
typedef MMTIME NEAR *NPMMTIME;
typedef MMTIME FAR  *LPMMTIME;

/* types for wType field in MMTIME struct */
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */


/****************************************************************************

                    Multimedia Extensions Window Messages

****************************************************************************/

#define MM_JOY1MOVE         0x3A0           /* joystick */
#define MM_JOY2MOVE         0x3A1
#define MM_JOY1ZMOVE        0x3A2
#define MM_JOY2ZMOVE        0x3A3
#define MM_JOY1BUTTONDOWN   0x3B5
#define MM_JOY2BUTTONDOWN   0x3B6
#define MM_JOY1BUTTONUP     0x3B7
#define MM_JOY2BUTTONUP     0x3B8

#define MM_MCINOTIFY        0x3B9           /* MCI */

#define MM_WOM_OPEN         0x3BB           /* waveform output */
#define MM_WOM_CLOSE        0x3BC
#define MM_WOM_DONE         0x3BD

#define MM_WIM_OPEN         0x3BE           /* waveform input */
#define MM_WIM_CLOSE        0x3BF
#define MM_WIM_DATA         0x3C0

#define MM_MIM_OPEN         0x3C1           /* MIDI input */
#define MM_MIM_CLOSE        0x3C2
#define MM_MIM_DATA         0x3C3
#define MM_MIM_LONGDATA     0x3C4
#define MM_MIM_ERROR        0x3C5
#define MM_MIM_LONGERROR    0x3C6

#define MM_MOM_OPEN         0x3C7           /* MIDI output */
#define MM_MOM_CLOSE        0x3C8
#define MM_MOM_DONE         0x3C9


/****************************************************************************

                String resource number bases (internal use)

****************************************************************************/

#define MMSYSERR_BASE          0
#define WAVERR_BASE            32
#define MIDIERR_BASE           64
#define TIMERR_BASE            96
#define JOYERR_BASE            160
#define MCIERR_BASE            256

#define MCI_STRING_OFFSET      512
#define MCI_VD_OFFSET          1024
#define MCI_CD_OFFSET          1088
#define MCI_WAVE_OFFSET        1152
#define MCI_SEQ_OFFSET         1216

/****************************************************************************

                        General error return values

****************************************************************************/

/* general error return values */
#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 11) /* last error in range */


#if (WINVER < 0x030a)
DECLARE_HANDLE(HDRVR);
#endif /* ifdef WINVER < 0x030a */

#ifndef MMNODRV
/****************************************************************************

                        Installable driver support

****************************************************************************/

#if (WINVER < 0x030a)

/* return values from DriverProc() function */
#define DRV_CANCEL              0x0000
#define DRV_OK                  0x0001
#define DRV_RESTART             0x0002

/* Driver messages */
#define DRV_LOAD                0x0001
#define DRV_ENABLE              0x0002
#define DRV_OPEN                0x0003
#define DRV_CLOSE               0x0004
#define DRV_DISABLE             0x0005
#define DRV_FREE                0x0006
#define DRV_CONFIGURE           0x0007
#define DRV_QUERYCONFIGURE      0x0008
#define DRV_INSTALL             0x0009
#define DRV_REMOVE              0x000A
#define DRV_RESERVED            0x0800
#define DRV_USER                0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO        *PDRVCONFIGINFO;
typedef DRVCONFIGINFO  NEAR *NPDRVCONFIGINFO;
typedef DRVCONFIGINFO  FAR  *LPDRVCONFIGINFO;

/* installable driver function prototypes */
LRESULT   WINAPI DrvClose(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);
HDRVR     WINAPI DrvOpen(LPCSTR szDriverName, LPCSTR szSectionName,
    LPARAM lParam2);
LRESULT   WINAPI DrvSendMessage(HDRVR hDriver, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
HINSTANCE WINAPI DrvGetModuleHandle(HDRVR hDriver);

LRESULT WINAPI DrvDefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, 
    UINT uMessage, LPARAM lParam1, LPARAM lParam2);

#define DefDriverProc DrvDefDriverProc

#endif /* ifdef WINVER < 0x030a */

#if (WINVER >= 0x030a)


/* return values from DriverProc() function */
#define DRV_CANCEL             DRVCNF_CANCEL
#define DRV_OK                 DRVCNF_OK
#define DRV_RESTART            DRVCNF_RESTART

#endif /* ifdef WINVER >= 0x030a */

#define DRV_MCI_FIRST          DRV_RESERVED
#define DRV_MCI_LAST           (DRV_RESERVED + 0xFFF)

#endif  /* ifndef MMNODRV */


/****************************************************************************

                          Driver callback support

****************************************************************************/

/* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and */
/* midiOutOpen() to specify the type of the dwCallback parameter. */

#define CALLBACK_TYPEMASK   0x00070000l    /* callback type mask */
#define CALLBACK_NULL       0x00000000l    /* no callback */
#define CALLBACK_WINDOW     0x00010000l    /* dwCallback is a HWND */
#define CALLBACK_TASK       0x00020000l    /* dwCallback is a HTASK */
#define CALLBACK_FUNCTION   0x00030000l    /* dwCallback is a FARPROC */

/* driver callback prototypes */
typedef void (CALLBACK DRVCALLBACK) (HDRVR h, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef DRVCALLBACK FAR *LPDRVCALLBACK;

/****************************************************************************

                         Manufacturer and product IDs
        
    Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS, 
    MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.

****************************************************************************/

/* manufacturer IDs */
#define MM_MICROSOFT            1       /* Microsoft Corp. */

/* product IDs */
#define MM_MIDI_MAPPER          1       /* MIDI Mapper */
#define MM_WAVE_MAPPER          2       /* Wave Mapper */

#define MM_SNDBLST_MIDIOUT      3       /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4       /* Sound Blaster MIDI input port  */
#define MM_SNDBLST_SYNTH        5       /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6       /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7       /* Sound Blaster waveform input */

#define MM_ADLIB                9       /* Ad Lib-compatible synthesizer */

#define MM_MPU401_MIDIOUT       10      /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN        11      /* MPU401-compatible MIDI input port */

#define MM_PC_JOYSTICK          12      /* Joystick adapter */


#ifndef MMNOMMSYSTEM
/****************************************************************************

                    General MMSYSTEM support

****************************************************************************/

WORD WINAPI mmsystemGetVersion(void);
void WINAPI OutputDebugStr(LPCSTR);

#endif  /* ifndef MMNOMMSYSTEM */


#ifndef MMNOSOUND
/****************************************************************************

                            Sound support

****************************************************************************/

BOOL WINAPI sndPlaySound(LPCSTR lpszSoundName, UINT uFlags);

/* flag values for wFlags parameter */
#define SND_SYNC            0x0000  /* play synchronously (default) */
#define SND_ASYNC           0x0001  /* play asynchronously */
#define SND_NODEFAULT       0x0002  /* don't use default sound */
#define SND_MEMORY          0x0004  /* lpszSoundName points to a memory file */
#define SND_LOOP            0x0008  /* loop the sound until next sndPlaySound */
#define SND_NOSTOP          0x0010  /* don't stop any currently playing sound */    

#endif  /* ifndef MMNOSOUND */


#ifndef MMNOWAVE
/****************************************************************************

                        Waveform audio support

****************************************************************************/

/* waveform audio error return values */
#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* waveform audio data types */
DECLARE_HANDLE(HWAVE);
DECLARE_HANDLE(HWAVEIN);
DECLARE_HANDLE(HWAVEOUT);
typedef HWAVEIN FAR *LPHWAVEIN;
typedef HWAVEOUT FAR *LPHWAVEOUT;
typedef DRVCALLBACK WAVECALLBACK;
typedef WAVECALLBACK FAR *LPWAVECALLBACK;

/* wave callback messages */
#define WOM_OPEN        MM_WOM_OPEN
#define WOM_CLOSE       MM_WOM_CLOSE
#define WOM_DONE        MM_WOM_DONE
#define WIM_OPEN        MM_WIM_OPEN
#define WIM_CLOSE       MM_WIM_CLOSE
#define WIM_DATA        MM_WIM_DATA

/* device ID for wave device mapper */
#define WAVE_MAPPER     (-1)

/* flags for dwFlags parameter in waveOutOpen() and waveInOpen() */
#define  WAVE_FORMAT_QUERY     0x0001
#define  WAVE_ALLOWSYNC        0x0002

/* wave data block header */
typedef struct wavehdr_tag {
    LPSTR       lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* length of data buffer */
    DWORD       dwBytesRecorded;        /* used for input only */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwLoops;                /* loop control counter */
    struct wavehdr_tag far *lpNext;     /* reserved for driver */
    DWORD       reserved;               /* reserved for driver */
} WAVEHDR;
typedef WAVEHDR       *PWAVEHDR;
typedef WAVEHDR NEAR *NPWAVEHDR;
typedef WAVEHDR FAR  *LPWAVEHDR;

/* flags for dwFlags field of WAVEHDR */
#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */

/* waveform output device capabilities structure */
typedef struct waveoutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    DWORD   dwFormats;             /* formats supported */
    UINT    wChannels;             /* number of sources supported */
    DWORD   dwSupport;             /* functionality supported by driver */
} WAVEOUTCAPS;
typedef WAVEOUTCAPS       *PWAVEOUTCAPS;
typedef WAVEOUTCAPS NEAR *NPWAVEOUTCAPS;
typedef WAVEOUTCAPS FAR  *LPWAVEOUTCAPS;

/* flags for dwSupport field of WAVEOUTCAPS */
#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010

/* waveform input device capabilities structure */
typedef struct waveincaps_tag {
    UINT    wMid;                    /* manufacturer ID */
    UINT    wPid;                    /* product ID */
    VERSION vDriverVersion;          /* version of the driver */
    char    szPname[MAXPNAMELEN];    /* product name (NULL terminated string) */
    DWORD   dwFormats;               /* formats supported */
    UINT    wChannels;               /* number of channels supported */
} WAVEINCAPS;
typedef WAVEINCAPS       *PWAVEINCAPS;
typedef WAVEINCAPS NEAR *NPWAVEINCAPS;
typedef WAVEINCAPS FAR  *LPWAVEINCAPS;

/* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS */
#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT       *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;

/* waveform audio function prototypes */
UINT WINAPI waveOutGetNumDevs(void);
UINT WINAPI waveOutGetDevCaps(UINT uDeviceID, WAVEOUTCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI waveOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI waveOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveOutOpen(HWAVEOUT FAR* lphWaveOut, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveOutClose(HWAVEOUT hWaveOut);
UINT WINAPI waveOutPrepareHeader(HWAVEOUT hWaveOut,
     WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutUnprepareHeader(HWAVEOUT hWaveOut,
    WAVEHDR FAR* lpWaveOutHdr, UINT uSize);
UINT WINAPI waveOutWrite(HWAVEOUT hWaveOut, WAVEHDR FAR* lpWaveOutHdr,
    UINT uSize);
UINT WINAPI waveOutPause(HWAVEOUT hWaveOut);
UINT WINAPI waveOutRestart(HWAVEOUT hWaveOut);
UINT WINAPI waveOutReset(HWAVEOUT hWaveOut);
UINT WINAPI waveOutBreakLoop(HWAVEOUT hWaveOut);
UINT WINAPI waveOutGetPosition(HWAVEOUT hWaveOut, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveOutGetPitch(HWAVEOUT hWaveOut, DWORD FAR* lpdwPitch);
UINT WINAPI waveOutSetPitch(HWAVEOUT hWaveOut, DWORD dwPitch);
UINT WINAPI waveOutGetPlaybackRate(HWAVEOUT hWaveOut, DWORD FAR* lpdwRate);
UINT WINAPI waveOutSetPlaybackRate(HWAVEOUT hWaveOut, DWORD dwRate);
UINT WINAPI waveOutGetID(HWAVEOUT hWaveOut, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI waveOutMessage(HWAVEOUT hWaveOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI waveInGetNumDevs(void);
UINT WINAPI waveInGetDevCaps(UINT uDeviceID, WAVEINCAPS FAR* lpCaps,
    UINT uSize);
UINT WINAPI waveInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI waveInOpen(HWAVEIN FAR* lphWaveIn, UINT uDeviceID,
    const WAVEFORMAT FAR* lpFormat, DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI waveInClose(HWAVEIN hWaveIn);
UINT WINAPI waveInPrepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInUnprepareHeader(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInAddBuffer(HWAVEIN hWaveIn,
    WAVEHDR FAR* lpWaveInHdr, UINT uSize);
UINT WINAPI waveInStart(HWAVEIN hWaveIn);
UINT WINAPI waveInStop(HWAVEIN hWaveIn);
UINT WINAPI waveInReset(HWAVEIN hWaveIn);
UINT WINAPI waveInGetPosition(HWAVEIN hWaveIn, MMTIME FAR* lpInfo,
    UINT uSize);
UINT WINAPI waveInGetID(HWAVEIN hWaveIn, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI waveInMessage(HWAVEIN hWaveIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOWAVE */


#ifndef MMNOMIDI
/****************************************************************************

                            MIDI audio support

****************************************************************************/

/* MIDI error return values */
#define MIDIERR_UNPREPARED    (MIDIERR_BASE + 0)   /* header not prepared */
#define MIDIERR_STILLPLAYING  (MIDIERR_BASE + 1)   /* still something playing */
#define MIDIERR_NOMAP         (MIDIERR_BASE + 2)   /* no current map */
#define MIDIERR_NOTREADY      (MIDIERR_BASE + 3)   /* hardware is still busy */
#define MIDIERR_NODEVICE      (MIDIERR_BASE + 4)   /* port no longer connected */
#define MIDIERR_INVALIDSETUP  (MIDIERR_BASE + 5)   /* invalid setup */
#define MIDIERR_LASTERROR     (MIDIERR_BASE + 5)   /* last error in range */

/* MIDI audio data types */
DECLARE_HANDLE(HMIDI);
DECLARE_HANDLE(HMIDIIN);
DECLARE_HANDLE(HMIDIOUT);
typedef HMIDIIN FAR *LPHMIDIIN;
typedef HMIDIOUT FAR *LPHMIDIOUT;
typedef DRVCALLBACK MIDICALLBACK;
typedef MIDICALLBACK FAR *LPMIDICALLBACK;
#define MIDIPATCHSIZE   128
typedef WORD PATCHARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPPATCHARRAY;
typedef WORD KEYARRAY[MIDIPATCHSIZE];
typedef WORD FAR *LPKEYARRAY;

/* MIDI callback messages */
#define MIM_OPEN        MM_MIM_OPEN
#define MIM_CLOSE       MM_MIM_CLOSE
#define MIM_DATA        MM_MIM_DATA
#define MIM_LONGDATA    MM_MIM_LONGDATA
#define MIM_ERROR       MM_MIM_ERROR
#define MIM_LONGERROR   MM_MIM_LONGERROR
#define MOM_OPEN        MM_MOM_OPEN
#define MOM_CLOSE       MM_MOM_CLOSE
#define MOM_DONE        MM_MOM_DONE

/* device ID for MIDI mapper */
#define MIDIMAPPER     (-1)
#define MIDI_MAPPER    (-1)

/* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() */                             
#define MIDI_CACHE_ALL      1                            
#define MIDI_CACHE_BESTFIT  2                            
#define MIDI_CACHE_QUERY    3                            
#define MIDI_UNCACHE        4                            

/* MIDI output device capabilities structure */
typedef struct midioutcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    UINT    wVoices;               /* # of voices (internal synth only) */
    UINT    wNotes;                /* max # of notes (internal synth only) */
    UINT    wChannelMask;          /* channels used (internal synth only) */
    DWORD   dwSupport;             /* functionality supported by driver */
} MIDIOUTCAPS;
typedef MIDIOUTCAPS       *PMIDIOUTCAPS;
typedef MIDIOUTCAPS NEAR *NPMIDIOUTCAPS;
typedef MIDIOUTCAPS FAR  *LPMIDIOUTCAPS;

/* flags for wTechnology field of MIDIOUTCAPS structure */
#define MOD_MIDIPORT    1  /* output port */
#define MOD_SYNTH       2  /* generic internal synth */
#define MOD_SQSYNTH     3  /* square wave internal synth */
#define MOD_FMSYNTH     4  /* FM internal synth */
#define MOD_MAPPER      5  /* MIDI mapper */

/* flags for dwSupport field of MIDIOUTCAPS structure */
#define MIDICAPS_VOLUME          0x0001  /* supports volume control */
#define MIDICAPS_LRVOLUME        0x0002  /* separate left-right volume control */
#define MIDICAPS_CACHE           0x0004  

/* MIDI output device capabilities structure */
typedef struct midiincaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
} MIDIINCAPS;
typedef MIDIINCAPS      *PMIDIINCAPS;
typedef MIDIINCAPS NEAR *NPMIDIINCAPS;
typedef MIDIINCAPS FAR  *LPMIDIINCAPS;

/* MIDI data block header */
typedef struct midihdr_tag {
    LPSTR       lpData;               /* pointer to locked data block */
    DWORD       dwBufferLength;       /* length of data in data block */
    DWORD       dwBytesRecorded;      /* used for input only */
    DWORD       dwUser;               /* for client's use */
    DWORD       dwFlags;              /* assorted flags (see defines) */
    struct midihdr_tag far *lpNext;   /* reserved for driver */
    DWORD       reserved;             /* reserved for driver */
} MIDIHDR;
typedef MIDIHDR       *PMIDIHDR;
typedef MIDIHDR NEAR *NPMIDIHDR;
typedef MIDIHDR FAR  *LPMIDIHDR;

/* flags for dwFlags field of MIDIHDR structure */
#define MHDR_DONE       0x00000001       /* done bit */
#define MHDR_PREPARED   0x00000002       /* set if header prepared */
#define MHDR_INQUEUE    0x00000004       /* reserved for driver */

/* MIDI function prototypes */
UINT WINAPI midiOutGetNumDevs(void);
UINT WINAPI midiOutGetDevCaps(UINT uDeviceID,
    MIDIOUTCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI midiOutGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);
UINT WINAPI midiOutSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI midiOutGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiOutOpen(HMIDIOUT FAR* lphMidiOut, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiOutClose(HMIDIOUT hMidiOut);
UINT WINAPI midiOutPrepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutUnprepareHeader(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutShortMsg(HMIDIOUT hMidiOut, DWORD dwMsg);
UINT WINAPI midiOutLongMsg(HMIDIOUT hMidiOut,
    MIDIHDR FAR* lpMidiOutHdr, UINT uSize);
UINT WINAPI midiOutReset(HMIDIOUT hMidiOut);
UINT WINAPI midiOutCachePatches(HMIDIOUT hMidiOut,
    UINT uBank, WORD FAR* lpwPatchArray, UINT uFlags);
UINT WINAPI midiOutCacheDrumPatches(HMIDIOUT hMidiOut,
    UINT uPatch, WORD FAR* lpwKeyArray, UINT uFlags);
UINT WINAPI midiOutGetID(HMIDIOUT hMidiOut, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI midiInGetNumDevs(void);
UINT WINAPI midiInGetDevCaps(UINT uDeviceID,
    LPMIDIINCAPS lpCaps, UINT uSize);
UINT WINAPI midiInGetErrorText(UINT uError, LPSTR lpText, UINT uSize);
UINT WINAPI midiInOpen(HMIDIIN FAR* lphMidiIn, UINT uDeviceID,
    DWORD dwCallback, DWORD dwInstance, DWORD dwFlags);
UINT WINAPI midiInClose(HMIDIIN hMidiIn);
UINT WINAPI midiInPrepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInUnprepareHeader(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInAddBuffer(HMIDIIN hMidiIn,
    MIDIHDR FAR* lpMidiInHdr, UINT uSize);
UINT WINAPI midiInStart(HMIDIIN hMidiIn);
UINT WINAPI midiInStop(HMIDIIN hMidiIn);
UINT WINAPI midiInReset(HMIDIIN hMidiIn);
UINT WINAPI midiInGetID(HMIDIIN hMidiIn, UINT FAR* lpuDeviceID);

#if (WINVER >= 0x030a)
DWORD WINAPI midiInMessage(HMIDIIN hMidiIn, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOMIDI */


#ifndef MMNOAUX
/****************************************************************************

                        Auxiliary audio support

****************************************************************************/

/* device ID for aux device mapper */
#define AUX_MAPPER     (-1)

/* Auxiliary audio device capabilities structure */
typedef struct auxcaps_tag {
    UINT    wMid;                  /* manufacturer ID */
    UINT    wPid;                  /* product ID */
    VERSION vDriverVersion;        /* version of the driver */
    char    szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT    wTechnology;           /* type of device */
    DWORD   dwSupport;             /* functionality supported by driver */
} AUXCAPS;
typedef AUXCAPS       *PAUXCAPS;
typedef AUXCAPS NEAR *NPAUXCAPS;
typedef AUXCAPS FAR  *LPAUXCAPS;

/* flags for wTechnology field in AUXCAPS structure */
#define AUXCAPS_CDAUDIO    1       /* audio from internal CD-ROM drive */
#define AUXCAPS_AUXIN      2       /* audio from auxiliary input jacks */

/* flags for dwSupport field in AUXCAPS structure */
#define AUXCAPS_VOLUME          0x0001  /* supports volume control */
#define AUXCAPS_LRVOLUME        0x0002  /* separate left-right volume control */

/* auxiliary audio function prototypes */
UINT WINAPI auxGetNumDevs(void);
UINT WINAPI auxGetDevCaps(UINT uDeviceID, AUXCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI auxSetVolume(UINT uDeviceID, DWORD dwVolume);
UINT WINAPI auxGetVolume(UINT uDeviceID, DWORD FAR* lpdwVolume);

#if (WINVER >= 0x030a)
DWORD WINAPI auxOutMessage(UINT uDeviceID, UINT uMessage, DWORD dw1, DWORD dw2);
#endif /* ifdef WINVER >= 0x030a */

#endif  /* ifndef MMNOAUX */


#ifndef MMNOTIMER
/****************************************************************************

                            Timer support

****************************************************************************/

/* timer error return values */
#define TIMERR_NOERROR        (0)                  /* no error */
#define TIMERR_NOCANDO        (TIMERR_BASE+1)      /* request not completed */
#define TIMERR_STRUCT         (TIMERR_BASE+33)     /* time struct size */

/* timer data types */
typedef void (CALLBACK TIMECALLBACK) (UINT uTimerID, UINT uMessage, DWORD dwUser, DWORD dw1, DWORD dw2);

typedef TIMECALLBACK FAR *LPTIMECALLBACK;

/* flags for wFlags parameter of timeSetEvent() function */
#define TIME_ONESHOT    0   /* program timer for single event */
#define TIME_PERIODIC   1   /* program for continuous periodic event */

/* timer device capabilities data structure */
typedef struct timecaps_tag {
    UINT    wPeriodMin;     /* minimum period supported  */
    UINT    wPeriodMax;     /* maximum period supported  */
    } TIMECAPS;
typedef TIMECAPS       *PTIMECAPS;
typedef TIMECAPS NEAR *NPTIMECAPS;
typedef TIMECAPS FAR  *LPTIMECAPS;

/* timer function prototypes */
UINT WINAPI timeGetSystemTime(MMTIME FAR* lpTime, UINT uSize);
DWORD WINAPI timeGetTime(void);
UINT WINAPI timeSetEvent(UINT uDelay, UINT uResolution,
    LPTIMECALLBACK lpFunction, DWORD dwUser, UINT uFlags);
UINT WINAPI timeKillEvent(UINT uTimerID);
UINT WINAPI timeGetDevCaps(TIMECAPS FAR* lpTimeCaps, UINT uSize);
UINT WINAPI timeBeginPeriod(UINT uPeriod);
UINT WINAPI timeEndPeriod(UINT uPeriod);

#endif  /* ifndef MMNOTIMER */


#ifndef MMNOJOY
/****************************************************************************

                            Joystick support

****************************************************************************/

/* joystick error return values */
#define JOYERR_NOERROR        (0)                  /* no error */
#define JOYERR_PARMS          (JOYERR_BASE+5)      /* bad parameters */
#define JOYERR_NOCANDO        (JOYERR_BASE+6)      /* request not completed */
#define JOYERR_UNPLUGGED      (JOYERR_BASE+7)      /* joystick is unplugged */

/* constants used with JOYINFO structure and MM_JOY* messages */
#define JOY_BUTTON1         0x0001
#define JOY_BUTTON2         0x0002
#define JOY_BUTTON3         0x0004
#define JOY_BUTTON4         0x0008
#define JOY_BUTTON1CHG      0x0100
#define JOY_BUTTON2CHG      0x0200
#define JOY_BUTTON3CHG      0x0400
#define JOY_BUTTON4CHG      0x0800

/* joystick ID constants */
#define JOYSTICKID1         0
#define JOYSTICKID2         1

/* joystick device capabilities data structure */
typedef struct joycaps_tag {
    UINT wMid;                  /* manufacturer ID */
    UINT wPid;                  /* product ID */
    char szPname[MAXPNAMELEN];  /* product name (NULL terminated string) */
    UINT wXmin;                 /* minimum x position value */
    UINT wXmax;                 /* maximum x position value */
    UINT wYmin;                 /* minimum y position value */
    UINT wYmax;                 /* maximum y position value */
    UINT wZmin;                 /* minimum z position value */
    UINT wZmax;                 /* maximum z position value */
    UINT wNumButtons;           /* number of buttons */
    UINT wPeriodMin;            /* minimum message period when captured */
    UINT wPeriodMax;            /* maximum message period when captured */
    } JOYCAPS;
typedef JOYCAPS       *PJOYCAPS;
typedef JOYCAPS NEAR *NPJOYCAPS;
typedef JOYCAPS FAR  *LPJOYCAPS;

/* joystick information data structure */
typedef struct joyinfo_tag {
    UINT wXpos;                 /* x position */
    UINT wYpos;                 /* y position */
    UINT wZpos;                 /* z position */
    UINT wButtons;              /* button states */
    } JOYINFO;
typedef JOYINFO       *PJOYINFO;
typedef JOYINFO NEAR *NPJOYINFO;
typedef JOYINFO FAR  *LPJOYINFO;

/* joystick function prototypes */
UINT WINAPI joyGetDevCaps(UINT uJoyID, JOYCAPS FAR* lpCaps, UINT uSize);
UINT WINAPI joyGetNumDevs(void);
UINT WINAPI joyGetPos(UINT uJoyID, JOYINFO FAR* lpInfo);
UINT WINAPI joyGetThreshold(UINT uJoyID, UINT FAR* lpuThreshold);
UINT WINAPI joyReleaseCapture(UINT uJoyID);
UINT WINAPI joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod,
    BOOL bChanged);
UINT WINAPI joySetThreshold(UINT uJoyID, UINT uThreshold);

#endif  /* ifndef MMNOJOY */


#ifndef MMNOMMIO
/****************************************************************************

                        Multimedia File I/O support

****************************************************************************/

/* MMIO error return values */
#define MMIOERR_BASE            256
#define MMIOERR_FILENOTFOUND    (MMIOERR_BASE + 1)  /* file not found */
#define MMIOERR_OUTOFMEMORY     (MMIOERR_BASE + 2)  /* out of memory */
#define MMIOERR_CANNOTOPEN      (MMIOERR_BASE + 3)  /* cannot open */
#define MMIOERR_CANNOTCLOSE     (MMIOERR_BASE + 4)  /* cannot close */
#define MMIOERR_CANNOTREAD      (MMIOERR_BASE + 5)  /* cannot read */
#define MMIOERR_CANNOTWRITE     (MMIOERR_BASE + 6)  /* cannot write */
#define MMIOERR_CANNOTSEEK      (MMIOERR_BASE + 7)  /* cannot seek */
#define MMIOERR_CANNOTEXPAND    (MMIOERR_BASE + 8)  /* cannot expand file */
#define MMIOERR_CHUNKNOTFOUND   (MMIOERR_BASE + 9)  /* chunk not found */
#define MMIOERR_UNBUFFERED      (MMIOERR_BASE + 10) /* file is unbuffered */

/* MMIO constants */
#define CFSEPCHAR       '+'             /* compound file name separator char. */

/* MMIO data types */
typedef DWORD           FOURCC;         /* a four character code */
typedef char _huge *    HPSTR;          /* a huge version of LPSTR */
DECLARE_HANDLE(HMMIO);                  /* a handle to an open file */
typedef LRESULT (CALLBACK MMIOPROC)(LPSTR lpmmioinfo, UINT uMessage,
            LPARAM lParam1, LPARAM lParam2);
typedef MMIOPROC FAR *LPMMIOPROC;

/* general MMIO information data structure */
typedef struct _MMIOINFO
{
        /* general fields */
        DWORD           dwFlags;        /* general status flags */
        FOURCC          fccIOProc;      /* pointer to I/O procedure */
        LPMMIOPROC      pIOProc;        /* pointer to I/O procedure */
        UINT            wErrorRet;      /* place for error to be returned */
        HTASK           htask;          /* alternate local task */

        /* fields maintained by MMIO functions during buffered I/O */
        LONG            cchBuffer;      /* size of I/O buffer (or 0L) */
        HPSTR           pchBuffer;      /* start of I/O buffer (or NULL) */
        HPSTR           pchNext;        /* pointer to next byte to read/write */
        HPSTR           pchEndRead;     /* pointer to last valid byte to read */
        HPSTR           pchEndWrite;    /* pointer to last byte to write */
        LONG            lBufOffset;     /* disk offset of start of buffer */

        /* fields maintained by I/O procedure */
        LONG            lDiskOffset;    /* disk offset of next read or write */
        DWORD           adwInfo[3];     /* data specific to type of MMIOPROC */

        /* other fields maintained by MMIO */
        DWORD           dwReserved1;    /* reserved for MMIO use */
        DWORD           dwReserved2;    /* reserved for MMIO use */
        HMMIO           hmmio;          /* handle to open file */
} MMIOINFO;
typedef MMIOINFO       *PMMIOINFO;
typedef MMIOINFO NEAR *NPMMIOINFO;
typedef MMIOINFO FAR  *LPMMIOINFO;

/* RIFF chunk information data structure */
typedef struct _MMCKINFO
{
        FOURCC          ckid;           /* chunk ID */
        DWORD           cksize;         /* chunk size */
        FOURCC          fccType;        /* form type or list type */
        DWORD           dwDataOffset;   /* offset of data portion of chunk */
        DWORD           dwFlags;        /* flags used by MMIO functions */
} MMCKINFO;
typedef MMCKINFO       *PMMCKINFO;
typedef MMCKINFO NEAR *NPMMCKINFO;
typedef MMCKINFO FAR  *LPMMCKINFO;

/* bit field masks */
#define MMIO_RWMODE     0x00000003      /* open file for reading/writing/both */
#define MMIO_SHAREMODE  0x00000070      /* file sharing mode number */

/* constants for dwFlags field of MMIOINFO */
#define MMIO_CREATE     0x00001000      /* create new file (or truncate file) */
#define MMIO_PARSE      0x00000100      /* parse new file returning path */
#define MMIO_DELETE     0x00000200      /* create new file (or truncate file) */
#define MMIO_EXIST      0x00004000      /* checks for existence of file */
#define MMIO_ALLOCBUF   0x00010000      /* mmioOpen() should allocate a buffer */
#define MMIO_GETTEMP    0x00020000      /* mmioOpen() should retrieve temp name */

#define MMIO_DIRTY      0x10000000      /* I/O buffer is dirty */


/* read/write mode numbers (bit field MMIO_RWMODE) */
#define MMIO_READ       0x00000000      /* open file for reading only */
#define MMIO_WRITE      0x00000001      /* open file for writing only */
#define MMIO_READWRITE  0x00000002      /* open file for reading and writing */

/* share mode numbers (bit field MMIO_SHAREMODE) */
#define MMIO_COMPAT     0x00000000      /* compatibility mode */
#define MMIO_EXCLUSIVE  0x00000010      /* exclusive-access mode */
#define MMIO_DENYWRITE  0x00000020      /* deny writing to other processes */
#define MMIO_DENYREAD   0x00000030      /* deny reading to other processes */
#define MMIO_DENYNONE   0x00000040      /* deny nothing to other processes */

/* various MMIO flags */
#define MMIO_FHOPEN             0x0010  /* mmioClose: keep file handle open */
#define MMIO_EMPTYBUF           0x0010  /* mmioFlush: empty the I/O buffer */
#define MMIO_TOUPPER            0x0010  /* mmioStringToFOURCC: to u-case */
#define MMIO_INSTALLPROC    0x00010000  /* mmioInstallIOProc: install MMIOProc */
#define MMIO_GLOBALPROC     0x10000000  /* mmioInstallIOProc: install globally */
#define MMIO_REMOVEPROC     0x00020000  /* mmioInstallIOProc: remove MMIOProc */
#define MMIO_FINDPROC       0x00040000  /* mmioInstallIOProc: find an MMIOProc */
#define MMIO_FINDCHUNK          0x0010  /* mmioDescend: find a chunk by ID */
#define MMIO_FINDRIFF           0x0020  /* mmioDescend: find a LIST chunk */
#define MMIO_FINDLIST           0x0040  /* mmioDescend: find a RIFF chunk */
#define MMIO_CREATERIFF         0x0020  /* mmioCreateChunk: make a LIST chunk */
#define MMIO_CREATELIST         0x0040  /* mmioCreateChunk: make a RIFF chunk */


/* message numbers for MMIOPROC I/O procedure functions */
#define MMIOM_READ      MMIO_READ       /* read */
#define MMIOM_WRITE    MMIO_WRITE       /* write */
#define MMIOM_SEEK              2       /* seek to a new position in file */
#define MMIOM_OPEN              3       /* open file */
#define MMIOM_CLOSE             4       /* close file */
#define MMIOM_WRITEFLUSH        5       /* write and flush */

#if (WINVER >= 0x030a)
#define MMIOM_RENAME            6       /* rename specified file */
#endif /* ifdef WINVER >= 0x030a */

#define MMIOM_USER         0x8000       /* beginning of user-defined messages */

/* standard four character codes */
#define FOURCC_RIFF     mmioFOURCC('R', 'I', 'F', 'F')
#define FOURCC_LIST     mmioFOURCC('L', 'I', 'S', 'T')

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_DOS      mmioFOURCC('D', 'O', 'S', ' ')
#define FOURCC_MEM      mmioFOURCC('M', 'E', 'M', ' ')

/* flags for mmioSeek() */
#ifndef SEEK_SET
#define SEEK_SET        0               /* seek to an absolute position */
#define SEEK_CUR        1               /* seek relative to current position */
#define SEEK_END        2               /* seek relative to end of file */
#endif  /* ifndef SEEK_SET */

/* other constants */
#define MMIO_DEFAULTBUFFER      8192    /* default buffer size */

/* MMIO macros */
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

/* MMIO function prototypes */
FOURCC WINAPI mmioStringToFOURCC(LPCSTR sz, UINT uFlags);
LPMMIOPROC WINAPI mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc,
    DWORD dwFlags);
HMMIO WINAPI mmioOpen(LPSTR szFileName, MMIOINFO FAR* lpmmioinfo,
    DWORD dwOpenFlags);

#if (WINVER >= 0x030a)
UINT WINAPI mmioRename(LPCSTR szFileName, LPCSTR szNewFileName,
     MMIOINFO FAR* lpmmioinfo, DWORD dwRenameFlags);
#endif /* ifdef WINVER >= 0x030a */

UINT WINAPI mmioClose(HMMIO hmmio, UINT uFlags);
LONG WINAPI mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);
LONG WINAPI mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch);
LONG WINAPI mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);
UINT WINAPI mmioGetInfo(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT uFlags);
UINT WINAPI mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer,
    UINT uFlags);
UINT WINAPI mmioFlush(HMMIO hmmio, UINT uFlags);
UINT WINAPI mmioAdvance(HMMIO hmmio, MMIOINFO FAR* lpmmioinfo, UINT uFlags);
LRESULT WINAPI mmioSendMessage(HMMIO hmmio, UINT uMessage,
    LPARAM lParam1, LPARAM lParam2);
UINT WINAPI mmioDescend(HMMIO hmmio, MMCKINFO FAR* lpck,
    const MMCKINFO FAR* lpckParent, UINT uFlags);
UINT WINAPI mmioAscend(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);
UINT WINAPI mmioCreateChunk(HMMIO hmmio, MMCKINFO FAR* lpck, UINT uFlags);

#endif  /* ifndef MMNOMMIO */


#ifndef MMNOMCI
/****************************************************************************

                            MCI support

****************************************************************************/

typedef UINT (CALLBACK *YIELDPROC) (UINT uDeviceID, DWORD dwYieldData);

/* MCI function prototypes */
DWORD WINAPI mciSendCommand (UINT uDeviceID, UINT uMessage,
    DWORD dwParam1, DWORD dwParam2);
DWORD WINAPI mciSendString (LPCSTR lpstrCommand,
    LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);
UINT WINAPI mciGetDeviceID (LPCSTR lpstrName);
UINT WINAPI mciGetDeviceIDFromElementID (DWORD dwElementID,
    LPCSTR lpstrType);
BOOL WINAPI mciGetErrorString (DWORD wError, LPSTR lpstrBuffer,
    UINT uLength);
BOOL WINAPI mciSetYieldProc (UINT uDeviceID, YIELDPROC fpYieldProc,
    DWORD dwYieldData);

#if (WINVER >= 0x030a)
HTASK WINAPI mciGetCreatorTask(UINT uDeviceID);
YIELDPROC WINAPI mciGetYieldProc (UINT uDeviceID, DWORD FAR* lpdwYieldData);
#endif /* ifdef WINVER >= 0x030a */

#if (WINVER < 0x030a)
BOOL WINAPI mciExecute (LPCSTR lpstrCommand);
#endif /* ifdef WINVER < 0x030a */

/* MCI error return values */
#define MCIERR_INVALID_DEVICE_ID        (MCIERR_BASE + 1)
#define MCIERR_UNRECOGNIZED_KEYWORD     (MCIERR_BASE + 3)
#define MCIERR_UNRECOGNIZED_COMMAND     (MCIERR_BASE + 5)
#define MCIERR_HARDWARE                 (MCIERR_BASE + 6)
#define MCIERR_INVALID_DEVICE_NAME      (MCIERR_BASE + 7)
#define MCIERR_OUT_OF_MEMORY            (MCIERR_BASE + 8)
#define MCIERR_DEVICE_OPEN              (MCIERR_BASE + 9)
#define MCIERR_CANNOT_LOAD_DRIVER       (MCIERR_BASE + 10)
#define MCIERR_MISSING_COMMAND_STRING   (MCIERR_BASE + 11)
#define MCIERR_PARAM_OVERFLOW           (MCIERR_BASE + 12)
#define MCIERR_MISSING_STRING_ARGUMENT  (MCIERR_BASE + 13)
#define MCIERR_BAD_INTEGER              (MCIERR_BASE + 14)
#define MCIERR_PARSER_INTERNAL          (MCIERR_BASE + 15)
#define MCIERR_DRIVER_INTERNAL          (MCIERR_BASE + 16)
#define MCIERR_MISSING_PARAMETER        (MCIERR_BASE + 17)
#define MCIERR_UNSUPPORTED_FUNCTION     (MCIERR_BASE + 18)
#define MCIERR_FILE_NOT_FOUND           (MCIERR_BASE + 19)
#define MCIERR_DEVICE_NOT_READY         (MCIERR_BASE + 20)
#define MCIERR_INTERNAL                 (MCIERR_BASE + 21)
#define MCIERR_DRIVER                   (MCIERR_BASE + 22)
#define MCIERR_CANNOT_USE_ALL           (MCIERR_BASE + 23)
#define MCIERR_MULTIPLE                 (MCIERR_BASE + 24)
#define MCIERR_EXTENSION_NOT_FOUND      (MCIERR_BASE + 25)
#define MCIERR_OUTOFRANGE               (MCIERR_BASE + 26)
#define MCIERR_FLAGS_NOT_COMPATIBLE     (MCIERR_BASE + 28)
#define MCIERR_FILE_NOT_SAVED           (MCIERR_BASE + 30)
#define MCIERR_DEVICE_TYPE_REQUIRED     (MCIERR_BASE + 31)
#define MCIERR_DEVICE_LOCKED            (MCIERR_BASE + 32)
#define MCIERR_DUPLICATE_ALIAS          (MCIERR_BASE + 33)
#define MCIERR_BAD_CONSTANT             (MCIERR_BASE + 34)
#define MCIERR_MUST_USE_SHAREABLE       (MCIERR_BASE + 35)
#define MCIERR_MISSING_DEVICE_NAME      (MCIERR_BASE + 36)
#define MCIERR_BAD_TIME_FORMAT          (MCIERR_BASE + 37)
#define MCIERR_NO_CLOSING_QUOTE         (MCIERR_BASE + 38)
#define MCIERR_DUPLICATE_FLAGS          (MCIERR_BASE + 39)
#define MCIERR_INVALID_FILE             (MCIERR_BASE + 40)
#define MCIERR_NULL_PARAMETER_BLOCK     (MCIERR_BASE + 41)
#define MCIERR_UNNAMED_RESOURCE         (MCIERR_BASE + 42)
#define MCIERR_NEW_REQUIRES_ALIAS       (MCIERR_BASE + 43)
#define MCIERR_NOTIFY_ON_AUTO_OPEN      (MCIERR_BASE + 44)
#define MCIERR_NO_ELEMENT_ALLOWED       (MCIERR_BASE + 45)
#define MCIERR_NONAPPLICABLE_FUNCTION   (MCIERR_BASE + 46)
#define MCIERR_ILLEGAL_FOR_AUTO_OPEN    (MCIERR_BASE + 47)
#define MCIERR_FILENAME_REQUIRED        (MCIERR_BASE + 48)
#define MCIERR_EXTRA_CHARACTERS         (MCIERR_BASE + 49)
#define MCIERR_DEVICE_NOT_INSTALLED     (MCIERR_BASE + 50)
#define MCIERR_GET_CD                   (MCIERR_BASE + 51)
#define MCIERR_SET_CD                   (MCIERR_BASE + 52)
#define MCIERR_SET_DRIVE                (MCIERR_BASE + 53)
#define MCIERR_DEVICE_LENGTH            (MCIERR_BASE + 54)
#define MCIERR_DEVICE_ORD_LENGTH        (MCIERR_BASE + 55)
#define MCIERR_NO_INTEGER               (MCIERR_BASE + 56)

#define MCIERR_WAVE_OUTPUTSINUSE        (MCIERR_BASE + 64)
#define MCIERR_WAVE_SETOUTPUTINUSE      (MCIERR_BASE + 65)
#define MCIERR_WAVE_INPUTSINUSE         (MCIERR_BASE + 66)
#define MCIERR_WAVE_SETINPUTINUSE       (MCIERR_BASE + 67)
#define MCIERR_WAVE_OUTPUTUNSPECIFIED   (MCIERR_BASE + 68)
#define MCIERR_WAVE_INPUTUNSPECIFIED    (MCIERR_BASE + 69)
#define MCIERR_WAVE_OUTPUTSUNSUITABLE   (MCIERR_BASE + 70)
#define MCIERR_WAVE_SETOUTPUTUNSUITABLE (MCIERR_BASE + 71)
#define MCIERR_WAVE_INPUTSUNSUITABLE    (MCIERR_BASE + 72)
#define MCIERR_WAVE_SETINPUTUNSUITABLE  (MCIERR_BASE + 73)

#define MCIERR_SEQ_DIV_INCOMPATIBLE     (MCIERR_BASE + 80)
#define MCIERR_SEQ_PORT_INUSE           (MCIERR_BASE + 81)
#define MCIERR_SEQ_PORT_NONEXISTENT     (MCIERR_BASE + 82)
#define MCIERR_SEQ_PORT_MAPNODEVICE     (MCIERR_BASE + 83)
#define MCIERR_SEQ_PORT_MISCERROR       (MCIERR_BASE + 84)
#define MCIERR_SEQ_TIMER                (MCIERR_BASE + 85)
#define MCIERR_SEQ_PORTUNSPECIFIED      (MCIERR_BASE + 86)
#define MCIERR_SEQ_NOMIDIPRESENT        (MCIERR_BASE + 87)

#define MCIERR_NO_WINDOW                (MCIERR_BASE + 90)
#define MCIERR_CREATEWINDOW             (MCIERR_BASE + 91)
#define MCIERR_FILE_READ                (MCIERR_BASE + 92)
#define MCIERR_FILE_WRITE               (MCIERR_BASE + 93)

/* all custom device driver errors must be >= than this value */
#define MCIERR_CUSTOM_DRIVER_BASE       (MCIERR_BASE + 256)

/* MCI command message identifiers */
#define MCI_OPEN                        0x0803
#define MCI_CLOSE                       0x0804
#define MCI_ESCAPE                      0x0805
#define MCI_PLAY                        0x0806
#define MCI_SEEK                        0x0807
#define MCI_STOP                        0x0808
#define MCI_PAUSE                       0x0809
#define MCI_INFO                        0x080A
#define MCI_GETDEVCAPS                  0x080B
#define MCI_SPIN                        0x080C
#define MCI_SET                         0x080D
#define MCI_STEP                        0x080E
#define MCI_RECORD                      0x080F
#define MCI_SYSINFO                     0x0810
#define MCI_BREAK                       0x0811
#define MCI_SOUND                       0x0812
#define MCI_SAVE                        0x0813
#define MCI_STATUS                      0x0814
#define MCI_CUE                         0x0830
#define MCI_REALIZE                     0x0840
#define MCI_WINDOW                      0x0841
#define MCI_PUT                         0x0842
#define MCI_WHERE                       0x0843
#define MCI_FREEZE                      0x0844
#define MCI_UNFREEZE                    0x0845
#define MCI_LOAD                        0x0850
#define MCI_CUT                         0x0851
#define MCI_COPY                        0x0852
#define MCI_PASTE                       0x0853
#define MCI_UPDATE                      0x0854
#define MCI_RESUME                      0x0855
#define MCI_DELETE                      0x0856

/* all custom MCI command messages must be >= than this value */
#define MCI_USER_MESSAGES               (0x400 + DRV_MCI_FIRST)


/* device ID for "all devices" */
#define MCI_ALL_DEVICE_ID               0xFFFF

/* constants for predefined MCI device types */
#define MCI_DEVTYPE_VCR                 (MCI_STRING_OFFSET + 1)
#define MCI_DEVTYPE_VIDEODISC           (MCI_STRING_OFFSET + 2)
#define MCI_DEVTYPE_OVERLAY             (MCI_STRING_OFFSET + 3)
#define MCI_DEVTYPE_CD_AUDIO            (MCI_STRING_OFFSET + 4)
#define MCI_DEVTYPE_DAT                 (MCI_STRING_OFFSET + 5)
#define MCI_DEVTYPE_SCANNER             (MCI_STRING_OFFSET + 6)
#define MCI_DEVTYPE_ANIMATION           (MCI_STRING_OFFSET + 7)
#define MCI_DEVTYPE_DIGITAL_VIDEO       (MCI_STRING_OFFSET + 8)
#define MCI_DEVTYPE_OTHER               (MCI_STRING_OFFSET + 9)
#define MCI_DEVTYPE_WAVEFORM_AUDIO      (MCI_STRING_OFFSET + 10)
#define MCI_DEVTYPE_SEQUENCER           (MCI_STRING_OFFSET + 11)

#define MCI_DEVTYPE_FIRST               MCI_DEVTYPE_VCR
#define MCI_DEVTYPE_LAST                MCI_DEVTYPE_SEQUENCER

/* return values for 'status mode' command */
#define MCI_MODE_NOT_READY              (MCI_STRING_OFFSET + 12)
#define MCI_MODE_STOP                   (MCI_STRING_OFFSET + 13)
#define MCI_MODE_PLAY                   (MCI_STRING_OFFSET + 14)
#define MCI_MODE_RECORD                 (MCI_STRING_OFFSET + 15)
#define MCI_MODE_SEEK                   (MCI_STRING_OFFSET + 16)
#define MCI_MODE_PAUSE                  (MCI_STRING_OFFSET + 17)
#define MCI_MODE_OPEN                   (MCI_STRING_OFFSET + 18)

/* constants used in 'set time format' and 'status time format' commands */
#define MCI_FORMAT_MILLISECONDS         0
#define MCI_FORMAT_HMS                  1
#define MCI_FORMAT_MSF                  2
#define MCI_FORMAT_FRAMES               3
#define MCI_FORMAT_SMPTE_24             4
#define MCI_FORMAT_SMPTE_25             5
#define MCI_FORMAT_SMPTE_30             6
#define MCI_FORMAT_SMPTE_30DROP         7
#define MCI_FORMAT_BYTES                8
#define MCI_FORMAT_SAMPLES              9
#define MCI_FORMAT_TMSF                 10

/* MCI time format conversion macros */
#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                                  ((WORD)(s)<<8)) | \
                                                 (((DWORD)(BYTE)(f))<<16)))

#define MCI_TMSF_TRACK(tmsf)            ((BYTE)(tmsf))
#define MCI_TMSF_MINUTE(tmsf)           ((BYTE)(((WORD)(tmsf)) >> 8))
#define MCI_TMSF_SECOND(tmsf)           ((BYTE)((tmsf)>>16))
#define MCI_TMSF_FRAME(tmsf)            ((BYTE)((tmsf)>>24))

#define MCI_MAKE_TMSF(t, m, s, f)       ((DWORD)(((BYTE)(t) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s) | \
                                                   ((WORD)(f)<<8))<<16)))

#define MCI_HMS_HOUR(hms)               ((BYTE)(hms))
#define MCI_HMS_MINUTE(hms)             ((BYTE)(((WORD)(hms)) >> 8))
#define MCI_HMS_SECOND(hms)             ((BYTE)((hms)>>16))

#define MCI_MAKE_HMS(h, m, s)           ((DWORD)(((BYTE)(h) | \
                                                  ((WORD)(m)<<8)) | \
                                                 (((DWORD)(BYTE)(s))<<16)))


/* flags for wParam of MM_MCINOTIFY message */
#define MCI_NOTIFY_SUCCESSFUL           0x0001
#define MCI_NOTIFY_SUPERSEDED           0x0002
#define MCI_NOTIFY_ABORTED              0x0004
#define MCI_NOTIFY_FAILURE              0x0008


/* common flags for dwFlags parameter of MCI command messages */
#define MCI_NOTIFY                      0x00000001L
#define MCI_WAIT                        0x00000002L
#define MCI_FROM                        0x00000004L
#define MCI_TO                          0x00000008L
#define MCI_TRACK                       0x00000010L

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OPEN_SHAREABLE              0x00000100L
#define MCI_OPEN_ELEMENT                0x00000200L
#define MCI_OPEN_ALIAS                  0x00000400L
#define MCI_OPEN_ELEMENT_ID             0x00000800L
#define MCI_OPEN_TYPE_ID                0x00001000L
#define MCI_OPEN_TYPE                   0x00002000L

/* flags for dwFlags parameter of MCI_SEEK command message */
#define MCI_SEEK_TO_START               0x00000100L
#define MCI_SEEK_TO_END                 0x00000200L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_STATUS_ITEM                 0x00000100L
#define MCI_STATUS_START                0x00000200L

/* flags for dwItem field of the MCI_STATUS_PARMS parameter block */
#define MCI_STATUS_LENGTH               0x00000001L
#define MCI_STATUS_POSITION             0x00000002L
#define MCI_STATUS_NUMBER_OF_TRACKS     0x00000003L
#define MCI_STATUS_MODE                 0x00000004L
#define MCI_STATUS_MEDIA_PRESENT        0x00000005L
#define MCI_STATUS_TIME_FORMAT          0x00000006L
#define MCI_STATUS_READY                0x00000007L
#define MCI_STATUS_CURRENT_TRACK        0x00000008L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_INFO_PRODUCT                0x00000100L
#define MCI_INFO_FILE                   0x00000200L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_GETDEVCAPS_ITEM             0x00000100L

/* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_GETDEVCAPS_CAN_RECORD       0x00000001L
#define MCI_GETDEVCAPS_HAS_AUDIO        0x00000002L
#define MCI_GETDEVCAPS_HAS_VIDEO        0x00000003L
#define MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
#define MCI_GETDEVCAPS_USES_FILES       0x00000005L
#define MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L
#define MCI_GETDEVCAPS_CAN_EJECT        0x00000007L
#define MCI_GETDEVCAPS_CAN_PLAY         0x00000008L
#define MCI_GETDEVCAPS_CAN_SAVE         0x00000009L

/* flags for dwFlags parameter of MCI_SYSINFO command message */
#define MCI_SYSINFO_QUANTITY            0x00000100L
#define MCI_SYSINFO_OPEN                0x00000200L
#define MCI_SYSINFO_NAME                0x00000400L
#define MCI_SYSINFO_INSTALLNAME         0x00000800L

/* flags for dwFlags parameter of MCI_SET command message */
#define MCI_SET_DOOR_OPEN               0x00000100L
#define MCI_SET_DOOR_CLOSED             0x00000200L
#define MCI_SET_TIME_FORMAT             0x00000400L
#define MCI_SET_AUDIO                   0x00000800L
#define MCI_SET_VIDEO                   0x00001000L
#define MCI_SET_ON                      0x00002000L
#define MCI_SET_OFF                     0x00004000L

/* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS */
#define MCI_SET_AUDIO_ALL               0x00000000L
#define MCI_SET_AUDIO_LEFT              0x00000001L
#define MCI_SET_AUDIO_RIGHT             0x00000002L

/* flags for dwFlags parameter of MCI_BREAK command message */
#define MCI_BREAK_KEY                   0x00000100L
#define MCI_BREAK_HWND                  0x00000200L
#define MCI_BREAK_OFF                   0x00000400L

/* flags for dwFlags parameter of MCI_RECORD command message */
#define MCI_RECORD_INSERT               0x00000100L
#define MCI_RECORD_OVERWRITE            0x00000200L

/* flags for dwFlags parameter of MCI_SOUND command message */
#define MCI_SOUND_NAME                  0x00000100L

/* flags for dwFlags parameter of MCI_SAVE command message */
#define MCI_SAVE_FILE                   0x00000100L

/* flags for dwFlags parameter of MCI_LOAD command message */
#define MCI_LOAD_FILE                   0x00000100L

/* generic parameter block for MCI command messages with no special parameters */
typedef struct tagMCI_GENERIC_PARMS {
    DWORD   dwCallback;
} MCI_GENERIC_PARMS;
typedef MCI_GENERIC_PARMS FAR *LPMCI_GENERIC_PARMS;

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
} MCI_OPEN_PARMS;
typedef MCI_OPEN_PARMS FAR *LPMCI_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_PLAY_PARMS;
typedef MCI_PLAY_PARMS FAR *LPMCI_PLAY_PARMS;

/* parameter block for MCI_SEEK command message */
typedef struct tagMCI_SEEK_PARMS {
    DWORD   dwCallback;
    DWORD   dwTo;
} MCI_SEEK_PARMS;
typedef MCI_SEEK_PARMS FAR *LPMCI_SEEK_PARMS;

/* parameter block for MCI_STATUS command message */
typedef struct tagMCI_STATUS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
    DWORD   dwTrack;
} MCI_STATUS_PARMS;
typedef MCI_STATUS_PARMS FAR * LPMCI_STATUS_PARMS;

/* parameter block for MCI_INFO command message */
typedef struct tagMCI_INFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
} MCI_INFO_PARMS;
typedef MCI_INFO_PARMS FAR * LPMCI_INFO_PARMS;

/* parameter block for MCI_GETDEVCAPS command message */
typedef struct tagMCI_GETDEVCAPS_PARMS {
    DWORD   dwCallback;
    DWORD   dwReturn;
    DWORD   dwItem;
} MCI_GETDEVCAPS_PARMS;
typedef MCI_GETDEVCAPS_PARMS FAR * LPMCI_GETDEVCAPS_PARMS;

/* parameter block for MCI_SYSINFO command message */
typedef struct tagMCI_SYSINFO_PARMS {
    DWORD   dwCallback;
    LPSTR   lpstrReturn;
    DWORD   dwRetSize;
    DWORD   dwNumber;
    UINT    wDeviceType;
    UINT    wReserved0;
} MCI_SYSINFO_PARMS;
typedef MCI_SYSINFO_PARMS FAR * LPMCI_SYSINFO_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
} MCI_SET_PARMS;
typedef MCI_SET_PARMS FAR *LPMCI_SET_PARMS;

/* parameter block for MCI_BREAK command message */
typedef struct tagMCI_BREAK_PARMS {
    DWORD   dwCallback;
    int     nVirtKey;
    UINT    wReserved0;
    HWND    hwndBreak;
    UINT    wReserved1;
} MCI_BREAK_PARMS;
typedef MCI_BREAK_PARMS FAR * LPMCI_BREAK_PARMS;

/* parameter block for MCI_SOUND command message */
typedef struct tagMCI_SOUND_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrSoundName;
} MCI_SOUND_PARMS;
typedef MCI_SOUND_PARMS FAR * LPMCI_SOUND_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_SAVE_PARMS;
typedef MCI_SAVE_PARMS FAR * LPMCI_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
} MCI_LOAD_PARMS;
typedef MCI_LOAD_PARMS FAR * LPMCI_LOAD_PARMS;

/* parameter block for MCI_RECORD command message */
typedef struct tagMCI_RECORD_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_RECORD_PARMS;
typedef MCI_RECORD_PARMS FAR *LPMCI_RECORD_PARMS;


/* MCI extensions for videodisc devices */

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) */
#define MCI_VD_MODE_PARK                (MCI_VD_OFFSET + 1)

/* flag for dwReturn field of MCI_STATUS_PARMS */
/* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) */
#define MCI_VD_MEDIA_CLV                (MCI_VD_OFFSET + 2)
#define MCI_VD_MEDIA_CAV                (MCI_VD_OFFSET + 3)
#define MCI_VD_MEDIA_OTHER              (MCI_VD_OFFSET + 4)

#define MCI_VD_FORMAT_TRACK             0x4001

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_VD_PLAY_REVERSE             0x00010000L
#define MCI_VD_PLAY_FAST                0x00020000L
#define MCI_VD_PLAY_SPEED               0x00040000L
#define MCI_VD_PLAY_SCAN                0x00080000L
#define MCI_VD_PLAY_SLOW                0x00100000L

/* flag for dwFlags parameter of MCI_SEEK command message */
#define MCI_VD_SEEK_REVERSE             0x00010000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_VD_STATUS_SPEED             0x00004002L
#define MCI_VD_STATUS_FORWARD           0x00004003L
#define MCI_VD_STATUS_MEDIA_TYPE        0x00004004L
#define MCI_VD_STATUS_SIDE              0x00004005L
#define MCI_VD_STATUS_DISC_SIZE         0x00004006L

/* flags for dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_VD_GETDEVCAPS_CLV           0x00010000L
#define MCI_VD_GETDEVCAPS_CAV           0x00020000L

#define MCI_VD_SPIN_UP                  0x00010000L
#define MCI_VD_SPIN_DOWN                0x00020000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_VD_GETDEVCAPS_CAN_REVERSE   0x00004002L
#define MCI_VD_GETDEVCAPS_FAST_RATE     0x00004003L
#define MCI_VD_GETDEVCAPS_SLOW_RATE     0x00004004L
#define MCI_VD_GETDEVCAPS_NORMAL_RATE   0x00004005L

/* flags for the dwFlags parameter of MCI_STEP command message */
#define MCI_VD_STEP_FRAMES              0x00010000L
#define MCI_VD_STEP_REVERSE             0x00020000L

/* flag for the MCI_ESCAPE command message */
#define MCI_VD_ESCAPE_STRING            0x00000100L

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_VD_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
    } MCI_VD_PLAY_PARMS;
typedef MCI_VD_PLAY_PARMS FAR *LPMCI_VD_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_VD_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_VD_STEP_PARMS;
typedef MCI_VD_STEP_PARMS FAR *LPMCI_VD_STEP_PARMS;

/* parameter block for MCI_ESCAPE command message */
typedef struct tagMCI_VD_ESCAPE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpstrCommand;
} MCI_VD_ESCAPE_PARMS;
typedef MCI_VD_ESCAPE_PARMS FAR *LPMCI_VD_ESCAPE_PARMS;


/* MCI extensions for waveform audio devices */

/* flags for the dwFlags parameter of MCI_OPEN command message */
#define MCI_WAVE_OPEN_BUFFER            0x00010000L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_FORMATTAG          0x00010000L
#define MCI_WAVE_SET_CHANNELS           0x00020000L
#define MCI_WAVE_SET_SAMPLESPERSEC      0x00040000L
#define MCI_WAVE_SET_AVGBYTESPERSEC     0x00080000L
#define MCI_WAVE_SET_BLOCKALIGN         0x00100000L
#define MCI_WAVE_SET_BITSPERSAMPLE      0x00200000L

/* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages */
#define MCI_WAVE_INPUT                  0x00400000L
#define MCI_WAVE_OUTPUT                 0x00800000L

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_WAVE_STATUS_FORMATTAG       0x00004001L
#define MCI_WAVE_STATUS_CHANNELS        0x00004002L
#define MCI_WAVE_STATUS_SAMPLESPERSEC   0x00004003L
#define MCI_WAVE_STATUS_AVGBYTESPERSEC  0x00004004L
#define MCI_WAVE_STATUS_BLOCKALIGN      0x00004005L
#define MCI_WAVE_STATUS_BITSPERSAMPLE   0x00004006L
#define MCI_WAVE_STATUS_LEVEL           0x00004007L

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_WAVE_SET_ANYINPUT           0x04000000L
#define MCI_WAVE_SET_ANYOUTPUT          0x08000000L

/* flags for the dwFlags parameter of MCI_GETDEVCAPS command message */
#define MCI_WAVE_GETDEVCAPS_INPUTS      0x00004001L
#define MCI_WAVE_GETDEVCAPS_OUTPUTS     0x00004002L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_WAVE_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwBufferSeconds;
} MCI_WAVE_OPEN_PARMS;
typedef MCI_WAVE_OPEN_PARMS FAR *LPMCI_WAVE_OPEN_PARMS;

/* parameter block for MCI_DELETE command message */
typedef struct tagMCI_WAVE_DELETE_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
} MCI_WAVE_DELETE_PARMS;
typedef MCI_WAVE_DELETE_PARMS FAR *LPMCI_WAVE_DELETE_PARMS;

/* parameter block for MCI_SET command message */
typedef struct tagMCI_WAVE_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    UINT    wInput;
    UINT    wReserved0;
    UINT    wOutput;
    UINT    wReserved1;
    UINT    wFormatTag;
    UINT    wReserved2;
    UINT    nChannels;
    UINT    wReserved3;
    DWORD   nSamplesPerSec;
    DWORD   nAvgBytesPerSec;
    UINT    nBlockAlign;
    UINT    wReserved4;
    UINT    wBitsPerSample;
    UINT    wReserved5;
} MCI_WAVE_SET_PARMS;
typedef MCI_WAVE_SET_PARMS FAR * LPMCI_WAVE_SET_PARMS;


/* MCI extensions for MIDI sequencer devices */

/* flags for the dwReturn field of MCI_STATUS_PARMS parameter block */
/* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) */
#define     MCI_SEQ_DIV_PPQN            (0 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_24        (1 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_25        (2 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30DROP    (3 + MCI_SEQ_OFFSET)
#define     MCI_SEQ_DIV_SMPTE_30        (4 + MCI_SEQ_OFFSET)

/* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block */
/* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) */
#define     MCI_SEQ_FORMAT_SONGPTR      0x4001
#define     MCI_SEQ_FILE                0x4002
#define     MCI_SEQ_MIDI                0x4003
#define     MCI_SEQ_SMPTE               0x4004
#define     MCI_SEQ_NONE                65533

/* flags for the dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_SEQ_STATUS_TEMPO            0x00004002L
#define MCI_SEQ_STATUS_PORT             0x00004003L
#define MCI_SEQ_STATUS_SLAVE            0x00004007L
#define MCI_SEQ_STATUS_MASTER           0x00004008L
#define MCI_SEQ_STATUS_OFFSET           0x00004009L
#define MCI_SEQ_STATUS_DIVTYPE          0x0000400AL

/* flags for the dwFlags parameter of MCI_SET command message */
#define MCI_SEQ_SET_TEMPO               0x00010000L
#define MCI_SEQ_SET_PORT                0x00020000L
#define MCI_SEQ_SET_SLAVE               0x00040000L
#define MCI_SEQ_SET_MASTER              0x00080000L
#define MCI_SEQ_SET_OFFSET              0x01000000L

/* parameter block for MCI_SET command message */
typedef struct tagMCI_SEQ_SET_PARMS {
    DWORD   dwCallback;
    DWORD   dwTimeFormat;
    DWORD   dwAudio;
    DWORD   dwTempo;
    DWORD   dwPort;
    DWORD   dwSlave;
    DWORD   dwMaster;
    DWORD   dwOffset;
} MCI_SEQ_SET_PARMS;
typedef MCI_SEQ_SET_PARMS FAR * LPMCI_SEQ_SET_PARMS;


/* MCI extensions for animation devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_ANIM_OPEN_WS                0x00010000L
#define MCI_ANIM_OPEN_PARENT            0x00020000L
#define MCI_ANIM_OPEN_NOSTATIC          0x00040000L

/* flags for dwFlags parameter of MCI_PLAY command message */
#define MCI_ANIM_PLAY_SPEED             0x00010000L
#define MCI_ANIM_PLAY_REVERSE           0x00020000L
#define MCI_ANIM_PLAY_FAST              0x00040000L
#define MCI_ANIM_PLAY_SLOW              0x00080000L
#define MCI_ANIM_PLAY_SCAN              0x00100000L

/* flags for dwFlags parameter of MCI_STEP command message */
#define MCI_ANIM_STEP_REVERSE           0x00010000L
#define MCI_ANIM_STEP_FRAMES            0x00020000L

/* flags for dwItem field of MCI_STATUS_PARMS parameter block */
#define MCI_ANIM_STATUS_SPEED           0x00004001L
#define MCI_ANIM_STATUS_FORWARD         0x00004002L
#define MCI_ANIM_STATUS_HWND            0x00004003L
#define MCI_ANIM_STATUS_HPAL            0x00004004L
#define MCI_ANIM_STATUS_STRETCH         0x00004005L

/* flags for the dwFlags parameter of MCI_INFO command message */
#define MCI_ANIM_INFO_TEXT              0x00010000L

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_ANIM_GETDEVCAPS_CAN_REVERSE 0x00004001L
#define MCI_ANIM_GETDEVCAPS_FAST_RATE   0x00004002L
#define MCI_ANIM_GETDEVCAPS_SLOW_RATE   0x00004003L
#define MCI_ANIM_GETDEVCAPS_NORMAL_RATE 0x00004004L
#define MCI_ANIM_GETDEVCAPS_PALETTES    0x00004006L
#define MCI_ANIM_GETDEVCAPS_CAN_STRETCH 0x00004007L
#define MCI_ANIM_GETDEVCAPS_MAX_WINDOWS 0x00004008L

/* flags for the MCI_REALIZE command message */
#define MCI_ANIM_REALIZE_NORM           0x00010000L
#define MCI_ANIM_REALIZE_BKGD           0x00020000L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_ANIM_WINDOW_HWND            0x00010000L
#define MCI_ANIM_WINDOW_STATE           0x00040000L
#define MCI_ANIM_WINDOW_TEXT            0x00080000L
#define MCI_ANIM_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_ANIM_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block */
/* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) */
#define MCI_ANIM_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_ANIM_RECT                   0x00010000L
#define MCI_ANIM_PUT_SOURCE             0x00020000L
#define MCI_ANIM_PUT_DESTINATION        0x00040000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_ANIM_WHERE_SOURCE           0x00020000L
#define MCI_ANIM_WHERE_DESTINATION      0x00040000L

/* flags for dwFlags parameter of MCI_UPDATE command message */
#define MCI_ANIM_UPDATE_HDC             0x00020000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_ANIM_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
} MCI_ANIM_OPEN_PARMS;
typedef MCI_ANIM_OPEN_PARMS FAR *LPMCI_ANIM_OPEN_PARMS;

/* parameter block for MCI_PLAY command message */
typedef struct tagMCI_ANIM_PLAY_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrom;
    DWORD   dwTo;
    DWORD   dwSpeed;
} MCI_ANIM_PLAY_PARMS;
typedef MCI_ANIM_PLAY_PARMS FAR *LPMCI_ANIM_PLAY_PARMS;

/* parameter block for MCI_STEP command message */
typedef struct tagMCI_ANIM_STEP_PARMS {
    DWORD   dwCallback;
    DWORD   dwFrames;
} MCI_ANIM_STEP_PARMS;
typedef MCI_ANIM_STEP_PARMS FAR *LPMCI_ANIM_STEP_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_ANIM_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_ANIM_WINDOW_PARMS;
typedef MCI_ANIM_WINDOW_PARMS FAR * LPMCI_ANIM_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages */
typedef struct tagMCI_ANIM_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_ANIM_RECT_PARMS;
typedef MCI_ANIM_RECT_PARMS FAR * LPMCI_ANIM_RECT_PARMS;

/* parameter block for MCI_UPDATE PARMS */
typedef struct tagMCI_ANIM_UPDATE_PARMS {
    DWORD   dwCallback;
    RECT    rc;
    HDC     hDC;
} MCI_ANIM_UPDATE_PARMS;
typedef MCI_ANIM_UPDATE_PARMS FAR * LPMCI_ANIM_UPDATE_PARMS;


/* MCI extensions for video overlay devices */

/* flags for dwFlags parameter of MCI_OPEN command message */
#define MCI_OVLY_OPEN_WS                0x00010000L
#define MCI_OVLY_OPEN_PARENT            0x00020000L

/* flags for dwFlags parameter of MCI_STATUS command message */
#define MCI_OVLY_STATUS_HWND            0x00004001L
#define MCI_OVLY_STATUS_STRETCH         0x00004002L

/* flags for dwFlags parameter of MCI_INFO command message */
#define MCI_OVLY_INFO_TEXT              0x00010000L 

/* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block */
#define MCI_OVLY_GETDEVCAPS_CAN_STRETCH 0x00004001L
#define MCI_OVLY_GETDEVCAPS_CAN_FREEZE  0x00004002L
#define MCI_OVLY_GETDEVCAPS_MAX_WINDOWS 0x00004003L

/* flags for dwFlags parameter of MCI_WINDOW command message */
#define MCI_OVLY_WINDOW_HWND            0x00010000L
#define MCI_OVLY_WINDOW_STATE           0x00040000L
#define MCI_OVLY_WINDOW_TEXT            0x00080000L
#define MCI_OVLY_WINDOW_ENABLE_STRETCH  0x00100000L
#define MCI_OVLY_WINDOW_DISABLE_STRETCH 0x00200000L

/* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block */
#define MCI_OVLY_WINDOW_DEFAULT         0x00000000L

/* flags for dwFlags parameter of MCI_PUT command message */
#define MCI_OVLY_RECT                   0x00010000L
#define MCI_OVLY_PUT_SOURCE             0x00020000L
#define MCI_OVLY_PUT_DESTINATION        0x00040000L
#define MCI_OVLY_PUT_FRAME              0x00080000L
#define MCI_OVLY_PUT_VIDEO              0x00100000L

/* flags for dwFlags parameter of MCI_WHERE command message */
#define MCI_OVLY_WHERE_SOURCE           0x00020000L
#define MCI_OVLY_WHERE_DESTINATION      0x00040000L
#define MCI_OVLY_WHERE_FRAME            0x00080000L
#define MCI_OVLY_WHERE_VIDEO            0x00100000L

/* parameter block for MCI_OPEN command message */
typedef struct tagMCI_OVLY_OPEN_PARMS {
    DWORD   dwCallback;
    UINT    wDeviceID;
    UINT    wReserved0;
    LPCSTR  lpstrDeviceType;
    LPCSTR  lpstrElementName;
    LPCSTR  lpstrAlias;
    DWORD   dwStyle;
    HWND    hWndParent;
    UINT    wReserved1;
 } MCI_OVLY_OPEN_PARMS;
typedef MCI_OVLY_OPEN_PARMS FAR *LPMCI_OVLY_OPEN_PARMS;

/* parameter block for MCI_WINDOW command message */
typedef struct tagMCI_OVLY_WINDOW_PARMS {
    DWORD   dwCallback;
    HWND    hWnd;
    UINT    wReserved1;
    UINT    nCmdShow;
    UINT    wReserved2;
    LPCSTR  lpstrText;
} MCI_OVLY_WINDOW_PARMS;
typedef MCI_OVLY_WINDOW_PARMS FAR * LPMCI_OVLY_WINDOW_PARMS;

/* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages */
typedef struct tagMCI_OVLY_RECT_PARMS {
    DWORD   dwCallback;
#ifdef MCI_USE_OFFEXT
    POINT   ptOffset;
    POINT   ptExtent;
#else   /* ifdef MCI_USE_OFFEXT */
    RECT    rc;
#endif  /* ifdef MCI_USE_OFFEXT */
} MCI_OVLY_RECT_PARMS;
typedef MCI_OVLY_RECT_PARMS FAR * LPMCI_OVLY_RECT_PARMS;

/* parameter block for MCI_SAVE command message */
typedef struct tagMCI_OVLY_SAVE_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_SAVE_PARMS;
typedef MCI_OVLY_SAVE_PARMS FAR * LPMCI_OVLY_SAVE_PARMS;

/* parameter block for MCI_LOAD command message */
typedef struct tagMCI_OVLY_LOAD_PARMS {
    DWORD   dwCallback;
    LPCSTR  lpfilename;
    RECT    rc;
} MCI_OVLY_LOAD_PARMS;
typedef MCI_OVLY_LOAD_PARMS FAR * LPMCI_OVLY_LOAD_PARMS;

#endif  /* ifndef MMNOMCI */

/****************************************************************************

                        DISPLAY Driver extensions

****************************************************************************/

#ifndef C1_TRANSPARENT
    #define CAPS1           94          /* other caps */
    #define C1_TRANSPARENT  0x0001      /* new raster cap */
    #define NEWTRANSPARENT  3           /* use with SetBkMode() */

    #define QUERYROPSUPPORT 40          /* use to determine ROP support */
#endif  /* ifndef C1_TRANSPARENT */

/****************************************************************************

                        DIB Driver extensions

****************************************************************************/

#define SELECTDIB       41                      /* DIB.DRV select dib escape */
#define DIBINDEX(n)     MAKELONG((n),0x10FF)


/****************************************************************************

                        ScreenSaver support

    The current application will receive a syscommand of SC_SCREENSAVE just
    before the screen saver is invoked.  If the app wishes to prevent a
    screen save, return non-zero value, otherwise call DefWindowProc().

****************************************************************************/

#ifndef SC_SCREENSAVE

    #define SC_SCREENSAVE   0xF140

#endif  /* ifndef SC_SCREENSAVE */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif  /* _INC_MMSYSTEM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\mmsystem.inc ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;         MMSYSTEM.INC - Multimedia assembly language structures & constants
;
;         Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;     If defined, the following flags inhibit inclusion
;     of the indicated items:
; 
;       MMNODRV          - Installable driver support
;       MMNOSOUND        - Sound support
;       MMNOWAVE         - Waveform support
;       MMNOMIDI         - MIDI support
;       MMNOAUX          - Auxiliary audio support
;       MMNOTIMER        - Timer support
;       MMNOJOY          - Joystick support
;       MMNOMCI          - MCI support
;       MMNOMMIO         - Multimedia file I/O support
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   General constants and data types
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general constants
MAXPNAMELEN        equ    32     ; max product name length (including NULL)
MAXERRORLENGTH     equ    128    ; max error text length (including NULL)

; MMTIME data structure
MMTIME	struc
    mmt_wType           dw    ?  ; indicates the contents of the union
    mmt_TimeUnion       dd    ?  ; union
MMTIME	ends

SMPTE struc
    smpte_hour      db    ?  ; hours
    smpte_min       db    ?  ; minutes
    smpte_sec       db    ?  ; seconds
    smpte_frame     db    ?  ; frames
    smpte_fps       db    ?  ; frames per second
    smpte_reserved  db    ?  ; pad
SMPTE ends

; types for wType field in MMTIME struct
TIME_MS         equ    0001h   ; time in milliseconds
TIME_SAMPLES    equ    0002h   ; number of wave samples
TIME_BYTES      equ    0004h   ; current byte offset
TIME_SMPTE      equ    0008h   ; SMPTE time
TIME_MIDI       equ    0010h   ; MIDI time


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                   Multimedia Extensions Window Messages
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MM_JOY1MOVE         equ    3A0h            ; joystick
MM_JOY2MOVE         equ    3A1h
MM_JOY1ZMOVE        equ    3A2h
MM_JOY2ZMOVE        equ    3A3h
MM_JOY1BUTTONDOWN   equ    3B5h
MM_JOY2BUTTONDOWN   equ    3B6h
MM_JOY1BUTTONUP     equ    3B7h
MM_JOY2BUTTONUP     equ    3B8h

MM_MCINOTIFY        equ    3B9h            ; MCI
MM_MCISYSTEM_STRING equ    3CAh

MM_WOM_OPEN         equ    3BBh            ; waveform output
MM_WOM_CLOSE        equ    3BCh
MM_WOM_DONE         equ    3BDh

MM_WIM_OPEN         equ    3BEh            ; waveform input
MM_WIM_CLOSE        equ    3BFh
MM_WIM_DATA         equ    3C0h

MM_MIM_OPEN         equ    3C1h            ; MIDI input
MM_MIM_CLOSE        equ    3C2h
MM_MIM_DATA         equ    3C3h
MM_MIM_LONGDATA     equ    3C4h
MM_MIM_ERROR        equ    3C5h
MM_MIM_LONGERROR    equ    3C6h

MM_MOM_OPEN         equ    3C7h            ; MIDI output
MM_MOM_CLOSE        equ    3C8h
MM_MOM_DONE         equ    3C9h


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;               String resource number bases (internal use)
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

MMSYSERR_BASE          equ    0
WAVERR_BASE            equ    32
MIDIERR_BASE           equ    64
TIMERR_BASE            equ    96
JOYERR_BASE            equ    160
MCIERR_BASE            equ    256

MCI_STRING_OFFSET      equ    512
MCI_VD_OFFSET          equ    1024
MCI_CD_OFFSET          equ    1088
MCI_WAVE_OFFSET        equ    1152
MCI_SEQ_OFFSET         equ    1216

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       General error return values
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; general error return values
MMSYSERR_NOERROR      equ    0                    ; no error
MMSYSERR_ERROR        equ    (MMSYSERR_BASE + 1)  ; unspecified error
MMSYSERR_BADDEVICEID  equ    (MMSYSERR_BASE + 2)  ; device ID out of range
MMSYSERR_NOTENABLED   equ    (MMSYSERR_BASE + 3)  ; driver failed enable
MMSYSERR_ALLOCATED    equ    (MMSYSERR_BASE + 4)  ; device already allocated
MMSYSERR_INVALHANDLE  equ    (MMSYSERR_BASE + 5)  ; device handle is invalid
MMSYSERR_NODRIVER     equ    (MMSYSERR_BASE + 6)  ; no device driver present
MMSYSERR_NOMEM        equ    (MMSYSERR_BASE + 7)  ; memory allocation error
MMSYSERR_NOTSUPPORTED equ    (MMSYSERR_BASE + 8)  ; function isn't supported
MMSYSERR_BADERRNUM    equ    (MMSYSERR_BASE + 9)  ; error value out of range
MMSYSERR_INVALFLAG    equ    (MMSYSERR_BASE + 10) ; invalid flags passed
MMSYSERR_INVALPARAM   equ    (MMSYSERR_BASE + 11) ; invalid parameter passed
MMSYSERR_LASTERROR    equ    (MMSYSERR_BASE + 11) ; last error in range


ifndef MMNODRV
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Installable driver support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

DRV_MCI_FIRST          equ    DRV_RESERVED
DRV_MCI_LAST           equ    (DRV_RESERVED + 0FFFh)

endif  ;ifndef MMNODRV


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                         Driver callback support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and
; midiOutOpen() to specify the type of the dwCallback parameter.
CALLBACK_TYPEMASK   equ    00070000h     ; callback type mask
CALLBACK_NULL       equ    00000000h     ; no callback
CALLBACK_WINDOW     equ    00010000h     ; dwCallback is a HWND
CALLBACK_TASK       equ    00020000h     ; dwCallback is a HTASK
CALLBACK_FUNCTION   equ    00030000h     ; dwCallback is a FARPROC

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                        Manufacturer and product IDs
;        
;   Used with wMid and wPid fields in WAVEOUTCAPS, WAVEINCAPS, 
;   MIDIOUTCAPS, MIDIINCAPS, AUXCAPS, JOYCAPS structures.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; manufacturer IDs
MM_MICROSOFT            equ    1       ; Microsoft Corp.

; product IDs
MM_MIDI_MAPPER          equ    1       ; MIDI Mapper
MM_WAVE_MAPPER          equ    2       ; Wave Mapper

MM_SNDBLST_MIDIOUT      equ    3       ; Sound Blaster MIDI output port
MM_SNDBLST_MIDIIN       equ    4       ; Sound Blaster MIDI input port
MM_SNDBLST_SYNTH        equ    5       ; Sound Blaster internal synthesizer
MM_SNDBLST_WAVEOUT      equ    6       ; Sound Blaster waveform output
MM_SNDBLST_WAVEIN       equ    7       ; Sound Blaster waveform input

MM_ADLIB                equ    9       ; Ad Lib-compatible synthesizer

MM_MPU401_MIDIOUT       equ    10      ; MPU401-compatible MIDI output port
MM_MPU401_MIDIIN        equ    11      ; MPU401-compatible MIDI input port

MM_PC_JOYSTICK          equ    12      ; Joystick adapter


ifndef MMNOSOUND
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Sound support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; flag values for wFlags parameter
SND_SYNC            equ    0000h   ; play synchronously (default)
SND_ASYNC           equ    0001h   ; play asynchronously
SND_NODEFAULT       equ    0002h   ; don't use default sound
SND_MEMORY          equ    0004h   ; lpszSoundName points to a memory file
SND_LOOP            equ    0008h   ; loop the sound until next sndPlaySound
SND_NOSTOP          equ    0010h   ; don't stop any currently playing sound

endif  ;ifndef MMNOSOUND


ifndef MMNOWAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Waveform audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; waveform audio error return values
WAVERR_BADFORMAT      equ    (WAVERR_BASE + 0)    ; unsupported wave format
WAVERR_STILLPLAYING   equ    (WAVERR_BASE + 1)    ; still something playing
WAVERR_UNPREPARED     equ    (WAVERR_BASE + 2)    ; header not prepared
WAVERR_SYNC           equ    (WAVERR_BASE + 3)    ; device is synchronous
WAVERR_LASTERROR      equ    (WAVERR_BASE + 3)    ; last error in range

; wave callback messages
WOM_OPEN        equ    MM_WOM_OPEN
WOM_CLOSE       equ    MM_WOM_CLOSE
WOM_DONE        equ    MM_WOM_DONE
WIM_OPEN        equ    MM_WIM_OPEN
WIM_CLOSE       equ    MM_WIM_CLOSE
WIM_DATA        equ    MM_WIM_DATA

; device ID for wave device mapper
WAVE_MAPPER     equ    (-1)

; flags for dwFlags parameter in waveOutOpen() and waveInOpen()
WAVE_FORMAT_QUERY     equ    0001h
WAVE_ALLOWSYNC        equ    0002h

; wave data block header
WAVEHDR struc
    lpWaveData               dd    ?     ; pointer to locked data buffer
    dwWaveBufferLength       dd    ?     ; length of data buffer
    dwWaveBytesRecorded      dd    ?     ; used for input only
    dwWaveUser               dd    ?     ; for client's use
    dwWaveFlags              dd    ?     ; assorted flags (see defines)
    dwWaveLoops              dd    ?     ; loop control counter
    lpWaveNext               dd    ?     ; reserved for driver
    Wavereserved             dd    ?     ; reserved for driver
WAVEHDR ends

; flags for dwFlags field of WAVEHDR
WHDR_DONE       equ    00000001h   ; done bit
WHDR_PREPARED   equ    00000002h   ; set if this header has been prepared
WHDR_BEGINLOOP  equ    00000004h   ; loop start block
WHDR_ENDLOOP    equ    00000008h   ; loop end block
WHDR_INQUEUE    equ    00000010h   ; reserved for driver

; waveform output device capabilities structure
WAVEOUTCAPS struc
    woc_wMid            dw      ?      ; manufacturer ID
    woc_wPid            dw      ?      ; product ID
    woc_vDriverVersion  dw      ?      ; version of the driver
    woc_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    woc_dwFormats       dd      ?      ; formats supported
    woc_wChannels       dw      ?      ; number of sources supported
    woc_dwSupport       dd      ?      ; functionality supported by driver
WAVEOUTCAPS ends

; flags for dwSupport field of WAVEOUTCAPS
WAVECAPS_PITCH          equ    0001h    ; supports pitch control
WAVECAPS_PLAYBACKRATE   equ    0002h    ; supports playback rate control
WAVECAPS_VOLUME         equ    0004h    ; supports volume control
WAVECAPS_LRVOLUME       equ    0008h    ; separate left-right volume control
WAVECAPS_SYNC           equ    0010h

; waveform input device capabilities structure
WAVEINCAPS struc
    wic_wMid            dw      ?      ; manufacturer ID
    wic_wPid            dw      ?      ; product ID
    wic_vDriverVersion  dw      ?      ; version of the driver
    wic_szPname         db MAXPNAMELEN dup (?)  ; product name (NULL terminated string)
    wic_dwFormats       dd      ?      ; formats supported
    wic_wChannels       dw      ?      ; number of channels supported
WAVEINCAPS ends

; defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
WAVE_INVALIDFORMAT     equ    00000000h        ; invalid format
WAVE_FORMAT_1M08       equ    00000001h        ; 11.025 kHz, Mono,   8-bit
WAVE_FORMAT_1S08       equ    00000002h        ; 11.025 kHz, Stereo, 8-bit
WAVE_FORMAT_1M16       equ    00000004h        ; 11.025 kHz, Mono,   16-bit
WAVE_FORMAT_1S16       equ    00000008h        ; 11.025 kHz, Stereo, 16-bit
WAVE_FORMAT_2M08       equ    00000010h        ; 22.05  kHz, Mono,   8-bit
WAVE_FORMAT_2S08       equ    00000020h        ; 22.05  kHz, Stereo, 8-bit
WAVE_FORMAT_2M16       equ    00000040h        ; 22.05  kHz, Mono,   16-bit
WAVE_FORMAT_2S16       equ    00000080h        ; 22.05  kHz, Stereo, 16-bit
WAVE_FORMAT_4M08       equ    00000100h        ; 44.1   kHz, Mono,   8-bit
WAVE_FORMAT_4S08       equ    00000200h        ; 44.1   kHz, Stereo, 8-bit
WAVE_FORMAT_4M16       equ    00000400h        ; 44.1   kHz, Mono,   16-bit
WAVE_FORMAT_4S16       equ    00000800h        ; 44.1   kHz, Stereo, 16-bit

; general waveform format structure (information common to all formats)
WAVEFORMAT struc
    wfmt_wFormatTag       dw    ?   ; format type
    wfmt_nChannels        dw    ?   ; number of channels (i.e. mono, stereo, etc.)
    wfmt_nSamplesPerSec   dd    ?   ; sample rate
    wfmt_nAvgBytesPerSec  dd    ?   ; for buffer estimation
    wfmt_nBlockAlign      dw    ?   ; block size of data
WAVEFORMAT ends

; flags for wFormatTag field of WAVEFORMAT
WAVE_FORMAT_PCM     equ    1

; specific waveform format structure for PCM data
PCMWAVEFORMAT struc
    pcm_wf               db (SIZE WAVEFORMAT) dup (?)
    pcm_wBitsPerSample   dw    ?
PCMWAVEFORMAT ends

endif  ;ifndef MMNOWAVE


ifndef MMNOMIDI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MIDI audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MIDI error return values
MIDIERR_UNPREPARED    equ    (MIDIERR_BASE + 0)   ; header not prepared
MIDIERR_STILLPLAYING  equ    (MIDIERR_BASE + 1)   ; still something playing
MIDIERR_NOMAP         equ    (MIDIERR_BASE + 2)   ; no current map
MIDIERR_NOTREADY      equ    (MIDIERR_BASE + 3)   ; hardware is still busy
MIDIERR_NODEVICE      equ    (MIDIERR_BASE + 4)   ; port no longer connected
MIDIERR_INVALIDSETUP  equ    (MIDIERR_BASE + 5)   ; invalid setup
MIDIERR_LASTERROR     equ    (MIDIERR_BASE + 5)   ; last error in range

; MIDI audio data types
MIDIPATCHSIZE   equ    128

; MIDI callback messages
MIM_OPEN        equ    MM_MIM_OPEN
MIM_CLOSE       equ    MM_MIM_CLOSE
MIM_DATA        equ    MM_MIM_DATA
MIM_LONGDATA    equ    MM_MIM_LONGDATA
MIM_ERROR       equ    MM_MIM_ERROR
MIM_LONGERROR   equ    MM_MIM_LONGERROR
MOM_OPEN        equ    MM_MOM_OPEN
MOM_CLOSE       equ    MM_MOM_CLOSE
MOM_DONE        equ    MM_MOM_DONE

; device ID for MIDI mapper
MIDIMAPPER     equ    (-1)
MIDI_MAPPER    equ    (-1)

; flags for wFlags parm of midiOutCachePatches(),       
; midiOutCacheDrumPatches()                             
MIDI_CACHE_ALL      equ    1                            
MIDI_CACHE_BESTFIT  equ    2                            
MIDI_CACHE_QUERY    equ    3                            
MIDI_UNCACHE        equ    4                            

; MIDI output device capabilities structure
MIDIOUTCAPS struc
    moc_wMid            dw    ?        ; manufacturer ID
    moc_wPid            dw    ?        ; product ID
    moc_vDriverVersion  dw    ?        ; version of the driver
    moc_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    moc_wTechnology     dw    ?        ; type of device
    moc_wVoices         dw    ?        ; # of voices (internal synth only)
    moc_wNotes          dw    ?        ; max # of notes (internal synth only)
    moc_wChannelMask    dw    ?        ; channels used (internal synth only)
    moc_dwSupport       dd    ?        ; functionality supported by driver
MIDIOUTCAPS ends

; flags for wTechnology field of MIDIOUTCAPS structure
MOD_MIDIPORT    equ    1  ; output port
MOD_SYNTH       equ    2  ; generic internal synth
MOD_SQSYNTH     equ    3  ; square wave internal synth
MOD_FMSYNTH     equ    4  ; FM internal synth
MOD_MAPPER      equ    5  ; MIDI mapper

; flags for dwSupport field of MIDIOUTCAPS structure
MIDICAPS_VOLUME          equ    0001h   ; supports volume control
MIDICAPS_LRVOLUME        equ    0002h   ; separate left-right volume control
MIDICAPS_CACHE           equ    0004h  

; MIDI output device capabilities structure
MIDIINCAPS struc
    mic_wMid            dw    ?       ; manufacturer ID
    mic_wPid            dw    ?       ; product ID
    mic_vDriverVersion  dw    ?       ; version of the driver
    mic_szPname         db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
MIDIINCAPS ends

; MIDI data block header
MIDIHDR struc
    lpMidiData            dd    ?      ; pointer to locked data block
    dwMidiBufferLength    dd    ?      ; length of data in data block
    dwMidiBytesRecorded   dd    ?      ; used for input only
    dwMidiUser            dd    ?      ; for client's use
    dwMidiFlags           dd    ?      ; assorted flags (see defines)
    lpMidiNext            dd    ?      ; reserved for driver
    Midireserved          dd    ?      ; reserved for driver
MIDIHDR ends

; flags for dwFlags field of MIDIHDR structure
MHDR_DONE       equ    00000001h        ; done bit
MHDR_PREPARED   equ    00000002h        ; set if header prepared
MHDR_INQUEUE    equ    00000004h        ; reserved for driver

endif  ;ifndef MMNOMIDI


ifndef MMNOAUX
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Auxiliary audio support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; device ID for aux device mapper
AUX_MAPPER     equ    (-1)

; Auxiliary audio device capabilities structure
AUXCAPS struc
    acaps_wMid              dw    ?      ; manufacturer ID
    acaps_wPid              dw    ?      ; product ID
    acaps_vDriverVersion    dw    ?      ; version of the driver
    acaps_szPname           db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    acaps_wTechnology       dw    ?      ; type of device
    acaps_dwSupport         dd    ?      ; functionality supported by driver
AUXCAPS ends

; flags for wTechnology field in AUXCAPS structure
AUXCAPS_CDAUDIO    equ    1       ; audio from internal CD-ROM drive
AUXCAPS_AUXIN      equ    2       ; audio from auxiliary input jacks

; flags for dwSupport field in AUXCAPS structure
AUXCAPS_VOLUME          equ    0001h   ; supports volume control
AUXCAPS_LRVOLUME        equ    0002h   ; separate left-right volume control

endif  ;ifndef MMNOAUX


ifndef MMNOTIMER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Timer support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; timer error return values
TIMERR_NOERROR        equ    (0)                  ; no error
TIMERR_NOCANDO        equ    (TIMERR_BASE+1)      ; request not completed
TIMERR_STRUCT         equ    (TIMERR_BASE+33)     ; time struct size

; flags for wFlags parameter of timeSetEvent() function
TIME_ONESHOT    equ    0   ; program timer for single event
TIME_PERIODIC   equ    1   ; program for continuous periodic event

; timer device capabilities data structure
TIMECAPS struc
    tc_wPeriodMin    dw    ?     ; minimum period supported
    tc_wPeriodMax    dw    ?     ; maximum period supported
TIMECAPS ends

endif  ;ifndef MMNOTIMER


ifndef MMNOJOY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           Joystick support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; joystick error return values
JOYERR_NOERROR        equ    (0)                  ; no error
JOYERR_PARMS          equ    (JOYERR_BASE+5)      ; bad parameters
JOYERR_NOCANDO        equ    (JOYERR_BASE+6)      ; request not completed
JOYERR_UNPLUGGED      equ    (JOYERR_BASE+7)      ; joystick is unplugged

; constants used with JOYINFO structure and MM_JOY* messages
JOY_BUTTON1         equ    0001h
JOY_BUTTON2         equ    0002h
JOY_BUTTON3         equ    0004h
JOY_BUTTON4         equ    0008h
JOY_BUTTON1CHG      equ    0100h
JOY_BUTTON2CHG      equ    0200h
JOY_BUTTON3CHG      equ    0400h
JOY_BUTTON4CHG      equ    0800h

; joystick ID constants
JOYSTICKID1         equ    0
JOYSTICKID2         equ    1

; joystick device capabilities data structure
JOYCAPS struc
    jcaps_wMid         dw    ?    ; manufacturer ID
    jcaps_wPid         dw    ?    ; product ID
    jcaps_szPname      db MAXPNAMELEN dup (?) ; product name (NULL terminated string)
    jcaps_wXmin        dw    ?    ; minimum x position value
    jcaps_wXmax        dw    ?    ; maximum x position value
    jcaps_wYmin        dw    ?    ; minimum y position value
    jcaps_wYmax        dw    ?    ; maximum y position value
    jcaps_wZmin        dw    ?    ; minimum z position value
    jcaps_wZmax        dw    ?    ; maximum z position value
    jcaps_wNumButtons  dw    ?    ; number of buttons
    jcaps_wPeriodMin   dw    ?    ; minimum message period when captured
    jcaps_wPeriodMax   dw    ?    ; maximum message period when captured
JOYCAPS ends

; joystick information data structure
JOYINFO struc
    jinfo_wXpos        dw    ?  ; x position
    jinfo_wYpos        dw    ?  ; y position
    jinfo_wZpos        dw    ?  ; z position
    jinfo_wButtons     dw    ?  ; button states
JOYINFO ends

endif  ;ifndef MMNOJOY

ifndef MMNOMMIO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       Multimedia File I/O support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MMIO error return values
MMIOERR_BASE            equ    256
MMIOERR_FILENOTFOUND    equ    (MMIOERR_BASE + 1)  ; file not found
MMIOERR_OUTOFMEMORY     equ    (MMIOERR_BASE + 2)  ; out of memory
MMIOERR_CANNOTOPEN      equ    (MMIOERR_BASE + 3)  ; cannot open
MMIOERR_CANNOTCLOSE     equ    (MMIOERR_BASE + 4)  ; cannot close
MMIOERR_CANNOTREAD      equ    (MMIOERR_BASE + 5)  ; cannot read
MMIOERR_CANNOTWRITE     equ    (MMIOERR_BASE + 6)  ; cannot write
MMIOERR_CANNOTSEEK      equ    (MMIOERR_BASE + 7)  ; cannot seek
MMIOERR_CANNOTEXPAND    equ    (MMIOERR_BASE + 8)  ; cannot expand file
MMIOERR_CHUNKNOTFOUND   equ    (MMIOERR_BASE + 9)  ; chunk not found
MMIOERR_UNBUFFERED      equ    (MMIOERR_BASE + 10) ; file is unbuffered

; MMIO constants
CFSEPCHAR    equ   '+'             ; compound file name separator char.

; general MMIO information data structure
MMIOINFO struc
        ; general fields
    mmio_dwFlags        dd    ?      ; general status flags
    mmio_fccIOProc      dd    ?      ; pointer to I/O procedure
    mmio_pIOProc        dd    ?      ; pointer to I/O procedure
    mmio_wErrorRet      dw    ?      ; place for error to be returned
    mmio_htask          dw    ?      ; alternate local task

        ; fields maintained by MMIO functions during buffered I/O
    mmio_cchBuffer      dd    ?      ; size of I/O buffer (or 0L)
    mmio_pchBuffer      dd    ?      ; start of I/O buffer (or NULL)
    mmio_pchNext        dd    ?      ; pointer to next byte to read/write
    mmio_pchEndRead     dd    ?      ; pointer to last valid byte to read
    mmio_pchEndWrite    dd    ?      ; pointer to last byte to write
    mmio_lBufOffset     dd    ?      ; disk offset of start of buffer

        ; fields maintained by I/O procedure
    mmio_lDiskOffset    dd    ?      ; disk offset of next read or write
    mmio_adwInfo        dd 3 dup (?) ; data specific to type of MMIOPROC

        ; other fields maintained by MMIO
    mmio_dwReserved1    dd    ?      ; reserved for MMIO use
    mmio_dwReserved2    dd    ?      ; reserved for MMIO use
    mmio_hmmio          dw    ?      ; handle to open file
MMIOINFO ends

; RIFF chunk information data structure
MMCKINFO struc
    mmck_ckid          dd    ?  ; chunk ID
    mmck_cksize        dd    ?  ; chunk size
    mmck_fccType       dd    ?  ; form type or list type
    mmck_dwDataOffset  dd    ?  ; offset of data portion of chunk
    mmck_dwFlags       dd    ?  ; flags used by MMIO functions
MMCKINFO ends

; bit field masks
MMIO_RWMODE     equ    00000003h       ; open file for reading/writing/both
MMIO_SHAREMODE  equ    00000070h       ; file sharing mode number

; constants for dwFlags field of MMIOINFO
MMIO_CREATE     equ    00001000h       ; create new file (or truncate file)
MMIO_PARSE      equ    00000100h       ; parse new file returning path
MMIO_DELETE     equ    00000200h       ; create new file (or truncate file)
MMIO_EXIST      equ    00004000h       ; checks for existence of file
MMIO_ALLOCBUF   equ    00010000h       ; mmioOpen() should allocate a buffer
MMIO_GETTEMP    equ    00020000h       ; mmioOpen() should retrieve temp name

MMIO_DIRTY      equ    10000000h       ; I/O buffer is dirty


; read/write mode numbers (bit field MMIO_RWMODE)
MMIO_READ       equ    00000000h       ; open file for reading only
MMIO_WRITE      equ    00000001h       ; open file for writing only
MMIO_READWRITE  equ    00000002h       ; open file for reading and writing

; share mode numbers (bit field MMIO_SHAREMODE)
MMIO_COMPAT     equ    00000000h       ; compatibility mode
MMIO_EXCLUSIVE  equ    00000010h       ; exclusive-access mode
MMIO_DENYWRITE  equ    00000020h       ; deny writing to other processes
MMIO_DENYREAD   equ    00000030h       ; deny reading to other processes
MMIO_DENYNONE   equ    00000040h       ; deny nothing to other processes

; various MMIO flags
MMIO_FHOPEN             equ    0010h   ; mmioClose: keep file handle open
MMIO_EMPTYBUF           equ    0010h   ; mmioFlush: empty the I/O buffer
MMIO_TOUPPER            equ    0010h   ; mmioStringToFOURCC: to u-case
MMIO_INSTALLPROC    equ    00010000h   ; mmioInstallIOProc: install MMIOProc
MMIO_GLOBALPROC     equ    10000000h   ; mmioInstallIOProc: install globally
MMIO_REMOVEPROC     equ    00020000h   ; mmioInstallIOProc: remove MMIOProc
MMIO_FINDPROC       equ    00040000h   ; mmioInstallIOProc: find an MMIOProc
MMIO_FINDCHUNK          equ    0010h   ; mmioDescend: find a chunk by ID
MMIO_FINDRIFF           equ    0020h   ; mmioDescend: find a LIST chunk
MMIO_FINDLIST           equ    0040h   ; mmioDescend: find a RIFF chunk
MMIO_CREATERIFF         equ    0020h   ; mmioCreateChunk: make a LIST chunk
MMIO_CREATELIST         equ    0040h   ; mmioCreateChunk: make a RIFF chunk


; message numbers for MMIOPROC I/O procedure functions
MMIOM_READ      equ    MMIO_READ       ; read
MMIOM_WRITE    equ    MMIO_WRITE       ; write
MMIOM_SEEK              equ    2       ; seek to a new position in file
MMIOM_OPEN              equ    3       ; open file
MMIOM_CLOSE             equ    4       ; close file
MMIOM_WRITEFLUSH        equ    5       ; write and flush
MMIOM_RENAME            equ    6       ; rename specified file
MMIOM_USER         equ    8000h        ; beginning of user-defined messages

mmioFOURCC MACRO ch0,ch1,ch2,ch3
        mov     al,ch0
        mov     ah,ch1
        mov     dl,ch2
        mov     dh,ch3
        ENDM

; standard four character codes
FOURCC_RIFF     equ    mmioFOURCC('R', 'I', 'F', 'F')
FOURCC_LIST     equ    mmioFOURCC('L', 'I', 'S', 'T')

; four character codes used to identify standard built-in I/O procedures
FOURCC_DOS      equ    mmioFOURCC('D', 'O', 'S', ' ')
FOURCC_MEM      equ    mmioFOURCC('M', 'E', 'M', ' ')

; flags for mmioSeek()
ifndef SEEK_SET
SEEK_SET        equ    0               ; seek to an absolute position
SEEK_CUR        equ    1               ; seek relative to current position
SEEK_END        equ    2               ; seek relative to end of file
endif  ;ifndef SEEK_SET

; other constants
MMIO_DEFAULTBUFFER      equ    8192    ; default buffer size

endif	;ifndef MMNOMMIO

ifndef MMNOMCI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           MCI support
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; MCI error return values
MCIERR_INVALID_DEVICE_ID        equ    (MCIERR_BASE + 1)
MCIERR_UNRECOGNIZED_KEYWORD     equ    (MCIERR_BASE + 3)
MCIERR_UNRECOGNIZED_COMMAND     equ    (MCIERR_BASE + 5)
MCIERR_HARDWARE                 equ    (MCIERR_BASE + 6)
MCIERR_INVALID_DEVICE_NAME      equ    (MCIERR_BASE + 7)
MCIERR_OUT_OF_MEMORY            equ    (MCIERR_BASE + 8)
MCIERR_DEVICE_OPEN              equ    (MCIERR_BASE + 9)
MCIERR_CANNOT_LOAD_DRIVER       equ    (MCIERR_BASE + 10)
MCIERR_MISSING_COMMAND_STRING   equ    (MCIERR_BASE + 11)
MCIERR_PARAM_OVERFLOW           equ    (MCIERR_BASE + 12)
MCIERR_MISSING_STRING_ARGUMENT  equ    (MCIERR_BASE + 13)
MCIERR_BAD_INTEGER              equ    (MCIERR_BASE + 14)
MCIERR_PARSER_INTERNAL          equ    (MCIERR_BASE + 15)
MCIERR_DRIVER_INTERNAL          equ    (MCIERR_BASE + 16)
MCIERR_MISSING_PARAMETER        equ    (MCIERR_BASE + 17)
MCIERR_UNSUPPORTED_FUNCTION     equ    (MCIERR_BASE + 18)
MCIERR_FILE_NOT_FOUND           equ    (MCIERR_BASE + 19)
MCIERR_DEVICE_NOT_READY         equ    (MCIERR_BASE + 20)
MCIERR_INTERNAL                 equ    (MCIERR_BASE + 21)
MCIERR_DRIVER                   equ    (MCIERR_BASE + 22)
MCIERR_CANNOT_USE_ALL           equ    (MCIERR_BASE + 23)
MCIERR_MULTIPLE                 equ    (MCIERR_BASE + 24)
MCIERR_EXTENSION_NOT_FOUND      equ    (MCIERR_BASE + 25)
MCIERR_OUTOFRANGE               equ    (MCIERR_BASE + 26)
MCIERR_FLAGS_NOT_COMPATIBLE     equ    (MCIERR_BASE + 28)
MCIERR_FILE_NOT_SAVED           equ    (MCIERR_BASE + 30)
MCIERR_DEVICE_TYPE_REQUIRED     equ    (MCIERR_BASE + 31)
MCIERR_DEVICE_LOCKED            equ    (MCIERR_BASE + 32)
MCIERR_DUPLICATE_ALIAS          equ    (MCIERR_BASE + 33)
MCIERR_BAD_CONSTANT             equ    (MCIERR_BASE + 34)
MCIERR_MUST_USE_SHAREABLE       equ    (MCIERR_BASE + 35)
MCIERR_MISSING_DEVICE_NAME      equ    (MCIERR_BASE + 36)
MCIERR_BAD_TIME_FORMAT          equ    (MCIERR_BASE + 37)
MCIERR_NO_CLOSING_QUOTE         equ    (MCIERR_BASE + 38)
MCIERR_DUPLICATE_FLAGS          equ    (MCIERR_BASE + 39)
MCIERR_INVALID_FILE             equ    (MCIERR_BASE + 40)
MCIERR_NULL_PARAMETER_BLOCK     equ    (MCIERR_BASE + 41)
MCIERR_UNNAMED_RESOURCE         equ    (MCIERR_BASE + 42)
MCIERR_NEW_REQUIRES_ALIAS       equ    (MCIERR_BASE + 43)
MCIERR_NOTIFY_ON_AUTO_OPEN      equ    (MCIERR_BASE + 44)
MCIERR_NO_ELEMENT_ALLOWED       equ    (MCIERR_BASE + 45)
MCIERR_NONAPPLICABLE_FUNCTION   equ    (MCIERR_BASE + 46)
MCIERR_ILLEGAL_FOR_AUTO_OPEN    equ    (MCIERR_BASE + 47)
MCIERR_FILENAME_REQUIRED        equ    (MCIERR_BASE + 48)
MCIERR_EXTRA_CHARACTERS         equ    (MCIERR_BASE + 49)
MCIERR_DEVICE_NOT_INSTALLED     equ    (MCIERR_BASE + 50)
MCIERR_GET_CD                   equ    (MCIERR_BASE + 51)
MCIERR_SET_CD                   equ    (MCIERR_BASE + 52)
MCIERR_SET_DRIVE                equ    (MCIERR_BASE + 53)
MCIERR_DEVICE_LENGTH            equ    (MCIERR_BASE + 54)
MCIERR_DEVICE_ORD_LENGTH        equ    (MCIERR_BASE + 55)
MCIERR_NO_INTEGER               equ    (MCIERR_BASE + 56)

MCIERR_WAVE_OUTPUTSINUSE        equ    (MCIERR_BASE + 64)
MCIERR_WAVE_SETOUTPUTINUSE      equ    (MCIERR_BASE + 65)
MCIERR_WAVE_INPUTSINUSE         equ    (MCIERR_BASE + 66)
MCIERR_WAVE_SETINPUTINUSE       equ    (MCIERR_BASE + 67)
MCIERR_WAVE_OUTPUTUNSPECIFIED   equ    (MCIERR_BASE + 68)
MCIERR_WAVE_INPUTUNSPECIFIED    equ    (MCIERR_BASE + 69)
MCIERR_WAVE_OUTPUTSUNSUITABLE   equ    (MCIERR_BASE + 70)
MCIERR_WAVE_SETOUTPUTUNSUITABLE equ    (MCIERR_BASE + 71)
MCIERR_WAVE_INPUTSUNSUITABLE    equ    (MCIERR_BASE + 72)
MCIERR_WAVE_SETINPUTUNSUITABLE  equ    (MCIERR_BASE + 73)

MCIERR_SEQ_DIV_INCOMPATIBLE     equ    (MCIERR_BASE + 80)
MCIERR_SEQ_PORT_INUSE           equ    (MCIERR_BASE + 81)
MCIERR_SEQ_PORT_NONEXISTENT     equ    (MCIERR_BASE + 82)
MCIERR_SEQ_PORT_MAPNODEVICE     equ    (MCIERR_BASE + 83)
MCIERR_SEQ_PORT_MISCERROR       equ    (MCIERR_BASE + 84)
MCIERR_SEQ_TIMER                equ    (MCIERR_BASE + 85)
MCIERR_SEQ_PORTUNSPECIFIED      equ    (MCIERR_BASE + 86)
MCIERR_SEQ_NOMIDIPRESENT        equ    (MCIERR_BASE + 87)

MCIERR_NO_WINDOW                equ    (MCIERR_BASE + 90)
MCIERR_CREATEWINDOW             equ    (MCIERR_BASE + 91)
MCIERR_FILE_READ                equ    (MCIERR_BASE + 92)
MCIERR_FILE_WRITE               equ    (MCIERR_BASE + 93)

; all custom device driver errors must be >= than this value
MCIERR_CUSTOM_DRIVER_BASE       equ    (MCIERR_BASE + 256)

; MCI command message identifiers
MCI_OPEN                        equ    0803h
MCI_CLOSE                       equ    0804h
MCI_ESCAPE                      equ    0805h
MCI_PLAY                        equ    0806h
MCI_SEEK                        equ    0807h
MCI_STOP                        equ    0808h
MCI_PAUSE                       equ    0809h
MCI_INFO                        equ    080Ah
MCI_GETDEVCAPS                  equ    080Bh
MCI_SPIN                        equ    080Ch
MCI_SET                         equ    080Dh
MCI_STEP                        equ    080Eh
MCI_RECORD                      equ    080Fh
MCI_SYSINFO                     equ    0810h
MCI_BREAK                       equ    0811h
MCI_SOUND                       equ    0812h
MCI_SAVE                        equ    0813h
MCI_STATUS                      equ    0814h
MCI_CUE                         equ    0830h
MCI_REALIZE                     equ    0840h
MCI_WINDOW                      equ    0841h
MCI_PUT                         equ    0842h
MCI_WHERE                       equ    0843h
MCI_FREEZE                      equ    0844h
MCI_UNFREEZE                    equ    0845h
MCI_LOAD                        equ    0850h
MCI_CUT                         equ    0851h
MCI_COPY                        equ    0852h
MCI_PASTE                       equ    0853h
MCI_UPDATE                      equ    0854h
MCI_RESUME                      equ    0855h
MCI_DELETE                      equ    0856h

; all custom MCI command messages must be >= than this value
MCI_USER_MESSAGES               equ    (400h + DRV_MCI_FIRST)


; device ID for "all devices"
MCI_ALL_DEVICE_ID               equ    0FFFFh

; constants for predefined MCI device types
MCI_DEVTYPE_VCR                 equ    (MCI_STRING_OFFSET + 1)
MCI_DEVTYPE_VIDEODISC           equ    (MCI_STRING_OFFSET + 2)
MCI_DEVTYPE_OVERLAY             equ    (MCI_STRING_OFFSET + 3)
MCI_DEVTYPE_CD_AUDIO            equ    (MCI_STRING_OFFSET + 4)
MCI_DEVTYPE_DAT                 equ    (MCI_STRING_OFFSET + 5)
MCI_DEVTYPE_SCANNER             equ    (MCI_STRING_OFFSET + 6)
MCI_DEVTYPE_ANIMATION           equ    (MCI_STRING_OFFSET + 7)
MCI_DEVTYPE_DIGITAL_VIDEO       equ    (MCI_STRING_OFFSET + 8)
MCI_DEVTYPE_OTHER               equ    (MCI_STRING_OFFSET + 9)
MCI_DEVTYPE_WAVEFORM_AUDIO      equ    (MCI_STRING_OFFSET + 10)
MCI_DEVTYPE_SEQUENCER           equ    (MCI_STRING_OFFSET + 11)

MCI_DEVTYPE_FIRST               equ    MCI_DEVTYPE_VCR
MCI_DEVTYPE_LAST                equ    MCI_DEVTYPE_SEQUENCER

; return values for 'status mode' command
MCI_MODE_NOT_READY              equ    (MCI_STRING_OFFSET + 12)
MCI_MODE_STOP                   equ    (MCI_STRING_OFFSET + 13)
MCI_MODE_PLAY                   equ    (MCI_STRING_OFFSET + 14)
MCI_MODE_RECORD                 equ    (MCI_STRING_OFFSET + 15)
MCI_MODE_SEEK                   equ    (MCI_STRING_OFFSET + 16)
MCI_MODE_PAUSE                  equ    (MCI_STRING_OFFSET + 17)
MCI_MODE_OPEN                   equ    (MCI_STRING_OFFSET + 18)

; constants used in 'set time format' and 'status time format' commands
MCI_FORMAT_MILLISECONDS         equ    0
MCI_FORMAT_HMS                  equ    1
MCI_FORMAT_MSF                  equ    2
MCI_FORMAT_FRAMES               equ    3
MCI_FORMAT_SMPTE_24             equ    4
MCI_FORMAT_SMPTE_25             equ    5
MCI_FORMAT_SMPTE_30             equ    6
MCI_FORMAT_SMPTE_30DROP         equ    7
MCI_FORMAT_BYTES                equ    8
MCI_FORMAT_SAMPLES              equ    9
MCI_FORMAT_TMSF                 equ    10

; flags for wParam of MM_MCINOTIFY message
MCI_NOTIFY_SUCCESSFUL           equ    0001h
MCI_NOTIFY_SUPERSEDED           equ    0002h
MCI_NOTIFY_ABORTED              equ    0004h
MCI_NOTIFY_FAILURE              equ    0008h


; common flags for dwFlags parameter of MCI command messages
MCI_NOTIFY                      equ    00000001h
MCI_WAIT                        equ    00000002h
MCI_FROM                        equ    00000004h
MCI_TO                          equ    00000008h
MCI_TRACK                       equ    00000010h

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OPEN_SHAREABLE              equ    00000100h
MCI_OPEN_ELEMENT                equ    00000200h
MCI_OPEN_ALIAS                  equ    00000400h
MCI_OPEN_ELEMENT_ID             equ    00000800h
MCI_OPEN_TYPE_ID                equ    00001000h
MCI_OPEN_TYPE                   equ    00002000h

; flags for dwFlags parameter of MCI_SEEK command message
MCI_SEEK_TO_START               equ    00000100h
MCI_SEEK_TO_END                 equ    00000200h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_STATUS_ITEM                 equ    00000100h
MCI_STATUS_START                equ    00000200h

; flags for dwItem field of the MCI_STATUS_PARMS parameter block
MCI_STATUS_LENGTH               equ    00000001h
MCI_STATUS_POSITION             equ    00000002h
MCI_STATUS_NUMBER_OF_TRACKS     equ    00000003h
MCI_STATUS_MODE                 equ    00000004h
MCI_STATUS_MEDIA_PRESENT        equ    00000005h
MCI_STATUS_TIME_FORMAT          equ    00000006h
MCI_STATUS_READY                equ    00000007h
MCI_STATUS_CURRENT_TRACK        equ    00000008h

; flags for dwFlags parameter of MCI_INFO command message
MCI_INFO_PRODUCT                equ    00000100h
MCI_INFO_FILE                   equ    00000200h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_ITEM             equ    00000100h

; flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block
MCI_GETDEVCAPS_CAN_RECORD       equ    00000001h
MCI_GETDEVCAPS_HAS_AUDIO        equ    00000002h
MCI_GETDEVCAPS_HAS_VIDEO        equ    00000003h
MCI_GETDEVCAPS_DEVICE_TYPE      equ    00000004h
MCI_GETDEVCAPS_USES_FILES       equ    00000005h
MCI_GETDEVCAPS_COMPOUND_DEVICE  equ    00000006h
MCI_GETDEVCAPS_CAN_EJECT        equ    00000007h
MCI_GETDEVCAPS_CAN_PLAY         equ    00000008h
MCI_GETDEVCAPS_CAN_SAVE         equ    00000009h

; flags for dwFlags parameter of MCI_SYSINFO command message
MCI_SYSINFO_QUANTITY            equ    00000100h
MCI_SYSINFO_OPEN                equ    00000200h
MCI_SYSINFO_NAME                equ    00000400h
MCI_SYSINFO_INSTALLNAME         equ    00000800h

; flags for dwFlags parameter of MCI_SET command message
MCI_SET_DOOR_OPEN               equ    00000100h
MCI_SET_DOOR_CLOSED             equ    00000200h
MCI_SET_TIME_FORMAT             equ    00000400h
MCI_SET_AUDIO                   equ    00000800h
MCI_SET_VIDEO                   equ    00001000h
MCI_SET_ON                      equ    00002000h
MCI_SET_OFF                     equ    00004000h

; flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS
MCI_SET_AUDIO_ALL               equ    00000000h
MCI_SET_AUDIO_LEFT              equ    00000001h
MCI_SET_AUDIO_RIGHT             equ    00000002h

; flags for dwFlags parameter of MCI_BREAK command message
MCI_BREAK_KEY                   equ    00000100h
MCI_BREAK_HWND                  equ    00000200h
MCI_BREAK_OFF                   equ    00000400h

; flags for dwFlags parameter of MCI_RECORD command message
MCI_RECORD_INSERT               equ    00000100h
MCI_RECORD_OVERWRITE            equ    00000200h

; flags for dwFlags parameter of MCI_SOUND command message
MCI_SOUND_NAME                  equ    00000100h

; flags for dwFlags parameter of MCI_SAVE command message
MCI_SAVE_FILE                   equ    00000100h

; flags for dwFlags parameter of MCI_LOAD command message
MCI_LOAD_FILE                   equ    00000100h

; generic parameter block for MCI command messages with no special parameters
MCI_GENERIC_PARMS struc
    mcigen_dwCallback         dd    ?
MCI_GENERIC_PARMS ends

; parameter block for MCI_OPEN command message
MCI_OPEN_PARMS struc
    mciopen_dwCallback        dd    ?
    mciopen_wDeviceID         dw    ?
    mciopen_wReserved0        dw    ?
    mciopen_lpstrDeviceType   dd    ?
    mciopen_lpstrElementName  dd    ?
    mciopen_lpstrAlias        dd    ?
MCI_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_PLAY_PARMS struc
    mciplay_dwCallback        dd    ?
    mciplay_dwFrom            dd    ?
    mciplay_dwTo              dd    ?
MCI_PLAY_PARMS ends

; parameter block for MCI_SEEK command message
MCI_SEEK_PARMS struc
    mciseek_dwCallback        dd    ?
    mciseek_dwTo              dd    ?
MCI_SEEK_PARMS ends

; parameter block for MCI_STATUS command message
MCI_STATUS_PARMS struc
    mcistat_dwCallback        dd    ?
    mcistat_dwReturn          dd    ?
    mcistat_dwItem            dd    ?
    mcistat_dwTrack           dd    ?
MCI_STATUS_PARMS ends

; parameter block for MCI_INFO command message
MCI_INFO_PARMS struc
    mciinfo_dwCallback        dd    ?
    mciinfo_lpstrReturn       dd    ?
    mciinfo_dwRetSize         dd    ?
MCI_INFO_PARMS ends

; parameter block for MCI_GETDEVCAPS command message
MCI_GETDEVCAPS_PARMS struc
    mcigdc_dwCallback         dd    ?
    mcigdc_dwReturn           dd    ?
    mcigdc_dwItem             dd    ?
MCI_GETDEVCAPS_PARMS ends

; parameter block for MCI_SYSINFO command message
MCI_SYSINFO_PARMS struc
    mcisi_dwCallback          dd    ?
    mcisi_lpstrReturn         dd    ?
    mcisi_dwRetSize           dd    ?
    mcisi_dwNumber            dd    ?
    mcisi_wDeviceType         dw    ?
    mcisi_wReserved0          dw    ?
MCI_SYSINFO_PARMS ends

; parameter block for MCI_SET command message
MCI_SET_PARMS struc
    mciset_dwCallback         dd    ?
    mciset_dwTimeFormat       dd    ?
    mciset_dwAudio            dd    ?
MCI_SET_PARMS ends

; parameter block for MCI_BREAK command message
MCI_BREAK_PARMS struc
    mcibreak_dwCallback       dd    ?
    mcibreak_nVirtKey         dw    ?
    mcibreak_wReserved0       dw    ?
    mcibreak_hwndBreak        dw    ?
    mcibreak_wReserved1       dw    ?
MCI_BREAK_PARMS ends

; parameter block for MCI_SOUND command message
MCI_SOUND_PARMS struc
    mcisnd_dwCallback         dd    ?
    mcisnd_lpstrSoundName     dd    ?
MCI_SOUND_PARMS ends

; parameter block for MCI_SAVE command message
MCI_SAVE_PARMS struc
    mcisave_dwCallback        dd    ?
    mcisave_lpfilename        dd    ?
MCI_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_LOAD_PARMS struc
    mciload_dwCallback        dd    ?
    mciload_lpfilename        dd    ?
MCI_LOAD_PARMS ends

; parameter block for MCI_RECORD command message
MCI_RECORD_PARMS struc
    mcirec_dwCallback         dd    ?
    mcirec_dwFrom             dd    ?
    mcirec_dwTo               dd    ?
MCI_RECORD_PARMS ends


;
; MCI extensions for videodisc devices
;

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_STATUS_MODE)
MCI_VD_MODE_PARK                equ    (MCI_VD_OFFSET + 1)

; flag for dwReturn field of MCI_STATUS_PARMS
; MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE)
MCI_VD_MEDIA_CLV                equ    (MCI_VD_OFFSET + 2)
MCI_VD_MEDIA_CAV                equ    (MCI_VD_OFFSET + 3)
MCI_VD_MEDIA_OTHER              equ    (MCI_VD_OFFSET + 4)

MCI_VD_FORMAT_TRACK             equ    4001h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_VD_PLAY_REVERSE             equ    00010000h
MCI_VD_PLAY_FAST                equ    00020000h
MCI_VD_PLAY_SPEED               equ    00040000h
MCI_VD_PLAY_SCAN                equ    00080000h
MCI_VD_PLAY_SLOW                equ    00100000h

; flag for dwFlags parameter of MCI_SEEK command message
MCI_VD_SEEK_REVERSE             equ    00010000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_VD_STATUS_SPEED             equ    00004002h
MCI_VD_STATUS_FORWARD           equ    00004003h
MCI_VD_STATUS_MEDIA_TYPE        equ    00004004h
MCI_VD_STATUS_SIDE              equ    00004005h
MCI_VD_STATUS_DISC_SIZE         equ    00004006h

; flags for dwFlags parameter of MCI_GETDEVCAPS command message
MCI_VD_GETDEVCAPS_CLV           equ    00010000h
MCI_VD_GETDEVCAPS_CAV           equ    00020000h

MCI_VD_SPIN_UP                  equ    0001h
MCI_VD_SPIN_DOWN                equ    0002h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_VD_GETDEVCAPS_CAN_REVERSE   equ    00004002h
MCI_VD_GETDEVCAPS_FAST_RATE     equ    00004003h
MCI_VD_GETDEVCAPS_SLOW_RATE     equ    00004004h
MCI_VD_GETDEVCAPS_NORMAL_RATE   equ    00004005h

; flags for the dwFlags parameter of MCI_STEP command message
MCI_VD_STEP_FRAMES              equ    00010000h
MCI_VD_STEP_REVERSE             equ    00020000h

; flag for the MCI_ESCAPE command message
MCI_VD_ESCAPE_STRING            equ    00000100h

; parameter block for MCI_PLAY command message
MCI_VD_PLAY_PARMS struc
    mcivdplay_dwCallback      dd    ?
    mcivdplay_dwFrom          dd    ?
    mcivdplay_dwTo            dd    ?
    mcivdplay_dwSpeed         dd    ?
MCI_VD_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_VD_STEP_PARMS struc
    mcivdstep_dwCallback      dd    ?
    mcivdstep_dwFrames        dd    ?
MCI_VD_STEP_PARMS ends

; parameter block for MCI_ESCAPE command message
MCI_VD_ESCAPE_PARMS struc
    mcivcesc_dwCallback       dd    ?
    mcivcesc_lpstrCommand     dd    ?
MCI_VD_ESCAPE_PARMS ends


;
; MCI extensions for waveform audio devices
;

; flags for the dwFlags parameter of MCI_OPEN command message
MCI_WAVE_OPEN_BUFFER            equ    00010000h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_FORMATTAG          equ    00010000h
MCI_WAVE_SET_CHANNELS           equ    00020000h
MCI_WAVE_SET_SAMPLESPERSEC      equ    00040000h
MCI_WAVE_SET_AVGBYTESPERSEC     equ    00080000h
MCI_WAVE_SET_BLOCKALIGN         equ    00100000h
MCI_WAVE_SET_BITSPERSAMPLE      equ    00200000h

; flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages
MCI_WAVE_INPUT                  equ    00400000h
MCI_WAVE_OUTPUT                 equ    00800000h

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_WAVE_STATUS_FORMATTAG       equ    00004001h
MCI_WAVE_STATUS_CHANNELS        equ    00004002h
MCI_WAVE_STATUS_SAMPLESPERSEC   equ    00004003h
MCI_WAVE_STATUS_AVGBYTESPERSEC  equ    00004004h
MCI_WAVE_STATUS_BLOCKALIGN      equ    00004005h
MCI_WAVE_STATUS_BITSPERSAMPLE   equ    00004006h
MCI_WAVE_STATUS_LEVEL           equ    00004007h

; flags for the dwFlags parameter of MCI_SET command message
MCI_WAVE_SET_ANYINPUT           equ    04000000h
MCI_WAVE_SET_ANYOUTPUT          equ    08000000h

; flags for the dwFlags parameter of MCI_GETDEVCAPS command message
MCI_WAVE_GETDEVCAPS_INPUTS      equ    00004001h
MCI_WAVE_GETDEVCAPS_OUTPUTS     equ    00004002h

; parameter block for MCI_OPEN command message
MCI_WAVE_OPEN_PARMS struc
    mciwopen_dwCallback       dd    ?
    mciwopen_wDeviceID        dw    ?
    mciwopen_wReserved0       dw    ?
    mciwopen_lpstrDeviceType  dd    ?
    mciwopen_lpstrElementName dd    ?
    mciwopen_lpstrAlias       dd    ?
    mciwopen_dwBufferSeconds  dd    ?
MCI_WAVE_OPEN_PARMS ends

; parameter block for MCI_DELETE command message
MCI_WAVE_DELETE_PARMS struc
    mciwdel_dwCallback        dd    ?
    mciwdel_dwFrom            dd    ?
    mciwdel_dwTo              dd    ?
MCI_WAVE_DELETE_PARMS ends

; parameter block for MCI_SET command message
MCI_WAVE_SET_PARMS struc
    mciwset_dwCallback        dd    ?
    mciwset_dwTimeFormat      dd    ?
    mciwset_dwAudio           dd    ?
    mciwset_wInput            dw    ?
    mciwset_wReserved0        dw    ?
    mciwset_wOutput           dw    ?
    mciwset_wReserved1        dw    ?
    mciwset_wFormatTag        dw    ?
    mciwset_wReserved2        dw    ?
    mciwset_nChannels         dw    ?
    mciwset_wReserved3        dw    ?
    mciwset_nSamplesPerSec    dw    ?
    mciwset_nAvgBytesPerSec   dw    ?
    mciwset_nBlockAlign       dw    ?
    mciwset_wReserved4        dw    ?
    mciwset_wBitsPerSample    dw    ?
    mciwset_wReserved5        dw    ?
MCI_WAVE_SET_PARMS ends


;
; MCI extensions for MIDI sequencer devices
;

; flags for the dwReturn field of MCI_STATUS_PARMS parameter block
; MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE)
MCI_SEQ_DIV_PPQN            equ    (0 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_24        equ    (1 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_25        equ    (2 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30DROP    equ    (3 + MCI_SEQ_OFFSET)
MCI_SEQ_DIV_SMPTE_30        equ    (4 + MCI_SEQ_OFFSET)

; flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block
; MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER)
MCI_SEQ_FORMAT_SONGPTR      equ    4001h
MCI_SEQ_FILE                equ    4002h
MCI_SEQ_MIDI                equ    4003h
MCI_SEQ_SMPTE               equ    4004h
MCI_SEQ_NONE                equ    65533

; flags for the dwItem field of MCI_STATUS_PARMS parameter block
MCI_SEQ_STATUS_TEMPO            equ    00004002h
MCI_SEQ_STATUS_PORT             equ    00004003h
MCI_SEQ_STATUS_SLAVE            equ    00004007h
MCI_SEQ_STATUS_MASTER           equ    00004008h
MCI_SEQ_STATUS_OFFSET           equ    00004009h
MCI_SEQ_STATUS_DIVTYPE          equ    0000400Ah

; flags for the dwFlags parameter of MCI_SET command message
MCI_SEQ_SET_TEMPO               equ    00010000h
MCI_SEQ_SET_PORT                equ    00020000h
MCI_SEQ_SET_SLAVE               equ    00040000h
MCI_SEQ_SET_MASTER              equ    00080000h
MCI_SEQ_SET_OFFSET              equ    01000000h

; parameter block for MCI_SET command message
MCI_SEQ_SET_PARMS struc
    mcisset_dwCallback        dd    ?
    mcisset_dwTimeFormat      dd    ?
    mcisset_dwAudio           dd    ?
    mcisset_dwTempo           dd    ?
    mcisset_dwPort            dd    ?
    mcisset_dwSlave           dd    ?
    mcisset_dwMaster          dd    ?
    mcisset_dwOffset          dd    ?
MCI_SEQ_SET_PARMS ends


;
; MCI extensions for animation devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_ANIM_OPEN_WS                equ    00010000h
MCI_ANIM_OPEN_PARENT            equ    00020000h
MCI_ANIM_OPEN_NOSTATIC          equ    00040000h

; flags for dwFlags parameter of MCI_PLAY command message
MCI_ANIM_PLAY_SPEED             equ    00010000h
MCI_ANIM_PLAY_REVERSE           equ    00020000h
MCI_ANIM_PLAY_FAST              equ    00040000h
MCI_ANIM_PLAY_SLOW              equ    00080000h
MCI_ANIM_PLAY_SCAN              equ    00100000h

; flags for dwFlags parameter of MCI_STEP command message
MCI_ANIM_STEP_REVERSE           equ    00010000h
MCI_ANIM_STEP_FRAMES            equ    00020000h

; flags for dwItem field of MCI_STATUS_PARMS parameter block
MCI_ANIM_STATUS_SPEED           equ    00004001h
MCI_ANIM_STATUS_FORWARD         equ    00004002h
MCI_ANIM_STATUS_HWND            equ    00004003h
MCI_ANIM_STATUS_HPAL            equ    00004004h
MCI_ANIM_STATUS_STRETCH         equ    00004005h

; flags for the dwFlags parameter of MCI_INFO command message
MCI_ANIM_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_ANIM_GETDEVCAPS_CAN_REVERSE equ    00004001h
MCI_ANIM_GETDEVCAPS_FAST_RATE   equ    00004002h
MCI_ANIM_GETDEVCAPS_SLOW_RATE   equ    00004003h
MCI_ANIM_GETDEVCAPS_NORMAL_RATE equ    00004004h
MCI_ANIM_GETDEVCAPS_PALETTES    equ    00004006h
MCI_ANIM_GETDEVCAPS_CAN_STRETCH equ    00004007h
MCI_ANIM_GETDEVCAPS_MAX_WINDOWS equ    00004008h

; flags for the MCI_REALIZE command message
MCI_ANIM_REALIZE_NORM           equ    00010000h
MCI_ANIM_REALIZE_BKGD           equ    00020000h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_ANIM_WINDOW_HWND            equ    00010000h
MCI_ANIM_WINDOW_STATE           equ    00040000h
MCI_ANIM_WINDOW_TEXT            equ    00080000h
MCI_ANIM_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_ANIM_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block
; MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND)
MCI_ANIM_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_ANIM_RECT                   equ    00010000h
MCI_ANIM_PUT_SOURCE             equ    00020000h
MCI_ANIM_PUT_DESTINATION        equ    00040000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_ANIM_WHERE_SOURCE           equ    00020000h
MCI_ANIM_WHERE_DESTINATION      equ    00040000h

; flags for dwFlags parameter of MCI_UPDATE command message
MCI_ANIM_UPDATE_HDC             equ    00020000h

; parameter block for MCI_OPEN command message
MCI_ANIM_OPEN_PARMS struc
    mciaopen_dwCallback       dd    ?
    mciaopen_wDeviceID        dw    ?
    mciaopen_wReserved0       dw    ?
    mciaopen_lpstrDeviceType  dd    ?
    mciaopen_lpstrElementName dd    ?
    mciaopen_lpstrAlias       dd    ?
    mciaopen_dwStyle          dd    ?
    mciaopen_hWndParent       dw    ?
    mciaopen_wReserved1       dw    ?
MCI_ANIM_OPEN_PARMS ends

; parameter block for MCI_PLAY command message
MCI_ANIM_PLAY_PARMS struc
    mciaplay_dwCallback       dd    ?
    mciaplay_dwFrom           dd    ?
    mciaplay_dwTo             dd    ?
    mciaplay_dwSpeed          dd    ?
MCI_ANIM_PLAY_PARMS ends

; parameter block for MCI_STEP command message
MCI_ANIM_STEP_PARMS struc
    mciastep_dwCallback       dd    ?
    mciastep_dwFrames         dd    ?
MCI_ANIM_STEP_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_ANIM_WINDOW_PARMS struc
    mciawin_dwCallback        dd    ?
    mciawin_hWnd              dw    ?
    mciawin_wReserved1        dw    ?
    mciawin_nCmdShow          dw    ?
    mciawin_wReserved2        dw    ?
    mciawin_lpstrText         dd    ?
MCI_ANIM_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages
MCI_ANIM_RECT_PARMS struc
    mciarect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciarect_ptOffset         db (SIZE POINT) dup (?)
    mciarect_ptExtent         db (SIZE POINT) dup (?)
else	;ifdef MCI_USE_OFFEXT
    mciarect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_ANIM_RECT_PARMS ends

; parameter block for MCI_UPDATE PARMS
MCI_ANIM_UPDATE_PARMS struc
    mciaupd_dwCallback        dd    ?
    mciaupd_rc                db (SIZE RECT) dup (?)
    mciaupd_hDC               dw    ?
MCI_ANIM_UPDATE_PARMS ends


;
; MCI extensions for video overlay devices
;

; flags for dwFlags parameter of MCI_OPEN command message
MCI_OVLY_OPEN_WS                equ    00010000h
MCI_OVLY_OPEN_PARENT            equ    00020000h

; flags for dwFlags parameter of MCI_STATUS command message
MCI_OVLY_STATUS_HWND            equ    00004001h
MCI_OVLY_STATUS_STRETCH         equ    00004002h

; flags for dwFlags parameter of MCI_INFO command message
MCI_OVLY_INFO_TEXT              equ    00010000h

; flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block
MCI_OVLY_GETDEVCAPS_CAN_STRETCH equ    00004001h
MCI_OVLY_GETDEVCAPS_CAN_FREEZE  equ    00004002h
MCI_OVLY_GETDEVCAPS_MAX_WINDOWS equ    00004003h

; flags for dwFlags parameter of MCI_WINDOW command message
MCI_OVLY_WINDOW_HWND            equ    00010000h
MCI_OVLY_WINDOW_STATE           equ    00040000h
MCI_OVLY_WINDOW_TEXT            equ    00080000h
MCI_OVLY_WINDOW_ENABLE_STRETCH  equ    00100000h
MCI_OVLY_WINDOW_DISABLE_STRETCH equ    00200000h

; flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block
MCI_OVLY_WINDOW_DEFAULT         equ    00000000h

; flags for dwFlags parameter of MCI_PUT command message
MCI_OVLY_RECT                   equ    00010000h
MCI_OVLY_PUT_SOURCE             equ    00020000h
MCI_OVLY_PUT_DESTINATION        equ    00040000h
MCI_OVLY_PUT_FRAME              equ    00080000h
MCI_OVLY_PUT_VIDEO              equ    00100000h

; flags for dwFlags parameter of MCI_WHERE command message
MCI_OVLY_WHERE_SOURCE           equ    00020000h
MCI_OVLY_WHERE_DESTINATION      equ    00040000h
MCI_OVLY_WHERE_FRAME            equ    00080000h
MCI_OVLY_WHERE_VIDEO            equ    00100000h

; parameter block for MCI_OPEN command message
MCI_OVLY_OPEN_PARMS struc
    mcioopen_dwCallback       dd    ?
    mcioopen_wDeviceID        dw    ?
    mcioopen_wReserved0       dw    ?
    mcioopen_lpstrDeviceType  dd    ?
    mcioopen_lpstrElementName dd    ?
    mcioopen_lpstrAlias       dd    ?
    mcioopen_dwStyle          dd    ?
    mcioopen_hWndParent       dw    ?
    mcioopen_wReserved1       dw    ?
MCI_OVLY_OPEN_PARMS ends

; parameter block for MCI_WINDOW command message
MCI_OVLY_WINDOW_PARMS struc
    mciowin_dwCallback        dd    ?
    mciowin_hWnd              dw    ?
    mciowin_wReserved1        dw    ?
    mciowin_nCmdShow          dw    ?
    mciowin_wReserved2        dw    ?
    mciowin_lpstrText         dd    ?
MCI_OVLY_WINDOW_PARMS ends

; parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages
MCI_OVLY_RECT_PARMS struc
    mciorect_dwCallback       dd    ?
ifdef MCI_USE_OFFEXT
    mciorect_ptOffset         db (SIZE POINT) dup (?)
    mciorect_ptExtent         db (SIZE POINT) dup (?)
else	;ifdef MCI_USE_OFFEXT
    mciorect_rc               db (SIZE RECT) dup (?)
endif  ;ifdef MCI_USE_OFFEXT
MCI_OVLY_RECT_PARMS ends

; parameter block for MCI_SAVE command message
MCI_OVLY_SAVE_PARMS struc
    mciosave_dwCallback       dd    ?
    mciosave_lpfilename       dd    ?
    mciosave_rc               db (SIZE RECT) dup (?)
MCI_OVLY_SAVE_PARMS ends

; parameter block for MCI_LOAD command message
MCI_OVLY_LOAD_PARMS struc
    mcioload_dwCallback       dd    ?
    mcioload_lpfilename       dd    ?
    mcioload_rc               db (SIZE RECT) dup (?)
MCI_OVLY_LOAD_PARMS ends

endif  ;ifndef MMNOMCI

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DISPLAY Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef C1_TRANSPARENT
    CAPS1           equ    94          ; other caps
    C1_TRANSPARENT  equ    0001h       ; new raster cap
    NEWTRANSPARENT  equ    3           ; use with SetBkMode()

    QUERYROPSUPPORT equ    40          ; use to determine ROP support
endif  ;ifndef C1_TRANSPARENT

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       DIB Driver extensions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

SELECTDIB       equ    41                      ; DIB.DRV select dib escape
DIBINDEX MACRO a
        mov     ax,a
        mov     dx,10ffh
        ENDM


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                       ScreenSaver support
;
;   The current application will receive a syscommand of SC_SCREENSAVE just
;   before the screen saver is invoked.  If the app wishes to prevent a
;   screen save, return non-zero value, otherwise call DefWindowProc().
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SC_SCREENSAVE

    SC_SCREENSAVE   equ    0F140h

endif  ;ifndef SC_SCREENSAVE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\math.h ===
/***
*math.h - definitions and declarations for math library
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains constant definitions and external subroutine
*   declarations for the math subroutine library.
*   [ANSI/System V]
*
****/

#ifndef _INC_MATH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* definition of _exception struct - this struct is passed to the _matherr
 * routine when a floating point exception is detected
 */

#ifndef _EXCEPTION_DEFINED
#pragma pack(2)

struct _exception {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    double arg1;        /* first argument to function */
    double arg2;        /* second argument (if any) to function */
    double retval;      /* value to be returned by function */
    } ;

#ifndef __STDC__
/* Non-ANSI name for compatibility */
#define exception _exception
#endif 

#pragma pack()
#define _EXCEPTION_DEFINED
#endif 


/* definition of a _complex struct to be used by those who use cabs and
 * want type checking on their argument
 */

#ifndef _COMPLEX_DEFINED

struct _complex {
    double x,y; /* real and imaginary parts */
    } ;

#ifndef __cplusplus
#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct complex {
    double x,y; /* real and imaginary parts */
    } ;
#endif 
#endif 

#define _COMPLEX_DEFINED
#endif 


/* Constant definitions for the exception type passed in the _exception struct
 */

#define _DOMAIN     1   /* argument domain error */
#define _SING       2   /* argument singularity */
#define _OVERFLOW   3   /* overflow range error */
#define _UNDERFLOW  4   /* underflow range error */
#define _TLOSS      5   /* total loss of precision */
#define _PLOSS      6   /* partial loss of precision */

#define EDOM        33
#define ERANGE      34


/* definitions of _HUGE (XENIX) and HUGE_VAL (ANSI) error return values used
 * by several floating point math routines
 */

extern double __near __cdecl _HUGE;
#define HUGE_VAL _HUGE


/* function prototypes */

#ifdef _MT
int __cdecl  abs(int);
double  __pascal acos(double);
double  __pascal asin(double);
double  __pascal atan(double);
double  __pascal atan2(double, double);
double  __pascal atof(const char *);
double  __pascal _cabs(struct _complex);
double  __pascal ceil(double);
double  __pascal cos(double);
double  __pascal cosh(double);
int __cdecl  _dieeetomsbin(double *, double *);
int __cdecl  _dmsbintoieee(double *, double *);
double  __pascal exp(double);
double  __pascal fabs(double);
int __cdecl  _fieeetomsbin(float *, float *);
double  __pascal floor(double);
double  __pascal fmod(double, double);
int __cdecl  _fmsbintoieee(float *, float *);
double  __pascal frexp(double, int *);
double  __pascal _hypot(double, double);
double  __pascal _j0(double);
double  __pascal _j1(double);
double  __pascal _jn(int, double);
long    __cdecl  labs(long);
double  __pascal ldexp(double, int);
double  __pascal log(double);
double  __pascal log10(double);
int __cdecl  _matherr(struct _exception *);
double  __pascal modf(double, double *);
double  __pascal pow(double, double);
double  __pascal sin(double);
double  __pascal sinh(double);
double  __pascal sqrt(double);
double  __pascal tan(double);
double  __pascal tanh(double);
double  __pascal _y0(double);
double  __pascal _y1(double);
double  __pascal _yn(int, double);

#else 
int __cdecl abs(int);
double  __cdecl acos(double);
double  __cdecl asin(double);
double  __cdecl atan(double);
double  __cdecl atan2(double, double);
double  __cdecl atof(const char *);
double  __cdecl _cabs(struct _complex);
double  __cdecl ceil(double);
double  __cdecl cos(double);
double  __cdecl cosh(double);
int __cdecl _dieeetomsbin(double *, double *);
int __cdecl _dmsbintoieee(double *, double *);
double  __cdecl exp(double);
double  __cdecl fabs(double);
int __cdecl _fieeetomsbin(float *, float *);
double  __cdecl floor(double);
double  __cdecl fmod(double, double);
int __cdecl _fmsbintoieee(float *, float *);
double  __cdecl frexp(double, int *);
double  __cdecl _hypot(double, double);
double  __cdecl _j0(double);
double  __cdecl _j1(double);
double  __cdecl _jn(int, double);
long    __cdecl labs(long);
double  __cdecl ldexp(double, int);
double  __cdecl log(double);
double  __cdecl log10(double);
int __cdecl _matherr(struct _exception *);
double  __cdecl modf(double, double *);
double  __cdecl pow(double, double);
double  __cdecl sin(double);
double  __cdecl sinh(double);
double  __cdecl sqrt(double);
double  __cdecl tan(double);
double  __cdecl tanh(double);
double  __cdecl _y0(double);
double  __cdecl _y1(double);
double  __cdecl _yn(int, double);
#endif 


/* definition of _exceptionl struct - this struct is passed to the _matherrl
 * routine when a floating point exception is detected in a long double routine
 */

#ifndef _LD_EXCEPTION_DEFINED
#pragma pack(2)
struct _exceptionl {
    int type;       /* exception type - see below */
    char *name;   /* name of function where error occured */
    long double arg1;   /* first argument to function */
    long double arg2;   /* second argument (if any) to function */
    long double retval; /* value to be returned by function */
    } ;
#pragma pack()
#define _LD_EXCEPTION_DEFINED
#endif 


/* definition of a _complexl struct to be used by those who use _cabsl and
 * want type checking on their argument
 */

#ifndef _LD_COMPLEX_DEFINED
#pragma pack(2)
struct _complexl {
    long double x,y;    /* real and imaginary parts */
    } ;
#pragma pack()
#define _LD_COMPLEX_DEFINED
#endif 

extern long double __near __cdecl _LHUGE;
#define _LHUGE_VAL _LHUGE


long double  __cdecl acosl(long double);
long double  __cdecl asinl(long double);
long double  __cdecl atanl(long double);
long double  __cdecl atan2l(long double, long double);
long double  __cdecl _atold(const char *);
long double  __cdecl _cabsl(struct _complexl);
long double  __cdecl ceill(long double);
long double  __cdecl cosl(long double);
long double  __cdecl coshl(long double);
long double  __cdecl expl(long double);
long double  __cdecl fabsl(long double);
long double  __cdecl floorl(long double);
long double  __cdecl fmodl(long double, long double);
long double  __cdecl frexpl(long double, int *);
long double  __cdecl _hypotl(long double, long double);
long double  __cdecl _j0l(long double);
long double  __cdecl _j1l(long double);
long double  __cdecl _jnl(int, long double);
long double  __cdecl ldexpl(long double, int);
long double  __cdecl logl(long double);
long double  __cdecl log10l(long double);
int      __cdecl _matherrl(struct _exceptionl *);
long double  __cdecl modfl(long double, long double *);
long double  __cdecl powl(long double, long double);
long double  __cdecl sinl(long double);
long double  __cdecl sinhl(long double);
long double  __cdecl sqrtl(long double);
long double  __cdecl tanl(long double);
long double  __cdecl tanhl(long double);
long double  __cdecl _y0l(long double);
long double  __cdecl _y1l(long double);
long double  __cdecl _ynl(int, long double);


#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define DOMAIN      _DOMAIN
#define SING        _SING
#define OVERFLOW    _OVERFLOW
#define UNDERFLOW   _UNDERFLOW
#define TLOSS       _TLOSS
#define PLOSS       _PLOSS

#define matherr _matherr

extern double __near __cdecl HUGE;

#ifdef _MT
#ifndef __cplusplus
double  __pascal cabs(struct complex);
#endif 
double  __pascal hypot(double, double);
double  __pascal j0(double);
double  __pascal j1(double);
double  __pascal jn(int, double);
double  __pascal y0(double);
double  __pascal y1(double);
double  __pascal yn(int, double);
#else 
#ifndef __cplusplus
double  __cdecl cabs(struct complex);
#endif 
double  __cdecl hypot(double, double);
double  __cdecl j0(double);
double  __cdecl j1(double);
double  __cdecl jn(int, double);
double  __cdecl y0(double);
double  __cdecl y1(double);
double  __cdecl yn(int, double);
#endif 

int __cdecl dieeetomsbin(double *, double *);
int __cdecl dmsbintoieee(double *, double *);
int __cdecl fieeetomsbin(float *, float *);
int __cdecl fmsbintoieee(float *, float *);

long double  __cdecl cabsl(struct _complexl);
long double  __cdecl hypotl(long double, long double);

#endif 


#ifdef __cplusplus
}
#endif 

#define _INC_MATH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\moniker.h ===
/*****************************************************************************\
*                                                                             *
* moniker.h - 	Moniker and related interfaces and APIs						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _MONIKER_H_ )
#define _MONIKER_H_

#define MK_E_CONNECTMANUALLY        MK_E_FIRST
#define MK_E_EXCEEDEDDEADLINE       (MK_E_FIRST + 1)
#define MK_E_NEEDGENERIC            (MK_E_FIRST + 2)
#define MK_E_UNAVAILABLE            (MK_E_FIRST + 3)
#define MK_E_SYNTAX                 (MK_E_FIRST + 4)
#define MK_E_NOOBJECT               (MK_E_FIRST + 5)
#define MK_E_INVALIDEXTENSION       (MK_E_FIRST + 6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED (MK_E_FIRST + 7)
#define MK_E_NOTBINDABLE            (MK_E_FIRST + 8)
#define MK_E_NOTBOUND               (MK_E_FIRST + 9)
                            // called IBindCtx->RevokeObjectBound for an
                            // object which was not bound
#define MK_E_CANTOPENFILE           (MK_E_FIRST + 10)
#define MK_E_MUSTBOTHERUSER         (MK_E_FIRST + 11)
#define MK_E_NOINVERSE              (MK_E_FIRST + 12)
#define MK_E_NOSTORAGE              (MK_E_FIRST + 13)
#define MK_E_NOPREFIX               (MK_E_FIRST + 14)


// reserved                     MK_S_FIRST
// reserved                     (MK_S_FIRST + 1)
#define MK_S_REDUCED_TO_SELF    (MK_S_FIRST + 2)
// reserved                     (MK_S_FIRST + 3)
#define MK_S_ME                 (MK_S_FIRST + 4)
#define MK_S_HIM                (MK_S_FIRST + 5)
#define MK_S_US                 (MK_S_FIRST + 6)
#define MK_S_MONIKERALREADYREGISTERED (MK_S_FIRST + 7)


// bind options; variable sized
typedef struct FARSTRUCT tagBIND_OPTS
{
    DWORD       cbStruct;       //  sizeof(BIND_OPTS)
    DWORD       grfFlags;
    DWORD       grfMode;
    DWORD       dwTickCountDeadline;
} BIND_OPTS, FAR* LPBIND_OPTS;


// bind flags; controls binding; stored in bind options above
typedef enum
{
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2
} BIND_FLAGS;


// system moniker types; returned from IsSystemMoniker.
typedef enum tagMKSYS
{
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5
}MKSYS;


// bit wise enum to control how much reduction takes place.
typedef enum tagMKREDUCE
{
    MKRREDUCE_ONE           =   3<<16,
    MKRREDUCE_TOUSER        =   2<<16,
    MKRREDUCE_THROUGHUSER   =   1<<16,
    MKRREDUCE_ALL           =   0
} MKRREDUCE;


#if defined(__cplusplus)
interface IEnumMoniker;
interface IRunningObjectTable;
#else 
typedef interface IEnumMoniker IEnumMoniker;
typedef interface IRunningObjectTable IRunningObjectTable;
#endif

typedef       IEnumMoniker FAR* LPENUMMONIKER;
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IBindCtx

DECLARE_INTERFACE_(IBindCtx, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBindCtx methods ***
    STDMETHOD(RegisterObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(RevokeObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(ReleaseBoundObjects) (THIS) PURE;
    
    STDMETHOD(SetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetBindOptions) (THIS_ LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetRunningObjectTable) (THIS_ LPRUNNINGOBJECTTABLE  FAR*
        pprot) PURE;
    STDMETHOD(RegisterObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN punk) PURE;
    STDMETHOD(GetObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHOD(EnumObjectParam) (THIS_ LPENUMSTRING FAR* ppenum) PURE;
    STDMETHOD(RevokeObjectParam) (THIS_ LPSTR lpszKey) PURE;
};
typedef             IBindCtx FAR* LPBC;
typedef         IBindCtx FAR* LPBINDCTX;



#undef  INTERFACE
#define INTERFACE   IMoniker

DECLARE_INTERFACE_(IMoniker, IPersistStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) PURE;

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID FAR* ppvResult) PURE;
    STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
        ppmkToLeft, LPMONIKER FAR * ppmkReduced) PURE;
    STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER FAR* ppmkComposite) PURE;
    STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
        PURE;
    STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker) PURE;
    STDMETHOD(Hash) (THIS_ LPDWORD pdwHash) PURE;
    STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
        pmkNewlyRunning) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR* pfiletime) PURE;
    STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(CommonPrefixWith) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix) PURE;
    STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath) PURE;
    STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR lpszDisplayName, ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut) PURE;
    STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys) PURE;
};
typedef         IMoniker FAR* LPMONIKER;


//  IRunningObjectTable::Register flags
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 1

#undef  INTERFACE
#define INTERFACE   IRunningObjectTable

DECLARE_INTERFACE_(IRunningObjectTable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRunningObjectTable methods ***
    STDMETHOD(Register) (THIS_ DWORD grfFlags, LPUNKNOWN punkObject, 
        LPMONIKER pmkObjectName, DWORD FAR * pdwRegister) PURE;
    STDMETHOD(Revoke) (THIS_ DWORD dwRegister) PURE;
    STDMETHOD(IsRunning) (THIS_ LPMONIKER pmkObjectName) PURE;
    STDMETHOD(GetObject) (THIS_ LPMONIKER pmkObjectName,
        LPUNKNOWN FAR* ppunkObject) PURE;
    STDMETHOD(NoteChangeTime) (THIS_ DWORD dwRegister, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPMONIKER pmkObjectName, FILETIME FAR * pfiletime) PURE;
    STDMETHOD(EnumRunning) (THIS_ LPENUMMONIKER FAR * ppenumMoniker ) PURE;
};
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IEnumMoniker

DECLARE_INTERFACE_(IEnumMoniker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOleDataObject methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPMONIKER FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumMoniker FAR* FAR* ppenm) PURE;
};
typedef       IEnumMoniker FAR* LPENUMMONIKER;




STDAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
STDAPI  MkParseDisplayName(LPBC pbc, LPSTR szUserName, 
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL fCalledFromMethod);
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
STDAPI  GetClassFile (LPCSTR szFilename, CLSID FAR* pclsid);

STDAPI  CreateFileMoniker(LPSTR lpszPathName, LPMONIKER FAR* ppmk);
STDAPI  CreateItemMoniker(LPSTR lpszDelim, LPSTR lpszItem,
    LPMONIKER FAR* ppmk);
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);


#endif  // _MONIKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\new.h ===
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Contains the function declarations for C++ memory allocation functions.
*
****/

#ifndef _INC_NEW

#ifdef __cplusplus


/* constants for based heap routines */

#define _NULLSEG    ((__segment)0)
#define _NULLOFF    ((void __based(void) *)0xffff)

/* types and structures */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

typedef int (__cdecl * _PNH)( size_t );
typedef int (__cdecl * _PNHH)( unsigned long, size_t );
typedef int (__cdecl * _PNHB)( __segment, size_t );

/* function prototypes */

_PNH __cdecl _set_new_handler( _PNH );
_PNH __cdecl _set_nnew_handler( _PNH );
_PNH __cdecl _set_fnew_handler( _PNH );
_PNHH __cdecl _set_hnew_handler( _PNHH );
_PNHB __cdecl _set_bnew_handler( _PNHB );

#else 

/* handler functions only supported in C++, emit appropriate error */
#error Functions declared in new.h can only be used in C++ source

#endif 

#define _INC_NEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\odbcinst.h ===
/*--------------------------------------------------------------------------
  ODBCInst.h -- Prototypes for ODBCINST.DLL

  (c) Microsoft Corp., 1990-1993
--------------------------------------------------------------------------*/

#ifndef __ODBCINST_H
#define __ODBCINST_H

#ifdef __cplusplus
extern "C" {                               // Assume C declarations for C++
#endif	// __cplusplus

#ifndef WINVER
#define  WINVER  0x300                     // Assume Windows 3.0
#endif

#if (WINVER < 0x30a)
// Win 3.1 Types -----------------------------------------------------------
typedef const char FAR*   LPCSTR;
#endif


// Constants ---------------------------------------------------------------
// SQLConfigDataSource request flags
#define  ODBC_ADD_DSN     1               // Add data source
#define  ODBC_CONFIG_DSN  2               // Configure (edit) data source
#define  ODBC_REMOVE_DSN  3               // Remove data source

#ifndef EXPORT
#define EXPORT _export
#endif

#ifndef RC_INVOKED
// Prototypes --------------------------------------------------------------
#ifdef WIN32
#define INSTAPI __stdcall
#else
#define INSTAPI EXPORT FAR PASCAL
#endif

#ifndef WIN32
#define SQLGetPrivateProfileString   GetPrivateProfileString
#define SQLWritePrivateProfileString WritePrivateProfileString
#endif

// High level APIs
BOOL INSTAPI SQLInstallODBC          (HWND       hwndParent,
                                      LPCSTR     lpszInfFile,
									  LPCSTR     lpszSrcPath,
									  LPCSTR     lpszDrivers);
BOOL INSTAPI SQLManageDataSources    (HWND       hwndParent);
BOOL INSTAPI SQLCreateDataSource     (HWND       hwndParent,
                                      LPCSTR     lpszDSN);
BOOL INSTAPI SQLGetTranslator        (HWND       hwnd,
									   LPSTR      lpszName,
									   WORD       cbNameMax,
									   WORD  FAR *pcbNameOut,
									   LPSTR      lpszPath,
									   WORD       cbPathMax,
									   WORD  FAR *pcbPathOut,
									   DWORD FAR *pvOption);

// Low level APIs
// NOTE: The high-level APIs should always be used. These APIs
//       have been left for compatibility.
BOOL INSTAPI SQLInstallDriver        (LPCSTR     lpszInfFile,
                                      LPCSTR     lpszDriver,
                                      LPSTR      lpszPath,
                                      WORD       cbPathMax,
                                      WORD FAR * pcbPathOut);
BOOL INSTAPI SQLInstallDriverManager (LPSTR      lpszPath,
                                      WORD       cbPathMax,
                                      WORD FAR * pcbPathOut);
BOOL INSTAPI SQLGetInstalledDrivers  (LPSTR      lpszBuf,
                                      WORD       cbBufMax,
                                      WORD FAR * pcbBufOut);
BOOL INSTAPI SQLGetAvailableDrivers  (LPCSTR     lpszInfFile,
                                      LPSTR      lpszBuf,
                                      WORD       cbBufMax,
                                      WORD FAR * pcbBufOut);
BOOL INSTAPI SQLConfigDataSource     (HWND       hwndParent,
                                      WORD       fRequest,
                                      LPCSTR     lpszDriver,
                                      LPCSTR     lpszAttributes);
BOOL INSTAPI SQLRemoveDefaultDataSource(void);
BOOL INSTAPI SQLWriteDSNToIni        (LPCSTR     lpszDSN,
                                      LPCSTR     lpszDriver);
BOOL INSTAPI SQLRemoveDSNFromIni     (LPCSTR     lpszDSN);
BOOL INSTAPI SQLValidDSN             (LPCSTR     lpszDSN);

#ifdef WIN32
BOOL INSTAPI SQLWritePrivateProfileString(LPCSTR lpszSection,
										 LPCSTR lpszEntry,
										 LPCSTR lpszString,
										 LPCSTR lpszFilename);

int  INSTAPI SQLGetPrivateProfileString( LPCSTR lpszSection,
										LPCSTR lpszEntry,
										LPCSTR lpszDefault,
										LPSTR  lpszRetBuffer,
										int    cbRetBuffer,
										LPCSTR lpszFilename);
#endif

//	Driver specific Setup APIs called by installer

BOOL INSTAPI ConfigDSN (HWND	hwndParent,
						WORD	fRequest,
						LPCSTR	lpszDriver,
						LPCSTR	lpszAttributes);

BOOL INSTAPI ConfigTranslator (	HWND		hwndParent,
								DWORD FAR  *pvOption);

#endif // RC_INVOKED

#ifdef __cplusplus
}                                    // End of extern "C" {
#endif	// __cplusplus

#endif // __ODBCINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\odbcver.h ===
/*--------------------------------------------------------------------------
  ODBCVer.h -- ODBC Version info
--------------------------------------------------------------------------*/


// Includes ----------------------------------------------------------------
#ifndef WIN32
#include  <ver.h>                         // Version defines
#endif


// Constants ---------------------------------------------------------------
#define VER_FILEVERSION 02,00,15,10
#define VER_FILEVERSION_STR " 2.00.1510\0"
#define VER_PRODUCTVERSION 02,00,15,10
#define VER_PRODUCTVERSION_STR " 2.00.1510\0"

#define VER_FILEFLAGSMASK (VS_FF_DEBUG | VS_FF_PRERELEASE)
#ifdef DEBUG
#define VER_FILEFLAGS (VS_FF_DEBUG)
#else
#define VER_FILEFLAGS (0)
#endif

#ifdef WIN32
#define	VER_FILEOS	VOS_NT_WINDOWS32
#else
#define VER_FILEOS  VOS_DOS_WINDOWS16
#endif

#define VER_COMPANYNAME_STR     "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR     "Microsoft Open Database Connectivity\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ole2dbg.h ===
/*
	ole2dbg.h:	This header file contains the function declarations for the publicly
	exported debugging interfaces.

	Include *after* standard OLE2 includes.
	
	Copyright (c) 1992-1993, Microsoft Corp. All rights reserved.
*/

#ifndef __OLE2DBG_H
#define __OLE2DBG_H

STDAPI_(void) DbgDumpObject( IUnknown FAR * pUnk, DWORD dwReserved);
STDAPI_(void) DbgDumpExternalObject( IUnknown FAR * pUnk, DWORD dwReserved );

STDAPI_(BOOL) DbgIsObjectValid( IUnknown FAR * pUnk );
STDAPI_(void) DbgDumpClassName( IUnknown FAR * pUnk );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ole1cls.h ===
/*****************************************************************************\
*                                                                             *
* ole1cls.h -   Master definition of GUIDs for OLE1 classes					  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* This file is the master definition of all GUIDs for OLE1 classes.
   
   All such GUIDs are of the form:

       0003xxxx-0000-0000-C000-000000000046

    The last parameter to DEFINE_OLE1GUID is the old 1.0 class name,
    i.e., its key in the registration database.

    Do not remove or change GUIDs.

    Do not add anything to this file except comments and DEFINE_OLE1GUID macros.
*/

#ifndef DEFINE_OLE1GUID
#define DEFINE_OLE1GUID(a,b,c,d,e) DEFINE_OLEGUID (a,b,c,d)
#endif
   
DEFINE_OLE1GUID(CLSID_ExcelWorksheet,   0x00030000, 0, 0, "ExcelWorksheet");
DEFINE_OLE1GUID(CLSID_ExcelChart,       0x00030001, 0, 0, "ExcelChart");
DEFINE_OLE1GUID(CLSID_ExcelMacrosheet,  0x00030002, 0, 0, "ExcelMacrosheet");
DEFINE_OLE1GUID(CLSID_WordDocument,     0x00030003, 0, 0, "WordDocument");
DEFINE_OLE1GUID(CLSID_MSPowerPoint,     0x00030004, 0, 0, "MSPowerPoint");
DEFINE_OLE1GUID(CLSID_MSPowerPointSho,  0x00030005, 0, 0, "MSPowerPointSho");
DEFINE_OLE1GUID(CLSID_MSGraph,          0x00030006, 0, 0, "MSGraph");
DEFINE_OLE1GUID(CLSID_MSDraw,               0x00030007, 0, 0, "MSDraw");
DEFINE_OLE1GUID(CLSID_Note_It,          0x00030008, 0, 0, "Note-It");
DEFINE_OLE1GUID(CLSID_WordArt,          0x00030009, 0, 0, "WordArt");
DEFINE_OLE1GUID(CLSID_PBrush,               0x0003000a, 0, 0, "PBrush");
DEFINE_OLE1GUID(CLSID_Equation,         0x0003000b, 0, 0, "Equation");
DEFINE_OLE1GUID(CLSID_Package,          0x0003000c, 0, 0, "Package");
DEFINE_OLE1GUID(CLSID_SoundRec,         0x0003000d, 0, 0, "SoundRec");
DEFINE_OLE1GUID(CLSID_MPlayer,          0x0003000e, 0, 0, "MPlayer");

/* test apps */
DEFINE_OLE1GUID(CLSID_ServerDemo,       0x0003000f, 0, 0, "ServerDemo");
DEFINE_OLE1GUID(CLSID_Srtest,               0x00030010, 0, 0, "Srtest");
DEFINE_OLE1GUID(CLSID_SrtInv,               0x00030011, 0, 0, "SrtInv");
DEFINE_OLE1GUID(CLSID_OleDemo,          0x00030012, 0, 0, "OleDemo");

/* External ISVs */
// Coromandel / Dorai Swamy / 718-793-7963
DEFINE_OLE1GUID(CLSID_CoromandelIntegra,    0x00030013, 0, 0, "CoromandelIntegra");
DEFINE_OLE1GUID(CLSID_CoromandelObjServer,0x00030014, 0, 0, "CoromandelObjServer");

// 3-d Visions Corp / Peter Hirsch / 310-325-1339
DEFINE_OLE1GUID(CLSID_StanfordGraphics, 0x00030015, 0, 0, "StanfordGraphics");

// Deltapoint / Nigel Hearne / 408-648-4000
DEFINE_OLE1GUID(CLSID_DGraphCHART,          0x00030016, 0, 0, "DGraphCHART");
DEFINE_OLE1GUID(CLSID_DGraphDATA,           0x00030017, 0, 0, "DGraphDATA");

// Corel / Richard V. Woodend / 613-728-8200 x1153
DEFINE_OLE1GUID(CLSID_PhotoPaint,           0x00030018, 0, 0, "PhotoPaint");
DEFINE_OLE1GUID(CLSID_CShow,                    0x00030019, 0, 0, "CShow");
DEFINE_OLE1GUID(CLSID_CorelChart,           0x0003001a, 0, 0, "CorelChart");
DEFINE_OLE1GUID(CLSID_CDraw,                    0x0003001b, 0, 0, "CDraw");

// Inset Systems / Mark Skiba / 203-740-2400
DEFINE_OLE1GUID(CLSID_HJWIN1_0,             0x0003001c, 0, 0, "HJWIN1.0");

// Mark V Systems / Mark McGraw / 818-995-7671
DEFINE_OLE1GUID(CLSID_ObjMakerOLE,          0x0003001d, 0, 0, "ObjMakerOLE");

// IdentiTech / Mike Gilger / 407-951-9503
DEFINE_OLE1GUID(CLSID_FYI,                      0x0003001e, 0, 0, "FYI");
DEFINE_OLE1GUID(CLSID_FYIView,                  0x0003001f, 0, 0, "FYIView");

// Inventa Corporation / Balaji Varadarajan / 408-987-0220
DEFINE_OLE1GUID(CLSID_Stickynote,       0x00030020, 0, 0, "Stickynote");

// ShapeWare Corp. / Lori Pearce / 206-467-6723
DEFINE_OLE1GUID(CLSID_ShapewareVISIO10, 0x00030021, 0, 0, "ShapewareVISIO10");
DEFINE_OLE1GUID(CLSID_ImportServer,     0x00030022, 0, 0, "ImportServer");


// test app SrTest
DEFINE_OLE1GUID(CLSID_SrvrTest,          0x00030023, 0, 0, "SrvrTest");

// Special clsid for when a 1.0 client pastes an embedded object
// that is a link.
// **This CLSID is obsolete. Do not reuse number.
//DEFINE_OLE1GUID(CLSID_10EmbedObj,        0x00030024, 0, 0, "OLE2_Embedded_Link");

// test app ClTest.  Doesn't really work as a server but is in reg db
DEFINE_OLE1GUID(CLSID_ClTest,            0x00030025, 0, 0, "Cltest");

// Microsoft ClipArt Gallery   Sherry Larsen-Holmes
DEFINE_OLE1GUID(CLSID_MS_ClipArt_Gallery,0x00030026, 0, 0, "MS_ClipArt_Gallery");

// Microsoft Project  Cory Reina
DEFINE_OLE1GUID(CLSID_MSProject,         0x00030027, 0, 0, "MSProject");

// Microsoft Works Chart
DEFINE_OLE1GUID(CLSID_MSWorksChart,      0x00030028, 0, 0, "MSWorksChart");

// Microsoft Works Spreadsheet
DEFINE_OLE1GUID(CLSID_MSWorksSpreadsheet,0x00030029, 0, 0, "MSWorksSpreadsheet");

// AFX apps - Dean McCrory
DEFINE_OLE1GUID(CLSID_MinSvr,            0x0003002A, 0, 0, "MinSvr");
DEFINE_OLE1GUID(CLSID_HierarchyList,     0x0003002B, 0, 0, "HierarchyList");
DEFINE_OLE1GUID(CLSID_BibRef,            0x0003002C, 0, 0, "BibRef");
DEFINE_OLE1GUID(CLSID_MinSvrMI,          0x0003002D, 0, 0, "MinSvrMI");
DEFINE_OLE1GUID(CLSID_TestServ,          0x0003002E, 0, 0, "TestServ");

// Ami Pro
DEFINE_OLE1GUID(CLSID_AmiProDocument,    0x0003002F, 0, 0, "AmiProDocument");

// WordPerfect Presentations For Windows
DEFINE_OLE1GUID(CLSID_WPGraphics,       0x00030030, 0, 0, "WPGraphics");
DEFINE_OLE1GUID(CLSID_WPCharts,         0x00030031, 0, 0, "WPCharts");


// MicroGrafx Charisma
DEFINE_OLE1GUID(CLSID_Charisma,         0x00030032, 0, 0, "Charisma");
DEFINE_OLE1GUID(CLSID_Charisma_30,      0x00030033, 0, 0, "Charisma_30");
DEFINE_OLE1GUID(CLSID_CharPres_30,      0x00030034, 0, 0, "CharPres_30");

// MicroGrafx Draw
DEFINE_OLE1GUID(CLSID_Draw,             0x00030035, 0, 0, "Draw");

// MicroGrafx Designer
DEFINE_OLE1GUID(CLSID_Designer_40,      0x00030036, 0, 0, "Designer_40");


#undef DEFINE_OLE1GUID

/* as we discover OLE 1 servers we will add them to the end of this list;
   there is room for 64K of them!
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ole2ver.h ===
#define rmj		0
#define rmm		23
#define rup		639
#define szVerName	""
#define szVerUser	"Y-OLEBLD"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ole2ui.h ===
/*
 * OLE2UI.H
 *
 * Published definitions, structures, types, and function prototypes for the
 * OLE 2.0 User Interface support library.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */

/* NOTE: All dialog and string resource ID's defined in this file are
 *    in the range:
 *          32248 - 32504   (0x7DF8 - 0x7EF8)
*/


#ifndef _OLE2UI_H_
#define _OLE2UI_H_

#ifndef RC_INVOKED
#pragma message ("Including OLE2UI.H from " __FILE__)
#endif  //RC_INVOKED

#ifdef WIN32
#define _INC_OLE
#define __RPC_H__
#endif

#if !defined(__cplusplus) && !defined( __TURBOC__)
#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H)
#endif

#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <string.h>
#include <dlgs.h>           //For fileopen dlg; standard include
#include "olestd.h"

#ifdef __TURBOC__
#define _getcwd getcwd
#define _itoa   itoa
#define __max   max
#define _find_t find_t
#endif // __TURBOC__

#ifdef WIN32
#define _fmemset memset
#define _fmemcpy memcpy
#define _fmemcmp memcmp
#define _fstrcpy strcpy
#define _fstrlen strlen
#define _fstrrchr strrchr
#define _fstrtok strtok
#define lstrcpyn strncpy

// BUGBUG32: isspace function does not seem to work properly
#undef isspace
#define isspace(j) (j==' ' || j=='\t' || j=='\n')
#endif  // WIN32

#if !defined( EXPORT )
#ifdef WIN32
#define EXPORT
#else
#define EXPORT  __export
#endif  // WIN32
#endif  // !EXPORT

/*
 * Initialization / Uninitialization routines.  OleUIInitialize
 * must be called prior to using any functions in OLE2UI, and OleUIUnInitialize
 * must be called before you app shuts down and when you are done using the
 * library.
 *
 * NOTE:  If you are using the DLL version of this library, these functions
 * are automatically called in the DLL's LibMain and WEP, so you should
 * not call them directly from your application.
 */

// Backward compatibility with older library
#define OleUIUninitialize OleUIUnInitialize

STDAPI_(BOOL) OleUIInitialize(HINSTANCE hInstance, HINSTANCE hPrevInst);
STDAPI_(BOOL) OleUIUninitialize(void);

#if !defined( SZCLASSICONBOX )
#define SZCLASSICONBOX  "ole2uiIBCls"
#endif

#if !defined( SZCLASSRESULTIMAGE )
#define SZCLASSRESULTIMAGE  "ole2uiRICls"
#endif

// object count, used to support DllCanUnloadNow and OleUICanUnloadNow
extern DWORD g_dwObjectCount;

STDAPI OleUICanUnloadNow(void);
STDAPI OleUILockLibrary(BOOL fLock);


//Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT        32248
#define IDD_CHANGEICON          32249
#define IDD_CONVERT             32250
#define IDD_PASTESPECIAL        32251
#define IDD_EDITLINKS           32252
#define IDD_FILEOPEN            32253
#define IDD_BUSY                32254
#define IDD_UPDATELINKS         32255
#define IDD_CANNOTUPDATELINK    32256
#define IDD_CHANGESOURCE        32257
#define IDD_INSERTFILEBROWSE    32258
#define IDD_CHANGEICONBROWSE    32259

// The following Dialogs are message dialogs used by OleUIPromptUser API
#define IDD_LINKSOURCEUNAVAILABLE   32260
#define IDD_SERVERNOTREG        32261
#define IDD_LINKTYPECHANGED     32262
#define IDD_SERVERNOTFOUND      32263
#define IDD_OUTOFMEMORY         32264

// Stringtable identifers
#define IDS_OLE2UIUNKNOWN       32300
#define IDS_OLE2UILINK          32301
#define IDS_OLE2UIOBJECT        32302
#define IDS_OLE2UIEDIT          32303
#define IDS_OLE2UICONVERT       32304
#define IDS_OLE2UIEDITLINKCMD_1VERB     32305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   32306
#define IDS_OLE2UIEDITLINKCMD_NVERB     32307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   32308
#define IDS_OLE2UIEDITNOOBJCMD  32309
// def. icon label (usu. "Document")
#define IDS_DEFICONLABEL        32310
#define IDS_OLE2UIPASTELINKEDTYPE  32311


#define IDS_FILTERS             32320
#define IDS_ICONFILTERS         32321
#define IDS_BROWSE              32322

//Resource identifiers for bitmaps
#define IDB_RESULTSEGA                  32325
#define IDB_RESULTSVGA                  32326
#define IDB_RESULTSHIRESVGA             32327


//Missing from windows.h
#ifndef PVOID
typedef VOID *PVOID;
#endif


//Hook type used in all structures.
typedef UINT (CALLBACK *LPFNOLEUIHOOK)(HWND, UINT, WPARAM, LPARAM);


//Strings for registered messages
#define SZOLEUI_MSG_HELP                "OLEUI_MSG_HELP"
#define SZOLEUI_MSG_ENDDIALOG           "OLEUI_MSG_ENDDIALOG"
#define SZOLEUI_MSG_BROWSE              "OLEUI_MSG_BROWSE"
#define SZOLEUI_MSG_CHANGEICON          "OLEUI_MSG_CHANGEICON"
#define SZOLEUI_MSG_CLOSEBUSYDIALOG     "OLEUI_MSG_CLOSEBUSYDIALOG"
#define SZOLEUI_MSG_FILEOKSTRING        "OLEUI_MSG_FILEOKSTRING"

//Standard error definitions
#define OLEUI_FALSE                     0
#define OLEUI_SUCCESS                   1     //No error, same as OLEUI_OK
#define OLEUI_OK                        1     //OK button pressed
#define OLEUI_CANCEL                    2     //Cancel button pressed

#define OLEUI_ERR_STANDARDMIN           100
#define OLEUI_ERR_STRUCTURENULL         101   //Standard field validation
#define OLEUI_ERR_STRUCTUREINVALID      102
#define OLEUI_ERR_CBSTRUCTINCORRECT     103
#define OLEUI_ERR_HWNDOWNERINVALID      104
#define OLEUI_ERR_LPSZCAPTIONINVALID    105
#define OLEUI_ERR_LPFNHOOKINVALID       106
#define OLEUI_ERR_HINSTANCEINVALID      107
#define OLEUI_ERR_LPSZTEMPLATEINVALID   108
#define OLEUI_ERR_HRESOURCEINVALID      109

#define OLEUI_ERR_FINDTEMPLATEFAILURE   110   //Initialization errors
#define OLEUI_ERR_LOADTEMPLATEFAILURE   111
#define OLEUI_ERR_DIALOGFAILURE         112
#define OLEUI_ERR_LOCALMEMALLOC         113
#define OLEUI_ERR_GLOBALMEMALLOC        114
#define OLEUI_ERR_LOADSTRING            115

#define OLEUI_ERR_STANDARDMAX           116   //Start here for specific errors.



//Help Button Identifier
#define ID_OLEUIHELP                    99

// Help button for fileopen.dlg  (need this for resizing) 1038 is pshHelp
#define IDHELP  1038

// Static text control (use this instead of -1 so things work correctly for
// localization
#define  ID_STATIC                      98

//Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX                 256  // make any changes to this in geticon.c too

//Maximum verb length and length of Object menu
#define OLEUI_CCHVERBMAX                32
#define OLEUI_OBJECTMENUMAX             256

//Maximum MS-DOS pathname.
#define OLEUI_CCHPATHMAX                256 // make any changes to this in geticon.c too
#define OLEUI_CCHFILEMAX                13

//Icon label length
#define OLEUI_CCHLABELMAX               40  // make any changes to this in geticon.c too

//Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING            39


/*
 * What follows here are first function prototypes for general utility
 * functions, then sections laid out by dialog.  Each dialog section
 * defines the dialog structure, the API prototype, flags for the dwFlags
 * field, the dialog-specific error values, and dialog control IDs (for
 * hooks and custom templates.
 */


//Miscellaneous utility functions.
STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
							 LPSTR lpszShortType,
							 HMENU hMenu,
							 UINT uPos,
							 UINT uIDVerbMin,
							 UINT uIDVerbMax,
							 BOOL bAddConvert,
							 UINT idConvert,
							 HMENU FAR *lphMenu);

//Metafile utility functions
STDAPI_(HGLOBAL) OleUIMetafilePictFromIconAndLabel(HICON, LPSTR, LPSTR, UINT);
STDAPI_(void)    OleUIMetafilePictIconFree(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictIconDraw(HDC, LPRECT, HGLOBAL, BOOL);
STDAPI_(UINT)    OleUIMetafilePictExtractLabel(HGLOBAL, LPSTR, UINT, LPDWORD);
STDAPI_(HICON)   OleUIMetafilePictExtractIcon(HGLOBAL);
STDAPI_(BOOL)    OleUIMetafilePictExtractIconSource(HGLOBAL,LPSTR,UINT FAR *);





/*************************************************************************
** INSERT OBJECT DIALOG
*************************************************************************/


typedef struct tagOLEUIINSERTOBJECT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIINSERTOBJECT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Return space for class ID
	LPSTR           lpszFile;         //Filename for inserts or links
	UINT            cchFile;          //Size of lpszFile buffer: OLEUI_CCHPATHMAX
	UINT            cClsidExclude;    //IN only:  CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //List of CLSIDs to exclude from listing.

	//Specific to create objects if flags say so
	IID             iid;              //Requested interface on creation.
	DWORD           oleRender;        //Rendering option
	LPFORMATETC     lpFormatEtc;      //Desired format
	LPOLECLIENTSITE lpIOleClientSite; //Site to be use for the object.
	LPSTORAGE       lpIStorage;       //Storage used for the object
	LPVOID FAR     *ppvObj;           //Where the object is returned.
	SCODE           sc;               //Result of creation calls.
	HGLOBAL         hMetaPict;        //OUT: METAFILEPICT containing iconic aspect.
									  //IFF we couldn't stuff it in the cache.
	} OLEUIINSERTOBJECT, *POLEUIINSERTOBJECT, FAR *LPOLEUIINSERTOBJECT;

//API prototype
STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT);


//Insert Object flags
#define IOF_SHOWHELP                0x00000001L
#define IOF_SELECTCREATENEW         0x00000002L
#define IOF_SELECTCREATEFROMFILE    0x00000004L
#define IOF_CHECKLINK               0x00000008L
#define IOF_CHECKDISPLAYASICON      0x00000010L
#define IOF_CREATENEWOBJECT         0x00000020L
#define IOF_CREATEFILEOBJECT        0x00000040L
#define IOF_CREATELINKOBJECT        0x00000080L
#define IOF_DISABLELINK             0x00000100L
#define IOF_VERIFYSERVERSEXIST      0x00000200L
#define IOF_DISABLEDISPLAYASICON    0x00000400L


//Insert Object specific error codes
#define OLEUI_IOERR_LPSZFILEINVALID         (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_LPSZLABELINVALID        (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_HICONINVALID            (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_IOERR_LPFORMATETCINVALID      (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_IOERR_PPVOBJINVALID           (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_IOERR_LPIOLECLIENTSITEINVALID (OLEUI_ERR_STANDARDMAX+5)
#define OLEUI_IOERR_LPISTORAGEINVALID       (OLEUI_ERR_STANDARDMAX+6)
#define OLEUI_IOERR_SCODEHASERROR           (OLEUI_ERR_STANDARDMAX+7)
#define OLEUI_IOERR_LPCLSIDEXCLUDEINVALID   (OLEUI_ERR_STANDARDMAX+8)
#define OLEUI_IOERR_CCHFILEINVALID          (OLEUI_ERR_STANDARDMAX+9)


//Insert Object Dialog identifiers
#define ID_IO_CREATENEW                 2100
#define ID_IO_CREATEFROMFILE            2101
#define ID_IO_LINKFILE                  2102
#define ID_IO_OBJECTTYPELIST            2103
#define ID_IO_DISPLAYASICON             2104
#define ID_IO_CHANGEICON                2105
#define ID_IO_FILE                      2106
#define ID_IO_FILEDISPLAY               2107
#define ID_IO_RESULTIMAGE               2108
#define ID_IO_RESULTTEXT                2109
#define ID_IO_ICONDISPLAY               2110
#define ID_IO_OBJECTTYPETEXT            2111
#define ID_IO_FILETEXT                  2112
#define ID_IO_FILETYPE                  2113

// Strings in OLE2UI resources
#define IDS_IORESULTNEW                 32400
#define IDS_IORESULTNEWICON             32401
#define IDS_IORESULTFROMFILE1           32402
#define IDS_IORESULTFROMFILE2           32403
#define IDS_IORESULTFROMFILEICON2       32404
#define IDS_IORESULTLINKFILE1           32405
#define IDS_IORESULTLINKFILE2           32406
#define IDS_IORESULTLINKFILEICON1       32407
#define IDS_IORESULTLINKFILEICON2       32408

/*************************************************************************
** PASTE SPECIAL DIALOG
*************************************************************************/

// Maximum number of link types
#define     PS_MAXLINKTYPES  8

//NOTE: OLEUIPASTEENTRY and OLEUIPASTEFLAG structs are defined in OLESTD.H

typedef struct tagOLEUIPASTESPECIAL
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUIPASTESPECIAL.

	//IN  fields
	LPDATAOBJECT    lpSrcDataObj;       //Source IDataObject* (on the
										// clipboard) for data to paste

	LPOLEUIPASTEENTRY arrPasteEntries;  //OLEUIPASTEENTRY array which
										// specifies acceptable formats. See
										// OLEUIPASTEENTRY for more info.
	int             cPasteEntries;      //No. of OLEUIPASTEENTRY array entries

	UINT        FAR *arrLinkTypes;      //List of link types that are
										// acceptable. Link types are referred
										// to using OLEUIPASTEFLAGS in
										// arrPasteEntries
	int             cLinkTypes;         //Number of link types
	UINT            cClsidExclude;      //Number of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;     //List of CLSIDs to exclude from list.

	//OUT fields
	int             nSelectedIndex;     //Index of arrPasteEntries[] that the
										// user selected
	BOOL            fLink;              //Indicates if Paste or Paste Link was
										// selected by the user
	HGLOBAL         hMetaPict;          //Handle to Metafile containing icon
										// and icon title selected by the user
										// Use the Metafile utility functions
										// defined in this header to
										// manipulate hMetaPict
	SIZEL           sizel;              // size of object/link in its source
										//  if the display aspect chosen by
										//  the user matches the aspect
										//  displayed in the source. if
										//  different aspect is chosen then
										//  sizel.cx=sizel.cy=0 is returned.
										//  sizel displayed in source is
										//  retrieved from the
										//  ObjectDescriptor if fLink is FALSE
										//  LinkSrcDescriptor if fLink is TRUE
	} OLEUIPASTESPECIAL, *POLEUIPASTESPECIAL, FAR *LPOLEUIPASTESPECIAL;


//API to bring up PasteSpecial dialog
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL);


//Paste Special flags
// Show Help button. IN flag.
#define PSF_SHOWHELP                0x00000001L

//Select Paste radio button at dialog startup. This is the default if
// PSF_SELECTPASTE or PSF_SELECTPASTELINK are not specified. Also specifies
// state of button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTE             0x00000002L

//Select PasteLink radio button at dialog startup. Also specifies state of
// button on dialog termination. IN/OUT flag.
#define PSF_SELECTPASTELINK         0x00000004L

//Specfies if DisplayAsIcon button was checked on dialog termination. OUT flag
#define PSF_CHECKDISPLAYASICON      0x00000008L
#define PSF_DISABLEDISPLAYASICON    0x00000010L


//Paste Special specific error codes
#define OLEUI_IOERR_SRCDATAOBJECTINVALID      (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_IOERR_ARRPASTEENTRIESINVALID    (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_IOERR_ARRLINKTYPESINVALID       (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_PSERR_CLIPBOARDCHANGED          (OLEUI_ERR_STANDARDMAX+3)

//Paste Special Dialog identifiers
#define ID_PS_PASTE                    500
#define ID_PS_PASTELINK                501
#define ID_PS_SOURCETEXT               502
#define ID_PS_PASTELIST                503
#define ID_PS_PASTELINKLIST            504
#define ID_PS_DISPLAYLIST              505
#define ID_PS_DISPLAYASICON            506
#define ID_PS_ICONDISPLAY              507
#define ID_PS_CHANGEICON               508
#define ID_PS_RESULTIMAGE              509
#define ID_PS_RESULTTEXT               510
#define ID_PS_RESULTGROUP              511
#define ID_PS_STXSOURCE                512
#define ID_PS_STXAS                    513

// Paste Special String IDs
#define IDS_PSPASTEDATA                32410
#define IDS_PSPASTEOBJECT              32411
#define IDS_PSPASTEOBJECTASICON        32412
#define IDS_PSPASTELINKDATA            32413
#define IDS_PSPASTELINKOBJECT          32414
#define IDS_PSPASTELINKOBJECTASICON    32415
#define IDS_PSNONOLE                   32416
#define IDS_PSUNKNOWNTYPE              32417
#define IDS_PSUNKNOWNSRC               32418
#define IDS_PSUNKNOWNAPP               32419


/*************************************************************************
** EDIT LINKS DIALOG
*************************************************************************/



/* IOleUILinkContainer Interface
** -----------------------------
**    This interface must be implemented by container applications that
**    want to use the EditLinks dialog. the EditLinks dialog calls back
**    to the container app to perform the OLE functions to manipulate
**    the links within the container.
*/

#define LPOLEUILINKCONTAINER     IOleUILinkContainer FAR*

#undef  INTERFACE
#define INTERFACE   IOleUILinkContainer

DECLARE_INTERFACE_(IOleUILinkContainer, IUnknown)
{
	//*** IUnknown methods ***/
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef) (THIS) PURE;
	STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD_(DWORD,GetNextLink) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(SetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD dwUpdateOpt) PURE;
	STDMETHOD(GetLinkUpdateOptions) (THIS_ DWORD dwLink, DWORD FAR* lpdwUpdateOpt) PURE;
	STDMETHOD(SetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR       lpszDisplayName,
			ULONG       lenFileName,
			ULONG FAR*  pchEaten,
			BOOL        fValidateSource) PURE;
	STDMETHOD(GetLinkSource) (THIS_
			DWORD       dwLink,
			LPSTR FAR*  lplpszDisplayName,
			ULONG FAR*  lplenFileName,
			LPSTR FAR*  lplpszFullLinkType,
			LPSTR FAR*  lplpszShortLinkType,
			BOOL FAR*   lpfSourceAvailable,
			BOOL FAR*   lpfIsSelected) PURE;
	STDMETHOD(OpenLinkSource) (THIS_ DWORD dwLink) PURE;
	STDMETHOD(UpdateLink) (THIS_
			DWORD dwLink,
			BOOL fErrorMessage,
			BOOL fErrorAction) PURE;
	STDMETHOD(CancelLink) (THIS_ DWORD dwLink) PURE;
};


typedef struct tagOLEUIEDITLINKS
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.

	LPOLEUILINKCONTAINER lpOleUILinkContainer;  //IN: Interface to manipulate
												//links in the container
	} OLEUIEDITLINKS, *POLEUIEDITLINKS, FAR *LPOLEUIEDITLINKS;


//API Prototype
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS);


// Edit Links flags
#define ELF_SHOWHELP                0x00000001L
#define ELF_DISABLEUPDATENOW        0x00000002L
#define ELF_DISABLEOPENSOURCE       0x00000004L
#define ELF_DISABLECHANGESOURCE     0x00000008L
#define ELF_DISABLECANCELLINK       0x00000010L

// Edit Links Dialog identifiers
#define ID_EL_CHANGESOURCE             201
#define ID_EL_AUTOMATIC                202
#define ID_EL_CLOSE                    208
#define ID_EL_CANCELLINK               209
#define ID_EL_UPDATENOW                210
#define ID_EL_OPENSOURCE               211
#define ID_EL_MANUAL                   212
#define ID_EL_LINKSOURCE               216
#define ID_EL_LINKTYPE                 217
#define ID_EL_UPDATE                   218
#define ID_EL_NULL                     -1
#define ID_EL_LINKSLISTBOX             206
#define ID_EL_COL1                     220
#define ID_EL_COL2                     221
#define ID_EL_COL3                     222



/*************************************************************************
** CHANGE ICON DIALOG
*************************************************************************/

typedef struct tagOLEUICHANGEICON
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;       //Structure Size
	DWORD           dwFlags;        //IN-OUT:  Flags
	HWND            hWndOwner;      //Owning window
	LPCSTR          lpszCaption;    //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;       //Hook callback
	LPARAM          lCustData;      //Custom data to pass to hook
	HINSTANCE       hInstance;      //Instance for customized template name
	LPCSTR          lpszTemplate;   //Customized template name
	HRSRC           hResource;      //Customized template handle

	//Specifics for OLEUICHANGEICON.  All are IN-OUT unless otherwise spec.
	HGLOBAL         hMetaPict;      //Current and final image.  Source of the
									//icon is embedded in the metafile itself.
	CLSID           clsid;          //IN only: class used to get Default icon
	char            szIconExe[OLEUI_CCHPATHMAX];
	int             cchIconExe;
	} OLEUICHANGEICON, *POLEUICHANGEICON, FAR *LPOLEUICHANGEICON;


//API prototype
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON);


//Change Icon flags
#define CIF_SHOWHELP                0x00000001L
#define CIF_SELECTCURRENT           0x00000002L
#define CIF_SELECTDEFAULT           0x00000004L
#define CIF_SELECTFROMFILE          0x00000008L
#define CIF_USEICONEXE              0x0000000aL


//Change Icon specific error codes
#define OLEUI_CIERR_MUSTHAVECLSID           (OLEUI_ERR_STANDARDMAX+0)
#define OLEUI_CIERR_MUSTHAVECURRENTMETAFILE (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CIERR_SZICONEXEINVALID        (OLEUI_ERR_STANDARDMAX+2)


//Change Icon Dialog identifiers
#define ID_GROUP                    120
#define ID_CURRENT                  121
#define ID_CURRENTICON              122
#define ID_DEFAULT                  123
#define ID_DEFAULTICON              124
#define ID_FROMFILE                 125
#define ID_FROMFILEEDIT             126
#define ID_ICONLIST                 127
#define ID_LABEL                    128
#define ID_LABELEDIT                129
#define ID_BROWSE                   130
#define ID_RESULTICON               132
#define ID_RESULTLABEL              133

// Stringtable defines for Change Icon
#define IDS_CINOICONSINFILE         32430
#define IDS_CIINVALIDFILE           32431
#define IDS_CIFILEACCESS            32432
#define IDS_CIFILESHARE             32433
#define IDS_CIFILEOPENFAIL          32434



/*************************************************************************
** CONVERT DIALOG
*************************************************************************/

typedef struct tagOLEUICONVERT
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUICONVERT.  All are IN-OUT unless otherwise spec.
	CLSID           clsid;            //Class ID sent in to dialog: IN only
	CLSID           clsidConvertDefault;  //Class ID to use as convert default: IN only
	CLSID           clsidActivateDefault;  //Class ID to use as activate default: IN only

	CLSID           clsidNew;         //Selected Class ID: OUT only
	DWORD           dvAspect;         //IN-OUT, either DVASPECT_CONTENT or
									  //DVASPECT_ICON
	WORD            wFormat;          //Original data format
	BOOL            fIsLinkedObject;  //IN only; true if object is linked
	HGLOBAL         hMetaPict;        //IN-OUT: METAFILEPICT containing iconic aspect.
	LPSTR           lpszUserType;     //IN-OUT: user type name of original class.
									  //  We'll do lookup if it's NULL.
									  //  This gets freed on exit.
	BOOL            fObjectsIconChanged;  // OUT; TRUE if ChangeIcon was called (and not cancelled)
	LPSTR           lpszDefLabel;     //IN-OUT: default label to use for icon.
									  //  if NULL, the short user type name
									  //  will be used. if the object is a
									  //  link, the caller should pass the
									  //  DisplayName of the link source
									  //  This gets freed on exit.

	UINT            cClsidExclude;    //IN: No. of CLSIDs in lpClsidExclude
	LPCLSID         lpClsidExclude;   //IN: List of CLSIDs to exclude from list
	} OLEUICONVERT, *POLEUICONVERT, FAR *LPOLEUICONVERT;


//API prototype
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT);

// Determine if there is at least one class that can Convert or ActivateAs
// the given clsid.
STDAPI_(BOOL) OleUICanConvertOrActivateAs(
		REFCLSID    rClsid,
		BOOL        fIsLinkedObject,
		WORD        wFormat
);

//Convert Dialog flags

// IN only: Shows "HELP" button
#define CF_SHOWHELPBUTTON          0x00000001L

// IN only: lets you set the convert default object - the one that is
// selected as default in the convert listbox.
#define CF_SETCONVERTDEFAULT       0x00000002L


// IN only: lets you set the activate default object - the one that is
// selected as default in the activate listbox.

#define CF_SETACTIVATEDEFAULT       0x00000004L


// IN/OUT: Selects the "Convert To" radio button, is set on exit if
// this button was selected
#define CF_SELECTCONVERTTO         0x00000008L

// IN/OUT: Selects the "Activate As" radio button, is set on exit if
// this button was selected
#define CF_SELECTACTIVATEAS        0x00000010L
#define CF_DISABLEDISPLAYASICON    0x00000020L
#define CF_DISABLEACTIVATEAS       0x00000040L


//Convert specific error codes
#define OLEUI_CTERR_CLASSIDINVALID      (OLEUI_ERR_STANDARDMAX+1)
#define OLEUI_CTERR_DVASPECTINVALID     (OLEUI_ERR_STANDARDMAX+2)
#define OLEUI_CTERR_CBFORMATINVALID     (OLEUI_ERR_STANDARDMAX+3)
#define OLEUI_CTERR_HMETAPICTINVALID    (OLEUI_ERR_STANDARDMAX+4)
#define OLEUI_CTERR_STRINGINVALID       (OLEUI_ERR_STANDARDMAX+5)


//Convert Dialog identifiers
#define IDCV_OBJECTTYPE             150
#define IDCV_DISPLAYASICON          152
#define IDCV_CHANGEICON             153
#define IDCV_ACTIVATELIST           154
#define IDCV_CONVERTTO              155
#define IDCV_ACTIVATEAS             156
#define IDCV_RESULTTEXT             157
#define IDCV_CONVERTLIST            158
#define IDCV_ICON                   159
#define IDCV_ICONLABEL1             160
#define IDCV_ICONLABEL2             161
#define IDCV_STXCURTYPE             162
#define IDCV_GRPRESULT              163
#define IDCV_STXCONVERTTO           164

// String IDs for Convert dialog
#define IDS_CVRESULTCONVERTLINK     32440
#define IDS_CVRESULTCONVERTTO       32441
#define IDS_CVRESULTNOCHANGE        32442
#define IDS_CVRESULTDISPLAYASICON   32443
#define IDS_CVRESULTACTIVATEAS      32444
#define IDS_CVRESULTACTIVATEDIFF    32445


/*************************************************************************
** BUSY DIALOG
*************************************************************************/

typedef struct tagOLEUIBUSY
	{
	//These IN fields are standard across all OLEUI dialog functions.
	DWORD           cbStruct;         //Structure Size
	DWORD           dwFlags;          //IN-OUT:  Flags ** NOTE ** this dialog has no flags
	HWND            hWndOwner;        //Owning window
	LPCSTR          lpszCaption;      //Dialog caption bar contents
	LPFNOLEUIHOOK   lpfnHook;         //Hook callback
	LPARAM          lCustData;        //Custom data to pass to hook
	HINSTANCE       hInstance;        //Instance for customized template name
	LPCSTR          lpszTemplate;     //Customized template name
	HRSRC           hResource;        //Customized template handle

	//Specifics for OLEUIBUSY.
	HTASK           hTask;            //IN: HTask which is blocking
	HWND FAR *      lphWndDialog;     //IN: Dialog's HWND is placed here
	} OLEUIBUSY, *POLEUIBUSY, FAR *LPOLEUIBUSY;

//API prototype
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY);

// Flags for this dialog

// IN only: Disables "Cancel" button
#define BZ_DISABLECANCELBUTTON          0x00000001L

// IN only: Disables "Switch To..." button
#define BZ_DISABLESWITCHTOBUTTON        0x00000002L

// IN only: Disables "Retry" button
#define BZ_DISABLERETRYBUTTON           0x00000004L

// IN only: Generates a "Not Responding" dialog as opposed to the
// "Busy" dialog.  The wording in the text is slightly different, and
// the "Cancel" button is grayed out if you set this flag.
#define BZ_NOTRESPONDINGDIALOG          0x00000008L

// Busy specific error/return codes
#define OLEUI_BZERR_HTASKINVALID     (OLEUI_ERR_STANDARDMAX+0)

// SWITCHTOSELECTED is returned when user hit "switch to"
#define OLEUI_BZ_SWITCHTOSELECTED    (OLEUI_ERR_STANDARDMAX+1)

// RETRYSELECTED is returned when user hit "retry"
#define OLEUI_BZ_RETRYSELECTED       (OLEUI_ERR_STANDARDMAX+2)

// CALLUNBLOCKED is returned when call has been unblocked
#define OLEUI_BZ_CALLUNBLOCKED       (OLEUI_ERR_STANDARDMAX+3)

// Busy dialog identifiers
#define IDBZ_RETRY                      600
#define IDBZ_ICON                       601
#define IDBZ_MESSAGE1                   602
#define IDBZ_SWITCHTO                   604

// Busy dialog stringtable defines
#define IDS_BZRESULTTEXTBUSY            32447
#define IDS_BZRESULTTEXTNOTRESPONDING   32448

// Links dialog stringtable defines
#define IDS_LINK_AUTO           32450
#define IDS_LINK_MANUAL         32451
#define IDS_LINK_UNKNOWN        32452
#define IDS_LINKS               32453
#define IDS_FAILED              32454
#define IDS_CHANGESOURCE        32455
#define IDS_INVALIDSOURCE       32456
#define IDS_ERR_GETLINKSOURCE   32457
#define IDS_ERR_GETLINKUPDATEOPTIONS    32458
#define IDS_ERR_ADDSTRING       32459
#define IDS_CHANGEADDITIONALLINKS   32460
#define IDS_CLOSE               32461


/*************************************************************************
** PROMPT USER DIALOGS
*************************************************************************/
#define ID_PU_LINKS             900
#define ID_PU_TEXT              901
#define ID_PU_CONVERT           902
#define ID_PU_BROWSE            904
#define ID_PU_METER             905
#define ID_PU_PERCENT           906
#define ID_PU_STOP              907

// used for -1 ids in dialogs:
#define ID_DUMMY    999

/* inside ole2ui.c */
#ifdef __cplusplus
extern "C"
#endif
int EXPORT FAR CDECL OleUIPromptUser(WORD nTemplate, HWND hwndParent, ...);

#define UPDATELINKS_STARTDELAY  2000    // Delay before 1st link updates
										//  to give the user a chance to
										//  dismiss the dialog before any
										//  links update.

STDAPI_(BOOL) OleUIUpdateLinks(
		LPOLEUILINKCONTAINER lpOleUILinkCntr,
		HWND hwndParent,
		LPSTR lpszTitle,
		int cLinks);


/*************************************************************************
** OLE OBJECT FEEDBACK EFFECTS
*************************************************************************/

#define OLEUI_HANDLES_USEINVERSE    0x00000001L
#define OLEUI_HANDLES_NOBORDER      0x00000002L
#define OLEUI_HANDLES_INSIDE        0x00000004L
#define OLEUI_HANDLES_OUTSIDE       0x00000008L


#define OLEUI_SHADE_FULLRECT        1
#define OLEUI_SHADE_BORDERIN        2
#define OLEUI_SHADE_BORDEROUT       3

/* objfdbk.c function prototypes */
STDAPI_(void) OleUIDrawHandles(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cSize, BOOL fDraw);
STDAPI_(void) OleUIDrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth);
STDAPI_(void) OleUIShowObject(LPCRECT lprc, HDC hdc, BOOL fIsLink);


/*************************************************************************
** Hatch window definitions and prototypes                              **
*************************************************************************/
#define DEFAULT_HATCHBORDER_WIDTH   4

STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst);
STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst);
STDAPI_(UINT) GetHatchWidth(HWND hWndHatch);
STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lpHatchRect);
STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect);
STDAPI_(void) SetHatchWindowSize(
		HWND        hWndHatch,
		LPRECT      lprcIPObjRect,
		LPRECT      lprcClipRect,
		LPPOINT     lpptOffset
);



/*************************************************************************
** VERSION VERIFICATION INFORMATION
*************************************************************************/

// The following magic number is used to verify that the resources we bind
// to our EXE are the same "version" as the LIB (or DLL) file which
// contains these routines.  This is not the same as the Version information
// resource that we place in OLE2UI.RC, this is a special ID that we will
// have compiled in to our EXE.  Upon initialization of OLE2UI, we will
// look in our resources for an RCDATA called "VERIFICATION" (see OLE2UI.RC),
// and make sure that the magic number there equals the magic number below.

#define OLEUI_VERSION_MAGIC 0x4D42

#endif  //_OLE2UI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ole2.h ===
/*****************************************************************************\
*                                                                             *
* ole2.h - 		Main OLE2 header; includes all subcomponents				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _OLE2_H_ )
#define _OLE2_H_

#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif  /* RC_INVOKED */

#include <string.h>

/****** Standard Object Definitions *****************************************/

#include <compobj.h>


// *************** FACILITY_ITF scodes common to all interfaces ************
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//

// error codes

#define OLE_E_OLEVERB               (OLE_E_FIRST)
// invalid OLEVERB structure  

#define OLE_E_ADVF                  (OLE_E_FIRST+1)
// invalid advise flags

#define OLE_E_ENUM_NOMORE           (OLE_E_FIRST+2)
// you can't enuemrate any more, because the associated data is missing

#define OLE_E_ADVISENOTSUPPORTED    (OLE_E_FIRST+3)
// this implementation doesn't take advises

#define OLE_E_NOCONNECTION          (OLE_E_FIRST+4)
// there is no connection for this connection id

#define OLE_E_NOTRUNNING            (OLE_E_FIRST+5)
// need run the object to perform this operation

#define OLE_E_NOCACHE               (OLE_E_FIRST+6)
// there is no cache to operate on

#define OLE_E_BLANK                 (OLE_E_FIRST+7)
// Uninitialized object

#define OLE_E_CLASSDIFF             (OLE_E_FIRST+8)
// linked object's source class has changed 

#define OLE_E_CANT_GETMONIKER       (OLE_E_FIRST+9)
// not able to get the moniker of the object

#define OLE_E_CANT_BINDTOSOURCE     (OLE_E_FIRST+10)
// not able to bind to the source

#define OLE_E_STATIC                (OLE_E_FIRST+11)
// object is static, operation not allowed

#define OLE_E_PROMPTSAVECANCELLED   (OLE_E_FIRST+12)
// user cancelled out of save dialog

#define OLE_E_INVALIDRECT           (OLE_E_FIRST+13)
// invalid rectangle 

#define OLE_E_WRONGCOMPOBJ          (OLE_E_FIRST+14)
// compobj.dll is too old for the ole2.dll initialized

#define OLE_E_INVALIDHWND           (OLE_E_FIRST+15)
// invalid window handle

#define OLE_E_NOT_INPLACEACTIVE     (OLE_E_FIRST+16)
// object is not in any of the inplace active states  

#define OLE_E_CANTCONVERT			(OLE_E_FIRST+17)
// not able to convert the object 

#define OLE_E_NOSTORAGE				(OLE_E_FIRST+18)
// not able to perform the operation because object is not given storage yet.
 

#define DVGEN_E_FIRST               (OLE_E_FIRST+100)

#define DV_E_FORMATETC              (DVGEN_E_FIRST)
// invalid FORMATETC structure

#define DV_E_DVTARGETDEVICE         (DVGEN_E_FIRST+1)
// invalid DVTARGETDEVICE structure

#define DV_E_STGMEDIUM              (DVGEN_E_FIRST+2)
// invalid STDGMEDIUM structure

#define DV_E_STATDATA               (DVGEN_E_FIRST+3)
// invalid STATDATA structure

#define DV_E_LINDEX                 (DVGEN_E_FIRST+4)
// invalid lindex

#define DV_E_TYMED                  (DVGEN_E_FIRST+5)
// invalid tymed

#define DV_E_CLIPFORMAT             (DVGEN_E_FIRST+6)
// invalid clipboard format

#define DV_E_DVASPECT               (DVGEN_E_FIRST+7)
// invalid aspect(s) 

#define DV_E_DVTARGETDEVICE_SIZE    (DVGEN_E_FIRST+8)
// tdSize paramter of the DVTARGETDEVICE structure is invalid

#define DV_E_NOIVIEWOBJECT          (DVGEN_E_FIRST+9)
// object doesn't support IViewObject interface


// Success codes

#define OLE_S_USEREG                (OLE_S_FIRST)
// use the reg database to provide the requested info

#define OLE_S_STATIC                (OLE_S_FIRST+1)
// success, but static 

#define OLE_S_MAC_CLIPFORMAT        (OLE_S_FIRST+2)
// macintosh clipboard format

//*************************** Interface or API specific scodes *************

// Errors for OleConvertOLESTREAMToIStorage and OleConvertIStorageToOLESTREAM

// OLESTREAM Get method failed
#define CONVERT10_E_OLESTREAM_GET       (CONVERT10_E_FIRST + 0)

// OLESTREAM Put method failed
#define CONVERT10_E_OLESTREAM_PUT       (CONVERT10_E_FIRST + 1)

// Contents of the OLESTREAM not in correct format
#define CONVERT10_E_OLESTREAM_FMT       (CONVERT10_E_FIRST + 2)

// There was in an error in a Windows GDI call while converting the bitmap
// to a DIB.
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB (CONVERT10_E_FIRST + 3)

// Contents of the IStorage not in correct format
#define CONVERT10_E_STG_FMT             (CONVERT10_E_FIRST + 4)

// Contents of IStorage is missing one of the standard streams ("\1CompObj", 
// "\1Ole", "\2OlePres000").  This may be the storage for a DLL object, or a
// class that does not use the def handler.
#define CONVERT10_E_STG_NO_STD_STREAM   (CONVERT10_E_FIRST + 5)

// There was in an error in a Windows GDI call while converting the DIB
// to a bitmap.
#define CONVERT10_E_STG_DIB_TO_BITMAP   (CONVERT10_E_FIRST + 6)


// Returned by either API, this scode indicates that the original object
//  had no presentation, therefore the converted object does not either.
#define CONVERT10_S_NO_PRESENTATION     (CONVERT10_S_FIRST + 0)


// Errors for Clipboard functions

// OpenClipboard Failed
#define CLIPBRD_E_CANT_OPEN     (CLIPBRD_E_FIRST + 0)

// EmptyClipboard Failed
#define CLIPBRD_E_CANT_EMPTY        (CLIPBRD_E_FIRST + 1)

// SetClipboard Failed
#define CLIPBRD_E_CANT_SET          (CLIPBRD_E_FIRST + 2)

// Data on clipboard is invalid
#define CLIPBRD_E_BAD_DATA          (CLIPBRD_E_FIRST + 3)

// CloseClipboard Failed
#define CLIPBRD_E_CANT_CLOSE        (CLIPBRD_E_FIRST + 4)


/****** OLE value types *****************************************************/

/* rendering options */
typedef enum tagOLERENDER
{
    OLERENDER_NONE   = 0, 
    OLERENDER_DRAW   = 1, 
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS   = 3
} OLERENDER;
typedef  OLERENDER FAR* LPOLERENDER;

// OLE verb; returned by IEnumOLEVERB
typedef struct FARSTRUCT tagOLEVERB
{
    LONG    lVerb;
    LPSTR   lpszVerbName;
    DWORD   fuFlags;
    DWORD	grfAttribs;
} OLEVERB, FAR* LPOLEVERB;


// Bitwise verb attributes used in OLEVERB.grfAttribs
typedef enum tagOLEVERBATTRIB // bitwise
{
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2
} OLEVERBATTRIB;


// IOleObject::GetUserType optons; determines which form of the string to use
typedef enum tagUSERCLASSTYPE
{
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT= 2,
    USERCLASSTYPE_APPNAME= 3,
} USERCLASSTYPE;


// bits returned from IOleObject::GetMistStatus
typedef enum tagOLEMISC // bitwise
{
    OLEMISC_RECOMPOSEONRESIZE				= 1,
    OLEMISC_ONLYICONIC						= 2,
    OLEMISC_INSERTNOTREPLACE				= 4,
    OLEMISC_STATIC							= 8,
    OLEMISC_CANTLINKINSIDE					= 16,
    OLEMISC_CANLINKBYOLE1					= 32,
    OLEMISC_ISLINKOBJECT					= 64,
    OLEMISC_INSIDEOUT						= 128,
    OLEMISC_ACTIVATEWHENVISIBLE				= 256,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT	= 512	
} OLEMISC;


// IOleObject::Close options
typedef enum tagOLECLOSE
{
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE      = 1,
    OLECLOSE_PROMPTSAVE  = 2
} OLECLOSE;


// IOleObject::GetMoniker and IOleClientSite::GetMoniker options; determines
// if and how monikers should be assigned.
typedef enum tagOLEGETMONIKER
{
    OLEGETMONIKER_ONLYIFTHERE=1,
    OLEGETMONIKER_FORCEASSIGN=2,
    OLEGETMONIKER_UNASSIGN=3,
    OLEGETMONIKER_TEMPFORUSER=4 
} OLEGETMONIKER;


// IOleObject::GetMoniker, IOleObject::SetMoniker and 
// IOleClientSite::GetMoniker options; determines which moniker to use
typedef enum tagOLEWHICHMK
{
    OLEWHICHMK_CONTAINER=1,
    OLEWHICHMK_OBJREL=2,
    OLEWHICHMK_OBJFULL=3
} OLEWHICHMK;


#ifdef WIN32
#define LPSIZEL PSIZEL
#else
typedef struct FARSTRUCT tagSIZEL
{
    long cx;
    long cy;
} SIZEL, FAR* LPSIZEL;
#endif


#ifdef WIN32
#define LPRECTL PRECTL
#else
typedef struct FARSTRUCT tagRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
} RECTL, FAR* LPRECTL;

typedef struct FARSTRUCT tagPOINTL {
    LONG x;
    LONG y;
} POINTL;

#endif
   

#ifndef LPCRECT
typedef const RECT FAR* LPCRECT;
#endif

#ifndef LPCRECTL
typedef const RECTL FAR* LPCRECTL;
#endif


// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L // role is handler; implementation is 
										 // default handler; pCF can be NULL
#define EMBDHLP_INPROC_SERVER    0x0001L // role is server; pCF can't be NULL

#define EMBDHLP_CREATENOW    0x00000000L // create using pCF immediately; if pCF
										 // is NULL, uses std remoting handler
#define EMBDHLP_DELAYCREATE  0x00010000L // delayed create; must supply pCF


// NOTE: OleCreateEmbeddingHelper(clsid, pUnkOuter, 
// 		EMBDHLP_INPROC_HANDLER | EMBDHLP_CREATENOW, NULL, riid, lplpObj) 
// is the same as OleCreateDefaultHandler(clsid, pUnkOuter, riid, lplpObj);
// i.e., the embedding helper is the default handler in various roles.


/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM FAR*  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;


/****** Clipboard Data structures *****************************************/

typedef struct tagOBJECTDESCRIPTOR
{
   ULONG    cbSize;              // Size of structure in bytes
   CLSID    clsid;               // CLSID of data being transferred
   DWORD    dwDrawAspect;        // Display aspect of the object
                                 //     normally DVASPECT_CONTENT or ICON.
                                 //     dwDrawAspect will be 0 (which is NOT
                                 //     DVASPECT_CONTENT) if the copier or 
                                 //     dragsource didn't draw the object to 
                                 //     begin with.
   SIZEL    sizel;               // size of the object in HIMETRIC
                                 //    sizel is opt.: will be (0,0) for apps
                                 //    which don't draw the object being
                                 //    transferred
   POINTL   pointl;              // Offset in HIMETRIC units from the
                                 //    upper-left corner of the obj where the
                                 //    mouse went down for the drag.
                                 //    NOTE: y coordinates increase downward.
                                 //          x coordinates increase to right
                                 //    pointl is opt.; it is only meaningful 
                                 //    if object is transfered via drag/drop.
                                 //    (0, 0) if mouse position is unspecified
                                 //    (eg. when obj transfered via clipboard)
   DWORD    dwStatus;            // Misc. status flags for object. Flags are 
                                 //    defined by OLEMISC enum. these flags 
                                 //    are as would be returned
                                 //    by IOleObject::GetMiscStatus.
   DWORD    dwFullUserTypeName;  // Offset from beginning of structure to 
                                 //    null-terminated string that specifies 
                                 //    Full User Type Name of the object. 
                                 //    0 indicates string not present.
   DWORD    dwSrcOfCopy;         // Offset from beginning of structure to 
                                 //    null-terminated string that specifies
                                 //    source of the transfer. 
                                 //    dwSrcOfCOpy is normally implemented as 
                                 //    the display name of the temp-for-user 
                                 //    moniker which identifies the source of 
                                 //    the data. 
                                 //    0 indicates string not present.
                                 //    NOTE: moniker assignment is NOT forced.
                                 //    see IOleObject::GetMoniker(
                                 //                OLEGETMONIKER_TEMPFORUSER)

 /* variable sized string data may appear here */

} OBJECTDESCRIPTOR,  *POBJECTDESCRIPTOR,  FAR *LPOBJECTDESCRIPTOR,
  LINKSRCDESCRIPTOR, *PLINKSRCDESCRIPTOR, FAR *LPLINKSRCDESCRIPTOR;



/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)


//      forward type declarations
#if defined(__cplusplus)
interface IOleClientSite;
interface IOleContainer;
interface IOleObject;
#else 
typedef interface IOleClientSite IOleClientSite;
typedef interface IOleContainer IOleContainer;
typedef interface IOleObject IOleObject;
#endif

typedef         IOleObject FAR* LPOLEOBJECT;
typedef     IOleClientSite FAR* LPOLECLIENTSITE;
typedef       IOleContainer FAR* LPOLECONTAINER;


/****** OLE GUIDs *********************************************************/

#ifndef INITGUID
#include "oleguid.h"
#endif


/****** Other Major Interfaces ********************************************/

#include <dvobj.h>

#include <storage.h>



/****** IDrop??? Interfaces ********************************************/

#define MK_ALT 0x0020


#define DROPEFFECT_NONE     0
#define DROPEFFECT_COPY     1
#define DROPEFFECT_MOVE     2
#define DROPEFFECT_LINK     4
#define DROPEFFECT_SCROLL   0x80000000

// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
#define DD_DEFSCROLLINSET		11

// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
#define DD_DEFSCROLLDELAY		50

// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval",
//                              DD_DEFSCROLLINTERVAL)
#define DD_DEFSCROLLINTERVAL	50

// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
#define DD_DEFDRAGDELAY     	200

// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
#define DD_DEFDRAGMINDIST		2



/* Dragdrop specific error codes */

#define DRAGDROP_E_NOTREGISTERED        (DRAGDROP_E_FIRST)
// trying to revoke a drop target that has not been registered 

#define DRAGDROP_E_ALREADYREGISTERED    (DRAGDROP_E_FIRST+1)
// this window has already been registered as a drop target

#define DRAGDROP_E_INVALIDHWND          (DRAGDROP_E_FIRST+2)
// invalid HWND


#define DRAGDROP_S_DROP                 (DRAGDROP_S_FIRST + 0)
// successful drop took place 

#define DRAGDROP_S_CANCEL               (DRAGDROP_S_FIRST + 1)
// drag-drop operation canceled

#define DRAGDROP_S_USEDEFAULTCURSORS    (DRAGDROP_S_FIRST + 2)
// use the default cursor


#undef INTERFACE
#define INTERFACE   IDropTarget

DECLARE_INTERFACE_(IDropTarget, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragOver) (THIS_ DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
    STDMETHOD(DragLeave) (THIS) PURE;
    STDMETHOD(Drop) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect) PURE;
};
typedef         IDropTarget FAR* LPDROPTARGET;



#undef INTERFACE
#define INTERFACE   IDropSource

DECLARE_INTERFACE_(IDropSource, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropSource methods ***
    STDMETHOD(QueryContinueDrag) (THIS_ BOOL fEscapePressed, DWORD grfKeyState) PURE;
    STDMETHOD(GiveFeedback) (THIS_ DWORD dwEffect) PURE;
};
typedef         IDropSource FAR* LPDROPSOURCE;



/****** IPersist??? Interfaces ********************************************/


#undef INTERFACE
#define INTERFACE   IPersist

DECLARE_INTERFACE_(IPersist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
};
typedef            IPersist FAR* LPPERSIST;



#undef INTERFACE
#define INTERFACE   IPersistStorage

DECLARE_INTERFACE_(IPersistStorage, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStorage methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(InitNew) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Load) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Save) (THIS_ LPSTORAGE pStgSave, BOOL fSameAsLoad) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPSTORAGE pStgNew) PURE;
    STDMETHOD(HandsOffStorage) (THIS) PURE; 
};
typedef         IPersistStorage FAR* LPPERSISTSTORAGE;



#undef INTERFACE
#define INTERFACE   IPersistStream

DECLARE_INTERFACE_(IPersistStream, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR* pcbSize) PURE;
};
typedef          IPersistStream FAR* LPPERSISTSTREAM;



#undef INTERFACE
#define INTERFACE   IPersistFile

DECLARE_INTERFACE_(IPersistFile, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
    
    // *** IPersistFile methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPCSTR lpszFileName, DWORD grfMode) PURE;
    STDMETHOD(Save) (THIS_ LPCSTR lpszFileName, BOOL fRemember) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPCSTR lpszFileName) PURE;
    STDMETHOD(GetCurFile) (THIS_ LPSTR FAR* lplpszFileName) PURE;
};
typedef            IPersistFile FAR* LPPERSISTFILE;

  
/****** Moniker Object Interfaces ******************************************/

#include <moniker.h>


/****** OLE Object Interfaces ******************************************/
  
 
#undef  INTERFACE
#define INTERFACE   IEnumOLEVERB

DECLARE_INTERFACE_(IEnumOLEVERB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumOLEVERB FAR* FAR* ppenm) PURE;
};
typedef         IEnumOLEVERB FAR* LPENUMOLEVERB;




#undef  INTERFACE
#define INTERFACE   IOleObject

#define OLEOBJ_E_NOVERBS                (OLEOBJ_E_FIRST + 0)

#define OLEOBJ_E_INVALIDVERB            (OLEOBJ_E_FIRST + 1)

#define OLEOBJ_S_INVALIDVERB            (OLEOBJ_S_FIRST + 0)

#define OLEOBJ_S_CANNOT_DOVERB_NOW      (OLEOBJ_S_FIRST + 1)
// verb number is valid but verb cannot be done now, for instance
// hiding a link or hiding a visible OLE 1.0 server

#define OLEOBJ_S_INVALIDHWND            (OLEOBJ_S_FIRST + 2)
// invalid hwnd passed


DECLARE_INTERFACE_(IOleObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite) (THIS_ LPOLECLIENTSITE pClientSite) PURE;
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR* ppClientSite) PURE;
    STDMETHOD(SetHostNames) (THIS_ LPCSTR szContainerApp, LPCSTR szContainerObj) PURE;
    STDMETHOD(Close) (THIS_ DWORD dwSaveOption) PURE;
    STDMETHOD(SetMoniker) (THIS_ DWORD dwWhichMoniker, LPMONIKER pmk) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(InitFromData) (THIS_ LPDATAOBJECT pDataObject,
                BOOL fCreation,
                DWORD dwReserved) PURE;
    STDMETHOD(GetClipboardData) (THIS_ DWORD dwReserved, 
                LPDATAOBJECT FAR* ppDataObject) PURE;
    STDMETHOD(DoVerb) (THIS_ LONG iVerb,
                LPMSG lpmsg, 
                LPOLECLIENTSITE pActiveSite, 
                LONG lindex,
                HWND hwndParent,
                LPCRECT lprcPosRect) PURE;
    STDMETHOD(EnumVerbs) (THIS_ LPENUMOLEVERB FAR* ppenumOleVerb) PURE;
    STDMETHOD(Update) (THIS) PURE;
    STDMETHOD(IsUpToDate) (THIS) PURE;
    STDMETHOD(GetUserClassID) (THIS_ CLSID FAR* pClsid) PURE;
    STDMETHOD(GetUserType) (THIS_ DWORD dwFormOfType, LPSTR FAR* pszUserType) PURE;
    STDMETHOD(SetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LPSIZEL lpsizel) PURE;

    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
    STDMETHOD(GetMiscStatus) (THIS_ DWORD dwAspect, DWORD FAR* pdwStatus) PURE;
    STDMETHOD(SetColorScheme) (THIS_ LPLOGPALETTE lpLogpal) PURE;
};
typedef      IOleObject FAR* LPOLEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleClientSite

DECLARE_INTERFACE_(IOleClientSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject) (THIS) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer) PURE;   
    STDMETHOD(ShowObject) (THIS) PURE;  
    STDMETHOD(OnShowWindow) (THIS_ BOOL fShow) PURE;    
    STDMETHOD(RequestNewObjectLayout) (THIS) PURE;      
};
typedef      IOleClientSite FAR* LPOLECLIENTSITE;


/****** OLE Runnable Object Interface **********************************/

#undef  INTERFACE
#define INTERFACE	IRunnableObject

DECLARE_INTERFACE_(IRunnableObject, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IRunnableObject methods ***
    STDMETHOD(GetRunningClass) (THIS_ LPCLSID lpClsid) PURE;
    STDMETHOD(Run) (THIS_ LPBINDCTX pbc) PURE;
    STDMETHOD_(BOOL, IsRunning) (THIS) PURE;
	STDMETHOD(LockRunning)(THIS_ BOOL fLock, BOOL fLastUnlockCloses) PURE;
	STDMETHOD(SetContainedObject)(THIS_ BOOL fContained) PURE;
};
typedef      IRunnableObject FAR* LPRUNNABLEOBJECT;


/****** OLE Container Interfaces ***************************************/
  

#undef  INTERFACE
#define INTERFACE   IParseDisplayName

DECLARE_INTERFACE_(IParseDisplayName, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;
};
typedef       IParseDisplayName FAR* LPPARSEDISPLAYNAME;


#undef  INTERFACE
#define INTERFACE   IOleContainer

DECLARE_INTERFACE_(IOleContainer, IParseDisplayName)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) ( DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
};
typedef IOleContainer FAR* LPOLECONTAINER;


typedef enum tagBINDSPEED
{
    BINDSPEED_INDEFINITE    = 1,
    BINDSPEED_MODERATE      = 2,
    BINDSPEED_IMMEDIATE     = 3
} BINDSPEED;

typedef enum tagOLECONTF
{
    OLECONTF_EMBEDDINGS     =  1,
    OLECONTF_LINKS          =  2,
    OLECONTF_OTHERS         =  4,
    OLECONTF_ONLYUSER       =  8,
    OLECONTF_ONLYIFRUNNING  = 16
} OLECONTF;


#undef  INTERFACE
#define INTERFACE   IOleItemContainer

DECLARE_INTERFACE_(IOleItemContainer, IOleContainer)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) (THIS_ DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
    
    // *** IOleItemContainer methods ***
    STDMETHOD(GetObject) (THIS_ LPSTR lpszItem, DWORD dwSpeedNeeded,
        LPBINDCTX pbc, REFIID riid, LPVOID FAR* ppvObject) PURE;
    STDMETHOD(GetObjectStorage) (THIS_ LPSTR lpszItem, LPBINDCTX pbc,
        REFIID riid, LPVOID FAR* ppvStorage) PURE;
    STDMETHOD(IsRunning) (THIS_ LPSTR lpszItem) PURE;
};
typedef       IOleItemContainer FAR* LPOLEITEMCONTAINER;


/****** OLE Advise Holder Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IOleAdviseHolder

DECLARE_INTERFACE_(IOleAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD(SendOnSave)(THIS) PURE;
    STDMETHOD(SendOnClose)(THIS) PURE;
};
typedef      IOleAdviseHolder FAR* LPOLEADVISEHOLDER;


/****** OLE Link Interface ************************************************/

/* Link update options */
typedef enum tagOLEUPDATE
{
    OLEUPDATE_ALWAYS=1,
    OLEUPDATE_ONCALL=3
} OLEUPDATE;
typedef  OLEUPDATE FAR* LPOLEUPDATE;


// for IOleLink::BindToSource
typedef enum tagOLELINKBIND
{
    OLELINKBIND_EVENIFCLASSDIFF = 1,
} OLELINKBIND;


#undef  INTERFACE
#define INTERFACE   IOleLink

DECLARE_INTERFACE_(IOleLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleLink methods ***
    STDMETHOD(SetUpdateOptions) (THIS_ DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetUpdateOptions) (THIS_ LPDWORD pdwUpdateOpt) PURE;
    STDMETHOD(SetSourceMoniker) (THIS_ LPMONIKER pmk, REFCLSID rclsid) PURE;
    STDMETHOD(GetSourceMoniker) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(SetSourceDisplayName) (THIS_ LPCSTR lpszDisplayName) PURE;
    STDMETHOD(GetSourceDisplayName) (THIS_ LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(BindToSource) (THIS_ DWORD bindflags, LPBINDCTX pbc) PURE;
    STDMETHOD(BindIfRunning) (THIS) PURE;
    STDMETHOD(GetBoundSource) (THIS_ LPUNKNOWN FAR* ppUnk) PURE;
    STDMETHOD(UnbindSource) (THIS) PURE;
    STDMETHOD(Update) (THIS_ LPBINDCTX pbc) PURE;
};
typedef         IOleLink FAR* LPOLELINK;


/****** OLE InPlace Editing Interfaces ************************************/
  
#ifdef _MAC
typedef Handle  HOLEMENU;
typedef long    SIZE;
typedef long    HACCEL;
#else
DECLARE_HANDLE(HOLEMENU);
#endif  

typedef struct FARSTRUCT tagOIFI          // OleInPlaceFrameInfo
{
    UINT    cb;
    BOOL    fMDIApp;
    HWND    hwndFrame;
    HACCEL  haccel;
    int     cAccelEntries;
} OLEINPLACEFRAMEINFO, FAR* LPOLEINPLACEFRAMEINFO;


typedef struct FARSTRUCT tagOleMenuGroupWidths
{
    LONG    width[6];
} OLEMENUGROUPWIDTHS, FAR* LPOLEMENUGROUPWIDTHS;

typedef RECT    BORDERWIDTHS;
typedef LPRECT  LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;

/* Inplace editing specific error codes */

#define INPLACE_E_NOTUNDOABLE   (INPLACE_E_FIRST)
// undo is not avaiable

#define INPLACE_E_NOTOOLSPACE       (INPLACE_E_FIRST+1)
// Space for tools is not available

#define INPLACE_S_TRUNCATED     (INPLACE_S_FIRST)
// Message is too long, some of it had to be truncated before displaying

//misc definitions
#define INPLACE_DEFBORDERWIDTH	4

//      forward type declarations
#if defined(__cplusplus)
interface IOleInPlaceUIWindow;
#else 
typedef interface IOleInPlaceUIWindow IOleInPlaceUIWindow;
#endif

typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;


#undef  INTERFACE
#define INTERFACE   IOleWindow

DECLARE_INTERFACE_(IOleWindow, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
};

typedef         IOleWindow FAR* LPOLEWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceObject

DECLARE_INTERFACE_(IOleInPlaceObject, IOleWindow)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceObject methods ***
    STDMETHOD(InPlaceDeactivate) (THIS) PURE;   
    STDMETHOD(UIDeactivate) (THIS) PURE;
    STDMETHOD(SetObjectRects) (THIS_ LPCRECT lprcPosRect, 
                    LPCRECT lprcClipRect) PURE;
    STDMETHOD(ReactivateAndUndo) (THIS) PURE;   
};
typedef         IOleInPlaceObject FAR* LPOLEINPLACEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceActiveObject

DECLARE_INTERFACE_(IOleInPlaceActiveObject, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceActiveObject methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;   
    STDMETHOD(OnFrameWindowActivate) (THIS_ BOOL fActivate) PURE;           
    STDMETHOD(OnDocWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(ResizeBorder) (THIS_ LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow) PURE;          
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};
typedef         IOleInPlaceActiveObject FAR* LPOLEINPLACEACTIVEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceUIWindow

DECLARE_INTERFACE_(IOleInPlaceUIWindow, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                        LPCSTR lpszObjName) PURE; 
};
typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceFrame

DECLARE_INTERFACE_(IOleInPlaceFrame, IOleInPlaceUIWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                    LPCSTR lpszObjName) PURE; 
    
    
    // *** IOleInPlaceFrame methods ***
    STDMETHOD(InsertMenus) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenu) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenus) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusText) (THIS_ LPCSTR lpszStatusText) PURE;    
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg, WORD wID) PURE;
};
typedef     IOleInPlaceFrame FAR* LPOLEINPLACEFRAME;


#undef  INTERFACE
#define INTERFACE   IOleInPlaceSite

DECLARE_INTERFACE_(IOleInPlaceSite, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceSite methods ***
    STDMETHOD(CanInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnUIActivate) (THIS) PURE;    
    STDMETHOD(GetWindowContext) (THIS_ LPOLEINPLACEFRAME FAR* lplpFrame,
                        LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                        LPRECT lprcPosRect,
                        LPRECT lprcClipRect,
                        LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
    STDMETHOD(Scroll) (THIS_ SIZE scrollExtent) PURE;       
    STDMETHOD(OnUIDeactivate) (THIS_ BOOL fUndoable) PURE;      
    STDMETHOD(OnInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(DiscardUndoState) (THIS) PURE;
    STDMETHOD(DeactivateAndUndo) (THIS) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ LPCRECT lprcPosRect) PURE; 
};
typedef         IOleInPlaceSite FAR* LPOLEINPLACESITE;



/****** OLE API Prototypes ************************************************/

STDAPI_(DWORD) OleBuildVersion( VOID );

/* helper functions */
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid);
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid);
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid);
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPSTR lpszUserType);
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPSTR FAR* lplpszUserType);


/* init/term */

STDAPI OleInitialize(LPMALLOC pMalloc);
STDAPI_(void) OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from 
   the data object */

STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);
                    

/* Object creation APIs */

STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt, 
                LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite, 
                LPSTORAGE pStg, LPVOID FAR* ppvObj); 

STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid, 
                DWORD renderopt, LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);    

                
STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);
            
STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite, 
            LPVOID FAR* ppvObj);
            
STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
STDAPI  RevokeDragDrop(HWND hwnd);
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj);
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);
STDAPI  OleFlushClipboard(void);
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

STDAPI_(HOLEMENU)   OleCreateMenuDescriptor (HMENU hmenuCombined, 
                                LPOLEMENUGROUPWIDTHS lpMenuWidths);
STDAPI              OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
STDAPI              OleDestroyMenuDescriptor (HOLEMENU holemenu);

STDAPI              OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame, 
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);
                                
                                    
/* Helper APIs */
STDAPI_(HANDLE) OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat, 
                        UINT uiFlags);

STDAPI          OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, 
                    LPCRECT lprcBounds); 
                        
STDAPI          OleRun(LPUNKNOWN pUnknown);
STDAPI_(BOOL)   OleIsRunning(LPOLEOBJECT pObject);
STDAPI          OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);

STDAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM);
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder);

STDAPI          OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    REFIID riid, LPVOID FAR* lplpObj);

STDAPI          OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    DWORD flags, LPCLASSFACTORY pCF,
					REFIID riid, LPVOID FAR* lplpObj);
					
STDAPI_(BOOL)	IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, 
					WORD FAR* lpwCmd);

					
/* Icon extraction Helper APIs */
					
STDAPI_(HGLOBAL) OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel);

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid,	LPSTR lpszLabel, 
					BOOL fUseTypeAsLabel);

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPSTR lpszLabel,
					LPSTR lpszSourceFile, UINT iIconIndex);


					
/* Registration Database Helper APIs */

STDAPI 			OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
					LPSTR FAR* pszUserType);

STDAPI 			OleRegGetMiscStatus	(REFCLSID clsid, DWORD dwAspect,
					DWORD FAR* pdwStatus);

STDAPI 			OleRegEnumFormatEtc	(REFCLSID clsid, DWORD dwDirection,
					LPENUMFORMATETC FAR* ppenum);

STDAPI 			OleRegEnumVerbs	(REFCLSID clsid, LPENUMOLEVERB FAR* ppenum);



/* OLE 1.0 conversion APIS */

STDAPI OleConvertIStorageToOLESTREAM
    (LPSTORAGE			pstg,
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                polestm,
     LPSTORAGE                  pstg,
     const DVTARGETDEVICE FAR*  ptd);

STDAPI OleConvertIStorageToOLESTREAMEx
    (LPSTORAGE			pstg,
									// Presentation data to OLESTREAM
	 CLIPFORMAT			cfFormat,	//		format
	 LONG				lWidth,		//		width
	 LONG				lHeight,	//		height
	 DWORD				dwSize,		//		size in bytes
     LPSTGMEDIUM		pmedium,	//		bits
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorageEx
    (LPOLESTREAM		polestm,
	 LPSTORAGE			pstg,
									// Presentation data from OLESTREAM
	 CLIPFORMAT FAR*	pcfFormat,	//		format
	 LONG FAR*			plwWidth,	//		width
	 LONG FAR*			plHeight,	//		height
	 DWORD FAR*			pdwSize,	//		size in bytes
	 LPSTGMEDIUM		pmedium);	//		bits



/* Storage Utility APIs */
STDAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL FAR* phglobal);
STDAPI CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES FAR* pplkbyt);

STDAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL FAR* phglobal);
STDAPI CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM FAR* ppstm);


/* ConvertTo APIS */

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);
STDAPI GetConvertStg(LPSTORAGE pStg);
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


#endif // _OLE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\olenls.h ===
/***
*olenls.h - National language support functions.
*
*  Copyright (C) 1992-1993, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*  This describes the NLSAPI functions for Win16.  This is a subset
*  of Win32 NLSAPI, and is a non-Unicode version.
*
*Implementation Notes:
*  This files is largely ported from the Win32 header winnls.h.
*
*****************************************************************************/

#ifndef _OLENLS_
#define _OLENLS_

#ifndef NONLS

#ifdef __cplusplus
extern "C" {
#endif


#ifndef EXTERN_C
# ifdef __cplusplus
#  define EXTERN_C extern "C"
# else
#  define EXTERN_C extern
# endif
#endif

#ifdef _MAC
# ifndef FAR
#  define FAR
# endif
# ifdef _MSC_VER
#  define NLSAPI_(TYPE) EXTERN_C TYPE __pascal
# else
#  define NLSAPI_(TYPE) EXTERN_C pascal TYPE
# endif
#else
# define NLSAPI_(TYPE) EXTERN_C TYPE WINAPI
#endif


/***************************************************************************\
* Constants
*
* Define all constants for the NLS component here.
\***************************************************************************/

/*
 *  Character Type Flags.
 */
#define CT_CTYPE1            0x00000001     /* ctype 1 information */
#define CT_CTYPE2            0x00000002     /* ctype 2 information */
#define CT_CTYPE3            0x00000004     /* ctype 3 information */

/*
 *  CType 1 Flag Bits.
 */
#define C1_UPPER             0x0001         /* upper case */
#define C1_LOWER             0x0002         /* lower case */
#define C1_DIGIT             0x0004         /* decimal digits */
#define C1_SPACE             0x0008         /* spacing characters */
#define C1_PUNCT             0x0010         /* punctuation characters */
#define C1_CNTRL             0x0020         /* control characters */
#define C1_BLANK             0x0040         /* blank characters */
#define C1_XDIGIT            0x0080         /* other digits */
#define C1_ALPHA             0x0100         /* any letter */

/*
 *  CType 2 Flag Bits.
 */
#define C2_LEFTTORIGHT       0x1            /* left to right */
#define C2_RIGHTTOLEFT       0x2            /* right to left */

#define C2_EUROPENUMBER      0x3            /* European number, digit */
#define C2_EUROPESEPARATOR   0x4            /* European numeric separator */
#define C2_EUROPETERMINATOR  0x5            /* European numeric terminator */
#define C2_ARABICNUMBER      0x6            /* Arabic number */
#define C2_COMMONSEPARATOR   0x7            /* common numeric separator */

#define C2_BLOCKSEPARATOR    0x8            /* block separator */
#define C2_SEGMENTSEPARATOR  0x9            /* segment separator */
#define C2_WHITESPACE        0xA            /* white space */
#define C2_OTHERNEUTRAL      0xB            /* other neutrals */

#define C2_NOTAPPLICABLE     0x0            /* no implicit directionality */

/*
 *  CType 3 Flag Bits.
 */
#define C3_NONSPACING        0x0001         /* nonspacing character */
#define C3_DIACRITIC         0x0002         /* diacritic mark */
#define C3_VOWELMARK         0x0004         /* vowel mark */
#define C3_SYMBOL            0x0008         /* symbols */

#define C3_KATAKANA          0x0010
#define C3_HIRAGANA          0x0020
#define C3_HALFWIDTH         0x0040
#define C3_FULLWIDTH         0x0080
#define C3_IDEOGRAPH         0x0100
#define C3_JAPANACCENT       0x0200

#define C3_NOTAPPLICABLE     0x0            /* ctype 3 is not applicable */


/*
 *  String Flags.
 */
#define NORM_IGNORECASE         0x00000001  /* ignore case */
#define NORM_IGNORENONSPACE     0x00000002  /* ignore nonspacing chars */
#define NORM_IGNORESYMBOLS      0x00000004  /* ignore symbols */

#define NORM_IGNOREWIDTH        0x00000008  /* ignore width */
#define NORM_IGNOREKANATYPE     0x00000040  /* ignore kanatype */
#define NORM_IGNOREJAPANACCENT  0x00000080  /* ignore Japanese accent marks */

#define NORM_IGNOREKASHIDA      0x00040000  /* ignore Arabic kashida chars */


/*
 *  Locale Dependent Mapping Flags.
 */
#define LCMAP_LOWERCASE      0x00000100 /* lower case letters */
#define LCMAP_UPPERCASE      0x00000200 /* upper case letters */
#define LCMAP_SORTKEY        0x00000400 /* WC sort key (normalize) */

#define LCMAP_HALFWIDTH      0x00000800  /* narrow pitch case letters */
#define LCMAP_FULLWIDTH      0x00001000  /* wide picth case letters */ 
#define LCMAP_HIRAGANA       0x00002000  /* map katakana to hiragana */
#define LCMAP_KATAKANA       0x00004000  /* map hiragana to katakana */


/*
 *  Language IDs.
 *
 *  The following two combinations of primary language ID and
 *  sublanguage ID have special semantics: 
 *
 *    Primary Language ID   Sublanguage ID      Result
 *    -------------------   ---------------     ------------------------
 *    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
 *    LANG_NEUTRAL          SUBLANG_DEFAULT     Process default language
 *    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language	 
 */

/*
 *  Primary language IDs.
 */
#define LANG_NEUTRAL                     0x00

#define LANG_ALBANIAN                    0x1c
#define LANG_ARABIC                      0x01
#define LANG_BAHASA                      0x21
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HEBREW                      0x0d
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_RHAETO_ROMAN                0x17
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SERBO_CROATIAN              0x1a
#define LANG_SLOVAK                      0x1b
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_THAI                        0x1e
#define LANG_TURKISH                     0x1f
#define LANG_URDU                        0x20

/*
 *  Sublanguage IDs.
 *
 *  The name immediately following SUBLANG_ dictates which primary
 *  language ID that sublanguage ID can be combined with to form a
 *  valid language ID.
 */
#define SUBLANG_NEUTRAL                  0x00    /* language neutral */
#define SUBLANG_DEFAULT                  0x01    /* user default */
#define SUBLANG_SYS_DEFAULT              0x02    /* system default */

#define SUBLANG_CHINESE_SIMPLIFIED       0x02    /* Chinese (Simplified) */
#define SUBLANG_CHINESE_TRADITIONAL      0x01    /* Chinese (Traditional) */ 
#define SUBLANG_DUTCH                    0x01    /* Dutch */
#define SUBLANG_DUTCH_BELGIAN            0x02    /* Dutch (Belgian) */
#define SUBLANG_ENGLISH_US               0x01    /* English (USA) */
#define SUBLANG_ENGLISH_UK               0x02    /* English (UK) */
#define SUBLANG_ENGLISH_AUS              0x03    /* English (Australian) */
#define SUBLANG_ENGLISH_CAN              0x04    /* English (Canadian) */
#define SUBLANG_ENGLISH_NZ               0x05    /* English (New Zealand) */
#define SUBLANG_ENGLISH_EIRE             0x06    /* English (Irish) */
#define SUBLANG_FRENCH                   0x01    /* French */
#define SUBLANG_FRENCH_BELGIAN           0x02    /* French (Belgian) */
#define SUBLANG_FRENCH_CANADIAN          0x03    /* French (Canadian) */
#define SUBLANG_FRENCH_SWISS             0x04    /* French (Swiss) */
#define SUBLANG_GERMAN                   0x01    /* German */
#define SUBLANG_GERMAN_SWISS             0x02    /* German (Swiss) */
#define SUBLANG_GERMAN_AUSTRIAN          0x03    /* German (Austrian) */
#define SUBLANG_ITALIAN                  0x01    /* Italian */
#define SUBLANG_ITALIAN_SWISS            0x02    /* Italian (Swiss) */
#define SUBLANG_NORWEGIAN_BOKMAL         0x01    /* Norwegian (Bokmal) */
#define SUBLANG_NORWEGIAN_NYNORSK        0x02    /* Norwegian (Nynorsk) */
#define SUBLANG_PORTUGUESE               0x02    /* Portuguese */
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01    /* Portuguese (Brazilian) */
#define SUBLANG_SERBO_CROATIAN_CYRILLIC  0x02    /* Serbo-Croatian (Cyrillic) */
#define SUBLANG_SERBO_CROATIAN_LATIN     0x01    /* Croato-Serbian (Latin) */
#define SUBLANG_SPANISH                  0x01    /* Spanish */
#define SUBLANG_SPANISH_MEXICAN          0x02    /* Spanish (Mexican) */
#define SUBLANG_SPANISH_MODERN           0x03    /* Spanish (Modern) */


/*
 *  Country Codes.
 */
#define CTRY_DEFAULT                     0

#define CTRY_AUSTRALIA                   61      /* Australia */
#define CTRY_AUSTRIA                     43      /* Austria */
#define CTRY_BELGIUM                     32      /* Belgium */
#define CTRY_BRAZIL                      55      /* Brazil */
#define CTRY_CANADA                      2       /* Canada */
#define CTRY_DENMARK                     45      /* Denmark */
#define CTRY_FINLAND                     358     /* Finland */
#define CTRY_FRANCE                      33      /* France */
#define CTRY_GERMANY                     49      /* Germany */
#define CTRY_ICELAND                     354     /* Iceland */
#define CTRY_IRELAND                     353     /* Ireland */
#define CTRY_ITALY                       39      /* Italy */
#define CTRY_JAPAN                       81      /* Japan */
#define CTRY_MEXICO                      52      /* Mexico */
#define CTRY_NETHERLANDS                 31      /* Netherlands */
#define CTRY_NEW_ZEALAND                 64      /* New Zealand */
#define CTRY_NORWAY                      47      /* Norway */
#define CTRY_PORTUGAL                    351     /* Portugal */
#define CTRY_PRCHINA                     86      /* PR China */
#define CTRY_SOUTH_KOREA                 82      /* South Korea */
#define CTRY_SPAIN                       34      /* Spain */
#define CTRY_SWEDEN                      46      /* Sweden */
#define CTRY_SWITZERLAND                 41      /* Switzerland */
#define CTRY_TAIWAN                      886     /* Taiwan */
#define CTRY_UNITED_KINGDOM              44      /* United Kingdom */
#define CTRY_UNITED_STATES               1       /* United States */


/*
 *  Locale Types.
 *
 *  These types are used for the GetLocaleInfoA NLS API routine.
 */

#define LOCALE_NOUSEROVERRIDE   0x80000000    /* OR in to avoid user override */

#define LOCALE_ILANGUAGE            0x0001    /* language id */
#define LOCALE_SLANGUAGE            0x0002    /* localized name of language */
#define LOCALE_SENGLANGUAGE         0x1001    /* English name of language */
#define LOCALE_SABBREVLANGNAME      0x0003    /* abbreviated language name */
#define LOCALE_SNATIVELANGNAME      0x0004    /* native name of language */
#define LOCALE_ICOUNTRY             0x0005    /* country code */
#define LOCALE_SCOUNTRY             0x0006    /* localized name of country */  
#define LOCALE_SENGCOUNTRY          0x1002    /* English name of country */  
#define LOCALE_SABBREVCTRYNAME      0x0007    /* abbreviated country name */
#define LOCALE_SNATIVECTRYNAME      0x0008    /* native name of country */  
#define LOCALE_IDEFAULTLANGUAGE     0x0009    /* default language id */
#define LOCALE_IDEFAULTCOUNTRY      0x000A    /* default country code */
#define LOCALE_IDEFAULTCODEPAGE     0x000B    /* default code page */
                                            
#define LOCALE_SLIST                0x000C    /* list item separator */
#define LOCALE_IMEASURE             0x000D    /* 0 = metric, 1 = US */
                                            
#define LOCALE_SDECIMAL             0x000E    /* decimal separator */
#define LOCALE_STHOUSAND            0x000F    /* thousand separator */
#define LOCALE_SGROUPING            0x0010    /* digit grouping */
#define LOCALE_IDIGITS              0x0011    /* number of fractional digits */
#define LOCALE_ILZERO               0x0012    /* leading zeros for decimal */
#define LOCALE_SNATIVEDIGITS        0x0013    /* native ascii 0-9 */
                                            
#define LOCALE_SCURRENCY            0x0014    /* local monetary symbol */
#define LOCALE_SINTLSYMBOL          0x0015    /* intl monetary symbol */
#define LOCALE_SMONDECIMALSEP       0x0016    /* monetary decimal separator */
#define LOCALE_SMONTHOUSANDSEP      0x0017    /* monetary thousand separator */
#define LOCALE_SMONGROUPING         0x0018    /* monetary grouping */
#define LOCALE_ICURRDIGITS          0x0019    /* # local monetary digits */
#define LOCALE_IINTLCURRDIGITS      0x001A    /* # intl monetary digits */
#define LOCALE_ICURRENCY            0x001B    /* positive currency mode */
#define LOCALE_INEGCURR             0x001C    /* negative currency mode */
                                            
#define LOCALE_SDATE                0x001D    /* date separator */
#define LOCALE_STIME                0x001E    /* time separator */
#define LOCALE_SSHORTDATE           0x001F    /* short date-time separator */
#define LOCALE_SLONGDATE            0x0020    /* long date-time separator */
#define LOCALE_IDATE                0x0021    /* short date format ordering */
#define LOCALE_ILDATE               0x0022    /* long date format ordering */
#define LOCALE_ITIME                0x0023    /* time format specifier */
#define LOCALE_ICENTURY             0x0024    /* century format specifier */
#define LOCALE_ITLZERO              0x0025    /* leading zeros in time field */
#define LOCALE_IDAYLZERO            0x0026    /* leading zeros in day field */
#define LOCALE_IMONLZERO            0x0027    /* leading zeros in month field */
#define LOCALE_S1159                0x0028    /* AM designator */
#define LOCALE_S2359                0x0029    /* PM designator */
                                            
#define LOCALE_SDAYNAME1            0x002A    /* long name for Monday */
#define LOCALE_SDAYNAME2            0x002B    /* long name for Tuesday */
#define LOCALE_SDAYNAME3            0x002C    /* long name for Wednesday */
#define LOCALE_SDAYNAME4            0x002D    /* long name for Thursday */
#define LOCALE_SDAYNAME5            0x002E    /* long name for Friday */
#define LOCALE_SDAYNAME6            0x002F    /* long name for Saturday */
#define LOCALE_SDAYNAME7            0x0030    /* long name for Sunday */
#define LOCALE_SABBREVDAYNAME1      0x0031    /* abbreviated name for Monday */   
#define LOCALE_SABBREVDAYNAME2      0x0032    /* abbreviated name for Tuesday */  
#define LOCALE_SABBREVDAYNAME3      0x0033    /* abbreviated name for Wednesday */
#define LOCALE_SABBREVDAYNAME4      0x0034    /* abbreviated name for Thursday */ 
#define LOCALE_SABBREVDAYNAME5      0x0035    /* abbreviated name for Friday */   
#define LOCALE_SABBREVDAYNAME6      0x0036    /* abbreviated name for Saturday */ 
#define LOCALE_SABBREVDAYNAME7      0x0037    /* abbreviated name for Sunday */   
#define LOCALE_SMONTHNAME1          0x0038    /* long name for January */
#define LOCALE_SMONTHNAME2          0x0039    /* long name for February */
#define LOCALE_SMONTHNAME3          0x003A    /* long name for March */
#define LOCALE_SMONTHNAME4          0x003B    /* long name for April */
#define LOCALE_SMONTHNAME5          0x003C    /* long name for May */
#define LOCALE_SMONTHNAME6          0x003D    /* long name for June */
#define LOCALE_SMONTHNAME7          0x003E    /* long name for July */
#define LOCALE_SMONTHNAME8          0x003F    /* long name for August */
#define LOCALE_SMONTHNAME9          0x0040    /* long name for September */
#define LOCALE_SMONTHNAME10         0x0041    /* long name for October */
#define LOCALE_SMONTHNAME11         0x0042    /* long name for November */
#define LOCALE_SMONTHNAME12         0x0043    /* long name for December */
#define LOCALE_SABBREVMONTHNAME1    0x0044    /* abbreviated name for January */
#define LOCALE_SABBREVMONTHNAME2    0x0045    /* abbreviated name for February */
#define LOCALE_SABBREVMONTHNAME3    0x0046    /* abbreviated name for March */
#define LOCALE_SABBREVMONTHNAME4    0x0047    /* abbreviated name for April */
#define LOCALE_SABBREVMONTHNAME5    0x0048    /* abbreviated name for May */
#define LOCALE_SABBREVMONTHNAME6    0x0049    /* abbreviated name for June */
#define LOCALE_SABBREVMONTHNAME7    0x004A    /* abbreviated name for July */
#define LOCALE_SABBREVMONTHNAME8    0x004B    /* abbreviated name for August */
#define LOCALE_SABBREVMONTHNAME9    0x004C    /* abbreviated name for September */
#define LOCALE_SABBREVMONTHNAME10   0x004D    /* abbreviated name for October */
#define LOCALE_SABBREVMONTHNAME11   0x004E    /* abbreviated name for November */
#define LOCALE_SABBREVMONTHNAME12   0x004F    /* abbreviated name for December */
                                            
#define LOCALE_SPOSITIVESIGN        0x0050    /* positive sign */
#define LOCALE_SNEGATIVESIGN        0x0051    /* negative sign */
#define LOCALE_IPOSSIGNPOSN         0x0052    /* positive sign position */
#define LOCALE_INEGSIGNPOSN         0x0053    /* negative sign position */
#define LOCALE_IPOSSYMPRECEDES      0x0054    /* mon sym precedes pos amt */
#define LOCALE_IPOSSEPBYSPACE       0x0055    /* mon sym sep by space from pos */ 
#define LOCALE_INEGSYMPRECEDES      0x0056    /* mon sym precedes neg amt */
#define LOCALE_INEGSEPBYSPACE       0x0057    /* mon sym sep by space from neg */
        
        
/***************************************************************************\
* Typedefs
*
* Define all types for the NLS component here.
\***************************************************************************/

/*
 *  IDs.
 */
typedef unsigned long  LCID;                  /* locale ID */
typedef unsigned short LANGID;                /* language ID */
typedef unsigned long  LCTYPE;                /* locale type constant */

#define _LCID_DEFINED



/***************************************************************************\
* Macros
*
* Define all macros for the NLS component here.
\***************************************************************************/

/*
 *  A language ID is a 16 bit value which is the combination of a
 *  primary language ID and a secondary language ID.  The bits are
 *  allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |      Sublanguage ID   |   Primary Language ID   |
 *       +-----------------------+-------------------------+
 *        15                   10 9                       0   bit
 *
 *
 *  Language ID creation/extraction macros:
 *
 *    MAKELANGID    - construct language id from primary language id and
 *                    sublanguage id.
 *    PRIMARYLANGID - extract primary language id from a language id.
 *    SUBLANGID     - extract sublanguage id from a language id.
 */
#define MAKELANGID(p, s)       ((((unsigned short)(s)) << 10) | (unsigned short)(p))

#define PRIMARYLANGID(lgid)    ((unsigned short)(lgid) & 0x3ff)

#define SUBLANGID(lgid)        ((unsigned short)(lgid) >> 10)


/*
 *  A locale ID is a 32 bit value which is the combination of a
 *  language ID and a reserved area.  The bits are allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |       Reserved        |      Language ID        |
 *       +-----------------------+-------------------------+
 *        31                   16 15                      0   bit
 *
 *
 *  Locale ID creation macro:
 *
 *    MAKELCID - construct locale id from a language id.
 */
#define MAKELCID(lgid)         ((unsigned long)(((unsigned short)(lgid)) | (((unsigned long)((unsigned short)(0))) << 16)))


/*
 *  Get the language id from a locale id.
 */
#define LANGIDFROMLCID(lcid)   ((unsigned short)(lcid))


/*
 *  Default System and User IDs for language and locale.
 */
#define LANG_SYSTEM_DEFAULT    (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT))
#define LANG_USER_DEFAULT      (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))

#define LOCALE_SYSTEM_DEFAULT  (MAKELCID(LANG_SYSTEM_DEFAULT))
#define LOCALE_USER_DEFAULT    (MAKELCID(LANG_USER_DEFAULT))



/***************************************************************************\
* Function Prototypes
*
* Only prototypes for the NLS APIs should go here.
\***************************************************************************/

 
NLSAPI_(int)
CompareStringA(LCID, unsigned long, const char FAR*, int, const char FAR*, int);

NLSAPI_(int)
LCMapStringA(LCID, unsigned long, const char FAR*, int, char FAR*, int);

NLSAPI_(int)
GetLocaleInfoA(LCID, LCTYPE, char FAR*, int);

NLSAPI_(int)
GetStringTypeA(LCID, unsigned long, const char FAR*, int, unsigned short FAR*);

NLSAPI_(LANGID)
GetSystemDefaultLangID(void);

NLSAPI_(LANGID)
GetUserDefaultLangID(void);

NLSAPI_(LCID)
GetSystemDefaultLCID(void);

NLSAPI_(LCID)
GetUserDefaultLCID(void);


#ifdef __cplusplus
}
#endif


#endif   /* NONLS */

#endif   /* _OLENLS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\olestd.h ===
/*************************************************************************
**
**    OLE 2.0 Standard Utilities
**
**    olestd.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. for the common OLE 2.0
**    utilities.
**    These utilities include the following:
**          Debuging Assert/Verify macros
**          HIMETRIC conversion routines
**          reference counting debug support
**          OleStd API's for common compound-document app support
**
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#if !defined( _OLESTD_H_ )
#define _OLESTD_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING OLESTD.H from " __FILE__)
#endif  /* RC_INVOKED */

#if defined( __TURBOC__ ) || defined( WIN32 )
#define _based(a)
#endif

#ifndef RC_INVOKED
#include <dos.h>        // needed for filetime
#endif  /* RC_INVOKED */

#include <commdlg.h>    // needed for LPPRINTDLG
#include <shellapi.h>   // needed for HKEY

// String table defines...
#define  IDS_OLESTDNOCREATEFILE   700
#define  IDS_OLESTDNOOPENFILE     701
#define  IDS_OLESTDDISKFULL       702


/*
 * Some C interface declaration stuff
 */

#if ! defined(__cplusplus)
typedef struct tagINTERFACEIMPL {
		IUnknownVtbl FAR*       lpVtbl;
		LPVOID                  lpBack;
		int                     cRef;   // interface specific ref count.
} INTERFACEIMPL, FAR* LPINTERFACEIMPL;

#define INIT_INTERFACEIMPL(lpIFace, pVtbl, pBack)   \
		((lpIFace)->lpVtbl = pVtbl, \
			((LPINTERFACEIMPL)(lpIFace))->lpBack = (LPVOID)pBack,   \
			((LPINTERFACEIMPL)(lpIFace))->cRef = 0  \
		)

#if defined( _DEBUG )
#define OleDbgQueryInterfaceMethod(lpUnk)   \
		((lpUnk) != NULL ? ((LPINTERFACEIMPL)(lpUnk))->cRef++ : 0)
#define OleDbgAddRefMethod(lpThis, iface)   \
		((LPINTERFACEIMPL)(lpThis))->cRef++

#if _DEBUGLEVEL >= 2
#define OleDbgReleaseMethod(lpThis, iface) \
		(--((LPINTERFACEIMPL)(lpThis))->cRef == 0 ? \
			OleDbgOut("\t" iface "* RELEASED (cRef == 0)\r\n"),1 : \
			 (((LPINTERFACEIMPL)(lpThis))->cRef < 0) ? \
				( \
					DebugBreak(), \
					OleDbgOut(  \
						"\tERROR: " iface "* RELEASED TOO MANY TIMES\r\n") \
				),1 : \
				1)

#else       // if _DEBUGLEVEL < 2
#define OleDbgReleaseMethod(lpThis, iface) \
		(--((LPINTERFACEIMPL)(lpThis))->cRef == 0 ? \
			1 : \
			 (((LPINTERFACEIMPL)(lpThis))->cRef < 0) ? \
				( \
					OleDbgOut(  \
						"\tERROR: " iface "* RELEASED TOO MANY TIMES\r\n") \
		),1 : \
				1)

#endif      // if _DEBUGLEVEL < 2

#else       // ! defined (_DEBUG)

#define OleDbgQueryInterfaceMethod(lpUnk)
#define OleDbgAddRefMethod(lpThis, iface)
#define OleDbgReleaseMethod(lpThis, iface)

#endif      // if defined( _DEBUG )

#endif      // ! defined(__cplusplus)

/*
 * Some docfiles stuff
 */

#define STGM_DFRALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE)
#define STGM_DFALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE)
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)

/*
 * Some moniker stuff
 */

// Delimeter used to separate ItemMoniker pieces of a composite moniker
#if defined( _MAC )
#define OLESTDDELIM ":"
#else
#define OLESTDDELIM "\\"
#endif

/*
 * Some Concurrency stuff
 */

/* standard Delay (in msec) to wait before retrying an LRPC call.
**    this value is returned from IMessageFilter::RetryRejectedCall
*/
#define OLESTDRETRYDELAY    (DWORD)5000

/* Cancel the pending outgoing LRPC call.
**    this value is returned from IMessageFilter::RetryRejectedCall
*/
#define OLESTDCANCELRETRY   (DWORD)-1

/*
 * Some Icon support stuff.
 *
 * The following API's are now OBSOLETE because equivalent API's have been
 * added to the OLE2.DLL library
 *      GetIconOfFile       superceeded by OleGetIconOfFile
 *      GetIconOfClass      superceeded by OleGetIconOfClass
 *      OleUIMetafilePictFromIconAndLabel
 *                          superceeded by OleMetafilePictFromIconAndLabel
 *
 * The following macros are defined for backward compatibility with previous
 * versions of the OLE2UI library. It is recommended that the new Ole* API's
 * should be used instead.
 */
#define GetIconOfFile(hInst, lpszFileName, fUseFileAsLabel) \
	OleGetIconOfFile(lpszFileName, fUseFileAsLabel)

#define GetIconOfClass(hInst, rclsid, lpszLabel, fUseTypeAsLabel) \
	OleGetIconOfClass(rclsid, lpszLabel, fUseTypeAsLabel)

#define OleUIMetafilePictFromIconAndLabel(hIcon,pszLabel,pszSourceFile,iIcon)\
	OleMetafilePictFromIconAndLabel(hIcon, pszLabel, pszSourceFile, iIcon)


/*
 * Some Clipboard Copy/Paste & Drag/Drop support stuff
 */

//Macro to set all FormatEtc fields
#define SETFORMATETC(fe, cf, asp, td, med, li)   \
	((fe).cfFormat=cf, \
	 (fe).dwAspect=asp, \
	 (fe).ptd=td, \
	 (fe).tymed=med, \
	 (fe).lindex=li)

//Macro to set interesting FormatEtc fields defaulting the others.
#define SETDEFAULTFORMATETC(fe, cf, med)  \
	((fe).cfFormat=cf, \
	 (fe).dwAspect=DVASPECT_CONTENT, \
	 (fe).ptd=NULL, \
	 (fe).tymed=med, \
	 (fe).lindex=-1)

// Macro to test if two FormatEtc structures are an exact match
#define IsEqualFORMATETC(fe1, fe2)  \
	(OleStdCompareFormatEtc(&(fe1), &(fe2))==0)

// Clipboard format strings
#define CF_EMBEDSOURCE      "Embed Source"
#define CF_EMBEDDEDOBJECT   "Embedded Object"
#define CF_LINKSOURCE       "Link Source"
#define CF_CUSTOMLINKSOURCE "Custom Link Source"
#define CF_OBJECTDESCRIPTOR "Object Descriptor"
#define CF_LINKSRCDESCRIPTOR "Link Source Descriptor"
#define CF_OWNERLINK        "OwnerLink"
#define CF_FILENAME         "FileName"

#define OleStdQueryOleObjectData(lpformatetc)   \
	(((lpformatetc)->tymed & TYMED_ISTORAGE) ?    \
			NOERROR : ResultFromScode(DV_E_FORMATETC))

#define OleStdQueryLinkSourceData(lpformatetc)   \
	(((lpformatetc)->tymed & TYMED_ISTREAM) ?    \
			NOERROR : ResultFromScode(DV_E_FORMATETC))

#define OleStdQueryObjectDescriptorData(lpformatetc)    \
	(((lpformatetc)->tymed & TYMED_HGLOBAL) ?    \
			NOERROR : ResultFromScode(DV_E_FORMATETC))

#define OleStdQueryFormatMedium(lpformatetc, tymd)  \
	(((lpformatetc)->tymed & tymd) ?    \
			NOERROR : ResultFromScode(DV_E_FORMATETC))

// Make an independent copy of a MetafilePict
#define OleStdCopyMetafilePict(hpictin, phpictout)  \
	(*(phpictout) = OleDuplicateData(hpictin,CF_METAFILEPICT,GHND|GMEM_SHARE))


// REVIEW: these need to be added to OLE2.H
#if !defined( DD_DEFSCROLLINTERVAL )
#define DD_DEFSCROLLINTERVAL    50
#endif

#if !defined( DD_DEFDRAGDELAY )
#define DD_DEFDRAGDELAY         200
#endif

#if !defined( DD_DEFDRAGMINDIST )
#define DD_DEFDRAGMINDIST       2
#endif


/* OleStdGetDropEffect
** -------------------
**
** Convert a keyboard state into a DROPEFFECT.
**
** returns the DROPEFFECT value derived from the key state.
**    the following is the standard interpretation:
**          no modifier -- Default Drop     (NULL is returned)
**          CTRL        -- DROPEFFECT_COPY
**          SHIFT       -- DROPEFFECT_MOVE
**          CTRL-SHIFT  -- DROPEFFECT_LINK
**
**    Default Drop: this depends on the type of the target application.
**    this is re-interpretable by each target application. a typical
**    interpretation is if the drag is local to the same document
**    (which is source of the drag) then a MOVE operation is
**    performed. if the drag is not local, then a COPY operation is
**    performed.
*/
#define OleStdGetDropEffect(grfKeyState)    \
	( (grfKeyState & MK_CONTROL) ?          \
		( (grfKeyState & MK_SHIFT) ? DROPEFFECT_LINK : DROPEFFECT_COPY ) :  \
		( (grfKeyState & MK_SHIFT) ? DROPEFFECT_MOVE : 0 ) )


/* The OLEUIPASTEFLAG enumeration is used by the OLEUIPASTEENTRY structure.
 *
 * OLEUIPASTE_ENABLEICON    If the container does not specify this flag for the entry in the
 *   OLEUIPASTEENTRY array passed as input to OleUIPasteSpecial, the DisplayAsIcon button will be
 *   unchecked and disabled when the the user selects the format that corresponds to the entry.
 *
 * OLEUIPASTE_PASTEONLY     Indicates that the entry in the OLEUIPASTEENTRY array is valid for pasting only.
 * OLEUIPASTE_PASTE         Indicates that the entry in the OLEUIPASTEENTRY array is valid for pasting. It
 *   may also be valid for linking if any of the following linking flags are specified.
 *
 * If the entry in the OLEUIPASTEENTRY array is valid for linking, the following flags indicate which link
 * types are acceptable by OR'ing together the appropriate OLEUIPASTE_LINKTYPE<#> values.
 * These values correspond as follows to the array of link types passed to OleUIPasteSpecial:
 *   OLEUIPASTE_LINKTYPE1=arrLinkTypes[0]
 *   OLEUIPASTE_LINKTYPE2=arrLinkTypes[1]
 *   OLEUIPASTE_LINKTYPE3=arrLinkTypes[2]
 *   OLEUIPASTE_LINKTYPE4=arrLinkTypes[3]
 *   OLEUIPASTE_LINKTYPE5=arrLinkTypes[4]
 *   OLEUIPASTE_LINKTYPE6=arrLinkTypes[5]
 *   OLEUIPASTE_LINKTYPE7=arrLinkTypes[6]
 *  OLEUIPASTE_LINKTYPE8=arrLinkTypes[7]
 *
 * where,
 *   UINT arrLinkTypes[8] is an array of registered clipboard formats for linking. A maximium of 8 link
 *   types are allowed.
 */

typedef enum tagOLEUIPASTEFLAG
{
   OLEUIPASTE_ENABLEICON    = 2048,     // enable display as icon
   OLEUIPASTE_PASTEONLY     = 0,
   OLEUIPASTE_PASTE         = 512,
   OLEUIPASTE_LINKANYTYPE   = 1024,
   OLEUIPASTE_LINKTYPE1     = 1,
   OLEUIPASTE_LINKTYPE2     = 2,
   OLEUIPASTE_LINKTYPE3     = 4,
   OLEUIPASTE_LINKTYPE4     = 8,
   OLEUIPASTE_LINKTYPE5     = 16,
   OLEUIPASTE_LINKTYPE6     = 32,
   OLEUIPASTE_LINKTYPE7     = 64,
   OLEUIPASTE_LINKTYPE8     = 128
} OLEUIPASTEFLAG;

/*
 * PasteEntry structure
 * --------------------
 * An array of OLEUIPASTEENTRY entries is specified for the PasteSpecial dialog
 * box. Each entry includes a FORMATETC which specifies the formats that are
 * acceptable, a string that is to represent the format in the  dialog's list
 * box, a string to customize the result text of the dialog and a set of flags
 * from the OLEUIPASTEFLAG enumeration.  The flags indicate if the entry is
 * valid for pasting only, linking only or both pasting and linking. If the
 * entry is valid for linking, the flags indicate which link types are
 * acceptable by OR'ing together the appropriate OLEUIPASTE_LINKTYPE<#> values.
 * These values correspond to the array of link types as follows:
 *   OLEUIPASTE_LINKTYPE1=arrLinkTypes[0]
 *   OLEUIPASTE_LINKTYPE2=arrLinkTypes[1]
 *   OLEUIPASTE_LINKTYPE3=arrLinkTypes[2]
 *   OLEUIPASTE_LINKTYPE4=arrLinkTypes[3]
 *   OLEUIPASTE_LINKTYPE5=arrLinkTypes[4]
 *   OLEUIPASTE_LINKTYPE6=arrLinkTypes[5]
 *   OLEUIPASTE_LINKTYPE7=arrLinkTypes[6]
 *   OLEUIPASTE_LINKTYPE8=arrLinkTypes[7]
 *   UINT arrLinkTypes[8]; is an array of registered clipboard formats
 *                        for linking. A maximium of 8 link types are allowed.
 */

typedef struct tagOLEUIPASTEENTRY
{
   FORMATETC        fmtetc;            // Format that is acceptable. The paste
									   //   dialog checks if this format is
									   //   offered by the object on the
									   //   clipboard and if so offers it for
									   //   selection to the user.
   LPCSTR           lpstrFormatName;   // String that represents the format to the user. Any %s
									   //   in this string is replaced by the FullUserTypeName
									   //   of the object on the clipboard and the resulting string
									   //   is placed in the list box of the dialog. Atmost
									   //   one %s is allowed. The presence or absence of %s indicates
									   //   if the result text is to indicate that data is
									   //   being pasted or that an object that can be activated by
									   //   an application is being pasted. If %s is
									   //   present, the result-text says that an object is being pasted.
									   //   Otherwise it says that data is being pasted.
   LPCSTR           lpstrResultText;   // String to customize the result text of the dialog when
									   //  the user selects the format correspoding to this
									   //  entry. Any %s in this string is replaced by the the application
									   //  name or FullUserTypeName of the object on
									   //  the clipboard. Atmost one %s is allowed.
   DWORD            dwFlags;           // Values from OLEUIPASTEFLAG enum
   DWORD            dwScratchSpace;    // Scratch space available to be used
									   //   by routines which loop through an
									   //   IEnumFORMATETC* to mark if the
									   //   PasteEntry format is available.
									   //   this field CAN be left uninitialized.
} OLEUIPASTEENTRY, *POLEUIPASTEENTRY, FAR *LPOLEUIPASTEENTRY;

#define OLESTDDROP_NONE         0
#define OLESTDDROP_DEFAULT      1
#define OLESTDDROP_NONDEFAULT   2


/*
 * Some misc stuff
 */

#define EMBEDDINGFLAG "Embedding"     // Cmd line switch for launching a srvr

#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define PTS_PER_INCH        72        // number points (font size) per inch

#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

// Returns TRUE if all fields of the two Rect's are equal, else FALSE.
#define AreRectsEqual(lprc1, lprc2)     \
	(((lprc1->top == lprc2->top) &&     \
	  (lprc1->left == lprc2->left) &&   \
	  (lprc1->right == lprc2->right) && \
	  (lprc1->bottom == lprc2->bottom)) ? TRUE : FALSE)

// The Windows "lstrcpyn" has slightly different semantics than does
//  the standard-C library strncpy.  It just so happens that lstrcpyn
//  has exactly the semantics we want, so we just use it.  The specific
//  behavior that is needed is that the resulting string must always
//  be NUL terminated, which is not the case with strncpy.  The count
//  of characters (cch) is the limit on the number of characters to
//  place in the resulting string including the NUL.  In other words,
//  (cch) is the size of the destination buffer.

#define LSTRCPYN(lpdst, lpsrc, cch) lstrcpyn(lpdst, lpsrc, cch)

/****** DEBUG Stuff *****************************************************/

#ifdef _DEBUG

#if !defined( _DBGTRACE )
#define _DEBUGLEVEL 2
#else
#define _DEBUGLEVEL _DBGTRACE
#endif


#if defined( NOASSERT )

#define OLEDBGASSERTDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)
#define OleDbgVerifySz(a, b)

#else   // ! NOASSERT

#define OLEDBGASSERTDATA    \
		static char _based(_segname("_CODE")) _szAssertFile[]= __FILE__;

#define OleDbgAssert(a) \
		(!(a) ? FnAssert(#a, NULL, _szAssertFile, __LINE__) : (HRESULT)1)

#define OleDbgAssertSz(a, b)    \
		(!(a) ? FnAssert(#a, b, _szAssertFile, __LINE__) : (HRESULT)1)

#define OleDbgVerify(a) \
		OleDbgAssert(a)

#define OleDbgVerifySz(a, b)    \
		OleDbgAssertSz(a, b)

#endif  // ! NOASSERT


#define OLEDBGDATA_MAIN(szPrefix)   \
		char near g_szDbgPrefix[] = szPrefix;    \
		OLEDBGASSERTDATA
#define OLEDBGDATA  \
		extern char near g_szDbgPrefix[];    \
		OLEDBGASSERTDATA

#define OLEDBG_BEGIN(lpsz) \
		OleDbgPrintAlways(g_szDbgPrefix,lpsz,1);

#define OLEDBG_END  \
		OleDbgPrintAlways(g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOut(lpsz) \
		OleDbgPrintAlways(g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix(lpsz) \
		OleDbgPrintAlways("",lpsz,0)

#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)      \
		OleDbgPrintRefCntAlways(g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect(lpsz,lpRect)      \
		OleDbgPrintRectAlways(g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOutHResult(lpsz,hr)   \
		OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,GetScode(hr))

#define OleDbgOutScode(lpsz,sc) \
		OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,sc)

#define OleDbgOut1(lpsz)    \
		OleDbgPrint(1,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix1(lpsz)    \
		OleDbgPrint(1,"",lpsz,0)

#define OLEDBG_BEGIN1(lpsz)    \
		OleDbgPrint(1,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END1 \
		OleDbgPrint(1,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)     \
		OleDbgPrintRefCnt(1,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect1(lpsz,lpRect)     \
		OleDbgPrintRect(1,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut2(lpsz)    \
		OleDbgPrint(2,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix2(lpsz)    \
		OleDbgPrint(2,"",lpsz,0)

#define OLEDBG_BEGIN2(lpsz)    \
		OleDbgPrint(2,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END2 \
		OleDbgPrint(2,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)     \
		OleDbgPrintRefCnt(2,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect2(lpsz,lpRect)     \
		OleDbgPrintRect(2,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut3(lpsz)    \
		OleDbgPrint(3,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix3(lpsz)    \
		OleDbgPrint(3,"",lpsz,0)

#define OLEDBG_BEGIN3(lpsz)    \
		OleDbgPrint(3,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END3 \
		OleDbgPrint(3,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)     \
		OleDbgPrintRefCnt(3,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect3(lpsz,lpRect)     \
		OleDbgPrintRect(3,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut4(lpsz)    \
		OleDbgPrint(4,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix4(lpsz)    \
		OleDbgPrint(4,"",lpsz,0)

#define OLEDBG_BEGIN4(lpsz)    \
		OleDbgPrint(4,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END4 \
		OleDbgPrint(4,g_szDbgPrefix,"End\r\n",-1);

#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)     \
		OleDbgPrintRefCnt(4,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect4(lpsz,lpRect)     \
		OleDbgPrintRect(4,g_szDbgPrefix,lpsz,lpRect)

#else   //  !_DEBUG

#define OLEDBGDATA_MAIN(szPrefix)
#define OLEDBGDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)         (a)
#define OleDbgVerifySz(a, b)    (a)
#define OleDbgOutHResult(lpsz,hr)
#define OleDbgOutScode(lpsz,sc)
#define OLEDBG_BEGIN(lpsz)
#define OLEDBG_END
#define OleDbgOut(lpsz)
#define OleDbgOut1(lpsz)
#define OleDbgOut2(lpsz)
#define OleDbgOut3(lpsz)
#define OleDbgOut4(lpsz)
#define OleDbgOutNoPrefix(lpsz)
#define OleDbgOutNoPrefix1(lpsz)
#define OleDbgOutNoPrefix2(lpsz)
#define OleDbgOutNoPrefix3(lpsz)
#define OleDbgOutNoPrefix4(lpsz)
#define OLEDBG_BEGIN1(lpsz)
#define OLEDBG_BEGIN2(lpsz)
#define OLEDBG_BEGIN3(lpsz)
#define OLEDBG_BEGIN4(lpsz)
#define OLEDBG_END1
#define OLEDBG_END2
#define OLEDBG_END3
#define OLEDBG_END4
#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)
#define OleDbgOutRect(lpsz,lpRect)
#define OleDbgOutRect1(lpsz,lpRect)
#define OleDbgOutRect2(lpsz,lpRect)
#define OleDbgOutRect3(lpsz,lpRect)
#define OleDbgOutRect4(lpsz,lpRect)

#endif  //  _DEBUG


/*************************************************************************
** Function prototypes
*************************************************************************/


//OLESTD.C
STDAPI_(int) SetDCToAnisotropic(HDC hDC, LPRECT lprcPhysical, LPRECT lprcLogical, LPRECT lprcWindowOld, LPRECT lprcViewportOld);
STDAPI_(int) SetDCToDrawInHimetricRect(HDC, LPRECT, LPRECT, LPRECT, LPRECT);
STDAPI_(int) ResetOrigDC(HDC, int, LPRECT, LPRECT);

STDAPI_(int)        XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int)        XformWidthInPixelsToHimetric(HDC, int);
STDAPI_(int)        XformHeightInHimetricToPixels(HDC, int);
STDAPI_(int)        XformHeightInPixelsToHimetric(HDC, int);

STDAPI_(void) XformRectInPixelsToHimetric(HDC, LPRECT, LPRECT);
STDAPI_(void) XformRectInHimetricToPixels(HDC, LPRECT, LPRECT);
STDAPI_(void) XformSizeInPixelsToHimetric(HDC, LPSIZEL, LPSIZEL);
STDAPI_(void) XformSizeInHimetricToPixels(HDC, LPSIZEL, LPSIZEL);
STDAPI_(int) XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int) XformWidthInPixelsToHimetric(HDC, int);
STDAPI_(int) XformHeightInHimetricToPixels(HDC, int);
STDAPI_(int) XformHeightInPixelsToHimetric(HDC, int);

STDAPI_(void) ParseCmdLine(LPSTR, BOOL FAR *, LPSTR);

STDAPI_(BOOL) OleStdIsOleLink(LPUNKNOWN lpUnk);
STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid);
STDAPI_(LPSTORAGE) OleStdCreateRootStorage(LPSTR lpszStgName, DWORD grfMode);
STDAPI_(LPSTORAGE) OleStdOpenRootStorage(LPSTR lpszStgName, DWORD grfMode);
STDAPI_(LPSTORAGE) OleStdOpenOrCreateRootStorage(LPSTR lpszStgName, DWORD grfMode);
STDAPI_(LPSTORAGE) OleStdCreateChildStorage(LPSTORAGE lpStg, LPSTR lpszStgName);
STDAPI_(LPSTORAGE) OleStdOpenChildStorage(LPSTORAGE lpStg, LPSTR lpszStgName, DWORD grfMode);
STDAPI_(BOOL) OleStdCommitStorage(LPSTORAGE lpStg);
STDAPI OleStdDestroyAllElements(LPSTORAGE lpStg);

STDAPI_(LPSTORAGE) OleStdCreateStorageOnHGlobal(
		HANDLE hGlobal,
		BOOL fDeleteOnRelease,
		DWORD dwgrfMode
);
STDAPI_(LPSTORAGE) OleStdCreateTempStorage(BOOL fUseMemory, DWORD grfMode);
STDAPI OleStdDoConvert(LPSTORAGE lpStg, REFCLSID rClsidNew);
STDAPI_(BOOL) OleStdGetTreatAsFmtUserType(
		REFCLSID        rClsidApp,
		LPSTORAGE       lpStg,
		CLSID FAR*      lpclsid,
		CLIPFORMAT FAR* lpcfFmt,
		LPSTR FAR*      lplpszType
);
STDAPI OleStdDoTreatAsClass(LPSTR lpszUserType, REFCLSID rclsid, REFCLSID rclsidNew);
STDAPI_(BOOL) OleStdSetupAdvises(LPOLEOBJECT lpOleObject, DWORD dwDrawAspect,
					LPSTR lpszContainerApp, LPSTR lpszContainerObj,
					LPADVISESINK lpAdviseSink, BOOL fCreate);
STDAPI OleStdSwitchDisplayAspect(
		LPOLEOBJECT             lpOleObj,
		LPDWORD                 lpdwCurAspect,
		DWORD                   dwNewAspect,
		HGLOBAL                 hMetaPict,
		BOOL                    fDeleteOldAspect,
		BOOL                    fSetupViewAdvise,
		LPADVISESINK            lpAdviseSink,
		BOOL FAR*               lpfMustUpdate
);
STDAPI OleStdSetIconInCache(LPOLEOBJECT lpOleObj, HGLOBAL hMetaPict);
STDAPI_(HGLOBAL) OleStdGetData(
		LPDATAOBJECT        lpDataObj,
		CLIPFORMAT          cfFormat,
		DVTARGETDEVICE FAR* lpTargetDevice,
		DWORD               dwAspect,
		LPSTGMEDIUM         lpMedium
);
STDAPI_(void) OleStdMarkPasteEntryList(
		LPDATAOBJECT        lpSrcDataObj,
		LPOLEUIPASTEENTRY   lpPriorityList,
		int                 cEntries
);
STDAPI_(int) OleStdGetPriorityClipboardFormat(
		LPDATAOBJECT        lpSrcDataObj,
		LPOLEUIPASTEENTRY   lpPriorityList,
		int                 cEntries
);
STDAPI_(BOOL) OleStdIsDuplicateFormat(
		LPFORMATETC         lpFmtEtc,
		LPFORMATETC         arrFmtEtc,
		int                 nFmtEtc
);
STDAPI_(void) OleStdRegisterAsRunning(LPUNKNOWN lpUnk, LPMONIKER lpmkFull, DWORD FAR* lpdwRegister);
STDAPI_(void) OleStdRevokeAsRunning(DWORD FAR* lpdwRegister);
STDAPI_(void) OleStdNoteFileChangeTime(LPSTR lpszFileName, DWORD dwRegister);
STDAPI_(void) OleStdNoteObjectChangeTime(DWORD dwRegister);
STDAPI OleStdGetOleObjectData(
		LPPERSISTSTORAGE    lpPStg,
		LPFORMATETC         lpformatetc,
		LPSTGMEDIUM         lpMedium,
		BOOL                fUseMemory
);
STDAPI OleStdGetLinkSourceData(
		LPMONIKER           lpmk,
		LPCLSID             lpClsID,
		LPFORMATETC         lpformatetc,
		LPSTGMEDIUM         lpMedium
);
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorData(
		CLSID               clsid,
		DWORD               dwAspect,
		SIZEL               sizel,
		POINTL              pointl,
		DWORD               dwStatus,
		LPSTR               lpszFullUserTypeName,
		LPSTR               lpszSrcOfCopy
);
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorDataFromOleObject(
		LPOLEOBJECT         lpOleObj,
		LPSTR               lpszSrcOfCopy,
		DWORD               dwAspect,
		POINTL              pointl,
		LPSIZEL             lpSizelHim
);
STDAPI_(HGLOBAL) OleStdFillObjectDescriptorFromData(
		LPDATAOBJECT       lpDataObject,
		LPSTGMEDIUM        lpmedium,
		CLIPFORMAT FAR*    lpcfFmt
);
STDAPI_(HANDLE) OleStdGetMetafilePictFromOleObject(
		LPOLEOBJECT         lpOleObj,
		DWORD               dwDrawAspect,
		LPSIZEL             lpSizelHim,
		DVTARGETDEVICE FAR* ptd
);

STDAPI_(void) OleStdCreateTempFileMoniker(LPSTR lpszPrefixString, UINT FAR* lpuUnique, LPSTR lpszName, LPMONIKER FAR* lplpmk);
STDAPI_(LPMONIKER) OleStdGetFirstMoniker(LPMONIKER lpmk);
STDAPI_(ULONG) OleStdGetLenFilePrefixOfMoniker(LPMONIKER lpmk);
STDAPI OleStdMkParseDisplayName(
		REFCLSID        rClsid,
		LPBC            lpbc,
		LPSTR           lpszUserName,
		ULONG FAR*      lpchEaten,
		LPMONIKER FAR*  lplpmk
);
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize);
STDAPI_(LPVOID) OleStdRealloc(LPVOID pmem, ULONG ulSize);
STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(ULONG) OleStdGetSize(LPVOID pmem);
STDAPI_(void) OleStdFreeString(LPSTR lpsz, LPMALLOC lpMalloc);
STDAPI_(LPSTR) OleStdCopyString(LPSTR lpszSrc, LPMALLOC lpMalloc);
STDAPI_(ULONG) OleStdGetItemToken(LPSTR lpszSrc, LPSTR lpszDst,int nMaxChars);

STDAPI_(UINT)     OleStdIconLabelTextOut(HDC        hDC,
										 HFONT      hFont,
										 int        nXStart,
										 int        nYStart,
										 UINT       fuOptions,
										 RECT FAR * lpRect,
										 LPSTR      lpszString,
										 UINT       cchString,
										 int FAR *  lpDX);

// registration database query functions
STDAPI_(UINT)     OleStdGetAuxUserType(REFCLSID rclsid,
									  WORD   wAuxUserType,
									  LPSTR  lpszAuxUserType,
									  int    cch,
									  HKEY   hKey);

STDAPI_(UINT)     OleStdGetUserTypeOfClass(REFCLSID rclsid,
										   LPSTR lpszUserType,
										   UINT cch,
										   HKEY hKey);

STDAPI_(BOOL) OleStdGetMiscStatusOfClass(REFCLSID, HKEY, DWORD FAR *);
STDAPI_(CLIPFORMAT) OleStdGetDefaultFileFormatOfClass(
		REFCLSID        rclsid,
		HKEY            hKey
);

STDAPI_(void) OleStdInitVtbl(LPVOID lpVtbl, UINT nSizeOfVtbl);
STDMETHODIMP OleStdNullMethod(LPUNKNOWN lpThis);
STDAPI_(BOOL) OleStdCheckVtbl(LPVOID lpVtbl, UINT nSizeOfVtbl, LPSTR lpszIface);
STDAPI_(ULONG) OleStdVerifyRelease(LPUNKNOWN lpUnk, LPSTR lpszMsg);
STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk);

STDAPI_(HDC) OleStdCreateDC(DVTARGETDEVICE FAR* ptd);
STDAPI_(HDC) OleStdCreateIC(DVTARGETDEVICE FAR* ptd);
STDAPI_(DVTARGETDEVICE FAR*) OleStdCreateTargetDevice(LPPRINTDLG lpPrintDlg);
STDAPI_(BOOL) OleStdDeleteTargetDevice(DVTARGETDEVICE FAR* ptd);
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc);
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);
STDAPI_(int) OleStdCompareFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight);
STDAPI_(BOOL) OleStdCompareTargetDevice
	(DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight);


STDAPI_(void) OleDbgPrint(
		int     nDbgLvl,
		LPSTR   lpszPrefix,
		LPSTR   lpszMsg,
		int     nIndent
);
STDAPI_(void) OleDbgPrintAlways(LPSTR lpszPrefix, LPSTR lpszMsg, int nIndent);
STDAPI_(void) OleDbgSetDbgLevel(int nDbgLvl);
STDAPI_(int) OleDbgGetDbgLevel( void );
STDAPI_(void) OleDbgIndent(int n);
STDAPI_(void) OleDbgPrintRefCnt(
		int         nDbgLvl,
		LPSTR       lpszPrefix,
		LPSTR       lpszMsg,
		LPVOID      lpObj,
		ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRefCntAlways(
		LPSTR       lpszPrefix,
		LPSTR       lpszMsg,
		LPVOID      lpObj,
		ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRect(
		int         nDbgLvl,
		LPSTR       lpszPrefix,
		LPSTR       lpszMsg,
		LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintRectAlways(
		LPSTR       lpszPrefix,
		LPSTR       lpszMsg,
		LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintScodeAlways(LPSTR lpszPrefix, LPSTR lpszMsg, SCODE sc);

// debug implementation of the IMalloc interface.
STDAPI OleStdCreateDbAlloc(ULONG reserved, IMalloc FAR* FAR* ppmalloc);


STDAPI_(LPENUMFORMATETC)
  OleStdEnumFmtEtc_Create(ULONG nCount, LPFORMATETC lpEtc);

STDAPI_(LPENUMSTATDATA)
  OleStdEnumStatData_Create(ULONG nCount, LPSTATDATA lpStat);

STDAPI_(BOOL)
  OleStdCopyStatData(LPSTATDATA pDest, LPSTATDATA pSrc);

STDAPI_(HPALETTE)
  OleStdCreateStandardPalette(void);

#if defined( OBSOLETE )

/*************************************************************************
** The following API's have been converted into macros:
**          OleStdQueryOleObjectData
**          OleStdQueryLinkSourceData
**          OleStdQueryObjectDescriptorData
**          OleStdQueryFormatMedium
**          OleStdCopyMetafilePict
**          AreRectsEqual
**          OleStdGetDropEffect
**
**    These macros are defined above
*************************************************************************/
STDAPI_(BOOL) AreRectsEqual(LPRECT lprc1, LPRECT lprc2);
STDAPI_(BOOL) OleStdCopyMetafilePict(HANDLE hpictin, HANDLE FAR* phpictout);
STDAPI OleStdQueryOleObjectData(LPFORMATETC lpformatetc);
STDAPI OleStdQueryLinkSourceData(LPFORMATETC lpformatetc);
STDAPI OleStdQueryObjectDescriptorData(LPFORMATETC lpformatetc);
STDAPI OleStdQueryFormatMedium(LPFORMATETC lpformatetc, TYMED tymed);
STDAPI_(DWORD) OleStdGetDropEffect ( DWORD grfKeyState );
#endif  // OBSOLETE


#endif // _OLESTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\oleguid.h ===
/*****************************************************************************\
*                                                                             *
* oleguid.h -   Master definition of GUIDs for ole2.dll                       *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all public GUIDs specific to OLE 
   and is included in ole2.h.
   
   NOTE: The second least significant byte of all of these GUIDs is 1.
*/
   

DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);

DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);

DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);

DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);

DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);

DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);

DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0); // unused
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);

DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);

DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);

DEFINE_OLEGUID(IID_IAdviseSink2,            0x00000125, 0, 0);

DEFINE_OLEGUID(IID_IRunnableObject,         0x00000126, 0, 0);

DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IOleCache2,				0x00000128, 0, 0);
DEFINE_OLEGUID(IID_IOleCacheControl,        0x00000129, 0, 0);

/* NOTE: LSB values 0x27 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,        0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,             0x00000316, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\penwin.h ===
/*****************************************************************************\
*                                                                             *
* penwin.h -    Pen Windows functions, types, and definitions                 *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWS
#include <windows.h>    /* <windows.h> must be pre-included */
#endif /* _INC_WINDOWS */

#ifndef _INC_PENWIN     /* prevent multiple includes */
#define _INC_PENWIN

#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {
#endif	/* __cplusplus */

/****** General Pen Windows Definitions *************************************/

typedef int                    REC;    
typedef LONG                   SYV;    
typedef SYV FAR                *LPSYV;
typedef HANDLE                 HREC;
typedef int                    CL;
typedef LONG                   ALC;
typedef UINT                   HKP;
typedef int (CALLBACK * LPDF)(int, LPVOID, LPVOID, int, DWORD, DWORD);

#define BITPENUP               0x8000
#define FPenUpX(x)             (((x) & BITPENUP)!=0)

/* Default pen cursor to indicate writing, points northwest */
#define IDC_PEN                MAKEINTRESOURCE(32631)

/* alternate select cursor: upsidedown standard arrow, points southeast */
#define IDC_ALTSELECT          MAKEINTRESOURCE(32501)

#define RC_WDEFAULT            (0xFFFF)
#define RC_LDEFAULT            (0xFFFFFFFFL)
#define RC_WDEFAULTFLAGS       (0x8000)
#define RC_LDEFAULTFLAGS       (0x80000000L)

/* HIWORD(SYV) defines and detection macros */

#define SYVHI_SPECIAL          0
#define FIsSpecial(syv)        (HIWORD((syv))==SYVHI_SPECIAL)
#define SYVHI_ANSI             1
#define FIsAnsi(syv)           (HIWORD((syv))==SYVHI_ANSI)
#define SYVHI_GESTURE          2
#define FIsGesture(syv)        (HIWORD((syv))==SYVHI_GESTURE)
#define SYVHI_KANJI            3
#define FIsKanji(syv)          (HIWORD((syv))==SYVHI_KANJI)
#define SYVHI_SHAPE            4
#define FIsShape(syv)          (HIWORD((syv))==SYVHI_SHAPE)
#define SYVHI_UNICODE          5
#define FIsUniCode(syv)        (HIWORD((syv))==SYVHI_UNICODE)
#define SYVHI_VKEY             6
#define FIsVKey(syv)           (HIWORD((syv))==SYVHI_VKEY)

/* Macros to convert between SYV and ANSI */

#define ChSyvToAnsi(syv)       ((BYTE) (LOBYTE(LOWORD((syv)))))
#define SyvCharacterToSymbol(c) ((LONG)(unsigned char)(c) | 0x00010000)
#define SyvKanjiToSymbol(c) ((LONG)(WORD)(c) | 0x00030000)

/* SYV values with special meanings to Pen Windows */

#define SYV_NULL               0x00000000L
#define SYV_UNKNOWN            0x00000001L
#define SYV_EMPTY              0x00000003L
#define SYV_BEGINOR            0x00000010L
#define SYV_ENDOR              0x00000011L
#define SYV_OR                 0x00000012L
#define SYV_SOFTNEWLINE        0x00000020L
#define SYV_SPACENULL          SyvCharacterToSymbol('\0')

/* SYV values for gestures (map into UNICODE space) */

#define SYV_KKCONVERT          0x0002FFD4L
#define SYV_CLEAR              0x0002FFD5L
#define SYV_EXTENDSELECT       0x0002FFD8L
#define SYV_UNDO               0x0002FFD9L
#define SYV_COPY               0x0002FFDAL
#define SYV_CUT                0x0002FFDBL
#define SYV_PASTE              0x0002FFDCL
#define SYV_CLEARWORD          0x0002FFDDL
#define SYV_USER               0x0002FFDEL	/* ;Reserved */
#define SYV_CORRECT            0x0002FFDFL

#define SYV_BACKSPACE          0x00020008L
#define SYV_TAB                0x00020009L
#define SYV_RETURN             0x0002000DL
#define SYV_SPACE              0x00020020L

#define FIsStdGesture(syv)     \
     ((syv) == SYV_CLEAR       \
   || (syv) == SYV_EXTENDSELECT\
   || (syv) == SYV_UNDO        \
   || (syv) == SYV_COPY        \
   || (syv) == SYV_CUT         \
   || (syv) == SYV_PASTE       \
   || (syv) == SYV_CLEARWORD   \
   || (syv) == SYV_KKCONVERT   \
   || (syv) == SYV_USER        \
   || (syv) == SYV_CORRECT)

#define FIsAnsiGesture(syv)    \
     ((syv) == SYV_BACKSPACE   \
   || (syv) == SYV_TAB         \
   || (syv) == SYV_RETURN      \
   || (syv) == SYV_SPACE)

/* Application specific gestures, Circle a-z and Circle A-Z */

#define SYV_APPGESTUREMASK     0x00020000L
#define SYV_CIRCLEUPA          0x000224B6L
#define SYV_CIRCLEUPZ          0x000224CFL
#define SYV_CIRCLELOA          0x000224D0L
#define SYV_CIRCLELOZ          0x000224E9L

/* Gesture Macros */

#define FIsLoAppGesture(syv)   (syv >= SYV_CIRCLELOA && syv <= SYV_CIRCLELOZ)
#define FIsUpAppGesture(syv)   (syv >= SYV_CIRCLEUPA && syv <= SYV_CIRCLEUPZ)
#define FIsAppGesture(syv)     (syv>=SYV_CIRCLEUPA && syv<=SYV_CIRCLELOZ)

#define SyvAppGestureFromLoAnsi(ansi) ((DWORD)(BYTE)ansi- 'a' + SYV_CIRCLELOA)
#define SyvAppGestureFromUpAnsi(ansi) ((DWORD)(BYTE)ansi- 'A' + SYV_CIRCLEUPA)
#define AnsiFromSyvAppGesture(syv) ChSyvToAnsi( \
    syv-(FIsUpAppGesture(syv)? SYV_CIRCLEUPA-(SYV)'A': SYV_CIRCLELOA-(SYV)'a'))

/* SYV definitions for shapes */

#define SYV_SHAPELINE          0x00040001L
#define SYV_SHAPEELLIPSE       0x00040002L
#define SYV_SHAPERECT          0x00040003L
#define SYV_SHAPEMIN           SYV_SHAPELINE
#define SYV_SHAPEMAX           SYV_SHAPERECT

/****** Recognition Error Codes *********************************************/

#define REC_OEM                (-1024)
#define REC_LANGUAGE           (-48)
#define REC_GUIDE              (-47)
#define REC_PARAMERROR         (-46)
#define REC_INVALIDREF         (-45)
#define REC_RECTEXCLUDE        (-44)
#define REC_RECTBOUND          (-43)
#define REC_PCM                (-42)
#define REC_RESULTMODE         (-41)
#define REC_HWND               (-40)
#define REC_ALC                (-39)
#define REC_ERRORLEVEL         (-38)
#define REC_CLVERIFY           (-37)
#define REC_DICT               (-36)
#define REC_HREC               (-35)
#define REC_BADEVENTREF        (-33)
#define REC_NOCOLLECTION       (-32)

#define REC_DEBUG              (-32)    

#define REC_POINTEREVENT       (-31)
#define REC_BADHPENDATA        (-9)    
#define REC_OOM                (-8)
#define REC_NOINPUT            (-7)
#define REC_NOTABLET           (-6)
#define REC_BUSY               (-5)
#define REC_BUFFERTOOSMALL     (-4)
#define REC_ABORT              (-3)

#define REC_OVERFLOW           (-1)

#define REC_OK                 0
#define REC_TERMBOUND          1
#define REC_TERMEX             2
#define REC_TERMPENUP          3
#define REC_TERMRANGE          4
#define REC_TERMTIMEOUT        5
#define REC_DONE               6
#define REC_TERMOEM            512

/****** Pen Driver Structures and Entry points ******************************/

typedef struct tagOEMPENINFO
   {
   UINT wPdt;
   UINT wValueMax;
   UINT wDistinct;
   }
   OEMPENINFO, FAR *LPOEMPENINFO;

#define PDT_NULL               0
#define PDT_PRESSURE           1
#define PDT_HEIGHT             2
#define PDT_ANGLEXY            3
#define PDT_ANGLEZ             4
#define PDT_BARRELROTATION     5
#define PDT_OEMSPECIFIC        16

#define MAXOEMDATAWORDS        6

typedef struct tagPENPACKET
   {
   UINT wTabletX;
   UINT wTabletY;
   UINT wPDK;
   UINT rgwOemData[MAXOEMDATAWORDS];
   }
   PENPACKET, FAR *LPPENPACKET;

typedef BOOL (CALLBACK * LPFNRAWHOOK)(LPPENPACKET);

typedef struct tagPENINFO
   {
   UINT cxRawWidth;       
   UINT cyRawHeight;       
   UINT wDistinctWidth;   
   UINT wDistinctHeight;  
   int nSamplingRate; 
   int nSamplingDist; 
   LONG lPdc;        
   int cPens;        
   int cbOemData;    
   OEMPENINFO rgoempeninfo[MAXOEMDATAWORDS];  
   UINT rgwReserved[8];     
   }
   PENINFO, FAR *LPPENINFO;

#define PDC_INTEGRATED         0x00000001L
#define PDC_PROXIMITY          0x00000002L
#define PDC_RANGE              0x00000004L
#define PDC_INVERT             0x00000008L
#define PDC_RELATIVE           0x00000010L
#define PDC_BARREL1            0x00000020L
#define PDC_BARREL2            0x00000040L
#define PDC_BARREL3            0x00000080L

typedef struct tagSTROKEINFO
   {
   UINT cPnt;        
   UINT cbPnts;    
   UINT wPdk;        
   DWORD dwTick;    
   }
   STROKEINFO, FAR *LPSTROKEINFO;

typedef struct tagCALBSTRUCT
   {
   int wOffsetX;
   int wOffsetY;
   int wDistinctWidth;
   int wDistinctHeight;
   }
   CALBSTRUCT, FAR *LPCALBSTRUCT;

/****** DRV_ values for pen driver specific messages ************************/

#define DRV_SetPenDriverEntryPoints    DRV_RESERVED+1
#define DRV_RemovePenDriverEntryPoints DRV_RESERVED+2
#define DRV_SetPenSamplingRate         DRV_RESERVED+3
#define DRV_SetPenSamplingDist         DRV_RESERVED+4
#define DRV_GetName                    DRV_RESERVED+5
#define DRV_GetVersion                 DRV_RESERVED+6
#define DRV_GetPenInfo                 DRV_RESERVED+7
#define DRV_GetCalibration             DRV_RESERVED+11
#define DRV_SetCalibration             DRV_RESERVED+12

VOID WINAPI UpdatePenInfo(LPPENINFO);
BOOL WINAPI EndPenCollection(REC);
REC  WINAPI GetPenHwData(LPPOINT, LPVOID, int, UINT, LPSTROKEINFO);
REC  WINAPI GetPenHwEventData(UINT, UINT, LPPOINT, LPVOID, int, LPSTROKEINFO);
VOID WINAPI PenPacket(VOID);
BOOL WINAPI SetPenHook(HKP, LPFNRAWHOOK);

/****** Pen Hardware Constants **********************************************/

#define PDK_UP                 0x0000    
#define PDK_DOWN               0x0001    
#define PDK_BARREL1            0x0002    
#define PDK_BARREL2            0x0004    
#define PDK_BARREL3            0x0008    
#define PDK_TRANSITION         0x0010    
#define PDK_INVERTED           0x0080    
#define PDK_OUTOFRANGE         0x4000    
#define PDK_DRIVER             0x8000    
#define PDK_TIPMASK            0x0001    
#define PDK_SWITCHES           (PDK_DOWN|PDK_BARREL1|PDK_BARREL2|PDK_BARREL3)

#define PCM_PENUP              0x00000001L
#define PCM_RANGE              0x00000002L
#define PCM_INVERT             0x00000020L
#define PCM_RECTEXCLUDE        0x00002000L
#define PCM_RECTBOUND          0x00004000L
#define PCM_TIMEOUT            0x00008000L
#define PCM_ADDDEFAULTS        RC_LDEFAULTFLAGS /* 0x80000000L */

/****** Virtual Event Layer *************************************************/

VOID WINAPI PostVirtualKeyEvent(UINT, BOOL);
VOID WINAPI PostVirtualMouseEvent(UINT, int, int);
VOID WINAPI AtomicVirtualEvent(BOOL);

#define VWM_MOUSEMOVE          0x0001
#define VWM_MOUSELEFTDOWN      0x0002
#define VWM_MOUSELEFTUP        0x0004
#define VWM_MOUSERIGHTDOWN     0x0008
#define VWM_MOUSERIGHTUP       0x0010

/****** RC Definition *************************************************************/

#define CL_NULL                0
#define CL_MINIMUM             1
#define CL_MAXIMUM             100
#define INKWIDTH_MINIMUM       0
#define INKWIDTH_MAXIMUM       15
#define ENUM_MINIMUM           1
#define ENUM_MAXIMUM           4096
#define MAXDICTIONARIES        16

typedef struct tagGUIDE
   {
   int xOrigin;    
   int yOrigin;
   int cxBox;
   int cyBox;
   int cxBase;
   int cyBase;
   int cHorzBox;
   int cVertBox;
   int cyMid;
   }
   GUIDE, FAR *LPGUIDE;

typedef BOOL (CALLBACK * RCYIELDPROC)(VOID);

#define cbRcLanguageMax        44
#define cbRcUserMax            32
#define cbRcrgbfAlcMax         32
#define cwRcReservedMax        8

typedef struct tagRC
   {
   HREC hrec;
   HWND hwnd;
   UINT wEventRef;        
   UINT wRcPreferences;
   LONG lRcOptions;
   RCYIELDPROC lpfnYield;
   BYTE lpUser[cbRcUserMax];
   UINT wCountry;
   UINT wIntlPreferences;
   char lpLanguage[cbRcLanguageMax];
   LPDF rglpdf[MAXDICTIONARIES];
   UINT wTryDictionary;
   CL clErrorLevel;
   ALC alc;
   ALC alcPriority;
   BYTE rgbfAlc[cbRcrgbfAlcMax];
   UINT wResultMode;
   UINT wTimeOut;
   LONG lPcm;
   RECT rectBound;
   RECT rectExclude;
   GUIDE guide;
   UINT wRcOrient;
   UINT wRcDirect;
   int nInkWidth;
   COLORREF rgbInk;
   DWORD dwAppParam;
   DWORD dwDictParam;
   DWORD dwRecognizer;
   UINT rgwReserved[cwRcReservedMax];
   }
   RC, FAR *LPRC;

typedef HANDLE HPENDATA;

typedef struct tagSYC
   {
   UINT wStrokeFirst;
   UINT wPntFirst;
   UINT wStrokeLast;
   UINT wPntLast;
   BOOL fLastSyc;
   }
   SYC, FAR *LPSYC;
    
#define wPntAll                (UINT)0xFFFF
#define iSycNull               (-1)

typedef struct tagSYE
   {
   SYV syv;
   LONG lRecogVal;
   CL cl;
   int iSyc;
   }
   SYE, FAR *LPSYE;

#define MAXHOTSPOT             8

typedef struct tagSYG
   {
   POINT rgpntHotSpots[MAXHOTSPOT];
   int cHotSpot;
   int nFirstBox;
   LONG lRecogVal;
   LPSYE lpsye;
   int cSye;
   LPSYC lpsyc;
   int cSyc;
   }
   SYG, FAR *LPSYG;

typedef int (CALLBACK *ENUMPROC)(LPSYV, int, VOID FAR *);

typedef struct tagRCRESULT
   {
   SYG syg;
   UINT wResultsType;
   int cSyv;
   LPSYV lpsyv;
   HANDLE hSyv;
   int nBaseLine;
   int nMidLine;
   HPENDATA hpendata;
   RECT rectBoundInk;
   POINT pntEnd;
   LPRC lprc;
   }
   RCRESULT, FAR *LPRCRESULT;

#define RCRT_DEFAULT           0x0000
#define RCRT_UNIDENTIFIED      0x0001 
#define RCRT_GESTURE           0x0002 
#define RCRT_NOSYMBOLMATCH     0x0004    
#define RCRT_PRIVATE           0x4000 
#define RCRT_NORECOG           0x8000 
#define RCRT_ALREADYPROCESSED  0x0008   
#define RCRT_GESTURETRANSLATED 0x0010 
#define RCRT_GESTURETOKEYS     0x0020 

#define HKP_SETHOOK            0
#define HKP_UNHOOK             0xFFFF
#define HWR_RESULTS            0
#define HWR_APPWIDE            1

#define PEN_NOINKWIDTH         0
#define LPDFNULL               ((LPDF)NULL)

#define RPA_DEFAULT            1

/* GetGlobalRC return codes */
#define GGRC_OK                0
#define GGRC_DICTBUFTOOSMALL   1
#define GGRC_PARAMERROR        2

/* SetGlobalRC return code flags */
#define SGRC_OK                0x0000
#define SGRC_USER              0x0001
#define SGRC_PARAMERROR        0x0002
#define SGRC_RC                0x0004
#define SGRC_RECOGNIZER        0x0008
#define SGRC_DICTIONARY        0x0010
#define SGRC_INIFILE           0x0020

#define GetWEventRef()         (LOWORD(GetMessageExtraInfo()))

HREC WINAPI InstallRecognizer(LPSTR);
VOID WINAPI UninstallRecognizer(HREC);
UINT WINAPI GetGlobalRC(LPRC, LPSTR, LPSTR, int);
UINT WINAPI SetGlobalRC(LPRC, LPSTR, LPSTR);
VOID WINAPI RegisterPenApp(UINT, BOOL);
UINT WINAPI IsPenAware(VOID);
BOOL WINAPI SetRecogHook(UINT, UINT, HWND);
VOID WINAPI InitRC(HWND, LPRC);
REC  WINAPI Recognize(LPRC);
REC  WINAPI RecognizeData(LPRC, HPENDATA);
BOOL WINAPI TrainInk(LPRC, HPENDATA, LPSYV);
BOOL WINAPI TrainContext(LPRCRESULT, LPSYE, int, LPSYC, int);
REC  WINAPI ProcessWriting(HWND, LPRC);    
BOOL WINAPI CorrectWriting(HWND, LPSTR, UINT, LPRC, DWORD, DWORD);
VOID WINAPI EmulatePen(BOOL);
int  WINAPI GetSymbolMaxLength(LPSYG);
int  WINAPI GetSymbolCount(LPSYG);
VOID WINAPI FirstSymbolFromGraph(LPSYG, LPSYV, int, int FAR *);
UINT WINAPI EnumSymbols(LPSYG, WORD, ENUMPROC, LPVOID);

/****** Miscellaneous Functions *********************************************/

BOOL WINAPI TPtoDP(LPPOINT, int);
BOOL WINAPI DPtoTP(LPPOINT, int);
VOID WINAPI BoundingRectFromPoints(LPPOINT, int, LPRECT);
BOOL WINAPI SymbolToCharacter(LPSYV, int, LPSTR, LPINT);
int  WINAPI CharacterToSymbol(LPSTR, int, LPSYV);
UINT WINAPI GetVersionPenWin(VOID);
BOOL WINAPI ExecuteGesture(HWND, SYV, LPRCRESULT);

/****** RC Options and Flags  ***********************************************/

#define ALC_ALL                0x000043FFL
#define ALC_DEFAULT            0x00000000L
#define ALC_LCALPHA            0x00000001L
#define ALC_UCALPHA            0x00000002L
#define ALC_ALPHA              0x00000003L
#define ALC_NUMERIC            0x00000004L
#define ALC_ALPHANUMERIC       0x00000007L
#define ALC_PUNC               0x00000008L
#define ALC_MATH               0x00000010L
#define ALC_MONETARY           0x00000020L
#define ALC_OTHER              0x00000040L
#define ALC_WHITE              0x00000100L
#define ALC_NONPRINT           0x00000200L
#define ALC_GESTURE            0x00004000L
#define ALC_USEBITMAP          0x00008000L
#define ALC_DBCS               0x00000400L
#define ALC_HIRAGANA           0x00010000L
#define ALC_KATAKANA           0x00020000L
#define ALC_KANJI              0x00040000L
#define ALC_OEM                0x0FF80000L
#define ALC_RESERVED           0xF0003800L
#define ALC_NOPRIORITY         0x00000000L
#define ALC_SYSMINIMUM (ALC_ALPHANUMERIC | ALC_PUNC | ALC_WHITE | ALC_GESTURE)

#define MpAlcB(lprc,i) ((lprc)->rgbfAlc[((i) & 0xff) >> 3])
#define MpIbf(i)       ((BYTE)(1 << ((i) & 7)))

#define SetAlcBitAnsi(lprc,i)      do {MpAlcB(lprc,i) |= MpIbf(i);} while (0)
#define ResetAlcBitAnsi(lprc,i)    do {MpAlcB(lprc,i) &= ~MpIbf(i);} while (0)
#define IsAlcBitAnsi(lprc, i)      ((MpAlcB(lprc,i) & MpIbf(i)) != 0)

#define RCD_DEFAULT            0
#define RCD_LR                 1
#define RCD_RL                 2
#define RCD_TB                 3
#define RCD_BT                 4

#define RCO_NOPOINTEREVENT     0x00000001L
#define RCO_SAVEALLDATA        0x00000002L
#define RCO_SAVEHPENDATA       0x00000004L
#define RCO_NOFLASHUNKNOWN     0x00000008L
#define RCO_TABLETCOORD        0x00000010L
#define RCO_NOSPACEBREAK       0x00000020L
#define RCO_NOHIDECURSOR       0x00000040L
#define RCO_NOHOOK             0x00000080L
#define RCO_BOXED              0x00000100L
#define RCO_SUGGEST            0x00000200L
#define RCO_DISABLEGESMAP      0x00000400L
#define RCO_NOFLASHCURSOR      0x00000800L
#define RCO_COLDRECOG          0x00008000L

#define RCP_LEFTHAND           0x0001
#define RCP_MAPCHAR            0x0004

#define RCOR_NORMAL            1
#define RCOR_RIGHT             2
#define RCOR_UPSIDEDOWN        3
#define RCOR_LEFT              4

#define RRM_STROKE             0
#define RRM_SYMBOL             1
#define RRM_WORD               2
#define RRM_NEWLINE            3
#define RRM_COMPLETE           16

#define RCIP_ALLANSICHAR       0x0001
#define RCIP_MASK              0x0001

#define CWR_STRIPCR            0x00000001L
#define CWR_STRIPLF            0x00000002L
#define CWR_STRIPTAB           0x00000004L
#define CWR_SINGLELINEEDIT     0x00000007L
#define CWR_TITLE              0x00000010L
#define CWR_KKCONVERT          0x00000020L

#define MAP_GESTOGES				(RCRT_GESTURE|RCRT_GESTURETRANSLATED)
#define MAP_GESTOVKEYS			(RCRT_GESTURETOKEYS|RCRT_ALREADYPROCESSED)

#define IsGestureToGesture(lprcresult)	(((lprcresult)->wResultstype & MAP_GESTOGES \
													 ) == MAP_GESTOGES)

#define IsGestureToVkeys(lprcresult)	(((lprcresult)->wResultstype & MAP_GESTOVKEYS \
													 ) == MAP_GESTOVKEYS)

#define SetAlreadyProcessed(lprcresult) ((lprcresult)->wResultsType = ((lprcresult)->wResultsType \
														& ~RCRT_GESTURETOKEYS) | RCRT_ALREADYPROCESSED)

/****** Pen Data Type *******************************************************/

typedef struct tagPENDATAHEADER
   {
   UINT wVersion;
   UINT cbSizeUsed;        
   UINT cStrokes;          
   UINT cPnt;              
   UINT cPntStrokeMax;
   RECT rectBound;
   UINT wPndts;            
   int  nInkWidth;
   DWORD rgbInk;
   }
   PENDATAHEADER, FAR *LPPENDATAHEADER, FAR *LPPENDATA;

#define PDTS_LOMETRIC          0x0000
#define PDTS_HIMETRIC          0x0001
#define PDTS_HIENGLISH         0x0002
#define PDTS_SCALEMAX          0x0003
#define PDTS_DISPLAY           0x0003
#define PDTS_ARBITRARY         0x0004
#define PDTS_SCALEMASK         0x000F
#define PDTS_STANDARDSCALE     PDTS_HIENGLISH 

#define PDTS_NOPENINFO         0x0100  
#define PDTS_NOUPPOINTS        0x0200  
#define PDTS_NOOEMDATA         0x0400
#define PDTS_NOCOLINEAR        0x0800  
#define PDTS_COMPRESSED        0x8000
#define PDTS_COMPRESSMETHOD    0x00F0  
#define PDTS_COMPRESS2NDDERIV  0x0010 

#define PDTT_DEFAULT           0x0000         
#define PDTT_PENINFO           PDTS_NOPENINFO 
#define PDTT_UPPOINTS          PDTS_NOUPPOINTS
#define PDTT_OEMDATA           PDTS_NOOEMDATA
#define PDTT_COLINEAR          PDTS_NOCOLINEAR 
#define PDTT_COMPRESS          PDTS_COMPRESSED
#define PDTT_DECOMPRESS        0x4000
#define PDTT_ALL (PDTT_PENINFO|PDTT_UPPOINTS|PDTT_OEMDATA|PDTT_COLINEAR)

#define DestroyPenData(hpendata) (GlobalFree(hpendata)==NULL)
#define EndEnumStrokes(hpendata) GlobalUnlock(hpendata)

BOOL WINAPI IsPenEvent(UINT, LONG);
BOOL WINAPI GetPenAsyncState(UINT);

BOOL WINAPI GetPenDataInfo(HPENDATA, LPPENDATAHEADER, LPPENINFO, DWORD);
BOOL WINAPI GetPenDataStroke(LPPENDATA, UINT, LPPOINT FAR *, LPVOID FAR *, LPSTROKEINFO );
BOOL WINAPI GetPointsFromPenData(HPENDATA, UINT, UINT, UINT, LPPOINT);
VOID WINAPI DrawPenData(HDC, LPRECT, HPENDATA);
BOOL WINAPI MetricScalePenData(HPENDATA, UINT);
BOOL WINAPI ResizePenData(HPENDATA, LPRECT);
BOOL WINAPI OffsetPenData(HPENDATA, int, int);
BOOL WINAPI RedisplayPenData(HDC, HPENDATA, LPPOINT, LPPOINT, int, DWORD);
HPENDATA  WINAPI CompactPenData(HPENDATA, UINT );
HPENDATA  WINAPI DuplicatePenData(HPENDATA, UINT);
HPENDATA  WINAPI CreatePenData(LPPENINFO, int, UINT, UINT); 
HPENDATA  WINAPI AddPointsPenData(HPENDATA, LPPOINT, LPVOID, LPSTROKEINFO);
LPPENDATA WINAPI BeginEnumStrokes(HPENDATA );

/****** New Windows Messages ************************************************/

#define WM_RCRESULT            (WM_PENWINFIRST+1)
#define WM_HOOKRCRESULT        (WM_PENWINFIRST+2)
#define WM_GLOBALRCCHANGE      (WM_PENWINFIRST+3)
#define WM_SKB                 (WM_PENWINFIRST+4)
#define WM_HEDITCTL            (WM_PENWINFIRST+5)

/****** Dictionary **********************************************************/

#define cbDictPathMax          255
#define DIRQ_QUERY             1
#define DIRQ_DESCRIPTION       2
#define DIRQ_CONFIGURE         3
#define DIRQ_OPEN              4
#define DIRQ_CLOSE             5
#define DIRQ_SETWORDLISTS      6
#define DIRQ_STRING            7
#define DIRQ_SUGGEST           8
#define DIRQ_ADD               9
#define DIRQ_DELETE            10
#define DIRQ_FLUSH             11
#define DIRQ_RCCHANGE          12
#define DIRQ_SYMBOLGRAPH       13
#define DIRQ_INIT					 14
#define DIRQ_CLEANUP				 15
#define DIRQ_COPYRIGHT			 16


#define DIRQ_USER              4096

BOOL WINAPI DictionarySearch(LPRC, LPSYE, int, LPSYV, int);

/****** Handwriting Edit Control ********************************************/

#define HE_GETRC               3
#define HE_SETRC               4
#define HE_GETINFLATE          5
#define HE_SETINFLATE          6
#define HE_GETUNDERLINE        7
#define HE_SETUNDERLINE        8
#define HE_GETINKHANDLE        9
#define HE_SETINKMODE          10
#define HE_STOPINKMODE         11
#define HE_GETRCRESULTCODE     12
#define HE_DEFAULTFONT         13
#define HE_CHARPOSITION        14
#define HE_CHAROFFSET          15

#define HE_GETRCRESULT         22

#define HE_KKCONVERT           30
#define HE_GETKKCONVERT        31
#define HE_CANCELKKCONVERT     32
#define HE_FIXKKCONVERT        33

#define HEKK_DEFAULT           0
#define HEKK_CONVERT           1
#define HEKK_CANDIDATE         2

#define HEP_NORECOG            0
#define HEP_RECOG              1
#define HEP_WAITFORTAP         2

#define HN_ENDREC              4
#define HN_DELAYEDRECOGFAIL    5

#define HN_RCRESULT            20

#define HN_ENDKKCONVERT        30

typedef struct tagRECTOFS
   {
   int dLeft;
   int dTop;
   int dRight;
   int dBottom;
   }
   RECTOFS, FAR *LPRECTOFS;

/****** Boxed Edit Control **************************************************/

typedef struct tagBOXLAYOUT
   {
   int cyCusp;      
   int cyEndCusp;
   UINT style;      
   DWORD rgbText;
   DWORD rgbBox; 
   DWORD rgbSelect;
   }
   BOXLAYOUT, FAR *LPBOXLAYOUT;

#define BXS_NONE               0U
#define BXS_RECT               1U
#define BXS_ENDTEXTMARK        2U
#define BXS_MASK               3U

#define HE_GETBOXLAYOUT        20
#define HE_SETBOXLAYOUT        21

#define BXD_CELLWIDTH          12
#define BXD_CELLHEIGHT         16
#define BXD_BASEHEIGHT         13
#define BXD_BASEHORZ           0
#define BXD_CUSPHEIGHT         2
#define BXD_ENDCUSPHEIGHT      4

/****** Screen Keyboard *****************************************************/

typedef struct tagSKBINFO
   {
   HWND hwnd;
   UINT nPad;
   BOOL fVisible;
   BOOL fMinimized;
   RECT rect;
   DWORD dwReserved;
   }
   SKBINFO, FAR *LPSKBINFO;

#define SKB_QUERY              0x0000
#define SKB_SHOW               0x0001
#define SKB_HIDE               0x0002
#define SKB_CENTER             0x0010
#define SKB_MOVE               0x0020
#define SKB_MINIMIZE           0x0040
#define SKB_FULL               0x0100
#define SKB_BASIC              0x0200
#define SKB_NUMPAD             0x0400

#define OBM_SKBBTNUP           32767
#define OBM_SKBBTNDOWN         32766
#define OBM_SKBBTNDISABLED     32765

#define SKN_CHANGED            1

#define SKN_POSCHANGED         1
#define SKN_PADCHANGED         2
#define SKN_MINCHANGED         4
#define SKN_VISCHANGED         8
#define SKN_TERMINATED         0xffff

BOOL WINAPI ShowKeyboard(HWND, UINT, LPPOINT, LPSKBINFO);

/****** New ComboBox Notifications  *****************************************/

#define CBN_ENDREC             16
#define CBN_DELAYEDRECOGFAIL   17
#define CBN_RCRESULT           18


#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */

#endif /* #define _INC_PENWIN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\penwoem.h ===
/*****************************************************************************\
*                                                                             *
* penwoem.h -   Pen Windows APIs into recognizer layer.                       *
*               Assumes windows.h and penwin.h have been previously included. *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_PENWOEM     /* prevent multiple includes */
#define _INC_PENWOEM

#ifndef RC_INVOKED
#pragma pack(1)
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

typedef int (CALLBACK *LPFUNCRESULTS) (LPRCRESULT, REC);

/* Initialization Functions */

#define WCR_RECOGNAME          0
#define WCR_QUERY              1
#define WCR_CONFIGDIALOG       2
#define WCR_DEFAULT            3
#define WCR_RCCHANGE           4
#define WCR_VERSION            5
#define WCR_TRAIN              6
#define WCR_TRAINSAVE          7
#define WCR_TRAINMAX           8
#define WCR_TRAINDIRTY         9
#define WCR_TRAINCUSTOM        10
#define WCR_QUERYLANGUAGE      11
#define WCR_USERCHANGE         12
#define WCR_PRIVATE            1024

/* sub-function of WCR_USERCHANGE */
#define CRUC_REMOVE            1

/* Return values for WCR_TRAIN Function */
#define TRAIN_NONE             0x0000
#define TRAIN_DEFAULT          0x0001
#define TRAIN_CUSTOM           0x0002
#define TRAIN_BOTH             (TRAIN_DEFAULT | TRAIN_CUSTOM)

/* Control values for TRAINSAVE */
#define TRAIN_SAVE             0  /* Save changes that have been made */
#define TRAIN_REVERT           1  /* Discard changes that have been made */

UINT WINAPI ConfigRecognizer(UINT, WPARAM, LPARAM);
BOOL WINAPI InitRecognizer(LPRC);
VOID WINAPI CloseRecognizer(VOID);

/* Recognition Functions */
REC  WINAPI RecognizeInternal(LPRC, LPFUNCRESULTS);
REC  WINAPI RecognizeDataInternal(LPRC, HPENDATA, LPFUNCRESULTS);

/* Training Functions */
BOOL WINAPI TrainInkInternal(LPRC, HPENDATA, LPSYV);
BOOL WINAPI TrainContextInternal(LPRCRESULT, LPSYE, int, LPSYC, int);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif /* RC_INVOKED */

#endif /* #define _INC_PENWOEM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\print.h ===
/*****************************************************************************\
*                                                                             *
* print.h -     Printing helper functions, types, and definitions             *
*                                                                             *
*               Copyright (c) 1985-1992. Microsoft Corp.  All rights reserved.*
*                                                                             *
*******************************************************************************
*
*  PRINTDRIVER       - For inclusion with a printer driver
*  NOPQ              - Prevent inclusion of priority queue APIs
*
\*****************************************************************************/

#ifndef _INC_PRINT
#define _INC_PRINT

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifdef PRINTDRIVER

#define NORASTEROPS
#define NOTEXTMETRICS
#define NOGDICAPMASKS
#define NOGDIOBJ
#define NOBITMAP
#define NOSOUND
#define NOTEXTMETRIC
#define NOCOMM
#define NOKANJI

#include <windows.h>

#undef NORASTEROPS
#undef NOTEXTMETRICS
#undef NOGDICAPMASKS
#undef NOGDICAPMASKS
#undef NOGDIOBJ
#undef NOBITMAP
#undef NOSOUND
#undef NOTEXTMETRIC
#undef NOCOMM
#undef NOKANJI

#define NOPTRC	/* don't allow gdidefs.inc to redef these */
#define PTTYPE POINT

#define PQERROR (-1)

#ifndef NOPQ

DECLARE_HANDLE(HPQ);

HPQ     WINAPI CreatePQ(int);
int     WINAPI MinPQ(HPQ);
int     WINAPI ExtractPQ(HPQ);
int     WINAPI InsertPQ(HPQ, int, int);
int     WINAPI SizePQ(HPQ, int);
void    WINAPI DeletePQ(HPQ);
#endif  /* !NOPQ */

/* Spool routines for use by printer drivers */

DECLARE_HANDLE(HPJOB);

HPJOB   WINAPI OpenJob(LPSTR, LPSTR, HPJOB);
int     WINAPI StartSpoolPage(HPJOB);
int     WINAPI EndSpoolPage(HPJOB);
int     WINAPI WriteSpool(HPJOB, LPSTR, int);
int     WINAPI CloseJob(HPJOB);
int     WINAPI DeleteJob(HPJOB, int);
int     WINAPI WriteDialog(HPJOB, LPSTR, int);
int     WINAPI DeleteSpoolPage(HPJOB);

#endif /* !PRINTDRIVER */

typedef struct tagBANDINFOSTRUCT
{
    BOOL    fGraphics;
    BOOL    fText;
    RECT    rcGraphics;
} BANDINFOSTRUCT, FAR* LPBI;

#define USA_COUNTRYCODE 1

/*
 *  Printer driver initialization using ExtDeviceMode()
 *  and DeviceCapabilities().
 *  This replaces Drivinit.h
 */

/* size of a device name string */
#define CCHDEVICENAME 32
#define CCHPAPERNAME  64

/* current version of specification */
#define DM_SPECVERSION 0x30A

/* field selection bits */
#define DM_ORIENTATION	    0x0000001L
#define DM_PAPERSIZE	    0x0000002L
#define DM_PAPERLENGTH	    0x0000004L
#define DM_PAPERWIDTH	    0x0000008L
#define DM_SCALE	    0x0000010L
#define DM_COPIES	    0x0000100L
#define DM_DEFAULTSOURCE    0x0000200L
#define DM_PRINTQUALITY     0x0000400L
#define DM_COLOR	    0x0000800L
#define DM_DUPLEX	    0x0001000L
#define DM_YRESOLUTION	    0x0002000L
#define DM_TTOPTION	    0x0004000L

/* orientation selections */
#define DMORIENT_PORTRAIT   1
#define DMORIENT_LANDSCAPE  2

/* paper selections */
/*  Warning: The PostScript driver mistakingly uses DMPAPER_ values between
 *  50 and 56.  Don't use this range when defining new paper sizes.
 */
#define DMPAPER_FIRST	    DMPAPER_LETTER
#define DMPAPER_LETTER      1           /* Letter 8 1/2 x 11 in               */
#define DMPAPER_LETTERSMALL 2           /* Letter Small 8 1/2 x 11 in         */
#define DMPAPER_TABLOID     3           /* Tabloid 11 x 17 in                 */
#define DMPAPER_LEDGER      4           /* Ledger 17 x 11 in                  */
#define DMPAPER_LEGAL       5           /* Legal 8 1/2 x 14 in                */
#define DMPAPER_STATEMENT   6           /* Statement 5 1/2 x 8 1/2 in         */
#define DMPAPER_EXECUTIVE   7		/* Executive 7 1/4 x 10 1/2 in	      */
#define DMPAPER_A3          8           /* A3 297 x 420 mm                    */
#define DMPAPER_A4          9           /* A4 210 x 297 mm                    */
#define DMPAPER_A4SMALL     10          /* A4 Small 210 x 297 mm              */
#define DMPAPER_A5          11          /* A5 148 x 210 mm                    */
#define DMPAPER_B4          12          /* B4 250 x 354                       */
#define DMPAPER_B5          13          /* B5 182 x 257 mm                    */
#define DMPAPER_FOLIO       14          /* Folio 8 1/2 x 13 in                */
#define DMPAPER_QUARTO      15          /* Quarto 215 x 275 mm                */
#define DMPAPER_10X14       16          /* 10x14 in                           */
#define DMPAPER_11X17       17          /* 11x17 in                           */
#define DMPAPER_NOTE        18          /* Note 8 1/2 x 11 in                 */
#define DMPAPER_ENV_9       19          /* Envelope #9 3 7/8 x 8 7/8          */
#define DMPAPER_ENV_10      20          /* Envelope #10 4 1/8 x 9 1/2         */
#define DMPAPER_ENV_11      21          /* Envelope #11 4 1/2 x 10 3/8        */
#define DMPAPER_ENV_12      22          /* Envelope #12 4 \276 x 11           */
#define DMPAPER_ENV_14      23          /* Envelope #14 5 x 11 1/2            */
#define DMPAPER_CSHEET      24          /* C size sheet                       */
#define DMPAPER_DSHEET      25          /* D size sheet                       */
#define DMPAPER_ESHEET      26          /* E size sheet                       */
#define DMPAPER_ENV_DL      27          /* Envelope DL 110 x 220mm            */
#define DMPAPER_ENV_C5      28          /* Envelope C5 162 x 229 mm           */
#define DMPAPER_ENV_C3      29          /* Envelope C3  324 x 458 mm          */
#define DMPAPER_ENV_C4      30          /* Envelope C4  229 x 324 mm          */
#define DMPAPER_ENV_C6      31          /* Envelope C6  114 x 162 mm          */
#define DMPAPER_ENV_C65     32          /* Envelope C65 114 x 229 mm          */
#define DMPAPER_ENV_B4      33          /* Envelope B4  250 x 353 mm          */
#define DMPAPER_ENV_B5      34          /* Envelope B5  176 x 250 mm          */
#define DMPAPER_ENV_B6      35          /* Envelope B6  176 x 125 mm          */
#define DMPAPER_ENV_ITALY   36          /* Envelope 110 x 230 mm              */
#define DMPAPER_ENV_MONARCH 37          /* Envelope Monarch 3.875 x 7.5 in    */
#define DMPAPER_ENV_PERSONAL 38         /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
#define DMPAPER_FANFOLD_US  39          /* US Std Fanfold 14 7/8 x 11 in      */
#define DMPAPER_FANFOLD_STD_GERMAN  40  /* German Std Fanfold 8 1/2 x 12 in   */
#define DMPAPER_FANFOLD_LGL_GERMAN  41  /* German Legal Fanfold 8 1/2 x 13 in */

#define DMPAPER_LAST	    DMPAPER_FANFOLD_LGL_GERMAN

#define DMPAPER_USER	    256

/* bin selections */
#define DMBIN_FIRST	    DMBIN_UPPER
#define DMBIN_UPPER	    1
#define DMBIN_ONLYONE	    1
#define DMBIN_LOWER	    2
#define DMBIN_MIDDLE	    3
#define DMBIN_MANUAL	    4
#define DMBIN_ENVELOPE	    5
#define DMBIN_ENVMANUAL     6
#define DMBIN_AUTO	    7
#define DMBIN_TRACTOR	    8
#define DMBIN_SMALLFMT	    9
#define DMBIN_LARGEFMT	    10
#define DMBIN_LARGECAPACITY 11
#define DMBIN_CASSETTE      14
#define DMBIN_LAST	    DMBIN_CASSETTE

#define DMBIN_USER	    256     /* device specific bins start here */

/* print qualities */
#define DMRES_DRAFT	    (-1)
#define DMRES_LOW	    (-2)
#define DMRES_MEDIUM	    (-3)
#define DMRES_HIGH	    (-4)

/* color enable/disable for color printers */
#define DMCOLOR_MONOCHROME  1
#define DMCOLOR_COLOR	    2

/* duplex enable */
#define DMDUP_SIMPLEX	 1
#define DMDUP_VERTICAL	 2
#define DMDUP_HORIZONTAL 3

/* TrueType options */
#define DMTT_BITMAP     1       /* print TT fonts as graphics */
#define DMTT_DOWNLOAD   2       /* download TT fonts as soft fonts */
#define DMTT_SUBDEV     3       /* substitute device fonts for TT fonts */

typedef struct tagDEVMODE
{
    char  dmDeviceName[CCHDEVICENAME];
    UINT  dmSpecVersion;
    UINT  dmDriverVersion;
    UINT  dmSize;
    UINT  dmDriverExtra;
    DWORD dmFields;
    int   dmOrientation;
    int   dmPaperSize;
    int   dmPaperLength;
    int   dmPaperWidth;
    int   dmScale;
    int   dmCopies;
    int   dmDefaultSource;
    int   dmPrintQuality;
    int   dmColor;
    int   dmDuplex;
    int   dmYResolution;
    int   dmTTOption;
} DEVMODE;

typedef DEVMODE* PDEVMODE, NEAR* NPDEVMODE, FAR* LPDEVMODE;

/* mode selections for the device mode function */
#define DM_UPDATE	    1
#define DM_COPY 	    2
#define DM_PROMPT	    4
#define DM_MODIFY	    8

#define DM_IN_BUFFER	    DM_MODIFY
#define DM_IN_PROMPT	    DM_PROMPT
#define DM_OUT_BUFFER	    DM_COPY
#define DM_OUT_DEFAULT	    DM_UPDATE

/* device capabilities indices */
#define DC_FIELDS	    1
#define DC_PAPERS	    2
#define DC_PAPERSIZE	    3
#define DC_MINEXTENT	    4
#define DC_MAXEXTENT	    5
#define DC_BINS 	    6
#define DC_DUPLEX	    7
#define DC_SIZE 	    8
#define DC_EXTRA	    9
#define DC_VERSION	    10
#define DC_DRIVER	    11
#define DC_BINNAMES	    12
#define DC_ENUMRESOLUTIONS  13
#define DC_FILEDEPENDENCIES 14
#define DC_TRUETYPE	    15
#define DC_PAPERNAMES	    16
#define DC_ORIENTATION	    17
#define DC_COPIES	    18

/* bit fields of the return value (DWORD) for DC_TRUETYPE */
#define DCTT_BITMAP	    0x0000001L
#define DCTT_DOWNLOAD	    0x0000002L
#define DCTT_SUBDEV	    0x0000004L

/* export ordinal definitions */
#define PROC_EXTDEVICEMODE	MAKEINTRESOURCE(90)
#define PROC_DEVICECAPABILITIES MAKEINTRESOURCE(91)
#define PROC_OLDDEVICEMODE	MAKEINTRESOURCE(13)

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions
 */
typedef UINT   (CALLBACK* LPFNDEVMODE)(HWND, HMODULE, DEVMODE FAR*,
                          LPSTR, LPSTR, DEVMODE FAR*, LPSTR, UINT);

typedef DWORD  (CALLBACK* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, DEVMODE FAR*);

HDC     WINAPI ResetDC(HDC, const DEVMODE FAR*);

/* this structure is used by the GETSETSCREENPARAMS escape */
typedef struct tagSCREENPARAMS
{
   int angle;
   int frequency;
} SCREENPARAMS;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_PRINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ostream.h ===
/***
*ostream.h - definitions/declarations for the ostream class
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the ostream class.
*   [AT&T C++]
*
****/

#ifndef _INC_OSTREAM
#define _INC_OSTREAM

#include <ios.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

typedef long streamoff, streampos;

class ostream : virtual public ios {

public:
    ostream(streambuf*);
    virtual ~ostream();

    ostream& flush();
    int  opfx();
    void osfx();

inline  ostream& operator<<(ostream& (*f)(ostream&));
inline  ostream& operator<<(ios& (*f)(ios&));
    ostream& operator<<(const char _HFAR_ *);
inline  ostream& operator<<(const unsigned char _HFAR_ *);
inline  ostream& operator<<(const signed char _HFAR_ *);
inline  ostream& operator<<(char);
    ostream& operator<<(unsigned char);
inline  ostream& operator<<(signed char);
    ostream& operator<<(short);
    ostream& operator<<(unsigned short);
    ostream& operator<<(int);
    ostream& operator<<(unsigned int);
    ostream& operator<<(long);
    ostream& operator<<(unsigned long);
inline  ostream& operator<<(float);
    ostream& operator<<(double);
    ostream& operator<<(long double);
    ostream& operator<<(const void _HFAR_ *);
    ostream& operator<<(streambuf*);
inline  ostream& put(char);
    ostream& put(unsigned char);
inline  ostream& put(signed char);
    ostream& write(const char _HFAR_ *,int);
inline  ostream& write(const unsigned char _HFAR_ *,int);
inline  ostream& write(const signed char _HFAR_ *,int);
    ostream& seekp(streampos);
    ostream& seekp(streamoff,ios::seek_dir);
    streampos tellp();

protected:
    ostream();
    ostream(const ostream&);    // treat as private
    ostream& operator=(streambuf*); // treat as private
    ostream& operator=(const ostream& _os) {return operator=(_os.rdbuf()); }
    int do_opfx(int);       // not used
    void do_osfx();         // not used

private:
    ostream(ios&);
    ostream& writepad(const char _HFAR_ *, const char _HFAR_ *);
    int x_floatused;
};

inline ostream& ostream::operator<<(ostream& (*f)(ostream&)) { (*f)(*this); return *this; }
inline ostream& ostream::operator<<(ios& (*f)(ios& )) { (*f)(*this); return *this; }

inline  ostream& ostream::operator<<(char c) { return operator<<((unsigned char) c); }
inline  ostream& ostream::operator<<(signed char c) { return operator<<((unsigned char) c); }

inline  ostream& ostream::operator<<(const unsigned char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }
inline  ostream& ostream::operator<<(const signed char _HFAR_ * s) { return operator<<((const char _HFAR_ *) s); }

inline  ostream& ostream::operator<<(float f) { x_floatused = 1; return operator<<((double) f); }

inline  ostream& ostream::put(char c) { return put((unsigned char) c); }
inline  ostream& ostream::put(signed char c) { return put((unsigned char) c); }

inline  ostream& ostream::write(const unsigned char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }
inline  ostream& ostream::write(const signed char _HFAR_ * s, int n) { return write((char _HFAR_ *) s, n); }


class ostream_withassign : public ostream {
    public:
        ostream_withassign();
        ostream_withassign(streambuf* _is);
        ~ostream_withassign();
    ostream& operator=(const ostream& _os) { return ostream::operator=(_os.rdbuf()); }
    ostream& operator=(streambuf* _sb) { return ostream::operator=(_sb); }
};

#ifndef _WINDLL
extern ostream_withassign cout;
extern ostream_withassign cerr;
extern ostream_withassign clog;
#endif 

inline ostream& flush(ostream& _outs) { return _outs.flush(); }
inline ostream& endl(ostream& _outs) { return _outs << '\n' << flush; }
inline ostream& ends(ostream& _outs) { return _outs << char('\0'); }

ios&        dec(ios&);
ios&        hex(ios&);
ios&        oct(ios&);

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\setjmp.h ===
/***
*setjmp.h - definitions/declarations for setjmp/longjmp routines
*
*   Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the machine-dependent buffer used by
*   setjmp/longjmp to save and restore the program state, and
*   declarations for those routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_SETJMP

#ifndef __cplusplus

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

/* define the buffer type for holding the state information */

#define _JBLEN  9  /* bp, di, si, sp, ret addr, ds */

#ifndef _JMP_BUF_DEFINED
typedef  int  jmp_buf[_JBLEN];
#define _JMP_BUF_DEFINED
#endif 

/* ANSI requires setjmp be a macro */

#define setjmp  _setjmp

/* function prototypes */

int  __cdecl _setjmp(jmp_buf);
void __cdecl longjmp(jmp_buf, int);

#endif 

#define _INC_SETJMP
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\pgchart.h ===
/***
*pgchart.h - Declare constants, functions and macros for charting library.
*
*  Copyright (c) 1988-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*  This file declares the presentation graphics library functions and
*  the structures and manifest constants that are used with them.
*
***************************************************************************/


#ifdef __cplusplus
extern "C" {				/* allow use with C++ */
#endif

#if (_MSC_VER <= 600)
#define	__cdecl	_cdecl
#define	__far	_far
#endif

/* Force word alignment to avoid possible -Zp override */
#pragma	pack(2)


/* Required for the missing value definition */
#ifndef	FLT_MAX
#define FLT_MAX			3.402823466e+38F	/* max value */
#endif

#define _PG_PALETTELEN		16	/* Number of entries in internal palette */
#define _PG_MAXCHARTTYPE	5	/* Maximum available chart type */
#define _PG_MAXCHARTSTYLE	2	/* Maximum chart style */
#define _PG_TITLELEN		70	/* Maximum title text length */

#define _PG_LEFT		1	/* Positions used for titles and legends */
#define _PG_CENTER		2
#define _PG_RIGHT		3
#define _PG_BOTTOM		4
#define _PG_OVERLAY		5

#define _PG_LINEARAXIS		1	/* Used to specify axis types */
#define _PG_LOGAXIS		2

#define _PG_DECFORMAT		1	/* Used to specify tic mark label format */
#define _PG_EXPFORMAT		2

#define _PG_BARCHART		1	/* Charttype for a bar chart */
#define _PG_COLUMNCHART		2	/* Charttype for a column chart */
#define  _PG_PLAINBARS		1	/* Styles for bar and column charts */
#define  _PG_STACKEDBARS	2

#define _PG_LINECHART		3	/* Charttype for a line chart */
#define _PG_SCATTERCHART	4	/* Charttype for a scatter chart */
#define _PG_POINTANDLINE	1	/* Styles for line and scatter charts */
#define _PG_POINTONLY		2

#define _PG_PIECHART		5	/* Charttype for pie chart */
#define _PG_PERCENT		1	/* Styles for pie charts */
#define _PG_NOPERCENT		2

#define _PG_MISSINGVALUE	(-FLT_MAX) /* Indicates missing data values */


/* Error codes */

/* Numbers greater than 100 will terminate chart routine, others will cause
 * default values to be used
 */
#define	_PG_NOTINITIALIZED	102	/* If library not initialized */
#define	_PG_BADSCREENMODE	103	/* Graphics mode not set before charting */
#define	_PG_BADCHARTSTYLE	04	/* Chart style invalid */
#define	_PG_BADCHARTTYPE	104	/* Chart type invalid */
#define	_PG_BADLEGENDWINDOW	105	/* Invalid legend window specified */
#define	_PG_BADCHARTWINDOW	07	/* x1=x2 or y1=y2 in chart window spec. */
#define	_PG_BADDATAWINDOW	107	/* If chart window is too small */
#define	_PG_NOMEMORY		108	/* Not enough memory for data arrays */
#define	_PG_BADLOGBASE		05	/* Log base <= 0 */
#define	_PG_BADSCALEFACTOR	06	/* Scale factor = 0 */
#define	_PG_TOOSMALLN		109	/* Number of data points <= 0 */
#define	_PG_TOOFEWSERIES	110	/* Number of series <= 0 */


/* Typedefs */

/* Typedef for chart title */
#ifndef _TITLETYPE_DEFINED
typedef	struct	{
	char	title[_PG_TITLELEN];	/* Title text */
	short	titlecolor;		/* Internal palette color for title text */
	short	justify;		/* _PG_LEFT, _PG_CENTER, _PG_RIGHT */
} _titletype;
#define _TITLETYPE_DEFINED
#endif

/* Typedef for chart axes */
#ifndef _AXISTYPE_DEFINED
typedef	struct	{
	short		grid;		/* TRUE=grid lines drawn; FALSE no lines */
	short		gridstyle;	/* Style number from style pool for grid lines */
	_titletype	axistitle;	/* Title definition for axis */
	short		axiscolor;	/* Color for axis */
	short		labeled;	/* TRUE=tic marks and titles drawn */
	short		rangetype;	/* _PG_LINEARAXIS, _PG_LOGAXIS */
	float		logbase;	/* Base used if log axis */
	short		autoscale;	/* TRUE=next 7 values calculated by system */
	float		scalemin;	/* Minimum value of scale */
	float		scalemax;	/* Maximum value of scale */
	float		scalefactor;	/* Scale factor for data on this axis */
	_titletype	scaletitle;	/* Title definition for scaling factor */
	float		ticinterval;	/* Distance between tic marks (world coord.) */
	short		ticformat;	/* _PG_EXPFORMAT or _PG_DECFORMAT for tic labels */
	short		ticdecimals;	/* Number of decimals for tic labels (max=9)*/
} _axistype;
#define _AXISTYPE_DEFINED
#endif

/* Typedef used for defining chart and data windows */
#ifndef _WINDOWTYPE_DEFINED
typedef	struct	{
	short		x1;		/* Left edge of window in pixels */
	short		y1;		/* Top edge of window in pixels */
	short		x2;		/* Right edge of window in pixels */
	short		y2;		/* Bottom edge of window in pixels */
	short		border;		/* TRUE for border, FALSE otherwise */
	short		background;	/* Internal palette color for window bgnd */
	short		borderstyle;	/* Style bytes for window border */
	short		bordercolor;	/* Internal palette color for window border */
} _windowtype;
#define _WINDOWTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _LEGENDTYPE_DEFINED
typedef struct	{
	short		legend;		/* TRUE=draw legend; FALSE=no legend */
	short		place;		/* _PG_RIGHT, _PG_BOTTOM, _PG_OVERLAY */
	short		textcolor;	/* Internal palette color for text */
	short		autosize;	/* TRUE=system calculates size */
	_windowtype	legendwindow;	/* Window definition for legend */
} _legendtype;
#define _LEGENDTYPE_DEFINED
#endif

/* Typedef for legend definition */
#ifndef _CHARTENV_DEFINED
typedef struct	{
	short		charttype;	/* _PG_BARCHART, _PG_COLUMNCHART,
					_PG_LINECHART, _PG_SCATTERCHART,
						 _PG_PIECHART */
	short		chartstyle;	/* Style for selected chart type */
	_windowtype	chartwindow;	/* Window definition for overall chart */
	_windowtype	datawindow;	/* Window definition for data part of chart */
	_titletype	maintitle;	/* Main chart title */
	_titletype	subtitle;	/* Chart sub-title */
	_axistype	xaxis;		/* Definition for X-axis */
	_axistype	yaxis;		/* Definition for Y-axis */
	_legendtype	legend;		/* Definition for legend */
} _chartenv;
#define _CHARTENV_DEFINED
#endif

/* Typedef for character bitmap */
#ifndef _CHARMAP_DEFINED
typedef unsigned char _charmap[8];
#define _CHARMAP_DEFINED
#endif

/* Typedef for pattern bitmap */
#ifndef _FILLMAP_DEFINED
typedef unsigned char _fillmap[8];
#define _FILLMAP_DEFINED
#endif

/* Typedef for palette entry definition */
#ifndef _PALETTEENTRY_DEFINED
typedef struct {
	unsigned short	color;
	unsigned short	style;
	_fillmap	fill;
	char		plotchar;
} _paletteentry;
#define _PALETTEENTRY_DEFINED
#endif

/* Typedef for palette definition */
#ifndef _PALETTETYPE_DEFINED
typedef _paletteentry _palettetype[_PG_PALETTELEN];
#define _PALETTETYPE_DEFINED
#endif

/* Typedef for style sets */
#ifndef _STYLESET_DEFINED
typedef unsigned short _styleset[_PG_PALETTELEN];
#define _STYLESET_DEFINED
#endif

#ifndef __STDC__ 
/* Non-ANSI names for compatibility */ 
#define titletype     _titletype 
#define axistype      _axistype 
#define windowtype    _windowtype 
#define legendtype    _legendtype 
#define chartenv      _chartenv 
#define charmap       _charmap 
#define fillmap       _fillmap 
#define paletteentry  _paletteentry 
#define palettetype   _palettetype 
#define styleset      _styleset 
#endif 


/* Function prototypes for charting routines	*/

short __far __cdecl _pg_initchart(void);
short __far __cdecl _pg_defaultchart(_chartenv __far *, short, short);

short __far __cdecl _pg_chart(_chartenv __far *, const char __far * const __far *, const float __far *, short);
short __far __cdecl _pg_chartms(_chartenv __far *, const char __far * const __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_chartscatter(_chartenv __far *, const float __far *, const float __far *, short);
short __far __cdecl _pg_chartscatterms(_chartenv __far *, const float __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_chartpie(_chartenv __far *, const char __far * const __far *, const float __far *, const short __far *, short);

/* Function prototypes for support routines	*/

short __far __cdecl _pg_hlabelchart(_chartenv __far *, short, short, short, const char __far *);
short __far __cdecl _pg_vlabelchart(_chartenv __far *, short, short, short, const char __far *);

short __far __cdecl _pg_analyzechart(_chartenv __far *, const char __far * const __far *, const float __far *, short);
short __far __cdecl _pg_analyzechartms(_chartenv __far *, const char __far * const __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_analyzescatter(_chartenv __far *, const float __far *, const float __far *, short);
short __far __cdecl _pg_analyzescatterms(_chartenv __far *, const float __far *, const float __far *, short, short, short, const char __far * const __far *);

short __far __cdecl _pg_analyzepie(_chartenv __far *, const char __far * const __far *, const float __far *, const short __far *, short);

short __far __cdecl _pg_getpalette(_paletteentry __far *);
short __far __cdecl _pg_setpalette(const _paletteentry __far *);
short __far __cdecl _pg_resetpalette(void);

void  __far __cdecl _pg_getstyleset(unsigned short __far *);
void  __far __cdecl _pg_setstyleset(const unsigned short __far *);
void  __far __cdecl _pg_resetstyleset(void);

short __far __cdecl _pg_getchardef(short, unsigned char __far *);
short __far __cdecl _pg_setchardef(short, const unsigned char __far *);


/* Restore default packing */
#pragma pack()

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations for the sorting and
*   searching routines.
*   [System V]
*
****/

#ifndef _INC_SEARCH

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 


/* function prototypes */

void * __cdecl bsearch(const void *, const void *,
    size_t, size_t, int (__cdecl *)(const void *,
    const void *));
void * __cdecl _lfind(const void *, const void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void * __cdecl _lsearch(const void *, void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
    (const void *, const void *));

#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl lfind(const void *, const void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
void * __cdecl lsearch(const void *, void *,
    unsigned int *, unsigned int, int (__cdecl *)
    (const void *, const void *));
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_SEARCH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\scode.h ===
/*****************************************************************************\
*                                                                             *
* scode.h - 	Defines standard status code services.						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#ifndef __SCODE_H__
#define __SCODE_H__

//
// SCODE
//

typedef long SCODE;
typedef SCODE *PSCODE;
typedef void FAR * HRESULT;
#define NOERROR 0

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+---------------------+-------+-------------------------------+
//  |S|       Context       | Facil |               Code            |
//  +-+---------------------+-------+-------------------------------+
//
//  where
//
//      S - is the severity code
//
//          0 - Success
//          1 - Error
//
//      Context - context info
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1



#define SUCCEEDED(Status) ((SCODE)(Status) >= 0)

#define FAILED(Status) ((SCODE)(Status)<0)


//
// Return the code
//

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define SCODE_FACILITY(sc)  (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define SCODE_SEVERITY(sc)  (((sc) >> 31) & 0x1)

//
// Create an SCODE value from component pieces
//

#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



// --------------------- Functions ---------------------------------------

#define GetScode(hr)        ((SCODE)(hr) & 0x800FFFFF)
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))

STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew);


// -------------------------- Facility definitions -------------------------

#define FACILITY_NULL       0x0000 // generally useful errors ([SE]_*)
#define FACILITY_RPC            0x0001 // remote procedure call errors (RPC_E_*)
#define FACILITY_DISPATCH   0x0002 // late binding dispatch errors
#define FACILITY_STORAGE   0x0003 // storage errors (STG_E_*)
#define FACILITY_ITF            0x0004 // interface-specific errors



#define S_OK                0L
#define S_FALSE             MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)



// --------------------- FACILITY_NULL errors ------------------------------

#define E_UNEXPECTED        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 0xffff)
                            // relatively catastrophic failure

#define E_NOTIMPL           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 1)
                            // not implemented

#define E_OUTOFMEMORY       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 2)
                            // ran out of memory

#define E_INVALIDARG        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 3)
                            // one or more arguments are invalid

#define E_NOINTERFACE       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 4)
                            // no such interface supported


#define E_POINTER           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 5)
                            // invalid pointer

#define E_HANDLE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 6)
                            // invalid handle

#define E_ABORT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 7)
                            // operation aborted

#define E_FAIL              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
                            // unspecified error


#define E_ACCESSDENIED      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 9)
                            // general access denied error


// ----------------- FACILITY_ITF errors used by OLE ---------------------
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an OLE interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//
// The ranges, their associated interfaces, and the header file that defines
// the actual scodes are given below.
// 

// Generic OLE errors that may be returned by many interfaces
#define OLE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0000)
#define OLE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x00FF)
#define OLE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0000)
#define OLE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x00FF)
// interfaces: all
// file: ole2.h


#define DRAGDROP_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0100)
#define DRAGDROP_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x010F)
#define DRAGDROP_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0100)
#define DRAGDROP_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x010F)
// interfaces: IDropSource, IDropTarget
// file: ole2.h

#define CLASSFACTORY_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0110)
#define CLASSFACTORY_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x011F)
#define CLASSFACTORY_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0110)
#define CLASSFACTORY_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x011F)
// interfaces: IClassFactory
// file:

#define MARSHAL_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0120)
#define MARSHAL_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x012F)
#define MARSHAL_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0120)
#define MARSHAL_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x012F)
// interfaces: IMarshal, IStdMarshalInfo, marshal APIs
// file:

#define DATA_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0130)
#define DATA_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x013F)
#define DATA_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0130)
#define DATA_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x013F)
// interfaces: IDataObject
// file: dvobj.h

#define VIEW_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0140)
#define VIEW_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x014F)
#define VIEW_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0140)
#define VIEW_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x014F)
// interfaces: IViewObject
// file: dvobj.h

#define REGDB_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0150)
#define REGDB_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x015F)
#define REGDB_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0150)
#define REGDB_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x015F)
// API: reg.dat manipulation
// file: 


// range 160 - 16F reserved

#define CACHE_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0170) 
#define CACHE_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x017F)
#define CACHE_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0170)
#define CACHE_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x017F)
// interfaces: IOleCache
// file:

#define OLEOBJ_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0180)
#define OLEOBJ_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x018F)
#define OLEOBJ_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0180)
#define OLEOBJ_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x018F)
// interfaces: IOleObject
// file:

#define CLIENTSITE_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0190) 
#define CLIENTSITE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x019F)
#define CLIENTSITE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0190)
#define CLIENTSITE_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x019F)
// interfaces: IOleClientSite
// file:

#define INPLACE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01A0)
#define INPLACE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01AF)
#define INPLACE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01A0)
#define INPLACE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01AF)
// interfaces: IOleWindow, IOleInPlaceObject, IOleInPlaceActiveObject,
//                 IOleInPlaceUIWindow, IOleInPlaceFrame, IOleInPlaceSite
// file:

#define ENUM_E_FIRST        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01B0)
#define ENUM_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01BF)
#define ENUM_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01B0)
#define ENUM_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01BF)
// interfaces: IEnum*
// file:

#define CONVERT10_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01C0)
#define CONVERT10_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01CF)
#define CONVERT10_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01C0)
#define CONVERT10_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01CF)
// API: OleConvertOLESTREAMToIStorage, OleConvertIStorageToOLESTREAM
// file:


#define CLIPBRD_E_FIRST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01D0)
#define CLIPBRD_E_LAST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01DF)
#define CLIPBRD_S_FIRST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01D0)
#define CLIPBRD_S_LAST      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01DF)
// interfaces: OleSetClipboard, OleGetClipboard, OleFlushClipboard
// file: ole2.h

#define MK_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01E0)
#define MK_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01EF)
#define MK_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01E0)
#define MK_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01EF)
// interfaces: IMoniker, IBindCtx, IRunningObjectTable, IParseDisplayName,
//             IOleContainer, IOleItemContainer, IOleLink
// file: moniker.h


#define CO_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01F0)
#define CO_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01FF)
#define CO_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01F0)
#define CO_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01FF)
// all Co* API
// file: compobj.h


// range 200 - ffff for new error codes



#endif      // ifndef __SCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\scrnsave.h ===
/*****************************************************************************\
*                                                                             *
* scrnsave.h    Windows 3.1 screensaver defines and definitions.
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SCRNSAVE
#define _INC_SCRNSAVE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If not included with 3.1 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */


/* Icon resource ID.
 *
 * This should be the first icon used and must have this resource number.
 * This is needed as the first icon in the file will be grabbed
 */
#define ID_APP      100
#define DLG_CHANGEPASSWORD      2000
#define DLG_ENTERPASSWORD       2001
#define DLG_INVALIDPASSWORD     2002
#define DLG_SCRNSAVECONFIGURE   2003

#define idsIsPassword           1000
#define idsIniFile              1001
#define idsScreenSaver          1002
#define idsPassword             1003
#define idsDifferentPW          1004
#define idsChangePW             1005
#define idsBadOldPW             1006
#define idsAppName              1007
#define idsNoHelpMemory         1008
#define idsHelpFile             1009

/* This function is the Window Procedure for the screen saver.  It is
 * up to the programmer to handle any of the messages that wish to be
 * interpretted.  Any unused messages are then passed back to
 * DefScreenSaverProc if desired which will take default action on any
 * unprocessed message...
 */
LRESULT WINAPI ScreenSaverProc(HWND, unsigned, UINT, LPARAM);

/* This function performs default message processing.  Currently handles
 * the following messages:
 *
 * WM_SYSCOMMAND:   return FALSE if wParam is SC_SCREENSAVE or SC_CLOSE
 *
 * WM_DESTROY:      PostQuitMessage(0)
 *
 * WM_SETCURSOR:    By default, this will set the cursor to a null cursor,
 *                  thereby removing it from the screen.
 *
 * WM_LBUTTONDOWN:
 * WM_MBUTTONDOWN:
 * WM_RBUTTONDOWN:
 * WM_KEYDOWN:
 * WM_KEYUP:
 * WM_MOUSEMOVE:    By default, these will cause the program to terminate.
 *                  Unless the password option is enabled.  In that case
 *                  the DlgGetPassword() dialog box is brought up.
 *
 * WM_NCACTIVATE:
 * WM_ACTIVATEAPP:
 * WM_ACTIVATE:     By default, if the wParam parameter is FALSE (signifying
 *                  that transfer is being taken away from the application),
 *                  then the program will terminate.  Termination is
 *                  accomplished by generating a WM_CLOSE message.  This way,
 *                  if the user sets something up in the WM_CREATE, a
 *                  WM_DESTROY will be generated and it can be destroyed
 *                  properly.
 *                  This message is ignored, however is the password option
 *                  is enabled.
 */
LRESULT WINAPI DefScreenSaverProc(HWND, UINT, WPARAM, LPARAM);

/* A function is also needed for configuring the screen saver.  The function
 * should be exactly like it is below and must be exported such that the
 * program can use MAKEPROCINSTANCE on it and call up a dialog box. Further-
 * more, the template used for the dialog must be called
 * ScreenSaverConfigure to allow the main function to access it...
 */
BOOL    WINAPI ScreenSaverConfigureDialog(HWND, UINT, WPARAM, LPARAM);

/* This function is called from the ScreenSaveConfigureDialog() to change
 * the Screen Saver's password.  Note:  passwords are GLOBAL to all
 * screen savers using this model.  Whether or not the password is enabled
 * is LOCAL to a particular screen saver.
 */
BOOL    WINAPI DlgChangePassword(HWND, UINT, WPARAM, LPARAM);

/* To allow the programmer the ability to register child control windows, this
 * function is called prior to the creation of the dialog box.  Any
 * registering that is required should be done here, or return TRUE if none
 * is needed...
 */
BOOL    _cdecl RegisterDialogClasses(HINSTANCE);

/* The following three functions are called by DefScreenSaverProc and must
 * be exported by all screensavers using this model.
 */
BOOL    WINAPI DlgGetPassword(HWND, UINT, WPARAM, LPARAM);
BOOL    WINAPI DlgInvalidPassword(HWND, UINT, WPARAM, LPARAM);
DWORD   WINAPI HelpMessageFilterHookFunction(int, WORD, LPMSG);

/*
 * There are only three other points that should be of notice:
 * 1) The screen saver must have a string declared as 'szAppName' contaning the
 *     name of the screen saver, and it must be declared as a global.
 * 2) The screen saver EXE file should be renamed to a file with a SCR
 *     extension so that the screen saver dialog form the control panel can
 *     find it when is searches for screen savers.
 */
#define WS_GT   (WS_GROUP | WS_TABSTOP)
#define MAXFILELEN  13
#define TITLEBARNAMELEN 40
#define BUFFLEN    255

/* The following globals are defined in scrnsave.lib */
extern HINSTANCE _cdecl hMainInstance;
extern HWND _cdecl hMainWindow;
extern char _cdecl szName[TITLEBARNAMELEN];
extern char _cdecl szIsPassword[22];
extern char _cdecl szIniFile[MAXFILELEN];
extern char _cdecl szScreenSaver[22];
extern char _cdecl szPassword[16];
extern char _cdecl szDifferentPW[BUFFLEN];
extern char _cdecl szChangePW[30];
extern char _cdecl szBadOldPW[BUFFLEN];
extern char _cdecl szHelpFile[MAXFILELEN];
extern char _cdecl szNoHelpMemory[BUFFLEN];
extern UINT _cdecl MyHelpMessage;
extern HOOKPROC _cdecl fpMessageFilter;

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_SCRNSAVE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\share.h ===
/***
*share.h - defines file sharing modes for sopen
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the file sharing modes for sopen().
*
****/

#ifndef _INC_SHARE

#define _SH_COMPAT  0x00    /* compatibility mode */
#define _SH_DENYRW  0x10    /* deny read/write mode */
#define _SH_DENYWR  0x20    /* deny write mode */
#define _SH_DENYRD  0x30    /* deny read mode */
#define _SH_DENYNO  0x40    /* deny none mode */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define SH_COMPAT _SH_COMPAT
#define SH_DENYRW _SH_DENYRW
#define SH_DENYWR _SH_DENYWR
#define SH_DENYRD _SH_DENYRD
#define SH_DENYNO _SH_DENYNO
#endif 

#define _INC_SHARE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the declarations and definitions for the
*   spawnxx, execxx, and various other process control routines.
*
****/

#ifndef _INC_PROCESS

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* mode values for spawnxx routines
 * (only P_WAIT and P_OVERLAY are supported on MS-DOS)
 */

#ifndef _MT
extern int __near __cdecl _p_overlay;
#endif 

#define _P_WAIT     0
#define _P_NOWAIT   1
#ifdef _MT
#define _P_OVERLAY  2
#else 
#define _P_OVERLAY  _p_overlay
#endif 
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO  3
#define _P_DETACH   4


/* function prototypes */

#ifdef _MT
int __cdecl _beginthread(void(__cdecl *)(void *),
    void *, unsigned, void *);
void __cdecl _endthread(void);
#endif 
void __cdecl abort(void);
void __cdecl _cexit(void);
void __cdecl _c_exit(void);
#ifndef _WINDOWS
int __cdecl _execl(const char *, const char *, ...);
int __cdecl _execle(const char *, const char *, ...);
int __cdecl _execlp(const char *, const char *, ...);
int __cdecl _execlpe(const char *, const char *, ...);
int __cdecl _execv(const char *,
    const char * const *);
int __cdecl _execve(const char *,
    const char * const *, const char * const *);
int __cdecl _execvp(const char *,
    const char * const *);
int __cdecl _execvpe(const char *,
    const char * const *, const char * const *);
#endif 
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif 
int __cdecl _getpid(void);
#ifndef _WINDOWS
int __cdecl _spawnl(int, const char *, const char *,
    ...);
int __cdecl _spawnle(int, const char *, const char *,
    ...);
int __cdecl _spawnlp(int, const char *, const char *,
    ...);
int __cdecl _spawnlpe(int, const char *, const char *,
    ...);
int __cdecl _spawnv(int, const char *,
    const char * const *);
int __cdecl _spawnve(int, const char *,
    const char * const *, const char * const *);
int __cdecl _spawnvp(int, const char *,
    const char * const *);
int __cdecl _spawnvpe(int, const char *,
    const char * const *, const char * const *);
int __cdecl system(const char *);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_WAIT      _P_WAIT
#define P_NOWAIT    _P_NOWAIT
#define P_OVERLAY   _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO   _P_NOWAITO
#define P_DETACH    _P_DETACH

#ifndef _WINDOWS
int __cdecl execl(const char *, const char *, ...);
int __cdecl execle(const char *, const char *, ...);
int __cdecl execlp(const char *, const char *, ...);
int __cdecl execlpe(const char *, const char *, ...);
int __cdecl execv(const char *,
    const char * const *);
int __cdecl execve(const char *,
    const char * const *, const char * const *);
int __cdecl execvp(const char *,
    const char * const *);
int __cdecl execvpe(const char *,
    const char * const *, const char * const *);
#endif 
int __cdecl getpid(void);
#ifndef _WINDOWS
int __cdecl spawnl(int, const char *, const char *,
    ...);
int __cdecl spawnle(int, const char *, const char *,
    ...);
int __cdecl spawnlp(int, const char *, const char *,
    ...);
int __cdecl spawnlpe(int, const char *, const char *,
    ...);
int __cdecl spawnv(int, const char *,
    const char * const *);
int __cdecl spawnve(int, const char *,
    const char * const *, const char * const *);
int __cdecl spawnvp(int, const char *,
    const char * const *);
int __cdecl spawnvpe(int, const char *,
    const char * const *, const char * const *);
#endif 

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_PROCESS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\sql.h ===
/*****************************************************************
** SQL.H - This is the the main include for ODBC Core functions.
**
** preconditions:
**	#include "windows.h"
**
** (C) Copyright 1990 - 1994 By Microsoft Corp.
**
**	Updated 5/12/93 for 2.00 specification
**	Updated 5/23/94 for 2.01 specification
*********************************************************************/

#ifndef __SQL
#define __SQL

/*
* ODBCVER			ODBC version number (0x0200).	To exclude
*					definitions introduced in version 2.0 (or above)
*					#define ODBCVER 0x0100 before #including <sql.h>
*/

/* If ODBCVER is not defined, assume version 2.01 */
#ifndef ODBCVER
#define ODBCVER	0x0201
#endif

#ifdef __cplusplus
extern "C" {						/* Assume C declarations for C++   */
#endif	/* __cplusplus */

/* generally useful constants */
#if (ODBCVER >= 0x0200)
#define SQL_SPEC_MAJOR			  2 /* Major version of specification  */
#define SQL_SPEC_MINOR			  1 /* Minor version of specification  */
#define SQL_SPEC_STRING 	"02.01" /* String constant for version	   */
#endif	/* ODBCVER >= 0x0200 */
#define SQL_SQLSTATE_SIZE		  5 /* size of SQLSTATE 			   */
#define SQL_MAX_MESSAGE_LENGTH	512 /* message buffer size			   */
#define SQL_MAX_DSN_LENGTH		 32 /* maximum data source name size   */

/* RETCODEs */
#define SQL_INVALID_HANDLE		(-2)
#define SQL_ERROR				(-1)
#define SQL_SUCCESS 			0
#define SQL_SUCCESS_WITH_INFO	1
#define SQL_NO_DATA_FOUND		100

/* Standard SQL datatypes, using ANSI type numbering */
#define SQL_CHAR				1
#define SQL_NUMERIC 			2
#define SQL_DECIMAL 			3
#define SQL_INTEGER 			4
#define SQL_SMALLINT			5
#define SQL_FLOAT				6
#define SQL_REAL				7
#define SQL_DOUBLE				8
#define SQL_VARCHAR 			12

#define SQL_TYPE_MIN			SQL_CHAR
#define SQL_TYPE_NULL			0
#define SQL_TYPE_MAX			SQL_VARCHAR

/* C datatype to SQL datatype mapping	SQL types
										------------------- */
#define SQL_C_CHAR	  SQL_CHAR			/* CHAR, VARCHAR, DECIMAL, NUMERIC */
#define SQL_C_LONG	  SQL_INTEGER		/* INTEGER			*/
#define SQL_C_SHORT   SQL_SMALLINT		/* SMALLINT			*/
#define SQL_C_FLOAT   SQL_REAL			/* REAL				*/
#define SQL_C_DOUBLE  SQL_DOUBLE		/* FLOAT, DOUBLE	*/
#define SQL_C_DEFAULT 99

/* NULL status constants.  These are used in SQLColumns, SQLColAttributes,
SQLDescribeCol, SQLDescribeParam, and SQLSpecialColumns to describe the
nullablity of a column in a table. */
#define SQL_NO_NULLS				0
#define SQL_NULLABLE				1
#define SQL_NULLABLE_UNKNOWN		2

/* Special length values */
#define SQL_NULL_DATA				(-1)
#define SQL_DATA_AT_EXEC			(-2)
#define SQL_NTS 					(-3)

/* SQLFreeStmt defines */
#define SQL_CLOSE					0
#define SQL_DROP					1
#define SQL_UNBIND					2
#define SQL_RESET_PARAMS			3

/* SQLTransact defines */
#define SQL_COMMIT					0
#define SQL_ROLLBACK				1

/* SQLColAttributes defines */
#define SQL_COLUMN_COUNT            0
#define SQL_COLUMN_NAME             1
#define SQL_COLUMN_TYPE             2
#define SQL_COLUMN_LENGTH           3
#define SQL_COLUMN_PRECISION        4
#define SQL_COLUMN_SCALE            5
#define SQL_COLUMN_DISPLAY_SIZE     6
#define SQL_COLUMN_NULLABLE         7
#define SQL_COLUMN_UNSIGNED         8
#define SQL_COLUMN_MONEY            9
#define SQL_COLUMN_UPDATABLE		10
#define SQL_COLUMN_AUTO_INCREMENT	11
#define SQL_COLUMN_CASE_SENSITIVE	12
#define SQL_COLUMN_SEARCHABLE		13
#define SQL_COLUMN_TYPE_NAME		14
#if (ODBCVER >= 0x0200)
#define SQL_COLUMN_TABLE_NAME		15
#define SQL_COLUMN_OWNER_NAME		16
#define SQL_COLUMN_QUALIFIER_NAME	17
#define SQL_COLUMN_LABEL			18
#define SQL_COLATT_OPT_MAX			SQL_COLUMN_LABEL
#else
#define SQL_COLATT_OPT_MAX			SQL_COLUMN_TYPE_NAME
#endif	/* ODBCVER >= 0x0200 */
#define SQL_COLUMN_DRIVER_START		1000

#define	SQL_COLATT_OPT_MIN			SQL_COLUMN_COUNT

/* SQLColAttributes subdefines for SQL_COLUMN_UPDATABLE */
#define SQL_ATTR_READONLY			0
#define SQL_ATTR_WRITE				1
#define SQL_ATTR_READWRITE_UNKNOWN	2

/* SQLColAttributes subdefines for SQL_COLUMN_SEARCHABLE */
/* These are also used by SQLGetInfo                     */
#define SQL_UNSEARCHABLE			0
#define SQL_LIKE_ONLY				1
#define SQL_ALL_EXCEPT_LIKE 		2
#define SQL_SEARCHABLE				3

/* SQLError defines */
#define SQL_NULL_HENV				0
#define SQL_NULL_HDBC				0
#define SQL_NULL_HSTMT				0

/* environment specific definitions */
#ifndef EXPORT
#define EXPORT  _export
#endif

#ifdef WIN32
#define SQL_API __stdcall
#else
#define SQL_API EXPORT CALLBACK
#endif

#ifndef RC_INVOKED
/* SQL portable types for C */
typedef unsigned char       UCHAR;
typedef signed char         SCHAR;
typedef long int            SDWORD;
typedef short int           SWORD;
typedef unsigned long int   UDWORD;
typedef unsigned short int  UWORD;
#if (ODBCVER >= 0x0200)
typedef signed long 		SLONG;
typedef signed short		SSHORT;
typedef unsigned long		ULONG;
typedef unsigned short		USHORT;
#endif	/* ODBCVER >= 0x0200 */
typedef double              SDOUBLE;
#ifdef WIN32
typedef double         	    LDOUBLE; /* long double == short double in Win32 */
#else
typedef long double         LDOUBLE;
#endif
typedef float               SFLOAT;

typedef void FAR *          PTR;

typedef void FAR *          HENV;
typedef void FAR *          HDBC;
typedef void FAR *          HSTMT;

typedef signed short        RETCODE;


/* Core Function Prototypes */

RETCODE SQL_API SQLAllocConnect(
    HENV        henv,
    HDBC   FAR *phdbc);

RETCODE SQL_API SQLAllocEnv(
    HENV   FAR *phenv);

RETCODE SQL_API SQLAllocStmt(
    HDBC        hdbc,
    HSTMT  FAR *phstmt);

RETCODE SQL_API SQLBindCol(
    HSTMT       hstmt,
    UWORD       icol,
    SWORD       fCType,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

RETCODE SQL_API SQLCancel(
    HSTMT       hstmt);

RETCODE SQL_API SQLColAttributes(
    HSTMT       hstmt,
    UWORD       icol,
    UWORD       fDescType,
    PTR         rgbDesc,
	SWORD       cbDescMax,
    SWORD  FAR *pcbDesc,
    SDWORD FAR *pfDesc);

RETCODE SQL_API SQLConnect(
    HDBC        hdbc,
    UCHAR  FAR *szDSN,
    SWORD       cbDSN,
    UCHAR  FAR *szUID,
    SWORD       cbUID,
    UCHAR  FAR *szAuthStr,
    SWORD       cbAuthStr);

RETCODE SQL_API SQLDescribeCol(
    HSTMT       hstmt,
    UWORD       icol,
    UCHAR  FAR *szColName,
    SWORD       cbColNameMax,
    SWORD  FAR *pcbColName,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable);

RETCODE SQL_API SQLDisconnect(
    HDBC        hdbc);

RETCODE SQL_API SQLError(
    HENV        henv,
    HDBC        hdbc,
    HSTMT       hstmt,
    UCHAR  FAR *szSqlState,
    SDWORD FAR *pfNativeError,
    UCHAR  FAR *szErrorMsg,
    SWORD       cbErrorMsgMax,
    SWORD  FAR *pcbErrorMsg);

RETCODE SQL_API SQLExecDirect(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

RETCODE SQL_API SQLExecute(
    HSTMT       hstmt);

RETCODE SQL_API SQLFetch(
    HSTMT       hstmt);

RETCODE SQL_API SQLFreeConnect(
    HDBC        hdbc);

RETCODE SQL_API SQLFreeEnv(
    HENV        henv);

RETCODE SQL_API SQLFreeStmt(
    HSTMT       hstmt,
    UWORD       fOption);

RETCODE SQL_API SQLGetCursorName(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursorMax,
    SWORD  FAR *pcbCursor);

RETCODE SQL_API SQLNumResultCols(
    HSTMT       hstmt,
    SWORD  FAR *pccol);

RETCODE SQL_API SQLPrepare(
    HSTMT       hstmt,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStr);

RETCODE SQL_API SQLRowCount(
    HSTMT       hstmt,
    SDWORD FAR *pcrow);

RETCODE SQL_API SQLSetCursorName(
    HSTMT       hstmt,
    UCHAR  FAR *szCursor,
    SWORD       cbCursor);

RETCODE SQL_API SQLTransact(
    HENV        henv,
    HDBC        hdbc,
    UWORD       fType);

#endif /* RC_INVOKED */

/*	Deprecrated functions from prior versions of ODBC */
#ifndef RC_INVOKED

RETCODE SQL_API SQLSetParam(		/*	Use SQLBindParameter */
    HSTMT       hstmt,
    UWORD       ipar,
    SWORD       fCType,
    SWORD       fSqlType,
    UDWORD      cbColDef,
    SWORD       ibScale,
    PTR         rgbValue,
    SDWORD FAR *pcbValue);

#endif /* RC_INVOKED */


#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* #ifndef __SQL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\stdarg.h ===
/***
*stdarg.h - defines ANSI-style macros for variable argument functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines ANSI-style macros for accessing arguments
*   of functions which take a variable number of arguments.
*   [ANSI]
*
****/

#ifndef _INC_STDARG

#ifdef __cplusplus
extern "C" {
#endif 

#ifdef _WINDLL
#define _FARARG_ __far
#else 
#define _FARARG_
#endif 

#if (_MSC_VER <= 600)
#define __far       _far
#endif 

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif 

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_start(ap,v) ap = (va_list)&v + _INTSIZEOF(v)
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif 

#define _INC_STDARG
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	1

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\stddef.h ===
/***
*stddef.h - definitions/declarations for common constants, types, variables
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains definitions and declarations for some commonly
*   used constants, types, and variables.
*   [ANSI]
*
****/

#ifndef _INC_STDDEF

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

/* define the NULL pointer value and the offsetof() macro */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* offset of field m in a struct s */

#define offsetof(s,m)   (size_t)( (char *)&(((s *)0)->m) - (char *)0 )


/* errno declaration */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
#define errno   (*_errno())
#else 
extern int __near __cdecl volatile errno;
#endif 


/* define the implementation dependent size types */

#ifndef _PTRDIFF_T_DEFINED
typedef int ptrdiff_t;
#define _PTRDIFF_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 


#ifdef _MT
/* define pointer to thread id value */

extern int __far *_threadid;
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDDEF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\signal.h ===
/***
*signal.h - defines signal values and routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the signal values and declares the signal functions.
*   [ANSI/System V]
*
****/

#ifndef _INC_SIGNAL

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _SIG_ATOMIC_T_DEFINED
typedef int sig_atomic_t;
#define _SIG_ATOMIC_T_DEFINED
#endif 

#define NSIG 23     /* maximum signal number + 1 */


/* signal types */

#ifndef _WINDOWS
#define SIGINT      2   /* Ctrl-C sequence */
#define SIGILL      4   /* illegal instruction - invalid function image */
#endif 
#define SIGFPE      8   /* floating point exception */
#ifndef _WINDOWS
#define SIGSEGV     11  /* segment violation */
#define SIGTERM     15  /* Software termination signal from kill */
#define SIGABRT     22  /* abnormal termination triggered by abort call */
#endif 


/* signal action codes */

/* default signal action */
#define SIG_DFL (void (__cdecl *)(int))0

/* ignore */
#define SIG_IGN (void (__cdecl *)(int))1

/* signal error value (returned by signal call on error) */
#define SIG_ERR (void (__cdecl *)(int))-1


/* function prototypes */

void (__cdecl * __cdecl signal(int,
    void (__cdecl *)(int)))(int);
#ifndef _MT
int __cdecl raise(int);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_SIGNAL
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\sqlext.h ===
/*****************************************************************
** SQLEXT.H - This is the include for applications using
**             the Microsoft SQL Extensions
**
** (C) Copyright 1990 - 1994 By Microsoft Corp.
**
**	Updated 5/12/93 for 2.00 specification
**	Updated 5/23/94 for 2.01 specification
*********************************************************************/

#ifndef __SQLEXT
#define __SQLEXT

#ifdef __cplusplus
extern "C" {                         /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef __SQL
#include "sql.h"
#endif

/* Defines used by both Level 1 and Level 2 functions */

/* generally useful constants */
#define SQL_MAX_OPTION_STRING_LENGTH	256

/* Additional return codes */
#define SQL_STILL_EXECUTING 2
#define SQL_NEED_DATA		99

/* SQL extended datatypes */
#define SQL_DATE				 9
#define SQL_TIME				10
#define SQL_TIMESTAMP			11
#define SQL_LONGVARCHAR 		(-1)
#define SQL_BINARY				(-2)
#define SQL_VARBINARY			(-3)
#define SQL_LONGVARBINARY		(-4)
#define SQL_BIGINT				(-5)
#define SQL_TINYINT 			(-6)
#define SQL_BIT 				(-7)
#define SQL_TYPE_DRIVER_START	(-80)

#if (ODBCVER >= 0x0200)
#define SQL_SIGNED_OFFSET	(-20)
#define SQL_UNSIGNED_OFFSET (-22)
#endif	/* ODBCVER >= 0x0200 */

/* C datatype to SQL datatype mapping */
#define SQL_C_DATE		SQL_DATE
#define SQL_C_TIME		SQL_TIME
#define SQL_C_TIMESTAMP SQL_TIMESTAMP
#define SQL_C_BINARY	SQL_BINARY
#define SQL_C_BIT		SQL_BIT
#define SQL_C_TINYINT	SQL_TINYINT
#if (ODBCVER >= 0x0200)
#define SQL_C_SLONG 	SQL_C_LONG+SQL_SIGNED_OFFSET	/* SIGNED INTEGER	*/
#define SQL_C_SSHORT	SQL_C_SHORT+SQL_SIGNED_OFFSET	/* SIGNED SMALLINT	*/
#define SQL_C_STINYINT	SQL_TINYINT+SQL_SIGNED_OFFSET	/* SIGNED TINYINT	*/
#define SQL_C_ULONG 	SQL_C_LONG+SQL_UNSIGNED_OFFSET	/* UNSIGNED INTEGER */
#define SQL_C_USHORT	SQL_C_SHORT+SQL_UNSIGNED_OFFSET /* UNSIGNED SMALLINT*/
#define SQL_C_UTINYINT	SQL_TINYINT+SQL_UNSIGNED_OFFSET /* UNSIGNED TINYINT */
#define SQL_C_BOOKMARK	SQL_C_ULONG 					/* BOOKMARK 		*/
#endif	/* ODBCVER >= 0x0200 */

#ifndef RC_INVOKED
/* SQL portable types for C */
/* transfer types for DATE, TIME, TIMESTAMP */
typedef struct tagDATE_STRUCT
{
	SWORD year;
	UWORD month;
	UWORD day;
} DATE_STRUCT;

typedef struct tagTIME_STRUCT
{
	UWORD hour;
	UWORD minute;
	UWORD second;
} TIME_STRUCT;

typedef struct tagTIMESTAMP_STRUCT
{
	SWORD year;
	UWORD month;
	UWORD day;
	UWORD hour;
	UWORD minute;
	UWORD second;
	UDWORD fraction;
} TIMESTAMP_STRUCT;

#if (ODBCVER >= 0x0200)
typedef unsigned long int	BOOKMARK;
#endif	/* ODBCVER >= 0x0200 */

#endif /* RC_INVOKED */

/* from SQL.h -- extended data types change this */
#undef  SQL_TYPE_MIN  
#define SQL_TYPE_MIN					SQL_BIT
#define SQL_ALL_TYPES					0


/* Level 1 Functions			*/

/* Options for SQLDriverConnect */
#define SQL_DRIVER_NOPROMPT 			0
#define SQL_DRIVER_COMPLETE 			1
#define SQL_DRIVER_PROMPT				2
#define SQL_DRIVER_COMPLETE_REQUIRED	3

/* Special return values for SQLGetData */
#define SQL_NO_TOTAL		(-4)

/* SQLBindParameter extensions */
#if (ODBCVER >= 0x0200)
#define SQL_DEFAULT_PARAM	(-5)
#define SQL_IGNORE			(-6)
#define SQL_LEN_DATA_AT_EXEC_OFFSET (-100)
#define SQL_LEN_DATA_AT_EXEC(length) (-length+SQL_LEN_DATA_AT_EXEC_OFFSET)
#endif	/* ODBCVER >= 0x0200 */

/* Defines for SQLGetFunctions */
#define SQL_API_SQLALLOCCONNECT      1    /* Core Functions           */
#define SQL_API_SQLALLOCENV          2
#define SQL_API_SQLALLOCSTMT         3
#define SQL_API_SQLBINDCOL           4
#define SQL_API_SQLCANCEL            5
#define SQL_API_SQLCOLATTRIBUTES     6
#define SQL_API_SQLCONNECT           7
#define SQL_API_SQLDESCRIBECOL       8
#define SQL_API_SQLDISCONNECT        9
#define SQL_API_SQLERROR            10
#define SQL_API_SQLEXECDIRECT       11
#define SQL_API_SQLEXECUTE          12
#define SQL_API_SQLFETCH            13
#define SQL_API_SQLFREECONNECT      14
#define SQL_API_SQLFREEENV          15
#define SQL_API_SQLFREESTMT         16
#define SQL_API_SQLGETCURSORNAME    17
#define SQL_API_SQLNUMRESULTCOLS    18
#define SQL_API_SQLPREPARE          19
#define SQL_API_SQLROWCOUNT         20
#define SQL_API_SQLSETCURSORNAME    21
#define SQL_API_SQLSETPARAM         22
#define SQL_API_SQLTRANSACT         23

#define SQL_NUM_FUNCTIONS           23

#define SQL_EXT_API_START           40

#define SQL_API_SQLCOLUMNS          40    /* Level 1 Functions        */
#define SQL_API_SQLDRIVERCONNECT    41
#define SQL_API_SQLGETCONNECTOPTION 42
#define SQL_API_SQLGETDATA          43
#define SQL_API_SQLGETFUNCTIONS     44
#define SQL_API_SQLGETINFO          45
#define SQL_API_SQLGETSTMTOPTION    46
#define SQL_API_SQLGETTYPEINFO      47
#define SQL_API_SQLPARAMDATA        48
#define SQL_API_SQLPUTDATA          49
#define SQL_API_SQLSETCONNECTOPTION 50
#define SQL_API_SQLSETSTMTOPTION    51
#define SQL_API_SQLSPECIALCOLUMNS   52
#define SQL_API_SQLSTATISTICS       53
#define SQL_API_SQLTABLES           54

#define SQL_API_SQLBROWSECONNECT    55    /* Level 2 Functions        */
#define SQL_API_SQLCOLUMNPRIVILEGES 56
#define SQL_API_SQLDATASOURCES      57
#define SQL_API_SQLDESCRIBEPARAM    58
#define SQL_API_SQLEXTENDEDFETCH    59
#define SQL_API_SQLFOREIGNKEYS      60
#define SQL_API_SQLMORERESULTS      61
#define SQL_API_SQLNATIVESQL        62
#define SQL_API_SQLNUMPARAMS        63
#define SQL_API_SQLPARAMOPTIONS     64
#define SQL_API_SQLPRIMARYKEYS      65
#define SQL_API_SQLPROCEDURECOLUMNS 66
#define SQL_API_SQLPROCEDURES       67
#define SQL_API_SQLSETPOS           68
#define SQL_API_SQLSETSCROLLOPTIONS 69
#define SQL_API_SQLTABLEPRIVILEGES  70

/*		SDK 2.0 Additions		*/
#if (ODBCVER >= 0x0200)
#define SQL_API_SQLDRIVERS          71
#define SQL_API_SQLBINDPARAMETER	72
#define SQL_EXT_API_LAST			SQL_API_SQLBINDPARAMETER
#else
#define SQL_EXT_API_LAST			SQL_API_SQLTABLEPRIVILEGES
#endif	/* ODBCVER >= 0x0200 */

#define SQL_API_ALL_FUNCTIONS		0

#define SQL_NUM_EXTENSIONS (SQL_EXT_API_LAST-SQL_EXT_API_START+1)
#if (ODBCVER >= 0x0200)
#define SQL_API_LOADBYORDINAL		199
#endif	/* ODBCVER >= 0x0200 */

/* Defines for SQLGetInfo */
#define SQL_INFO_FIRST                       0
#define SQL_ACTIVE_CONNECTIONS               0
#define SQL_ACTIVE_STATEMENTS                1
#define SQL_DATA_SOURCE_NAME                 2
#define SQL_DRIVER_HDBC                      3
#define SQL_DRIVER_HENV                      4
#define SQL_DRIVER_HSTMT                     5
#define SQL_DRIVER_NAME                      6
#define SQL_DRIVER_VER                       7
#define SQL_FETCH_DIRECTION                  8
#define SQL_ODBC_API_CONFORMANCE             9
#define SQL_ODBC_VER                        10
#define SQL_ROW_UPDATES                     11
#define SQL_ODBC_SAG_CLI_CONFORMANCE        12
#define SQL_SERVER_NAME                     13
#define SQL_SEARCH_PATTERN_ESCAPE           14
#define SQL_ODBC_SQL_CONFORMANCE            15

#define SQL_DBMS_NAME                       17
#define SQL_DBMS_VER                        18

#define SQL_ACCESSIBLE_TABLES               19
#define SQL_ACCESSIBLE_PROCEDURES           20
#define SQL_PROCEDURES                      21
#define SQL_CONCAT_NULL_BEHAVIOR            22
#define SQL_CURSOR_COMMIT_BEHAVIOR          23
#define SQL_CURSOR_ROLLBACK_BEHAVIOR        24
#define SQL_DATA_SOURCE_READ_ONLY           25
#define SQL_DEFAULT_TXN_ISOLATION           26
#define SQL_EXPRESSIONS_IN_ORDERBY          27
#define SQL_IDENTIFIER_CASE                 28
#define SQL_IDENTIFIER_QUOTE_CHAR           29
#define SQL_MAX_COLUMN_NAME_LEN             30
#define SQL_MAX_CURSOR_NAME_LEN             31
#define SQL_MAX_OWNER_NAME_LEN              32
#define SQL_MAX_PROCEDURE_NAME_LEN          33
#define SQL_MAX_QUALIFIER_NAME_LEN          34
#define SQL_MAX_TABLE_NAME_LEN              35
#define SQL_MULT_RESULT_SETS                36
#define SQL_MULTIPLE_ACTIVE_TXN             37
#define SQL_OUTER_JOINS                     38
#define SQL_OWNER_TERM                      39
#define SQL_PROCEDURE_TERM                  40
#define SQL_QUALIFIER_NAME_SEPARATOR        41
#define SQL_QUALIFIER_TERM                  42
#define SQL_SCROLL_CONCURRENCY              43
#define SQL_SCROLL_OPTIONS                  44
#define SQL_TABLE_TERM                      45
#define SQL_TXN_CAPABLE                     46
#define SQL_USER_NAME                       47

#define SQL_CONVERT_FUNCTIONS               48
#define SQL_NUMERIC_FUNCTIONS               49
#define SQL_STRING_FUNCTIONS                50
#define SQL_SYSTEM_FUNCTIONS                51
#define SQL_TIMEDATE_FUNCTIONS              52

#define SQL_CONVERT_BIGINT                  53
#define SQL_CONVERT_BINARY                  54
#define SQL_CONVERT_BIT                     55
#define SQL_CONVERT_CHAR                    56
#define SQL_CONVERT_DATE                    57
#define SQL_CONVERT_DECIMAL                 58
#define SQL_CONVERT_DOUBLE                  59
#define SQL_CONVERT_FLOAT                   60
#define SQL_CONVERT_INTEGER                 61
#define SQL_CONVERT_LONGVARCHAR             62
#define SQL_CONVERT_NUMERIC                 63
#define SQL_CONVERT_REAL                    64
#define SQL_CONVERT_SMALLINT                65
#define SQL_CONVERT_TIME                    66
#define SQL_CONVERT_TIMESTAMP               67
#define SQL_CONVERT_TINYINT                 68
#define SQL_CONVERT_VARBINARY               69
#define SQL_CONVERT_VARCHAR                 70
#define SQL_CONVERT_LONGVARBINARY           71

#define SQL_TXN_ISOLATION_OPTION            72
#define SQL_ODBC_SQL_OPT_IEF                73

/*** ODBC SDK 1.0 Additions ***/
#define SQL_CORRELATION_NAME				74
#define SQL_NON_NULLABLE_COLUMNS			75

/*** ODBC SDK 2.0 Additions ***/
#if (ODBCVER >= 0x0200)
#define SQL_DRIVER_HLIB 					76
#define SQL_DRIVER_ODBC_VER 				77
#define SQL_LOCK_TYPES						78
#define SQL_POS_OPERATIONS					79
#define SQL_POSITIONED_STATEMENTS			80
#define SQL_GETDATA_EXTENSIONS				81
#define SQL_BOOKMARK_PERSISTENCE			82
#define SQL_STATIC_SENSITIVITY				83
#define SQL_FILE_USAGE						84
#define SQL_NULL_COLLATION					85
#define SQL_ALTER_TABLE 					86
#define SQL_COLUMN_ALIAS					87
#define SQL_GROUP_BY						88
#define SQL_KEYWORDS						89
#define SQL_ORDER_BY_COLUMNS_IN_SELECT		90
#define SQL_OWNER_USAGE 					91
#define SQL_QUALIFIER_USAGE 				92
#define SQL_QUOTED_IDENTIFIER_CASE			93
#define SQL_SPECIAL_CHARACTERS				94
#define SQL_SUBQUERIES						95
#define SQL_UNION							96
#define SQL_MAX_COLUMNS_IN_GROUP_BY 		97
#define SQL_MAX_COLUMNS_IN_INDEX			98
#define SQL_MAX_COLUMNS_IN_ORDER_BY 		99
#define SQL_MAX_COLUMNS_IN_SELECT		   100
#define SQL_MAX_COLUMNS_IN_TABLE		   101
#define SQL_MAX_INDEX_SIZE				   102
#define SQL_MAX_ROW_SIZE_INCLUDES_LONG	   103
#define SQL_MAX_ROW_SIZE				   104
#define SQL_MAX_STATEMENT_LEN			   105
#define SQL_MAX_TABLES_IN_SELECT		   106
#define SQL_MAX_USER_NAME_LEN			   107
#define SQL_MAX_CHAR_LITERAL_LEN 		   108
#define SQL_TIMEDATE_ADD_INTERVALS		   109
#define SQL_TIMEDATE_DIFF_INTERVALS 	   110
#define SQL_NEED_LONG_DATA_LEN			   111
#define SQL_MAX_BINARY_LITERAL_LEN		   112
#define SQL_LIKE_ESCAPE_CLAUSE			   113
#define SQL_QUALIFIER_LOCATION			   114

#if (ODBCVER >= 0x0201)
/*** ODBC SDK 2.01 Additions ***/
#define SQL_OJ_CAPABILITIES 			 65002	/* Temp value until ODBC 3.0 */
#endif	/* ODBCVER >= 0x0201 */

#define SQL_INFO_LAST						SQL_QUALIFIER_LOCATION
#else
#define SQL_INFO_LAST						SQL_NON_NULLABLE_COLUMNS
#endif	/* ODBCVER >= 0x0200 */

#define SQL_INFO_DRIVER_START             1000

/* SQL_CONVERT_*  return value bitmasks */

#define SQL_CVT_CHAR				0x00000001L
#define SQL_CVT_NUMERIC 			0x00000002L
#define SQL_CVT_DECIMAL 			0x00000004L
#define SQL_CVT_INTEGER 			0x00000008L
#define SQL_CVT_SMALLINT			0x00000010L
#define SQL_CVT_FLOAT				0x00000020L
#define SQL_CVT_REAL				0x00000040L
#define SQL_CVT_DOUBLE				0x00000080L
#define SQL_CVT_VARCHAR 			0x00000100L
#define SQL_CVT_LONGVARCHAR 		0x00000200L
#define SQL_CVT_BINARY				0x00000400L
#define SQL_CVT_VARBINARY			0x00000800L
#define SQL_CVT_BIT 				0x00001000L
#define SQL_CVT_TINYINT 			0x00002000L
#define SQL_CVT_BIGINT				0x00004000L
#define SQL_CVT_DATE				0x00008000L
#define SQL_CVT_TIME				0x00010000L
#define SQL_CVT_TIMESTAMP			0x00020000L
#define SQL_CVT_LONGVARBINARY		0x00040000L

/* SQL_CONVERT_FUNCTIONS functions */
#define SQL_FN_CVT_CONVERT			0x00000001L

/* SQL_STRING_FUNCTIONS functions */

#define SQL_FN_STR_CONCAT			0x00000001L
#define SQL_FN_STR_INSERT			0x00000002L
#define SQL_FN_STR_LEFT 			0x00000004L
#define SQL_FN_STR_LTRIM			0x00000008L
#define SQL_FN_STR_LENGTH			0x00000010L
#define SQL_FN_STR_LOCATE			0x00000020L
#define SQL_FN_STR_LCASE			0x00000040L
#define SQL_FN_STR_REPEAT			0x00000080L
#define SQL_FN_STR_REPLACE			0x00000100L
#define SQL_FN_STR_RIGHT			0x00000200L
#define SQL_FN_STR_RTRIM			0x00000400L
#define SQL_FN_STR_SUBSTRING		0x00000800L
#define SQL_FN_STR_UCASE			0x00001000L
#define SQL_FN_STR_ASCII			0x00002000L
#define SQL_FN_STR_CHAR 			0x00004000L
#if (ODBCVER >= 0x0200)
#define SQL_FN_STR_DIFFERENCE		0x00008000L
#define SQL_FN_STR_LOCATE_2 		0x00010000L
#define SQL_FN_STR_SOUNDEX			0x00020000L
#define SQL_FN_STR_SPACE			0x00040000L
#endif	/* ODBCVER >= 0x0200 */

/* SQL_NUMERIC_FUNCTIONS functions */

#define SQL_FN_NUM_ABS				0x00000001L
#define SQL_FN_NUM_ACOS 			0x00000002L
#define SQL_FN_NUM_ASIN 			0x00000004L
#define SQL_FN_NUM_ATAN 			0x00000008L
#define SQL_FN_NUM_ATAN2			0x00000010L
#define SQL_FN_NUM_CEILING			0x00000020L
#define SQL_FN_NUM_COS				0x00000040L
#define SQL_FN_NUM_COT				0x00000080L
#define SQL_FN_NUM_EXP				0x00000100L
#define SQL_FN_NUM_FLOOR			0x00000200L
#define SQL_FN_NUM_LOG				0x00000400L
#define SQL_FN_NUM_MOD				0x00000800L
#define SQL_FN_NUM_SIGN 			0x00001000L
#define SQL_FN_NUM_SIN				0x00002000L
#define SQL_FN_NUM_SQRT 			0x00004000L
#define SQL_FN_NUM_TAN				0x00008000L
#define SQL_FN_NUM_PI				0x00010000L
#define SQL_FN_NUM_RAND 			0x00020000L
#if (ODBCVER >= 0x0200)
#define SQL_FN_NUM_DEGREES			0x00040000L
#define SQL_FN_NUM_LOG10			0x00080000L
#define SQL_FN_NUM_POWER			0x00100000L
#define SQL_FN_NUM_RADIANS			0x00200000L
#define SQL_FN_NUM_ROUND			0x00400000L
#define SQL_FN_NUM_TRUNCATE 		0x00800000L
#endif	/* ODBCVER >= 0x0200 */

/* SQL_TIMEDATE_FUNCTIONS functions */

#define SQL_FN_TD_NOW				0x00000001L
#define SQL_FN_TD_CURDATE			0x00000002L
#define SQL_FN_TD_DAYOFMONTH		0x00000004L
#define SQL_FN_TD_DAYOFWEEK 		0x00000008L
#define SQL_FN_TD_DAYOFYEAR 		0x00000010L
#define SQL_FN_TD_MONTH 			0x00000020L
#define SQL_FN_TD_QUARTER			0x00000040L
#define SQL_FN_TD_WEEK				0x00000080L
#define SQL_FN_TD_YEAR				0x00000100L
#define SQL_FN_TD_CURTIME			0x00000200L
#define SQL_FN_TD_HOUR				0x00000400L
#define SQL_FN_TD_MINUTE			0x00000800L
#define SQL_FN_TD_SECOND			0x00001000L
#if (ODBCVER >= 0x0200)
#define SQL_FN_TD_TIMESTAMPADD		0x00002000L
#define SQL_FN_TD_TIMESTAMPDIFF 	0x00004000L
#define SQL_FN_TD_DAYNAME			0x00008000L
#define SQL_FN_TD_MONTHNAME 		0x00010000L
#endif	/* ODBCVER >= 0x0200 */

/* SQL_SYSTEM_FUNCTIONS functions */

#define SQL_FN_SYS_USERNAME 		0x00000001L
#define SQL_FN_SYS_DBNAME			0x00000002L
#define SQL_FN_SYS_IFNULL			0x00000004L

/* SQL_TIMEDATE_ADD_INTERVALS and SQL_TIMEDATE_DIFF_INTERVALS functions */

#if (ODBCVER >= 0x0200)
#define SQL_FN_TSI_FRAC_SECOND		0x00000001L
#define SQL_FN_TSI_SECOND			0x00000002L
#define SQL_FN_TSI_MINUTE			0x00000004L
#define SQL_FN_TSI_HOUR 			0x00000008L
#define SQL_FN_TSI_DAY				0x00000010L
#define SQL_FN_TSI_WEEK 			0x00000020L
#define SQL_FN_TSI_MONTH			0x00000040L
#define SQL_FN_TSI_QUARTER			0x00000080L
#define SQL_FN_TSI_YEAR 			0x00000100L
#endif	/* ODBCVER >= 0x0200 */

/* SQL_ODBC_API_CONFORMANCE values */

#define SQL_OAC_NONE				0x0000
#define SQL_OAC_LEVEL1				0x0001
#define SQL_OAC_LEVEL2				0x0002

/* SQL_ODBC_SAG_CLI_CONFORMANCE values */

#define SQL_OSCC_NOT_COMPLIANT		0x0000
#define SQL_OSCC_COMPLIANT			0x0001

/* SQL_ODBC_SQL_CONFORMANCE values */

#define SQL_OSC_MINIMUM 			0x0000
#define SQL_OSC_CORE				0x0001
#define SQL_OSC_EXTENDED			0x0002

/* SQL_CONCAT_NULL_BEHAVIOR values */

#define SQL_CB_NULL 				0x0000
#define SQL_CB_NON_NULL 			0x0001

/* SQL_CURSOR_COMMIT_BEHAVIOR and SQL_CURSOR_ROLLBACK_BEHAVIOR values */

#define SQL_CB_DELETE				0x0000
#define SQL_CB_CLOSE				0x0001
#define SQL_CB_PRESERVE				0x0002

/* SQL_IDENTIFIER_CASE values */

#define SQL_IC_UPPER				0x0001
#define SQL_IC_LOWER				0x0002
#define SQL_IC_SENSITIVE			0x0003
#define SQL_IC_MIXED				0x0004

/* SQL_TXN_CAPABLE values */

#define SQL_TC_NONE 				0x0000
#define SQL_TC_DML					0x0001
#define SQL_TC_ALL					0x0002
#if (ODBCVER >= 0x0200)
#define SQL_TC_DDL_COMMIT			0x0003
#define SQL_TC_DDL_IGNORE			0x0004
#endif	/* ODBCVER >= 0x0200 */

/* SQL_SCROLL_OPTIONS masks */

#define SQL_SO_FORWARD_ONLY 		0x00000001L
#define SQL_SO_KEYSET_DRIVEN		0x00000002L
#define SQL_SO_DYNAMIC				0x00000004L
#define SQL_SO_MIXED				0x00000008L
#if (ODBCVER >= 0x0200)
#define SQL_SO_STATIC				0x00000010L
#endif	/* ODBCVER >= 0x0200 */

/* SQL_SCROLL_CONCURRENCY masks */

#define SQL_SCCO_READ_ONLY			0x00000001L
#define SQL_SCCO_LOCK				0x00000002L
#define SQL_SCCO_OPT_ROWVER 		0x00000004L
#define SQL_SCCO_OPT_VALUES 		0x00000008L

/* SQL_FETCH_DIRECTION masks */

#define SQL_FD_FETCH_NEXT			0x00000001L
#define SQL_FD_FETCH_FIRST			0x00000002L
#define SQL_FD_FETCH_LAST			0x00000004L
#define SQL_FD_FETCH_PRIOR			0x00000008L
#define SQL_FD_FETCH_ABSOLUTE		0x00000010L
#define SQL_FD_FETCH_RELATIVE		0x00000020L
#define SQL_FD_FETCH_RESUME 		0x00000040L
#if (ODBCVER >= 0x0200)
#define SQL_FD_FETCH_BOOKMARK		0x00000080L
#endif	/* ODBCVER >= 0x0200 */

/* SQL_TXN_ISOLATION_OPTION masks */

#define SQL_TXN_READ_UNCOMMITTED	0x00000001L
#define SQL_TXN_READ_COMMITTED		0x00000002L
#define SQL_TXN_REPEATABLE_READ 	0x00000004L
#define SQL_TXN_SERIALIZABLE		0x00000008L
#define SQL_TXN_VERSIONING			0x00000010L

/* SQL_CORRELATION_NAME values */

#define SQL_CN_NONE 				0x0000
#define SQL_CN_DIFFERENT			0x0001
#define SQL_CN_ANY					0x0002

/* SQL_NON_NULLABLE_COLUMNS values */

#define SQL_NNC_NULL			   	0x0000
#define SQL_NNC_NON_NULL			0x0001

#if (ODBCVER >= 0x0200)
/* SQL_NULL_COLLATION values */
									  
#define SQL_NC_HIGH 				0x0000
#define SQL_NC_LOW					0x0001
#define SQL_NC_START				0x0002
#define SQL_NC_END					0x0004

/* SQL_FILE_USAGE values */

#define SQL_FILE_NOT_SUPPORTED		0x0000
#define SQL_FILE_TABLE				0x0001
#define SQL_FILE_QUALIFIER			0x0002

/* SQL_GETDATA_EXTENSIONS values */

#define SQL_GD_ANY_COLUMN			0x00000001L
#define SQL_GD_ANY_ORDER			0x00000002L
#define SQL_GD_BLOCK				0x00000004L
#define SQL_GD_BOUND				0x00000008L

/* SQL_ALTER_TABLE values */

#define SQL_AT_ADD_COLUMN			0x00000001L
#define SQL_AT_DROP_COLUMN			0x00000002L

/* SQL_POSITIONED_STATEMENTS masks */

#define SQL_PS_POSITIONED_DELETE	0x00000001L
#define SQL_PS_POSITIONED_UPDATE	0x00000002L
#define SQL_PS_SELECT_FOR_UPDATE	0x00000004L

/* SQL_GROUP_BY values */

#define SQL_GB_NOT_SUPPORTED			0x0000
#define SQL_GB_GROUP_BY_EQUALS_SELECT	0x0001
#define SQL_GB_GROUP_BY_CONTAINS_SELECT	0x0002
#define SQL_GB_NO_RELATION				0x0003
													
/* SQL_OWNER_USAGE masks */

#define SQL_OU_DML_STATEMENTS		0x00000001L
#define SQL_OU_PROCEDURE_INVOCATION 0x00000002L
#define SQL_OU_TABLE_DEFINITION 	0x00000004L
#define SQL_OU_INDEX_DEFINITION 	0x00000008L
#define SQL_OU_PRIVILEGE_DEFINITION 0x00000010L

/* SQL_QUALIFIER_USAGE masks */

#define SQL_QU_DML_STATEMENTS		0x00000001L
#define SQL_QU_PROCEDURE_INVOCATION 0x00000002L
#define SQL_QU_TABLE_DEFINITION 	0x00000004L
#define SQL_QU_INDEX_DEFINITION 	0x00000008L
#define SQL_QU_PRIVILEGE_DEFINITION 0x00000010L

/* SQL_SUBQUERIES masks */

#define SQL_SQ_COMPARISON				0x00000001L
#define SQL_SQ_EXISTS					0x00000002L
#define SQL_SQ_IN						0x00000004L
#define SQL_SQ_QUANTIFIED				0x00000008L
#define SQL_SQ_CORRELATED_SUBQUERIES	0x00000010L

/* SQL_UNION masks */

#define SQL_U_UNION						0x00000001L
#define SQL_U_UNION_ALL					0x00000002L

/* SQL_BOOKMARK_PERSISTENCE values */

#define SQL_BP_CLOSE				0x00000001L
#define SQL_BP_DELETE				0x00000002L
#define SQL_BP_DROP 				0x00000004L
#define SQL_BP_TRANSACTION			0x00000008L
#define SQL_BP_UPDATE				0x00000010L
#define SQL_BP_OTHER_HSTMT			0x00000020L
#define SQL_BP_SCROLL				0x00000040L

/* SQL_STATIC_SENSITIVITY values */

#define SQL_SS_ADDITIONS			0x00000001L
#define SQL_SS_DELETIONS			0x00000002L
#define SQL_SS_UPDATES				0x00000004L

/* SQL_LOCK_TYPESL masks */

#define SQL_LCK_NO_CHANGE			0x00000001L
#define SQL_LCK_EXCLUSIVE			0x00000002L
#define SQL_LCK_UNLOCK				0x00000004L

/* SQL_POS_OPERATIONS masks */

#define SQL_POS_POSITION			0x00000001L
#define SQL_POS_REFRESH 			0x00000002L
#define SQL_POS_UPDATE				0x00000004L
#define SQL_POS_DELETE				0x00000008L
#define SQL_POS_ADD					0x00000010L

/* SQL_QUALIFIER_LOCATION values */

#define SQL_QL_START				0x0001L
#define SQL_QL_END					0x0002L

/* SQL_OJ_CAPABILITIES values */

#if (ODBCVER >= 0x0201)
#define SQL_OJ_LEFT					0x00000001L
#define SQL_OJ_RIGHT				0x00000002L
#define SQL_OJ_FULL					0x00000004L
#define SQL_OJ_NESTED				0x00000008L
#define SQL_OJ_NOT_ORDERED			0x00000010L
#define SQL_OJ_INNER				0x00000020L
#define SQL_OJ_ALL_COMPARISON_OPS	0x00000040L
#endif	/* ODBCVER >= 0x0201 */
#endif	/* ODBCVER >= 0x0200 */

/* options for SQLGetStmtOption/SQLSetStmtOption */
#define SQL_QUERY_TIMEOUT			0
#define SQL_MAX_ROWS				1
#define SQL_NOSCAN					2
#define SQL_MAX_LENGTH				3
#define SQL_ASYNC_ENABLE			4
#define SQL_BIND_TYPE				5
#if (ODBCVER >= 0x0200)
#define SQL_CURSOR_TYPE 			6
#define SQL_CONCURRENCY 			7
#define SQL_KEYSET_SIZE 			8
#define SQL_ROWSET_SIZE 			9
#define SQL_SIMULATE_CURSOR 		10
#define SQL_RETRIEVE_DATA			11
#define SQL_USE_BOOKMARKS			12
#define SQL_GET_BOOKMARK			13	/*	GetStmtOption Only */
#define SQL_ROW_NUMBER				14	/*	GetStmtOption Only */
#define SQL_STMT_OPT_MAX			SQL_ROW_NUMBER
#else
#define SQL_STMT_OPT_MAX			SQL_BIND_TYPE
#endif	/* ODBCVER >= 0x0200 */

#define SQL_STMT_OPT_MIN			SQL_QUERY_TIMEOUT


/* SQL_QUERY_TIMEOUT options */
#define SQL_QUERY_TIMEOUT_DEFAULT	0UL

/* SQL_MAX_ROWS options */
#define SQL_MAX_ROWS_DEFAULT		0UL

/* SQL_NOSCAN options */
#define SQL_NOSCAN_OFF				0UL	/*	1.0 FALSE */
#define SQL_NOSCAN_ON				1UL	/*	1.0 TRUE */
#define SQL_NOSCAN_DEFAULT			SQL_NOSCAN_OFF

/* SQL_MAX_LENGTH options */
#define SQL_MAX_LENGTH_DEFAULT		0UL

/* SQL_ASYNC_ENABLE options */
#define SQL_ASYNC_ENABLE_OFF		0UL
#define SQL_ASYNC_ENABLE_ON			1UL
#define SQL_ASYNC_ENABLE_DEFAULT	SQL_ASYNC_ENABLE_OFF

/* SQL_BIND_TYPE options */
#define SQL_BIND_BY_COLUMN			0UL

/* SQL_CONCURRENCY options */
#define SQL_CONCUR_READ_ONLY		1
#define SQL_CONCUR_LOCK 			2
#define SQL_CONCUR_ROWVER			3
#define SQL_CONCUR_VALUES			4

#if (ODBCVER >= 0x0200)
/* SQL_CURSOR_TYPE options */
#define SQL_CURSOR_FORWARD_ONLY 	0UL
#define SQL_CURSOR_KEYSET_DRIVEN	1UL
#define SQL_CURSOR_DYNAMIC			2UL
#define SQL_CURSOR_STATIC			3UL

/* SQL_ROWSET_SIZE options */
#define SQL_ROWSET_SIZE_DEFAULT 	1UL

/* SQL_KEYSET_SIZE options */
#define SQL_KEYSET_SIZE_DEFAULT		0UL

/* SQL_SIMULATE_CURSOR options */
#define SQL_SC_NON_UNIQUE			0UL
#define SQL_SC_TRY_UNIQUE			1UL
#define SQL_SC_UNIQUE				2UL

/* SQL_RETRIEVE_DATA options */
#define SQL_RD_OFF					0UL
#define SQL_RD_ON					1UL
#define SQL_RD_DEFAULT				SQL_RD_ON

/* SQL_USE_BOOKMARKS options */
#define SQL_UB_OFF					0UL
#define SQL_UB_ON					1UL
#define SQL_UB_DEFAULT				SQL_UB_OFF

#endif	/* ODBCVER >= 0x0200 */

/* options for SQLSetConnectOption/SQLGetConnectOption */
#define SQL_ACCESS_MODE 			101
#define SQL_AUTOCOMMIT				102
#define SQL_LOGIN_TIMEOUT			103
#define SQL_OPT_TRACE				104
#define SQL_OPT_TRACEFILE			105
#define SQL_TRANSLATE_DLL			106
#define SQL_TRANSLATE_OPTION		107
#define SQL_TXN_ISOLATION			108
#define SQL_CURRENT_QUALIFIER		109
#if (ODBCVER >= 0x0200)
#define SQL_ODBC_CURSORS			110
#define SQL_QUIET_MODE				111
#define SQL_PACKET_SIZE 			112
#define SQL_CONN_OPT_MAX			SQL_PACKET_SIZE
#else
#define SQL_CONN_OPT_MAX			SQL_CURRENT_QUALIFIER
#endif	/* ODBCVER >= 0x0200 */
#define SQL_CONNECT_OPT_DRVR_START	1000

#define	SQL_CONN_OPT_MIN			SQL_ACCESS_MODE

/* SQL_ACCESS_MODE options */
#define SQL_MODE_READ_WRITE 		0UL
#define SQL_MODE_READ_ONLY			1UL
#define SQL_MODE_DEFAULT			SQL_MODE_READ_WRITE

/* SQL_AUTOCOMMIT options */
#define SQL_AUTOCOMMIT_OFF			0UL
#define SQL_AUTOCOMMIT_ON			1UL
#define SQL_AUTOCOMMIT_DEFAULT		SQL_AUTOCOMMIT_ON

/* SQL_LOGIN_TIMEOUT options */
#define SQL_LOGIN_TIMEOUT_DEFAULT	15UL

/* SQL_OPT_TRACE options */
#define SQL_OPT_TRACE_OFF			0UL
#define SQL_OPT_TRACE_ON			1UL
#define SQL_OPT_TRACE_DEFAULT		SQL_OPT_TRACE_OFF
#define SQL_OPT_TRACE_FILE_DEFAULT	"\\SQL.LOG"

#if (ODBCVER >= 0x0200)
/* SQL_ODBC_CURSORS options */
#define SQL_CUR_USE_IF_NEEDED		0UL
#define SQL_CUR_USE_ODBC			1UL
#define SQL_CUR_USE_DRIVER			2UL
#define SQL_CUR_DEFAULT 			SQL_CUR_USE_DRIVER
#endif	/* ODBCVER >= 0x0200 */

/* Column types and scopes in SQLSpecialColumns.  */
#define SQL_BEST_ROWID				1
#define SQL_ROWVER					2

#define SQL_SCOPE_CURROW			0
#define SQL_SCOPE_TRANSACTION		1
#define SQL_SCOPE_SESSION			2

/* Defines for SQLSetPos */
#define SQL_ENTIRE_ROWSET			0

/* Operations in SQLSetPos */
#define SQL_POSITION				0		/*	1.0 FALSE */
#define SQL_REFRESH 				1		/*	1.0 TRUE */
#if (ODBCVER >= 0x0200)
#define SQL_UPDATE					2
#define SQL_DELETE					3
#define SQL_ADD						4
#endif	/* ODBCVER >= 0x0200 */

/* Lock options in SQLSetPos */
#define SQL_LOCK_NO_CHANGE			0 		/*	1.0 FALSE */
#define SQL_LOCK_EXCLUSIVE			1		/*	1.0 TRUE */
#if (ODBCVER >= 0x0200)
#define SQL_LOCK_UNLOCK 			2

/* Macros for SQLSetPos */
#define SQL_POSITION_TO(hstmt,irow) SQLSetPos(hstmt,irow,SQL_POSITION,SQL_LOCK_NO_CHANGE)
#define SQL_LOCK_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_POSITION,fLock)
#define SQL_REFRESH_RECORD(hstmt,irow,fLock) SQLSetPos(hstmt,irow,SQL_REFRESH,fLock)
#define SQL_UPDATE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_UPDATE,SQL_LOCK_NO_CHANGE)
#define SQL_DELETE_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_DELETE,SQL_LOCK_NO_CHANGE)
#define SQL_ADD_RECORD(hstmt,irow) SQLSetPos(hstmt,irow,SQL_ADD,SQL_LOCK_NO_CHANGE)
#endif	/* ODBCVER >= 0x0200 */

#ifndef RC_INVOKED

#if (ODBCVER >= 0x0200)
/*	This define is too large for RC */
#define SQL_ODBC_KEYWORDS \
"ABSOLUTE,ACTION,ADA,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,"\
"ASC,ASSERTION,AT,AUTHORIZATION,AVG,"\
"BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,"\
"CHAR,CHAR_LENGTH,CHARACTER,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,"\
"COBOL,COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,"\
"CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,"\
"CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,"\
"DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,"\
"DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,"\
"DISTINCT,DOMAIN,DOUBLE,DROP,"\
"ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,"\
"EXISTS,EXTERNAL,EXTRACT,"\
"FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FORTRAN,FOUND,FROM,FULL,"\
"GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,"\
"IDENTITY,IMMEDIATE,IN,INCLUDE,INDEX,INDICATOR,INITIALLY,INNER,"\
"INPUT,INSENSITIVE,INSERT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,"\
"JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,"\
"MATCH,MAX,MIN,MINUTE,MODULE,MONTH,MUMPS,"\
"NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NONE,NOT,NULL,NULLIF,NUMERIC,"\
"OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,"\
"PAD,PARTIAL,PASCAL,PLI,POSITION,PRECISION,PREPARE,PRESERVE,"\
"PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,"\
"REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWS,"\
"SCHEMA,SCROLL,SECOND,SECTION,SELECT,SEQUENCE,SESSION,SESSION_USER,SET,SIZE,"\
"SMALLINT,SOME,SPACE,SQL,SQLCA,SQLCODE,SQLERROR,SQLSTATE,SQLWARNING,"\
"SUBSTRING,SUM,SYSTEM_USER,"\
"TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,"\
"TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,"\
"UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,"\
"VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,YEAR"
#endif	/* ODBCVER >= 0x0200 */

/* Level 1 Prototypes */
RETCODE SQL_API SQLColumns(
    HSTMT       hstmt,
    UCHAR  FAR *szTableQualifier,
    SWORD       cbTableQualifier,
    UCHAR  FAR *szTableOwner,
    SWORD       cbTableOwner,
    UCHAR  FAR *szTableName,
    SWORD       cbTableName,
    UCHAR  FAR *szColumnName,
    SWORD       cbColumnName);

RETCODE SQL_API SQLDriverConnect(
    HDBC        hdbc,
    HWND        hwnd,
    UCHAR  FAR *szConnStrIn,
    SWORD       cbConnStrIn,
    UCHAR  FAR *szConnStrOut,
    SWORD       cbConnStrOutMax,
    SWORD  FAR *pcbConnStrOut,
    UWORD       fDriverCompletion);

RETCODE SQL_API SQLGetConnectOption(
    HDBC        hdbc,
    UWORD       fOption,
    PTR         pvParam);

RETCODE SQL_API SQLGetData(
    HSTMT       hstmt,
    UWORD       icol,
    SWORD       fCType,
    PTR         rgbValue,
    SDWORD      cbValueMax,
    SDWORD FAR *pcbValue);

RETCODE SQL_API SQLGetFunctions(
    HDBC        hdbc,
    UWORD       fFunction,
    UWORD  FAR *pfExists);

RETCODE SQL_API SQLGetInfo(
    HDBC        hdbc,
    UWORD       fInfoType,
    PTR         rgbInfoValue,
    SWORD       cbInfoValueMax,
    SWORD  FAR *pcbInfoValue);

RETCODE SQL_API SQLGetStmtOption(
    HSTMT       hstmt,
    UWORD       fOption,
    PTR         pvParam);

RETCODE SQL_API SQLGetTypeInfo(
    HSTMT       hstmt,
    SWORD       fSqlType);

RETCODE SQL_API SQLParamData(
    HSTMT       hstmt,
    PTR    FAR *prgbValue);

RETCODE SQL_API SQLPutData(
    HSTMT       hstmt,
    PTR         rgbValue,
    SDWORD      cbValue);

RETCODE SQL_API SQLSetConnectOption(
    HDBC        hdbc,
    UWORD       fOption,
    UDWORD      vParam);

RETCODE SQL_API SQLSetStmtOption(
    HSTMT       hstmt,
    UWORD       fOption,
    UDWORD      vParam);

RETCODE SQL_API SQLSpecialColumns(
    HSTMT       hstmt,
    UWORD       fColType,
    UCHAR  FAR *szTableQualifier,
    SWORD       cbTableQualifier,
    UCHAR  FAR *szTableOwner,
    SWORD       cbTableOwner,
    UCHAR  FAR *szTableName,
    SWORD       cbTableName,
    UWORD       fScope,
    UWORD       fNullable);

RETCODE SQL_API SQLStatistics(
    HSTMT       hstmt,
    UCHAR  FAR *szTableQualifier,
    SWORD       cbTableQualifier,
    UCHAR  FAR *szTableOwner,
    SWORD       cbTableOwner,
    UCHAR  FAR *szTableName,
    SWORD       cbTableName,
    UWORD       fUnique,
    UWORD       fAccuracy);

RETCODE SQL_API SQLTables(
    HSTMT       hstmt,
    UCHAR  FAR *szTableQualifier,
    SWORD       cbTableQualifier,
    UCHAR  FAR *szTableOwner,
    SWORD       cbTableOwner,
    UCHAR  FAR *szTableName,
    SWORD       cbTableName,
    UCHAR  FAR *szTableType,
    SWORD       cbTableType);
#endif /* RC_INVOKED */


/* Level 2 Functions                             */

/* SQLExtendedFetch "fFetchType" values */
#define SQL_FETCH_NEXT			 1
#define SQL_FETCH_FIRST 		 2
#define SQL_FETCH_LAST			 3
#define SQL_FETCH_PRIOR			 4
#define SQL_FETCH_ABSOLUTE		 5
#define SQL_FETCH_RELATIVE		 6
#if (ODBCVER >= 0x0200)
#define SQL_FETCH_BOOKMARK		 8
#endif	/* ODBCVER >= 0x0200 */

/* SQLExtendedFetch "rgfRowStatus" element values */
#define SQL_ROW_SUCCESS 		0
#define SQL_ROW_DELETED 		1
#define SQL_ROW_UPDATED 		2
#define SQL_ROW_NOROW			3
#if (ODBCVER >= 0x0200)
#define SQL_ROW_ADDED			4
#define SQL_ROW_ERROR			5
#endif	/* ODBCVER >= 0x0200 */

/* Defines for SQLForeignKeys (returned in result set) */
#define SQL_CASCADE 			0
#define SQL_RESTRICT			1
#define SQL_SET_NULL			2

/* Defines for SQLBindParameter and
			   SQLProcedureColumns (returned in the result set) */
#define SQL_PARAM_TYPE_UNKNOWN  0
#define SQL_PARAM_INPUT         1
#define SQL_PARAM_INPUT_OUTPUT  2
#define SQL_RESULT_COL          3
#if (ODBCVER >= 0x0200)
#define SQL_PARAM_OUTPUT		4
#define SQL_RETURN_VALUE		5
#endif	/* ODBCVER >= 0x0200 */

/* Defines used by Driver Manager when mapping SQLSetParam to SQLBindParameter */
#define SQL_PARAM_TYPE_DEFAULT	SQL_PARAM_INPUT_OUTPUT
#define SQL_SETPARAM_VALUE_MAX	(-1L)

/* Defines for SQLStatistics */
#define SQL_INDEX_UNIQUE		0
#define SQL_INDEX_ALL			1

#define SQL_QUICK				0
#define SQL_ENSURE				1

/* Defines for SQLStatistics (returned in the result set) */
#define SQL_TABLE_STAT			0
#define SQL_INDEX_CLUSTERED 	1
#define SQL_INDEX_HASHED		2
#define SQL_INDEX_OTHER 		3

#if (ODBCVER >= 0x0200)
/* Defines for SQLProcedures (returned in the result set) */
#define SQL_PT_UNKNOWN			0
#define SQL_PT_PROCEDURE		1
#define SQL_PT_FUNCTION 		2

/* Defines for SQLSpecialColumns (returned in the result set) */
#define SQL_PC_UNKNOWN			0
#define SQL_PC_NOT_PSEUDO		1
#define SQL_PC_PSEUDO			2
#endif	/* ODBCVER >= 0x0200 */


#ifndef RC_INVOKED

/* Level 2 Prototypes */
RETCODE SQL_API SQLBrowseConnect(
    HDBC        hdbc,
    UCHAR  FAR *szConnStrIn,
    SWORD       cbConnStrIn,
    UCHAR  FAR *szConnStrOut,
    SWORD       cbConnStrOutMax,
    SWORD  FAR *pcbConnStrOut);

RETCODE SQL_API SQLColumnPrivileges(
    HSTMT       hstmt,
    UCHAR  FAR *szTableQualifier,
    SWORD       cbTableQualifier,
    UCHAR  FAR *szTableOwner,
    SWORD       cbTableOwner,
    UCHAR  FAR *szTableName,
    SWORD       cbTableName,
    UCHAR  FAR *szColumnName,
    SWORD       cbColumnName);

RETCODE SQL_API SQLDataSources(
    HENV        henv,
    UWORD       fDirection,
    UCHAR  FAR *szDSN,
    SWORD       cbDSNMax,
    SWORD  FAR *pcbDSN,
    UCHAR  FAR *szDescription,
    SWORD       cbDescriptionMax,
    SWORD  FAR *pcbDescription);

RETCODE SQL_API SQLDescribeParam(
    HSTMT       hstmt,
    UWORD       ipar,
    SWORD  FAR *pfSqlType,
    UDWORD FAR *pcbColDef,
    SWORD  FAR *pibScale,
    SWORD  FAR *pfNullable);
               
RETCODE SQL_API SQLExtendedFetch(
    HSTMT       hstmt,
    UWORD       fFetchType,
    SDWORD      irow,
    UDWORD FAR *pcrow,
    UWORD  FAR *rgfRowStatus);

RETCODE SQL_API SQLForeignKeys(
    HSTMT       hstmt,
    UCHAR  FAR *szPkTableQualifier,
    SWORD       cbPkTableQualifier,
    UCHAR  FAR *szPkTableOwner,
    SWORD       cbPkTableOwner,
    UCHAR  FAR *szPkTableName,
    SWORD       cbPkTableName,
    UCHAR  FAR *szFkTableQualifier,
    SWORD       cbFkTableQualifier,
    UCHAR  FAR *szFkTableOwner,
    SWORD       cbFkTableOwner,
    UCHAR  FAR *szFkTableName,
    SWORD       cbFkTableName);

RETCODE SQL_API SQLMoreResults(
    HSTMT       hstmt);

RETCODE SQL_API SQLNativeSql(
    HDBC        hdbc,
    UCHAR  FAR *szSqlStrIn,
    SDWORD      cbSqlStrIn,
    UCHAR  FAR *szSqlStr,
    SDWORD      cbSqlStrMax,
    SDWORD FAR *pcbSqlStr);

RETCODE SQL_API SQLNumParams(
    HSTMT       hstmt,
    SWORD  FAR *pcpar);

RETCODE SQL_API SQLParamOptions(
    HSTMT       hstmt,
    UDWORD      crow,
    UDWORD FAR *pirow);

RETCODE SQL_API SQLPrimaryKeys(
    HSTMT       hstmt,
    UCHAR  FAR *szTableQualifier,
    SWORD       cbTableQualifier,
    UCHAR  FAR *szTableOwner,
    SWORD       cbTableOwner,
    UCHAR  FAR *szTableName,
    SWORD       cbTableName);

RETCODE SQL_API SQLProcedureColumns(
    HSTMT       hstmt,
    UCHAR  FAR *szProcQualifier,
    SWORD       cbProcQualifier,
    UCHAR  FAR *szProcOwner,
    SWORD       cbProcOwner,
    UCHAR  FAR *szProcName,
    SWORD       cbProcName,
    UCHAR  FAR *szColumnName,
    SWORD       cbColumnName);

RETCODE SQL_API SQLProcedures(
    HSTMT       hstmt,
    UCHAR  FAR *szProcQualifier,
    SWORD       cbProcQualifier,
    UCHAR  FAR *szProcOwner,
    SWORD       cbProcOwner,
    UCHAR  FAR *szProcName,
    SWORD       cbProcName);

RETCODE SQL_API SQLSetPos(
    HSTMT       hstmt,
    UWORD       irow,
    UWORD       fOption,
    UWORD       fLock);

RETCODE SQL_API SQLTablePrivileges(
    HSTMT       hstmt,
    UCHAR  FAR *szTableQualifier,
    SWORD       cbTableQualifier,
    UCHAR  FAR *szTableOwner,
    SWORD       cbTableOwner,
    UCHAR  FAR *szTableName,
    SWORD       cbTableName);

/* SDK 2.0 Additions */

#if (ODBCVER >= 0x0200)
RETCODE SQL_API SQLDrivers(
    HENV        henv,
    UWORD       fDirection,
	UCHAR FAR  *szDriverDesc,
	SWORD		cbDriverDescMax,
	SWORD FAR  *pcbDriverDesc,
	UCHAR FAR  *szDriverAttributes,
    SWORD       cbDrvrAttrMax,
    SWORD  FAR *pcbDrvrAttr);

RETCODE SQL_API SQLBindParameter(
    HSTMT       hstmt,
	UWORD		ipar,
	SWORD		fParamType,
    SWORD       fCType,
	SWORD		fSqlType,
    UDWORD      cbColDef,
    SWORD       ibScale,
    PTR         rgbValue,
	SDWORD		cbValueMax,
    SDWORD FAR *pcbValue);
#endif	/* ODBCVER >= 0x0200 */
               
#endif /* RC_INVOKED */

/*	Deprecated defines from prior versions of ODBC */
#define SQL_DATABASE_NAME			16	/* Use SQLGetConnectOption/SQL_CURRENT_QUALIFIER */
#define SQL_FD_FETCH_PREV			SQL_FD_FETCH_PRIOR
#define SQL_FETCH_PREV				SQL_FETCH_PRIOR
#define SQL_CONCUR_TIMESTAMP		SQL_CONCUR_ROWVER
#define SQL_SCCO_OPT_TIMESTAMP		SQL_SCCO_OPT_ROWVER
#define SQL_CC_DELETE				SQL_CB_DELETE
#define SQL_CR_DELETE				SQL_CB_DELETE
#define SQL_CC_CLOSE				SQL_CB_CLOSE
#define SQL_CR_CLOSE				SQL_CB_CLOSE
#define SQL_CC_PRESERVE 			SQL_CB_PRESERVE
#define SQL_CR_PRESERVE 			SQL_CB_PRESERVE
#define SQL_FETCH_RESUME			7	/* Not supported by 2.0 drivers */
#define SQL_SCROLL_FORWARD_ONLY 	0L	/*-SQL_CURSOR_FORWARD_ONLY	*/
#define SQL_SCROLL_KEYSET_DRIVEN	(-1L) /*-SQL_CURSOR_KEYSET_DRIVEN */
#define SQL_SCROLL_DYNAMIC			(-2L) /*-SQL_CURSOR_DYNAMIC		*/
#if (ODBCVER >= 0x0200)
#define SQL_SCROLL_STATIC			(-3L) /*-SQL_CURSOR_STATIC		*/
#define SQL_PC_NON_PSEUDO			SQL_PC_NOT_PSEUDO
#endif	/* ODBCVER >= 0x0200 */

/*	Deprecrated functions from prior versions of ODBC */
#ifndef RC_INVOKED

RETCODE SQL_API SQLSetScrollOptions(	/*	Use SQLSetStmtOptions */
    HSTMT       hstmt,
    UWORD       fConcurrency,
    SDWORD      crowKeyset,
	UWORD		crowRowset);

#endif /* RC_INVOKED */


#ifdef __cplusplus
}                                    /* End of extern "C" { */
#endif	/* __cplusplus */

#endif /* __SQLEXT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\stdio.h ===
/***
*stdio.h - definitions/declarations for standard I/O routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structures, values, macros, and functions
*   used by the level 2 I/O ("standard I/O") routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_STDIO

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _VA_LIST_DEFINED
typedef char *va_list;
#define _VA_LIST_DEFINED
#endif 

/* buffered I/O macros */

#define BUFSIZ  512
#ifdef _MT
#define _NFILE  40
#else 
#define _NFILE  20
#endif 
#define EOF (-1)

#ifndef _FILE_DEFINED
#pragma pack(2)
struct _iobuf {
    char *_ptr;
    int   _cnt;
    char *_base;
    char  _flag;
    char  _file;
    };
typedef struct _iobuf FILE;
#pragma pack()
#define _FILE_DEFINED
#endif 


/* _P_tmpnam: Directory where temporary files may be created.
 * L_tmpnam size =  size of _P_tmpdir
 *  + 1 (in case _P_tmpdir does not end in "\\")
 *  + 6 (for the temp number string)
 *  + 1 (for the null terminator)
 */

#define  _P_tmpdir "\\"
#define  L_tmpnam sizeof(_P_tmpdir)+8


/* fseek constants */

#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


/* minimum guaranteed filename length, open file count, and unique
 * tmpnam filenames.
 */

#define FILENAME_MAX 128
#define FOPEN_MAX 18
#define TMP_MAX 32767
#define _SYS_OPEN 20


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* declare _iob[] array */

#ifndef _STDIO_DEFINED
extern FILE __near __cdecl _iob[];
#endif 


/* define file position type */

#ifndef _FPOS_T_DEFINED
typedef long fpos_t;
#define _FPOS_T_DEFINED
#endif 


/* standard file pointers */

#ifndef _WINDLL
#define stdin  (&_iob[0])
#define stdout (&_iob[1])
#define stderr (&_iob[2])
#endif 
#ifndef _WINDOWS
#define _stdaux (&_iob[3])
#define _stdprn (&_iob[4])
#endif 


#define _IOREAD     0x01
#define _IOWRT      0x02

#define _IOFBF      0x0
#define _IOLBF      0x40
#define _IONBF      0x04

#define _IOMYBUF    0x08
#define _IOEOF      0x10
#define _IOERR      0x20
#define _IOSTRG     0x40
#define _IORW       0x80


#ifdef _WINDOWS
#ifndef _WINDLL
#ifndef _WINFO_DEFINED
/* interface version number */
#define _QWINVER    0

/* max number of windows */
#define _WFILE      20

/* values for windows screen buffer size */
#define _WINBUFINF  0
#define _WINBUFDEF  -1

/* size/move settings */
#define _WINSIZEMIN 1
#define _WINSIZEMAX 2
#define _WINSIZERESTORE 3
#define _WINSIZECHAR    4

/* size/move query types */
#define _WINMAXREQ  100
#define _WINCURRREQ 101

/* values for closing window */
#define _WINPERSIST 1
#define _WINNOPERSIST   0

/* pseudo file handle for frame window */
#define _WINFRAMEHAND   -1

/* menu items */
#define _WINSTATBAR 1
#define _WINTILE    2
#define _WINCASCADE 3
#define _WINARRANGE 4

/* quickwin exit options */
#define _WINEXITPROMPT      1
#define _WINEXITNOPERSIST   2
#define _WINEXITPERSIST     3

/* open structure */
#pragma pack(2)
struct _wopeninfo {
    unsigned int _version;
    const char __far * _title;
    long _wbufsize;
    };
#pragma pack()

/* size/move structure */
struct _wsizeinfo {
    unsigned int _version;
    unsigned int _type;
    unsigned int _x;
    unsigned int _y;
    unsigned int _h;
    unsigned int _w;
    };
#define _WINFO_DEFINED
#endif 
#endif 
#endif 

/* function prototypes */

#ifndef _STDIO_DEFINED
int __cdecl _filbuf(FILE *);
int __cdecl _flsbuf(int, FILE *);
FILE * __cdecl _fsopen(const char *,
    const char *, int);
void __cdecl clearerr(FILE *);
int __cdecl fclose(FILE *);
int __cdecl _fcloseall(void);
FILE * __cdecl _fdopen(int, const char *);
int __cdecl feof(FILE *);
int __cdecl ferror(FILE *);
int __cdecl fflush(FILE *);
int __cdecl fgetc(FILE *);
#ifndef _WINDLL
int __cdecl _fgetchar(void);
#endif 
int __cdecl fgetpos(FILE *, fpos_t *);
char * __cdecl fgets(char *, int, FILE *);
int __cdecl _fileno(FILE *);
int __cdecl _flushall(void);
FILE * __cdecl fopen(const char *,
    const char *);
int __cdecl fprintf(FILE *, const char *, ...);
int __cdecl fputc(int, FILE *);
#ifndef _WINDLL
int __cdecl _fputchar(int);
#endif 
int __cdecl fputs(const char *, FILE *);
size_t __cdecl fread(void *, size_t, size_t, FILE *);
FILE * __cdecl freopen(const char *,
    const char *, FILE *);
#ifndef _WINDLL
int __cdecl fscanf(FILE *, const char *, ...);
#endif 
int __cdecl fsetpos(FILE *, const fpos_t *);
int __cdecl fseek(FILE *, long, int);
long __cdecl ftell(FILE *);
#ifdef _WINDOWS
#ifndef _WINDLL
FILE * __cdecl _fwopen(struct _wopeninfo *, struct _wsizeinfo *, const char *);
#endif 
#endif 
size_t __cdecl fwrite(const void *, size_t, size_t,
    FILE *);
int __cdecl getc(FILE *);
#ifndef _WINDLL
int __cdecl getchar(void);
char * __cdecl gets(char *);
#endif 
int __cdecl _getw(FILE *);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
#ifndef _WINDLL
int __cdecl printf(const char *, ...);
#endif 
int __cdecl putc(int, FILE *);
#ifndef _WINDLL
int __cdecl putchar(int);
int __cdecl puts(const char *);
#endif 
int __cdecl _putw(int, FILE *);
int __cdecl remove(const char *);
int __cdecl rename(const char *, const char *);
void __cdecl rewind(FILE *);
int __cdecl _rmtmp(void);
#ifndef _WINDLL
int __cdecl scanf(const char *, ...);
#endif 
void __cdecl setbuf(FILE *, char *);
int __cdecl setvbuf(FILE *, char *, int, size_t);
int __cdecl _snprintf(char *, size_t, const char *, ...);
int __cdecl sprintf(char *, const char *, ...);
#ifndef _WINDLL
int __cdecl sscanf(const char *, const char *, ...);
#endif 
char * __cdecl _tempnam(char *, char *);
FILE * __cdecl tmpfile(void);
char * __cdecl tmpnam(char *);
int __cdecl ungetc(int, FILE *);
int __cdecl _unlink(const char *);
int __cdecl vfprintf(FILE *, const char *, va_list);
#ifndef _WINDLL
int __cdecl vprintf(const char *, va_list);
#endif 
int __cdecl _vsnprintf(char *, size_t, const char *, va_list);
int __cdecl vsprintf(char *, const char *, va_list);
#define _STDIO_DEFINED
#endif 

/* macro definitions */

#define feof(_stream)     ((_stream)->_flag & _IOEOF)
#define ferror(_stream)   ((_stream)->_flag & _IOERR)
#define _fileno(_stream)  ((int)(unsigned char)(_stream)->_file)
#define getc(_stream)     (--(_stream)->_cnt >= 0 ? 0xff & *(_stream)->_ptr++ \
    : _filbuf(_stream))
#define putc(_c,_stream)  (--(_stream)->_cnt >= 0 \
    ? 0xff & (*(_stream)->_ptr++ = (char)(_c)) :  _flsbuf((_c),(_stream)))
#ifndef _WINDLL
#define getchar()     getc(stdin)
#define putchar(_c)   putc((_c),stdout)
#endif 

#ifdef _MT
#undef  getc
#undef  putc
#undef  getchar
#undef  putchar
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define P_tmpdir  _P_tmpdir
#define SYS_OPEN  _SYS_OPEN

#ifndef _WINDOWS
#define stdaux    _stdaux
#define stdprn    _stdprn
#endif 

int __cdecl fcloseall(void);
FILE * __cdecl fdopen(int, const char *);
#ifndef _WINDLL
int __cdecl fgetchar(void);
#endif 
int __cdecl fileno(FILE *);
int __cdecl flushall(void);
#ifndef _WINDLL
int __cdecl fputchar(int);
#endif 
int __cdecl getw(FILE *);
int __cdecl putw(int, FILE *);
int __cdecl rmtmp(void);
char * __cdecl tempnam(char *, char *);
int __cdecl unlink(const char *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDIO
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\stdiostr.h ===
/***
*stdiostr.h - definitions/declarations for stdiobuf, stdiostream
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the stdiostream and stdiobuf classes.
*   [AT&T C++]
*
****/

#include <iostream.h>
#include <stdio.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifndef _INC_STDIOSTREAM
#define _INC_STDIOSTREAM
class stdiobuf : public streambuf  {
public:
    stdiobuf(FILE* f);
FILE *  stdiofile() { return _str; }

virtual int pbackfail(int c);
virtual int overflow(int c = EOF);
virtual int underflow();
virtual streampos seekoff( streamoff, ios::seek_dir, int =ios::in|ios::out);
virtual int sync();
    ~stdiobuf();
    int setrwbuf(int _rsize, int _wsize); // CONSIDER: move to ios::
// protected:
// virtual int doallocate();
private:
    FILE * _str;
};

// obsolescent
class stdiostream : public iostream {   // note: spec.'d as : public IOS...
public:
    stdiostream(FILE *);
    ~stdiostream();
    stdiobuf* rdbuf() const { return (stdiobuf*) ostream::rdbuf(); }

private:
};

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\stdlib.h ===
/***
*stdlib.h - declarations/definitions for commonly used library functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This include file contains the function declarations for
*   commonly used library functions which either don't fit somewhere
*   else, or, like toupper/tolower, can't be declared in the normal
*   place for other reasons.
*   [ANSI]
*
****/

#ifndef _INC_STDLIB

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* exit() arg values */

#define EXIT_SUCCESS    0
#define EXIT_FAILURE    1

#ifndef _ONEXIT_T_DEFINED
typedef int (__cdecl * _onexit_t)();
typedef int (__far __cdecl * _fonexit_t)();
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef int (__cdecl * onexit_t)();
#endif 
#define _ONEXIT_T_DEFINED
#endif 


/* data structure definitions for div and ldiv runtimes. */

#ifndef _DIV_T_DEFINED

typedef struct _div_t {
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t {
    long quot;
    long rem;
} ldiv_t;

#define _DIV_T_DEFINED
#endif 

/* maximum value that can be returned by the rand function. */

#define RAND_MAX 0x7fff

extern unsigned short __mb_cur_max; /* mb-len for curr. locale */
#define MB_CUR_MAX __mb_cur_max


/* min and max macros */

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))


/* sizes for buffers used by the _makepath() and _splitpath() functions.
 * note that the sizes include space for 0-terminator
 */

#define _MAX_PATH   260 /* max. length of full pathname */
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

/* external variable declarations */

#ifdef _MT
extern int __far * __cdecl __far volatile _errno(void);
extern int __far * __cdecl __far __doserrno(void);
#define errno       (*_errno())
#define _doserrno   (*__doserrno())
#else 
extern int __near __cdecl volatile errno;   /* error value */
extern int __near __cdecl _doserrno;        /* OS system error value */
#endif 

extern char * __near __cdecl _sys_errlist[];    /* perror error message table */
extern int __near __cdecl _sys_nerr;        /* # of entries in sys_errlist table */
extern char ** __near __cdecl _environ;     /* pointer to environment table */
extern int __near __cdecl _fmode;       /* default file translation mode */
#ifndef _WINDOWS
extern int __near __cdecl _fileinfo;        /* open file info mode (for spawn) */
#endif 

extern unsigned int __near __cdecl _psp;    /* Program Segment Prefix */

extern char __far * __near __cdecl _pgmptr; /* Pointer to Program name */

/* DOS and Windows major/minor version numbers */

extern unsigned int __near __cdecl _osver;
extern unsigned char __near __cdecl _osmajor;
extern unsigned char __near __cdecl _osminor;
extern unsigned int __near __cdecl _winver;
extern unsigned char __near __cdecl _winmajor;
extern unsigned char __near __cdecl _winminor;

/* OS mode */

#define _DOS_MODE   0   /* DOS */
#define _OS2_MODE   1   /* OS/2 */
#define _WIN_MODE   2   /* Windows */

extern unsigned char __near __cdecl _osmode;

/* CPU mode */

#define _REAL_MODE  0   /* real mode */
#define _PROT_MODE  1   /* protect mode */

extern unsigned char __near __cdecl _cpumode;

/* function prototypes */

#ifdef _MT
double __pascal atof(const char *);
double __pascal strtod(const char *, char * *);
ldiv_t __pascal ldiv(long, long);
#else 
double __cdecl atof(const char *);
double __cdecl strtod(const char *, char * *);
ldiv_t __cdecl ldiv(long, long);
#endif 

void __cdecl abort(void);
int __cdecl abs(int);
int __cdecl atexit(void (__cdecl *)(void));
int __cdecl atoi(const char *);
long __cdecl atol(const char *);
long double __cdecl _atold(const char *);
void * __cdecl bsearch(const void *, const void *,
    size_t, size_t, int (__cdecl *)(const void *,
    const void *));
void * __cdecl calloc(size_t, size_t);
div_t __cdecl div(int, int);
char * __cdecl _ecvt(double, int, int *, int *);
#ifndef _WINDLL
void __cdecl exit(int);
void __cdecl _exit(int);
#endif 
int __far __cdecl _fatexit(void (__cdecl __far *)(void));
char * __cdecl _fcvt(double, int, int *, int *);
_fonexit_t __far __cdecl _fonexit(_fonexit_t);
void __cdecl free(void *);
char * __cdecl _fullpath(char *, const char *,
    size_t);
char * __cdecl _gcvt(double, int, char *);
char * __cdecl getenv(const char *);
char * __cdecl _itoa(int, char *, int);
long __cdecl labs(long);
unsigned long __cdecl _lrotl(unsigned long, int);
unsigned long __cdecl _lrotr(unsigned long, int);
char * __cdecl _ltoa(long, char *, int);
void __cdecl _makepath(char *, const char *,
    const char *, const char *, const char *);
void * __cdecl malloc(size_t);
_onexit_t __cdecl _onexit(_onexit_t);
#ifndef _WINDLL
void __cdecl perror(const char *);
#endif 
int __cdecl _putenv(const char *);
void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)
    (const void *, const void *));
unsigned int __cdecl _rotl(unsigned int, int);
unsigned int __cdecl _rotr(unsigned int, int);
int __cdecl rand(void);
void * __cdecl realloc(void *, size_t);
void __cdecl _searchenv(const char *, const char *,
    char *);
void __cdecl _splitpath(const char *, char *,
    char *, char *, char *);
void __cdecl srand(unsigned int);
long __cdecl strtol(const char *, char * *,
    int);
long double __cdecl _strtold(const char *,
    char * *);
unsigned long __cdecl strtoul(const char *,
    char * *, int);
void __cdecl _swab(char *, char *, int);
#ifndef _WINDOWS
int __cdecl system(const char *);
#endif 
char * __cdecl _ultoa(unsigned long, char *, int);

int __cdecl mblen(const char *, size_t);
int __cdecl mbtowc(wchar_t *, const char *, size_t);
int __cdecl wctomb(char *, wchar_t);
size_t __cdecl mbstowcs(wchar_t *, const char *, size_t);
size_t __cdecl wcstombs(char *, const wchar_t *, size_t);

/* model-independent function prototypes */

int __far __cdecl _fmblen(const char __far *, size_t);
int __far __cdecl _fmbtowc(wchar_t __far *, const char __far *,
    size_t);
int __far __cdecl _fwctomb(char __far *, wchar_t);
size_t __far __cdecl _fmbstowcs(wchar_t __far *, const char __far *,
    size_t);
size_t __far __cdecl _fwcstombs(char __far *, const wchar_t __far *,
    size_t);

#ifndef tolower
int __cdecl tolower(int);
#endif 

#ifndef toupper
int __cdecl toupper(int);
#endif 

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#ifndef __cplusplus
#define max(a,b)    (((a) > (b)) ? (a) : (b))
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif 

extern char * __near __cdecl sys_errlist[];
extern int __near __cdecl sys_nerr;
extern char ** __near __cdecl environ;

#define DOS_MODE    _DOS_MODE
#define OS2_MODE    _OS2_MODE

char * __cdecl ecvt(double, int, int *, int *);
char * __cdecl fcvt(double, int, int *, int *);
char * __cdecl gcvt(double, int, char *);
char * __cdecl itoa(int, char *, int);
char * __cdecl ltoa(long, char *, int);
onexit_t __cdecl onexit(onexit_t);
int __cdecl putenv(const char *);
void __cdecl swab(char *, char *, int);
char * __cdecl ultoa(unsigned long, char *, int);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STDLIB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\streamb.h ===
/***
*streamb.h - definitions/declarations for the streambuf class
*
*   Copyright (c) 1990-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the streambuf class.
*   [AT&T C++]
*
****/

#ifndef _INC_STREAMB
#define _INC_STREAMB


#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

#ifndef NULL
#define NULL    0
#endif 

#ifndef EOF
#define EOF (-1)
#endif 

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

typedef long streampos, streamoff;

class streambuf {
public:

    virtual ~streambuf();

    inline int in_avail() const;
    inline int out_waiting() const;
    int sgetc();
    int snextc();
    int sbumpc();
    void stossc();

    inline int sputbackc(char);

    inline int sputc(int);
    inline int sputn(const char _HFAR_ *,int);
    inline int sgetn(char _HFAR_ *,int);

    virtual int sync();

//  enum seek_dir { beg=0, cur=1, end=2 };  // CONSIDER: needed ???

    virtual streambuf* setbuf(char _HFAR_ *, int);
    virtual streampos seekoff(streamoff,ios::seek_dir,int =ios::in|ios::out);
    virtual streampos seekpos(streampos,int =ios::in|ios::out);

    virtual int xsputn(const char _HFAR_ *,int);
    virtual int xsgetn(char _HFAR_ *,int);

    virtual int overflow(int =EOF) = 0; // pure virtual function
    virtual int underflow() = 0;    // pure virtual function

    virtual int pbackfail(int);

    void dbp();

protected:
    streambuf();
    streambuf(char _HFAR_ *,int);

    inline char _HFAR_ * base() const;
    inline char _HFAR_ * ebuf() const;
    inline char _HFAR_ * pbase() const;
    inline char _HFAR_ * pptr() const;
    inline char _HFAR_ * epptr() const;
    inline char _HFAR_ * eback() const;
    inline char _HFAR_ * gptr() const;
    inline char _HFAR_ * egptr() const;
    inline int blen() const;
    inline void setp(char _HFAR_ *,char _HFAR_ *);
    inline void setg(char _HFAR_ *,char _HFAR_ *,char _HFAR_ *);
    inline void pbump(int);
    inline void gbump(int);

    void setb(char _HFAR_ *,char _HFAR_ *,int =0);
    inline int unbuffered() const;
    inline void unbuffered(int);
    int allocate();
    virtual int doallocate();

private:
    int _fAlloc;
    int _fUnbuf;
    int x_lastc;
    char _HFAR_ * _base;
    char _HFAR_ * _ebuf;
    char _HFAR_ * _pbase;
    char _HFAR_ * _pptr;
    char _HFAR_ * _epptr;
    char _HFAR_ * _eback;
    char _HFAR_ * _gptr;
    char _HFAR_ * _egptr;
};

inline int streambuf::in_avail() const { return (gptr()<_egptr) ? (_egptr-gptr()) : 0; }
inline int streambuf::out_waiting() const { return (_pptr>=_pbase) ? (_pptr-_pbase) : 0; }

inline int streambuf::sputbackc(char _c){ return (_eback<gptr()) ? *(--_gptr)=_c : pbackfail(_c); }

inline int streambuf::sputc(int _i){ return (_pptr<_epptr) ? (unsigned char)(*(_pptr++)=(char)_i) : overflow(_i); }

inline int streambuf::sputn(const char _HFAR_ * _str,int _n) { return xsputn(_str, _n); }
inline int streambuf::sgetn(char _HFAR_ * _str,int _n) { return xsgetn(_str, _n); }

inline char _HFAR_ * streambuf::base() const { return _base; }
inline char _HFAR_ * streambuf::ebuf() const { return _ebuf; }
inline int streambuf::blen() const  {return ((_ebuf > _base) ? (_ebuf-_base) : 0); }
inline char _HFAR_ * streambuf::pbase() const { return _pbase; }
inline char _HFAR_ * streambuf::pptr() const { return _pptr; }
inline char _HFAR_ * streambuf::epptr() const { return _epptr; }
inline char _HFAR_ * streambuf::eback() const { return _eback; }
inline char _HFAR_ * streambuf::gptr() const { return _gptr; }
inline char _HFAR_ * streambuf::egptr() const { return _egptr; }
inline void streambuf::gbump(int n) { if (_egptr) _gptr += n; }
inline void streambuf::pbump(int n) { if (_epptr) _pptr += n; }
inline void streambuf::setg(char _HFAR_ * eb, char _HFAR_ * g, char _HFAR_ * eg) {_eback=eb; _gptr=g; _egptr=eg; x_lastc=EOF; }
inline void streambuf::setp(char _HFAR_ * p, char _HFAR_ * ep) {_pptr=_pbase=p; _epptr=ep; }
inline int streambuf::unbuffered() const { return _fUnbuf; }
inline void streambuf::unbuffered(int fUnbuf) { _fUnbuf = fUnbuf; }

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\storage.h ===
/*****************************************************************************\
*                                                                             *
* storage.h -   Definitions for the strutured storage system
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _STORAGE_H_ )
#define _STORAGE_H_


#include <compobj.h>


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_EXTANTMARSHALLINGS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x108)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

/****** Storage types *******************************************************/

#if defined(_M_I286)
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP _huge
#endif
#else
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP
#endif
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L
#define STGM_TRANSACTED		0x00010000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef char FAR * FAR *SNB;


#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif


/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    char FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IENUMSTATSTG methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};

typedef IEnumSTATSTG FAR* LPENUMSTATSTG;



/****** ILockBytes Interface ************************************************/

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ILockBytes methods ***
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef ILockBytes FAR* LPLOCKBYTES;



/****** IStream Interface ***************************************************/


#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};

typedef IStream FAR* LPSTREAM;



/****** IStorage Interface **************************************************/

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStorage methods ***
    STDMETHOD(CreateStream) (THIS_ const char FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const char FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const char FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const char FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ char const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              char const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const char FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const char FAR* pwcsOldName,
                const char FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const char FAR *lpszName,
    			        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef IStorage FAR* LPSTORAGE;



/****** IRootStorage Interface **********************************************/

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRootStorage methods ***
    STDMETHOD(SwitchToFile) (THIS_ LPSTR lpstrFile) PURE;
};

typedef IRootStorage FAR* LPROOTSTORAGE;



/****** Storage API Prototypes ********************************************/

STDAPI StgCreateDocfile(const char FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const char FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const char FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgSetTimes(char const FAR* lpszName,
		  FILETIME const FAR* pctime,
                  FILETIME const FAR* patime,
                  FILETIME const FAR* pmtime);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\stress.h ===
/*****************************************************************************\
*                                                                             *
* stress.h -    Stress functions definitions                                  *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp. All rights reserved.      *
*                                                                             *
*******************************************************************************/

#ifndef _INC_STRESS
#define _INC_STRESS

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** Simple types & common helper macros *********************************/

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define UINT        WORD
#define WINAPI      FAR PASCAL
#endif  /* _INC_WINDOWS */

/* stuff for AllocDiskSpace() */
#define  EDS_WIN     1
#define  EDS_CUR     2
#define  EDS_TEMP    3


/* function prototypes */
BOOL    WINAPI AllocMem(DWORD);
void    WINAPI FreeAllMem(void);
int     WINAPI AllocFileHandles(int);
void    WINAPI UnAllocFileHandles(void);
int     WINAPI GetFreeFileHandles(void);
int     WINAPI AllocDiskSpace(long,UINT);
void    WINAPI UnAllocDiskSpace(UINT);
BOOL    WINAPI AllocUserMem(UINT);
void    WINAPI FreeAllUserMem(void);
BOOL    WINAPI AllocGDIMem(UINT);
void    WINAPI FreeAllGDIMem(void);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_STRESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file contains the function declarations for the string
*   manipulation functions.
*   [ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif 

/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 

/* function prototypes */

void * __cdecl _memccpy(void *, const void *,
    int, unsigned int);
void * __cdecl memchr(const void *, int, size_t);
int __cdecl memcmp(const void *, const void *,
    size_t);
int __cdecl _memicmp(const void *, const void *,
    unsigned int);
void * __cdecl memcpy(void *, const void *,
    size_t);
void * __cdecl memmove(void *, const void *,
    size_t);
void * __cdecl memset(void *, int, size_t);
void __cdecl _movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
char * __cdecl strcat(char *, const char *);
char * __cdecl strchr(const char *, int);
int __cdecl strcmp(const char *, const char *);
int __cdecl _strcmpi(const char *, const char *);
int __cdecl strcoll(const char *, const char *);
int __cdecl _stricmp(const char *, const char *);
char * __cdecl strcpy(char *, const char *);
size_t __cdecl strcspn(const char *, const char *);
char * __cdecl _strdup(const char *);
char * __cdecl _strerror(const char *);
char * __cdecl strerror(int);
size_t __cdecl strlen(const char *);
char * __cdecl _strlwr(char *);
char * __cdecl strncat(char *, const char *,
    size_t);
int __cdecl strncmp(const char *, const char *,
    size_t);
int __cdecl _strnicmp(const char *, const char *,
    size_t);
char * __cdecl strncpy(char *, const char *,
    size_t);
char * __cdecl _strnset(char *, int, size_t);
char * __cdecl strpbrk(const char *,
    const char *);
char * __cdecl strrchr(const char *, int);
char * __cdecl _strrev(char *);
char * __cdecl _strset(char *, int);
size_t __cdecl strspn(const char *, const char *);
char * __cdecl strstr(const char *,
    const char *);
char * __cdecl strtok(char *, const char *);
char * __cdecl _strupr(char *);
size_t __cdecl strxfrm (char *, const char *,
    size_t);


/* model independent function prototypes */

void __far * __far __cdecl _fmemccpy(void __far *, const void __far *,
    int, unsigned int);
void __far * __far __cdecl _fmemchr(const void __far *, int, size_t);
int __far __cdecl _fmemcmp(const void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemcpy(void __far *, const void __far *,
    size_t);
int __far __cdecl _fmemicmp(const void __far *, const void __far *,
    unsigned int);
void __far * __far __cdecl _fmemmove(void __far *, const void __far *,
    size_t);
void __far * __far __cdecl _fmemset(void __far *, int, size_t);
char __far * __far __cdecl _fstrcat(char __far *, const char __far *);
char __far * __far __cdecl _fstrchr(const char __far *, int);
int __far __cdecl _fstrcmp(const char __far *, const char __far *);
int __far __cdecl _fstricmp(const char __far *, const char __far *);
char __far * __far __cdecl _fstrcpy(char __far *, const char __far *);
size_t __far __cdecl _fstrcspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrdup(const char __far *);
char __near * __far __cdecl _nstrdup(const char __far *);
size_t __far __cdecl _fstrlen(const char __far *);
char __far * __far __cdecl _fstrlwr(char __far *);
char __far * __far __cdecl _fstrncat(char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrncmp(const char __far *, const char __far *,
    size_t);
int __far __cdecl _fstrnicmp(const char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrncpy(char __far *, const char __far *,
    size_t);
char __far * __far __cdecl _fstrnset(char __far *, int, size_t);
char __far * __far __cdecl _fstrpbrk(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrrchr(const char __far *, int);
char __far * __far __cdecl _fstrrev(char __far *);
char __far * __far __cdecl _fstrset(char __far *, int);
size_t __far __cdecl _fstrspn(const char __far *, const char __far *);
char __far * __far __cdecl _fstrstr(const char __far *,
    const char __far *);
char __far * __far __cdecl _fstrtok(char __far *, const char __far *);
char __far * __far __cdecl _fstrupr(char __far *);


#ifndef __STDC__
/* Non-ANSI names for compatibility */
void * __cdecl memccpy(void *, const void *,
    int, unsigned int);
int __cdecl memicmp(const void *, const void *,
    unsigned int);
void __cdecl movedata(unsigned int, unsigned int, unsigned int,
    unsigned int, unsigned int);
int __cdecl strcmpi(const char *, const char *);
int __cdecl stricmp(const char *, const char *);
char * __cdecl strdup(const char *);
char * __cdecl strlwr(char *);
int __cdecl strnicmp(const char *, const char *,
    size_t);
char * __cdecl strnset(char *, int, size_t);
char * __cdecl strrev(char *);
char * __cdecl strset(char *, int);
char * __cdecl strupr(char *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STRING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\strstrea.h ===
/***
*strstream.h - definitions/declarations for strstreambuf, strstream
*
*   Copyright (c) 1991-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the classes, values, macros, and functions
*   used by the strstream and strstreambuf classes.
*   [AT&T C++]
*
****/

#ifndef _INC_STRSTREAM
#define _INC_STRSTREAM

#include <iostream.h>

// Force word packing to avoid possible -Zp override
#pragma pack(2)

#pragma warning(disable:4505)       // disable unwanted /W4 warning
// #pragma warning(default:4505)    // use this to reenable, if necessary

#ifdef M_I86HM
#define _HFAR_ __far
#else 
#define _HFAR_
#endif 

class strstreambuf : public streambuf  {
public:
        strstreambuf();
        strstreambuf(int);
        strstreambuf(char _HFAR_ *, int, char _HFAR_ * = 0);
        strstreambuf(unsigned char _HFAR_ *, int, unsigned char _HFAR_ * = 0);
        strstreambuf(signed char _HFAR_ _HFAR_ *, int, signed char _HFAR_ * = 0);
        strstreambuf(void _HFAR_ * (*a)(long), void (*f) (void _HFAR_ *));
        ~strstreambuf();

    void    freeze(int =1);
    char _HFAR_ * str();

virtual int overflow(int);
virtual int underflow();
virtual streambuf* setbuf(char  _HFAR_ *, int);
virtual streampos seekoff(streamoff, ios::seek_dir, int);
virtual int sync();     // not in spec.

protected:
virtual int doallocate();
private:
    int x_dynamic;
    int     x_bufmin;
    int     _fAlloc;
    int x_static;
    void _HFAR_ * (* x_alloc)(long);
    void    (* x_free)(void _HFAR_ *);
};

class istrstream : public istream {
public:
        istrstream(char _HFAR_ *);
        istrstream(char _HFAR_ *, int);
        ~istrstream();

inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

class ostrstream : public ostream {
public:
        ostrstream();
        ostrstream(char _HFAR_ *, int, int = ios::out);
        ~ostrstream();

inline  int pcount() const { return rdbuf()->out_waiting(); }
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ios::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

class strstream : public iostream { // strstreambase ???
public:
        strstream();
        strstream(char _HFAR_ *, int, int);
        ~strstream();

inline  int pcount() const { return rdbuf()->out_waiting(); } // not in spec.
inline  strstreambuf* rdbuf() const { return (strstreambuf*) ostream::rdbuf(); }
inline  char _HFAR_ *   str() { return rdbuf()->str(); }
};

// Restore default packing
#pragma pack()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\toolhelp.h ===
/*****************************************************************************\
*                                                                             *
* toolhelp.h -  toolhelp.dll functions, types, and definitions                *
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_TOOLHELP
#define _INC_TOOLHELP

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _INC_WINDOWS    /* If included with 3.0 headers... */
#define LPCSTR      LPSTR
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define UINT        WORD
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#define HTASK       HANDLE
#endif  /* _INC_WINDOWS */

/****** General symbols ******************************************************/
#define MAX_DATA        11
#define MAX_PATH        255
#define MAX_MODULE_NAME 8 + 1
#define MAX_CLASSNAME   255

/****** Global heap walking ***************************************************/
typedef struct tagGLOBALINFO
{
    DWORD dwSize;
    WORD wcItems;
    WORD wcItemsFree;
    WORD wcItemsLRU;
} GLOBALINFO;

typedef struct tagGLOBALENTRY
{
    DWORD dwSize;
    DWORD dwAddress;
    DWORD dwBlockSize;
    HGLOBAL hBlock;
    WORD wcLock;
    WORD wcPageLock;
    WORD wFlags;
    BOOL wHeapPresent;
    HGLOBAL hOwner;
    WORD wType;
    WORD wData;
    DWORD dwNext;
    DWORD dwNextAlt;
} GLOBALENTRY;

/* GlobalFirst()/GlobalNext() flags */
#define GLOBAL_ALL      0
#define GLOBAL_LRU      1
#define GLOBAL_FREE     2

/* GLOBALENTRY.wType entries */
#define GT_UNKNOWN      0
#define GT_DGROUP       1
#define GT_DATA         2
#define GT_CODE         3
#define GT_TASK         4
#define GT_RESOURCE     5
#define GT_MODULE       6
#define GT_FREE         7
#define GT_INTERNAL     8
#define GT_SENTINEL     9
#define GT_BURGERMASTER 10

/* If GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData: */
#define GD_USERDEFINED      0
#define GD_CURSORCOMPONENT  1
#define GD_BITMAP           2
#define GD_ICONCOMPONENT    3
#define GD_MENU             4
#define GD_DIALOG           5
#define GD_STRING           6
#define GD_FONTDIR          7
#define GD_FONT             8
#define GD_ACCELERATORS     9
#define GD_RCDATA           10
#define GD_ERRTABLE         11
#define GD_CURSOR           12
#define GD_ICON             14
#define GD_NAMETABLE        15
#define GD_MAX_RESOURCE     15

/* GLOBALENTRY.wFlags */
#define GF_PDB_OWNER        0x0100      /* Low byte is KERNEL flags */

BOOL    WINAPI GlobalInfo(GLOBALINFO FAR* lpGlobalInfo);
BOOL    WINAPI GlobalFirst(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalNext(GLOBALENTRY FAR* lpGlobal, WORD wFlags);
BOOL    WINAPI GlobalEntryHandle(GLOBALENTRY FAR* lpGlobal, HGLOBAL hItem);
BOOL    WINAPI GlobalEntryModule(GLOBALENTRY FAR* lpGlobal, HMODULE hModule, WORD wSeg);
WORD    WINAPI GlobalHandleToSel(HGLOBAL hMem);

/****** Local heap walking ***************************************************/

typedef struct tagLOCALINFO
{
    DWORD dwSize;
    WORD wcItems;
} LOCALINFO;

typedef struct tagLOCALENTRY
{
    DWORD dwSize;
    HLOCAL hHandle;
    WORD wAddress;
    WORD wSize;
    WORD wFlags;
    WORD wcLock;
    WORD wType;
    WORD hHeap;
    WORD wHeapType;
    WORD wNext;
} LOCALENTRY;

/* LOCALENTRY.wHeapType flags */
#define NORMAL_HEAP     0
#define USER_HEAP       1
#define GDI_HEAP        2

/* LOCALENTRY.wFlags */
#define LF_FIXED        1
#define LF_FREE         2
#define LF_MOVEABLE     4

/* LOCALENTRY.wType */
#define LT_NORMAL                   0
#define LT_FREE                     0xff
#define LT_GDI_PEN                  1   /* LT_GDI_* is for GDI's heap */
#define LT_GDI_BRUSH                2
#define LT_GDI_FONT                 3
#define LT_GDI_PALETTE              4
#define LT_GDI_BITMAP               5
#define LT_GDI_RGN                  6
#define LT_GDI_DC                   7
#define LT_GDI_DISABLED_DC          8
#define LT_GDI_METADC               9
#define LT_GDI_METAFILE             10
#define LT_GDI_MAX                  LT_GDI_METAFILE
#define LT_USER_CLASS               1   /* LT_USER_* is for USER's heap */
#define LT_USER_WND                 2
#define LT_USER_STRING              3
#define LT_USER_MENU                4
#define LT_USER_CLIP                5
#define LT_USER_CBOX                6
#define LT_USER_PALETTE             7
#define LT_USER_ED                  8
#define LT_USER_BWL                 9
#define LT_USER_OWNERDRAW           10
#define LT_USER_SPB                 11
#define LT_USER_CHECKPOINT          12
#define LT_USER_DCE                 13
#define LT_USER_MWP                 14
#define LT_USER_PROP                15
#define LT_USER_LBIV                16
#define LT_USER_MISC                17
#define LT_USER_ATOMS               18
#define LT_USER_LOCKINPUTSTATE      19
#define LT_USER_HOOKLIST            20
#define LT_USER_USERSEEUSERDOALLOC  21
#define LT_USER_HOTKEYLIST          22
#define LT_USER_POPUPMENU           23
#define LT_USER_HANDLETABLE         32
#define LT_USER_MAX                 LT_USER_HANDLETABLE

BOOL    WINAPI LocalInfo(LOCALINFO FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalFirst(LOCALENTRY FAR* lpLocal, HGLOBAL hHeap);
BOOL    WINAPI LocalNext(LOCALENTRY FAR* lpLocal);

/****** Stack Tracing ********************************************************/

typedef struct tagSTACKTRACEENTRY
{
    DWORD dwSize;
    HTASK hTask;
    WORD wSS;
    WORD wBP;
    WORD wCS;
    WORD wIP;
    HMODULE hModule;
    WORD wSegment;
    WORD wFlags;
} STACKTRACEENTRY;

/* STACKTRACEENTRY.wFlags values */
#define FRAME_FAR       0
#define FRAME_NEAR      1

BOOL    WINAPI StackTraceFirst(STACKTRACEENTRY FAR* lpStackTrace, HTASK hTask);
BOOL    WINAPI StackTraceCSIPFirst(STACKTRACEENTRY FAR* lpStackTrace,
            WORD wSS, WORD wCS, WORD wIP, WORD wBP);
BOOL    WINAPI StackTraceNext(STACKTRACEENTRY FAR* lpStackTrace);

/****** Module list walking **************************************************/

typedef struct tagMODULEENTRY
{
    DWORD dwSize;
    char szModule[MAX_MODULE_NAME + 1];
    HMODULE hModule;
    WORD wcUsage;
    char szExePath[MAX_PATH + 1];
    WORD wNext;
} MODULEENTRY;

BOOL    WINAPI ModuleFirst(MODULEENTRY FAR* lpModule);
BOOL    WINAPI ModuleNext(MODULEENTRY FAR* lpModule);
HMODULE WINAPI ModuleFindName(MODULEENTRY FAR* lpModule, LPCSTR lpstrName);
HMODULE WINAPI ModuleFindHandle(MODULEENTRY FAR* lpModule, HMODULE hModule);

/****** Task list walking *****************************************************/

typedef struct tagTASKENTRY
{
    DWORD dwSize;
    HTASK hTask;
    HTASK hTaskParent;
    HINSTANCE hInst;
    HMODULE hModule;
    WORD wSS;
    WORD wSP;
    WORD wStackTop;
    WORD wStackMinimum;
    WORD wStackBottom;
    WORD wcEvents;
    HGLOBAL hQueue;
    char szModule[MAX_MODULE_NAME + 1];
    WORD wPSPOffset;
    HANDLE hNext;
} TASKENTRY;

BOOL    WINAPI TaskFirst(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskNext(TASKENTRY FAR* lpTask);
BOOL    WINAPI TaskFindHandle(TASKENTRY FAR* lpTask, HTASK hTask);
DWORD   WINAPI TaskSetCSIP(HTASK hTask, WORD wCS, WORD wIP);
DWORD   WINAPI TaskGetCSIP(HTASK hTask);
BOOL    WINAPI TaskSwitch(HTASK hTask, DWORD dwNewCSIP);

/****** Window Class enumeration **********************************************/

typedef struct tagCLASSENTRY
{
    DWORD dwSize;
    HMODULE hInst;              /* This is really an hModule */
    char szClassName[MAX_CLASSNAME + 1];
    WORD wNext;
} CLASSENTRY;

BOOL    WINAPI ClassFirst(CLASSENTRY FAR* lpClass);
BOOL    WINAPI ClassNext(CLASSENTRY FAR* lpClass);

/****** Information functions *************************************************/

typedef struct tagMEMMANINFO
{
    DWORD dwSize;
    DWORD dwLargestFreeBlock;
    DWORD dwMaxPagesAvailable;
    DWORD dwMaxPagesLockable;
    DWORD dwTotalLinearSpace;
    DWORD dwTotalUnlockedPages;
    DWORD dwFreePages;
    DWORD dwTotalPages;
    DWORD dwFreeLinearSpace;
    DWORD dwSwapFilePages;
    WORD wPageSize;
} MEMMANINFO;

BOOL    WINAPI MemManInfo(MEMMANINFO FAR* lpEnhMode);

typedef struct tagSYSHEAPINFO
{
    DWORD dwSize;
    WORD wUserFreePercent;
    WORD wGDIFreePercent;
    HGLOBAL hUserSegment;
    HGLOBAL hGDISegment;
} SYSHEAPINFO;

BOOL    WINAPI SystemHeapInfo(SYSHEAPINFO FAR* lpSysHeap);

/****** Interrupt Handling ****************************************************/

/* Hooked interrupts */
#define INT_DIV0            0
#define INT_1               1
#define INT_3               3
#define INT_UDINSTR         6
#define INT_STKFAULT        12
#define INT_GPFAULT         13
#define INT_BADPAGEFAULT    14
#define INT_CTLALTSYSRQ     256

/* TOOLHELP Interrupt callbacks registered with InterruptRegister should
 *  always be written in assembly language.  The stack frame is not 
 *  compatible with high level language conventions.
 *
 *  This stack frame looks as follows to the callback.  All registers
 *  should be preserved across this callback to allow restarting fault.
 *               ------------
 *               |   Flags  |  [SP + 0Eh]
 *               |    CS    |  [SP + 0Ch]
 *               |    IP    |  [SP + 0Ah]
 *               |  Handle  |  [SP + 08h]
 *               |Exception#|  [SP + 06h]
 *               |    AX    |  [SP + 04h]  AX Saved to allow MakeProcInstance
 *               |  Ret CS  |  [SP + 02h]
 *       SP--->  |  Ret IP  |  [SP + 00h]
 *               ------------
 */
BOOL    WINAPI InterruptRegister(HTASK hTask, FARPROC lpfnIntCallback);
BOOL    WINAPI InterruptUnRegister(HTASK hTask);

/*  Notifications:
 *      When a notification callback is called, two parameters are passed
 *      in:  a WORD, wID, and another DWORD, dwData.  wID is one of
 *      the values NFY_* below.  Callback routines should ignore unrecog-
 *      nized values to preserve future compatibility.  Callback routines
 *      are also passed a dwData value.  This may contain data or may be
 *      a FAR pointer to a structure, or may not be used depending on
 *      which notification is being received.
 *
 *      In all cases, if the return value of the callback is TRUE, the
 *      notification will NOT be passed on to other callbacks.  It has
 *      been handled.  This should be used sparingly and only with certain
 *      notifications.  Callbacks almost always return FALSE.
 */

/* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
 *  should ignore these.
 */
#define NFY_UNKNOWN         0

/* NFY_LOADSEG:  dwData points to a NFYLOADSEG structure */
#define NFY_LOADSEG         1
typedef struct tagNFYLOADSEG
{
    DWORD dwSize;
    WORD wSelector;
    WORD wSegNum;
    WORD wType;             /* Low bit set if data seg, clear if code seg */
    WORD wcInstance;        /* Instance count ONLY VALID FOR DATA SEG */
    LPCSTR lpstrModuleName;
} NFYLOADSEG;

/* NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed */
#define NFY_FREESEG         2

/* NFY_STARTDLL:  dwData points to a NFYLOADSEG structure */
#define NFY_STARTDLL        3
typedef struct tagNFYSTARTDLL
{
    DWORD dwSize;
    HMODULE hModule;
    WORD wCS;
    WORD wIP;
} NFYSTARTDLL;

/* NFY_STARTTASK:  dwData is the CS:IP of the start address of the task */
#define NFY_STARTTASK       4

/* NFY_EXITTASK:  The low byte of dwData contains the program exit code */
#define NFY_EXITTASK        5

/* NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed */
#define NFY_DELMODULE       6

/* NFY_RIP:  dwData points to a NFYRIP structure */
#define NFY_RIP             7
typedef struct tagNFYRIP
{
    DWORD dwSize;
    WORD wIP;
    WORD wCS;
    WORD wSS;
    WORD wBP;
    WORD wExitCode;
} NFYRIP;

/* NFY_TASKIN:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKIN          8

/* NFY_TASKOUT:  No data.  Callback should do GetCurrentTask() */
#define NFY_TASKOUT         9

/* NFY_INCHAR:  Return value from callback is used.  If NULL, mapped to 'i' */
#define NFY_INCHAR          10

/* NFY_OUTSTR:  dwData points to the string to be displayed */
#define NFY_OUTSTR          11

/* NFY_LOGERROR:  dwData points to a NFYLOGERROR struct */
#define NFY_LOGERROR        12
typedef struct tagNFYLOGERROR
{
    DWORD dwSize;
    UINT wErrCode;
    void FAR* lpInfo;       /* Error code-dependent */
} NFYLOGERROR;

/* NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct */
#define NFY_LOGPARAMERROR   13
typedef struct tagNFYLOGPARAMERROR
{
    DWORD dwSize;
    UINT wErrCode;
    FARPROC lpfnErrorAddr;
    void FAR* FAR* lpBadParam;
} NFYLOGPARAMERROR;

/* NotifyRegister() flags */
#define NF_NORMAL       0
#define NF_TASKSWITCH   1
#define NF_RIP          2

typedef BOOL (CALLBACK* LPFNNOTIFYCALLBACK)(WORD wID, DWORD dwData);

BOOL    WINAPI NotifyRegister(HTASK hTask, LPFNNOTIFYCALLBACK lpfn, WORD wFlags);
BOOL    WINAPI NotifyUnRegister(HTASK hTask);

/****** Miscellaneous *********************************************************/

void    WINAPI TerminateApp(HTASK hTask, WORD wFlags);

/* TerminateApp() flag values */
#define UAE_BOX     0
#define NO_UAE_BOX  1

DWORD   WINAPI MemoryRead(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);
DWORD   WINAPI MemoryWrite(WORD wSel, DWORD dwOffset, void FAR* lpBuffer, DWORD dwcb);

typedef struct tagTIMERINFO
{
    DWORD dwSize;
    DWORD dwmsSinceStart;
    DWORD dwmsThisVM;
} TIMERINFO;

BOOL    WINAPI TimerCount(TIMERINFO FAR* lpTimer);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif

#endif /* !_INC_TOOLHELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\time.h ===
/***
*time.h - definitions/declarations for time routines
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the various declarations and definitions
*   for the time routines.
*   [ANSI/System V]
*
****/

#ifndef _INC_TIME

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#define __near      _near
#define __pascal    _pascal
#endif 

/* implementation defined time types */

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

#ifndef _CLOCK_T_DEFINED
typedef long clock_t;
#define _CLOCK_T_DEFINED
#endif 

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif 

/* structure for use with localtime(), gmtime(), etc. */

#ifndef _TM_DEFINED
struct tm {
    int tm_sec; /* seconds after the minute - [0,59] */
    int tm_min; /* minutes after the hour - [0,59] */
    int tm_hour;    /* hours since midnight - [0,23] */
    int tm_mday;    /* day of the month - [1,31] */
    int tm_mon; /* months since January - [0,11] */
    int tm_year;    /* years since 1900 */
    int tm_wday;    /* days since Sunday - [0,6] */
    int tm_yday;    /* days since January 1 - [0,365] */
    int tm_isdst;   /* daylight savings time flag */
    };
#define _TM_DEFINED
#endif 


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else 
#define NULL    ((void *)0)
#endif 
#endif 


/* clock ticks macro - ANSI version */

#define CLOCKS_PER_SEC  1000


/* extern declarations for the global variables used by the ctime family of
 * routines.
 */

extern int __near __cdecl _daylight;    /* non-zero if daylight savings time is used */
extern long __near __cdecl _timezone;   /* difference in seconds between GMT and local time */
extern char * __near __cdecl _tzname[2];/* standard/daylight savings time zone names */


/* function prototypes */

#ifdef _MT
double __pascal difftime(time_t, time_t);
#else 
double __cdecl difftime(time_t, time_t);
#endif 

char * __cdecl asctime(const struct tm *);
char * __cdecl ctime(const time_t *);
#ifndef _WINDLL
clock_t __cdecl clock(void);
#endif 
struct tm * __cdecl gmtime(const time_t *);
struct tm * __cdecl localtime(const time_t *);
time_t __cdecl mktime(struct tm *);
#ifndef _WINDLL
size_t __cdecl strftime(char *, size_t, const char *,
    const struct tm *);
#endif 
char * __cdecl _strdate(char *);
char * __cdecl _strtime(char *);
time_t __cdecl time(time_t *);
void __cdecl _tzset(void);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define CLK_TCK  CLOCKS_PER_SEC

extern int __near __cdecl daylight;
extern long __near __cdecl timezone;
extern char * __near __cdecl tzname[2];

void __cdecl tzset(void);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_TIME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\tchar.h ===
/***
*tchar.h - definitions for generic international text functions (16-bit)
*
*   Copyright (c) 1991-1994, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   Definitions for generic international functions, mostly defines
*   which map string/formatted-io/ctype functions to char, wchar_t, or
*   MBCS versions.  To be used for compatibility between single-byte,
*   multi-byte and Unicode text models.
*
*   NOTE: This is a stripped-down version for use with 16-bit libraries.
*       It maps to SBCS only, not to MBCS or Unicode.
*
****/

#ifndef _INC_TCHAR

#ifdef  _MSC_VER
#pragma warning(disable:4505)       /* disable unwanted C++ /W4 warning */
/* #pragma warning(default:4505) */ /* use this to reenable, if necessary */
#endif  /* _MSC_VER */

#ifdef  __cplusplus
extern "C" {
#endif


/* Define __cdecl for non-Microsoft compilers */

#if ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif


#define _TEOF       EOF

#define __T(x)      x

#ifndef __TCHAR_DEFINED
typedef char            _TCHAR;
typedef signed char     _TSCHAR;
typedef unsigned char   _TUCHAR;
typedef char            _TXCHAR;
typedef int             _TINT;
#define __TCHAR_DEFINED
#endif

#ifndef _TCHAR_DEFINED
#if !__STDC__
typedef char            TCHAR;
#endif
#define _TCHAR_DEFINED
#endif


/* ++++++++++++++++++++ SBCS FUNCTIONS ++++++++++++++++++++ */


/* Program */

#define _tmain      main
#ifdef  _POSIX_
#define _tenviron   environ
#else
#define _tenviron  _environ
#endif


/* Far functions */

#define _ftcscat    _fstrcat
#define _ftcschr    _fstrchr
#define _ftcscmp    _fstrcmp
#define _ftcscpy    _fstrcpy
#define _ftcscspn   _fstrcspn
#define _ftcslen    _fstrlen
#define _ftcsncat   _fstrncat
#define _ftcsncmp   _fstrncmp
#define _ftcsncpy   _fstrncpy
#define _ftcspbrk   _fstrpbrk
#define _ftcsrchr   _fstrrchr
#define _ftcsspn    _fstrspn
#define _ftcsstr    _fstrstr
#define _ftcstok    _fstrtok

#define _ftcsdup    _fstrdup
#define _ftcsicmp   _fstricmp
#define _ftcsnicmp  _fstrnicmp
#define _ftcsnset   _fstrnset
#define _ftcsrev    _fstrrev
#define _ftcsset    _fstrset

#define _ftcslwr    _fstrlwr
#define _ftcsupr    _fstrupr


/* Formatted i/o */

#define _tprintf    printf
#define _ftprintf   fprintf
#define _stprintf   sprintf
#define _sntprintf  _snprintf
#define _vtprintf   vprintf
#define _vftprintf  vfprintf
#define _vstprintf  vsprintf
#define _vsntprintf _vsnprintf
#define _tscanf     scanf
#define _ftscanf    fscanf
#define _stscanf    sscanf


/* Unformatted i/o */

#define _fgettc     fgetc
#define _fgettchar  _fgetchar
#define _fgetts     fgets
#define _fputtc     fputc
#define _fputtchar  _fputchar
#define _fputts     fputs
#define _gettc      getc
#define _gettchar   getchar
#define _getts      gets
#define _puttc      putc
#define _puttchar   putchar
#define _putts      puts
#define _ungettc    ungetc


/* Execute functions */

#define _texecl     _execl
#define _texecle    _execle
#define _texeclp    _execlp
#define _texeclpe   _execlpe
#define _texecv     _execv
#define _texecve    _execve
#define _texecvp    _execvp
#define _texecvpe   _execvpe

#define _tspawnl    _spawnl
#define _tspawnle   _spawnle
#define _tspawnlp   _spawnlp
#define _tspawnlpe  _spawnlpe
#define _tspawnv    _spawnv
#define _tspawnve   _spawnve
#define _tspawnvp   _spawnvp
#define _tspawnvpe  _spawnvpe

#define _tsystem    system


/* Time functions */

#define _tasctime   asctime
#define _tctime     ctime
#define _tstrdate   _strdate
#define _tstrtime   _strtime
#define _tutime     _utime
#define _tcsftime   strftime


/* Directory functions */

#define _tchdir     _chdir
#define _tgetcwd    _getcwd
#define _tgetdcwd   _getdcwd
#define _tmkdir     _mkdir
#define _trmdir     _rmdir


/* Environment/Path functions */

#define _tfullpath  _fullpath
#define _tgetenv    getenv
#define _tmakepath  _makepath
#define _tputenv    _putenv
#define _tsearchenv _searchenv
#define _tsplitpath _splitpath


/* Stdio functions */

#ifdef  _POSIX_
#define _tfdopen    fdopen
#else
#define _tfdopen    _fdopen
#endif
#define _tfsopen    _fsopen
#define _tfopen     fopen
#define _tfreopen   freopen
#define _tperror    perror
#define _tpopen     _popen
#define _tsetbuf    setbuf
#define _tsetvbuf   setvbuf
#define _ttempnam   _tempnam
#define _ttmpnam    tmpnam


/* Io functions */

#define _taccess    _access
#define _tchmod     _chmod
#define _tcreat     _creat
#define _tfindfirst _findfirst
#define _tfindnext  _findnext
#define _tmktemp    _mktemp
#define _topen      _open
#define _tremove    remove
#define _trename    rename
#define _tsopen     _sopen
#define _tunlink    _unlink

#define _tfinddata_t    _finddata_t


/* Stat functions */

#define _tstat      _stat


/* Setlocale functions */

#define _tsetlocale setlocale


/* String conversion functions */

#define _tcstod     strtod
#define _tcstol     strtol
#define _tcstoul    strtoul

#define _itot       _itoa
#define _ltot       _ltoa
#define _ultot      _ultoa
#define _ttoi       atoi
#define _ttol       atol


/* String functions */

#define _tcscat     strcat
#define _tcscpy     strcpy
#define _tcslen     strlen
#define _tcsxfrm    strxfrm
#define _tcscoll    strcoll

#define _tcsdup     _strdup

#define _tcschr     strchr
#define _tcscmp     strcmp
#define _tcscspn    strcspn
#define _tcsncat    strncat
#define _tcsncmp    strncmp
#define _tcsncpy    strncpy
#define _tcspbrk    strpbrk
#define _tcsrchr    strrchr
#define _tcsspn     strspn
#define _tcsstr     strstr
#define _tcstok     strtok

#define _tcsicmp    _stricmp
#define _tcsnicmp   _strnicmp
#define _tcsnset    _strnset
#define _tcsrev     _strrev
#define _tcsset     _strset


/* "logical-character" mappings */

#define _tcsclen    strlen
#define _tcsnccat   strncat
#define _tcsnccpy   strncpy
#define _tcsnccmp   strncmp
#define _tcsncicmp  _strnicmp
#define _tcsncset   _strnset


/* Ctype functions */

#define _istascii   isascii
#define _istcntrl   iscntrl
#define _istxdigit  isxdigit

#define _istalnum   isalnum
#define _istalpha   isalpha
#define _istdigit   isdigit
#define _istgraph   isgraph
#define _istlower   islower
#define _istprint   isprint
#define _istpunct   ispunct
#define _istspace   isspace
#define _istupper   isupper

#define _totupper   toupper
#define _totlower   tolower


/* Generic text macros to be used with string literals and character constants.
   Will also allow symbolic constants that resolve to same. */

#define _T(x)       __T(x)
#define _TEXT(x)    __T(x)


#ifdef __cplusplus
}
#endif

#define _INC_TCHAR
#endif  /* _INC_TCHAR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\toolhelp.inc ===
;**************************************************************************
;*  TOOLHELP.INC
;*
;*      Assembly-language public include file for TOOLHELP.DLL
;*
;**************************************************************************

;** General symbol values
MAX_DATA        EQU     11
MAX_PATH        EQU     255
MAX_MODULE_NAME EQU     8 + 1           ;Leave room for the zero and padding
MAX_CLASSNAME   EQU     255

; ----- Global heap walking -----

GLOBALENTRY STRUC
ge_dwSize       DD      ?               ;Structure version
ge_dwAddress    DD      ?               ;This block's address
ge_dwBlockSize  DD      ?               ;This block's size
ge_hBlock       DW      ?               ;This block's handle
ge_wcLock       DW      ?               ;Lock count
ge_wcPageLock   DW      ?               ;Page lock count
ge_wFlags       DW      ?               ;Block flags
ge_wHeapPresent DW      ?               ;Size of available local heap
ge_hOwner       DW      ?               ;Owner handle
ge_wType        DW      ?               ;Block type
ge_wData        DW      ?               ;Type-specific data
ge_dwNext       DD      ?               ;Pointer to next block
ge_dwNextAlt    DD      ?               ;Next free/LRU block in chain
GLOBALENTRY ENDS

; ** GlobalFirst()/GlobalNext() flags
GLOBAL_ALL      EQU     0
GLOBAL_LRU      EQU     1
GLOBAL_FREE     EQU     2

; ** GLOBALENTRY.ge_wType entries
GT_UNKNOWN      EQU     0
GT_DGROUP       EQU     1
GT_DATA         EQU     2
GT_CODE         EQU     3
GT_TASK         EQU     4
GT_RESOURCE     EQU     5
GT_MODULE       EQU     6
GT_FREE         EQU     7
GT_INTERNAL     EQU     8
GT_SENTINEL     EQU     9
GT_BURGERMASTER EQU     10

; ** if GLOBALENTRY.wType==GT_RESOURCE, the following is GLOBALENTRY.wData:
GD_USERDEFINED          EQU     0
GD_CURSORCOMPONENT      EQU     1
GD_BITMAP               EQU     2
GD_ICONCOMPONENT        EQU     3
GD_MENU                 EQU     4
GD_DIALOG               EQU     5
GD_STRING               EQU     6
GD_FONTDIR              EQU     7
GD_FONT                 EQU     8
GD_ACCELERATORS         EQU     9
GD_RCDATA               EQU     10
GD_ERRTABLE             EQU     11
GD_CURSOR               EQU     12
GD_ICON                 EQU     14
GD_NAMETABLE            EQU     15
GD_MAX_RESOURCE         EQU     15

;** GLOBALENTRY.wFlags
GF_PDB_OWNER    EQU     100h            ;Low byte is KERNEL flags

; ----- Local heap walking -----

LOCALENTRY STRUC
le_dwSize       DD      ?
le_hHandle      DW      ?
le_wAddress     DW      ?
le_wSize        DW      ?
le_wFlags       DW      ?
le_wcLock       DW      ?
le_wType        DW      ?
le_hHeap        DW      ?
le_wHeapType    DW      ?
le_wNext        DW      ?
LOCALENTRY ENDS

; ** LOCALENTRY.wHeapType flags
NORMAL_HEAP     EQU     0
USER_HEAP       EQU     1
GDI_HEAP        EQU     2

;** LOCALENTRY.wFlags
LF_FIXED                EQU     1
LF_FREE                 EQU     2
LF_MOVEABLE             EQU     4

;** LOCALENTRY.wType
LT_NORMAL               EQU     0
LT_GDI_PEN              EQU     1
LT_GDI_BRUSH            EQU     2
LT_GDI_FONT             EQU     3
LT_GDI_PALETTE          EQU     4
LT_GDI_BITMAP           EQU     5
LT_GDI_RGN              EQU     6
LT_GDI_DC               EQU     7
LT_GDI_DISABLED_DC      EQU     8
LT_GDI_METADC           EQU     9
LT_GDI_METAFILE         EQU     10
LT_GDI_MAX              EQU     LT_GDI_METAFILE
LT_FREE                 EQU     0ffh

; ----- Stack tracing -----

STACKTRACEENTRY STRUC
st_dwSize       DD      ?
st_hTask        DW      ?
st_wSS          DW      ?
st_wBP          DW      ?
st_wCS          DW      ?
st_wIP          DW      ?
st_hModule      DW      ?
st_wSegment     DW      ?
st_wFlags       DW      ?
STACKTRACEENTRY ENDS

;** STACKTRACEENTRY.wFlags values
FRAME_FAR       EQU     0
FRAME_NEAR      EQU     1

; ----- Module list walking -----

MODULEENTRY STRUC
me_dwSize       DD      ?
me_szModule     DB      MAX_MODULE_NAME + 1 DUP(?)
me_hModule      DW      ?
me_wcUsage      DW      ?
me_szExePath    DB      MAX_PATH + 1 + 1 DUP(?)
me_wNext        DW      ?
MODULEENTRY ENDS

; ----- Task list walking -----

TASKENTRY STRUC
te_dwSize               DD      ?
te_hTask                DW      ?
te_hTaskParent          DW      ?
te_hInst                DW      ?
te_hModule              DW      ?
te_wSS                  DW      ?
te_wSP                  DW      ?
te_wStackTop            DW      ?
te_wStackMinimum        DW      ?
te_wStackBottom         DW      ?
te_wcEvents             DW      ?
te_hQueue               DW      ?
te_szModule             DB      MAX_MODULE_NAME + 1 DUP(?)
te_wPSPOffset           DW      ?
te_hNext                DW      ?
TASKENTRY ENDS

;** TaskSwitch() return values
TS_ERROR    EQU         0
TS_NEW      EQU         1
TS_OLD      EQU         2

; ----- Window Class enumeration -----

CLASSENTRY STRUC
ce_dwSize               DD      ?
ce_hInst                DW      ?
ce_szClassName          DB      MAX_CLASSNAME + 1 DUP(?)
ce_wNext                DW      ?
CLASSENTRY ENDS

; ----- Information functions -----

VMEMMANINFO STRUC
vmm_dwSize              DD      ?
vmm_dwLargestFreeBlock  DD      ?
vmm_dwMaxPagesAvailable DD      ?
vmm_dwMaxPagesLockable  DD      ?
vmm_dwTotalLinearSpace  DD      ?
vmm_dwTotalUnlockedPages DD     ?
vmm_dwFreePages         DD      ?
vmm_dwTotalPages        DD      ?
vmm_dwFreeLinearSpace   DD      ?
vmm_dwSwapFilePages     DD      ?
vmm_wPageSize           DW      ?
VMEMMANINFO ENDS

SYSHEAPINFO STRUC
si_dwSize               DD      ?
si_wUserFreePercent     DW      ?
si_wGDIFreePercent      DW      ?
si_hUserSegment         DW      ?
si_hGDISegment          DW      ?
SYSHEAPINFO ENDS

; ----- Notifications -----

;* NFY_UNKNOWN:  An unknown notification has been returned from KERNEL.  Apps
;*      should ignore these.
;*
NFY_UNKNOWN     EQU     0

;** NFY_LOADSEG:  dwData points to a NFYLOADSEG structure
NFY_LOADSEG     EQU     1
NFYLOADSEG STRUC
nls_dwSize              DD      ?
nls_wSelector           DW      ?
nls_wSegNum             DW      ?
nls_wType               DW      ?       ;Low bit set for DATA, clear for CODE
nls_wcInstance          DW      ?       ;Instance count ONLY VALID FOR DATA!
nls_lpstrModuleName     DD      ?
NFYLOADSEG ENDS

;** NFY_FREESEG:  LOWORD(dwData) is the selector of the segment being freed
NFY_FREESEG     EQU     2

;** NFY_STARTDLL:  dwData points to a NFYSTARTDLL structure
NFY_STARTDLL    EQU     3
NFYSTARTDLL STRUC
nsd_dwSize              DD      ?
nsd_hModule             DW      ?
nsd_wCS                 DW      ?
nsd_wIP                 DW      ?
NFYSTARTDLL ENDS

;** NFY_STARTTASK:  dwData is the CS:IP of the task start address
NFY_STARTTASK   EQU     4

;** NFY_EXITTASK:  The low byte of dwData contains the program exit code
NFY_EXITTASK    EQU     5

;** NFY_DELMODULE:  LOWORD(dwData) is the handle of the module to be freed
NFY_DELMODULE   EQU     6

;** NFY_RIP:  LOWORD(dwData) is the fatal exit code
;** NFY_RIP:  dwData points to a NFYRIP structure
NFY_RIP         EQU     7
NFYRIP STRUC
nrp_dwSize      DD      ?
nrp_wIP         DW      ?
nrp_wCS         DW      ?
nrp_wSS         DW      ?
nrp_wBP         DW      ?
nrp_wExitCode   DW      ?
NFYRIP ENDS

;** NFY_TASKIN:  No data.  Callback should do GetCurrentTask()
NFY_TASKIN      EQU     8

;** NFY_TASKOUT:  No data.  Callback should do GetCurrentTask()
NFY_TASKOUT     EQU     9

;** NFY_INCHAR:  Return value of callback is used.  If FALSE, mapped to 'i'
NFY_INCHAR      EQU     10

;** NFY_OUTSTR:  dwData points to the string to be displayed
NFY_OUTSTR      EQU     11

;** NFY_LOGERROR:  dwData points to a NFYLOGERROR struct
NFY_LOGERROR    EQU     12
NFYLOGERROR STRUC
nle_dwSize      DD      ?
nle_wErrCode    DW      ?
nle_lpInfo      DD      ?       ;Error-code dependent
NFYLOGERROR ENDS

;** NFY_LOGPARAMERROR:  dwData points to a NFYLOGPARAMERROR struct
NFY_LOGPARAMERROR EQU   13
NFYLOGPARAMERROR STRUC
nlp_dwSize              DD      ?
nlp_wErrCode            DW      ?
nlp_lpfnErrorAddr       DD      ?
nlp_lpBadParam          DD      ?
NFYLOGPARAMERROR ENDS

;** NotifyRegister() flags
NF_NORMAL       EQU     0
NF_TASKSWITCH   EQU     1
NF_RIP          EQU     2

;** TerminateApp() flag values
UAE_BOX         EQU     0
NO_UAE_BOX      EQU     1

TIMERINFO STRUC
ti_dwSize               DD      ?
ti_dwmsSinceStart       DD      ?
ti_dwmsThisVM           DD      ?
TIMERINFO ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\varargs.h ===
/***
*varargs.h - XENIX style macros for variable argument functions
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines XENIX style macros for accessing arguments of a
*   function which takes a variable number of arguments.
*   [System V]
*
****/

#ifdef __cplusplus
extern "C" {
#endif 

#ifdef _WINDLL
#define _FARARG_ __far
#else 
#define _FARARG_
#endif 

#if (_MSC_VER <= 600)
#define __far       _far
#endif 

#ifdef __STDC__
#error varargs.h incompatible with ANSI (use stdarg.h)
#endif 

#ifndef _VA_LIST_DEFINED
typedef char _FARARG_ *va_list;
#define _VA_LIST_DEFINED
#endif 

/*
 * define a macro to compute the size of a type, variable or expression,
 * rounded up to the nearest multiple of sizeof(int). This number is its
 * size as function argument (Intel architecture). Note that the macro
 * depends on sizeof(int) being a power of 2!
 */

#define _INTSIZEOF(n)    ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define va_dcl va_list va_alist;
#define va_start(ap) ap = (va_list)&va_alist
#define va_arg(ap,t) ( *(t _FARARG_ *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define va_end(ap) ap = (va_list)0

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\ver.h ===
/*****************************************************************************\
*                                                                             *
* ver.h -       Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL and VER.LIB.  These libraries are    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*               The API is unchanged for LIB and DLL versions.                *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
*******************************************************************************
*
* #define LIB   - To be used with VER.LIB (default is for VER.DLL)
*
\*****************************************************************************/

#ifndef _INC_VER
#define _INC_VER

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
 * If .lib version is being used, declare types used in this file.
 */
#ifdef LIB

#ifndef WINAPI                      /* don't declare if they're already declared */
#define WINAPI      _far _pascal
#define NEAR        _near
#define FAR         _far
#define PASCAL      _pascal
typedef int             BOOL;
#define TRUE        1
#define FALSE       0
typedef unsigned char   BYTE;
typedef unsigned short  WORD;
typedef unsigned int    UINT;
typedef signed long     LONG;
typedef unsigned long   DWORD;
typedef char far*       LPSTR;
typedef const char far* LPCSTR;
typedef int             HFILE;
#define OFSTRUCT    void            /* Not used by the .lib version */
#define LOWORD(l)		((WORD)(l))
#define HIWORD(l)		((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define MAKEINTRESOURCE(i)	(LPSTR)((DWORD)((WORD)(i)))
#endif  /* WINAPI */

#else   /* LIB */

/* If .dll version is being used and we're being included with
 * the 3.0 windows.h, #define compatible type aliases.
 * If included with the 3.0 windows.h, #define compatible aliases
 */
#ifndef _INC_WINDOWS
#define UINT        WORD
#define LPCSTR      LPSTR
#define HFILE       int
#endif  /* !_INC_WINDOWS */

#endif  /* !LIB */

/* ----- RC defines ----- */
#ifdef RC_INVOKED
#define ID(id)			id
#else
#define ID(id)			MAKEINTRESOURCE(id)
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO		ID(16)		/* Version stamp res type */
#define VS_VERSION_INFO		ID(1)  		/* Version stamp res ID */
#define VS_USER_DEFINED		ID(100)		/* User-defined res IDs */

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FFI_SIGNATURE	0xFEEF04BDL
#define	VS_FFI_STRUCVERSION	0x00010000L
#define	VS_FFI_FILEFLAGSMASK	0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define	VS_FF_DEBUG		0x00000001L
#define	VS_FF_PRERELEASE	0x00000002L
#define	VS_FF_PATCHED		0x00000004L
#define	VS_FF_PRIVATEBUILD	0x00000008L
#define	VS_FF_INFOINFERRED	0x00000010L
#define	VS_FF_SPECIALBUILD	0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define	VOS_UNKNOWN		0x00000000L
#define	VOS_DOS			0x00010000L
#define	VOS_OS216		0x00020000L
#define	VOS_OS232		0x00030000L
#define	VOS_NT			0x00040000L

#define	VOS__BASE		0x00000000L
#define	VOS__WINDOWS16		0x00000001L
#define	VOS__PM16		0x00000002L
#define	VOS__PM32		0x00000003L
#define	VOS__WINDOWS32		0x00000004L

#define	VOS_DOS_WINDOWS16	0x00010001L
#define	VOS_DOS_WINDOWS32	0x00010004L
#define	VOS_OS216_PM16		0x00020002L
#define	VOS_OS232_PM32		0x00030003L
#define	VOS_NT_WINDOWS32	0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define	VFT_UNKNOWN		0x00000000L
#define	VFT_APP			0x00000001L
#define	VFT_DLL			0x00000002L
#define	VFT_DRV			0x00000003L
#define	VFT_FONT		0x00000004L
#define	VFT_VXD			0x00000005L
#define	VFT_STATIC_LIB		0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define	VFT2_UNKNOWN		0x00000000L
#define VFT2_DRV_PRINTER	0x00000001L
#define	VFT2_DRV_KEYBOARD	0x00000002L
#define	VFT2_DRV_LANGUAGE	0x00000003L
#define	VFT2_DRV_DISPLAY	0x00000004L
#define	VFT2_DRV_MOUSE		0x00000005L
#define	VFT2_DRV_NETWORK	0x00000006L
#define	VFT2_DRV_SYSTEM		0x00000007L
#define	VFT2_DRV_INSTALLABLE	0x00000008L
#define	VFT2_DRV_SOUND		0x00000009L
#define	VFT2_DRV_COMM		0x0000000AL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER	0x00000001L
#define	VFT2_FONT_VECTOR	0x00000002L
#define	VFT2_FONT_TRUETYPE	0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE	0x0001

#define VFF_CURNEDEST		0x0001
#define VFF_FILEINUSE		0x0002
#define VFF_BUFFTOOSMALL	0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL	0x0001
#define VIFF_DONTDELETEOLD	0x0002

#define VIF_TEMPFILE		0x00000001L
#define VIF_MISMATCH		0x00000002L
#define VIF_SRCOLD		0x00000004L

#define VIF_DIFFLANG		0x00000008L
#define VIF_DIFFCODEPG		0x00000010L
#define VIF_DIFFTYPE		0x00000020L

#define VIF_WRITEPROT		0x00000040L
#define VIF_FILEINUSE		0x00000080L
#define VIF_OUTOFSPACE		0x00000100L
#define VIF_ACCESSVIOLATION	0x00000200L
#define VIF_SHARINGVIOLATION	0x00000400L
#define VIF_CANNOTCREATE	0x00000800L
#define VIF_CANNOTDELETE	0x00001000L
#define VIF_CANNOTRENAME	0x00002000L
#define VIF_CANNOTDELETECUR	0x00004000L
#define VIF_OUTOFMEMORY		0x00008000L

#define VIF_CANNOTREADSRC	0x00010000L
#define VIF_CANNOTREADDST	0x00020000L

#define VIF_BUFFTOOSMALL	0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef signed short int SHORT;

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

UINT WINAPI VerFindFile(UINT uFlags, LPCSTR szFileName,
      LPCSTR szWinDir, LPCSTR szAppDir,
      LPSTR szCurDir, UINT FAR* lpuCurDirLen,
      LPSTR szDestDir, UINT FAR* lpuDestDirLen);

DWORD WINAPI VerInstallFile(UINT uFlags,
      LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir,
      LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, UINT FAR* lpuTmpFileLen);

/* Returns size of version info in bytes */
DWORD WINAPI GetFileVersionInfoSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD FAR *lpdwHandle);   /* Information for use by GetFileVersionInfo */

/* Read version info into buffer */
BOOL WINAPI GetFileVersionInfo(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      DWORD dwHandle,           /* Information from GetFileVersionSize */
      DWORD dwLen,              /* Length of buffer for info */
      void FAR* lpData);        /* Buffer to place the data structure */

/* Returns size of resource in bytes */
DWORD WINAPI GetFileResourceSize(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD FAR *lpdwFileOffset); /* Returns file offset of resource */

/* Reads file resource into buffer */
BOOL WINAPI GetFileResource(
      LPCSTR lpstrFilename,     /* Filename of version stamped file */
      LPCSTR lpstrResType,      /* Type:  normally VS_FILE_INFO */
      LPCSTR lpstrResID,        /* ID:  normally VS_VERSION_INFO */
      DWORD dwFileOffset,       /* File offset or NULL */
      DWORD dwResLen,           /* Length of resource to read or NULL */
      void FAR* lpData);        /* Pointer to data buffer */

UINT WINAPI VerLanguageName(UINT wLang, LPSTR szLang, UINT nSize);

UINT WINAPI GetWindowsDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

UINT WINAPI GetSystemDir(LPCSTR szAppDir, LPSTR lpBuffer, int nSize);

BOOL WINAPI VerQueryValue(const void FAR* pBlock, LPCSTR lpSubBlock,
      void FAR* FAR* lplpBuffer, UINT FAR* lpuLen);

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#pragma pack()

#endif  /* !RC_INVOKED */
#endif  /* !_INC_VER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\variant.h ===
/*** 
*variant.h
*
*  Copyright (C) 1992-1993, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*  This file declares VARIANT, and related data types.
*
*Implementation Notes:
*  This file requires ole2.h
*
*****************************************************************************/

#ifndef _VARIANT_H_
#define _VARIANT_H_


#ifndef HUGEP
# ifdef _MAC
#  define HUGEP FAR
# else
#  if WIN32
#   define HUGEP
#  else
#   define HUGEP _huge
#  endif
# endif
#endif

#ifndef FAR
# ifdef _MAC
#  define FAR
# else
#  ifdef WIN32
#   define FAR
#  else
#   define FAR _far
#  endif
# endif
#endif


/* Forward Declarations */

#ifdef __cplusplus
interface IDispatch;
#else
typedef interface IDispatch IDispatch;
#endif


#if defined(WIN32) && defined(UNICODE) 

  typedef wchar_t FAR* BSTR;
  typedef BSTR FAR* LPBSTR;

#else /* ANSI Version */

  typedef char FAR* BSTR;
  typedef BSTR FAR* LPBSTR;
  
  #ifndef _TCHAR_DEFINED
     typedef char TCHAR;
  #endif

#endif


typedef struct FARSTRUCT tagSAFEARRAYBOUND {
    unsigned long cElements;
    long lLbound;
} SAFEARRAYBOUND, FAR* LPSAFEARRAYBOUND;

typedef struct FARSTRUCT tagSAFEARRAY {
    unsigned short cDims;
    unsigned short fFeatures;
    unsigned short cbElements;
    unsigned short cLocks;
#ifdef _MAC
    Handle handle;
#else
    unsigned long handle;
#endif
    void HUGEP* pvData;
    SAFEARRAYBOUND rgsabound[1];
} SAFEARRAY, FAR* LPSAFEARRAY;

#define FADF_AUTO       0x0001	/* array is allocated on the stack         */
#define FADF_STATIC     0x0002	/* array is staticly allocated             */
#define FADF_EMBEDDED   0x0004	/* array is embedded in a structure        */
#define FADF_FIXEDSIZE  0x0010	/* array may not be resized or reallocated */
#define FADF_BSTR       0x0100	/* an array of BSTRs                       */
#define FADF_UNKNOWN    0x0200	/* an array of IUnknown*                   */
#define FADF_DISPATCH   0x0400	/* an array of IDispatch*                  */
#define FADF_VARIANT    0x0800	/* an array of VARIANTs                    */
#define FADF_RESERVED   0xF0E8  /* bits reserved for future use            */


/* 0 == FALSE, -1 == TRUE */
typedef short VARIANT_BOOL;


typedef double DATE;


/* This is a helper struct for use in handling currency. */
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
    long	  Hi;
    unsigned long Lo;
#else
    unsigned long Lo;
    long	  Hi;
#endif
} CY;


/*
 * VARENUM usage key,
 *
 *   [V] - may appear in a VARIANT
 *   [T] - may appear in a TYPEDESC
 *   [P] - may appear in an OLE property set
 *
 */
enum VARENUM
{
    VT_EMPTY           = 0,   /* [V]   [P]  nothing                     */
    VT_NULL            = 1,   /* [V]        SQL style Null              */
    VT_I2              = 2,   /* [V][T][P]  2 byte signed int           */
    VT_I4              = 3,   /* [V][T][P]  4 byte signed int           */
    VT_R4              = 4,   /* [V][T][P]  4 byte real                 */
    VT_R8              = 5,   /* [V][T][P]  8 byte real                 */
    VT_CY              = 6,   /* [V][T][P]  currency                    */
    VT_DATE            = 7,   /* [V][T][P]  date                        */
    VT_BSTR            = 8,   /* [V][T][P]  binary string               */
    VT_DISPATCH        = 9,   /* [V][T]     IDispatch FAR*              */
    VT_ERROR           = 10,  /* [V][T]     SCODE                       */
    VT_BOOL            = 11,  /* [V][T][P]  True=-1, False=0            */
    VT_VARIANT         = 12,  /* [V][T][P]  VARIANT FAR*                */
    VT_UNKNOWN         = 13,  /* [V][T]     IUnknown FAR*               */

    VT_I1              = 16,  /*    [T]     signed char                 */
    VT_UI1             = 17,  /*    [T]     unsigned char               */
    VT_UI2             = 18,  /*    [T]     unsigned short              */
    VT_UI4             = 19,  /*    [T]     unsigned short              */
    VT_I8              = 20,  /*    [T][P]  signed 64-bit int           */
    VT_UI8             = 21,  /*    [T]     unsigned 64-bit int         */
    VT_INT             = 22,  /*    [T]     signed machine int          */
    VT_UINT            = 23,  /*    [T]     unsigned machine int        */
    VT_VOID            = 24,  /*    [T]     C style void                */
    VT_HRESULT         = 25,  /*    [T]                                 */
    VT_PTR             = 26,  /*    [T]     pointer type                */
    VT_SAFEARRAY       = 27,  /*    [T]     (use VT_ARRAY in VARIANT)   */
    VT_CARRAY          = 28,  /*    [T]     C style array               */
    VT_USERDEFINED     = 29,  /*    [T]     user defined type	        */
    VT_LPSTR           = 30,  /*    [T][P]  null terminated string      */
    VT_LPWSTR          = 31,  /*    [T][P]  wide null terminated string */

    VT_FILETIME        = 64,  /*       [P]  FILETIME                    */
    VT_BLOB            = 65,  /*       [P]  Length prefixed bytes       */
    VT_STREAM          = 66,  /*       [P]  Name of the stream follows  */
    VT_STORAGE         = 67,  /*       [P]  Name of the storage follows */
    VT_STREAMED_OBJECT = 68,  /*       [P]  Stream contains an object   */
    VT_STORED_OBJECT   = 69,  /*       [P]  Storage contains an object  */
    VT_BLOB_OBJECT     = 70,  /*       [P]  Blob contains an object     */
    VT_CF              = 71,  /*       [P]  Clipboard format            */
    VT_CLSID           = 72   /*       [P]  A Class ID                  */
};

#define VT_VECTOR      0x1000 /*       [P]  simple counted array        */
#define VT_ARRAY       0x2000 /* [V]        SAFEARRAY*                  */
#define VT_BYREF       0x4000 /* [V]                                    */
#define VT_RESERVED    0x8000


typedef unsigned short VARTYPE;

typedef struct FARSTRUCT tagVARIANT VARIANT;
typedef struct FARSTRUCT tagVARIANT FAR* LPVARIANT;
typedef struct FARSTRUCT tagVARIANT VARIANTARG;
typedef struct FARSTRUCT tagVARIANT FAR* LPVARIANTARG;

struct FARSTRUCT tagVARIANT{
    VARTYPE vt;
    unsigned short wReserved1;
    unsigned short wReserved2;
    unsigned short wReserved3;
    union {
      short	   iVal;             /* VT_I2                */
      long	   lVal;             /* VT_I4                */
      float	   fltVal;           /* VT_R4                */
      double	   dblVal;           /* VT_R8                */
      VARIANT_BOOL bool;             /* VT_BOOL              */
      SCODE	   scode;            /* VT_ERROR             */
      CY	   cyVal;            /* VT_CY                */
      DATE	   date;             /* VT_DATE              */
      BSTR	   bstrVal;          /* VT_BSTR              */
      IUnknown	   FAR* punkVal;     /* VT_UNKNOWN           */
      IDispatch	   FAR* pdispVal;    /* VT_DISPATCH          */
      SAFEARRAY	   FAR* parray;	     /* VT_ARRAY|*           */

      short	   FAR* piVal;       /* VT_BYREF|VT_I2	     */
      long	   FAR* plVal;       /* VT_BYREF|VT_I4	     */
      float	   FAR* pfltVal;     /* VT_BYREF|VT_R4       */
      double	   FAR* pdblVal;     /* VT_BYREF|VT_R8       */
      VARIANT_BOOL FAR* pbool;       /* VT_BYREF|VT_BOOL     */
      SCODE	   FAR* pscode;      /* VT_BYREF|VT_ERROR    */
      CY	   FAR* pcyVal;      /* VT_BYREF|VT_CY       */
      DATE	   FAR* pdate;       /* VT_BYREF|VT_DATE     */
      BSTR	   FAR* pbstrVal;    /* VT_BYREF|VT_BSTR     */
      IUnknown  FAR* FAR* ppunkVal;  /* VT_BYREF|VT_UNKNOWN  */
      IDispatch FAR* FAR* ppdispVal; /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY FAR* FAR* pparray;   /* VT_BYREF|VT_ARRAY|*  */
      VARIANT	   FAR* pvarVal;     /* VT_BYREF|VT_VARIANT  */

      void	   FAR* byref;	     /* Generic ByRef        */
    }
#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
    u
#endif
    ;
};

#if defined(NONAMELESSUNION) || (defined(_MAC) && !defined(__cplusplus) && !defined(_MSC_VER))
# define V_UNION(X, Y) ((X)->u.Y)
#else
# define V_UNION(X, Y) ((X)->Y)
#endif

/* Variant access macros */
#define V_VT(X)          ((X)->vt)
#define V_ISBYREF(X)     (V_VT(X)&VT_BYREF)
#define V_ISARRAY(X)     (V_VT(X)&VT_ARRAY)
#define V_ISVECTOR(X)    (V_VT(X)&VT_VECTOR)

#define V_NONE(X)        V_I2(X)
#define V_I2(X)	         V_UNION(X, iVal)
#define V_I2REF(X)       V_UNION(X, piVal)
#define V_I4(X)          V_UNION(X, lVal)
#define V_I4REF(X)       V_UNION(X, plVal)
#define V_R4(X)	         V_UNION(X, fltVal)
#define V_R4REF(X)       V_UNION(X, pfltVal)
#define V_R8(X)	         V_UNION(X, dblVal)
#define V_R8REF(X)       V_UNION(X, pdblVal)
#define V_BOOL(X)        V_UNION(X, bool)
#define V_BOOLREF(X)     V_UNION(X, pbool)
#define V_ERROR(X)       V_UNION(X, scode)
#define V_ERRORREF(X)    V_UNION(X, pscode)
#define V_CY(X)	         V_UNION(X, cyVal)
#define V_CYREF(X)       V_UNION(X, pcyVal)
#define V_DATE(X)        V_UNION(X, date)
#define V_DATEREF(X)     V_UNION(X, pdate)
#define V_BSTR(X)        V_UNION(X, bstrVal)
#define V_BSTRREF(X)     V_UNION(X, pbstrVal)
#define V_UNKNOWN(X)     V_UNION(X, punkVal)
#define V_UNKNOWNREF(X)  V_UNION(X, ppunkVal)
#define V_DISPATCH(X)    V_UNION(X, pdispVal)
#define V_DISPATCHREF(X) V_UNION(X, ppdispVal)
#define V_VARIANTREF(X)  V_UNION(X, pvarVal)
#define V_ARRAY(X)       V_UNION(X, parray)
#define V_ARRAYREF(X)    V_UNION(X, pparray)
#define V_BYREF(X)       V_UNION(X, byref)

#endif /* _VARIANT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\wfext.h ===
/*****************************************************************************\
*                                                                             *
* wfext.h -     Windows File Manager Extensions definitions		      *
*                                                                             *
*               Version 3.10                                                  *                   *
*                                                                             *
*               Copyright (c) 1991-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************/

#ifndef _INC_WFEXT
#define _INC_WFEXT    /* #defined if wfext.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#define MENU_TEXT_LEN		40

#define FMMENU_FIRST		1
#define FMMENU_LAST		99

#define FMEVENT_LOAD		100
#define FMEVENT_UNLOAD		101
#define FMEVENT_INITMENU	102
#define FMEVENT_USER_REFRESH	103
#define FMEVENT_SELCHANGE	104

#define FMFOCUS_DIR		1
#define FMFOCUS_TREE		2
#define FMFOCUS_DRIVES		3
#define FMFOCUS_SEARCH		4

#define FM_GETFOCUS		(WM_USER + 0x0200)
#define FM_GETDRIVEINFO		(WM_USER + 0x0201)
#define FM_GETSELCOUNT		(WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN	(WM_USER + 0x0203)	/* LFN versions are odd */
#define FM_GETFILESEL		(WM_USER + 0x0204)
#define FM_GETFILESELLFN	(WM_USER + 0x0205)	/* LFN versions are odd */
#define FM_REFRESH_WINDOWS	(WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS	(WM_USER + 0x0207)

typedef struct tagFMS_GETFILESEL
{
        UINT wTime;
        UINT wDate;
	DWORD dwSize;
	BYTE bAttr;
        char szName[260];               /* always fully qualified */
} FMS_GETFILESEL, FAR *LPFMS_GETFILESEL;

typedef struct tagFMS_GETDRIVEINFO       /* for drive */
{
	DWORD dwTotalSpace;
	DWORD dwFreeSpace;
	char szPath[260];		/* current directory */
	char szVolume[14];		/* volume label */
	char szShare[128];		/* if this is a net drive */
} FMS_GETDRIVEINFO, FAR *LPFMS_GETDRIVEINFO;

typedef struct tagFMS_LOAD
{
	DWORD dwSize;				/* for version checks */
	char  szMenuName[MENU_TEXT_LEN];	/* output */
	HMENU hMenu;				/* output */
        UINT  wMenuDelta;                       /* input */
} FMS_LOAD, FAR *LPFMS_LOAD;

typedef DWORD (CALLBACK *FM_EXT_PROC)(HWND, UINT, LONG);
typedef DWORD (CALLBACK *FM_UNDELETE_PROC)(HWND, LPSTR);

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WFEXT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\vmemory.h ===
/***
* vmemory.h - Virtual Memory (VM) Management Routines
*
*	Copyright (c) 1989-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This include file provides prototypes and definitions for
*	the virtual memory management routines.
*
*******************************************************************************/

#ifndef _INC_VMEMORY

#if (_MSC_VER <= 600)
#define __far       _far
#define __pascal    _pascal
#endif

/* virtual memory handle type */
typedef unsigned long _vmhnd_t;

/* null handle value */
#define _VM_NULL	((_vmhnd_t) 0)

/* use all available DOS memory for virtual heap */
#define _VM_ALLDOS	0

/* swap areas */
#define _VM_EMS 	1
#define _VM_XMS 	2
#define _VM_DISK	4
#define _VM_ALLSWAP	(_VM_EMS | _VM_XMS | _VM_DISK)

/* clean/dirty flags */
#define _VM_CLEAN	0
#define _VM_DIRTY	1

/* function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

void __far __pascal _vfree(_vmhnd_t);
int __far __pascal _vheapinit(unsigned int, unsigned int, unsigned int);
void __far __pascal _vheapterm(void);
void __far * __far __pascal _vload(_vmhnd_t, int);
void __far * __far __pascal _vlock(_vmhnd_t);
unsigned int __far __pascal _vlockcnt(_vmhnd_t);
_vmhnd_t __far __pascal _vmalloc(unsigned long);
unsigned long __far __pascal _vmsize(_vmhnd_t);
_vmhnd_t __far __pascal _vrealloc(_vmhnd_t , unsigned long);
void __far __pascal _vunlock(_vmhnd_t, int);

#ifdef __cplusplus
}
#endif

#define _INC_VMEMORY
#endif /* _INC_VMEMORY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\windows.h ===
/*****************************************************************************\
*                                                                             *
* windows.h -   Windows functions, types, and definitions                     *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************
*
* The following symbols control inclusion of various parts of this file:
*
* WINVER            Windows version number (0x030a).  To exclude
*                   definitions introduced in version 3.1 (or above)
*                   #define WINVER 0x0300 before #including <windows.h>
*
* #define:          To prevent inclusion of:
*
* NOKERNEL          KERNEL APIs and definitions
* NOGDI             GDI APIs and definitions
* NOUSER            USER APIs and definitions
* NOSOUND           Sound APIs and definitions
* NOCOMM            Comm driver APIs and definitions
* NODRIVERS         Installable driver APIs and definitions
*
* NOMINMAX          min() and max() macros
* NOLOGERROR        LogError() and related definitions
* NOPROFILER        Profiler APIs
* NOMEMMGR          Local and global memory management
* NOLFILEIO         _l* file I/O routines
* NOOPENFILE        OpenFile and related definitions
* NORESOURCE        Resource management
* NOATOM            Atom management
* NOLANGUAGE        Character test routines
* NOLSTRING         lstr* string management routines
* NODBCS            Double-byte character set routines
* NOKEYBOARDINFO    Keyboard driver routines
* NOGDICAPMASKS     GDI device capability constants
* NOCOLOR           COLOR_* color values
* NOGDIOBJ          GDI pens, brushes, fonts
* NODRAWTEXT        DrawText() and related definitions
* NOTEXTMETRIC      TEXTMETRIC and related APIs
* NOSCALABLEFONT    Truetype scalable font support
* NOBITMAP          Bitmap support
* NORASTEROPS       GDI Raster operation definitions
* NOMETAFILE        Metafile support
* NOSYSMETRICS      GetSystemMetrics() and related SM_* definitions
* NOSYSTEMPARAMSINFO SystemParametersInfo() and SPI_* definitions
* NOMSG             APIs and definitions that use MSG structure
* NOWINSTYLES       Window style definitions
* NOWINOFFSETS      Get/SetWindowWord/Long offset definitions
* NOSHOWWINDOW      ShowWindow and related definitions
* NODEFERWINDOWPOS  DeferWindowPos and related definitions
* NOVIRTUALKEYCODES VK_* virtual key codes
* NOKEYSTATES       MK_* message key state flags
* NOWH              SetWindowsHook and related WH_* definitions
* NOMENUS           Menu APIs
* NOSCROLL          Scrolling APIs and scroll bar control
* NOCLIPBOARD       Clipboard APIs and definitions
* NOICONS           IDI_* icon IDs
* NOMB              MessageBox and related definitions
* NOSYSCOMMANDS     WM_SYSCOMMAND SC_* definitions
* NOMDI             MDI support
* NOCTLMGR          Control management and controls
* NOWINMESSAGES     WM_* window messages
* NOHELP            Help support
*
\****************************************************************************/

#ifndef _INC_WINDOWS
#define _INC_WINDOWS    /* #defined if windows.h has been included */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If WINVER is not defined, assume version 3.1 */
#ifndef WINVER
#define WINVER  0x030a
#endif

#ifdef RC_INVOKED
/* Don't include definitions that RC.EXE can't parse */
#define NOATOM
#define NOGDI
#define NOGDICAPMASKS
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NORASTEROPS
#define NOSCROLL
#define NOSOUND
#define NOSYSMETRICS
#define NOTEXTMETRIC
#define NOWH
#define NODBCS
#define NOSYSTEMPARAMSINFO
#define NOCOMM
#define NOOEMRESOURCE
#endif  /* RC_INVOKED */

/* Handle OEMRESOURCE for 3.0 compatibility */
#if (WINVER < 0x030a)
#define NOOEMRESOURCE
#ifdef OEMRESOURCE
#undef NOOEMRESOURCE
#endif
#endif

/******* Common definitions and typedefs ***********************************/

#define VOID		    void

#define FAR                 _far
#define NEAR		    _near
#define PASCAL		    _pascal
#define CDECL		    _cdecl

#define WINAPI              _far _pascal
#define CALLBACK            _far _pascal

/****** Simple types & common helper macros *********************************/

typedef int		    BOOL;
#define FALSE		    0
#define TRUE		    1

typedef unsigned char	    BYTE;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;

typedef unsigned int	    UINT;

#ifdef STRICT
typedef signed long	    LONG;
#else
#define LONG long
#endif

#define LOBYTE(w)	    ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((UINT)(w) >> 8) & 0xFF))

#define LOWORD(l)           ((WORD)(DWORD)(l))
#define HIWORD(l)           ((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))

#define MAKELONG(low, high) ((LONG)(((WORD)(low)) | (((DWORD)((WORD)(high))) << 16)))

#ifndef NOMINMAX
#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif
#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif
#endif  /* NOMINMAX */

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKELPARAM(low, high)	((LPARAM)MAKELONG(low, high))
#define MAKELRESULT(low, high)	((LRESULT)MAKELONG(low, high))

/****** Common pointer types ************************************************/

#ifndef NULL
#define NULL		    0
#endif

typedef char NEAR*          PSTR;
typedef char NEAR*          NPSTR;


typedef char FAR*           LPSTR;
typedef const char FAR*     LPCSTR;

typedef BYTE NEAR*	    PBYTE;
typedef BYTE FAR*	    LPBYTE;

typedef int NEAR*	    PINT;
typedef int FAR*	    LPINT;

typedef WORD NEAR*          PWORD;
typedef WORD FAR*           LPWORD;

typedef long NEAR*	    PLONG;
typedef long FAR*	    LPLONG;

typedef DWORD NEAR*         PDWORD;
typedef DWORD FAR*          LPDWORD;

typedef void FAR*           LPVOID;

#define MAKELP(sel, off)    ((void FAR*)MAKELONG((off), (sel)))
#define SELECTOROF(lp)      HIWORD(lp)
#define OFFSETOF(lp)        LOWORD(lp)

#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)

/****** Common handle types *************************************************/

#ifdef STRICT
typedef const void NEAR*        HANDLE;
#define DECLARE_HANDLE(name)    struct name##__ { int unused; }; \
                                typedef const struct name##__ NEAR* name
#define DECLARE_HANDLE32(name)  struct name##__ { int unused; }; \
                                typedef const struct name##__ FAR* name
#else   /* STRICT */
typedef UINT                    HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name
#define DECLARE_HANDLE32(name)  typedef DWORD name
#endif  /* !STRICT */

typedef HANDLE* 	    PHANDLE;
typedef HANDLE NEAR*	    SPHANDLE;
typedef HANDLE FAR*	    LPHANDLE;

typedef HANDLE		    HGLOBAL;
typedef HANDLE		    HLOCAL;

typedef HANDLE		    GLOBALHANDLE;
typedef HANDLE		    LOCALHANDLE;

typedef UINT                ATOM;

#ifdef STRICT
typedef void (CALLBACK*     FARPROC)(void);
typedef void (NEAR PASCAL*  NEARPROC)(void);
#else
typedef int (CALLBACK*      FARPROC)();
typedef int (NEAR PASCAL*   NEARPROC)();
#endif

DECLARE_HANDLE(HSTR);

/****** KERNEL typedefs, structures, and functions **************************/

DECLARE_HANDLE(HINSTANCE);
typedef HINSTANCE HMODULE;  /* HMODULEs can be used in place of HINSTANCEs */

#ifndef NOKERNEL

/****** Application entry point function ************************************/

#ifdef STRICT
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
#endif

/****** System Information **************************************************/

DWORD   WINAPI GetVersion(void);

DWORD   WINAPI GetFreeSpace(UINT);
UINT    WINAPI GetCurrentPDB(void);

UINT    WINAPI GetWindowsDirectory(LPSTR, UINT);
UINT    WINAPI GetSystemDirectory(LPSTR, UINT);

#if (WINVER >= 0x030a)
UINT    WINAPI GetFreeSystemResources(UINT);
#define GFSR_SYSTEMRESOURCES   0x0000
#define GFSR_GDIRESOURCES      0x0001
#define GFSR_USERRESOURCES     0x0002
#endif  /* WINVER >= 0x030a */

DWORD   WINAPI GetWinFlags(void);

#define WF_PMODE	0x0001
#define WF_CPU286	0x0002
#define WF_CPU386	0x0004
#define WF_CPU486	0x0008
#define WF_STANDARD	0x0010
#define WF_WIN286	0x0010
#define WF_ENHANCED	0x0020
#define WF_WIN386	0x0020
#define WF_CPU086	0x0040
#define WF_CPU186	0x0080
#define WF_LARGEFRAME	0x0100
#define WF_SMALLFRAME	0x0200
#define WF_80x87	0x0400
#define WF_PAGING	0x0800
#define WF_WLO          0x8000

LPSTR   WINAPI GetDOSEnvironment(void);

DWORD   WINAPI GetCurrentTime(void);
DWORD   WINAPI GetTickCount(void);
DWORD   WINAPI GetTimerResolution(void);

/****** Error handling ******************************************************/

#if (WINVER >= 0x030a)
#ifndef NOLOGERROR

void    WINAPI LogError(UINT err, void FAR* lpInfo);
void    WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);

/****** LogParamError/LogError values */

/* Error modifier bits */

#define ERR_WARNING		0x8000
#define ERR_PARAM		0x4000

#define ERR_SIZE_MASK		0x3000
#define ERR_BYTE                0x1000
#define ERR_WORD                0x2000
#define ERR_DWORD               0x3000

/****** LogParamError() values */

/* Generic parameter values */
#define ERR_BAD_VALUE           0x6001
#define ERR_BAD_FLAGS           0x6002
#define ERR_BAD_INDEX           0x6003
#define ERR_BAD_DVALUE		0x7004
#define ERR_BAD_DFLAGS		0x7005
#define ERR_BAD_DINDEX		0x7006
#define ERR_BAD_PTR		0x7007
#define ERR_BAD_FUNC_PTR	0x7008
#define ERR_BAD_SELECTOR        0x6009
#define ERR_BAD_STRING_PTR	0x700a
#define ERR_BAD_HANDLE          0x600b

/* KERNEL parameter errors */
#define ERR_BAD_HINSTANCE       0x6020
#define ERR_BAD_HMODULE         0x6021
#define ERR_BAD_GLOBAL_HANDLE   0x6022
#define ERR_BAD_LOCAL_HANDLE    0x6023
#define ERR_BAD_ATOM            0x6024
#define ERR_BAD_HFILE           0x6025

/* USER parameter errors */
#define ERR_BAD_HWND            0x6040
#define ERR_BAD_HMENU           0x6041
#define ERR_BAD_HCURSOR         0x6042
#define ERR_BAD_HICON           0x6043
#define ERR_BAD_HDWP            0x6044
#define ERR_BAD_CID             0x6045
#define ERR_BAD_HDRVR           0x6046

/* GDI parameter errors */
#define ERR_BAD_COORDS		0x7060
#define ERR_BAD_GDI_OBJECT      0x6061
#define ERR_BAD_HDC             0x6062
#define ERR_BAD_HPEN            0x6063
#define ERR_BAD_HFONT           0x6064
#define ERR_BAD_HBRUSH          0x6065
#define ERR_BAD_HBITMAP         0x6066
#define ERR_BAD_HRGN            0x6067
#define ERR_BAD_HPALETTE        0x6068
#define ERR_BAD_HMETAFILE       0x6069


/**** LogError() values */

/* KERNEL errors */
#define ERR_GALLOC              0x0001
#define ERR_GREALLOC            0x0002
#define ERR_GLOCK               0x0003
#define ERR_LALLOC              0x0004
#define ERR_LREALLOC            0x0005
#define ERR_LLOCK               0x0006
#define ERR_ALLOCRES            0x0007
#define ERR_LOCKRES             0x0008
#define ERR_LOADMODULE          0x0009

/* USER errors */
#define ERR_CREATEDLG           0x0040
#define ERR_CREATEDLG2          0x0041
#define ERR_REGISTERCLASS       0x0042
#define ERR_DCBUSY              0x0043
#define ERR_CREATEWND           0x0044
#define ERR_STRUCEXTRA          0x0045
#define ERR_LOADSTR             0x0046
#define ERR_LOADMENU            0x0047
#define ERR_NESTEDBEGINPAINT    0x0048
#define ERR_BADINDEX            0x0049
#define ERR_CREATEMENU          0x004a

/* GDI errors */
#define ERR_CREATEDC            0x0080
#define ERR_CREATEMETA          0x0081
#define ERR_DELOBJSELECTED      0x0082
#define ERR_SELBITMAP           0x0083

/* Debugging support (DEBUG SYSTEM ONLY) */
typedef struct tagWINDEBUGINFO
{
    UINT    flags;
    DWORD   dwOptions;
    DWORD   dwFilter;
    char    achAllocModule[8];
    DWORD   dwAllocBreak;
    DWORD   dwAllocCount;
} WINDEBUGINFO;

BOOL    WINAPI GetWinDebugInfo(WINDEBUGINFO FAR* lpwdi, UINT flags);
BOOL    WINAPI SetWinDebugInfo(const WINDEBUGINFO FAR* lpwdi);

void    FAR _cdecl DebugOutput(UINT flags, LPCSTR lpsz, ...);

/* WINDEBUGINFO flags values */
#define WDI_OPTIONS         0x0001
#define WDI_FILTER          0x0002
#define WDI_ALLOCBREAK      0x0004

/* dwOptions values */
#define DBO_CHECKHEAP       0x0001
#define DBO_BUFFERFILL      0x0004
#define DBO_DISABLEGPTRAPPING 0x0010
#define DBO_CHECKFREE       0x0020

#define DBO_SILENT          0x8000

#define DBO_TRACEBREAK      0x2000
#define DBO_WARNINGBREAK    0x1000
#define DBO_NOERRORBREAK    0x0800
#define DBO_NOFATALBREAK    0x0400
#define DBO_INT3BREAK       0x0100

/* DebugOutput flags values */
#define DBF_TRACE           0x0000
#define DBF_WARNING         0x4000
#define DBF_ERROR           0x8000
#define DBF_FATAL           0xc000

/* dwFilter values */
#define DBF_KERNEL          0x1000
#define DBF_KRN_MEMMAN      0x0001
#define DBF_KRN_LOADMODULE  0x0002
#define DBF_KRN_SEGMENTLOAD 0x0004
#define DBF_USER            0x0800
#define DBF_GDI             0x0400
#define DBF_MMSYSTEM        0x0040
#define DBF_PENWIN          0x0020
#define DBF_APPLICATION     0x0008
#define DBF_DRIVER          0x0010

#endif  /* NOLOGERROR */
#endif  /* WINVER >= 0x030a */

void    WINAPI FatalExit(int);
void    WINAPI FatalAppExit(UINT, LPCSTR);

BOOL    WINAPI ExitWindows(DWORD dwReturnCode, UINT wReserved);

#define EW_RESTARTWINDOWS 0x42
#if (WINVER >= 0x030a)
#define EW_REBOOTSYSTEM   0x43

BOOL    WINAPI ExitWindowsExec(LPCSTR, LPCSTR);
#endif  /* WINVER >= 0x030a */

void    WINAPI DebugBreak(void);
void    WINAPI OutputDebugString(LPCSTR);

/* SetErrorMode() constants */
#define SEM_FAILCRITICALERRORS  0x0001
#define SEM_NOGPFAULTERRORBOX   0x0002
#define SEM_NOOPENFILEERRORBOX  0x8000

UINT    WINAPI SetErrorMode(UINT);

/****** Pointer validation **************************************************/

#if (WINVER >= 0x030a)

BOOL    WINAPI IsBadReadPtr(const void FAR* lp, UINT cb);
BOOL    WINAPI IsBadWritePtr(void FAR* lp, UINT cb);
BOOL    WINAPI IsBadHugeReadPtr(const void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadHugeWritePtr(void _huge* lp, DWORD cb);
BOOL    WINAPI IsBadCodePtr(FARPROC lpfn);
BOOL    WINAPI IsBadStringPtr(const void FAR* lpsz, UINT cchMax);
#endif  /* WINVER >= 0x030a */

/****** Profiling support ***************************************************/

#ifndef NOPROFILER

int     WINAPI ProfInsChk(void);
void    WINAPI ProfSetup(int,int);
void    WINAPI ProfSampRate(int,int);
void    WINAPI ProfStart(void);
void    WINAPI ProfStop(void);
void    WINAPI ProfClear(void);
void    WINAPI ProfFlush(void);
void    WINAPI ProfFinish(void);
#endif  /* NOPROFILER */

/****** Catch/Throw and stack management ************************************/

typedef int CATCHBUF[9];
typedef int FAR* LPCATCHBUF;

int     WINAPI Catch(int FAR*);
void    WINAPI Throw(const int FAR*, int);

void    WINAPI SwitchStackBack(void);
void    WINAPI SwitchStackTo(UINT, UINT, UINT);

/****** Module Management ***************************************************/

#define HINSTANCE_ERROR ((HINSTANCE)32)


HINSTANCE   WINAPI LoadModule(LPCSTR, LPVOID);
BOOL        WINAPI FreeModule(HINSTANCE);

HINSTANCE   WINAPI LoadLibrary(LPCSTR);
void        WINAPI FreeLibrary(HINSTANCE);

UINT    WINAPI WinExec(LPCSTR, UINT);

HMODULE WINAPI GetModuleHandle(LPCSTR);

int     WINAPI GetModuleUsage(HINSTANCE);
int     WINAPI GetModuleFileName(HINSTANCE, LPSTR, int);

FARPROC WINAPI GetProcAddress(HINSTANCE, LPCSTR);

int     WINAPI GetInstanceData(HINSTANCE, BYTE*, int);

HGLOBAL WINAPI GetCodeHandle(FARPROC);

typedef struct tagSEGINFO
{
    UINT offSegment;
    UINT cbSegment;
    UINT flags;
    UINT cbAlloc;
    HGLOBAL h;
    UINT alignShift;
    UINT reserved[2];
} SEGINFO;
typedef SEGINFO FAR* LPSEGINFO;

void    WINAPI GetCodeInfo(FARPROC lpProc, SEGINFO FAR* lpSegInfo);

FARPROC WINAPI MakeProcInstance(FARPROC, HINSTANCE);
void    WINAPI FreeProcInstance(FARPROC);

LONG    WINAPI SetSwapAreaSize(UINT);
void    WINAPI SwapRecording(UINT);
void    WINAPI ValidateCodeSegments(void);

/* Windows Exit Procedure flag values */
#define	WEP_SYSTEM_EXIT	1
#define	WEP_FREE_DLL	0

/****** Task Management *****************************************************/

#endif	/* NOKERNEL */

DECLARE_HANDLE(HTASK);

#ifndef NOKERNEL

UINT    WINAPI GetNumTasks(void);

#if (WINVER >= 0x030a)
BOOL    WINAPI IsTask(HTASK);
#endif  /* WINVER >= 0x030a */

HTASK   WINAPI GetCurrentTask(void);

void    WINAPI Yield(void);
void    WINAPI DirectedYield(HTASK);


/****** Global memory management ********************************************/

#ifndef NOMEMMGR

/* Global Memory Flags */

#define GMEM_FIXED	    0x0000
#define GMEM_MOVEABLE	    0x0002
#define GMEM_NOCOMPACT	    0x0010
#define GMEM_NODISCARD	    0x0020
#define GMEM_ZEROINIT	    0x0040
#define GMEM_MODIFY	    0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE	    0x2000
#define GMEM_DDESHARE	    0x2000
#define GMEM_NOTIFY	    0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#define GHND		    (GMEM_MOVEABLE | GMEM_ZEROINIT)
#define GPTR		    (GMEM_FIXED | GMEM_ZEROINIT)

#define GlobalDiscard(h)    GlobalReAlloc(h, 0L, GMEM_MOVEABLE)

HGLOBAL WINAPI GlobalAlloc(UINT, DWORD);
HGLOBAL WINAPI GlobalReAlloc(HGLOBAL, DWORD, UINT);
HGLOBAL WINAPI GlobalFree(HGLOBAL);

DWORD   WINAPI GlobalDosAlloc(DWORD);
UINT    WINAPI GlobalDosFree(UINT);

#ifdef STRICT
void FAR* WINAPI GlobalLock(HGLOBAL);
#else
char FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND		    (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		    (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND	    (LMEM_MOVEABLE)
#define NONZEROLPTR	    (LMEM_FIXED)


#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ 	    0x0000
#define OF_WRITE	    0x0001
#define OF_READWRITE	    0x0002
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	    0x0100
#define OF_DELETE	    0x0200
#define OF_VERIFY	    0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH	    0x0400	/* Used without OF_REOPEN */
#define OF_CANCEL	    0x0800
#define OF_CREATE	    0x1000
#define OF_PROMPT	    0x2000
#define OF_EXIST	    0x4000
#define OF_REOPEN	    0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ	    0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long	WINAPI _hread(HFILE, void _huge*, long);
long	WINAPI _hwrite(HFILE, const void _huge*, long);
#endif	/* WINVER >= 0x030a */


#endif	/* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE	    (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection errors */
#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)	    GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR	    MAKEINTRESOURCE(1)
#define RT_BITMAP	    MAKEINTRESOURCE(2)
#define RT_ICON 	    MAKEINTRESOURCE(3)
#define RT_MENU 	    MAKEINTRESOURCE(4)
#define RT_DIALOG	    MAKEINTRESOURCE(5)
#define RT_STRING	    MAKEINTRESOURCE(6)
#define RT_FONTDIR	    MAKEINTRESOURCE(7)
#define RT_FONT 	    MAKEINTRESOURCE(8)
#define RT_ACCELERATOR	    MAKEINTRESOURCE(9)
#define RT_RCDATA	    MAKEINTRESOURCE(10)

#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON	    MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE	    32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI	    32737
#define OBM_DNARROWI	    32736
#define OBM_RGARROWI	    32735
#define OBM_LFARROWI	    32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL	    32512
#define OCR_IBEAM	    32513
#define OCR_WAIT	    32514
#define OCR_CROSS	    32515
#define OCR_UP		    32516
#define OCR_SIZE	    32640
#define OCR_ICON	    32641
#define OCR_SIZENWSE	    32642
#define OCR_SIZENESW	    32643
#define OCR_SIZEWE	    32644
#define OCR_SIZENS	    32645
#define OCR_SIZEALL	    32646
#define OCR_ICOCUR	    32647

#define OIC_SAMPLE	    32512
#define OIC_HAND	    32513
#define OIC_QUES	    32514
#define OIC_BANG	    32515
#define OIC_NOTE	    32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE	    0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);


#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif	/* WINVER >= 0x030a */
#endif	/* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif	/* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef	NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif	/* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)	    (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY	DCB_ACCUMULATE
#define DCB_SET 	(DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);


/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR		   0
#define COLOR_BACKGROUND	   1
#define COLOR_ACTIVECAPTION	   2
#define COLOR_INACTIVECAPTION	   3
#define COLOR_MENU		   4
#define COLOR_WINDOW		   5
#define COLOR_WINDOWFRAME	   6
#define COLOR_MENUTEXT		   7
#define COLOR_WINDOWTEXT	   8
#define COLOR_CAPTIONTEXT  	   9
#define COLOR_ACTIVEBORDER	  10
#define COLOR_INACTIVEBORDER	  11
#define COLOR_APPWORKSPACE	  12
#define COLOR_HIGHLIGHT		  13
#define COLOR_HIGHLIGHTTEXT	  14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT		  18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN 	    1
#define OBJ_BRUSH	    2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID	    0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL 	    5
#define PS_INSIDEFRAME 	    6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4
#define	BS_DIBPATTERN	    5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH	    PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif	/* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR		    0
#define NULLREGION	    1
#define SIMPLEREGION	    2
#define COMPLEXREGION	    3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND 	    1
#define RGN_OR		    2
#define RGN_XOR 	    3
#define RGN_DIFF	    4
#define RGN_COPY	    5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED	0x01	/* palette index used for animation */
#define PC_EXPLICIT	0x02	/* palette index is explicit to device */
#define	PC_NOCOLLAPSE	0x04	/* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define	SYSPAL_STATIC	1
#define	SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);


/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);


/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED	0x0001
#define ETO_OPAQUE	0x0002
#define ETO_CLIPPED	0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP		    0x0000
#define DT_LEFT 	    0x0000
#define DT_CENTER	    0x0001
#define DT_RIGHT	    0x0002
#define DT_VCENTER	    0x0004
#define DT_BOTTOM	    0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE	    0x0020
#define DT_EXPANDTABS	    0x0040
#define DT_TABSTOP	    0x0080
#define DT_NOCLIP	    0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT	    0x0400
#define DT_NOPREFIX	    0x0800
#define DT_INTERNAL	    0x1000

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP		     0x0000
#define TA_UPDATECP		     0x0001
#define TA_LEFT 		     0x0000
#define TA_RIGHT		     0x0002
#define TA_CENTER		     0x0006
#define TA_TOP			     0x0000
#define TA_BOTTOM		     0x0008
#define TA_BASELINE		     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE	    32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE	    0
#define FW_THIN 	    100
#define FW_EXTRALIGHT	    200
#define FW_LIGHT	    300
#define FW_NORMAL	    400
#define FW_MEDIUM	    500
#define FW_SEMIBOLD	    600
#define FW_BOLD 	    700
#define FW_EXTRABOLD	    800
#define FW_HEAVY	    900

#define FW_ULTRALIGHT	    FW_EXTRALIGHT
#define FW_REGULAR	    FW_NORMAL
#define FW_DEMIBOLD	    FW_SEMIBOLD
#define FW_ULTRABOLD	    FW_EXTRABOLD
#define FW_BLACK	    FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET	    0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET	    2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET	    255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS		4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK		0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES		0x10
#define CLIP_TT_ALWAYS		0x20
#define CLIP_EMBEDDED		0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT	    10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT	    12
#define SYSTEM_FONT	    13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING	     0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE	    0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif	/* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR	    0x02
#define TMPF_DEVICE	    0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE	    0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR	0x00000040L
#define NTM_BOLD	0x00000020L
#define NTM_ITALIC	0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL	WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE	0x0001
#define TT_ENABLED	0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD	     bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE	     bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;


HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif	/* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif	/* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0410
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F

#define	META_CHORD		     0x0830
#define	META_SETMAPPERFLAGS	     0x0231
#define	META_EXTTEXTOUT		     0x0a32
#define	META_SETDIBTODEV	     0x0d33
#define	META_SELECTPALETTE	     0x0234
#define	META_REALIZEPALETTE	     0x0035
#define	META_ANIMATEPALETTE	     0x0436
#define	META_SETPALENTRIES	     0x0037
#define	META_POLYPOLYGON	     0x0538
#define	META_RESIZEPALETTE	     0x0139

#define	META_DIBBITBLT		     0x0940
#define	META_DIBSTRETCHBLT	     0x0b41
#define	META_DIBCREATEPATTERNBRUSH   0x0142
#define	META_STRETCHDIB		     0x0f43

#define META_EXTFLOODFILL	     0x0548

#define META_RESETDC		     0x014C
#define META_STARTDOC		     0x014D
#define META_STARTPAGE		     0x004F
#define META_ENDPAGE		     0x0050
#define META_ABORTDOC		     0x0052
#define META_ENDDOC		     0x005E

#define	META_DELETEOBJECT	     0x01f0

#define	META_CREATEPALETTE	     0x00f7
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED		     0x4000
#define SP_ERROR		     (-1)
#define SP_APPABORT		     (-2)
#define SP_USERABORT		     (-3)
#define SP_OUTOFDISK		     (-4)
#define SP_OUTOFMEMORY		     (-5)

#define PR_JOBSTATUS		     0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS	    0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETABORTPROC		     9
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define MOUSETRAILS		     39

#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;	    /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	     0
#define SM_CYSCREEN	     1
#define SM_CXVSCROLL	     2
#define SM_CYHSCROLL	     3
#define SM_CYCAPTION	     4
#define SM_CXBORDER	     5
#define SM_CYBORDER	     6
#define SM_CXDLGFRAME	     7
#define SM_CYDLGFRAME	     8
#define SM_CYVTHUMB	     9
#define SM_CXHTHUMB	     10
#define SM_CXICON	     11
#define SM_CYICON	     12
#define SM_CXCURSOR	     13
#define SM_CYCURSOR	     14
#define SM_CYMENU	     15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL	     20
#define SM_CXHSCROLL	     21
#define SM_DEBUG	     22
#define SM_SWAPBUTTON	     23
#define SM_RESERVED1	     24
#define SM_RESERVED2	     25
#define SM_RESERVED3	     26
#define SM_RESERVED4	     27
#define SM_CXMIN	     28
#define SM_CYMIN	     29
#define SM_CXSIZE	     30
#define SM_CYSIZE	     31
#define SM_CXFRAME	     32
#define SM_CYFRAME	     33
#define SM_CXMINTRACK	     34
#define SM_CYMINTRACK	     35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_CMETRICS	     43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE	    0x001E

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP		    1
#define SPI_SETBEEP		    2
#define SPI_GETMOUSE		    3
#define SPI_SETMOUSE		    4
#define SPI_GETBORDER		    5
#define SPI_SETBORDER		    6
#define SPI_GETKEYBOARDSPEED	    10
#define SPI_SETKEYBOARDSPEED	    11
#define SPI_LANGDRIVER		    12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY	    18
#define SPI_SETGRIDGRANULARITY	    19
#define SPI_SETDESKWALLPAPER	    20
#define SPI_SETDESKPATTERN	    21
#define SPI_GETKEYBOARDDELAY	    22
#define SPI_SETKEYBOARDDELAY	    23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP	    25
#define SPI_SETICONTITLEWRAP	    26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH	    29
#define SPI_SETDOUBLECLKHEIGHT	    30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME	    32
#define SPI_SETMOUSEBUTTONSWAP	    33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE	    0x0001
#define SPIF_SENDWININICHANGE	    0x0002

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL		    0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER		    0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND	hwnd;
    UINT        message;
    WPARAM	wParam;
    LPARAM	lParam;
    DWORD       time;
    POINT	pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE	0x0000
#define PM_REMOVE	0x0001
#define PM_NOYIELD	0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY		0x0001
#define QS_MOUSEMOVE	0x0002
#define QS_MOUSEBUTTON	0x0004
#define QS_MOUSE	(QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE	0x0008
#define QS_TIMER	0x0010
#define QS_PAINT	0x0020
#define QS_SENDMESSAGE	0x0040

#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST	((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE	    3

#define WH_CALLWNDPROC	    4

#define WH_MSGFILTER	    (-1)
#define WH_SYSMSGFILTER	    6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX		 0
#define MSGF_MENU		 2
#define MSGF_MOVE		 3
#define MSGF_SIZE		 4
#define MSGF_SCROLLBAR		 5
#define MSGF_NEXTWINDOW 	 6
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST	    0x0380
#define WM_PENWINLAST	    0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F


#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER	    0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION	    0x0016

#define WM_QUIT		    0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR	    0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC	lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE	hInstance;
    HICON	hIcon;
    HCURSOR	hCursor;
    HBRUSH	hbrBackground;
    LPCSTR	lpszMenuName;
    LPCSTR	lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW	    0x0001
#define CS_HREDRAW	    0x0002

#define CS_OWNDC	    0x0020
#define CS_CLASSDC	    0x0040
#define CS_PARENTDC	    0x0080

#define CS_SAVEBITS	    0x0800

#define CS_DBLCLKS	    0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE	    0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT	    0x0100

#define CS_GLOBALCLASS	    0x4000
#endif	/* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME	    (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR	    (-12)
#define GCW_HICON	    (-14)
#define GCW_HMODULE	    (-16)
#define GCW_CBWNDEXTRA	    (-18)
#define GCW_CBCLSEXTRA	    (-20)
#define GCL_WNDPROC	    (-24)
#define GCW_STYLE	    (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif	/* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED	    0x00000000L
#define WS_POPUP	    0x80000000L
#define WS_CHILD	    0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE	    0x10000000L
#define WS_DISABLED	    0x08000000L

/* Main window states */
#define WS_MINIMIZE	    0x20000000L
#define WS_MAXIMIZE	    0x01000000L

/* Main window styles */
#define WS_CAPTION	    0x00C00000L     /* WS_BORDER | WS_DLGFRAME	*/
#define WS_BORDER	    0x00800000L
#define WS_DLGFRAME	    0x00400000L
#define WS_VSCROLL	    0x00200000L
#define WS_HSCROLL	    0x00100000L
#define WS_SYSMENU	    0x00080000L
#define WS_THICKFRAME	    0x00040000L
#define WS_MINIMIZEBOX	    0x00020000L
#define WS_MAXIMIZEBOX	    0x00010000L

/* Control window styles */
#define WS_GROUP	    0x00020000L
#define WS_TABSTOP	    0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW	    (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	    (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST	     0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED	    WS_OVERLAPPED
#define WS_ICONIC	    WS_MINIMIZE
#define WS_SIZEBOX	    WS_THICKFRAME
#define WS_TILEDWINDOW	    WS_OVERLAPPEDWINDOW


#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE	    0x0001
#define WM_NCCREATE	    0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY	    0x0002
#define WM_NCDESTROY	    0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);


#ifndef NOSHOWWINDOW

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW	    0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW	    0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM	    SW_OTHERRESTORED
#endif	/* NOSHOWWINDOW */

#define WM_SETREDRAW	    0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE	    0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT	    0x000C
#define WM_GETTEXT	    0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	    (-4)
#define GWW_HINSTANCE	    (-6)
#define GWW_HWNDPARENT	    (-8)
#define GWW_ID		    (-12)
#define GWL_STYLE	    (-16)
#define GWL_EXSTYLE	    (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT	    ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE	    0x0001
#define SWP_NOMOVE	    0x0002
#define SWP_NOZORDER	    0x0004
#define SWP_NOREDRAW	    0x0008
#define SWP_NOACTIVATE	    0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW	    0x0040
#define SWP_HIDEWINDOW	    0x0080
#define SWP_NOCOPYBITS	    0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME	    SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM	    ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE		    0x0003
#define WM_SIZE		    0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED	    0
#define SIZE_MINIMIZED	    1
#define SIZE_MAXIMIZED	    2
#define SIZE_MAXSHOW	    3
#define SIZE_MAXHIDE	    4

/* Obsolete constant names */
#define SIZENORMAL	    SIZE_RESTORED
#define SIZEICONIC	    SIZE_MINIMIZED
#define SIZEFULLSCREEN	    SIZE_MAXIMIZED
#define SIZEZOOMSHOW	    SIZE_MAXSHOW
#define SIZEZOOMHIDE	    SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN	    0x0013
#define WM_CLOSE	    0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024


BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER	4
#define GW_CHILD	5


/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW	    0x00000001L
#define DCX_CACHE	    0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP	    0x00000020L

#define DCX_EXCLUDERGN	    0x00000040L
#define DCX_INTERSECTRGN    0x00000080L


#define DCX_LOCKWINDOWUPDATE 0x00000400L


#define DCX_USESTYLE	    0x00010000L

#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT	    0x000F
#define WM_ERASEBKGND	    0x0014
#define WM_ICONERASEBKGND   0x0027

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC 	hdc;
    BOOL	fErase;
    RECT	rcPaint;
    BOOL	fRestore;
    BOOL	fIncUpdate;
    BYTE	rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE		0x0001
#define RDW_INTERNALPAINT	0x0002
#define RDW_ERASE		0x0004

#define RDW_VALIDATE		0x0008
#define RDW_NOINTERNALPAINT	0x0010
#define RDW_NOERASE		0x0020

#define RDW_NOCHILDREN		0x0040
#define RDW_ALLCHILDREN 	0x0080

#define RDW_UPDATENOW		0x0100
#define RDW_ERASENOW		0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004


#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT	    0x0085

#define WM_NCCALCSIZE	    0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP	    0x0010
#define WVR_ALIGNLEFT	    0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT	    0x0080
#define WVR_HREDRAW	    0x0100
#define WVR_VREDRAW	    0x0200
#define WVR_REDRAW	    (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS	    0x0400


/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT	   rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST	    0x0084

/* WM_NCHITTEST return codes */
#define HTERROR 	    (-2)
#define HTTRANSPARENT	    (-1)
#define HTNOWHERE	    0
#define HTCLIENT	    1
#define HTCAPTION	    2
#define HTSYSMENU	    3
#define HTSIZE		    4
#define HTMENU		    5
#define HTHSCROLL	    6
#define HTVSCROLL	    7
#define HTMINBUTTON	    8
#define HTMAXBUTTON	    9
#define HTLEFT		    10
#define HTRIGHT 	    11
#define HTTOP		    12
#define HTTOPLEFT	    13
#define HTTOPRIGHT	    14
#define HTBOTTOM	    15
#define HTBOTTOMLEFT	    16
#define HTBOTTOMRIGHT	    17
#define HTBORDER	    18
#define HTGROWBOX	    HTSIZE
#define HTREDUCE	    HTMINBUTTON
#define HTZOOM		    HTMAXBUTTON

/****** Drag-and-drop support ***********************************************/

#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES	    0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE	    0
#define WA_ACTIVE	    1
#define WA_CLICKACTIVE	    2

#define WM_ACTIVATE	    0x0006
#define WM_ACTIVATEAPP	    0x001C
#define WM_NCACTIVATE	    0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101

#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103

#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105

#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107


/* Keyboard message range */
#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED	    0x0100
#define KF_DLGMODE	    0x0800
#define KF_MENUMODE	    0x1000
#define KF_ALTDOWN	    0x2000
#define KF_REPEAT	    0x4000
#define KF_UP		    0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON	    0x01
#define VK_RBUTTON	    0x02
#define VK_CANCEL	    0x03
#define VK_MBUTTON          0x04
#define VK_BACK 	    0x08
#define VK_TAB		    0x09
#define VK_CLEAR	    0x0C
#define VK_RETURN	    0x0D
#define VK_SHIFT	    0x10
#define VK_CONTROL	    0x11
#define VK_MENU 	    0x12
#define VK_PAUSE	    0x13
#define VK_CAPITAL	    0x14
#define VK_ESCAPE	    0x1B
#define VK_SPACE	    0x20
#define VK_PRIOR	    0x21
#define VK_NEXT 	    0x22
#define VK_END		    0x23
#define VK_HOME 	    0x24
#define VK_LEFT 	    0x25
#define VK_UP		    0x26
#define VK_RIGHT	    0x27
#define VK_DOWN 	    0x28
#define VK_SELECT	    0x29
#define VK_PRINT	    0x2A
#define VK_EXECUTE	    0x2B
#define VK_SNAPSHOT	    0x2C
#define VK_INSERT	    0x2D
#define VK_DELETE	    0x2E
#define VK_HELP 	    0x2F
#define VK_NUMPAD0	    0x60
#define VK_NUMPAD1	    0x61
#define VK_NUMPAD2	    0x62
#define VK_NUMPAD3	    0x63
#define VK_NUMPAD4	    0x64
#define VK_NUMPAD5	    0x65
#define VK_NUMPAD6	    0x66
#define VK_NUMPAD7	    0x67
#define VK_NUMPAD8	    0x68
#define VK_NUMPAD9	    0x69
#define VK_MULTIPLY	    0x6A
#define VK_ADD		    0x6B
#define VK_SEPARATOR	    0x6C
#define VK_SUBTRACT	    0x6D
#define VK_DECIMAL	    0x6E
#define VK_DIVIDE	    0x6F
#define VK_F1		    0x70
#define VK_F2		    0x71
#define VK_F3		    0x72
#define VK_F4		    0x73
#define VK_F5		    0x74
#define VK_F6		    0x75
#define VK_F7		    0x76
#define VK_F8		    0x77
#define VK_F9		    0x78
#define VK_F10		    0x79
#define VK_F11		    0x7A
#define VK_F12		    0x7B
#define VK_F13		    0x7C
#define VK_F14		    0x7D
#define VK_F15		    0x7E
#define VK_F16		    0x7F
#define VK_F17		    0x80
#define VK_F18		    0x81
#define VK_F19		    0x82
#define VK_F20		    0x83
#define VK_F21		    0x84
#define VK_F22		    0x85
#define VK_F23		    0x86
#define VK_F24		    0x87
#define VK_NUMLOCK	    0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD	    2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE	    0x0200
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON	    0x0001
#define MK_RBUTTON	    0x0002
#define MK_SHIFT	    0x0004
#define MK_CONTROL	    0x0008
#define MK_MBUTTON	    0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE	    0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP	    0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP	    0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP	    0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE	    7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif	/* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE	    0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER	    0x0113

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT	    0x0000
#define MF_CHANGE	    0x0080
#define MF_APPEND	    0x0100
#define MF_DELETE	    0x0200
#define MF_REMOVE	    0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND	    0x0000
#define MF_BYPOSITION	    0x0400

#define MF_SEPARATOR	    0x0800

#define MF_ENABLED	    0x0000
#define MF_GRAYED	    0x0001
#define MF_DISABLED	    0x0002

#define MF_UNCHECKED	    0x0000
#define MF_CHECKED	    0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING	    0x0000
#define MF_BITMAP	    0x0004
#define MF_OWNERDRAW	    0x0100

#define MF_POPUP	    0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK	    0x0040

#define MF_UNHILITE	    0x0000
#define MF_HILITE	    0x0080

#define MF_SYSMENU	    0x2000
#define MF_HELP 	    0x4000
#define MF_MOUSESELECT	    0x8000


#define MF_END		    0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT	    0x011F
#define WM_MENUCHAR	    0x0120

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND	    0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP	    0
#define SB_LINELEFT	    0
#define SB_LINEDOWN	    1
#define SB_LINERIGHT	    1
#define SB_PAGEUP	    2
#define SB_PAGELEFT	    2
#define SB_PAGEDOWN	    3
#define SB_PAGERIGHT	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_LEFT 	    6
#define SB_BOTTOM	    7
#define SB_RIGHT	    7
#define SB_ENDSCROLL	    8

/* Scroll bar selection constants */
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT 	     1
#define CF_BITMAP	     2
#define CF_METAFILEPICT      3
#define CF_SYLK 	     4
#define CF_DIF		     5
#define CF_TIFF 	     6
#define CF_OEMTEXT	     7
#define CF_DIB		     8
#define CF_PALETTE	     9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW	    MAKEINTRESOURCE(32512)
#define IDC_IBEAM	    MAKEINTRESOURCE(32513)
#define IDC_WAIT	    MAKEINTRESOURCE(32514)
#define IDC_CROSS	    MAKEINTRESOURCE(32515)
#define IDC_UPARROW	    MAKEINTRESOURCE(32516)
#define IDC_SIZE	    MAKEINTRESOURCE(32640)
#define IDC_ICON	    MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	    MAKEINTRESOURCE(32644)
#define IDC_SIZENS	    MAKEINTRESOURCE(32645)

#define WM_SETCURSOR	    0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND	    MAKEINTRESOURCE(32513)
#define IDI_QUESTION	    MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	    MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005
#define MB_TYPEMASK	    0x000F

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK	    0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200
#define MB_DEFMASK	    0x0F00

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000



#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND	0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_TASKLIST	0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM 	SC_MAXIMIZE


#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE	    0x0220
#define WM_MDIDESTROY	    0x0221
#define WM_MDIACTIVATE	    0x0222
#define WM_MDIRESTORE	    0x0223
#define WM_MDINEXT	    0x0224
#define WM_MDIMAXIMIZE	    0x0225
#define WM_MDITILE	    0x0226
#define WM_MDICASCADE	    0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU	    0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL	0x0000
#define MDITILE_HORIZONTAL	0x0001
#define MDITILE_SKIPDISABLED	0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG	(MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA	30

/* Dialog styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID	    (WM_USER+0)
#define DM_SETDEFID	    (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID	    0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG	    0x0110
#define WM_NEXTDLGCTL	    0x0028

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE	    0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT	0
#define DWL_DLGPROC	4
#define DWL_USER	8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE	    0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR	    0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT	    1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN	    3
#define CTLCOLOR_DLG	    4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6

#define WM_SETFONT          0x0030
#define WM_GETFONT	    0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK		    1
#define IDCANCEL	    2
#define IDABORT 	    3
#define IDRETRY 	    4
#define IDIGNORE	    5
#define IDYES		    6
#define IDNO		    7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU	1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

/* Owner draw actions */
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT	0x0002
#define ODA_FOCUS	0x0004

/* Owner draw state */
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS	0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND	hwndItem;
    HDC		hDC;
    RECT	rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM	    0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND	hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT 	    0x00000000L
#define SS_CENTER	    0x00000001L
#define SS_RIGHT	    0x00000002L
#define SS_ICON 	    0x00000003L
#define SS_BLACKRECT	    0x00000004L
#define SS_GRAYRECT	    0x00000005L
#define SS_WHITERECT	    0x00000006L
#define SS_BLACKFRAME	    0x00000007L
#define SS_GRAYFRAME	    0x00000008L
#define SS_WHITEFRAME	    0x00000009L
#define SS_SIMPLE	    0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON	    (WM_USER+0)
#define STM_GETICON	    (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON	    0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX	    0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON	    0x00000004L
#define BS_3STATE	    0x00000005L
#define BS_AUTO3STATE	    0x00000006L
#define BS_GROUPBOX	    0x00000007L
#define BS_USERBUTTON	    0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW	    0x0000000BL
#define BS_LEFTTEXT	    0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK	    (WM_USER+0)
#define BM_SETCHECK	    (WM_USER+1)
#define BM_GETSTATE	    (WM_USER+2)
#define BM_SETSTATE	    (WM_USER+3)
#define BM_SETSTYLE	    (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED	    0
#define BN_PAINT	    1
#define BN_HILITE	    2
#define BN_UNHILITE	    3
#define BN_DISABLE	    4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT 	    0x00000000L
#define ES_CENTER	    0x00000001L
#define ES_RIGHT	    0x00000002L
#define ES_MULTILINE	    0x00000004L
#define ES_UPPERCASE	    0x00000008L
#define ES_LOWERCASE	    0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL	    0x00000040L
#define ES_AUTOHSCROLL	    0x00000080L
#define ES_NOHIDESEL	    0x00000100L
#define ES_OEMCONVERT	    0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY	    0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL	        (WM_USER+0)
#define EM_SETSEL	        (WM_USER+1)
#define EM_GETRECT	        (WM_USER+2)
#define EM_SETRECT	        (WM_USER+3)
#define EM_SETRECTNP	        (WM_USER+4)
#define EM_LINESCROLL	        (WM_USER+6)
#define EM_GETMODIFY	        (WM_USER+8)
#define EM_SETMODIFY	        (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX	        (WM_USER+11)
#define EM_SETHANDLE	        (WM_USER+12)
#define EM_GETHANDLE	        (WM_USER+13)
#define EM_LINELENGTH	        (WM_USER+17)
#define EM_REPLACESEL	        (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE	        (WM_USER+20)
#define EM_LIMITTEXT	        (WM_USER+21)
#define EM_CANUNDO	        (WM_USER+22)
#define EM_UNDO 	        (WM_USER+23)
#define EM_FMTLINES	        (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS	        (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE	(WM_USER+30)
#define EM_SETREADONLY	        (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT		   0
#define WB_RIGHT	   1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	      0x0001L
#define LBS_SORT	      0x0002L
#define LBS_NOREDRAW	      0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD	      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	       (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL	       (WM_USER+6)
#define LB_SETCURSEL	       (WM_USER+7)
#define LB_GETSEL	       (WM_USER+8)
#define LB_GETCURSEL	       (WM_USER+9)
#define LB_GETTEXT	       (WM_USER+10)
#define LB_GETTEXTLEN	       (WM_USER+11)
#define LB_GETCOUNT	       (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR		       (WM_USER+14)
#define LB_GETTOPINDEX	       (WM_USER+15)
#define LB_FINDSTRING	       (WM_USER+16)
#define LB_GETSELCOUNT	       (WM_USER+17)
#define LB_GETSELITEMS	       (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX	       (WM_USER+24)
#define LB_GETITEMRECT	       (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE	    (-2)
#define LBN_SELCHANGE	    1
#define LBN_DBLCLK	    2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F

/* Listbox message return values */
#define LB_OKAY 	    0
#define LB_ERR		    (-1)
#define LB_ERRSPACE	    (-2)

#define LB_CTLCODE	    0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */


/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY	    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE	    0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL	         (WM_USER+0)
#define CB_LIMITTEXT	         (WM_USER+1)
#define CB_SETEDITSEL	         (WM_USER+2)
#define CB_ADDSTRING	         (WM_USER+3)
#define CB_DELETESTRING	         (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT	         (WM_USER+6)
#define CB_GETCURSEL	         (WM_USER+7)
#define CB_GETLBTEXT	         (WM_USER+8)
#define CB_GETLBTEXTLEN	         (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT	         (WM_USER+11)
#define CB_FINDSTRING	         (WM_USER+12)
#define CB_SELECTSTRING	         (WM_USER+13)
#define CB_SETCURSEL	         (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE	    (-1)
#define CBN_SELCHANGE	    1
#define CBN_DBLCLK	    2
#define CBN_SETFOCUS	    3
#define CBN_KILLFOCUS	    4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY 	    0
#define CB_ERR		    (-1)
#define CB_ERRSPACE	    (-2)

#endif	/* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */


/* Standard hook code */
#define HC_ACTION	    0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN	    (-3)
#define HC_LPLPFNNEXT	    (-2)
#define HC_LPFNNEXT	    (-1)

#endif	/* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT		    5

#define HCBT_MOVESIZE	    0
#define HCBT_MINMAX	    1
#define HCBT_QS 	    2
#define HCBT_CREATEWND	    3
#define HCBT_DESTROYWND	    4
#define HCBT_ACTIVATE	    5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND	    8
#define HCBT_SETFOCUS	    9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif	/* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE	    8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT	    1
#define HC_SKIP 	    2
#define HC_NOREMOVE	    3
#define HC_NOREM	    HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF	    5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif	/* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG	    9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE	hModuleHook;
    LPARAM	reserved;
    LPARAM	lParam;
    WPARAM	wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY	    0
#define S_THRESHOLD	    1
#define S_ALLTHRESHOLD	    2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY	    0
#define ODDPARITY	    1
#define EVENPARITY	    2
#define MARKPARITY	    3
#define SPACEPARITY	    4

#define ONESTOPBIT	    0
#define ONE5STOPBITS	    1
#define TWOSTOPBITS	    2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE	    EV_RingTe

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110	     0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY		0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int	FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD		0x0001
#define DRV_ENABLE		0x0002
#define DRV_OPEN		0x0003
#define DRV_CLOSE		0x0004
#define DRV_DISABLE		0x0005
#define DRV_FREE		0x0006
#define DRV_CONFIGURE		0x0007
#define DRV_QUERYCONFIGURE	0x0008
#define DRV_INSTALL		0x0009
#define DRV_REMOVE		0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER		0x000F

#define DRV_RESERVED		0x0800
#define DRV_USER		0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL		0x0000
#define DRVCNF_OK		0x0001
#define DRVCNF_RESTART		0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY	0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE		0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\windows.inc ===
;*************************************************************************
;
;       WINDOWS.INC - Windows assembly language structures & constants
;
;*************************************************************************
;
; Conditional Block includes:   (True states)
;     NOTEXT - don't include TextMetric struc & text drawing modes & stock objs.
;     NORASTOPS - don't include binary and ternary raster ops.
;     NOVK      - don't include virtual key definitions
;     NOMB      - don't include message box definitions
;     NOWM      - don't include window messages
;
;
FALSE   =       0
TRUE    =       1
NULL    =       0

;*******************************************************************
;
;       Rectangle
;
;*******************************************************************

RECT    struc
        rcLeft          dw      ?
        rcTop           dw      ?
        rcRight         dw      ?
        rcBottom        dw      ?
RECT    ends

;*******************************************************************
;
;  Window Class structure
;
;*******************************************************************

WNDCLASS struc
        clsStyle        dw      ?       ; class style
        clsLpfnWndProc  dd      ?
        clsCbClsExtra   dw      ?
        clsCbWndExtra   dw      ?
        clsHInstance    dw      ?       ; instance handle
        clsHIcon        dw      ?       ; class icon handle
        clsHCursor      dw      ?       ; class cursor handle
        clsHbrBackground dw     ?       ; class background brush
        clsLpszMenuName dd      ?       ; menu name
        clsLpszClassName dd     ?       ; far ptr to class name
WNDCLASS ends

IFNDEF NOTEXT
TEXTMETRIC struc
    tmHeight	    dw	    ?
    tmAscent	    dw	    ?
    tmDescent	    dw	    ?
    tmIntLeading    dw	    ?
    tmExtLeading    dw	    ?
    tmAveCharWidth  dw	    ?
    tmMaxCharWidth  dw	    ?
    tmWeight	    dw	    ?
    tmItalic	    db	    ?
    tmUnderlined    db	    ?
    tmStruckOut     db	    ?
    tmFirstChar     db	    ?
    tmLastChar	    db	    ?
    tmDefaultChar   db	    ?
    tmBreakChar     db	    ?
    tmPitch	    db	    ?
    tmCharSet	    db	    ?
    tmOverhang	    dw	    ?
    tmAspectX	    dw	    ?
    tmAspectY	    dw	    ?
TEXTMETRIC ends

LF_FACESIZE	EQU	32

LOGFONT struc
    lfHeight	      dw   ?
    lfWidth	      dw   ?
    lfEscapement      dw   ?
    lfOrientation     dw   ?
    lfWeight	      dw   ?
    lfItalic	      db   ?
    lfUnderline       db   ?
    lfStrikeOut       db   ?
    lfCharSet	      db   ?
    lfOutPrecision    db   ?
    lfClipPrecision   db   ?
    lfQuality	      db   ?
    lfPitchAndFamily  db   ?
    lfFaceName	      db   LF_FACESIZE dup(?)
LOGFONT ends

LOGBRUSH struc
    lbStyle         dw ?
    lbColor         dd ?
    lbHatch         dw ?
LOGBRUSH ends

;
;  Text Drawing modes
;
TRANSPARENT     = 1
OPAQUE          = 2
;
; Mapping Modes
;
MM_TEXT         =   1
MM_LOMETRIC     =   2
MM_HIMETRIC     =   3
MM_LOENGLISH    =   4
MM_HIENGLISH    =   5
MM_TWIPS        =   6
MM_ISOTROPIC    =   7
MM_ANISOTROPIC  =   8
;
; Coordinate Modes
;
ABSOLUTE        =   1
RELATIVE        =   2
;
;  Stock Logical Objects
;
WHITE_BRUSH         =  0
LTGRAY_BRUSH        =  1
GRAY_BRUSH          =  2
DKGRAY_BRUSH        =  3
BLACK_BRUSH         =  4
NULL_BRUSH          =  5
HOLLOW_BRUSH        =  5
WHITE_PEN           =  6
BLACK_PEN           =  7
NULL_PEN            =  8
DOT_MARKER          =  9
OEM_FIXED_FONT      = 10
ANSI_FIXED_FONT     = 11
ANSI_VAR_FONT       = 12
SYSTEM_FONT         = 13
DEVICE_DEFAULT_FONT = 14
DEFAULT_PALETTE     = 15
SYSTEM_FIXED_FONT   = 16
ENDIF
;
; Brush Styles
;
BS_SOLID        =   0
BS_NULL         =   1
BS_HOLLOW       =   BS_NULL
BS_HATCHED      =   2
BS_PATTERN      =   3
BS_INDEXED      =   4
BS_DIBPATTERN	=   5
;
; Hatch Styles
;
HS_HORIZONTAL   =   0       ; -----
HS_VERTICAL     =   1       ; |||||
HS_FDIAGONAL    =   2       ; \\\\\
HS_BDIAGONAL    =   3       ; /////
HS_CROSS        =   4       ; +++++
HS_DIAGCROSS    =   5       ; xxxxx
;
; Pen Styles
;
PS_SOLID        =   0
PS_DASH         =   1       ; -------
PS_DOT          =   2       ; .......
PS_DASHDOT      =   3       ; _._._._
PS_DASHDOTDOT   =   4       ; _.._.._
PS_NULL         =   5
PS_INSIDEFRAME  =   6
;
; Device Parameters for GetDeviceCaps()
;
DRIVERVERSION =0     ; Device driver version
TECHNOLOGY    =2     ; Device classification
HORZSIZE      =4     ; Horizontal size in millimeters
VERTSIZE      =6     ; Vertical size in millimeters
HORZRES       =8     ; Horizontal width in pixels
VERTRES       =10    ; Vertical width in pixels
BITSPIXEL     =12    ; Number of bits per pixel
PLANES        =14    ; Number of planes
NUMBRUSHES    =16    ; Number of brushes the device has
NUMPENS       =18    ; Number of pens the device has
NUMMARKERS    =20    ; Number of markers the device has
NUMFONTS      =22    ; Number of fonts the device has
NUMCOLORS     =24    ; Number of colors the device supports
PDEVICESIZE   =26    ; Size required for device descriptor
CURVECAPS     =28    ; Curve capabilities
LINECAPS      =30    ; Line capabilities
POLYGONALCAPS =32    ; Polygonal capabilities
TEXTCAPS      =34    ; Text capabilities
CLIPCAPS      =36    ; Clipping capabilities
RASTERCAPS    =38    ; Bitblt capabilities
ASPECTX       =40    ; Length of the X leg
ASPECTY       =42    ; Length of the Y leg
ASPECTXY      =44    ; Length of the hypotenuse

LOGPIXELSX    =88    ; Logical pixels/inch in X
LOGPIXELSY    =90    ; Logical pixels/inch in Y

SIZEPALETTE   =104   ; Number of entries in physical palette
NUMRESERVED   =106   ; Number of reserved entries in palette
COLORRES      =108   ; Actual color resolution
;
ifndef NOGDICAPMASKS
;
; Device Capability Masks:
;
; Device Technologies
DT_PLOTTER       =   0  ; /* Vector plotter                   */
DT_RASDISPLAY    =   1  ; /* Raster display                   */
DT_RASPRINTER    =   2  ; /* Raster printer                   */
DT_RASCAMERA     =   3  ; /* Raster camera                    */
DT_CHARSTREAM    =   4  ; /* Character-stream, PLP            */
DT_METAFILE      =   5  ; /* Metafile, VDM                    */
DT_DISPFILE      =   6  ; /* Display-file                     */
;
; Curve Capabilities
CC_NONE          =   0  ; /* Curves not supported             */
CC_CIRCLES       =   1  ; /* Can do circles                   */
CC_PIE           =   2  ; /* Can do pie wedges                */
CC_CHORD         =   4  ; /* Can do chord arcs                */
CC_ELLIPSES      =   8  ; /* Can do ellipese                  */
CC_WIDE          =   16 ; /* Can do wide lines                */
CC_STYLED        =   32 ; /* Can do styled lines              */
CC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
CC_INTERIORS     =   128; /* Can do interiors                 */
;
; Line Capabilities
LC_NONE          =   0  ; /* Lines not supported              */
LC_POLYLINE      =   2  ; /* Can do polylines                 */
LC_MARKER        =   4  ; /* Can do markers                   */
LC_POLYMARKER    =   8  ; /* Can do polymarkers               */
LC_WIDE          =   16 ; /* Can do wide lines                */
LC_STYLED        =   32 ; /* Can do styled lines              */
LC_WIDESTYLED    =   64 ; /* Can do wide styled lines         */
LC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities
PC_NONE          =   0  ; /* Polygonals not supported         */
PC_POLYGON       =   1  ; /* Can do polygons                  */
PC_RECTANGLE     =   2  ; /* Can do rectangles                */
PC_WINDPOLYGON   =   4  ; /* Can do winding polygons          */
PC_TRAPEZOID     =   4  ; /* Can do trapezoids                */
PC_SCANLINE      =   8  ; /* Can do scanlines                 */
PC_WIDE          =   16 ; /* Can do wide borders              */
PC_STYLED        =   32 ; /* Can do styled borders            */
PC_WIDESTYLED    =   64 ; /* Can do wide styled borders       */
PC_INTERIORS     =   128; /* Can do interiors                 */
;
; Polygonal Capabilities */
CP_NONE          =   0  ; /* No clipping of output            */
CP_RECTANGLE     =   1  ; /* Output clipped to rects          */
;
; Text Capabilities
TC_OP_CHARACTER  =   0001h ; /* Can do OutputPrecision   CHARACTER      */
TC_OP_STROKE     =   0002h ; /* Can do OutputPrecision   STROKE         */
TC_CP_STROKE     =   0004h ; /* Can do ClipPrecision     STROKE         */
TC_CR_90         =   0008h ; /* Can do CharRotAbility    90             */
TC_CR_ANY        =   0010h ; /* Can do CharRotAbility    ANY            */
TC_SF_X_YINDEP   =   0020h ; /* Can do ScaleFreedom      X_YINDEPENDENT */
TC_SA_DOUBLE     =   0040h ; /* Can do ScaleAbility      DOUBLE         */
TC_SA_INTEGER    =   0080h ; /* Can do ScaleAbility      INTEGER        */
TC_SA_CONTIN     =   0100h ; /* Can do ScaleAbility      CONTINUOUS     */
TC_EA_DOUBLE     =   0200h ; /* Can do EmboldenAbility   DOUBLE         */
TC_IA_ABLE       =   0400h ; /* Can do ItalisizeAbility  ABLE           */
TC_UA_ABLE       =   0800h ; /* Can do UnderlineAbility  ABLE           */
TC_SO_ABLE       =   1000h ; /* Can do StrikeOutAbility  ABLE           */
TC_RA_ABLE       =   2000h ; /* Can do RasterFontAble    ABLE           */
TC_VA_ABLE       =   4000h ; /* Can do VectorFontAble    ABLE           */
TC_RESERVED      =   8000h
;
; Raster Capabilities
RC_BITBLT        =   1      ; /* Can do standard BLT.             */
RC_BANDING       =   2      ; /* Device requires banding support  */
RC_SCALING       =   4      ; /* Device requires scaling support  */
RC_BITMAP64      =   8      ; /* Device can support >64K bitmap   */
RC_GDI20_OUTPUT  =   0010h  ; /* has 2.0 output calls         */
RC_DI_BITMAP     =   0080h  ; /* supports DIB to memory       */
RC_PALETTE       =   0100h  ; /* supports a palette           */
RC_DIBTODEV      =   0200h  ; /* supports DIBitsToDevice      */
RC_BIGFONT       =   0400h  ; /* supports >64K fonts          */
RC_STRETCHBLT    =   0800h  ; /* supports StretchBlt          */
RC_FLOODFILL     =   1000h  ; /* supports FloodFill           */
RC_STRETCHDIB    =   2000h  ; /* supports StretchDIBits       */

endif       ;NOGDICAPMASKS

; palette entry flags
;
PC_RESERVED     = 1    ;/* palette index used for animation */
PC_EXPLICIT     = 2    ;/* palette index is explicit to device */
PC_NOCOLLAPSE	= 4    ;/* do not match color to system palette */

; DIB color table identifiers
;
DIB_RGB_COLORS  = 0    ;/* color table in RGBTriples */
DIB_PAL_COLORS  = 1    ;/* color table in palette indices */
;

;constants for Get/SetSystemPaletteUse()
;
SYSPAL_STATIC	= 1
SYSPAL_NOSTATIC	= 2

; constants for CreateDIBitmap
CBM_INIT        = 4    ;/* initialize bitmap */
;
; Bitmap format constants
BI_RGB          = 0
BI_RLE8         = 1
BI_RLE4         = 2
;
;
ANSI_CHARSET    = 0
SYMBOL_CHARSET	= 2
OEM_CHARSET     = 255
;
;  styles for CombineRgn
;
RGN_AND  = 1
RGN_OR   = 2
RGN_XOR  = 3
RGN_DIFF = 4
RGN_COPY = 5
;
;  Predefined cursor & icon IDs
;
IDC_ARROW       = 32512
IDC_IBEAM       = 32513
IDC_WAIT        = 32514
IDC_CROSS       = 32515
IDC_UPARROW     = 32516
IDC_SIZE        = 32640
IDC_ICON        = 32641
IDC_SIZENWSE    = 32642
IDC_SIZENESW    = 32643
IDC_SIZEWE      = 32644
IDC_SIZENS      = 32645

IDI_APPLICATION = 32512
IDI_HAND        = 32513
IDI_QUESTION    = 32514
IDI_EXCLAMATION = 32515
IDI_ASTERISK    = 32516

;
; OEM Resource Ordinal Numbers */
;
OBM_CLOSE         =  32754
OBM_UPARROW       =  32753
OBM_DNARROW       =  32752
OBM_RGARROW       =  32751
OBM_LFARROW       =  32750
OBM_REDUCE        =  32749
OBM_ZOOM          =  32748
OBM_RESTORE       =  32747
OBM_REDUCED       =  32746
OBM_ZOOMD         =  32745
OBM_RESTORED      =  32744
OBM_UPARROWD      =  32743
OBM_DNARROWD      =  32742
OBM_RGARROWD      =  32741
OBM_LFARROWD      =  32740
OBM_MNARROW       =  32739
OBM_COMBO         =  32738
OBM_UPARROWI	  =  32737
OBM_DNARROWI	  =  32736
OBM_RGARROWI	  =  32735
OBM_LFARROWI	  =  32734

OBM_OLD_CLOSE     =  32767
OBM_SIZE          =  32766
OBM_OLD_UPARROW   =  32765
OBM_OLD_DNARROW   =  32764
OBM_OLD_RGARROW   =  32763
OBM_OLD_LFARROW   =  32762
OBM_BTSIZE        =  32761
OBM_CHECK         =  32760
OBM_CHECKBOXES    =  32759
OBM_BTNCORNERS    =  32758
OBM_OLD_REDUCE    =  32757
OBM_OLD_ZOOM      =  32756
OBM_OLD_RESTORE   =  32755

OCR_NORMAL        =  32512
OCR_IBEAM         =  32513
OCR_WAIT          =  32514
OCR_CROSS         =  32515
OCR_UP            =  32516
OCR_SIZE          =  32640
OCR_ICON          =  32641
OCR_SIZENWSE      =  32642
OCR_SIZENESW      =  32643
OCR_SIZEWE        =  32644
OCR_SIZENS        =  32645
OCR_SIZEALL       =  32646
OCR_ICOCUR        =  32647

OIC_SAMPLE        =  32512
OIC_HAND          =  32513
OIC_QUES          =  32514
OIC_BANG          =  32515
OIC_NOTE          =  32516

;
;   Scroll bar constants
;
SB_HORZ = 0
SB_VERT = 1
SB_CTL  = 2
SB_BOTH = 3
;
;   Scroll Commands
;
SB_LINEUP        = 0
SB_LINEDOWN      = 1
SB_PAGEUP        = 2
SB_PAGEDOWN      = 3
SB_THUMBPOSITION = 4
SB_THUMBTRACK    = 5
SB_TOP           = 6
SB_BOTTOM        = 7
SB_ENDSCROLL     = 8
;
;  MessageBox type flags
;
IFNDEF                  NOMB
MB_OK                   = 0000H
MB_OKCANCEL             = 0001H
MB_ABORTRETRYIGNORE     = 0002H
MB_YESNOCANCEL          = 0003H
MB_YESNO                = 0004H
MB_RETRYCANCEL          = 0005H

MB_ICONHAND             = 0010H
MB_ICONQUESTION         = 0020H
MB_ICONEXCLAMATION      = 0030H
MB_ICONASTERISK         = 0040H

MB_DEFBUTTON1           = 0000H
MB_DEFBUTTON2           = 0100H
MB_DEFBUTTON3           = 0200H

MB_APPLMODAL            = 0000H
MB_SYSTEMMODAL          = 1000H
MB_TASKMODAL            = 2000H

MB_NOFOCUS              = 8000H

;
;  Conventional dialog box and message box command IDs
;
IDOK     =   1
IDCANCEL =   2
IDABORT  =   3
IDRETRY  =   4
IDIGNORE =   5
IDYES    =   6
IDNO     =   7
;
;  Flags for OpenFile
;
OF_READ 	    = 0000H
OF_WRITE	    = 0001H
OF_READWRITE	    = 0002H
OF_SHARE_COMPAT	    = 0000H
OF_SHARE_EXCLUSIVE  = 0010H
OF_SHARE_DENY_WRITE = 0020H
OF_SHARE_DENY_READ  = 0030H
OF_SHARE_DENY_NONE  = 0040H
OF_PARSE	    = 0100H
OF_DELETE	    = 0200H
OF_VERIFY	    = 0400H     ; Used with OF_REOPEN
OF_SEARCH	    = 0400H     ; Used without OF_REOPEN
OF_CANCEL           = 0800H
OF_CREATE           = 1000H
OF_PROMPT           = 2000H
OF_EXIST            = 4000H
OF_REOPEN           = 8000H

TF_FORCEDRIVE   = 80H

OPENSTRUC       STRUC
opLen   db      ?
opDisk  db      ?
opXtra  dw      ?
opDate  dw      ?
opTime  dw      ?
opFile  db      120 dup (?)
OPENSTRUC       ENDS
;
;  DrawText format flags
;
DT_LEFT         = 00H
DT_CENTER       = 01H
DT_RIGHT        = 02H
DT_TOP          = 00H
DT_VCENTER      = 04H
DT_BOTTOM       = 08H
DT_WORDBREAK    = 10H
DT_SINGLELINE   = 20H
DT_EXPANDTABS   = 40H
DT_TABSTOP      = 80H
DT_NOCLIP       =    0100H
DT_EXTERNALLEADING = 0200H
DT_CALCRECT     =    0400H
DT_NOPREFIX     =    0800H
DT_INTERNAL     =    1000H
ENDIF

;
; ExtFloodFill style flags
;
FLOODFILLBORDER  =  0
FLOODFILLSURFACE =  1

;
; Memory manager flags
;
LMEM_FIXED      =   0000h
LMEM_MOVEABLE   =   0002h
LMEM_NOCOMPACT  =   0010H
LMEM_NODISCARD  =   0020H
LMEM_ZEROINIT   =   0040h
LMEM_MODIFY     =   0080H
LMEM_DISCARDABLE=   0F00h
LHND    =    LMEM_MOVEABLE+LMEM_ZEROINIT
LPTR    =    LMEM_FIXED+LMEM_ZEROINIT
; Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE)
LMEM_DISCARDED  =   4000H
LMEM_LOCKCOUNT  =   00FFH

NONZEROLHND     =    LMEM_MOVEABLE
NONZEROLPTR     =    LMEM_FIXED



GMEM_FIXED      =   0000h
GMEM_MOVEABLE   =   0002h
GMEM_NOCOMPACT  =   0010h
GMEM_NODISCARD  =   0020h
GMEM_ZEROINIT   =   0040h
GMEM_MODIFY     =   0080h
GMEM_DISCARDABLE=   0100h
GMEM_NOT_BANKED =   1000h
GMEM_DDESHARE   =   2000h
GMEM_SHARE	=   2000h
GMEM_NOTIFY     =   4000h
GMEM_LOWER      =   GMEM_NOT_BANKED
GHND            =   GMEM_MOVEABLE+GMEM_ZEROINIT
GPTR            =   GMEM_FIXED+GMEM_ZEROINIT

; Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE)
GMEM_DISCARDED  =    4000h
GMEM_LOCKCOUNT  =    00FFh

; Flags returned by GetWinFlags

WF_PMODE        =    0001h
WF_CPU286       =    0002h
WF_CPU386       =    0004h
WF_CPU486       =    0008h
WF_STANDARD	=    0010h
WF_WIN286	=    0010h
WF_ENHANCED	=    0020h
WF_WIN386	=    0020h
WF_CPU086	=    0040h
WF_CPU186	=    0080h
WF_LARGEFRAME   =    0100h
WF_SMALLFRAME   =    0200h
WF_80x87	=    0400h
WF_PAGING	=    0800h
WF_WLO          =    8000h

; WEP fSystemExit flag values
WEP_SYSTEM_EXIT	=	1
WEP_FREE_DLL	=	0


;  Virtual Keys, Standard Set

IFNDEF          NOVK
VK_LBUTTON      = 01H
VK_RBUTTON      = 02H
VK_CANCEL       = 03H
VK_BACK         = 08H
VK_TAB          = 09H
VK_CLEAR        = 0cH
VK_RETURN       = 0dH
VK_SHIFT        = 10H
VK_CONTROL      = 11H
VK_MENU         = 12H
VK_PAUSE        = 13H
VK_CAPITAL      = 14H
VK_ESCAPE       = 1bH
VK_SPACE        = 20H

VK_PRIOR        = 21H
VK_NEXT         = 22H
VK_END          = 23H
VK_HOME         = 24H
VK_LEFT         = 25H
VK_UP           = 26H
VK_RIGHT        = 27H
VK_DOWN         = 28H

;  VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z'
;  VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0'

VK_PRINT        = 2aH
VK_EXECUTE      = 2bH
VK_SNAPSHOT	= 2ch	; Printscreen key..
VK_INSERT       = 2dH
VK_DELETE       = 2eH
VK_HELP         = 2fH

VK_NUMPAD0      = 60H
VK_NUMPAD1      = 61H
VK_NUMPAD2      = 62H
VK_NUMPAD3      = 63H
VK_NUMPAD4      = 64H
VK_NUMPAD5      = 65H
VK_NUMPAD6      = 66H
VK_NUMPAD7      = 67H
VK_NUMPAD8      = 68H
VK_NUMPAD9      = 69H
VK_MULTIPLY     = 6AH
VK_ADD          = 6BH
VK_SEPARATER    = 6CH
VK_SUBTRACT     = 6DH
VK_DECIMAL      = 6EH
VK_DIVIDE       = 6FH

VK_F1           = 70H
VK_F2           = 71H
VK_F3           = 72H
VK_F4           = 73H
VK_F5           = 74H
VK_F6           = 75H
VK_F7           = 76H
VK_F8           = 77H
VK_F9           = 78H
VK_F10          = 79H
VK_F11          = 7aH
VK_F12          = 7bH
VK_F13          = 7cH
VK_F14          = 7dH
VK_F15          = 7eH
VK_F16          = 7fH
VK_F17		= 80H
VK_F18		= 81H
VK_F19		= 82H
VK_F20		= 83H
VK_F21		= 84H
VK_F22		= 85H
VK_F23		= 86H
VK_F24		= 87H

VK_NUMLOCK      = 90H
VK_SCROLL       = 91H
ENDIF

IFNDEF NOWH

; SetWindowsHook() codes
WH_MSGFILTER       = (-1)
WH_JOURNALRECORD   = 0
WH_JOURNALPLAYBACK = 1
WH_KEYBOARD        = 2
WH_GETMESSAGE      = 3
WH_CALLWNDPROC     = 4
IFNDEF NOWIN31
WH_CBT             = 5
WH_SYSMSGFILTER    = 6
WH_MOUSE	   = 7
WH_HARDWARE	   = 8
WH_DEBUG	   = 9
ENDIF
;
; Hook Codes
HC_GETLPLPFN	   = (-3)
HC_LPLPFNNEXT      = (-2)
HC_LPFNNEXT        = (-1)
HC_ACTION          = 0
HC_GETNEXT         = 1
HC_SKIP            = 2
HC_NOREM           = 3
HC_NOREMOVE        = 3
HC_SYSMODALON      = 4
HC_SYSMODALOFF     = 5
;
; CBT Hook Codes
HCBT_MOVESIZE      = 0
HCBT_MINMAX        = 1
HCBT_QS            = 2
HCBT_CREATEWND	   = 3
HCBT_DESTROYWND	   = 4
HCBT_ACTIVATE	   = 5
HCBT_CLICKSKIPPED  = 6
HCBT_KEYSKIPPED    = 7
HCBT_SYSCOMMAND	   = 8
HCBT_SETFOCUS	   = 9

;
; WH_MSGFILTER Filter Proc Codes
MSGF_DIALOGBOX     = 0
MSGF_MENU          = 2
MSGF_MOVE          = 3
MSGF_SIZE          = 4
MSGF_SCROLLBAR     = 5
MSGF_NEXTWINDOW    = 6
;
; Window Manager Hook Codes
WC_INIT            = 1
WC_SWP             = 2
WC_DEFWINDOWPROC   = 3
WC_MINMAX          = 4
WC_MOVE            = 5
WC_SIZE            = 6
WC_DRAWCAPTION     = 7
;

; Message Structure used in Journaling
EVENTMSG    struc
    message     dw ?
    paramL      dw ?
    paramH      dw ?
    time        dd ?
EVENTMSG    ends

ENDIF ;NOWH

; Window field offsets for GetWindowLong() and GetWindowWord()
GWL_WNDPROC       =  (-4)
GWW_HINSTANCE     =  (-6)
GWW_HWNDPARENT    =  (-8)
GWW_ID            =  (-12)
GWL_STYLE         =  (-16)
GWL_EXSTYLE       =  (-20)

; GetWindow() Constants
GW_HWNDFIRST	  =  0
GW_HWNDLAST	  =  1
GW_HWNDNEXT	  =  2
GW_HWNDPREV	  =  3
GW_OWNER	  =  4
GW_CHILD	  =  5

; Class field offsets for GetClassLong() and GetClassWord()
GCL_MENUNAME      =  (-8)
GCW_HBRBACKGROUND =  (-10)
GCW_HCURSOR       =  (-12)
GCW_HICON         =  (-14)
GCW_HMODULE       =  (-16)
GCW_CBWNDEXTRA    =  (-18)
GCW_CBCLSEXTRA    =  (-20)
GCL_WNDPROC       =  (-24)
GCW_STYLE         =  (-26)

; WinWhere() Area Codes
HTERROR           =  (-2)
HTTRANSPARENT     =  (-1)
HTNOWHERE         =  0
HTCLIENT          =  1
HTCAPTION         =  2
HTSYSMENU         =  3
HTGROWBOX         =  4
HTSIZE            =  HTGROWBOX
HTMENU            =  5
HTHSCROLL         =  6
HTVSCROLL         =  7
HTREDUCE          =  8
HTZOOM            =  9
HTLEFT            =  10
HTRIGHT           =  11
HTTOP             =  12
HTTOPLEFT         =  13
HTTOPRIGHT        =  14
HTBOTTOM          =  15
HTBOTTOMLEFT      =  16
HTBOTTOMRIGHT     =  17
HTSIZEFIRST       =  HTLEFT
HTSIZELAST        =  HTBOTTOMRIGHT



;*************************************************************************
;
;       Misc structures & constants
;
;*************************************************************************

IFNDEF  NOMST
POINT   struc
        ptX             dw      ?
        ptY             dw      ?
POINT   ends

LOGPEN struc
    lopnStyle       dw ?
    lopnWidth       db (SIZE POINT) DUP(?)
    lopnColor       dd ?
LOGPEN ends


BITMAP STRUC
        bmType         DW ?
        bmWidth        DW ?
        bmHeight       DW ?
        bmWidthBytes   DW ?
        bmPlanes       DB ?
        bmBitsPixel    DB ?
        bmBits         DD ?
BITMAP ENDS

RGBTRIPLE	struc
	rgbBlue		db ?
	rgbGreen	db ?
	rgbRed		db ?
RGBTRIPLE	ends

RGBQUAD         struc
        rgbqBlue        db ?
        rgbqGreen       db ?
        rgbqRed         db ?
        rgbqReserved    db ?
RGBQUAD         ends

; structures for defining DIBs
BITMAPCOREHEADER struc
        bcSize      dd ?
        bcWidth     dw ?
        bcHeight    dw ?
        bcPlanes    dw ?
        bcBitCount  dw ?
BITMAPCOREHEADER ends

BITMAPINFOHEADER struc
        biSize           dd ?
        biWidth          dd ?
        biHeight         dd ?
        biPlanes         dw ?
        biBitCount       dw ?

        biCompression    dd ?
        biSizeImage      dd ?
        biXPelsPerMeter  dd ?
        biYPelsPerMeter  dd ?
        biClrUsed        dd ?
        biClrImportant   dd ?
BITMAPINFOHEADER ends

BITMAPINFO  struc
    bmiHeader   db (SIZE BITMAPINFOHEADER) DUP (?)
    bmiColors   db ?            ; array of RGBQUADs
BITMAPINFO  ends

BITMAPCOREINFO  struc
    bmciHeader  db (SIZE BITMAPCOREHEADER) DUP (?)
    bmciColors  db ?            ; array of RGBTRIPLEs
BITMAPCOREINFO  ends

BITMAPFILEHEADER struc
    bfType          dw ?
    bfSize          dd ?
    bfReserved1     dw ?
    bfReserved2     dw ?
    bfOffBits       dd ?
BITMAPFILEHEADER ends


WNDSTRUC struc
        WSwndStyle        dd      ?
        WSwndID           dw      ?
        WSwndText         dw      ?
        WSwndParent       dw      ?
        WSwndInstance     dw      ?
        WSwndClassProc    dd      ?
WNDSTRUC ends
;
;  Message structure
;
MSGSTRUCT       struc
msHWND          dw      ?
msMESSAGE       dw      ?
msWPARAM        dw      ?
msLPARAM        dd      ?
msTIME          dd      ?
msPT            dd      ?
MSGSTRUCT       ends

NEWPARMS struc
        nprmHwnd        dw      ?
        nprmCmd         db      ?
NEWPARMS ends
ENDIF

PAINTSTRUCT STRUC
    PShdc         DW ?
    PSfErase      DW ?
    PSrcPaint     DB size RECT dup(?)
    PSfRestore    DW ?
    PSfIncUpdate  DW ?
    PSrgbReserved DB 16 dup(?)
PAINTSTRUCT ENDS


CREATESTRUCT struc
    cs_lpCreateParams  dd ?
    cs_hInstance       dw ?
    cs_hMenu           dw ?
    cs_hwndParent      dw ?
    cs_cy              dw ?
    cs_cx              dw ?
    cs_y               dw ?
    cs_x               dw ?
    cs_style           dd ?
    cs_lpszName        dd ?
    cs_lpszClass       dd ?
    cs_dwExStyle       dd ?
CREATESTRUCT  ends
;
;       PostError constants
;
WARNING     = 0           ; command codes
MINOR_ERROR = 1
FATAL_ERROR = 2

IGNORE      = 0           ; response codes
RETRY       = 1
ABORT       = 2
;
; GDI-related constants & commands
;
ERRORREGION     = 0
NULLREGION      = 1
SIMPLEREGION    = 2
COMPLEXREGION   = 3

IFNDEF NORASTOPS
;
; Binary raster ops
;
R2_BLACK        =  1
R2_NOTMERGEPEN  =  2
R2_MASKNOTPEN   =  3
R2_NOTCOPYPEN   =  4
R2_MASKPENNOT   =  5
R2_NOT          =  6
R2_XORPEN       =  7
R2_NOTMASKPEN   =  8
R2_MASKPEN      =  9
R2_NOTXORPEN    = 10
R2_NOP          = 11
R2_MERGENOTPEN  = 12
R2_COPYPEN      = 13
R2_MERGEPENNOT  = 14
R2_MERGEPEN     = 15
R2_WHITE        = 16
;
; Ternary raster ops
;
SRCCOPY_L     = 0020h   ;dest=source
SRCCOPY_H     = 00CCh
SRCPAINT_L    = 0086h   ;dest=source OR dest
SRCPAINT_H    = 00EEh
SRCAND_L      = 00C6h   ;dest=source AND   dest
SRCAND_H      = 0088h
SRCINVERT_L   = 0046h   ;dest= source XOR      dest
SRCINVERT_H   = 0066h
SRCERASE_L    = 0328h   ;dest= source AND (not dest )
SRCERASE_H    = 0044h
NOTSRCCOPY_L  = 0008h   ;dest= (not source)
NOTSRCCOPY_H  = 0033h
NOTSRCERASE_L = 00A6h   ;dest= (not source) AND (not dest)
NOTSRCERASE_H = 0011h
MERGECOPY_L   = 00CAh   ;dest= (source AND pattern)
MERGECOPY_H   = 00C0h
MERGEPAINT_L  = 0226h   ;dest= (source AND pattern) OR dest
MERGEPAINT_H  = 00BBh
PATCOPY_L     = 0021h   ;dest= pattern
PATCOPY_H     = 00F0h
PATPAINT_L    = 0A09h   ;DPSnoo
PATPAINT_H    = 00FBh
PATINVERT_L   = 0049h   ;dest= pattern XOR     dest
PATINVERT_H   = 005Ah
DSTINVERT_L   = 0009h   ;dest= (not dest)
DSTINVERT_H   = 0055h
BLACKNESS_L   = 0042h   ;dest= BLACK
BLACKNESS_H   = 0000h
WHITENESS_L   = 0062h   ;dest= WHITE
WHITENESS_H   = 00FFh
;
; StretchBlt modes
;
BLACKONWHITE    = 1
WHITEONBLACK    = 2
COLORONCOLOR    = 3
;
; New StretchBlt modes
;
STRETCH_ANDSCANS    = 1
STRETCH_ORSCANS     = 2
STRETCH_DELETESCANS = 3
;
; PolyFill modes
;
ALTERNATE       = 1
WINDING         = 2
ENDIF
;
; Text Alignment Options
;
TA_NOUPDATECP   =  0
TA_UPDATECP     =  1

TA_LEFT         =  0
TA_RIGHT        =  2
TA_CENTER       =  6

TA_TOP          =  0
TA_BOTTOM       =  8
TA_BASELINE     =  24

ETO_GRAYED      =  1
ETO_OPAQUE      =  2
ETO_CLIPPED     =  4

ASPECT_FILTERING = 1

ifndef NOMETAFILE

; Metafile Functions */
META_SETBKCOLOR            =  0201h
META_SETBKMODE             =  0102h
META_SETMAPMODE            =  0103h
META_SETROP2               =  0104h
META_SETRELABS             =  0105h
META_SETPOLYFILLMODE       =  0106h
META_SETSTRETCHBLTMODE     =  0107h
META_SETTEXTCHAREXTRA      =  0108h
META_SETTEXTCOLOR          =  0209h
META_SETTEXTJUSTIFICATION  =  020Ah
META_SETWINDOWORG          =  020Bh
META_SETWINDOWEXT          =  020Ch
META_SETVIEWPORTORG        =  020Dh
META_SETVIEWPORTEXT        =  020Eh
META_OFFSETWINDOWORG       =  020Fh
META_SCALEWINDOWEXT        =  0400h
META_OFFSETVIEWPORTORG     =  0211h
META_SCALEVIEWPORTEXT      =  0412h
META_LINETO                =  0213h
META_MOVETO                =  0214h
META_EXCLUDECLIPRECT       =  0415h
META_INTERSECTCLIPRECT     =  0416h
META_ARC                   =  0817h
META_ELLIPSE               =  0418h
META_FLOODFILL             =  0419h
META_PIE                   =  081Ah
META_RECTANGLE             =  041Bh
META_ROUNDRECT             =  061Ch
META_PATBLT                =  061Dh
META_SAVEDC                =  001Eh
META_SETPIXEL              =  041Fh
META_OFFSETCLIPRGN         =  0220h
META_TEXTOUT               =  0521h
META_BITBLT                =  0922h
META_STRETCHBLT            =  0B23h
META_POLYGON               =  0324h
META_POLYLINE              =  0325h
META_ESCAPE                =  0626h
META_RESTOREDC             =  0127h
META_FILLREGION            =  0228h
META_FRAMEREGION           =  0429h
META_INVERTREGION          =  012Ah
META_PAINTREGION           =  012Bh
META_SELECTCLIPREGION      =  012Ch
META_SELECTOBJECT          =  012Dh
META_SETTEXTALIGN          =  012Eh
META_DRAWTEXT              =  062Fh

META_CHORD		   =  0830h
META_SETMAPPERFLAGS	   =  0231h
META_EXTTEXTOUT		   =  0a32h
META_SETDIBTODEV	   =  0d33h
META_SELECTPALETTE	   =  0234h
META_REALIZEPALETTE	   =  0035h
META_ANIMATEPALETTE	   =  0436h
META_SETPALENTRIES	   =  0037h
META_POLYPOLYGON	   =  0538h
META_RESIZEPALETTE	   =  0139h

META_DIBBITBLT		   =  0940h
META_DIBSTRETCHBLT	   =  0b41h
META_DIBCREATEPATTERNBRUSH =  0142h
META_STRETCHDIB		   =  0f43h

META_DELETEOBJECT	   =  01f0h

META_CREATEPALETTE	   =  00f7h
META_CREATEBRUSH           =  00F8h
META_CREATEPATTERNBRUSH    =  01F9h
META_CREATEPENINDIRECT     =  02FAh
META_CREATEFONTINDIRECT    =  02FBh
META_CREATEBRUSHINDIRECT   =  02FCh
META_CREATEBITMAPINDIRECT  =  02FDh
META_CREATEBITMAP          =  06FEh
META_CREATEREGION          =  06FFh

; /* Clipboard Metafile Picture Structure */
HANDLETABLE struc
    ht_objectHandle  dw      ?
HANDLETABLE ends

METARECORD struc
    mr_rdSize	     dd      ?
    mr_rdFunction    dw      ?
    mr_rdParm	     dw      ?
METARECORD ends

METAFILEPICT struc
    mfp_mm	dw	?
    mfp_xExt	dw	?
    mfp_yExt	dw	?
    mfp_hMF	dw	?
METAFILEPICT ends

METAHEADER struc
  mtType	dw	?
  mtHeaderSize	dw	?
  mtVersion	dw	?
  mtSize	dd	?
  mtNoObjects	dw	?
  mtMaxRecord	dd	?
  mtNoParameters dw	?
METAHEADER ends

endif ; NOMETAFILE

; GDI Escapes
NEWFRAME                  =   1
ABORTDOC                  =   2
NEXTBAND                  =   3
SETCOLORTABLE             =   4
GETCOLORTABLE             =   5
FLUSHOUTPUT               =   6
DRAFTMODE                 =   7
QUERYESCSUPPORT           =   8
SETABORTPROC              =   9
STARTDOC                  =   10
;; This value conflicts with a std WIN386 MACRO definition
;;ENDDOC		    =	11
GETPHYSPAGESIZE           =   12
GETPRINTINGOFFSET         =   13
GETSCALINGFACTOR          =   14
MFCOMMENT                 =   15
GETPENWIDTH               =   16
SETCOPYCOUNT              =   17
SELECTPAPERSOURCE         =   18
DEVICEDATA                =   19
PASSTHROUGH               =   19
GETTECHNOLGY		  =   20
GETTECHNOLOGY		  =   20
SETENDCAP                 =   21
SETLINEJOIN               =   22
SETMITERLIMIT             =   23
BANDINFO                  =   24
DRAWPATTERNRECT           =   25
GETVECTORPENSIZE          =   26
GETVECTORBRUSHSIZE        =   27
ENABLEDUPLEX              =   28
ENABLEMANUALFEED	  =   29
GETSETPAPERBINS 	  =   29
GETSETPRINTORIENT	  =   30
ENUMPAPERBINS		  =   31

GETEXTENDEDTEXTMETRICS    =   256
GETEXTENTTABLE            =   257
GETPAIRKERNTABLE          =   258
GETTRACKKERNTABLE         =   259

EXTTEXTOUT                =   512

ENABLERELATIVEWIDTHS      =   768
ENABLEPAIRKERNING         =   769
SETKERNTRACK              =   770
SETALLJUSTVALUES	  =   771
SETCHARSET		  =   772

GETSETSCREENPARAMS        =   3072

STRETCHBLT                =   2048


; Spooler Error Codes
SP_NOTREPORTED            =   4000h
SP_ERROR                  =   (-1)
SP_APPABORT               =   (-2)
SP_USERABORT              =   (-3)
SP_OUTOFDISK              =   (-4)
SP_OUTOFMEMORY            =   (-5)

PR_JOBSTATUS              =   0000

; Object Definitions for EnumObjects()
OBJ_PEN                   =   1
OBJ_BRUSH                 =   2

;
; Menu flags for Change/Check/Enable MenuItem
;
MF_INSERT       =   0000h
MF_CHANGE       =   0080h
MF_APPEND       =   0100h
MF_DELETE       =   0200h
MF_REMOVE       =   1000h

MF_BYCOMMAND    =   0000h
MF_BYPOSITION   =   0400h

MF_SEPARATOR    =   0800h

MF_ENABLED      =   0000h
MF_GRAYED       =   0001h
MF_DISABLED     =   0002h

MF_UNCHECKED    =   0000h
MF_CHECKED      =   0008h
MF_USECHECKBITMAPS= 0200h

MF_STRING       =   0000h
MF_BITMAP       =   0004h
MF_OWNERDRAW    =   0100h

MF_POPUP        =   0010h
MF_MENUBARBREAK =   0020h
MF_MENUBREAK    =   0040h

MF_UNHILITE     =   0000h
MF_HILITE       =   0080h

MF_SYSMENU      =   2000h
MF_HELP         =   4000h
MF_MOUSESELECT  =   8000h


;
;  System Menu Command Values
;
SC_SIZE        = 0F000h
SC_MOVE        = 0F010h
SC_MINIMIZE    = 0F020h
SC_MAXIMIZE    = 0F030h
SC_NEXTWINDOW  = 0F040h
SC_PREVWINDOW  = 0F050h
SC_CLOSE       = 0F060h
SC_VSCROLL     = 0F070h
SC_HSCROLL     = 0F080h
SC_MOUSEMENU   = 0F090h
SC_KEYMENU     = 0F100h
SC_ARRANGE     = 0F110h
SC_RESTORE     = 0F120h
SC_TASKLIST    = 0F130h
SC_SCREENSAVE  = 0F140h
SC_HOTKEY      = 0F150h

SC_ICON        = SC_MINIMIZE
SC_ZOOM        = SC_MAXIMIZE

;
;  Window State Messages
;
IFNDEF  NOWM
WM_STATE            = 0000H

WM_NULL             = 0000h
WM_CREATE           = 0001h
WM_DESTROY          = 0002h
WM_MOVE             = 0003h
WM_SIZE             = 0005h
WM_ACTIVATE         = 0006h
WM_SETFOCUS         = 0007h
WM_KILLFOCUS        = 0008h
WM_ENABLE           = 000Ah
WM_SETREDRAW        = 000Bh
WM_SETTEXT          = 000Ch
WM_GETTEXT          = 000Dh
WM_GETTEXTLENGTH    = 000Eh
WM_PAINT            = 000Fh
WM_CLOSE            = 0010h
WM_QUERYENDSESSION  = 0011h
WM_QUIT             = 0012h
WM_QUERYOPEN        = 0013h
WM_ERASEBKGND       = 0014h
WM_SYSCOLORCHANGE   = 0015h
WM_ENDSESSION       = 0016h
WM_SYSTEMERROR      = 0017h
WM_SHOWWINDOW       = 0018h
WM_CTLCOLOR         = 0019h
WM_WININICHANGE     = 001Ah
WM_DEVMODECHANGE    = 001Bh
WM_ACTIVATEAPP      = 001Ch
WM_FONTCHANGE       = 001Dh
WM_TIMECHANGE       = 001Eh
WM_CANCELMODE       = 001Fh
WM_SETCURSOR        = 0020h
WM_MOUSEACTIVATE    = 0021h
WM_CHILDACTIVATE    = 0022h
WM_QUEUESYNC        = 0023h
WM_GETMINMAXINFO    = 0024h
WM_PAINTICON        = 0026h
WM_ICONERASEBKGND   = 0027h
WM_NEXTDLGCTL       = 0028h
WM_SPOOLERSTATUS    = 002Ah
WM_DRAWITEM         = 002Bh
WM_MEASUREITEM      = 002Ch
WM_DELETEITEM       = 002Dh
WM_VKEYTOITEM       = 002Eh
WM_CHARTOITEM       = 002Fh
WM_SETFONT          = 0030h
WM_GETFONT          = 0031h
WM_QUERYDRAGICON    = 0037h
WM_COMPAREITEM	    = 0039h
WM_COMPACTING       = 0041h
IFNDEF NOWIN31
WM_COMMNOTIFY       = 0044h
WM_WINDOWPOSCHANGING= 0046h
WM_WINDOWPOSCHANGED = 0047h
WM_POWER            = 0048h
ENDIF


WM_NCCREATE         = 0081h
WM_NCDESTROY        = 0082h
WM_NCCALCSIZE       = 0083h
WM_NCHITTEST        = 0084h
WM_NCPAINT          = 0085h
WM_NCACTIVATE       = 0086h
WM_GETDLGCODE       = 0087h
WM_NCMOUSEMOVE      = 00A0h
WM_NCLBUTTONDOWN    = 00A1h
WM_NCLBUTTONUP      = 00A2h
WM_NCLBUTTONDBLCLK  = 00A3h
WM_NCRBUTTONDOWN    = 00A4h
WM_NCRBUTTONUP      = 00A5h
WM_NCRBUTTONDBLCLK  = 00A6h
WM_NCMBUTTONDOWN    = 00A7h
WM_NCMBUTTONUP      = 00A8h
WM_NCMBUTTONDBLCLK  = 00A9h

WM_KEYFIRST         = 0100h
WM_KEYDOWN          = 0100h
WM_KEYUP            = 0101h
WM_CHAR             = 0102h
WM_DEADCHAR         = 0103h
WM_SYSKEYDOWN       = 0104h
WM_SYSKEYUP         = 0105h
WM_SYSCHAR          = 0106h
WM_SYSDEADCHAR      = 0107h
WM_KEYLAST          = 0108h

WM_INITDIALOG       = 0110h
WM_COMMAND          = 0111h
WM_SYSCOMMAND       = 0112h
WM_TIMER            = 0113h
WM_HSCROLL          = 0114h
WM_VSCROLL          = 0115h
WM_INITMENU         = 0116h
WM_INITMENUPOPUP    = 0117h
WM_MENUSELECT       = 011Fh
WM_MENUCHAR         = 0120h
WM_ENTERIDLE        = 0121h

			  
WM_MOUSEFIRST       = 0200h
WM_MOUSEMOVE        = 0200h
WM_LBUTTONDOWN      = 0201h
WM_LBUTTONUP        = 0202h
WM_LBUTTONDBLCLK    = 0203h
WM_RBUTTONDOWN      = 0204h
WM_RBUTTONUP        = 0205h
WM_RBUTTONDBLCLK    = 0206h
WM_MBUTTONDOWN      = 0207h
WM_MBUTTONUP        = 0208h
WM_MBUTTONDBLCLK    = 0209h
WM_MOUSELAST        = 0209h

WM_PARENTNOTIFY     = 0210h
WM_MDICREATE        = 0220h
WM_MDIDESTROY       = 0221h
WM_MDIACTIVATE      = 0222h
WM_MDIRESTORE       = 0223h
WM_MDINEXT          = 0224h
WM_MDIMAXIMIZE      = 0225h
WM_MDITILE          = 0226h
WM_MDICASCADE       = 0227h
WM_MDIICONARRANGE   = 0228h
WM_MDIGETACTIVE     = 0229h
WM_MDISETMENU       = 0230h
WM_DROPFILES	    = 0233h


WM_CUT              = 0300h
WM_COPY             = 0301h
WM_PASTE            = 0302h
WM_CLEAR            = 0303h
WM_UNDO             = 0304h
WM_RENDERFORMAT     = 0305h
WM_RENDERALLFORMATS = 0306h
WM_DESTROYCLIPBOARD = 0307h
WM_DRAWCLIPBOARD    = 0308h
WM_PAINTCLIPBOARD   = 0309h
WM_VSCROLLCLIPBOARD = 030Ah
WM_SIZECLIPBOARD    = 030Bh
WM_ASKCBFORMATNAME  = 030Ch
WM_CHANGECBCHAIN    = 030Dh
WM_HSCROLLCLIPBOARD = 030Eh
WM_QUERYNEWPALETTE  = 030Fh
WM_PALETTEISCHANGING = 0310h
WM_PALETTECHANGED   = 0311h

IFNDEF NOWIN31
WM_PENWINFIRST      equ 0380h
WM_PENWINLAST       equ 038Fh


WM_COALESCE_FIRST  equ 0390h
WM_COALESCE_LAST   equ 039Fh




ENDIF



;  private window messages start here
WM_USER             = 0400H
ENDIF           ; NOWM

; WM_MOUSEACTIVATE Return Codes
MA_ACTIVATE       =  1
MA_ACTIVATEANDEAT =  2
MA_NOACTIVATE     =  3

; Size message commands
SIZENORMAL       = 0
SIZEICONIC       = 1
SIZEFULLSCREEN   = 2
SIZEZOOMSHOW     = 3
SIZEZOOMHIDE     = 4

; ShowWindow() Commands
SW_HIDE            = 0
SW_SHOWNORMAL      = 1
SW_NORMAL          = 1
SW_SHOWMINIMIZED   = 2
SW_SHOWMAXIMIZED   = 3
SW_MAXIMIZE        = 3
SW_SHOWNOACTIVATE  = 4
SW_SHOW            = 5
SW_MINIMIZE        = 6
SW_SHOWMINNOACTIVE = 7
SW_SHOWNA          = 8
SW_RESTORE         = 9

; Old ShowWindow() Commands
HIDE_WINDOW        = 0
SHOW_OPENWINDOW    = 1
SHOW_ICONWINDOW    = 2
SHOW_FULLSCREEN    = 3
SHOW_OPENNOACTIVATE= 4

;  identifiers for the WM_SHOWWINDOW message
SW_PARENTCLOSING =  1
SW_OTHERZOOM     =  2
SW_PARENTOPENING =  3
SW_OTHERUNZOOM   =  4
;
; Key state masks for mouse messages
;
MK_LBUTTON       = 0001h
MK_RBUTTON       = 0002h
MK_SHIFT         = 0004h
MK_CONTROL       = 0008h
MK_MBUTTON       = 0010h
;
; Class styles
;
CS_VREDRAW         = 0001h
CS_HREDRAW         = 0002h
CS_KEYCVTWINDOW    = 0004H
CS_DBLCLKS         = 0008h
; 		     0010h reserved
CS_OWNDC           = 0020h
CS_CLASSDC         = 0040h
CS_PARENTDC        = 0080h
CS_NOKEYCVT        = 0100h
CS_SAVEBITS        = 0800h
CS_NOCLOSE         = 0200h
CS_BYTEALIGNCLIENT = 1000h
CS_BYTEALIGNWINDOW = 2000h
CS_GLOBALCLASS     = 4000h    ; Global window class

;
; Special CreateWindow position value
;
CW_USEDEFAULT	EQU    8000h

;
; Windows styles (the high words)
;
WS_OVERLAPPED   = 00000h
WS_ICONICPOPUP  = 0C000h
WS_POPUP        = 08000h
WS_CHILD        = 04000h
WS_MINIMIZE     = 02000h
WS_VISIBLE      = 01000h
WS_DISABLED     = 00800h
WS_CLIPSIBLINGS = 00400h
WS_CLIPCHILDREN = 00200h
WS_MAXIMIZE     = 00100h
WS_CAPTION      = 000C0h     ; WS_BORDER | WS_DLGFRAME
WS_BORDER       = 00080h
WS_DLGFRAME     = 00040h
WS_VSCROLL      = 00020h
WS_HSCROLL      = 00010h
WS_SYSMENU      = 00008h
WS_THICKFRAME   = 00004h
WS_HREDRAW      = 00002h
WS_VREDRAW      = 00001h
WS_GROUP        = 00002h
WS_TABSTOP      = 00001h
WS_MINIMIZEBOX  = 00002h
WS_MAXIMIZEBOX  = 00001h

; Common Window Styles

WS_OVERLAPPEDWINDOW = WS_OVERLAPPED + WS_CAPTION + WS_SYSMENU + WS_THICKFRAME + WS_MINIMIZEBOX + WS_MAXIMIZEBOX
WS_POPUPWINDOW  = WS_POPUP + WS_BORDER + WS_SYSMENU
WS_CHILDWINDOW  = WS_CHILD
WS_TILEDWINDOW  = WS_OVERLAPPEDWINDOW

WS_TILED        = WS_OVERLAPPED
WS_ICONIC       = WS_MINIMIZE
WS_SIZEBOX      = WS_THICKFRAME

; Extended Window Styles (low words)
WS_EX_DLGMODALFRAME  = 0001
WS_EX_DRAGOBJECT     = 0002
WS_EX_NOPARENTNOTIFY = 0004
WS_EX_TOPMOST        = 0008

;
; predefined clipboard formats
;
CF_TEXT         =  1
CF_BITMAP       =  2
CF_METAFILEPICT =  3
CF_SYLK         =  4
CF_DIF          =  5
CF_TIFF         =  6
CF_OEMTEXT      =  7
CF_DIB          =  8
CF_PALETTE      =  9
CF_PENDATA      = 10
CF_RIFF         = 11
CF_WAVE         = 12

CF_OWNERDISPLAY = 80h       ; owner display
CF_DSPTEXT      = 81h       ; display text
CF_DSPBITMAP    = 82h       ; display bitmap
CF_DSPMETAFILEPICT  = 83h   ; display metafile
;
; Private clipboard format range
;
CF_PRIVATEFIRST       = 200h       ; Anything in this range doesn't
CF_PRIVATELAST        = 2ffh       ; get GlobalFree'd
CF_GDIOBJFIRST        = 300h       ; Anything in this range gets
CF_GDIOBJLAST         = 3ffh       ; DeleteObject'ed


MAKEINTRESOURCE MACRO a
        mov     ax,a
        xor     dx,dx
        ENDM
;
;  Predefined resource types
;
RT_CURSOR       = 1              ; must be passed through MAKEINTRESOURCE
RT_BITMAP       = 2
RT_ICON         = 3
RT_MENU         = 4
RT_DIALOG       = 5
RT_STRING       = 6
RT_FONTDIR      = 7
RT_FONT         = 8
RT_ACCELERATOR  = 9
RT_RCDATA       = 10

;** NOTE: if any new resource types are introduced above this point, then the
;** value of DIFFERENCE must be changed.
;** (RT_GROUP_CURSOR - RT_CURSOR) must always be equal to DIFFERENCE
;** (RT_GROUP_ICON - RT_ICON) must always be equal to DIFFERENCE

DIFFERENCE       =   11

RT_GROUP_CURSOR  =   RT_CURSOR + DIFFERENCE
RT_GROUP_ICON    =   RT_ICON + DIFFERENCE



IFNDEF NOMDI
MDICREATESTRUCT     struc
    szClass	    dd ?
    szTitle	    dd ?
    hOwner	    dw ?
    x		    dw ?
    y		    dw ?
    cxc 	    dw ?
    cyc 	    dw ?
    style	    dd ?
MDICREATESTRUCT ends

CLIENTCREATESTRUCT  struc
    hWindowMenu     dw ?
    idFirstChild    dw ?
CLIENTCREATESTRUCT ends
ENDIF

; NOMDI


PALETTEENTRY	    struc
    peRed	    db ?
    peGreen	    db ?
    peBlue	    db ?
    peFlags	    db ?
PALETTEENTRY	    ends

; Logical Palette
LOGPALETTE	    struc
    palVersion	    dw ?
    palNumEntries   dw ?
    palPalEntry     db ?  ; array of PALETTEENTRY
LOGPALETTE	    ends

; DRAWITEMSTRUCT for ownerdraw
DRAWITEMSTRUCT	    struc
    drCtlType	      dw ?
    drCtlID	      dw ?
    dritemID	      dw ?
    dritemAction      dw ?
    dritemState       dw ?
    drhwndItem	      dw ?
    drhDC	      dw ?
    drrcItem	      DB size RECT dup(?)
    dritemData	      dd ?
DRAWITEMSTRUCT ends

; DELETEITEMSTRUCT for ownerdraw
DELETEITEMSTRUCT    struc
    deCtlType	      dw ?
    deCtlID	      dw ?
    deitemID	      dw ?
    dehwndItem	      dw ?
    deitemData	      dd ?
DELETEITEMSTRUCT ends

; MEASUREITEMSTRUCT for ownerdraw
MEASUREITEMSTRUCT   struc
    meCtlType	      dw ?
    meCtlID	      dw ?
    meitemID	      dw ?
    meitemWidth       dw ?
    meitemHeight      dw ?
    meitemData	      dd ?
MEASUREITEMSTRUCT ends

; COMPAREITEMSTUCT for ownerdraw sorting
COMPAREITEMSTRUCT   struc
    coCtlType   dw ?
    coCtlID     dw ?
    cohwndItem  dw ?
    coitemID1   dw ?
    coitemData1 dd ?
    coitemID2   dw ?
    coitemData2 dd ?
COMPAREITEMSTRUCT   ends

; Owner draw control types
ODT_MENU      =  1
ODT_LISTBOX   =  2
ODT_COMBOBOX  =  3
ODT_BUTTON    =  4

; Owner draw actions
ODA_DRAWENTIRE = 1
ODA_SELECT     = 2
ODA_FOCUS      = 4

; Owner draw state
ODS_SELECTED   = 0001h
ODS_GRAYED     = 0002h
ODS_DISABLED   = 0004h
ODS_CHECKED    = 0008h
ODS_FOCUS      = 0010h

; PeekMessage() Options
PM_NOREMOVE    = 0000h
PM_REMOVE      = 0001h
PM_NOYIELD     = 0002h

; SetWindowPos Flags
SWP_NOSIZE       =  0001h
SWP_NOMOVE       =  0002h
SWP_NOZORDER     =  0004h
SWP_NOREDRAW     =  0008h
SWP_NOACTIVATE   =  0010h
SWP_DRAWFRAME    =  0020h
SWP_SHOWWINDOW   =  0040h
SWP_HIDEWINDOW   =  0080h
SWP_NOCOPYBITS   =  0100h
SWP_NOREPOSITION =  0200h


IFNDEF NOWINMESSAGES

; Listbox messages
LB_ADDSTRING	       = (WM_USER+1)
LB_INSERTSTRING        = (WM_USER+2)
LB_DELETESTRING        = (WM_USER+3)
LB_RESETCONTENT        = (WM_USER+5)
LB_SETSEL	       = (WM_USER+6)
LB_SETCURSEL	       = (WM_USER+7)
LB_GETSEL	       = (WM_USER+8)
LB_GETCURSEL	       = (WM_USER+9)
LB_GETTEXT	       = (WM_USER+10)
LB_GETTEXTLEN	       = (WM_USER+11)
LB_GETCOUNT	       = (WM_USER+12)
LB_SELECTSTRING        = (WM_USER+13)
LB_DIR		       = (WM_USER+14)
LB_GETTOPINDEX	       = (WM_USER+15)
LB_FINDSTRING	       = (WM_USER+16)
LB_GETSELCOUNT	       = (WM_USER+17)
LB_GETSELITEMS	       = (WM_USER+18)
LB_SETTABSTOPS	       = (WM_USER+19)
LB_GETHORIZONTALEXTENT = (WM_USER+20)
LB_SETHORIZONTALEXTENT = (WM_USER+21)
LB_SETTOPINDEX	       = (WM_USER+24)
LB_GETITEMRECT	       = (WM_USER+25)
LB_GETITEMDATA	       = (WM_USER+26)
LB_SETITEMDATA	       = (WM_USER+27)
LB_SELITEMRANGE        = (WM_USER+28)
LB_SETCARETINDEX       = (WM_USER+31)
LB_GETCARETINDEX       = (WM_USER+32)
IFNDEF NOWIN31
LB_SETITEMHEIGHT       = (WM_USER+33)
LB_GETITEMHEIGHT       = (WM_USER+34)
LB_FINDSTRINGEXACT     = (WM_USER+35)
ENDIF

ENDIF
; NOWINMESSAGES

; Listbox Styles
LBS_NOTIFY            = 0001h
LBS_SORT              = 0002h
LBS_NOREDRAW          = 0004h
LBS_MULTIPLESEL       = 0008h
LBS_OWNERDRAWFIXED    = 0010h
LBS_OWNERDRAWVARIABLE = 0020h
LBS_HASSTRINGS        = 0040h
LBS_USETABSTOPS       = 0080h
LBS_NOINTEGRALHEIGHT  = 0100h
LBS_MULTICOLUMN       = 0200h
LBS_WANTKEYBOARDINPUT = 0400h
LBS_EXTENDEDSEL	      = 0800h
LBS_STANDARD          = LBS_NOTIFY + LBS_SORT + WS_VSCROLL + WS_BORDER
LBS_DISABLENOSCROLL   = 1000h

; Listbox Notification Codes
LBN_ERRSPACE      =  (-2)
LBN_SELCHANGE     =  1
LBN_DBLCLK        =  2
LBN_SELCANCEL     =  3
LBN_SETFOCUS      =  4
LBN_KILLFOCUS     =  5

IFNDEF NOWINMESSAGES

; Edit Control Messages
EM_GETSEL              = (WM_USER+0)
EM_SETSEL              = (WM_USER+1)
EM_GETRECT             = (WM_USER+2)
EM_SETRECT             = (WM_USER+3)
EM_SETRECTNP           = (WM_USER+4)
EM_SCROLL              = (WM_USER+5)
EM_LINESCROLL          = (WM_USER+6)
EM_GETMODIFY           = (WM_USER+8)
EM_SETMODIFY           = (WM_USER+9)
EM_GETLINECOUNT        = (WM_USER+10)
EM_LINEINDEX           = (WM_USER+11)
EM_SETHANDLE           = (WM_USER+12)
EM_GETHANDLE           = (WM_USER+13)
EM_LINELENGTH          = (WM_USER+17)
EM_REPLACESEL          = (WM_USER+18)
EM_SETFONT             = (WM_USER+19)
EM_GETLINE             = (WM_USER+20)
EM_LIMITTEXT           = (WM_USER+21)
EM_CANUNDO             = (WM_USER+22)
EM_UNDO                = (WM_USER+23)
EM_FMTLINES            = (WM_USER+24)
EM_LINEFROMCHAR        = (WM_USER+25)
EM_SETWORDBREAK        = (WM_USER+26)
EM_SETTABSTOPS         = (WM_USER+27)
EM_SETPASSWORDCHAR     = (WM_USER+28)
EM_EMPTYUNDOBUFFER     = (WM_USER+29)
IFNDEF NOWIN31
EM_GETFIRSTVISIBLELINE = (WM_USER+30)
EM_SETREADONLY         = (WM_USER+31)
EM_SETWORDBREAKPROC    = (WM_USER+32)
EM_GETWORDBREAKPROC    = (WM_USER+33)
EM_GETPASSWORDCHAR     = (WM_USER+34)
ENDIF

ENDIF
; NOWINMESSAGES


; Edit Control Styles (low word)
ES_LEFT            = 0000h
ES_CENTER          = 0001h
ES_RIGHT           = 0002h
ES_MULTILINE       = 0004h
ES_UPPERCASE       = 0008h
ES_LOWERCASE       = 0010h
ES_PASSWORD        = 0020h
ES_AUTOVSCROLL     = 0040h
ES_AUTOHSCROLL     = 0080h
ES_NOHIDESEL       = 0100h
ES_OEMCONVERT      = 0400h
IFNDEF NOWIN31
ES_READONLY        = 0800h
ES_WANTRETURN      = 1000h
ENDIF


; Edit Control Notification Codes
EN_SETFOCUS        = 0100h
EN_KILLFOCUS       = 0200h
EN_CHANGE          = 0300h
EN_UPDATE          = 0400h
EN_ERRSPACE        = 0500h
EN_MAXTEXT         = 0501h
EN_HSCROLL         = 0601h
EN_VSCROLL         = 0602h

IFNDEF NOWINMESSAGES

; Button Control Messages
BM_GETCHECK	   = (WM_USER+0)
BM_SETCHECK	   = (WM_USER+1)
BM_GETSTATE	   = (WM_USER+2)
BM_SETSTATE	   = (WM_USER+3)
BM_SETSTYLE	   = (WM_USER+4)

ENDIF
; NOWINMESSAGES

; Button Control Styles (low word)
BS_PUSHBUTTON      = 00h
BS_DEFPUSHBUTTON   = 01h
BS_CHECKBOX        = 02h
BS_AUTOCHECKBOX    = 03h
BS_RADIOBUTTON     = 04h
BS_3STATE          = 05h
BS_AUTO3STATE      = 06h
BS_GROUPBOX        = 07h
BS_USERBUTTON      = 08h
BS_AUTORADIOBUTTON = 09h
BS_OWNERDRAW       = 0Bh
BS_LEFTTEXT        = 20h

; User Button Notification Codes
BN_CLICKED         = 0
BN_PAINT           = 1
BN_HILITE          = 2
BN_UNHILITE        = 3
BN_DISABLE         = 4
BN_DOUBLECLICKED   = 5

; Dialog Styles (low words)
DS_ABSALIGN        = 01h
DS_SYSMODAL        = 02h
DS_LOCALEDIT       = 20h  ;/* Edit items get Local storage. */
DS_SETFONT         = 40h  ;/* User specified font for Dlg controls */
DS_MODALFRAME      = 80h  ;/* Can be combined with WS_CAPTION  */
DS_NOIDLEMSG       = 100h ;/* WM_ENTERIDLE message will not be sent */

IFNDEF NOWINMESSAGES

; Dialog box messages
DM_GETDEFID	   = (WM_USER+0)
DM_SETDEFID	   = (WM_USER+1)

ENDIF   ;NOWINMESSAGES

; Dialog Codes
DLGC_WANTARROWS     = 0001h    ;  /* Control wants arrow keys         */
DLGC_WANTTAB        = 0002h    ;  /* Control wants tab keys           */
DLGC_WANTALLKEYS    = 0004h    ;  /* Control wants all keys           */
DLGC_WANTMESSAGE    = 0004h    ;  /* Pass message to control          */
DLGC_HASSETSEL      = 0008h    ;  /* Understands EM_SETSEL message    */
DLGC_DEFPUSHBUTTON  = 0010h    ;  /* Default pushbutton               */
DLGC_UNDEFPUSHBUTTON= 0020h    ;  /* Non-default pushbutton           */
DLGC_RADIOBUTTON    = 0040h    ;  /* Radio button                     */
DLGC_WANTCHARS      = 0080h    ;  /* Want WM_CHAR messages            */
DLGC_STATIC         = 0100h    ;  /* Static item: don't include       */
DLGC_BUTTON         = 2000h    ;  /* Button item: can be checked      */

; Combo Box return Values
CB_OKAY          =   0
CB_ERR           =   (-1)
CB_ERRSPACE      =   (-2)

; Combo Box Notification Codes
CBN_ERRSPACE     =   (-1)
CBN_SELCHANGE    =   1
CBN_DBLCLK       =   2
CBN_SETFOCUS     =   3
CBN_KILLFOCUS    =   4
CBN_EDITCHANGE   =   5
CBN_EDITUPDATE   =   6
CBN_DROPDOWN     =   7

; Combo Box styles (low words)
CBS_SIMPLE           = 0001h
CBS_DROPDOWN         = 0002h
CBS_DROPDOWNLIST     = 0003h
CBS_OWNERDRAWFIXED   = 0010h
CBS_OWNERDRAWVARIABLE= 0020h
CBS_AUTOHSCROLL      = 0040h
CBS_OEMCONVERT       = 0080h
CBS_SORT             = 0100h
CBS_HASSTRINGS       = 0200h
CBS_NOINTEGRALHEIGHT = 0400h

IFNDEF NOWINMESSAGES

; Combo Box messages
CB_GETEDITSEL	         = (WM_USER+0)
CB_LIMITTEXT	         = (WM_USER+1)
CB_SETEDITSEL	         = (WM_USER+2)
CB_ADDSTRING	         = (WM_USER+3)
CB_DELETESTRING          = (WM_USER+4)
CB_DIR		         = (WM_USER+5)
CB_GETCOUNT	         = (WM_USER+6)
CB_GETCURSEL	         = (WM_USER+7)
CB_GETLBTEXT	         = (WM_USER+8)
CB_GETLBTEXTLEN          = (WM_USER+9)
CB_INSERTSTRING          = (WM_USER+10)
CB_RESETCONTENT          = (WM_USER+11)
CB_FINDSTRING	         = (WM_USER+12)
CB_SELECTSTRING          = (WM_USER+13)
CB_SETCURSEL	         = (WM_USER+14)
CB_SHOWDROPDOWN          = (WM_USER+15)
CB_GETITEMDATA           = (WM_USER+16)
CB_SETITEMDATA           = (WM_USER+17)
IFNDEF NOWIN31
CB_GETDROPPEDCONTROLRECT = (WM_USER+18)
CB_SETITEMHEIGHT         = (WM_USER+19)
CB_GETITEMHEIGHT         = (WM_USER+20)
CB_SETEXTENDEDUI         = (WM_USER+21)
CB_GETEXTENDEDUI         = (WM_USER+22)
CB_GETDROPPEDSTATE       = (WM_USER+23)
CB_FINDSTRINGEXACT       = (WM_USER+24)
ENDIF

ENDIF ; NOWINMESSAGES

; Static Control styles (low word)
SS_LEFT            = 00h
SS_CENTER          = 01h
SS_RIGHT           = 02h
SS_ICON            = 03h
SS_BLACKRECT       = 04h
SS_GRAYRECT        = 05h
SS_WHITERECT       = 06h
SS_BLACKFRAME      = 07h
SS_GRAYFRAME       = 08h
SS_WHITEFRAME      = 09h
SS_SIMPLE          = 0Bh
SS_LEFTNOWORDWRAP  = 0Ch
SS_NOPREFIX        = 80h    ; Don't do "&" character translation

IFNDEF NOWIN31
IFNDEF NOWINMESSAGES

;Static Control Messages
STM_SETICON        = (WM_USER+0)
STM_GETICON        = (WM_USER+1)
ENDIF
ENDIF

; Scroll Bar Styles (low word)
SBS_HORZ                    = 0000h
SBS_VERT                    = 0001h
SBS_TOPALIGN                = 0002h
SBS_LEFTALIGN               = 0002h
SBS_BOTTOMALIGN             = 0004h
SBS_RIGHTALIGN              = 0004h
SBS_SIZEBOXTOPLEFTALIGN     = 0002h
SBS_SIZEBOXBOTTOMRIGHTALIGN = 0004h
SBS_SIZEBOX                 = 0008h

IFNDEF NOSYSMETRICS

; GetSystemMetrics() codes
SM_CXSCREEN           =  0
SM_CYSCREEN           =  1
SM_CXVSCROLL          =  2
SM_CYHSCROLL          =  3
SM_CYCAPTION          =  4
SM_CXBORDER           =  5
SM_CYBORDER           =  6
SM_CXDLGFRAME         =  7
SM_CYDLGFRAME         =  8
SM_CYVTHUMB           =  9
SM_CXHTHUMB           =  10
SM_CXICON             =  11
SM_CYICON             =  12
SM_CXCURSOR           =  13
SM_CYCURSOR           =  14
SM_CYMENU             =  15
SM_CXFULLSCREEN       =  16
SM_CYFULLSCREEN       =  17
SM_CYKANJIWINDOW      =  18
SM_MOUSEPRESENT       =  19
SM_CYVSCROLL          =  20
SM_CXHSCROLL          =  21
SM_DEBUG              =  22
SM_SWAPBUTTON         =  23
SM_RESERVED1          =  24
SM_RESERVED2          =  25
SM_RESERVED3          =  26
SM_RESERVED4          =  27
SM_CXMIN              =  28
SM_CYMIN              =  29
SM_CXSIZE             =  30
SM_CYSIZE             =  31
SM_CXFRAME            =  32
SM_CYFRAME            =  33
SM_CXMINTRACK         =  34
SM_CYMINTRACK         =  35
IFNDEF NOWIN31
SM_CXDOUBLECLK        =  36
SM_CYDOUBLECLK        =  37
SM_CXICONSPACING      =  38
SM_CYICONSPACING      =  39
SM_MENUDROPALIGNMENT  =  40
SM_PENWINDOWS         =  41
SM_DBCSENABLED        =  42
ENDIF
SM_CMETRICSMAX        =  43

ENDIF   ;NOSYSMETRICS

IFNDEF  NOCOLOR

COLOR_SCROLLBAR           = 0
COLOR_BACKGROUND          = 1
COLOR_ACTIVECAPTION       = 2
COLOR_INACTIVECAPTION     = 3
COLOR_MENU                = 4
COLOR_WINDOW              = 5
COLOR_WINDOWFRAME         = 6
COLOR_MENUTEXT            = 7
COLOR_WINDOWTEXT          = 8
COLOR_CAPTIONTEXT         = 9
COLOR_ACTIVEBORDER        = 10
COLOR_INACTIVEBORDER      = 11
COLOR_APPWORKSPACE        = 12
COLOR_HIGHLIGHT           = 13
COLOR_HIGHLIGHTTEXT       = 14
COLOR_BTNFACE             = 15
COLOR_BTNSHADOW           = 16
COLOR_GRAYTEXT            = 17
COLOR_BTNTEXT             = 18
IFNDEF NOWIN31
COLOR_INACTIVECAPTIONTEXT = 19
COLOR_BTNHILIGHT          = 20
ENDIF
ENDIF   ;NOCOLOR

; Commands to pass WinHelp()
HELP_CONTEXT	=0001h	;/* Display topic in ulTopic */
HELP_QUIT	=0002h	;/* Terminate help */
HELP_INDEX	=0003h	;/* Display index */
HELP_HELPONHELP =0004h	;/* Display help on using help */
HELP_SETINDEX	=0005h	;/* Set the current Index for multi index help */
HELP_KEY	=0101h	;/* Display topic for keyword in offabData */

IFNDEF NOCOMM

NOPARITY        =   0
ODDPARITY       =   1
EVENPARITY      =   2
MARKPARITY      =   3
SPACEPARITY     =   4

ONESTOPBIT      =   0
ONE5STOPBITS    =   1
TWOSTOPBITS     =   2

IGNORE          =   0      ; /* Ignore signal    */
INFINITE        =   0FFFFh ; /* Infinite timeout */

; Error Flags
CE_RXOVER       =    0001h ; /* Receive Queue overflow       */
CE_OVERRUN      =    0002h ; /* Receive Overrun Error        */
CE_RXPARITY     =    0004h ; /* Receive Parity Error         */
CE_FRAME        =    0008h ; /* Receive Framing error        */
CE_BREAK        =    0010h ; /* Break Detected               */
CE_CTSTO        =    0020h ; /* CTS Timeout                  */
CE_DSRTO        =    0040h ; /* DSR Timeout                  */
CE_RLSDTO       =    0080h ; /* RLSD Timeout                 */
CE_TXFULL       =    0100h ; /* TX Queue is full             */
CE_PTO          =    0200h ; /* LPTx Timeout                 */
CE_IOE          =    0400h ; /* LPTx I/O Error               */
CE_DNS          =    0800h ; /* LPTx Device not selected     */
CE_OOP          =    1000h ; /* LPTx Out-Of-Paper            */
CE_MODE         =    8000h ; /* Requested mode unsupported   */

IE_BADID        =    (-1)  ;  /* Invalid or unsupported id    */
IE_OPEN         =    (-2)  ;  /* Device Already Open          */
IE_NOPEN        =    (-3)  ;  /* Device Not Open              */
IE_MEMORY       =    (-4)  ;  /* Unable to allocate queues    */
IE_DEFAULT      =    (-5)  ;  /* Error in default parameters  */
IE_HARDWARE     =    (-10) ;  /* Hardware Not Present         */
IE_BYTESIZE     =    (-11) ;  /* Illegal Byte Size            */
IE_BAUDRATE     =    (-12) ;  /* Unsupported BaudRate         */

; Events
EV_RXCHAR       =    0001h ; /* Any Character received       */
EV_RXFLAG       =    0002h ; /* Received certain character   */
EV_TXEMPTY      =    0004h ; /* Transmitt Queue Empty        */
EV_CTS          =    0008h ; /* CTS changed state            */
EV_DSR          =    0010h ; /* DSR changed state            */
EV_RLSD         =    0020h ; /* RLSD changed state           */
EV_BREAK        =    0040h ; /* BREAK received               */
EV_ERR          =    0080h ; /* Line status error occurred   */
EV_RING         =    0100h ; /* Ring signal detected         */
EV_PERR         =    0200h ; /* Printer error occured        */
EV_CTSS         =    0400h ; /* CTS state                    */
EV_DSRS         =    0800h ; /* DSR state                    */
EV_RLSDS        =    1000h ; /* RLSD state                   */
EV_RingTe       =    2000h ; /* Ring Trailing Edge Indicator */


; Escape Functions
SETXOFF         =    1     ;  /* Simulate XOFF received       */
SETXON          =    2     ;  /* Simulate XON received        */
SETRTS          =    3     ;  /* Set RTS high                 */
CLRRTS          =    4     ;  /* Set RTS low                  */
SETDTR          =    5     ;  /* Set DTR high                 */
CLRDTR          =    6     ;  /* Set DTR low                  */
RESETDEV        =    7     ;  /* Reset device if possible     */

LPTx            =    80h   ; /* Set if ID is for LPT device  */

IFNDEF NOWIN31
; new escape functions
GETMAXLPT   equ  8	   ; Max supported LPT id
GETMAXCOM   equ  9	   ; Max supported COM id
GETBASEIRQ  equ 10	   ; Get port base & irq for a port

; Comm Baud Rate indices
CBR_110     equ 0FF10h
CBR_300     equ 0FF11h
CBR_600     equ 0FF12h
CBR_1200    equ 0FF13h
CBR_2400    equ 0FF14h
CBR_4800    equ 0FF15h
CBR_9600    equ 0FF16h
CBR_14400   equ 0FF17h
CBR_19200   equ 0FF18h
;		0FF19h	(reserved)
;		0FF1Ah	(reserved)
CBR_38400   equ 0FF1Bh
;		0FF1Ch	(reserved)
;		0FF1Dh	(reserved)
;		0FF1Eh	(reserved)
CBR_56000   equ 0FF1Fh
;		0FF20h	(reserved)
;		0FF21h	(reserved)
;		0FF22h	(reserved)
CBR_128000  equ 0FF23h
;		0FF24h	(reserved)
;		0FF25h	(reserved)
;		0FF26h	(reserved)
CBR_256000  equ 0FF27h

; notifications passed in low word of lParam on WM_COMMNOTIFY messages
CN_RECEIVE  equ 1	    ; bytes are available in the input queue
CN_TRANSMIT equ 2	    ; fewer than wOutTrigger bytes still
			    ; remain in the output queue waiting
			    ; to be transmitted.
CN_EVENT    equ 4	    ; an enabled event has occurred

ENDIF


DCB     struc
    DCB_Id             db ?  ; /* Internal Device ID              */
    DCB_BaudRate       dw ?  ; /* Baudrate at which runing        */
    DCB_ByteSize       db ?  ; /* Number of bits/byte, 4-8        */
    DCB_Parity         db ?  ; /* 0-4=None,Odd,Even,Mark,Space    */
    DCB_StopBits       db ?  ; /* 0,1,2 = 1, 1.5, 2               */
    DCB_RlsTimeout     dw ?  ; /* Timeout for RLSD to be set      */
    DCB_CtsTimeout     dw ?  ; /* Timeout for CTS to be set       */
    DCB_DsrTimeout     dw ?  ; /* Timeout for DSR to be set       */

    DCB_BitMask1       db ?

    ;   BYTE fBinary: 1;     /* Binary Mode (skip EOF check     */
    ;   BYTE fRtsDisable:1;  /* Don't assert RTS at init time   */
    ;   BYTE fParity: 1;     /* Enable parity checking          */
    ;   BYTE fOutxCtsFlow:1; /* CTS handshaking on output       */
    ;   BYTE fOutxDsrFlow:1; /* DSR handshaking on output       */
    ;   BYTE fDummy: 2;      /* Reserved                        */
    ;   BYTE fDtrDisable:1;  /* Don't assert DTR at init time   */

    DCB_BitMask2       db ?

    ;   BYTE fOutX: 1;       /* Enable output X-ON/X-OFF        */
    ;   BYTE fInX: 1;        /* Enable input X-ON/X-OFF         */
    ;   BYTE fPeChar: 1;     /* Enable Parity Err Replacement   */
    ;   BYTE fNull: 1;       /* Enable Null stripping           */
    ;   BYTE fChEvt: 1;      /* Enable Rx character event.      */
    ;   BYTE fDtrflow: 1;    /* DTR handshake on input          */
    ;   BYTE fRtsflow: 1;    /* RTS handshake on input          */
    ;   BYTE fDummy2: 1;

    DCB_XonChar        db ? ; /* Tx and Rx X-ON character        */
    DCB_XoffChar       db ? ; /* Tx and Rx X-OFF character       */
    DCB_XonLim         dw ? ; /* Transmit X-ON threshold         */
    DCB_XoffLim        dw ? ; /* Transmit X-OFF threshold        */
    DCB_PeChar         db ? ; /* Parity error replacement char   */
    DCB_EofChar        db ? ; /* End of Input character          */
    DCB_EvtChar        db ? ; /* Recieved Event character        */
    DCB_TxDelay        dw ? ; /* Amount of time between chars    */
DCB     ends

COMSTAT     struc
    COMS_BitMask1   db ?

;    BYTE fCtsHold: 1;   /* Transmit is on CTS hold         */
;    BYTE fDsrHold: 1;   /* Transmit is on DSR hold         */
;    BYTE fRlsdHold: 1;  /* Transmit is on RLSD hold        */
;    BYTE fXoffHold: 1;  /* Received handshake              */
;    BYTE fXoffSent: 1;  /* Issued handshake                */
;    BYTE fEof: 1;       /* End of file character found     */
;    BYTE fTxim: 1;      /* Character being transmitted     */


    COMS_cbInQue    dw ?  ;   /* count of characters in Rx Queue */
    COMS_cbOutQue   dw ?  ;   /* count of characters in Tx Queue */
COMSTAT     ends

ENDIF       ;NOCOM

;
; Installable Driver Support
;
; Driver Messages
DRV_LOAD	    = 0001h
DRV_ENABLE	    = 0002h
DRV_OPEN	    = 0003h
DRV_CLOSE	    = 0004h
DRV_DISABLE	    = 0005h
DRV_FREE	    = 0006h
DRV_CONFIGURE	    = 0007h
DRV_QUERYCONFIGURE  = 0008h
DRV_INSTALL	    = 0009h
DRV_REMOVE	    = 000Ah
DRV_EXITSESSION	    = 000Bh
DRV_POWER	    = 000Fh
DRV_RESERVED	    = 0800h
DRV_USER	    = 4000h

;LPARAM of DRV_CONFIGURE message and return values
DRVCONFIGINFO struc
    DRVCNF_dwDCISize	      dw ?
    DRVCNF_lpszDCISectionName dd ?
    DRVCNF_lpszDCIAliasName   dd ?
DRVCONFIGINFO ends

DRVCNF_CANCEL	    = 0000h
DRVCNF_OK	    = 0001h
DRVCNF_RESTART	    = 0002h


IFNDEF  NOKERNEL
;
; Common Kernel errors
; 
ERR_GALLOC	= 01030h	; GlobalAlloc Failed
ERR_GREALLOC	= 01031h	; GlobalReAlloc Failed
ERR_GLOCK	= 01032h	; GlobalLock Failed
ERR_LALLOC	= 01033h	; LocalAlloc Failed
ERR_LREALLOC	= 01034h	; LocalReAlloc Failed
ERR_LLOCK	= 01035h	; LocalLock Failed
ERR_ALLOCRES	= 01036h	; AllocResource Failed
ERR_LOCKRES	= 01037h	; LockResource Failed
ERR_LOADMODULE  = 01038h	; LoadModule failed

;
; Common User Errors 
;
ERR_CREATEDLG	     =	01045h ; /* Create Dlg failure due to LoadMenu failure */
ERR_CREATEDLG2	     =	01046h ; /* Create Dlg failure due to CreateWindow Failure */
ERR_REGISTERCLASS    =	01047h ; /* RegisterClass failure due to Class already registered */
ERR_DCBUSY	     =	01048h ; /* DC Cache is full */
ERR_CREATEWND	     =	01049h ; /* Create Wnd failed due to class not found */
ERR_STRUCEXTRA	     =  01050h ; /* Unallocated Extra space is used */
ERR_LOADSTR	     =	01051h ; /* LoadString() failed */
ERR_LOADMENU	     =	01052h ; /* LoadMenu Failed     */
ERR_NESTEDBEGINPAINT =  01053h ; /* Nested BeginPaint() calls */
ERR_BADINDEX	     =  01054h ; /* Bad index to Get/Set Class/Window Word/Long */
ERR_CREATEMENU	     =	01055h ; /* Error creating menu */

;
; Common GDI Errors
;
ERR_CREATEDC	    = 01070h	; /* CreateDC/CreateIC etc., failure */
ERR_CREATEMETA      = 01071h	; /* CreateMetafile failure */
ERR_DELOBJSELECTED  = 01072h	; /* Bitmap being deleted is selected into DC */
ERR_SELBITMAP	    = 01073h	; /* Bitmap being selected is already selected elsewhere */

ENDIF	    ;NOKERNEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\winmem32.h ===
/*
 * Function protypes and general defines for WINMEM32 DLL
 *	Version 1.00
 *
 * NOTE that WINDOWS.H must be included before this file.
 *
 */

/*
 *
 * The functions
 *
 */
WORD	FAR PASCAL GetWinMem32Version(void);
WORD	FAR PASCAL Global32Alloc(DWORD, LPWORD, DWORD, WORD);
WORD	FAR PASCAL Global32Realloc(WORD, DWORD, WORD);
WORD	FAR PASCAL Global32Free(WORD, WORD);
WORD	FAR PASCAL Global16PointerAlloc(WORD, DWORD, LPDWORD, DWORD, WORD);
WORD	FAR PASCAL Global16PointerFree(WORD, DWORD, WORD);
WORD	FAR PASCAL Global32CodeAlias(WORD, LPWORD, WORD);
WORD	FAR PASCAL Global32CodeAliasFree(WORD, WORD, WORD);

/*
 *
 * Error Codes
 *
 */
#define WM32_Invalid_Func	0001
#define WM32_Invalid_Flags	0002
#define WM32_Invalid_Arg	0003
#define WM32_Insufficient_Sels	0004
#define WM32_Insufficient_Mem	0005
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\sys\timeb.h ===
/***
*sys\timeb.h - definition/declarations for ftime()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file define the ftime() function and the types it uses.
*   [System V]
*
****/

#ifndef _INC_TIMEB

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* structure returned by ftime system call */

#ifndef _TIMEB_DEFINED
#pragma pack(2)

struct _timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
    };
#endif 

#pragma pack()
#define _TIMEB_DEFINED
#endif 


/* function prototypes */

void __cdecl _ftime(struct _timeb *);

#ifndef __STDC__
/* Non-ANSI name for compatibility */
void __cdecl ftime(struct timeb *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_TIMEB
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\windowsx.h ===
/*****************************************************************************\
*                                                                             *
* windowsx.h -  Macro APIs, window message crackers, and control APIs         *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_WINDOWSX
#define _INC_WINDOWSX

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****** KERNEL Macro APIs ****************************************************/

#define     GetInstanceModule(hInstance) \
                GetModuleHandle((LPCSTR)MAKELP(0, hInstance))

#define     GlobalPtrHandle(lp)         \
                ((HGLOBAL)LOWORD(GlobalHandle(SELECTOROF(lp))))

#define     GlobalLockPtr(lp)		\
                ((BOOL)SELECTOROF(GlobalLock(GlobalPtrHandle(lp))))
#define     GlobalUnlockPtr(lp) 	\
                GlobalUnlock(GlobalPtrHandle(lp))

#define     GlobalAllocPtr(flags, cb)	\
                (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalReAllocPtr(lp, cbNew, flags)	\
                (GlobalUnlockPtr(lp), GlobalLock(GlobalReAlloc(GlobalPtrHandle(lp) , (cbNew), (flags))))
#define     GlobalFreePtr(lp)		\
                (GlobalUnlockPtr(lp), (BOOL)GlobalFree(GlobalPtrHandle(lp)))

/****** GDI Macro APIs *******************************************************/

#define     DeletePen(hpen)	    DeleteObject((HGDIOBJ)(HPEN)(hpen))
#define     SelectPen(hdc, hpen)    ((HPEN)SelectObject((hdc), (HGDIOBJ)(HPEN)(hpen)))
#define     GetStockPen(i)	    ((HPEN)GetStockObject(i))

#define     DeleteBrush(hbr)	    DeleteObject((HGDIOBJ)(HBRUSH)(hbr))
#define     SelectBrush(hdc, hbr)   ((HBRUSH)SelectObject((hdc), (HGDIOBJ)(HBRUSH)(hbr)))
#define     GetStockBrush(i)	    ((HBRUSH)GetStockObject(i))

#define     DeleteRgn(hrgn)	    DeleteObject((HGDIOBJ)(HRGN)(hrgn))

#define     CopyRgn(hrgnDst, hrgnSrc)               CombineRgn(hrgnDst, hrgnSrc, 0, RGN_COPY)
#define     IntersectRgn(hrgnResult, hrgnA, hrgnB)  CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define     SubtractRgn(hrgnResult, hrgnA, hrgnB)   CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define     UnionRgn(hrgnResult, hrgnA, hrgnB)      CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define     XorRgn(hrgnResult, hrgnA, hrgnB)        CombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

#define     DeletePalette(hpal)     DeleteObject((HGDIOBJ)(HPALETTE)(hpal))

#define     DeleteFont(hfont)	    DeleteObject((HGDIOBJ)(HFONT)(hfont))
#define     SelectFont(hdc, hfont)  ((HFONT)SelectObject((hdc), (HGDIOBJ)(HFONT)(hfont)))
#define     GetStockFont(i)	    ((HFONT)GetStockObject(i))

#define     DeleteBitmap(hbm)       DeleteObject((HGDIOBJ)(HBITMAP)(hbm))
#define     SelectBitmap(hdc, hbm)  ((HBITMAP)SelectObject((hdc), (HGDIOBJ)(HBITMAP)(hbm)))

#define     InsetRect(lprc, dx, dy) InflateRect((lprc), -(dx), -(dy))

/****** USER Macro APIs ******************************************************/

#define     GetWindowInstance(hwnd) ((HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE))

#define     GetWindowStyle(hwnd)    ((DWORD)GetWindowLong(hwnd, GWL_STYLE))
#define     GetWindowExStyle(hwnd)  ((DWORD)GetWindowLong(hwnd, GWL_EXSTYLE))

#define     GetWindowOwner(hwnd)    GetWindow(hwnd, GW_OWNER)

#define     GetFirstChild(hwnd)     GetTopWindow(hwnd)
#define     GetFirstSibling(hwnd)   GetWindow(hwnd, GW_HWNDFIRST)
#define     GetLastSibling(hwnd)    GetWindow(hwnd, GW_HWNDLAST)
#define     GetNextSibling(hwnd)    GetWindow(hwnd, GW_HWNDNEXT)
#define     GetPrevSibling(hwnd)    GetWindow(hwnd, GW_HWNDPREV)

#define     GetWindowID(hwnd)	    GetDlgCtrlID(hwnd)

#define     SetWindowRedraw(hwnd, fRedraw)  \
                    ((void)SendMessage(hwnd, WM_SETREDRAW, (WPARAM)(BOOL)(fRedraw), 0L))

#define     SubclassWindow(hwnd, lpfn)	\
		((WNDPROC)SetWindowLong((hwnd), GWL_WNDPROC, (LPARAM)(WNDPROC)(lpfn)))

#define     IsMinimized(hwnd)	IsIconic(hwnd)
#define     IsMaximized(hwnd)	IsZoomed(hwnd)
#define     IsRestored(hwnd)    ((GetWindowStyle(hwnd) & (WS_MINIMIZE | WS_MAXIMIZE)) == 0L)

#define     SetWindowFont(hwnd, hfont, fRedraw) FORWARD_WM_SETFONT((hwnd), (hfont), (fRedraw), SendMessage)

#define     GetWindowFont(hwnd)                 FORWARD_WM_GETFONT((hwnd), SendMessage)

#if (WINVER >= 0x030a)
#define     MapWindowRect(hwndFrom, hwndTo, lprc) \
                    MapWindowPoints((hwndFrom), (hwndTo), (POINT FAR*)(lprc), 2)
#endif  /* WINVER >= 0x030a */

#define     IsLButtonDown()	(GetKeyState(VK_LBUTTON) < 0)
#define     IsRButtonDown()	(GetKeyState(VK_RBUTTON) < 0)
#define     IsMButtonDown()	(GetKeyState(VK_MBUTTON) < 0)

#define     SubclassDialog(hwndDlg, lpfn) \
		((DLGPROC)SetWindowLong(hwndDlg, DWL_DLGPROC, (LPARAM)(DLGPROC)(lpfn)))

#define     SetDlgMsgResult(hwnd, msg, result)	 \
    (((msg) == WM_CTLCOLOR || (msg) == WM_COMPAREITEM || (msg) == WM_VKEYTOITEM ||  \
    (msg) == WM_CHARTOITEM || (msg) == WM_QUERYDRAGICON || (msg) == WM_INITDIALOG)  \
    ? (BOOL)LOWORD(result) : (SetWindowLong((hwnd), DWL_MSGRESULT, (LPARAM)(LRESULT)(result)), TRUE))

#define     DefDlgProcEx(hwnd, msg, wParam, lParam, pfRecursion) \
    (*(pfRecursion) = TRUE, DefDlgProc(hwnd, msg, wParam, lParam))

#define     CheckDefDlgRecursion(pfRecursion) \
    if (*(pfRecursion)) { *(pfRecursion) = FALSE; return FALSE; }

/****** Message crackers ****************************************************/

#define HANDLE_MSG(hwnd, message, fn)    \
    case (message): return HANDLE_##message((hwnd), (wParam), (lParam), (fn))

/* void Cls_OnCompacting(HWND hwnd, UINT compactRatio); */
#define HANDLE_WM_COMPACTING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_COMPACTING(hwnd, compactRatio, fn) \
    (void)(fn)((hwnd), WM_COMPACTING, (WPARAM)(UINT)(compactRatio), 0L)

/* void Cls_OnWinIniChange(HWND hwnd, LPCSTR lpszSectionName); */
#define HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_WININICHANGE(hwnd, lpszSectionName, fn) \
    (void)(fn)((hwnd), WM_WININICHANGE, 0, (LPARAM)(LPCSTR)(lpszSectionName))

/* void Cls_OnSysColorChange(HWND hwnd); */
#define HANDLE_WM_SYSCOLORCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_SYSCOLORCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_SYSCOLORCHANGE, 0, 0L)

/* BOOL Cls_OnQueryNewPalette(HWND hwnd); */
#define HANDLE_WM_QUERYNEWPALETTE(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYNEWPALETTE(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYNEWPALETTE, 0, 0L)

/* void Cls_OnPaletteIsChanging(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTEISCHANGING(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTEISCHANGING(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTEISCHANGING, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange); */
#define HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_PALETTECHANGED(hwnd, hwndPaletteChange, fn) \
    (void)(fn)((hwnd), WM_PALETTECHANGED, (WPARAM)(HWND)(hwndPaletteChange), 0L)

/* void Cls_OnFontChange(HWND hwnd); */
#define HANDLE_WM_FONTCHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_FONTCHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_FONTCHANGE, 0, 0L)

/* void Cls_OnSpoolerStatus(HWND hwnd, UINT status, int cJobInQueue); */
#define HANDLE_WM_SPOOLERSTATUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SPOOLERSTATUS(hwnd, status, cJobInQueue, fn) \
    (void)(fn)((hwnd), WM_SPOOLERSTATUS, (WPARAM)(status), MAKELPARAM((UINT)(cJobInQueue), 0))

/* void Cls_OnDevModeChange(HWND hwnd, LPCSTR lpszDeviceName); */
#define HANDLE_WM_DEVMODECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_DEVMODECHANGE(hwnd, lpszDeviceName, fn) \
    (void)(fn)((hwnd), WM_DEVMODECHANGE, 0,(LPARAM)(LPCSTR)(lpszDeviceName))

/* void Cls_OnTimeChange(HWND hwnd); */
#define HANDLE_WM_TIMECHANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_TIMECHANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_TIMECHANGE, 0, 0L)

/* void Cls_OnPower(HWND hwnd, int code); */
#define HANDLE_WM_POWER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_POWER(hwnd, code, fn) \
    (void)(fn)((hwnd), WM_POWER, (WPARAM)(code), 0L)

/* BOOL Cls_OnQueryEndSession(HWND hwnd); */
#define HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYENDSESSION(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYENDSESSION, 0, 0L)

/* void Cls_OnEndSession(HWND hwnd, BOOL fEnding); */
#define HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENDSESSION(hwnd, fEnding, fn) \
    (void)(fn)((hwnd), WM_ENDSESSION, (WPARAM)(BOOL)(fEnding), 0L)

/* void Cls_OnQuit(HWND hwnd, int exitCode); */
#define HANDLE_WM_QUIT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_QUIT(hwnd, exitCode, fn) \
    (void)(fn)((hwnd), WM_QUIT, (WPARAM)(exitCode), 0L)

/* void Cls_OnSystemError(HWND hwnd, int errCode); */
#define HANDLE_WM_SYSTEMERROR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam)), 0L)
#define FORWARD_WM_SYSTEMERROR(hwnd, errCode, fn) \
    (void)(fn)((hwnd), WM_SYSTEMERROR, (WPARAM)(errCode), 0L)

/* BOOL Cls_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_CREATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (CREATESTRUCT FAR*)(lParam)) ? 0L : (LRESULT)-1L)
#define FORWARD_WM_CREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_CREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* BOOL Cls_OnNCCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct) */
#define HANDLE_WM_NCCREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (CREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCCREATE, 0, (LPARAM)(CREATESTRUCT FAR*)(lpCreateStruct))

/* void Cls_OnDestroy(HWND hwnd); */
#define HANDLE_WM_DESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROY, 0, 0L)

/* void Cls_OnNCDestroy(HWND hwnd); */
#define HANDLE_WM_NCDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_NCDESTROY(hwnd, fn) \
    (void)(fn)((hwnd), WM_NCDESTROY, 0, 0L)

/* void Cls_OnShowWindow(HWND hwnd, BOOL fShow, UINT status); */
#define HANDLE_WM_SHOWWINDOW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_SHOWWINDOW(hwnd, fShow, status, fn) \
    (void)(fn)((hwnd), WM_SHOWWINDOW, (WPARAM)(BOOL)(fShow), MAKELPARAM((UINT)(status), 0))

/* void Cls_OnSetRedraw(HWND hwnd, BOOL fRedraw); */
#define HANDLE_WM_SETREDRAW(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_SETREDRAW(hwnd, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETREDRAW, (WPARAM)(fRedraw), 0L)

/* void Cls_OnEnable(HWND hwnd, BOOL fEnable); */
#define HANDLE_WM_ENABLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam)), 0L)
#define FORWARD_WM_ENABLE(hwnd, fEnable, fn) \
    (void)(fn)((hwnd), WM_ENABLE, (WPARAM)(BOOL)(fEnable), 0L)

/* void Cls_OnSetText(HWND hwnd, LPCSTR lpszText); */
#define HANDLE_WM_SETTEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (LPCSTR)(lParam)), 0L)
#define FORWARD_WM_SETTEXT(hwnd, lpszText, fn) \
    (void)(fn)((hwnd), WM_SETTEXT, 0, (LPARAM)(LPCSTR)(lpszText))

/* INT Cls_OnGetText(HWND hwnd, int cchTextMax, LPSTR lpszText) */
#define HANDLE_WM_GETTEXT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (int)(wParam), (LPSTR)(lParam))
#define FORWARD_WM_GETTEXT(hwnd, cchTextMax, lpszText, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXT, (WPARAM)(int)(cchTextMax), (LPARAM)(LPSTR)(lpszText))

/* INT Cls_OnGetTextLength(HWND hwnd); */
#define HANDLE_WM_GETTEXTLENGTH(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)(hwnd)
#define FORWARD_WM_GETTEXTLENGTH(hwnd, fn) \
    (int)(DWORD)(fn)((hwnd), WM_GETTEXTLENGTH, 0, 0L)

/* BOOL Cls_OnWindowPosChanging(HWND hwnd, WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGING(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (WINDOWPOS FAR*)(lParam))
#define FORWARD_WM_WINDOWPOSCHANGING(hwnd, lpwpos, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_WINDOWPOSCHANGING, 0, (LPARAM)(WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnWindowPosChanged(HWND hwnd, const WINDOWPOS FAR* lpwpos); */
#define HANDLE_WM_WINDOWPOSCHANGED(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const WINDOWPOS FAR*)(lParam)), 0L)
#define FORWARD_WM_WINDOWPOSCHANGED(hwnd, lpwpos, fn) \
    (void)(fn)((hwnd), WM_WINDOWPOSCHANGED, 0, (LPARAM)(const WINDOWPOS FAR*)(lpwpos))

/* void Cls_OnMove(HWND hwnd, int x, int y); */
#define HANDLE_WM_MOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_MOVE(hwnd, x, y, fn) \
    (void)(fn)((hwnd), WM_MOVE, 0, MAKELPARAM((int)(x), (int)(y)))

/* void Cls_OnSize(HWND hwnd, UINT state, int cx, int cy); */
#define HANDLE_WM_SIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SIZE(hwnd, state, cx, cy, fn) \
    (void)(fn)((hwnd), WM_SIZE, (WPARAM)(UINT)(state), MAKELPARAM((int)(cx), (int)(cy)))

/* void Cls_OnClose(HWND hwnd); */
#define HANDLE_WM_CLOSE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLOSE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLOSE, 0, 0L)

/* BOOL Cls_OnQueryOpen(HWND hwnd); */
#define HANDLE_WM_QUERYOPEN(hwnd, wParam, lParam, fn) \
    MAKELRESULT((BOOL)(fn)(hwnd), 0)
#define FORWARD_WM_QUERYOPEN(hwnd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_QUERYOPEN, 0, 0L)

/* void Cls_OnGetMinMaxInfo(HWND hwnd, MINMAXINFO FAR* lpMinMaxInfo); */
#define HANDLE_WM_GETMINMAXINFO(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MINMAXINFO FAR*)(lParam)), 0L)
#define FORWARD_WM_GETMINMAXINFO(hwnd, lpMinMaxInfo, fn) \
    (void)(fn)((hwnd), WM_GETMINMAXINFO, 0, (LPARAM)(MINMAXINFO FAR*)(lpMinMaxInfo))

/* void Cls_OnPaint(HWND hwnd); */
#define HANDLE_WM_PAINT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PAINT(hwnd, fn) \
    (void)(fn)((hwnd), WM_PAINT, 0, 0L)

/* BOOL Cls_OnEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ERASEBKGND(hwnd, hdc, fn) \
   (BOOL)(DWORD)(fn)((hwnd), WM_ERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* BOOL Cls_OnIconEraseBkgnd(HWND hwnd, HDC hdc); */
#define HANDLE_WM_ICONERASEBKGND(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HDC)(wParam))
#define FORWARD_WM_ICONERASEBKGND(hwnd, hdc, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_ICONERASEBKGND, (WPARAM)(HDC)(hdc), 0L)

/* void Cls_OnNCPaint(HWND hwnd, HRGN hrgn); */
#define HANDLE_WM_NCPAINT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HRGN)(wParam)), 0L)
#define FORWARD_WM_NCPAINT(hwnd, hrgn, fn) \
    (void)(fn)((hwnd), WM_NCPAINT, (WPARAM)(HRGN)(hrgn), 0L)

/* UINT Cls_OnNCCalcSize(HWND hwnd, BOOL fCalcValidRects, NCCALCSIZE_PARAMS FAR* lpcsp) */
#define HANDLE_WM_NCCALCSIZE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (NCCALCSIZE_PARAMS FAR*)(lParam))
#define FORWARD_WM_NCCALCSIZE(hwnd, fCalcValidRects, lpcsp, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCCALCSIZE, (WPARAM)(fCalcValidRects), (LPARAM)(NCCALCSIZE_PARAMS FAR*)(lpcsp))

/* UINT Cls_OnNCHitTest(HWND hwnd, int x, int y); */
#define HANDLE_WM_NCHITTEST(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_NCHITTEST(hwnd, x, y, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_NCHITTEST, 0, MAKELPARAM((int)(x), (int)(y)))

/* HICON Cls_OnQueryDragIcon(HWND hwnd); */
#define HANDLE_WM_QUERYDRAGICON(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_QUERYDRAGICON(hwnd, fn) \
    (HICON)(UINT)(DWORD)(fn)((hwnd), WM_QUERYDRAGICON, 0, 0L)

#ifdef _INC_SHELLAPI
/* void Cls_OnDropFiles(HWND hwnd, HDROP hdrop); */
#define HANDLE_WM_DROPFILES(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HDROP)(wParam)), 0L)
#define FORWARD_WM_DROPFILES(hwnd, hdrop, fn) \
    (void)(fn)((hwnd), WM_DROPFILES, (WPARAM)(hdrop), 0L)
#endif  /* _INC_SHELLAPI */

/* void Cls_OnActivate(HWND hwnd, UINT state, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_ACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATE(hwnd, state, hwndActDeact, fMinimized, fn) \
    (void)(fn)((hwnd), WM_ACTIVATE, (WPARAM)(UINT)(state), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnActivateApp(HWND hwnd, BOOL fActivate, HTASK htaskActDeact); */
#define HANDLE_WM_ACTIVATEAPP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HTASK)LOWORD(lParam)), 0L)
#define FORWARD_WM_ACTIVATEAPP(hwnd, fActivate, htaskActDeact, fn) \
    (void)(fn)((hwnd), WM_ACTIVATEAPP, (WPARAM)(BOOL)(fActivate), MAKELPARAM((htaskActDeact),0))

/* BOOL Cls_OnNCActivate(HWND hwnd, BOOL fActive, HWND hwndActDeact, BOOL fMinimized); */
#define HANDLE_WM_NCACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (BOOL)HIWORD(lParam))
#define FORWARD_WM_NCACTIVATE(hwnd, fActive, hwndActDeact, fMinimized, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_NCACTIVATE, (WPARAM)(BOOL)(fActive), MAKELPARAM((UINT)(HWND)(hwndActDeact), (UINT)(BOOL)(fMinimized)))

/* void Cls_OnSetFocus(HWND hwnd, HWND hwndOldFocus) */
#define HANDLE_WM_SETFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_SETFOCUS(hwnd, hwndOldFocus, fn) \
    (void)(fn)((hwnd), WM_SETFOCUS, (WPARAM)(HWND)(hwndOldFocus), 0L)

/* void Cls_OnKillFocus(HWND hwnd, HWND hwndNewFocus); */
#define HANDLE_WM_KILLFOCUS(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_KILLFOCUS(hwnd, hwndNewFocus, fn) \
    (void)(fn)((hwnd), WM_KILLFOCUS, (WPARAM)(HWND)(hwndNewFocus), 0L)

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_KEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_KEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_KEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_CHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_CHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_DEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_DEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_DEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat),0))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), TRUE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYDOWN(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYDOWN, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags); */
#define HANDLE_WM_SYSKEYUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), FALSE, (int)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSKEYUP(hwnd, vk, cRepeat, flags, fn) \
    (void)(fn)((hwnd), WM_SYSKEYUP, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(cRepeat), (UINT)(flags)))

/* void Cls_OnSysChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnSysDeadChar(HWND hwnd, UINT ch, int cRepeat); */
#define HANDLE_WM_SYSDEADCHAR(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_SYSDEADCHAR(hwnd, ch, cRepeat, fn) \
    (void)(fn)((hwnd), WM_SYSDEADCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(cRepeat), 0))

/* void Cls_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MOUSEMOVE(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MOUSEMOVE, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_LBUTTONDBLCLK : WM_LBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags); */
#define HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_LBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_LBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_RBUTTONDBLCLK : WM_RBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_RBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnRButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_RBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_RBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_RBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONDOWN(hwnd, fDoubleClick, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_MBUTTONDBLCLK : WM_MBUTTONDOWN, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags); */
#define HANDLE_WM_MBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnMButtonUp(HWND hwnd, int x, int y, UINT flags); */
#define HANDLE_WM_MBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_MBUTTONUP(hwnd, x, y, keyFlags, fn) \
    (void)(fn)((hwnd), WM_MBUTTONUP, (WPARAM)(UINT)(keyFlags), MAKELPARAM((x), (y)))

/* void Cls_OnNCMouseMove(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMOUSEMOVE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMOUSEMOVE(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMOUSEMOVE, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCLBUTTONDBLCLK : WM_NCLBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)))

/* void Cls_OnNCLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCLButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCLBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCLBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCLBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCRBUTTONDBLCLK : WM_NCRBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCRButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCRBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCRBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCRBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDOWN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), FALSE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONDOWN(hwnd, fDoubleClick, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), (fDoubleClick) ? WM_NCMBUTTONDBLCLK : WM_NCMBUTTONDOWN, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* void Cls_OnNCMButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONDBLCLK(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), TRUE, (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)

/* void Cls_OnNCMButtonUp(HWND hwnd, int x, int y, UINT codeHitTest); */
#define HANDLE_WM_NCMBUTTONUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)LOWORD(lParam), (int)HIWORD(lParam), (UINT)(wParam)), 0L)
#define FORWARD_WM_NCMBUTTONUP(hwnd, x, y, codeHitTest, fn) \
    (void)(fn)((hwnd), WM_NCMBUTTONUP, (WPARAM)(UINT)(codeHitTest), MAKELPARAM((x), (y)) )

/* int Cls_OnMouseActivate(HWND hwnd, HWND hwndTopLevel, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_MOUSEACTIVATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam))
#define FORWARD_WM_MOUSEACTIVATE(hwnd, hwndTopLevel, codeHitTest, msg, fn) \
    (int)(DWORD)(fn)((hwnd), WM_MOUSEACTIVATE, (WPARAM)(HWND)(hwndTopLevel), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnCancelMode(HWND hwnd); */
#define HANDLE_WM_CANCELMODE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CANCELMODE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CANCELMODE, 0, 0L)

/* void Cls_OnTimer(HWND hwnd, UINT id); */
#define HANDLE_WM_TIMER(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam)), 0L)
#define FORWARD_WM_TIMER(hwnd, id, fn) \
    (void)(fn)((hwnd), WM_TIMER, (WPARAM)(UINT)(id), 0L)

/* void Cls_OnInitMenu(HWND hwnd, HMENU hMenu); */
#define HANDLE_WM_INITMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam)), 0L)
#define FORWARD_WM_INITMENU(hwnd, hMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENU, (WPARAM)(HMENU)(hMenu), 0L)

/* void Cls_OnInitMenuPopup(HWND hwnd, HMENU hMenu, int item, BOOL fSystemMenu); */
#define HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)(wParam), (int)LOWORD(lParam), (BOOL)HIWORD(lParam)), 0L)
#define FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, fn) \
    (void)(fn)((hwnd), WM_INITMENUPOPUP, (WPARAM)(HMENU)(hMenu), MAKELPARAM((item),(fSystemMenu)))

/* void Cls_OnMenuSelect(HWND hwnd, HMENU hmenu, int item, HMENU hmenuPopup, UINT flags); */
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HMENU)HIWORD(lParam), (LOWORD(lParam) & MF_POPUP) ? 0 : (int)(wParam), \
                            (LOWORD(lParam) & MF_POPUP) ? (HMENU)(wParam) : 0, LOWORD(lParam)), 0L)
#define FORWARD_WM_MENUSELECT(hwnd, hmenu, item, hmenuPopup, flags, fn) \
    (void)(fn)((hwnd), WM_MENUSELECT, ((flags) & MF_POPUP) ? (WPARAM)(HMENU)(hmenuPopup) : (WPARAM)(int)(item), MAKELPARAM((flags), (hmenu)))

/* DWORD Cls_OnMenuChar(HWND hwnd, UINT ch, UINT flags, HMENU hmenu); */
#define HANDLE_WM_MENUCHAR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam), LOWORD(lParam), (HMENU)HIWORD(lParam));
#define FORWARD_WM_MENUCHAR(hwnd, ch, flags, hmenu, fn) \
    (DWORD)(fn)((hwnd), WM_MENUCHAR, (WPARAM)(UINT)(ch), MAKELPARAM((flags), (UINT)(hmenu)))

/* void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify); */
#define HANDLE_WM_COMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
    (void)(fn)((hwnd), WM_COMMAND, (WPARAM)(int)(id), MAKELPARAM((UINT)(hwndCtl), (codeNotify)))

/* void Cls_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_HSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam), (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos); */
#define HANDLE_WM_VSCROLL(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)HIWORD(lParam), (UINT)(wParam),  (int)LOWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLL(hwnd, hwndCtl, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLL, (WPARAM)(UINT)(code), MAKELPARAM((pos), (UINT)(hwndCtl)))

/* void Cls_OnCut(HWND hwnd); */
#define HANDLE_WM_CUT(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CUT(hwnd, fn) \
    (void)(fn)((hwnd), WM_CUT, 0, 0L)

/* void Cls_OnCopy(HWND hwnd); */
#define HANDLE_WM_COPY(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_COPY(hwnd, fn) \
    (void)(fn)((hwnd), WM_COPY, 0, 0L)

/* void Cls_OnPaste(HWND hwnd); */
#define HANDLE_WM_PASTE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_PASTE(hwnd, fn) \
    (void)(fn)((hwnd), WM_PASTE, 0, 0L)

/* void Cls_OnClear(HWND hwnd); */
#define HANDLE_WM_CLEAR(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CLEAR(hwnd, fn) \
    (void)(fn)((hwnd), WM_CLEAR, 0, 0L)

/* void Cls_OnUndo(HWND hwnd); */
#define HANDLE_WM_UNDO(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_UNDO(hwnd, fn) \
    (void)(fn)((hwnd), WM_UNDO, 0, 0L)

/* HANDLE Cls_OnRenderFormat(HWND hwnd, UINT fmt); */
#define HANDLE_WM_RENDERFORMAT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HANDLE)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_RENDERFORMAT(hwnd, fmt, fn) \
    (HANDLE)(UINT)(DWORD)(fn)((hwnd), WM_RENDERFORMAT, (WPARAM)(UINT)(fmt), 0L)

/* void Cls_OnRenderAllFormats(HWND hwnd); */
#define HANDLE_WM_RENDERALLFORMATS(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_RENDERALLFORMATS(hwnd, fn) \
    (void)(fn)((hwnd), WM_RENDERALLFORMATS, 0, 0L)

/* void Cls_OnDestroyClipboard(HWND hwnd); */
#define HANDLE_WM_DESTROYCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DESTROYCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DESTROYCLIPBOARD, 0, 0L)

/* void Cls_OnDrawClipboard(HWND hwnd); */
#define HANDLE_WM_DRAWCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_DRAWCLIPBOARD(hwnd, fn) \
    (void)(fn)((hwnd), WM_DRAWCLIPBOARD, 0, 0L)

/* void Cls_OnPaintClipboard(HWND hwnd, HWND hwndCBViewer, const PAINTSTRUCT FAR* lpPaintStruct) */
#define HANDLE_WM_PAINTCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const PAINTSTRUCT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_PAINTCLIPBOARD(hwnd, hwndCBViewer, lpPaintStruct, fn) \
    (void)(fn)((hwnd), WM_PAINTCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lpPaintStruct))

/* void Cls_OnSizeClipboard(HWND hwnd, HWND hwndCBViewer, const RECT FAR* lprc); */
#define HANDLE_WM_SIZECLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (const RECT FAR*)GlobalLock((HGLOBAL)LOWORD(lParam))), GlobalUnlock((HGLOBAL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SIZECLIPBOARD(hwnd, hwndCBViewer, lprc, fn) \
    (void)(fn)((hwnd), WM_SIZECLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), (LPARAM)(lprc))

/* void Cls_OnVScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_VSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_VSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_VSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnHScrollClipboard(HWND hwnd, HWND hwndCBViewer, UINT code, int pos); */
#define HANDLE_WM_HSCROLLCLIPBOARD(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_HSCROLLCLIPBOARD(hwnd, hwndCBViewer, code, pos, fn) \
    (void)(fn)((hwnd), WM_HSCROLLCLIPBOARD, (WPARAM)(HWND)(hwndCBViewer), MAKELPARAM((code), (pos)))

/* void Cls_OnAskCBFormatName(HWND hwnd, int cchMax, LPSTR rgchName); */
#define HANDLE_WM_ASKCBFORMATNAME(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), (LPSTR)(lParam)), 0L)
#define FORWARD_WM_ASKCBFORMATNAME(hwnd, cchMax, rgchName, fn) \
    (void)(fn)((hwnd), WM_ASKCBFORMATNAME, (WPARAM)(int)(cchMax), (LPARAM)(rgchName))

/* void Cls_OnChangeCBChain(HWND hwnd, HWND hwndRemove, HWND hwndNext); */
#define HANDLE_WM_CHANGECBCHAIN(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_CHANGECBCHAIN(hwnd, hwndRemove, hwndNext, fn) \
    (void)(fn)((hwnd), WM_CHANGECBCHAIN, (WPARAM)(HWND)(hwndRemove), MAKELPARAM((UINT)(hwndNext), 0))

/* BOOL Cls_OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg); */
#define HANDLE_WM_SETCURSOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(BOOL)(fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam));
#define FORWARD_WM_SETCURSOR(hwnd, hwndCursor, codeHitTest, msg, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_SETCURSOR, (WPARAM)(HWND)(hwndCursor), MAKELPARAM((codeHitTest), (msg)))

/* void Cls_OnSysCommand(HWND hwnd, UINT cmd, int x, int y); */
#define HANDLE_WM_SYSCOMMAND(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, fn) \
    (void)(fn)((hwnd), WM_SYSCOMMAND, (WPARAM)(UINT)(cmd), MAKELPARAM((x), (y)))

/* HWND Cls_MDICreate(HWND hwnd, const MDICREATESTRUCT FAR* lpmcs); */
#define HANDLE_WM_MDICREATE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (MDICREATESTRUCT FAR*)(lParam))
#define FORWARD_WM_MDICREATE(hwnd, lpmcs, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDICREATE, 0, (LPARAM)(lpmcs))

/* void Cls_MDIDestroy(HWND hwnd, HWND hwndDestroy); */
#define HANDLE_WM_MDIDESTROY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIDESTROY(hwnd, hwndDestroy, fn) \
    (void)(fn)((hwnd), WM_MDIDESTROY, (WPARAM)(hwndDestroy), 0L)

/* NOTE: Usable only by MDI client windows */
/* void Cls_MDIActivate(HWND hwnd, BOOL fActive, HWND hwndActivate, HWND hwndDeactivate); */
#define HANDLE_WM_MDIACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (BOOL)(wParam), (HWND)LOWORD(lParam), (HWND)HIWORD(lParam)), 0L)
#define FORWARD_WM_MDIACTIVATE(hwnd, fActive, hwndActivate, hwndDeactivate, fn) \
    (void)(fn)(hwnd, WM_MDIACTIVATE, (WPARAM)(fActive), MAKELPARAM((hwndActivate), (hwndDeactivate)))

/* void Cls_MDIRestore(HWND hwnd, HWND hwndRestore); */
#define HANDLE_WM_MDIRESTORE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIRESTORE(hwnd, hwndRestore, fn) \
    (void)(fn)((hwnd), WM_MDIRESTORE, (WPARAM)(hwndRestore), 0L)

/* HWND Cls_MDINext(HWND hwnd, HWND hwndCur, BOOL fPrev); */
#define HANDLE_WM_MDINEXT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_MDINEXT(hwnd, hwndCur, fPrev, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDINEXT, (WPARAM)(hwndCur), MAKELPARAM((fPrev), 0))

/* void Cls_MDIMaximize(HWND hwnd, HWND hwndMaximize); */
#define HANDLE_WM_MDIMAXIMIZE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam)), 0L)
#define FORWARD_WM_MDIMAXIMIZE(hwnd, hwndMaximize, fn) \
    (void)(fn)((hwnd), WM_MDIMAXIMIZE, (WPARAM)(hwndMaximize), 0L)

/* BOOL Cls_MDITile(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDITILE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDITILE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDITILE, (WPARAM)(cmd), 0L)

/* BOOL Cls_MDICascade(HWND hwnd, UINT cmd); */
#define HANDLE_WM_MDICASCADE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(fn)((hwnd), (UINT)(wParam))
#define FORWARD_WM_MDICASCADE(hwnd, cmd, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_MDICASCADE, (WPARAM)(cmd), 0L)

/* void Cls_MDIIconArrange(HWND hwnd); */
#define HANDLE_WM_MDIICONARRANGE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_MDIICONARRANGE(hwnd, fn) \
    (void)(fn)((hwnd), WM_MDIICONARRANGE, 0, 0L)

/* HWND Cls_MDIGetActive(HWND hwnd); */
#define HANDLE_WM_MDIGETACTIVE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd)
#define FORWARD_WM_MDIGETACTIVE(hwnd, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_MDIGETACTIVE, 0, 0L)

/* HMENU Cls_MDISetMenu(HWND hwnd, BOOL fRefresh, HMENU hmenuFrame, HMENU hmenuWindow); */
#define HANDLE_WM_MDISETMENU(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)((hwnd), (BOOL)(wParam), (HMENU)LOWORD(lParam), (HMENU)HIWORD(lParam))
#define FORWARD_WM_MDISETMENU(hwnd, fRefresh, hmenuFrame, hmenuWindow, fn) \
    (HMENU)(UINT)(DWORD)(fn)((hwnd), WM_MDISETMENU, (WPARAM)(fRefresh), MAKELPARAM((hmenuFrame), (hmenuWindow)))

/* void Cls_OnChildActivate(HWND hwnd); */
#define HANDLE_WM_CHILDACTIVATE(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_CHILDACTIVATE(hwnd, fn) \
    (void)(fn)((hwnd), WM_CHILDACTIVATE, 0, 0L)

/* BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam); */
#define HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(BOOL)(fn)((hwnd), (HWND)(wParam), lParam);
#define FORWARD_WM_INITDIALOG(hwnd, hwndFocus, lParam, fn) \
    (BOOL)(DWORD)(fn)((hwnd), WM_INITDIALOG, (WPARAM)(HWND)(hwndFocus), (lParam))

/* HWND Cls_OnNextDlgCtl(HWND hwnd, HWND hwndSetFocus, BOOL fNext) */
#define HANDLE_WM_NEXTDLGCTL(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HWND)(fn)((hwnd), (HWND)(wParam), (BOOL)LOWORD(lParam))
#define FORWARD_WM_NEXTDLGCTL(hwnd, hwndSetFocus, fNext, fn) \
    (HWND)(UINT)(DWORD)(fn)((hwnd), WM_NEXTDLGCTL, (WPARAM)(HWND)(hwndSetFocus), MAKELPARAM((fNext), 0))

/* void Cls_OnParentNotify(HWND hwnd, UINT msg, HWND hwndChild, int idChild); */
#define HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define FORWARD_WM_PARENTNOTIFY(hwnd, msg, hwndChild, idChild, fn) \
    (void)(fn)((hwnd), WM_PARENTNOTIFY, (WPARAM)(UINT)(msg), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(idChild)))

/* void Cls_OnEnterIdle(HWND hwnd, UINT source, HWND hwndSource); */
#define HANDLE_WM_ENTERIDLE(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam)), 0L)
#define FORWARD_WM_ENTERIDLE(hwnd, source, hwndSource, fn) \
    (void)(fn)((hwnd), WM_ENTERIDLE, (WPARAM)(UINT)(source), MAKELPARAM((UINT)(HWND)(hwndSource), 0))

/* UINT Cls_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg); */
#define HANDLE_WM_GETDLGCODE(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(fn)(hwnd, (MSG FAR*)(lParam))
#define FORWARD_WM_GETDLGCODE(hwnd, lpmsg, fn) \
    (UINT)(DWORD)(fn)((hwnd), WM_GETDLGCODE, (SELECTOROF(lpmsg) ? lpmsg->wParam : 0), (LPARAM)(lpmsg))

/* HBRUSH Cls_OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type); */
#define HANDLE_WM_CTLCOLOR(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)LOWORD(lParam), (int)(HIWORD(lParam)))
#define FORWARD_WM_CTLCOLOR(hwnd, hdc, hwndChild, type, fn) \
    (HBRUSH)(UINT)(DWORD)(fn)((hwnd), WM_CTLCOLOR, (WPARAM)(HDC)(hdc), MAKELPARAM((UINT)(HWND)(hwndChild), (UINT)(int)(type)))

/* void Cls_OnSetFont(HWND hwndCtl, HFONT hfont, BOOL fRedraw); */
#define HANDLE_WM_SETFONT(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HFONT)(wParam), (BOOL)LOWORD(lParam)), 0L)
#define FORWARD_WM_SETFONT(hwnd, hfont, fRedraw, fn) \
    (void)(fn)((hwnd), WM_SETFONT, (WPARAM)(HFONT)(hfont), MAKELPARAM((UINT)(BOOL)(fRedraw), 0))

/* HFONT Cls_OnGetFont(HWND hwnd); */
#define HANDLE_WM_GETFONT(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HFONT)(fn)(hwnd)
#define FORWARD_WM_GETFONT(hwnd, fn) \
    (HFONT)(UINT)(DWORD)(fn)((hwnd), WM_GETFONT, 0, 0L)

/* void Cls_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT FAR* lpDrawItem); */
#define HANDLE_WM_DRAWITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DRAWITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DRAWITEM(hwnd, lpDrawItem, fn) \
    (void)(fn)((hwnd), WM_DRAWITEM, 0, (LPARAM)(const DRAWITEMSTRUCT FAR*)(lpDrawItem))

/* void Cls_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem); */
#define HANDLE_WM_MEASUREITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (MEASUREITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_MEASUREITEM(hwnd, lpMeasureItem, fn) \
    (void)(fn)((hwnd), WM_MEASUREITEM, 0, (LPARAM)(MEASUREITEMSTRUCT FAR*)(lpMeasureItem))

/* void Cls_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT FAR* lpDeleteItem) */
#define HANDLE_WM_DELETEITEM(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (const DELETEITEMSTRUCT FAR*)(lParam)), 0L)
#define FORWARD_WM_DELETEITEM(hwnd, lpDeleteItem, fn) \
    (void)(fn)((hwnd), WM_DELETEITEM, 0, (LPARAM)(const DELETEITEMSTRUCT FAR*)(lpDeleteItem))

/* int Cls_OnCompareItem(HWND hwnd, const COMPAREITEMSTRUCT FAR* lpCompareItem); */
#define HANDLE_WM_COMPAREITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (const COMPAREITEMSTRUCT FAR*)(lParam))
#define FORWARD_WM_COMPAREITEM(hwnd, lpCompareItem, fn) \
    (int)(DWORD)(fn)((hwnd), WM_COMPAREITEM, 0, (LPARAM)(const COMPAREITEMSTRUCT FAR*)(lpCompareItem))

/* int Cls_OnVkeyToItem(HWND hwnd, UINT vk, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_VKEYTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_VKEYTOITEM(hwnd, vk, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_VKEYTOITEM, (WPARAM)(UINT)(vk), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* int Cls_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret); */
#define HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(int)(fn)((hwnd), (UINT)(wParam), (HWND)LOWORD(lParam), (int)HIWORD(lParam))
#define FORWARD_WM_CHARTOITEM(hwnd, ch, hwndListBox, iCaret, fn) \
    (int)(DWORD)(fn)((hwnd), WM_CHARTOITEM, (WPARAM)(UINT)(ch), MAKELPARAM((UINT)(hwndListBox), (UINT)(iCaret)))

/* void Cls_OnQueueSync(HWND hwnd); */
#define HANDLE_WM_QUEUESYNC(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd), 0L)
#define FORWARD_WM_QUEUESYNC(hwnd, fn) \
    (void)(fn)((hwnd), WM_QUEUESYNC, 0, 0L)

/* void Cls_OnCommNotify(HWND hwnd, int cid, UINT flags); */
#define HANDLE_WM_COMMNOTIFY(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (int)(wParam), LOWORD(lParam)), 0L)
#define FORWARD_WM_COMMNOTIFY(hwnd, cid, flags, fn) \
    (void)(fn)((hwnd), WM_COMMNOTIFY, (WPARAM)(cid), MAKELPARAM((flags), 0))

/****** Static control message APIs ******************************************/

#define Static_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Static_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Static_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Static_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Static_SetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_SETICON, (WPARAM)(HICON)(hIcon), 0L))
#define Static_GetIcon(hwndCtl, hIcon)          ((HICON)(UINT)(DWORD)SendMessage((hwndCtl), STM_GETICON, 0, 0L))

/****** Button control message APIs ******************************************/

#define Button_Enable(hwndCtl, fEnable)         EnableWindow((hwndCtl), (fEnable))

#define Button_GetText(hwndCtl, lpch, cchMax)   GetWindowText((hwndCtl), (lpch), (cchMax))
#define Button_GetTextLength(hwndCtl)           GetWindowTextLength(hwndCtl)
#define Button_SetText(hwndCtl, lpsz)           SetWindowText((hwndCtl), (lpsz))

#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETCHECK, 0, 0L))
#define Button_SetCheck(hwndCtl, check)     ((void)SendMessage((hwndCtl), BM_SETCHECK, (WPARAM)(int)(check), 0L))

#define Button_GetState(hwndCtl)            ((int)(DWORD)SendMessage((hwndCtl), BM_GETSTATE, 0, 0L))
#define Button_SetState(hwndCtl, state)     ((UINT)(DWORD)SendMessage((hwndCtl), BM_SETSTATE, (WPARAM)(int)(state), 0L))

#define Button_SetStyle(hwndCtl, style, fRedraw) ((void)SendMessage((hwndCtl), BM_SETSTYLE, (WPARAM)LOWORD(style), MAKELPARAM(((fRedraw) ? TRUE : FALSE), 0)))

/****** Edit control message APIs ********************************************/

#define Edit_Enable(hwndCtl, fEnable)           EnableWindow((hwndCtl), (fEnable))

#define Edit_GetText(hwndCtl, lpch, cchMax)     GetWindowText((hwndCtl), (lpch), (cchMax))
#define Edit_GetTextLength(hwndCtl)             GetWindowTextLength(hwndCtl)
#define Edit_SetText(hwndCtl, lpsz)             SetWindowText((hwndCtl), (lpsz))

#define Edit_LimitText(hwndCtl, cchMax)         ((void)SendMessage((hwndCtl), EM_LIMITTEXT, (WPARAM)(cchMax), 0L))

#define Edit_GetLineCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINECOUNT, 0, 0L))
#define Edit_GetLine(hwndCtl, line, lpch, cchMax) ((*((int FAR*)(lpch)) = (cchMax)), ((int)(DWORD)SendMessage((hwndCtl), EM_GETLINE, (WPARAM)(int)(line), (LPARAM)(LPSTR)(lpch))))

#define Edit_GetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_GETRECT, 0, (LPARAM)(RECT FAR*)(lprc)))
#define Edit_SetRect(hwndCtl, lprc)             ((void)SendMessage((hwndCtl), EM_SETRECT, 0, (LPARAM)(const RECT FAR*)(lprc)))
#define Edit_SetRectNoPaint(hwndCtl, lprc)      ((void)SendMessage((hwndCtl), EM_SETRECTNP, 0, (LPARAM)(const RECT FAR*)(lprc)))

#define Edit_GetSel(hwndCtl)                    ((DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L))
#define Edit_SetSel(hwndCtl, ichStart, ichEnd)  ((void)SendMessage((hwndCtl), EM_SETSEL, 0, MAKELPARAM((ichStart), (ichEnd))))
#define Edit_ReplaceSel(hwndCtl, lpszReplace)   ((void)SendMessage((hwndCtl), EM_REPLACESEL, 0, (LPARAM)(LPCSTR)(lpszReplace)))

#define Edit_GetModify(hwndCtl)                 ((BOOL)(DWORD)SendMessage((hwndCtl), EM_GETMODIFY, 0, 0L))
#define Edit_SetModify(hwndCtl, fModified)      ((void)SendMessage((hwndCtl), EM_SETMODIFY, (WPARAM)(UINT)(fModified), 0L))

#define Edit_LineFromChar(hwndCtl, ich)         ((int)(DWORD)SendMessage((hwndCtl), EM_LINEFROMCHAR, (WPARAM)(int)(ich), 0L))
#define Edit_LineIndex(hwndCtl, line)           ((int)(DWORD)SendMessage((hwndCtl), EM_LINEINDEX, (WPARAM)(int)(line), 0L))
#define Edit_LineLength(hwndCtl, line)          ((int)(DWORD)SendMessage((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

#define Edit_Scroll(hwndCtl, dv, dh)            ((void)SendMessage((hwndCtl), EM_LINESCROLL, 0, MAKELPARAM((dv), (dh))))

#define Edit_CanUndo(hwndCtl)                   ((BOOL)(DWORD)SendMessage((hwndCtl), EM_CANUNDO, 0, 0L))
#define Edit_Undo(hwndCtl)                      ((BOOL)(DWORD)SendMessage((hwndCtl), EM_UNDO, 0, 0L))
#define Edit_EmptyUndoBuffer(hwndCtl)           ((void)SendMessage((hwndCtl), EM_EMPTYUNDOBUFFER, 0, 0L))

#define Edit_SetPasswordChar(hwndCtl, ch)       ((void)SendMessage((hwndCtl), EM_SETPASSWORDCHAR, (WPARAM)(UINT)(ch), 0L))

#define Edit_SetTabStops(hwndCtl, cTabs, lpTabs) ((void)SendMessage((hwndCtl), EM_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(const int FAR*)(lpTabs)))

#define Edit_FmtLines(hwndCtl, fAddEOL)         ((BOOL)(DWORD)SendMessage((hwndCtl), EM_FMTLINES, (WPARAM)(BOOL)(fAddEOL), 0L))

#define Edit_GetHandle(hwndCtl)                 ((HLOCAL)(UINT)(DWORD)SendMessage((hwndCtl), EM_GETHANDLE, 0, 0L))
#define Edit_SetHandle(hwndCtl, h)              ((void)SendMessage((hwndCtl), EM_SETHANDLE, (WPARAM)(UINT)(HLOCAL)(h), 0L))

#if (WINVER >= 0x030a)
#define Edit_GetFirstVisibleLine(hwndCtl)       ((int)(DWORD)SendMessage((hwndCtl), EM_GETFIRSTVISIBLELINE, 0, 0L))

#define Edit_SetReadOnly(hwndCtl, fReadOnly)    ((BOOL)(DWORD)SendMessage((hwndCtl), EM_SETREADONLY, (WPARAM)(BOOL)(fReadOnly), 0L))

#define Edit_GetPasswordChar(hwndCtl)           ((char)(DWORD)SendMessage((hwndCtl), EM_GETPASSWORDCHAR, 0, 0L))

#define Edit_SetWordBreakProc(hwndCtl, lpfnWordBreak) ((void)SendMessage((hwndCtl), EM_SETWORDBREAKPROC, 0, (LPARAM)(EDITWORDBREAKPROC)(lpfnWordBreak)))
#define Edit_GetWordBreakProc(hwndCtl)          ((EDITWORDBREAKPROC)SendMessage((hwndCtl), EM_GETWORDBREAKPROC, 0, 0L))
#endif /* WINVER >= 0x030a */

/****** ScrollBar control message APIs ***************************************/

/* NOTE: flags parameter is a collection of ESB_* values, NOT a boolean! */
#define ScrollBar_Enable(hwndCtl, flags)            EnableScrollBar((hwndCtl), SB_CTL, (flags))

#define ScrollBar_Show(hwndCtl, fShow)              ShowWindow((hwndCtl), (fShow) ? SW_SHOWNORMAL : SW_HIDE)

#define ScrollBar_SetPos(hwndCtl, pos, fRedraw)     SetScrollPos((hwndCtl), SB_CTL, (pos), (fRedraw))
#define ScrollBar_GetPos(hwndCtl)                   GetScrollPos((hwndCtl), SB_CTL)

#define ScrollBar_SetRange(hwndCtl, posMin, posMax, fRedraw)    SetScrollRange((hwndCtl), SB_CTL, (posMin), (posMax), (fRedraw))
#define ScrollBar_GetRange(hwndCtl, lpposMin, lpposMax)         GetScrollRange((hwndCtl), SB_CTL, (lpposMin), (lpposMax))

/****** ListBox control message APIs *****************************************/

#define ListBox_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ListBox_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), LB_GETCOUNT, 0, 0L))
#define ListBox_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), LB_RESETCONTENT, 0, 0L))

#define ListBox_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ListBox_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ListBox_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), LB_ADDSTRING, 0, (LPARAM)(data)))
#define ListBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ListBox_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ListBox_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ListBox_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), LB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ListBox_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ListBox_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), LB_SETSEL, (WPARAM)(BOOL)(fSelect), MAKELPARAM((index), 0)))
#define ListBox_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), LB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ListBox_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), LB_GETCURSEL, 0, 0L))
#define ListBox_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ListBox_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ListBox_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), LB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ListBox_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETSEL, (WPARAM)(int)(index), 0L))
#define ListBox_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELCOUNT, 0, 0L))
#define ListBox_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), LB_GETTOPINDEX, 0, 0L))
#define ListBox_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), LB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int FAR*)(lpItems)))

#define ListBox_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), LB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ListBox_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), LB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ListBox_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), LB_GETHORIZONTALEXTENT, 0, 0L))
#define ListBox_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), LB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ListBox_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), LB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int FAR*)(lpTabs)))

#define ListBox_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT FAR*)(lprc)))

#define ListBox_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ListBox_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), LB_GETCARETINDEX, 0, 0L))


#if (WINVER >= 0x030a)
#define ListBox_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), LB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ListBox_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), LB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ListBox_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), LB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ListBox_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), LB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

/****** ComboBox control message APIs ****************************************/

#define ComboBox_Enable(hwndCtl, fEnable)       EnableWindow((hwndCtl), (fEnable))

#define ComboBox_GetText(hwndCtl, lpch, cchMax) GetWindowText((hwndCtl), (lpch), (cchMax))
#define ComboBox_GetTextLength(hwndCtl)         GetWindowTextLength(hwndCtl)
#define ComboBox_SetText(hwndCtl, lpsz)         SetWindowText((hwndCtl), (lpsz))

#define ComboBox_LimitText(hwndCtl, cchLimit)   ((int)(DWORD)SendMessage((hwndCtl), CB_LIMITTEXT, (WPARAM)(int)(cchLimit), 0L))

#define ComboBox_GetEditSel(hwndCtl)            ((DWORD)SendMessage((hwndCtl), CB_GETEDITSEL, 0, 0L))
#define ComboBox_SetEditSel(hwndCtl, ichStart, ichEnd) ((int)(DWORD)SendMessage((hwndCtl), CB_SETEDITSEL, 0, MAKELPARAM((ichStart), (ichEnd))))

#define ComboBox_GetCount(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CB_GETCOUNT, 0, 0L))
#define ComboBox_ResetContent(hwndCtl)          ((int)(DWORD)SendMessage((hwndCtl), CB_RESETCONTENT, 0, 0L))

#define ComboBox_AddString(hwndCtl, lpsz)       ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(LPCSTR)(lpsz)))
#define ComboBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpsz)))

#define ComboBox_AddItemData(hwndCtl, data)     ((int)(DWORD)SendMessage((hwndCtl), CB_ADDSTRING, 0, (LPARAM)(data)))
#define ComboBox_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_DeleteString(hwndCtl, index)   ((int)(DWORD)SendMessage((hwndCtl), CB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ComboBox_GetLBTextLen(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXTLEN, (WPARAM)(int)(index), 0L))
#define ComboBox_GetLBText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CB_GETLBTEXT, (WPARAM)(int)(index), (LPARAM)(LPCSTR)(lpszBuffer)))

#define ComboBox_GetItemData(hwndCtl, index)        ((LRESULT)(DWORD)SendMessage((hwndCtl), CB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ComboBox_SetItemData(hwndCtl, index, data)  ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#define ComboBox_FindString(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))
#define ComboBox_FindItemData(hwndCtl, indexStart, data)    ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_GetCurSel(hwndCtl)                 ((int)(DWORD)SendMessage((hwndCtl), CB_GETCURSEL, 0, 0L))
#define ComboBox_SetCurSel(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ComboBox_SelectString(hwndCtl, indexStart, lpszSelect)  ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszSelect)))
#define ComboBox_SelectItemData(hwndCtl, indexStart, data)      ((int)(DWORD)SendMessage((hwndCtl), CB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ComboBox_Dir(hwndCtl, attrs, lpszFileSpec)  ((int)(DWORD)SendMessage((hwndCtl), CB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCSTR)(lpszFileSpec)))

#define ComboBox_ShowDropdown(hwndCtl, fShow)       ((BOOL)(DWORD)SendMessage((hwndCtl), CB_SHOWDROPDOWN, (WPARAM)(BOOL)(fShow), 0L))

#if (WINVER >= 0x030a)
#define ComboBox_FindStringExact(hwndCtl, indexStart, lpszFind)  ((int)(DWORD)SendMessage((hwndCtl), CB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCSTR)(lpszFind)))

#define ComboBox_GetDroppedState(hwndCtl)           ((BOOL)(DWORD)SendMessage((hwndCtl), CB_GETDROPPEDSTATE, 0, 0L))
#define ComboBox_GetDroppedControlRect(hwndCtl, lprc) ((void)SendMessage((hwndCtl), CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)(RECT FAR*)(lprc)))

#define ComboBox_GetItemHeight(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CB_GETITEMHEIGHT, 0, 0L))
#define ComboBox_SetItemHeight(hwndCtl, cyItem)     ((int)(DWORD)SendMessage((hwndCtl), CB_SETITEMHEIGHT, (WPARAM)(int)(index), 0L))

#define ComboBox_GetExtendedUI(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), CB_GETEXTENDEDUI, 0, 0L))
#define ComboBox_SetExtendedUI(hwndCtl, flags)      ((int)(DWORD)SendMessage((hwndCtl), CB_SETEXTENDEDUI, (WPARAM)(UINT)(flags), 0L))
#endif  /* WINVER >= 0x030a */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* !_INC_WINDOWSX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\sys\locking.h ===
/***
*sys\locking.h - flags for locking() function
*
*   Copyright (c) 1985-1992, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   This file defines the flags for the locking() function.
*   [System V]
*
****/

#ifndef _INC_LOCKING

#define _LK_UNLCK   0   /* unlock the file region */
#define _LK_LOCK    1   /* lock the file region */
#define _LK_NBLCK   2   /* non-blocking lock */
#define _LK_RLCK    3   /* lock for writing */
#define _LK_NBRLCK  4   /* non-blocking lock for writing */

#ifndef __STDC__
/* Non-ANSI names for compatibility */
#define LK_UNLCK       _LK_UNLCK
#define LK_LOCK        _LK_LOCK
#define LK_NBLCK       _LK_NBLCK
#define LK_RLCK        _LK_RLCK
#define LK_NBRLCK      _LK_NBRLCK
#endif 

#define _INC_LOCKING
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\sys\stat.h ===
/***
*sys\stat.h - defines structure used by stat() and fstat()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structure used by the stat() and fstat()
*   routines.
*   [System V]
*
****/

#ifndef _INC_STAT

#ifndef _INC_TYPES
#include <sys/types.h>
#endif 

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* define structure for returning status information */

#ifndef _STAT_DEFINED
#pragma pack(2)

struct _stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
    };
#endif 

#pragma pack()
#define _STAT_DEFINED
#endif 

#define _S_IFMT     0170000     /* file type mask */
#define _S_IFDIR    0040000     /* directory */
#define _S_IFCHR    0020000     /* character special */
#define _S_IFREG    0100000     /* regular */
#define _S_IREAD    0000400     /* read permission, owner */
#define _S_IWRITE   0000200     /* write permission, owner */
#define _S_IEXEC    0000100     /* execute/search permission, owner */


/* function prototypes */

int __cdecl _fstat(int, struct _stat *);
int __cdecl _stat(const char *, struct _stat *);

#ifndef __STDC__
/* Non-ANSI names for compatibility */

#define S_IFMT   _S_IFMT
#define S_IFDIR  _S_IFDIR
#define S_IFCHR  _S_IFCHR
#define S_IFREG  _S_IFREG
#define S_IREAD  _S_IREAD
#define S_IWRITE _S_IWRITE
#define S_IEXEC  _S_IEXEC

int __cdecl fstat(int, struct stat *);
int __cdecl stat(const char *, struct stat *);

#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_STAT
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\winsock.h ===
/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 * Change log:
 *
 * Fri Apr 23 16:31:01 1993  Mark Towfiq  (towfiq@Microdyne.COM)
 *	New version from David Treadwell which adds extern "C" around
 *	__WSAFDIsSet() and removes "const" from buf param of
 *	WSAAsyncGetHostByAddr().  Added change log.
 *
 * Sat May 15 10:55:00 1993 David Treadwell (davidtr@microsoft.com)
 *  Fix the IN_CLASSC macro to account for class-D multicasts.
 *  Add AF_IPX == AF_NS.
 *
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

/*
 * Pull in WINDOWS.H if necessary
 */
#ifndef _INC_WINDOWS
#include <windows.h>
#endif /* _INC_WINDOWS */

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

#ifdef __cplusplus
extern "C" {
#endif

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#ifdef __cplusplus
}
#endif


#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=(fd);\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128

typedef struct WSAData {
        WORD                    wVersion;
        WORD                    wHighVersion;
        char                    szDescription[WSADESCRIPTION_LEN+1];
        char                    szSystemStatus[WSASYS_STATUS_LEN+1];
        unsigned short          iMaxSockets;
        unsigned short          iMaxUdpDg;
        char FAR *              lpVendorInfo;
} WSADATA;

typedef WSADATA FAR *LPWSADATA;

/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS          1           /* set/get IP per-packet options    */
#define IP_MULTICAST_IF     2           /* set/get IP multicast interface   */
#define IP_MULTICAST_TTL    3           /* set/get IP multicast timetolive  */
#define IP_MULTICAST_LOOP   4           /* set/get IP multicast loopback    */
#define IP_ADD_MEMBERSHIP   5           /* add  an IP group membership      */
#define IP_DROP_MEMBERSHIP  6           /* drop an IP group membership      */

#define IP_DEFAULT_MULTICAST_TTL   1    /* normally limit m'casts to 1 hop  */
#define IP_DEFAULT_MULTICAST_LOOP  1    /* normally hear sends if a member  */
#define IP_MAX_MEMBERSHIPS         20   /* per socket; must fit in one mbuf */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */
        struct in_addr  imr_interface;  /* local IP address of interface */
};

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */
#define SO_CONNDATA     0x7000
#define SO_CONNOPT      0x7001
#define SO_DISCDATA     0x7002
#define SO_DISCOPT      0x7003
#define SO_CONNDATALEN  0x7004
#define SO_CONNOPTLEN   0x7005
#define SO_DISCDATALEN  0x7006
#define SO_DISCOPTLEN   0x7007

/*
 * Option for opening sockets for synchronous access.
 */
#define SO_OPENTYPE     0x7008

#define SO_SYNCHRONOUS_ALERT    0x10
#define SO_SYNCHRONOUS_NONALERT 0x20

/*
 * Other NT-specific options.
 */
#define SO_MAXDG        0x7009
#define SO_MAXPATHDG    0x700A

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001
#define TCP_BSDURGENT   0x7000

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_IPX          6               /* IPX and SPX */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */

#define AF_MAX          18

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

#define	MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

#define WSAEDISCON              (WSABASEERR+101)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

#define h_errno         WSAGetLastError()

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)
#define TRY_AGAIN               WSATRY_AGAIN

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)
#define NO_RECOVERY             WSANO_RECOVERY

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)
#define NO_DATA                 WSANO_DATA

/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS

/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
                          int FAR *addrlen);

int PASCAL FAR bind (SOCKET s, const struct sockaddr FAR *addr, int namelen);

int PASCAL FAR closesocket (SOCKET s);

int PASCAL FAR connect (SOCKET s, const struct sockaddr FAR *name, int namelen);

int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);

int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
                           char FAR * optval, int FAR *optlen);

u_long PASCAL FAR htonl (u_long hostlong);

u_short PASCAL FAR htons (u_short hostshort);

unsigned long PASCAL FAR inet_addr (const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (struct in_addr in);

int PASCAL FAR listen (SOCKET s, int backlog);

u_long PASCAL FAR ntohl (u_long netlong);

u_short PASCAL FAR ntohs (u_short netshort);

int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);

int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);

int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds,
                       fd_set FAR *exceptfds, const struct timeval FAR *timeout);

int PASCAL FAR send (SOCKET s, const char FAR * buf, int len, int flags);

int PASCAL FAR sendto (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);

int PASCAL FAR shutdown (SOCKET s, int how);

SOCKET PASCAL FAR socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(const char FAR * addr,
                                              int len, int type);

struct hostent FAR * PASCAL FAR gethostbyname(const char FAR * name);

int PASCAL FAR gethostname (char FAR * name, int namelen);

struct servent FAR * PASCAL FAR getservbyport(int port, const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(const char FAR * name,
                                              const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(int proto);

struct protoent FAR * PASCAL FAR getprotobyname(const char FAR * name);

/* Microsoft Windows Extension function prototypes */

int PASCAL FAR WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

int PASCAL FAR WSACleanup(void);

void PASCAL FAR WSASetLastError(int iError);

int PASCAL FAR WSAGetLastError(void);

BOOL PASCAL FAR WSAIsBlocking(void);

int PASCAL FAR WSAUnhookBlockingHook(void);

FARPROC PASCAL FAR WSASetBlockingHook(FARPROC lpBlockFunc);

int PASCAL FAR WSACancelBlockingCall(void);

HANDLE PASCAL FAR WSAAsyncGetServByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name,
                                        const char FAR * proto,
                                        char FAR * buf, int buflen);

HANDLE PASCAL FAR WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port,
                                        const char FAR * proto, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg,
                                         const char FAR * name, char FAR * buf,
                                         int buflen);

HANDLE PASCAL FAR WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg,
                                           int number, char FAR * buf,
                                           int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByName(HWND hWnd, u_int wMsg,
                                        const char FAR * name, char FAR * buf,
                                        int buflen);

HANDLE PASCAL FAR WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg,
                                        const char FAR * addr, int len, int type,
                                        char FAR * buf, int buflen);

int PASCAL FAR WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

int PASCAL FAR WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg,
                               long lEvent);

int PASCAL FAR WSARecvEx (SOCKET s, char FAR * buf, int len, int FAR *flags);

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

/*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 */
#define WSAMAKEASYNCREPLY(buflen,error)     MAKELONG(buflen,error)
/*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 */
#define WSAMAKESELECTREPLY(event,error)     MAKELONG(event,error)
/*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCBUFLEN(lParam)           LOWORD(lParam)
/*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 */
#define WSAGETASYNCERROR(lParam)            HIWORD(lParam)
/*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTEVENT(lParam)           LOWORD(lParam)
/*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 */
#define WSAGETSELECTERROR(lParam)           HIWORD(lParam)

#endif  /* _WINSOCKAPI_ */



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\sys\types.h ===
/***
*sys\types.h - types returned by system level calls for file and time info
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines types used in defining values returned by system
*   level calls for file status and time information.
*   [System V]
*
****/

#ifndef _INC_TYPES

#ifndef _TIME_T_DEFINED
typedef unsigned long time_t;
#define _TIME_T_DEFINED
#endif 

#ifndef _INO_T_DEFINED
typedef unsigned short _ino_t;      /* i-node number (not used on DOS) */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef unsigned short ino_t;
#endif 
#define _INO_T_DEFINED
#endif 

#ifndef _DEV_T_DEFINED
typedef short _dev_t;           /* device code */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef short dev_t;
#endif 
#define _DEV_T_DEFINED
#endif 

#ifndef _OFF_T_DEFINED
typedef long _off_t;            /* file offset value */
#ifndef __STDC__
/* Non-ANSI name for compatibility */
typedef long off_t;
#endif 
#define _OFF_T_DEFINED
#endif 

#define _INC_TYPES
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afx.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_H__
#define __AFX_H__

#ifndef __cplusplus
#error Microsoft Foundation Classes require C++ compilation (use a .cpp suffix)
#endif

/////////////////////////////////////////////////////////////////////////////

#include <afxver_.h>        // Target version control

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file
//   in addition to standard primitive data types and various helper macros

struct CRuntimeClass;          // object type information

class CObject;                        // the root of all objects classes

	class CException;                 // the root of all exceptions
		class CMemoryException;       // out-of-memory exception
		class CNotSupportedException; // feature not supported exception
		class CArchiveException;// archive exception
		class CFileException;         // file exception

	class CFile;                      // raw binary file
		class CStdioFile;             // buffered stdio text/binary file
		class CMemFile;               // memory based file

// Non CObject classes
class CString;                        // growable string type
class CTimeSpan;                      // time/date difference
class CTime;                          // absolute time/date
struct CFileStatus;                   // file status information
struct CMemoryState;                  // diagnostic memory support

class CArchive;                       // object persistence tool
class CDumpContext;                   // object diagnostic dumping

/////////////////////////////////////////////////////////////////////////////
// Other includes from standard "C" runtimes

#ifndef NOSTRICT
#define STRICT      // default is to use STRICT interfaces
#endif

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/////////////////////////////////////////////////////////////////////////////
// Basic types (from Windows)

typedef unsigned char  BYTE;   // 8-bit unsigned entity
typedef unsigned short WORD;   // 16-bit unsigned number
typedef unsigned int   UINT;   // machine sized unsigned number (preferred)
typedef long           LONG;   // 32-bit signed number
typedef unsigned long  DWORD;  // 32-bit unsigned number
typedef int            BOOL;   // BOOLean (0 or !=0)
typedef char FAR*      LPSTR;  // far pointer to a string
typedef const char FAR* LPCSTR; // far pointer to a read-only string

typedef void*      POSITION;   // abstract iteration position

// Standard constants
#undef FALSE
#undef TRUE
#undef NULL

#define FALSE   0
#define TRUE    1
#define NULL    0

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support
#ifdef _DEBUG
extern "C"
{
void CDECL AfxTrace(LPCSTR pszFormat, ...);
void AFXAPI AfxAssertFailedLine(LPCSTR lpszFileName, int nLine);
void AFXAPI AfxAssertValidObject(const CObject* pOb,
				LPCSTR lpszFileName, int nLine);
void AFXAPI AfxDump(const CObject* pOb); // Dump an object from CodeView
}
#define TRACE              ::AfxTrace
#define THIS_FILE          __FILE__
#define ASSERT(f)          ((f) ? (void)0 : \
								::AfxAssertFailedLine(THIS_FILE, __LINE__))
#define VERIFY(f)          ASSERT(f)
#define ASSERT_VALID(pOb)  (::AfxAssertValidObject(pOb, THIS_FILE, __LINE__))

// The following trace macros put the trace string in a code segment
// so that it will not impact DGROUP
#define TRACE0(sz) \
				do { \
					static char BASED_DEBUG _sz[] = sz; \
					::AfxTrace(_sz); \
				} while (0)
#define TRACE1(sz, p1) \
				do { \
					static char BASED_DEBUG _sz[] = sz; \
					::AfxTrace(_sz, p1); \
				} while (0)
#define TRACE2(sz, p1, p2) \
				do { \
					static char BASED_DEBUG _sz[] = sz; \
					::AfxTrace(_sz, p1, p2); \
				} while (0)
#define TRACE3(sz, p1, p2, p3) \
				do { \
					static char BASED_DEBUG _sz[] = sz; \
					::AfxTrace(_sz, p1, p2, p3); \
				} while (0)
// Use this in Dump to put the string literals in a code segment and
// out of DGROUP.
#define AFX_DUMP0(dc, sz) \
				do { \
					static char BASED_DEBUG _sz[] = sz; \
					dc << _sz; \
				} while (0)
#define AFX_DUMP1(dc, sz, p1) \
				do { \
					static char BASED_DEBUG _sz[] = sz; \
					dc << _sz << p1; \
				} while (0)
#else
#define ASSERT(f)          ((void)0)
#define VERIFY(f)          ((void)(f))
#define ASSERT_VALID(pOb)  ((void)0)
inline void CDECL AfxTrace(LPCSTR /* pszFormat */, ...) { }
#define TRACE              1 ? (void)0 : ::AfxTrace
#define TRACE0             1 ? (void)0 : ::AfxTrace
#define TRACE1             1 ? (void)0 : ::AfxTrace
#define TRACE2             1 ? (void)0 : ::AfxTrace
#define TRACE3             1 ? (void)0 : ::AfxTrace
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files
#ifndef ALL_WARNINGS
#pragma warning(disable: 4001)  // nameless unions are part of C++
#pragma warning(disable: 4061)  // allow enums in switch with default
#pragma warning(disable: 4127)  // constant expression for TRACE/ASSERT
#pragma warning(disable: 4134)  // message map member fxn casts
#pragma warning(disable: 4505)  // optimize away locals
#pragma warning(disable: 4510)  // default constructors are bad to have
#pragma warning(disable: 4511)  // private copy constructors are good to have
#pragma warning(disable: 4512)  // private operator= are good to have
#ifdef STRICT
#pragma warning(disable: 4305)  // STRICT handles are near*, integer truncation
#endif
#if (_MSC_VER >= 800)
// turn off code generator warnings for information lost in normal optimizations
#pragma warning(disable: 4705)  // TRACE turned into statement with no effect
#pragma warning(disable: 4710)  // private constructors are disallowed
#pragma warning(disable: 4791)  // loss of debugging info in retail version
#endif
#endif //ALL_WARNINGS

/////////////////////////////////////////////////////////////////////////////
// Other implementation helpers

#define BEFORE_START_POSITION ((void*)-1L)
#define _AFX_FP_OFF(thing) (*((UINT*)&(thing)))
#define _AFX_FP_SEG(lp) (*((UINT*)&(lp)+1))

/////////////////////////////////////////////////////////////////////////////
// Explicit extern for version API/Windows 3.0 loader problem
#ifdef _WINDOWS
extern "C" int AFXAPI _export _afx_version();
#else
extern "C" int AFXAPI _afx_version();
#endif

/////////////////////////////////////////////////////////////////////////////
// Basic object model

struct CRuntimeClass
{
// Attributes
	LPCSTR m_lpszClassName;
	int m_nObjectSize;
	UINT m_wSchema; // schema number of the loaded class
	void (PASCAL* m_pfnConstruct)(void* p); // NULL => abstract class
	CRuntimeClass* m_pBaseClass;

// Operations
	CObject* CreateObject();

// Implementation
	BOOL ConstructObject(void* pThis);
	void Store(CArchive& ar);
	static CRuntimeClass* PASCAL Load(CArchive& ar, UINT* pwSchemaNum);

	// CRuntimeClass objects linked together in simple list
	static CRuntimeClass* AFXAPI_DATA pFirstClass; // start of class list
	CRuntimeClass* m_pNextClass;       // linked list of registered classes
};


/////////////////////////////////////////////////////////////////////////////
// class CObject is the root of all compliant objects

#if defined(_M_I86MM) && !defined(_PORTABLE)
// force vtables to be in far code segments for medium model
class FAR CObjectRoot
{
protected:
	virtual CRuntimeClass* GetRuntimeClass() NEAR const = 0;
};

#pragma warning(disable: 4149)  // don't warn for medium model change
class NEAR CObject : public CObjectRoot
#else
class CObject
#endif
{
public:

// Object model (types, destruction, allocation)
	virtual CRuntimeClass* GetRuntimeClass() const;
	virtual ~CObject();  // virtual destructors are necessary

	// Diagnostic allocations
	void* operator new(size_t, void* p);
	void* operator new(size_t nSize);
	void operator delete(void* p);

#ifdef _DEBUG
	// for file name/line number tracking using DEBUG_NEW
	void* operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#endif

	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
protected:
	CObject();
private:
	CObject(const CObject& objectSrc);              // no implementation
	void operator=(const CObject& objectSrc);       // no implementation

// Attributes
public:
	BOOL IsSerializable() const;
	BOOL IsKindOf(const CRuntimeClass* pClass) const;

// Overridables
	virtual void Serialize(CArchive& ar);

	// Diagnostic Support
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;

// Implementation
public:
	static CRuntimeClass AFXAPI_DATA classCObject;
};

#if defined(_M_I86MM)
#pragma warning(default: 4149)  // base class now ambient
#endif

// CObject::Serialize is always inline to avoid duplicate definitions
inline void CObject::Serialize(CArchive&)
	{ /* CObject does not serialize anything by default */ }

// Helper macros
#define RUNTIME_CLASS(class_name) \
	(&class_name::class##class_name)

//////////////////////////////////////////////////////////////////////////////
// Helper macros for declaring compliant classes

// AFXAPP_DATA will be NEAR for app classes but AFXAPI_DATA for library classes
#define AFXAPP_DATA     AFXAPI_DATA

#define DECLARE_DYNAMIC(class_name) \
public: \
	static CRuntimeClass AFXAPP_DATA class##class_name; \
	virtual CRuntimeClass* GetRuntimeClass() const;

// not serializable, but dynamically constructable
#define DECLARE_DYNCREATE(class_name) \
	DECLARE_DYNAMIC(class_name) \
	static void PASCAL Construct(void* p);

#define DECLARE_SERIAL(class_name) \
	DECLARE_DYNCREATE(class_name) \
	friend CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb);

// generate static object constructor for class registration
#ifdef AFX_CLASS_MODEL
struct NEAR AFX_CLASSINIT
#else
struct AFX_CLASSINIT
#endif
	{ AFX_CLASSINIT(CRuntimeClass* pNewClass); };

#define _IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, pfnNew) \
	static char BASED_CODE _lpsz##class_name[] = #class_name; \
	CRuntimeClass AFXAPP_DATA class_name::class##class_name = { \
		_lpsz##class_name, sizeof(class_name), wSchema, pfnNew, \
			RUNTIME_CLASS(base_class_name), NULL }; \
	static AFX_CLASSINIT _init_##class_name(&class_name::class##class_name); \
	CRuntimeClass* class_name::GetRuntimeClass() const \
		{ return &class_name::class##class_name; } \
// end of _IMPLEMENT_RUNTIMECLASS

#define IMPLEMENT_DYNAMIC(class_name, base_class_name) \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, NULL)

#define IMPLEMENT_DYNCREATE(class_name, base_class_name) \
	void PASCAL class_name::Construct(void* p) \
		{ new(p) class_name; } \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, 0xFFFF, \
		class_name::Construct)

#define IMPLEMENT_SERIAL(class_name, base_class_name, wSchema) \
	void PASCAL class_name::Construct(void* p) \
		{ new(p) class_name; } \
	_IMPLEMENT_RUNTIMECLASS(class_name, base_class_name, wSchema, \
		class_name::Construct) \
	CArchive& AFXAPI operator>>(CArchive& ar, class_name* &pOb) \
		{ pOb = (class_name*) ar.ReadObject(RUNTIME_CLASS(class_name)); \
			return ar; } \
// end of IMPLEMENT_SERIAL

/////////////////////////////////////////////////////////////////////////////
// other helpers

// zero fill everything after the VTable pointer
#define AFX_ZERO_INIT_OBJECT(base_class) \
	memset(((base_class*)this)+1, 0, sizeof(*this) - sizeof(base_class));

// Windows compatible setjmp for C++
#ifndef _AFX_JBLEN
// use default Window C++ calling convention
#define _AFX_JBLEN  9
extern "C" int FAR PASCAL Catch(int FAR*);
#endif

/////////////////////////////////////////////////////////////////////////////
// Exceptions

class CException : public CObject
{
	// abstract class for dynamic type checking
	DECLARE_DYNAMIC(CException)
};

// out-of-line routines for smaller code
BOOL AFXAPI AfxCatchProc(CRuntimeClass* pClass);
void AFXAPI AfxThrow(CException* pException, BOOL bShared);
void AFXAPI AfxThrowLast();
void AFXAPI AfxTryCleanupProc();

// Placed on frame for EXCEPTION linkage
struct AFX_STACK_DATA AFX_EXCEPTION_LINK
{
	AFX_EXCEPTION_LINK* m_pLinkPrev;    // previous top, next in handler chain

	CException* m_pException;   // current exception (NULL in TRY block)
	BOOL m_bAutoDelete;         // m_pException is "auto-delete", if TRUE

	UINT m_nType;               // 0 for setjmp, !=0 for user extension
	union
	{
		int m_jumpBuf[_AFX_JBLEN]; // arg for Catch/Throw (nType = 0)
		struct
		{
			void (PASCAL* pfnCleanup)(AFX_EXCEPTION_LINK* pLink);
			void* pvData;       // extra data follows
		} m_callback;       // callback for cleanup (nType != 0)
	};

	AFX_EXCEPTION_LINK();       // for initialization and linking
	~AFX_EXCEPTION_LINK()       // for cleanup and unlinking
		{ AfxTryCleanupProc(); };
};

// Exception global state - never access directly
struct AFX_EXCEPTION_CONTEXT
{
	AFX_EXCEPTION_LINK* m_pLinkTop;

	// Note: most of the exception context is now in the AFX_EXCEPTION_LINK
};

void AFXAPI AfxAbort();

// Obsolete and non-portable: setting terminate handler
//  use CWinApp::ProcessWndProcException for Windows apps instead
void AFXAPI AfxTerminate();
#ifndef _AFXDLL
typedef void (AFXAPI* AFX_TERM_PROC)();
AFX_TERM_PROC AFXAPI AfxSetTerminate(AFX_TERM_PROC);
#endif //!_AFXDLL

/////////////////////////////////////////////////////////////////////////////
// Exception helper macros

#define TRY \
	{ AFX_EXCEPTION_LINK _afxExceptionLink; \
	if (::Catch(_afxExceptionLink.m_jumpBuf) == 0)

#define CATCH(class, e) \
	else if (::AfxCatchProc(RUNTIME_CLASS(class))) \
	{ class* e = (class*)_afxExceptionLink.m_pException;

#define AND_CATCH(class, e) \
	} else if (::AfxCatchProc(RUNTIME_CLASS(class))) \
	{ class* e = (class*)_afxExceptionLink.m_pException;

#define END_CATCH \
	} else { ::AfxThrowLast(); } }

#define THROW(e) ::AfxThrow(e, FALSE)
#define THROW_LAST() ::AfxThrowLast()

// Advanced macros for smaller code
#define CATCH_ALL(e) \
	else { CException* e = _afxExceptionLink.m_pException;

#define AND_CATCH_ALL(e) \
	} else { CException* e = _afxExceptionLink.m_pException;

#define END_CATCH_ALL } }

#define END_TRY }

/////////////////////////////////////////////////////////////////////////////
// Standard Exception classes

class CMemoryException : public CException
{
	DECLARE_DYNAMIC(CMemoryException)
public:
	CMemoryException();
};

class CNotSupportedException : public CException
{
	DECLARE_DYNAMIC(CNotSupportedException)
public:
	CNotSupportedException();
};

class CArchiveException : public CException
{
	DECLARE_DYNAMIC(CArchiveException)
public:
	enum {
		none,
		generic,
		readOnly,
		endOfFile,
		writeOnly,
		badIndex,
		badClass,
		badSchema
	};

// Constructor
	CArchiveException(int cause = CArchiveException::none);

// Attributes
	int m_cause;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

class CFileException : public CException
{
	DECLARE_DYNAMIC(CFileException)

public:
	enum {
		none,
		generic,
		fileNotFound,
		badPath,
		tooManyOpenFiles,
		accessDenied,
		invalidFile,
		removeCurrentDir,
		directoryFull,
		badSeek,
		hardIO,
		sharingViolation,
		lockViolation,
		diskFull,
		endOfFile
	};

// Constructors

	CFileException(int cause = CFileException::none, LONG lOsError = -1);

// Attributes
	int m_cause;
	LONG m_lOsError;

// Operations

	// convert a OS dependent error code to a Cause
	static int PASCAL OsErrorToException(LONG lOsError);
	static int PASCAL ErrnoToException(int nErrno);

	// helper functions to throw exception after converting to a Cause
	static void PASCAL ThrowOsError(LONG lOsError);
	static void PASCAL ThrowErrno(int nErrno);

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Standard exception throws

void AFXAPI AfxThrowMemoryException();
void AFXAPI AfxThrowNotSupportedException();
void AFXAPI AfxThrowArchiveException(int cause);
void AFXAPI AfxThrowFileException(int cause, LONG lOsError = -1);


/////////////////////////////////////////////////////////////////////////////
// File - raw unbuffered disk file I/O

class CFile : public CObject
{
	DECLARE_DYNAMIC(CFile)

public:
// Flag values
	enum OpenFlags {
		modeRead =          0x0000,
		modeWrite =         0x0001,
		modeReadWrite =     0x0002,
		shareCompat =       0x0000,
		shareExclusive =    0x0010,
		shareDenyWrite =    0x0020,
		shareDenyRead =     0x0030,
		shareDenyNone =     0x0040,
		modeNoInherit =     0x0080,
		modeCreate =        0x1000,
		typeText =          0x4000, // typeText and typeBinary are used in
		typeBinary =   (int)0x8000 // derived classes only
		};

	enum Attribute {
		normal =    0x00,
		readOnly =  0x01,
		hidden =    0x02,
		system =    0x04,
		volume =    0x08,
		directory = 0x10,
		archive =   0x20
		};

	enum SeekPosition { begin = 0x0, current = 0x1, end = 0x2 };

	enum {hFileNull = -1};

// Constructors
	CFile();
	CFile(int hFile);
	CFile(const char* pszFileName, UINT nOpenFlags);

// Attributes
	UINT m_hFile;

	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;

// Operations
	virtual BOOL Open(const char* pszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);

	static void PASCAL Rename(const char* pszOldName,
				const char* pszNewName);
	static void PASCAL Remove(const char* pszFileName);
	static BOOL PASCAL GetStatus(const char* pszFileName,
				CFileStatus& rStatus);
	static void PASCAL SetStatus(const char* pszFileName,
				const CFileStatus& status);

	DWORD SeekToEnd();
	void SeekToBegin();

	// Helpers for > 32K read/write operations. Use for any CFile derived class.
	DWORD ReadHuge(void FAR* lpBuffer, DWORD dwCount);
	void WriteHuge(const void FAR* lpBuffer, DWORD dwCount);

// Overridables
	virtual CFile* Duplicate() const;

	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void SetLength(DWORD dwNewLen);
	virtual DWORD GetLength() const;

	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);

	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);

	virtual void Abort();
	virtual void Flush();
	virtual void Close();

// Implementation
public:
	virtual ~CFile();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	BOOL m_bCloseOnDelete;
};

/////////////////////////////////////////////////////////////////////////////
// STDIO file implementation

class CStdioFile : public CFile
{
	DECLARE_DYNAMIC(CStdioFile)

public:
// Constructors
	CStdioFile();
	CStdioFile(FILE* pOpenStream);
	CStdioFile(const char* pszFileName, UINT nOpenFlags);

// Attributes
	FILE* m_pStream;    // stdio FILE
						// m_hFile from base class is _fileno(m_pStream)

// Operations
	virtual void WriteString(LPCSTR lpsz);
		// write a string, like "C" fputs
	virtual LPSTR ReadString(LPSTR lpsz, UINT nMax);
		// like "C" fgets

// Implementation
public:
	virtual ~CStdioFile();
#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
	virtual DWORD GetPosition() const;
	virtual BOOL Open(const char* pszFileName, UINT nOpenFlags,
		CFileException* pError = NULL);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
};

////////////////////////////////////////////////////////////////////////////
// Memory based file implementation

class CMemFile : public CFile
{
	DECLARE_DYNAMIC(CMemFile)

public:
// Constructors
	CMemFile(UINT nGrowBytes = 1024);

// Advanced Overridables
protected:
	virtual BYTE FAR* Alloc(DWORD nBytes);
	virtual BYTE FAR* Realloc(BYTE FAR* lpMem, DWORD nBytes);
	virtual BYTE FAR* Memcpy(BYTE FAR* lpMemTarget, const BYTE FAR* lpMemSource, UINT nBytes);
	virtual void Free(BYTE FAR* lpMem);
	virtual void GrowFile(DWORD dwNewLen);

// Implementation
protected:
	UINT m_nGrowBytes;
	DWORD m_nPosition;
	DWORD m_nBufferSize;
	DWORD m_nFileSize;
	BYTE FAR* m_lpBuffer;
public:
	virtual ~CMemFile();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	virtual DWORD GetPosition() const;
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void SetLength(DWORD dwNewLen);
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();

	// Unsupported APIs
	virtual CFile* Duplicate() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
};

/////////////////////////////////////////////////////////////////////////////
// Strings

typedef char FAR* BSTR; // must match typedef in dispatch.h

class CString
{
public:

// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(char ch, int nRepeat = 1);
	CString(const char* psz);
	CString(const char* pch, int nLength);
#ifdef _NEARDATA
	// Additional versions for far string data
	CString(LPCSTR lpsz);
	CString(LPCSTR lpch, int nLength);
#endif
	~CString();

// Attributes & Operations

	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	char GetAt(int nIndex) const;       // 0 based
	char operator[](int nIndex) const;  // same as GetAt
	void SetAt(int nIndex, char ch);
	operator const char*() const;       // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(char ch);
	const CString& operator=(const char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(char ch);
	const CString& operator+=(const char* psz);

	friend CString AFXAPI operator+(const CString& string1,
			const CString& string2);
	friend CString AFXAPI operator+(const CString& string, char ch);
	friend CString AFXAPI operator+(char ch, const CString& string);
	friend CString AFXAPI operator+(const CString& string, const char* psz);
	friend CString AFXAPI operator+(const char* psz, const CString& string);

	// string comparison
	int Compare(const char* psz) const;         // straight character
	int CompareNoCase(const char* psz) const;   // ignore case
	int Collate(const char* psz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(const char* pszCharSet) const;
	CString SpanExcluding(const char* pszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char ch) const;                    // like "C" strchr
	int ReverseFind(char ch) const;
	int FindOneOf(const char* pszCharSet) const;

	// look for a specific sub-string
	int Find(const char* pszSub) const;         // like "C" strstr

	// input and output
#ifdef _DEBUG
	friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,
				const CString& string);
#endif
	friend CArchive& AFXAPI operator<<(CArchive& ar, const CString& string);
	friend CArchive& AFXAPI operator>>(CArchive& ar, CString& string);

	// Windows support
#ifdef _WINDOWS
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
	// ANSI<->OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();

	// OLE 2.0 BSTR support (use for OLE automation)
	BSTR AllocSysString();
	BSTR SetSysString(BSTR FAR* pbstr);
#endif //_WINDOWS

	// Access to string implementation buffer as "C" character array
	char* GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	char* GetBufferSetLength(int nNewLength);

// Implementation
public:
	int GetAllocLength() const;
protected:
	// lengths/sizes in characters
	//  (note: an extra character is always allocated)
	char* m_pchData;            // actual string (zero terminated)
	int m_nDataLength;          // does not include terminating 0
	int m_nAllocLength;         // does not include terminating 0

	// implementation helpers
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, const char* pszSrcData);
	void ConcatCopy(int nSrc1Len, const char* pszSrc1Data, int nSrc2Len, const char* pszSrc2Data);
	void ConcatInPlace(int nSrcLen, const char* pszSrcData);
	static void SafeDelete(char* pch);
	static int SafeStrlen(const char* psz);
};


// Compare helpers
BOOL AFXAPI operator==(const CString& s1, const CString& s2);
BOOL AFXAPI operator==(const CString& s1, const char* s2);
BOOL AFXAPI operator==(const char* s1, const CString& s2);
BOOL AFXAPI operator!=(const CString& s1, const CString& s2);
BOOL AFXAPI operator!=(const CString& s1, const char* s2);
BOOL AFXAPI operator!=(const char* s1, const CString& s2);
BOOL AFXAPI operator<(const CString& s1, const CString& s2);
BOOL AFXAPI operator<(const CString& s1, const char* s2);
BOOL AFXAPI operator<(const char* s1, const CString& s2);
BOOL AFXAPI operator>(const CString& s1, const CString& s2);
BOOL AFXAPI operator>(const CString& s1, const char* s2);
BOOL AFXAPI operator>(const char* s1, const CString& s2);
BOOL AFXAPI operator<=(const CString& s1, const CString& s2);
BOOL AFXAPI operator<=(const CString& s1, const char* s2);
BOOL AFXAPI operator<=(const char* s1, const CString& s2);
BOOL AFXAPI operator>=(const CString& s1, const CString& s2);
BOOL AFXAPI operator>=(const CString& s1, const char* s2);
BOOL AFXAPI operator>=(const char* s1, const CString& s2);

/////////////////////////////////////////////////////////////////////////////
// CTimeSpan and CTime

class CTimeSpan
{
public:

// Constructors
	CTimeSpan();
	CTimeSpan(time_t time);
	CTimeSpan(LONG lDays, int nHours, int nMins, int nSecs);

	CTimeSpan(const CTimeSpan& timeSpanSrc);
	const CTimeSpan& operator=(const CTimeSpan& timeSpanSrc);

// Attributes
	// extract parts
	LONG GetDays() const;   // total # of days
	LONG GetTotalHours() const;
	int GetHours() const;
	LONG GetTotalMinutes() const;
	int GetMinutes() const;
	LONG GetTotalSeconds() const;
	int GetSeconds() const;

// Operations
	// time math
	CTimeSpan operator-(CTimeSpan timeSpan) const;
	CTimeSpan operator+(CTimeSpan timeSpan) const;
	const CTimeSpan& operator+=(CTimeSpan timeSpan);
	const CTimeSpan& operator-=(CTimeSpan timeSpan);
	BOOL operator==(CTimeSpan timeSpan) const;
	BOOL operator!=(CTimeSpan timeSpan) const;
	BOOL operator<(CTimeSpan timeSpan) const;
	BOOL operator>(CTimeSpan timeSpan) const;
	BOOL operator<=(CTimeSpan timeSpan) const;
	BOOL operator>=(CTimeSpan timeSpan) const;

#if !defined(_AFXDLL) && !defined(_USRDLL)
	CString Format(const char* pFormat) const;
#endif //! DLL variant

	// serialization
#ifdef _DEBUG
	friend CDumpContext& AFXAPI operator<<(CDumpContext& dc,CTimeSpan timeSpan);
#endif
	friend CArchive& AFXAPI operator<<(CArchive& ar, CTimeSpan timeSpan);
	friend CArchive& AFXAPI operator>>(CArchive& ar, CTimeSpan& rtimeSpan);

private:
	time_t m_timeSpan;
	friend class CTime;
};

class CTime
{
public:

// Constructors
	static CTime PASCAL GetCurrentTime();

	CTime();
	CTime(time_t time);
	CTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec);
	CTime(WORD wDosDate, WORD wDosTime);
	CTime(const CTime& timeSrc);

	const CTime& operator=(const CTime& timeSrc);
	const CTime& operator=(time_t t);

// Attributes
	struct tm* GetGmtTm(struct tm* ptm = NULL) const;
	struct tm* GetLocalTm(struct tm* ptm = NULL) const;

	time_t GetTime() const;
	int GetYear() const;
	int GetMonth() const;       // month of year (1 = Jan)
	int GetDay() const;         // day of month
	int GetHour() const;
	int GetMinute() const;
	int GetSecond() const;
	int GetDayOfWeek() const;   // 1=Sun, 2=Mon, ..., 7=Sat

// Operations
	// time math
	CTimeSpan operator-(CTime time) const;
	CTime operator-(CTimeSpan timeSpan) const;
	CTime operator+(CTimeSpan timeSpan) const;
	const CTime& operator+=(CTimeSpan timeSpan);
	const CTime& operator-=(CTimeSpan timeSpan);
	BOOL operator==(CTime time) const;
	BOOL operator!=(CTime time) const;
	BOOL operator<(CTime time) const;
	BOOL operator>(CTime time) const;
	BOOL operator<=(CTime time) const;
	BOOL operator>=(CTime time) const;

	// formatting using "C" strftime
#if !defined(_AFXDLL) && !defined(_USRDLL)
	CString Format(const char* pFormat) const;
	CString FormatGmt(const char* pFormat) const;
#endif //! DLL variant

	// serialization
#ifdef _DEBUG
	friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, CTime time);
#endif
	friend CArchive& AFXAPI operator<<(CArchive& ar, CTime time);
	friend CArchive& AFXAPI operator>>(CArchive& ar, CTime& rtime);

private:
	time_t m_time;
};

/////////////////////////////////////////////////////////////////////////////
// File status

struct CFileStatus
{
	CTime m_ctime;          // creation date/time of file
	CTime m_mtime;          // last modification date/time of file
	CTime m_atime;          // last access date/time of file
	LONG m_size;            // logical size of file in bytes
	BYTE m_attribute;       // logical OR of CFile::Attribute enum values
	BYTE _m_padding;        // pad the structure to a WORD
	char m_szFullName[_MAX_PATH]; // absolute path name

#ifdef _DEBUG
	void Dump(CDumpContext& dc) const;
#endif
};


/////////////////////////////////////////////////////////////////////////////
// Diagnostic memory management routines

// Low level sanity checks for memory blocks
extern "C" BOOL AFXAPI AfxIsValidAddress(const void FAR* lp,
			UINT nBytes, BOOL bReadWrite = TRUE);
#ifdef _NEARDATA
BOOL AFXAPI AfxIsValidAddress(const void NEAR* np, UINT nBytes,
			BOOL bReadWrite = TRUE);
#endif
extern "C" BOOL AFXAPI AfxIsValidString(LPCSTR lpsz, int nLength = -1);
#ifdef _NEARDATA
BOOL AFXAPI AfxIsValidString(const char*psz, int nLength = -1);
#endif

#ifdef _DEBUG

// Memory tracking allocation
void* operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#define DEBUG_NEW new(THIS_FILE, __LINE__)

// Return TRUE if valid memory block of nBytes
BOOL AFXAPI AfxIsMemoryBlock(const void* p, UINT nBytes,
			LONG* plRequestNumber = NULL);

// Return TRUE if memory is sane or print out what is wrong
BOOL AFXAPI AfxCheckMemory();

// Options for tuning the allocation diagnostics
extern "C" { extern int NEAR afxMemDF; }

enum AfxMemDF // memory debug/diagnostic flags
{
	allocMemDF          = 0x01,         // turn on debugging allocator
	delayFreeMemDF      = 0x02,         // delay freeing memory
	checkAlwaysMemDF    = 0x04          // AfxCheckMemory on every alloc/free
};

// Advanced initialization: for overriding default diagnostics
extern "C" BOOL AFXAPI AfxDiagnosticInit(void);

// turn on/off tracking for a short while
BOOL AFXAPI AfxEnableMemoryTracking(BOOL bTrack);

// Memory allocator failure simulation and control (_DEBUG only)

// A failure hook returns whether to permit allocation
typedef BOOL (AFXAPI* AFX_ALLOC_HOOK)(size_t nSize, BOOL bObject, LONG lRequestNumber);

// Set new hook, return old (never NULL)
AFX_ALLOC_HOOK AFXAPI AfxSetAllocHook(AFX_ALLOC_HOOK pfnAllocHook);

#ifndef _PORTABLE
// Debugger hook on specified allocation request - Obsolete
void AFXAPI AfxSetAllocStop(LONG lRequestNumber);
#endif

struct CBlockHeader;

// Memory state for snapshots/leak detection
struct CMemoryState
{
// Attributes
	enum blockUsage
	{
		freeBlock,    // memory not used
		objectBlock,  // contains a CObject derived class object
		bitBlock,     // contains ::operator new data
		nBlockUseMax  // total number of usages
	};

	struct CBlockHeader* m_pBlockHeader;
	LONG m_lCounts[nBlockUseMax];
	LONG m_lSizes[nBlockUseMax];
	LONG m_lHighWaterCount;
	LONG m_lTotalCount;

	CMemoryState();

// Operations
	void Checkpoint();  // fill with current state
	BOOL Difference(const CMemoryState& oldState,
					const CMemoryState& newState);  // fill with difference

	// Output to afxDump
	void DumpStatistics() const;
	void DumpAllObjectsSince() const;
};

// Enumerate allocated objects or runtime classes
void AFXAPI AfxDoForAllObjects(void (*pfn)(CObject* pObject,
			void* pContext), void* pContext);
void AFXAPI AfxDoForAllClasses(void (*pfn)(const CRuntimeClass* pClass,
			void* pContext), void* pContext);

#else

// NonDebug version that assume everything is OK
#define DEBUG_NEW new
#define AfxCheckMemory() TRUE
#define AfxIsMemoryBlock(p, nBytes) TRUE

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Archives for serializing CObject data

// needed for implementation
class CPtrArray;
class CMapPtrToWord;
class CDocument;

class CArchive
{
public:
// Flag values
	enum Mode { store = 0, load = 1, bNoFlushOnDelete = 2 };

	CArchive(CFile* pFile, UINT nMode, int nBufSize = 512, void FAR* lpBuf = NULL);
	~CArchive();

// Attributes
	BOOL IsLoading() const;
	BOOL IsStoring() const;
	BOOL IsBufferEmpty() const;
	CFile* GetFile() const;

	CDocument* m_pDocument; // pointer to document being serialized
							//  must set to serialize COleClientItems
							//  in a document!

// Operations
	UINT Read(void FAR* lpBuf, UINT nMax);
	void Write(const void FAR* lpBuf, UINT nMax);
	void Flush();
	void Close();
	void Abort();

public:
	// Object I/O is pointer based to avoid added construction overhead.
	// Use the Serialize member function directly for embedded objects.
	friend CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb);

	friend CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb);
	friend CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb);

	// insertion operations
	// NOTE: operators available only for fixed size types for portability
	CArchive& operator<<(BYTE by);
	CArchive& operator<<(WORD w);
	CArchive& operator<<(LONG l);
	CArchive& operator<<(DWORD dw);
	CArchive& operator<<(float f);
	CArchive& operator<<(double d);

	// extraction operations
	// NOTE: operators available only for fixed size types for portability
	CArchive& operator>>(BYTE& by);
	CArchive& operator>>(WORD& w);
	CArchive& operator>>(DWORD& dw);
	CArchive& operator>>(LONG& l);
	CArchive& operator>>(float& f);
	CArchive& operator>>(double& d);

	CObject* ReadObject(const CRuntimeClass* pClass);
	void WriteObject(const CObject* pOb);

// Implementation
public:
	BOOL m_bForceFlat;  // for COleClientItem implementation (default TRUE)
	void FillBuffer(UINT nBytesNeeded);

protected:
	// archive objects cannot be copied or assigned
	CArchive(const CArchive& arSrc);
	void operator=(const CArchive& arSrc);

	BOOL m_nMode;
	BOOL m_bUserBuf;
	int m_nBufSize;
	CFile* m_pFile;
	BYTE FAR* m_lpBufCur;
	BYTE FAR* m_lpBufMax;
	BYTE FAR* m_lpBufStart;

	UINT m_nMapCount;   // count and map used when storing
	union
	{
		CPtrArray* m_pLoadArray;
		CMapPtrToWord* m_pStoreMap;
	};
};


/////////////////////////////////////////////////////////////////////////////
// Diagnostic dumping

class CDumpContext
{
public:
	CDumpContext(CFile* pFile);

// Attributes
	int GetDepth() const;      // 0 => this object, 1 => children objects
	void SetDepth(int nNewDepth);

// Operations
	CDumpContext& operator<<(LPCSTR lpsz);
	CDumpContext& operator<<(const void FAR* lp);
#ifdef _NEARDATA
	CDumpContext& operator<<(const void NEAR* np);
#endif
	CDumpContext& operator<<(const CObject* pOb);
	CDumpContext& operator<<(const CObject& ob);
	CDumpContext& operator<<(BYTE by);
	CDumpContext& operator<<(WORD w);
	CDumpContext& operator<<(UINT u);
	CDumpContext& operator<<(LONG l);
	CDumpContext& operator<<(DWORD dw);
	CDumpContext& operator<<(float f);
	CDumpContext& operator<<(double d);
	CDumpContext& operator<<(int n);
	void HexDump(const char* pszLine, BYTE* pby, int nBytes, int nWidth);
	void Flush();

// Implementation
protected:
	// dump context objects cannot be copied or assigned
	CDumpContext(const CDumpContext& dcSrc);
	void operator=(const CDumpContext& dcSrc);
	void OutputString(LPCSTR lpsz);

	int m_nDepth;

public:
	CFile* m_pFile;
};

#ifdef _DEBUG
#ifdef _AFXCTL
extern CDumpContext& AFXAPP_DATA afxDump;
#else
extern CDumpContext& NEAR afxDump;
#endif

extern "C" { extern BOOL NEAR afxTraceEnabled; }
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

// macro to get ambient pointer from far pointer
//  (original pointer must have been ambient)
#define _AfxGetPtrFromFarPtr(p) ((void*)(DWORD)(LPVOID)(p))

#ifdef _AFX_ENABLE_INLINES
#define _AFX_INLINE inline
#include <afx.inl>
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

#endif // __AFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\include\sys\utime.h ===
/***
*sys\utime.h - definitions/declarations for utime()
*
*   Copyright (c) 1985-1992, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file defines the structure used by the utime routine to set
*   new file access and modification times.  NOTE - MS-DOS
*   does not recognize access time, so this field will
*   always be ignored and the modification time field will be
*   used to set the new time.
*
****/

#ifndef _INC_UTIME

#ifdef __cplusplus
extern "C" {
#endif 

#if (_MSC_VER <= 600)
#define __cdecl     _cdecl
#define __far       _far
#endif 

#ifndef _TIME_T_DEFINED
typedef long    time_t;
#define _TIME_T_DEFINED
#endif 

/* define struct used by utime() function */

#ifndef _UTIMBUF_DEFINED

struct _utimbuf {
    time_t actime;      /* access time */
    time_t modtime;     /* modification time */
    };

#ifndef __STDC__
/* Non-ANSI name for compatibility */
struct utimbuf {
    time_t actime;      /* access time */
    time_t modtime;     /* modification time */
    };
#endif 

#define _UTIMBUF_DEFINED
#endif 


/* function prototypes */

int __cdecl _utime(const char *, struct _utimbuf *);

#ifndef __STDC__
/* Non-ANSI name for compatibility */
int __cdecl utime(const char *, struct utimbuf *);
#endif 

#ifdef __cplusplus
}
#endif 

#define _INC_UTIME
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdd_.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXWIN.H)

/////////////////////////////////////////////////////////////////////////////
// Standard Dialog Data Exchange routines

// simple text operations
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, BYTE& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, UINT& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, long& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DWORD& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, float& value);
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, double& value);

// special control types
void AFXAPI DDX_Check(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_Radio(CDataExchange* pDX, int nIDC, int& value);
void AFXAPI DDX_LBString(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_CBString(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_LBIndex(CDataExchange* pDX, int nIDC, int& index);
void AFXAPI DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index);
#if (WINVER >= 0x030a)
void AFXAPI DDX_LBStringExact(CDataExchange* pDX, int nIDC, CString& value);
void AFXAPI DDX_CBStringExact(CDataExchange* pDX, int nIDC, CString& value);
#endif

// for getting access to the actual controls
void AFXAPI DDX_Control(CDataExchange* pDX, int nIDC, CWnd& rControl);

/////////////////////////////////////////////////////////////////////////////
// Standard Dialog Data Validation routines

// range - value must be >= minVal and <= maxVal
// NOTE: you will require casts for 'minVal' and 'maxVal' to use the
//   UINT, DWORD or float types
void AFXAPI DDV_MinMaxByte(CDataExchange* pDX, BYTE value, BYTE minVal, BYTE maxVal);
void AFXAPI DDV_MinMaxInt(CDataExchange* pDX, int value, int minVal, int maxVal);
void AFXAPI DDV_MinMaxLong(CDataExchange* pDX, long value, long minVal, long maxVal);
void AFXAPI DDV_MinMaxUInt(CDataExchange* pDX, UINT value, UINT minVal, UINT maxVal);
void AFXAPI DDV_MinMaxDWord(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal);
void AFXAPI DDV_MinMaxFloat(CDataExchange* pDX, float const& value, float minVal, float maxVal);
void AFXAPI DDV_MinMaxDouble(CDataExchange* pDX, double const& value, double minVal, double maxVal);

// number of characters
void AFXAPI DDV_MaxChars(CDataExchange* pDX, CString const& value, int nChars);

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdb.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDB_H__
#define __AFXDB_H__

#ifndef __AFXWIN_H__
#include <afxext.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDB - MFC SQL/ODBC/Database support

// Classes declared in this file

	//CException
		class CDBException;    // abnormal return value

	//CFieldExchange
		class CFieldExchange;   // Recordset Field Exchange

	//CObject
		class CDatabase;    // Connecting to databases
		class CRecordset;   // Data result sets

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CScrollView
					//CFormView
						class CRecordView;     // view records with a form

// Non CObject classes
struct CRecordsetStatus;
struct CFieldInfo;

/////////////////////////////////////////////////////////////////////////////

// include standard SQL/ODBC "C" APIs
#include <sql.h>        // core
#include <sqlext.h>     // extensions

// ODBC helpers
// return code left in 'nRetCode'
#define AFX_SQL_ASYNC(prs, SQLFunc) do { ASSERT(!CDatabase::InWaitForDataSource()); \
	while ((nRetCode = (SQLFunc)) == SQL_STILL_EXECUTING) \
		prs->OnWaitForDataSource(TRUE); \
	prs->OnWaitForDataSource(FALSE); } while (0)

#define AFX_SQL_SYNC(SQLFunc)   do { ASSERT(!CDatabase::InWaitForDataSource()); \
	nRetCode = SQLFunc; } while (0)

// Max display length in chars of timestamp (date & time) value
#define TIMESTAMP_PRECISION 23

// AFXDLL support
#undef AFXAPP_DATA
#define AFXAPP_DATA AFXAPIEX_DATA

//  Miscellaneous sizing info
#define MAX_CURRENCY     30     // Max size of Currency($) string
#define MAX_TNAME_LEN    64     // Max size of table names
#define MAX_FNAME_LEN    64     // Max size of field names
#define MAX_DBNAME_LEN   32     // Max size of a database name
#define MAX_DNAME_LEN    256        // Max size of Recordset names
#define MAX_CONNECT_LEN  512        // Max size of Connect string
#define MAX_CURSOR_NAME  18     // Max size of a cursor name

// Max size for CString (incl. zero term.) and CByteArray
#define MAXINT 32767

// Timeout and net wait defaults
#define DEFAULT_LOGIN_TIMEOUT 15    // seconds to before fail on connect
#define DEFAULT_QUERY_TIMEOUT 15    // seconds to before fail waiting for results
#define DEFAULT_MAX_WAIT_FOR_DATASOURCE 250 // milliseconds. Give DATASOURCE 1/4 second to respond
#define DEFAULT_MIN_WAIT_FOR_DATASOURCE 50  // milliseconds. Start value for min wait heuristic


// Field Flags, used to indicate status of fields
#define AFX_SQL_FIELD_FLAG_DIRTY    0x1
#define AFX_SQL_FIELD_FLAG_NULL     0x2

/////////////////////////////////////////////////////////////////////////////
// CDBException - something gone wrong

// Dbkit extended error codes
#define AFX_SQL_ERROR                           1000
#define AFX_SQL_ERROR_CONNECT_FAIL              AFX_SQL_ERROR+1
#define AFX_SQL_ERROR_RECORDSET_FORWARD_ONLY    AFX_SQL_ERROR+2
#define AFX_SQL_ERROR_EMPTY_COLUMN_LIST         AFX_SQL_ERROR+3
#define AFX_SQL_ERROR_FIELD_SCHEMA_MISMATCH     AFX_SQL_ERROR+4
#define AFX_SQL_ERROR_ILLEGAL_MODE              AFX_SQL_ERROR+5
#define AFX_SQL_ERROR_MULTIPLE_ROWS_AFFECTED    AFX_SQL_ERROR+6
#define AFX_SQL_ERROR_NO_CURRENT_RECORD         AFX_SQL_ERROR+7
#define AFX_SQL_ERROR_NO_ROWS_AFFECTED          AFX_SQL_ERROR+8
#define AFX_SQL_ERROR_RECORDSET_READONLY        AFX_SQL_ERROR+9
#define AFX_SQL_ERROR_SQL_NO_TOTAL              AFX_SQL_ERROR+10
#define AFX_SQL_ERROR_ODBC_LOAD_FAILED          AFX_SQL_ERROR+11
#define AFX_SQL_ERROR_DYNASET_NOT_SUPPORTED     AFX_SQL_ERROR+12
#define AFX_SQL_ERROR_SNAPSHOT_NOT_SUPPORTED    AFX_SQL_ERROR+13
#define AFX_SQL_ERROR_API_CONFORMANCE           AFX_SQL_ERROR+14
#define AFX_SQL_ERROR_SQL_CONFORMANCE           AFX_SQL_ERROR+15
#define AFX_SQL_ERROR_NO_DATA_FOUND             AFX_SQL_ERROR+16
#define AFX_SQL_ERROR_ROW_UPDATE_NOT_SUPPORTED  AFX_SQL_ERROR+17
#define AFX_SQL_ERROR_ODBC_V2_REQUIRED          AFX_SQL_ERROR+18
#define AFX_SQL_ERROR_NO_POSITIONED_UPDATES     AFX_SQL_ERROR+19
#define AFX_SQL_ERROR_LOCK_MODE_NOT_SUPPORTED   AFX_SQL_ERROR+20
#define AFX_SQL_ERROR_DATA_TRUNCATED            AFX_SQL_ERROR+21
#define AFX_SQL_ERROR_ROW_FETCH                 AFX_SQL_ERROR+22
#define AFX_SQL_ERROR_MAX                       AFX_SQL_ERROR+23

class CDBException : public CException
{
	DECLARE_DYNAMIC(CDBException)

// Attributes
public:
	RETCODE m_nRetCode;
	CString m_strError;
	CString m_strStateNativeOrigin;

// Implementation (use AfxThrowDBException to create)
public:
	CDBException(RETCODE nRetCode = SQL_SUCCESS);

	void BuildErrorString(CDatabase* pdb, HSTMT hstmt);
	void Empty();
	virtual ~CDBException();

#ifdef _DEBUG
	virtual void AssertValid() const;
	void TraceErrorMessage(LPCTSTR szTrace) const;
#endif // _DEBUG
};

void AFXAPI AfxThrowDBException(RETCODE nRetCode, CDatabase* pdb,
	HSTMT hstmt);

//////////////////////////////////////////////////////////////////////////////
// CLongBinary - a Long (generally > 32k in length) Binary object

#define AFX_SQL_DEFAULT_LONGBINARY_SIZE 1024

class CLongBinary : public CObject
{
	DECLARE_DYNAMIC(CLongBinary)

// Constructors
public:
	CLongBinary();

// Attributes
	HGLOBAL m_hData;
	DWORD m_dwDataLength;

// Implementation
public:
	virtual ~CLongBinary();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG
};

//////////////////////////////////////////////////////////////////////////////
// CDatabase - a SQL Database

class CDatabase : public CObject
{
	DECLARE_DYNAMIC(CDatabase)

// Constructors
public:
	CDatabase();

	virtual BOOL Open(LPCSTR lpszDSN, BOOL bExclusive = FALSE,
		BOOL bReadonly = FALSE, LPCSTR lpszConnect = "ODBC;");
	virtual void Close();

// Attributes
public:
	HDBC m_hdbc;

	BOOL IsOpen() const;        // Database successfully opened?
	BOOL CanUpdate() const;
	BOOL CanTransact() const;   // Are Transactions supported?

	CString GetDatabaseName() const;
	const CString& GetConnect() const;

	// global state - if waiting for datasource => not normal operations
	static BOOL PASCAL InWaitForDataSource();

// Operations
public:
	void SetLoginTimeout(DWORD dwSeconds);
	void SetQueryTimeout(DWORD dwSeconds);
	void SetSynchronousMode(BOOL bSynchronous);

	// transaction control
	BOOL BeginTrans();
	BOOL CommitTrans();
	BOOL Rollback();

	// direct sql execution
	BOOL ExecuteSQL(LPCSTR lpszSQL);

	// Cancel asynchronous operation
	void Cancel();

// Overridables
public:
	// set special options
	virtual void OnSetOptions(HSTMT hstmt);

	// Give user chance to cancel long operation
	virtual void OnWaitForDataSource(BOOL bStillExecuting);

// Implementation
public:
	virtual ~CDatabase();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;

	BOOL m_bTransactionPending;
#endif //_DEBUG

	// general error check
	virtual BOOL Check(RETCODE nRetCode) const;

	CString QuoteName(const char* szName);
	BOOL m_bStripTrailingSpaces;

protected:
	CString m_strConnect;

	int nRefCount;
	BOOL m_bUpdatable;
	BOOL m_bTransactions;
	DWORD m_dwLoginTimeout;
	HSTMT m_hstmt;
	DWORD m_dwWait;

	DWORD m_dwQueryTimeout;
	DWORD m_dwMinWaitForDataSource;
	DWORD m_dwMaxWaitForDataSource;
	BOOL m_bAsync;
	char m_chIDQuoteChar;

	void ThrowDBException(RETCODE nRetCode);
	void AllocConnect();
	void Free();

	// friend classes that call protected CDatabase overridables
	friend class CRecordset;
	friend class CFieldExchange;
	friend class CDBException;
};


//////////////////////////////// /////////////////////////////////////////////
// Recordset Field exchanged (RFX_)

#define AFX_RFX_INT_PSEUDO_NULL (0x7EE4)
#define AFX_RFX_LONG_PSEUDO_NULL (0x4a4d4120L)
#define AFX_RFX_BYTE_PSEUDO_NULL 255
#define AFX_RFX_SINGLE_PSEUDO_NULL (-9.123e19)
#define AFX_RFX_DOUBLE_PSEUDO_NULL (-9.123e19)
#define AFX_RFX_BOOL_PSEUDO_NULL 2
#define AFX_RFX_DATE_PSEUDO_NULL CTime(0)

#define AFX_RFX_BOOL        1
#define AFX_RFX_BYTE        2
#define AFX_RFX_INT     3
#define AFX_RFX_LONG        4
#define AFX_RFX_SINGLE      6
#define AFX_RFX_DOUBLE      7
#define AFX_RFX_DATE        8
#define AFX_RFX_BINARY      9
#define AFX_RFX_TEXT        10
#define AFX_RFX_LONGBINARY  11

// CFieldExchange - for field exchange
class AFX_STACK_DATA CFieldExchange
{
// Attributes
public:
	enum RFX_Operation
	{
		BindParam, // register users parameters with ODBC SQLSetParam
		BindFieldToColumn, // register users fields with ODBC SQLBindCol
		Fixup, // Set string lengths, clear status bits
		MarkForAddNew,
		MarkForUpdate,  // Prepare fields and flags for update operation
		Name, // append dirty field name
		NameValue, // append dirty name=value
		Value, // append dirty value or parameter marker
		SetFieldDirty, // Set status bit for changed status
		SetFieldNull,   // Set status bit for null value
		IsFieldDirty,// return TRUE if field is dirty
		IsFieldNull,// return TRUE if field is marked NULL
		IsFieldNullable,// return TRUE if field can hold NULL values
		StoreField, // archive values of current record
		LoadField,  // reload archived values into current record
		GetFieldInfoValue,  // general info on a field via pv for field
		GetFieldInfoOrdinal,    // general info on a field via field ordinal
		RebindDateParam, //  migrate date param values to proxy array before Requery
		MaxRFXOperation,
	};
	UINT m_nOperation;  // Type of exchange operation
	CRecordset* m_prs;  // recordset handle

// Operations
	enum FieldType
	{
		noFieldType,
		outputColumn,
		param,
	};

// Operations (for implementors of RFX procs)
	BOOL IsFieldType(UINT* pnField);

	// Indicate purpose of subsequent RFX calls
	void SetFieldType(UINT nFieldType);

// Implementation
	CFieldExchange(UINT nOperation, CRecordset* prs, void* pvField = NULL);

	void Default(const char *szName,
		void* pv, LONG* plLength, int nCType, UINT cbValue, UINT cbPrecision);

	int GetColumnType(int nColumn, UINT* pcbLength = NULL,
		int* pnScale = NULL, int* pnNullable = NULL);

	// Current type of field
	UINT m_nFieldType;

	// For GetFieldInfo
	CFieldInfo* m_pfi;  // GetFieldInfo return struct
	BOOL m_bFieldFound; // GetFieldInfo search successful?

	// For returning status info for a field
	BOOL m_bNull;       // return result of IsFieldNull(able)/Dirty operation
	BOOL m_bDirty;      // return result of IsFieldNull(able)/Dirty operation

	CString* m_pstr;    // Field name or destination for building various SQL clauses
	BOOL m_bField;      // Value to set for SetField operation
	void* m_pvField;    // For indicating an operation on a specific field
	CArchive* m_par;    // For storing/loading copy buffer
	LPCSTR m_lpszSeparator; // append after field names
	UINT m_nFields;     // count of fields for various operations
	UINT m_nParams;     // count of fields for various operations
	UINT m_nParamFields;    // count of fields for various operations
	HSTMT m_hstmt;      // For SQLSetParam on update statement
};

/////////////////////////////////////////////////////////////////////////////
// Standard RecordSet Field Exchange routines

// text data
void AFXAPI RFX_Text(CFieldExchange* pFX, const char *szName, CString& value,
	// Default max length for char and varchar, default datasource type
	int nMaxLength = 255, int nColumnType = SQL_VARCHAR);

// boolean data
void AFXAPI RFX_Bool(CFieldExchange* pFX, const char *szName, BOOL& value);

// integer data
void AFXAPI RFX_Long(CFieldExchange* pFX, const char *szName, long& value);
void AFXAPI RFX_Int(CFieldExchange* pFX, const char *szName, int& value);
void AFXAPI RFX_Single(CFieldExchange* pFX, const char *szName, float& value);
void AFXAPI RFX_Double(CFieldExchange* pFX, const char *szName, double& value);

// date and time
void AFXAPI RFX_Date(CFieldExchange* pFX, const char *szName, CTime& value);

// Binary data
void AFXAPI RFX_Binary(CFieldExchange* pFX, const char *szName, CByteArray& value,
	// Default max length is for binary and varbinary
	int nMaxLength = 255);
void AFXAPI RFX_Byte(CFieldExchange* pFX, const char *szName, BYTE& value);
void AFXAPI RFX_LongBinary(CFieldExchange* pFX, const char *szName, CLongBinary& value);


/////////////////////////////////////////////////////////////////////////////
// Database Dialog Data Exchange cover routines
// Cover routines provide database semantics on top of DDX routines

// simple text operations
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, BYTE& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, int& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, UINT& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, long& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, DWORD& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, CString& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, double& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldText(CDataExchange* pDX, int nIDC, float& value, CRecordset* pRecordset);

// special control types
void AFXAPI DDX_FieldCheck(CDataExchange* pDX, int nIDC, int& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldRadio(CDataExchange* pDX, int nIDC, int& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldLBString(CDataExchange* pDX, int nIDC, CString& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldCBString(CDataExchange* pDX, int nIDC, CString& value, CRecordset* pRecordset);
#if (WINVER >= 0x030a)
void AFXAPI DDX_FieldLBStringExact(CDataExchange* pDX, int nIDC, CString& value, CRecordset* pRecordset);
void AFXAPI DDX_FieldCBStringExact(CDataExchange* pDX, int nIDC, CString& value, CRecordset* pRecordset);
#endif

//////////////////////////////////////////////////////////////////////////////
// CRecordset - the result of a SQL Statement

#define AFX_MOVE_FIRST      0x80000000L
#define AFX_MOVE_PREVIOUS   -1L
#define AFX_MOVE_REFRESH    0L
#define AFX_MOVE_NEXT       +1L
#define AFX_MOVE_LAST       0x7fffffffL

class CRecordset : public CObject
{
	DECLARE_DYNAMIC(CRecordset)

// Constructor
protected:
	CRecordset(CDatabase* pDatabase = NULL);

public:
	virtual ~CRecordset();

	enum OpenType
	{
		dynaset,
		snapshot,
		forwardOnly
	};

	enum OpenOptions
	{
		none =          0x0,
		readOnly =      0x0004,
		appendOnly =        0x0008,
		optimizeBulkAdd =	0x2000, // Use prepared HSTMT for multiple AddNews, dirty fields must not change.
		firstBulkAdd =		0x4000,	// INTERNAL to MFC, don't specify on Open.
	};
	virtual BOOL Open(UINT nOpenType = snapshot, LPCSTR lpszSQL = NULL, DWORD dwOptions = none);
	virtual void Close();

// Attributes
public:
	HSTMT m_hstmt;          // Source statement for this resultset
	CDatabase* m_pDatabase;       // Source database for this resultset

	CString m_strFilter;        // Where clause
	CString m_strSort;      // Order By Clause

	BOOL CanAppend() const;     // Can AddNew be called?
	BOOL CanRestart() const;    // Can Requery be called to restart a query?
	BOOL CanScroll() const;     // Can MovePrev and MoveFirst be called?
	BOOL CanTransact() const;   // Are Transactions supported?
	BOOL CanUpdate() const;     // Can Edit/AddNew/Delete be called?

	const CString& GetSQL() const;      // SQL executed for this recordset
	const CString& GetTableName() const;        // Table name

	BOOL IsOpen() const;        // Recordset successfully opened?
	BOOL IsBOF() const;     // Beginning Of File
	BOOL IsEOF() const;     // End Of File
	BOOL IsDeleted() const;     // On a deleted record

	BOOL IsFieldDirty(void *pv);    // has field been updated?
	BOOL IsFieldNull(void *pv); // is field NULL valued?
	BOOL IsFieldNullable(void *pv); // can field be set to a NULL value

	long GetRecordCount() const;        // Records seen so far or -1 if unknown
	void GetStatus(CRecordsetStatus& rStatus) const;

// Operations
public:
	// cursor operations
	void MoveNext();
	void MovePrev();
	void MoveFirst();
	void MoveLast();
	virtual void Move(long lRows);

	// edit buffer operations
	void AddNew();      // add new record at the end
	void Edit();        // start editing
	BOOL Update();      // update it
	void Delete();      // delete the current record

	// field operations
	void SetFieldDirty(void *pv, BOOL bDirty = TRUE);
	void SetFieldNull(void *pv, BOOL bNull = TRUE);

	// locking control during Edit
	enum LockMode
	{
		optimistic,
		pessimistic,
	};
	void SetLockingMode(UINT nMode);

	// Recordset operations
	virtual BOOL Requery();         // Re-execute query based on new params

	// Cancel asynchronous operation
	void Cancel();

// Overridables
public:
	// Get default connect string
	virtual CString GetDefaultConnect();

	// Get SQL to execute
	virtual CString GetDefaultSQL() = 0;

	// set special options
	virtual void OnSetOptions(HSTMT hstmt);

	// Give user chance to cancel long operation
	virtual void OnWaitForDataSource(BOOL bStillExecuting);

	// for recordset field exchange
	virtual void DoFieldExchange(CFieldExchange* pFX) = 0;

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG

	virtual BOOL Check(RETCODE nRetCode) const; // general error check
	void InitRecord();
	virtual void PreBindFields();   // called before data fields are bound
	UINT m_nFields;         // number of RFX fields
	UINT m_nParams;         // number of RFX params

	// RFX Operations on fields of CRecordset
	UINT BindParams(HSTMT hstmt);
	void RebindDateParams(HSTMT hstmt);
	UINT BindFieldsToColumns();
	void Fixups();
	UINT AppendNames(CString* pstr, LPCSTR szSeparator);
	UINT AppendValues(HSTMT hstmt, CString* pstr, LPCSTR szSeparator);
	UINT AppendNamesValues(HSTMT hstmt, CString* pstr, LPCSTR szSeparator);
	void StoreFields();
	void LoadFields();
	void MarkForAddNew();
	void MarkForUpdate();
	BOOL GetFieldInfo(void* pv, CFieldInfo* pfi);
	BOOL GetFieldInfo(UINT nField, CFieldInfo* pfi);

	// RFX operation helper functions
	BOOL UnboundFieldInfo(UINT nField, CFieldInfo* pfi);

	void ThrowDBException(RETCODE nRetCode, HSTMT hstmt = SQL_NULL_HSTMT);

	CMemFile* m_pmemfile;   // For saving copy buffer
	CArchive* m_par;    // For saving copy buffer

	void AllocFlags();
	BYTE GetFieldFlags(UINT nField, UINT nFieldType = CFieldExchange::outputColumn);
	void SetFieldFlags(UINT nField, BYTE bFlags, UINT nFieldType = CFieldExchange::outputColumn);
	void ClearFieldFlags(UINT nField, BYTE bFlags, UINT nFieldType = CFieldExchange::outputColumn);
	LONG* GetFieldLength(CFieldExchange* pFX);
	BOOL IsFieldFlagNull(UINT nField, UINT nFieldType);
	BOOL IsFieldFlagDirty(UINT nField, UINT nFieldType);
	void** m_pvFieldProxy;
	void** m_pvParamProxy;

protected:
	UINT m_nOpenType;
	enum EditMode
	{
		noMode,
		edit,
		addnew
	};
	UINT m_nEditMode;
	BOOL m_bEOFSeen;
	long m_lRecordCount;
	long m_lCurrentRecord;
	CString m_strCursorName;
	// Perform operation based on m_nEditMode
	BOOL UpdateInsertDelete();
	void ReleaseCopyBuffer();
	BOOL m_nLockMode;       // Control concurrency for Edit()
	HSTMT m_hstmtUpdate;
	BOOL m_bRecordsetDb;
public:
	DWORD m_dwOptions;	// Cache options specified on Open.
protected:
	BOOL m_bBOF;
	BOOL m_bEOF;
	BOOL m_bUpdatable;      // Is recordset updatable?
	BOOL m_bAppendable;
	CString m_strSQL;       // SQL statement for recordset
	CString m_strTableName;     // source table of recordset
	BOOL m_bScrollable; // supports MovePrev
	BOOL m_bDeleted;
	DWORD m_dwWait;
	UINT m_nFieldsBound;
	BYTE* m_pbFieldFlags;
	LONG* m_plFieldLength;
	BYTE* m_pbParamFlags;
	LONG* m_plParamLength;
	BOOL m_bExtendedFetch;
	void BuildTableQuery();

	friend class CFieldExchange;
	friend class CRecordView;
};

#define AFX_CURRENT_RECORD_UNDEFINED -2
#define AFX_CURRENT_RECORD_BOF -1

// For returning status for a recordset
struct CRecordsetStatus
{
	long m_lCurrentRecord;  // -2=Unknown,-1=BOF,0=1st record. . .
	BOOL m_bRecordCountFinal;// Have we counted all records?
};

// For returning field info on RFX fields
struct CFieldInfo
{
	// For ID'ing field
	UINT nField;        // Field number
	CString strName;    // Field name
	void* pv;       // Address of value for field

	// Return info GetFieldInfo
	UINT nDataType;     // data type of field (BOOL, BYTE, etc)
	DWORD dwSize;       // Max size for field data
};

/////////////////////////////////////////////////////////////////////////////
// CRecordView - form for viewing data records

class CRecordView : public CFormView
{
	DECLARE_DYNAMIC(CRecordView)
// Construction
protected:  // must derive your own class
	CRecordView(LPCSTR lpszTemplateName);
	CRecordView(UINT nIDTemplate);

// Attributes
public:
	virtual CRecordset* OnGetRecordset() = 0;

	BOOL IsOnLastRecord();
	BOOL IsOnFirstRecord();

// Operations
public:
	virtual BOOL OnMove(UINT nIDMoveCommand);

// Implementation
public:
	virtual ~CRecordView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

protected:

	BOOL m_bOnFirstRecord;
	BOOL m_bOnLastRecord;

	//{{AFX_MSG(CRecordView)
	afx_msg void OnUpdateRecordFirst(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordPrev(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordNext(CCmdUI* pCmdUI);
	afx_msg void OnUpdateRecordLast(CCmdUI* pCmdUI);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#undef AFXAPP_DATA
#define AFXAPP_DATA NEAR

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXDBCORE_INLINE inline
#define _AFXDBRFX_INLINE inline
#define _AFXDBVIEW_INLINE inline
#include <afxdb.inl>
#undef _AFXDBVIEW_INLINE
#undef _AFXDBCORE_INLINE
#undef _AFXDBRFX_INLINE
#endif

//////////////////////////////////////////////////////////////////////////////
#endif //__AFXDB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxcoll.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXCOLL.H

#ifdef _AFXCOLL_INLINE

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CByteArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CByteArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CByteArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE BYTE CByteArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CByteArray::SetAt(int nIndex, BYTE newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
_AFXCOLL_INLINE BYTE& CByteArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE int CByteArray::Add(BYTE newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE BYTE CByteArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE BYTE& CByteArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CWordArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE WORD CWordArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CWordArray::SetAt(int nIndex, WORD newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
_AFXCOLL_INLINE WORD& CWordArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE int CWordArray::Add(WORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE WORD CWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE WORD& CWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CDWordArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CDWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE DWORD CDWordArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CDWordArray::SetAt(int nIndex, DWORD newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
_AFXCOLL_INLINE DWORD& CDWordArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE int CDWordArray::Add(DWORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE DWORD CDWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE DWORD& CDWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CUIntArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CUIntArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CUIntArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE UINT CUIntArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CUIntArray::SetAt(int nIndex, UINT newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
_AFXCOLL_INLINE UINT& CUIntArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE int CUIntArray::Add(UINT newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE UINT CUIntArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE UINT& CUIntArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CPtrArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void* CPtrArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CPtrArray::SetAt(int nIndex, void* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
_AFXCOLL_INLINE void*& CPtrArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE int CPtrArray::Add(void* newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CObArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CObArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CObArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE CObject* CObArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CObArray::SetAt(int nIndex, CObject* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
_AFXCOLL_INLINE CObject*& CObArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE int CObArray::Add(CObject* newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE CObject* CObArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE CObject*& CObArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CStringArray::GetSize() const
	{ return m_nSize; }
_AFXCOLL_INLINE int CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE CString CStringArray::GetAt(int nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CStringArray::SetAt(int nIndex, const char* newElement)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_pData[nIndex] = newElement; }
_AFXCOLL_INLINE CString& CStringArray::ElementAt(int nIndex)
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_pData[nIndex]; }
_AFXCOLL_INLINE int CStringArray::Add(const char* newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE CString CStringArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE CString& CStringArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CPtrList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPtrList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void*& CPtrList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE void* CPtrList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE void*& CPtrList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE void* CPtrList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CPtrList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CPtrList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE void*& CPtrList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE void* CPtrList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE void CPtrList::SetAt(POSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CObList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CObList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CObject*& CObList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CObject* CObList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CObject*& CObList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE CObject* CObList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CObList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CObList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CObject*& CObList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CObject* CObList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CObject*& CObList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CObject* CObList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CObject*& CObList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE CObject* CObList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE void CObList::SetAt(POSITION pos, CObject* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CStringList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CStringList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE CString& CStringList::GetHead()
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CString CStringList::GetHead() const
	{ ASSERT(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
_AFXCOLL_INLINE CString& CStringList::GetTail()
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE CString CStringList::GetTail() const
	{ ASSERT(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
_AFXCOLL_INLINE POSITION CStringList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
_AFXCOLL_INLINE POSITION CStringList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
_AFXCOLL_INLINE CString& CStringList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CString CStringList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
_AFXCOLL_INLINE CString& CStringList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CString CStringList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
_AFXCOLL_INLINE CString& CStringList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE CString CStringList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
_AFXCOLL_INLINE void CStringList::SetAt(POSITION pos, const char* newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CMapWordToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapWordToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapWordToPtr::SetAt(WORD key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapWordToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapWordToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CMapPtrToWord::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapPtrToWord::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapPtrToWord::SetAt(void* key, WORD newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapPtrToWord::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapPtrToWord::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CMapPtrToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapPtrToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapPtrToPtr::SetAt(void* key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapPtrToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapPtrToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CMapWordToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapWordToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapWordToOb::SetAt(WORD key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapWordToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapWordToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE int CMapStringToPtr::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToPtr::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToPtr::SetAt(const char* key, void* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToPtr::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToPtr::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE int CMapStringToOb::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToOb::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToOb::SetAt(const char* key, CObject* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToOb::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToOb::GetHashTableSize() const
	{ return m_nHashTableSize; }


////////////////////////////////////////////////////////////////////////////
_AFXCOLL_INLINE int CMapStringToString::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CMapStringToString::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void CMapStringToString::SetAt(const char* key, const char* newValue)
	{ (*this)[key] = newValue; }
_AFXCOLL_INLINE POSITION CMapStringToString::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }
_AFXCOLL_INLINE UINT CMapStringToString::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXCOLL_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdb.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDB.H

/////////////////////////////////////////////////////////////////////////////
// General database inlines

#ifdef _AFXDBCORE_INLINE

// CDatabase inlines
_AFXDBCORE_INLINE BOOL CDatabase::IsOpen() const
	{ ASSERT_VALID(this); return m_hdbc != SQL_NULL_HDBC; }
_AFXDBCORE_INLINE BOOL CDatabase::CanUpdate() const
	{ ASSERT(IsOpen()); return m_bUpdatable; }
_AFXDBCORE_INLINE BOOL CDatabase::CanTransact() const
	{ ASSERT(IsOpen()); return m_bTransactions; }
_AFXDBCORE_INLINE void CDatabase::SetLoginTimeout(DWORD dwSeconds)
	{ ASSERT_VALID(this); m_dwLoginTimeout = dwSeconds; }
_AFXDBCORE_INLINE void CDatabase::SetQueryTimeout(DWORD dwSeconds)
	{ ASSERT_VALID(this); m_dwQueryTimeout = dwSeconds; }
_AFXDBCORE_INLINE void CDatabase::SetSynchronousMode(BOOL bSynchronous)
	{ ASSERT_VALID(this); m_bAsync = !bSynchronous; }
_AFXDBCORE_INLINE const CString& CDatabase::GetConnect() const
	{ ASSERT_VALID(this); return m_strConnect; }
_AFXDBCORE_INLINE void CDatabase::ThrowDBException(RETCODE nRetCode)
	{ ASSERT_VALID(this); AfxThrowDBException(nRetCode, this, m_hstmt); }

// CRecordset inlines
_AFXDBCORE_INLINE BOOL CRecordset::IsOpen() const
	{ ASSERT_VALID(this); return m_hstmt != SQL_NULL_HSTMT; }
_AFXDBCORE_INLINE const CString& CRecordset::GetSQL() const
	{ ASSERT(IsOpen()); return m_strSQL; }
_AFXDBCORE_INLINE const CString& CRecordset::GetTableName() const
	{ ASSERT(IsOpen()); return m_strTableName; }
_AFXDBCORE_INLINE BOOL CRecordset::IsBOF() const
	{ ASSERT(IsOpen()); return m_bBOF; }
_AFXDBCORE_INLINE BOOL CRecordset::IsEOF() const
	{ ASSERT(IsOpen()); return m_bEOF; }
_AFXDBCORE_INLINE BOOL CRecordset::IsDeleted() const
	{ ASSERT(IsOpen()); return m_bDeleted; }
_AFXDBCORE_INLINE BOOL CRecordset::CanUpdate() const
	{ ASSERT(IsOpen()); return m_bUpdatable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanScroll() const
	{ ASSERT(IsOpen()); return m_bScrollable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanAppend() const
	{ ASSERT(IsOpen()); return m_bAppendable; }
_AFXDBCORE_INLINE BOOL CRecordset::CanRestart() const
	{ ASSERT(IsOpen()); return TRUE; }
_AFXDBCORE_INLINE BOOL CRecordset::CanTransact() const
	{ ASSERT(IsOpen());return m_pDatabase->m_bTransactions; }
_AFXDBCORE_INLINE long CRecordset::GetRecordCount() const
	{ ASSERT(IsOpen()); return m_lRecordCount; }
_AFXDBCORE_INLINE void CRecordset::GetStatus(CRecordsetStatus& rStatus) const
	{ ASSERT(IsOpen());
		rStatus.m_lCurrentRecord = m_lCurrentRecord;
		rStatus.m_bRecordCountFinal = m_bEOFSeen; }
_AFXDBCORE_INLINE void CRecordset::ThrowDBException(RETCODE nRetCode, HSTMT hstmt)
	{ ASSERT_VALID(this); AfxThrowDBException(nRetCode, m_pDatabase,
		(hstmt == SQL_NULL_HSTMT)? m_hstmt : hstmt); }
_AFXDBCORE_INLINE void CRecordset::MoveNext()
	{ ASSERT(IsOpen()); Move(AFX_MOVE_NEXT); }
_AFXDBCORE_INLINE void CRecordset::MovePrev()
	{ ASSERT(IsOpen()); Move(AFX_MOVE_PREVIOUS); }
_AFXDBCORE_INLINE void CRecordset::MoveFirst()
	{ ASSERT(IsOpen()); Move(AFX_MOVE_FIRST); }
_AFXDBCORE_INLINE void CRecordset::MoveLast()
	{ ASSERT(IsOpen()); Move(AFX_MOVE_LAST); }
_AFXDBCORE_INLINE BOOL CRecordset::IsFieldFlagNull(UINT nColumn, UINT nFieldType)
	{ ASSERT_VALID(this);
		return (GetFieldFlags(nColumn, nFieldType) & AFX_SQL_FIELD_FLAG_NULL) != 0; }
_AFXDBCORE_INLINE BOOL CRecordset::IsFieldFlagDirty(UINT nColumn, UINT nFieldType)
	{ ASSERT_VALID(this);
		return (GetFieldFlags(nColumn, nFieldType) & AFX_SQL_FIELD_FLAG_DIRTY) != 0; }

#endif //_AFXDBCORE_INLINE


#ifdef _AFXDBRFX_INLINE

_AFXDBRFX_INLINE void CFieldExchange::SetFieldType(UINT nFieldType)
	{ ASSERT(nFieldType == outputColumn || nFieldType == param);
		m_nFieldType = nFieldType; }

#endif //_AFXDBRFX_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afx.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFX.H

#ifdef _AFX_INLINE

/////////////////////////////////////////////////////////////////////////////

// CObject
_AFX_INLINE CObject::CObject()
	{ }
_AFX_INLINE CObject::~CObject()
	{ }
_AFX_INLINE void* CObject::operator new(size_t, void* p)
	{ return p; }
#ifndef _DEBUG
// _DEBUG versions in memory.cpp
_AFX_INLINE void CObject::operator delete(void* p)
	{ ::operator delete(p); }
_AFX_INLINE void* CObject::operator new(size_t nSize)
	{ return ::operator new(nSize); }
#endif


// exceptions
_AFX_INLINE CMemoryException::CMemoryException()
	{ }
_AFX_INLINE CNotSupportedException::CNotSupportedException()
	{ }
_AFX_INLINE CArchiveException::CArchiveException(int cause /* = CArchiveException::none */)
	{ m_cause = cause; }
_AFX_INLINE CFileException::CFileException(int cause /* = CFileException::none */, LONG lOsError /* = -1 */)
	{ m_cause = cause; m_lOsError = lOsError; }


// CFile

_AFX_INLINE DWORD CFile::SeekToEnd()
	{ return Seek(0, CFile::end); }
_AFX_INLINE void CFile::SeekToBegin()
	{ Seek(0, CFile::begin); }

// CString
_AFX_INLINE int CString::GetLength() const
	{ return m_nDataLength; }
_AFX_INLINE int CString::GetAllocLength() const
	{ return m_nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return m_nDataLength == 0; }
_AFX_INLINE CString::operator const char*() const
	{ return (const char*)m_pchData; }
_AFX_INLINE int CString::SafeStrlen(const char* psz)
	{ return (psz == NULL) ? NULL : strlen(psz); }

#ifndef _WINDOWS
_AFX_INLINE int CString::Compare(const char* psz) const
	{ return strcmp(m_pchData, psz); }
_AFX_INLINE int CString::CompareNoCase(const char* psz) const
	{ return _stricmp(m_pchData, psz); }
_AFX_INLINE int CString::Collate(const char* psz) const
	{ return strcoll(m_pchData, psz); }
_AFX_INLINE void CString::MakeUpper()
	{ _strupr(m_pchData); }
_AFX_INLINE void CString::MakeLower()
	{ _strlwr(m_pchData); }
// Windows version in AFXWIN.H
#endif //!_WINDOWS

_AFX_INLINE void CString::MakeReverse()
	{ _strrev(m_pchData); }
_AFX_INLINE char CString::GetAt(int nIndex) const
	{
		ASSERT(nIndex >= 0);
		ASSERT(nIndex < m_nDataLength);

		return m_pchData[nIndex];
	}
_AFX_INLINE char CString::operator[](int nIndex) const
	{
		// same as GetAt

		ASSERT(nIndex >= 0);
		ASSERT(nIndex < m_nDataLength);

		return m_pchData[nIndex];
	}
_AFX_INLINE void CString::SetAt(int nIndex, char ch)
	{
		ASSERT(nIndex >= 0);
		ASSERT(nIndex < m_nDataLength);
		ASSERT(ch != 0);

		m_pchData[nIndex] = ch;
	}
_AFX_INLINE BOOL AFXAPI operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE BOOL AFXAPI operator==(const CString& s1, const char* s2)
	{ return s1.Compare(s2) == 0; }
_AFX_INLINE BOOL AFXAPI operator==(const char* s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
_AFX_INLINE BOOL AFXAPI operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE BOOL AFXAPI operator!=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) != 0; }
_AFX_INLINE BOOL AFXAPI operator!=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
_AFX_INLINE BOOL AFXAPI operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL AFXAPI operator<(const CString& s1, const char* s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL AFXAPI operator<(const char* s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(const CString& s1, const char* s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL AFXAPI operator>(const char* s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE BOOL AFXAPI operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL AFXAPI operator<=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL AFXAPI operator<=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL AFXAPI operator>=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

// CTime and CTimeSpan
_AFX_INLINE CTimeSpan::CTimeSpan()
	{ }
_AFX_INLINE CTimeSpan::CTimeSpan(time_t time)
	{ m_timeSpan = time; }
_AFX_INLINE CTimeSpan::CTimeSpan(LONG lDays, int nHours, int nMins, int nSecs)
	{ m_timeSpan = nSecs + 60* (nMins + 60* (nHours + 24* lDays)); }
_AFX_INLINE CTimeSpan::CTimeSpan(const CTimeSpan& timeSpanSrc)
	{ m_timeSpan = timeSpanSrc.m_timeSpan; }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator=(const CTimeSpan& timeSpanSrc)
	{ m_timeSpan = timeSpanSrc.m_timeSpan; return *this; }
_AFX_INLINE LONG CTimeSpan::GetDays() const
	{ return m_timeSpan / (24*3600L); }
_AFX_INLINE LONG CTimeSpan::GetTotalHours() const
	{ return m_timeSpan/3600; }
_AFX_INLINE int CTimeSpan::GetHours() const
	{ return (int)(GetTotalHours() - GetDays()*24); }
_AFX_INLINE LONG CTimeSpan::GetTotalMinutes() const
	{ return m_timeSpan/60; }
_AFX_INLINE int CTimeSpan::GetMinutes() const
	{ return (int)(GetTotalMinutes() - GetTotalHours()*60); }
_AFX_INLINE LONG CTimeSpan::GetTotalSeconds() const
	{ return m_timeSpan; }
_AFX_INLINE int CTimeSpan::GetSeconds() const
	{ return (int)(GetTotalSeconds() - GetTotalMinutes()*60); }
_AFX_INLINE CTimeSpan CTimeSpan::operator-(CTimeSpan timeSpan) const
	{ return CTimeSpan(m_timeSpan - timeSpan.m_timeSpan); }
_AFX_INLINE CTimeSpan CTimeSpan::operator+(CTimeSpan timeSpan) const
	{ return CTimeSpan(m_timeSpan + timeSpan.m_timeSpan); }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator+=(CTimeSpan timeSpan)
	{ m_timeSpan += timeSpan.m_timeSpan; return *this; }
_AFX_INLINE const CTimeSpan& CTimeSpan::operator-=(CTimeSpan timeSpan)
	{ m_timeSpan -= timeSpan.m_timeSpan; return *this; }
_AFX_INLINE BOOL CTimeSpan::operator==(CTimeSpan timeSpan) const
	{ return m_timeSpan == timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator!=(CTimeSpan timeSpan) const
	{ return m_timeSpan != timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator<(CTimeSpan timeSpan) const
	{ return m_timeSpan < timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator>(CTimeSpan timeSpan) const
	{ return m_timeSpan > timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator<=(CTimeSpan timeSpan) const
	{ return m_timeSpan <= timeSpan.m_timeSpan; }
_AFX_INLINE BOOL CTimeSpan::operator>=(CTimeSpan timeSpan) const
	{ return m_timeSpan >= timeSpan.m_timeSpan; }


_AFX_INLINE CTime::CTime()
	{ }
_AFX_INLINE CTime::CTime(time_t time)
	{ m_time = time; }
_AFX_INLINE CTime::CTime(const CTime& timeSrc)
	{ m_time = timeSrc.m_time; }
_AFX_INLINE const CTime& CTime::operator=(const CTime& timeSrc)
	{ m_time = timeSrc.m_time; return *this; }
_AFX_INLINE const CTime& CTime::operator=(time_t t)
	{ m_time = t; return *this; }
_AFX_INLINE time_t CTime::GetTime() const
	{ return m_time; }
_AFX_INLINE int CTime::GetYear() const
	{ return (GetLocalTm(NULL)->tm_year) + 1900; }
_AFX_INLINE int CTime::GetMonth() const
	{ return GetLocalTm(NULL)->tm_mon + 1; }
_AFX_INLINE int CTime::GetDay() const
	{ return GetLocalTm(NULL)->tm_mday; }
_AFX_INLINE int CTime::GetHour() const
	{ return GetLocalTm(NULL)->tm_hour; }
_AFX_INLINE int CTime::GetMinute() const
	{ return GetLocalTm(NULL)->tm_min; }
_AFX_INLINE int CTime::GetSecond() const
	{ return GetLocalTm(NULL)->tm_sec; }
_AFX_INLINE int CTime::GetDayOfWeek() const
	{ return GetLocalTm(NULL)->tm_wday + 1; }
_AFX_INLINE CTimeSpan CTime::operator-(CTime time) const
	{ return CTimeSpan(m_time - time.m_time); }
_AFX_INLINE CTime CTime::operator-(CTimeSpan timeSpan) const
	{ return CTime(m_time - timeSpan.m_timeSpan); }
_AFX_INLINE CTime CTime::operator+(CTimeSpan timeSpan) const
	{ return CTime(m_time + timeSpan.m_timeSpan); }
_AFX_INLINE const CTime& CTime::operator+=(CTimeSpan timeSpan)
	{ m_time += timeSpan.m_timeSpan; return *this; }
_AFX_INLINE const CTime& CTime::operator-=(CTimeSpan timeSpan)
	{ m_time -= timeSpan.m_timeSpan; return *this; }
_AFX_INLINE BOOL CTime::operator==(CTime time) const
	{ return m_time == time.m_time; }
_AFX_INLINE BOOL CTime::operator!=(CTime time) const
	{ return m_time != time.m_time; }
_AFX_INLINE BOOL CTime::operator<(CTime time) const
	{ return m_time < time.m_time; }
_AFX_INLINE BOOL CTime::operator>(CTime time) const
	{ return m_time > time.m_time; }
_AFX_INLINE BOOL CTime::operator<=(CTime time) const
	{ return m_time <= time.m_time; }
_AFX_INLINE BOOL CTime::operator>=(CTime time) const
	{ return m_time >= time.m_time; }


// CArchive
_AFX_INLINE BOOL CArchive::IsLoading() const
	{ return (m_nMode & CArchive::load) != 0; }
_AFX_INLINE BOOL CArchive::IsStoring() const
	{ return (m_nMode & CArchive::load) == 0; }
_AFX_INLINE BOOL CArchive::IsBufferEmpty() const
	{ return m_lpBufCur == m_lpBufMax; }
_AFX_INLINE CFile* CArchive::GetFile() const
	{ return m_pFile; }
_AFX_INLINE CArchive& CArchive::operator<<(BYTE by)
	{ if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax) Flush();
		*(BYTE FAR*)m_lpBufCur = by; m_lpBufCur += sizeof(BYTE); return *this; }
_AFX_INLINE CArchive& CArchive::operator<<(WORD w)
	{ if (m_lpBufCur + sizeof(WORD) > m_lpBufMax) Flush();
		*(WORD FAR*)m_lpBufCur = w; m_lpBufCur += sizeof(WORD); return *this; }
_AFX_INLINE CArchive& CArchive::operator<<(LONG l)
	{ if (m_lpBufCur + sizeof(LONG) > m_lpBufMax) Flush();
		*(LONG FAR*)m_lpBufCur = l; m_lpBufCur += sizeof(LONG); return *this; }
_AFX_INLINE CArchive& CArchive::operator<<(DWORD dw)
	{ if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax) Flush();
		*(DWORD FAR*)m_lpBufCur = dw; m_lpBufCur += sizeof(DWORD); return *this; }
_AFX_INLINE CArchive& CArchive::operator<<(float f)
	{ if (m_lpBufCur + sizeof(float) > m_lpBufMax) Flush();
		*(_AFXFLOAT FAR*)m_lpBufCur = *(_AFXFLOAT FAR*)&f; m_lpBufCur += sizeof(float); return *this; }
_AFX_INLINE CArchive& CArchive::operator<<(double d)
	{ if (m_lpBufCur + sizeof(double) > m_lpBufMax) Flush();
		*(_AFXDOUBLE FAR*)m_lpBufCur = *(_AFXDOUBLE FAR*)&d; m_lpBufCur += sizeof(double); return *this; }
_AFX_INLINE CArchive& CArchive::operator>>(BYTE& by)
	{ if (m_lpBufCur + sizeof(BYTE) > m_lpBufMax)
			FillBuffer(sizeof(BYTE) - (UINT)(m_lpBufMax - m_lpBufCur));
		by = *(BYTE FAR*)m_lpBufCur; m_lpBufCur += sizeof(BYTE); return *this; }
_AFX_INLINE CArchive& CArchive::operator>>(WORD& w)
	{ if (m_lpBufCur + sizeof(WORD) > m_lpBufMax)
			FillBuffer(sizeof(WORD) - (UINT)(m_lpBufMax - m_lpBufCur));
		w = *(WORD FAR*)m_lpBufCur; m_lpBufCur += sizeof(WORD); return *this; }
_AFX_INLINE CArchive& CArchive::operator>>(DWORD& dw)
	{ if (m_lpBufCur + sizeof(DWORD) > m_lpBufMax)
			FillBuffer(sizeof(DWORD) - (UINT)(m_lpBufMax - m_lpBufCur));
		dw = *(DWORD FAR*)m_lpBufCur; m_lpBufCur += sizeof(DWORD); return *this; }
_AFX_INLINE CArchive& CArchive::operator>>(float& f)
	{ if (m_lpBufCur + sizeof(float) > m_lpBufMax)
			FillBuffer(sizeof(float) - (UINT)(m_lpBufMax - m_lpBufCur));
		*(_AFXFLOAT FAR*)&f = *(_AFXFLOAT FAR*)m_lpBufCur; m_lpBufCur += sizeof(float); return *this; }
_AFX_INLINE CArchive& CArchive::operator>>(double& d)
	{ if (m_lpBufCur + sizeof(double) > m_lpBufMax)
			FillBuffer(sizeof(double) - (UINT)(m_lpBufMax - m_lpBufCur));
		*(_AFXDOUBLE FAR*)&d = *(_AFXDOUBLE FAR*)m_lpBufCur; m_lpBufCur += sizeof(double); return *this; }
_AFX_INLINE CArchive& CArchive::operator>>(LONG& l)
	{ if (m_lpBufCur + sizeof(LONG) > m_lpBufMax)
			FillBuffer(sizeof(LONG) - (UINT)(m_lpBufMax - m_lpBufCur));
		l = *(LONG FAR*)m_lpBufCur; m_lpBufCur += sizeof(LONG); return *this; }
_AFX_INLINE CArchive::CArchive(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE void CArchive::operator=(const CArchive& /* arSrc */)
	{ }
_AFX_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const CObject* pOb)
	{ ar.WriteObject(pOb); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }
_AFX_INLINE CArchive& AFXAPI operator>>(CArchive& ar, const CObject*& pOb)
	{ pOb = ar.ReadObject(NULL); return ar; }


// CDumpContext
_AFX_INLINE int CDumpContext::GetDepth() const
	{ return m_nDepth; }
_AFX_INLINE void CDumpContext::SetDepth(int nNewDepth)
	{ m_nDepth = nNewDepth; }
_AFX_INLINE CDumpContext::CDumpContext(const CDumpContext& /* dcSrc */)
	{ }
_AFX_INLINE void CDumpContext::operator=(const CDumpContext& /* dcSrc */)
	{ }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFX_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdisp.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef __AFXDISP_H__
#define __AFXDISP_H__

#ifndef __AFXWIN_H__
#include <afxwin.h>
#endif

// include OLE 2.0 headers
#define FARSTRUCT
#include <compobj.h>
#include <scode.h>
#include <storage.h>
#include <dispatch.h>

#include <stddef.h>

/////////////////////////////////////////////////////////////////////////////
// AFXDISP - MFC IDispatch & ClassFactory support

// Classes declared in this file

//CException
	class COleException;            // caught by client or server
	class COleDispatchException;    // special exception for IDispatch calls

//CCmdTarget
	class COleObjectFactory;        // glue for IClassFactory -> runtime class
		class COleTemplateServer;   // server documents using CDocTemplate

class COleDispatchDriver;           // helper class to call IDispatch

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFXAPP_DATA
#define AFXAPP_DATA     AFXAPIEX_DATA

/////////////////////////////////////////////////////////////////////////////
// OLE 2.0 COM (Component Object Model) implementation infastructure
//      - data driven QueryInterface
//      - standard implementation of aggregate AddRef and Release)
// (see CCmdTarget in AFXWIN.H for more information)

#define METHOD_PROLOGUE(theClass, localClass) \
	theClass* pThis = ((theClass*)((char*)_AfxGetPtrFromFarPtr(this) - \
		offsetof(theClass, m_x##localClass))); \

#define BEGIN_INTERFACE_PART(localClass, iface) \
	class FAR X##localClass : public iface \
	{ \
	public: \
		STDMETHOD_(ULONG, AddRef)(); \
		STDMETHOD_(ULONG, Release)(); \
		STDMETHOD(QueryInterface)(REFIID iid, LPVOID far* ppvObj); \

// Note: Inserts the rest of OLE functionality between these two macros,
//  depending upon the interface that is being implemented.  It is not
//  necessary to include AddRef, Release, and QueryInterface since those
//  member functions are declared by the macro.

#define END_INTERFACE_PART(localClass) \
	} m_x##localClass; \
	friend class X##localClass; \

#define BEGIN_INTERFACE_MAP(theClass, theBase) \
	AFX_INTERFACEMAP FAR* theClass::GetInterfaceMap() const \
		{ return &theClass::interfaceMap; } \
	AFX_INTERFACEMAP BASED_CODE theClass::interfaceMap = \
		{ &(theBase::interfaceMap), theClass::_interfaceEntries, }; \
	AFX_INTERFACEMAP_ENTRY BASED_CODE theClass::_interfaceEntries[] = \
	{

#define INTERFACE_PART(theClass, iid, localClass) \
		{ &iid, offsetof(theClass, m_x##localClass) }, \

#define INTERFACE_AGGREGATE(theClass, theAggr) \
		{ NULL, offsetof(theClass, theAggr) }, \

#define END_INTERFACE_MAP() \
		{ NULL, (size_t)-1 } \
	}; \

/////////////////////////////////////////////////////////////////////////////
// COleException - unexpected or rare OLE error returned

class COleException : public CException
{
	DECLARE_DYNAMIC(COleException)

public:
	SCODE m_sc;
	static SCODE PASCAL Process(const CException* pAnyException);

// Implementation (use AfxThrowOleException to create)
	COleException();
};

void AFXAPI AfxThrowOleException(SCODE sc);
void AFXAPI AfxThrowOleException(HRESULT hr);

/////////////////////////////////////////////////////////////////////////////
// IDispatch specific exception

class COleDispatchException : public CException
{
	DECLARE_DYNAMIC(COleDispatchException)

public:
// Attributes
	WORD m_wCode;   // error code (specific to IDispatch implementation)
	CString m_strDescription;   // human readable description of the error
	DWORD m_dwHelpContext;      // help context for error

	// usually empty in application which creates it (eg. servers)
	CString m_strHelpFile;      // help file to use with m_dwHelpContext
	CString m_strSource;        // source of the error (name of server)

// Implementation
public:
	COleDispatchException(LPCSTR lpszDescription, UINT nHelpID, WORD wCode);
	static void PASCAL Process(
		EXCEPINFO FAR* pInfo, const CException* pAnyException);

	SCODE m_scError;            // SCODE describing the error
};

void AFXAPI AfxThrowOleDispatchException(WORD wCode, LPCSTR lpszDescription,
	UINT nHelpID = 0);
void AFXAPI AfxThrowOleDispatchException(WORD wCode, UINT nDescriptionID,
	UINT nHelpID = -1);

/////////////////////////////////////////////////////////////////////////////
// Macros for CCmdTarget IDispatchable classes

#define BEGIN_DISPATCH_MAP(theClass, baseClass) \
	AFX_DISPMAP FAR* theClass::GetDispatchMap() const \
		{ return &theClass::dispatchMap; } \
	AFX_DISPMAP BASED_CODE theClass::dispatchMap = \
		{ &(baseClass::dispatchMap), theClass::_dispatchEntries }; \
	AFX_DISPMAP_ENTRY BASED_CODE theClass::_dispatchEntries[] = \
	{

#define END_DISPATCH_MAP() \
	{ VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
		(AFX_PMSG)NULL, (AFX_PMSG)NULL, (size_t)-1 } }; \

// parameter types: by value VTs
#define VTS_I2              "\x02"      // a 'short'
#define VTS_I4              "\x03"      // a 'long'
#define VTS_R4              "\x04"      // a 'float'
#define VTS_R8              "\x05"      // a 'double'
#define VTS_CY              "\x06"      // a 'const CY FAR&'
#define VTS_DATE            "\x07"      // a 'DATE'
#define VTS_BSTR            "\x08"      // an 'LPCSTR'
#define VTS_DISPATCH        "\x09"      // an 'IDispatch FAR*'
#define VTS_SCODE           "\x0A"      // an 'SCODE'
#define VTS_BOOL            "\x0B"      // a 'BOOL'
#define VTS_VARIANT         "\x0C"      // a 'const VARIANT FAR&'
#define VTS_UNKNOWN         "\x0D"      // an 'IUnknown FAR*'

// parameter types: by reference VTs
#define VTS_PI2             "\x42"      // a 'short FAR*'
#define VTS_PI4             "\x43"      // a 'long FAR*'
#define VTS_PR4             "\x44"      // a 'float FAR*'
#define VTS_PR8             "\x45"      // a 'double FAR*'
#define VTS_PCY             "\x46"      // a 'CY FAR*'
#define VTS_PDATE           "\x47"      // a 'DATE FAR*'
#define VTS_PBSTR           "\x48"      // a 'BSTR FAR*'
#define VTS_PDISPATCH       "\x49"      // an 'IDispatch FAR* FAR*'
#define VTS_PSCODE          "\x4A"      // an 'SCODE FAR*'
#define VTS_PBOOL           "\x4B"      // a 'BOOL FAR*'
#define VTS_PVARIANT        "\x4C"      // a 'VARIANT FAR*'
#define VTS_PUNKNOWN        "\x4D"      // an 'IUnknown FAR* FAR*'

// special VT_ and VTS_ values
#define VTS_NONE            ""          // used for members with 0 params
#define VT_MFCVALUE         0xFFF       // special value for DISPID_VALUE
#define VT_MFCBYREF         0x40        // indicates VT_BYREF type
#define VT_MFCMARKER        0xFF        // delimits named parameters

// these DISP_ macros cause the framework to generate the DISPID
#define DISP_FUNCTION(theClass, szExternalName, pfnMember, vtRetVal, vtsParams) \
	{ szExternalName, DISPID_UNKNOWN, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))pfnMember, (AFX_PMSG)0, 0 }, \

#define DISP_PROPERTY(theClass, szExternalName, memberName, vtPropType) \
	{ szExternalName, DISPID_UNKNOWN, "", vtPropType, (AFX_PMSG)0, (AFX_PMSG)0, \
		offsetof(theClass, memberName) }, \

#define DISP_PROPERTY_NOTIFY(theClass, szExternalName, memberName, pfnAfterSet, vtPropType) \
	{ szExternalName, DISPID_UNKNOWN, "", vtPropType, (AFX_PMSG)0, \
		(AFX_PMSG)(void (theClass::*)(void))pfnAfterSet, \
		offsetof(theClass, memberName) }, \

#define DISP_PROPERTY_EX(theClass, szExternalName, pfnGet, pfnSet, vtPropType) \
	{ szExternalName, DISPID_UNKNOWN, "", vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))pfnSet, 0 }, \

#define DISP_PROPERTY_PARAM(theClass, szExternalName, pfnGet, pfnSet, vtPropType, vtsParams) \
	{ szExternalName, DISPID_UNKNOWN, vtsParams, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))pfnSet, 0 }, \

// these DISP_ macros allow the app to determine the DISPID
#define DISP_FUNCTION_ID(theClass, szExternalName, dispid, pfnMember, vtRetVal, vtsParams) \
	{ szExternalName, dispid, vtsParams, vtRetVal, \
		(AFX_PMSG)(void (theClass::*)(void))pfnMember, (AFX_PMSG)0, 0 }, \

#define DISP_PROPERTY_ID(theClass, szExternalName, dispid, memberName, vtPropType) \
	{ szExternalName, dispid, "", vtPropType, (AFX_PMSG)0, (AFX_PMSG)0, \
		offsetof(theClass, memberName) }, \

#define DISP_PROPERTY_NOTIFY_ID(theClass, szExternalName, dispid, memberName, pfnAfterSet, vtPropType) \
	{ szExternalName, dispid, "", vtPropType, (AFX_PMSG)0, \
		(AFX_PMSG)(void (theClass::*)(void))pfnAfterSet, \
		offsetof(theClass, memberName) }, \

#define DISP_PROPERTY_EX_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType) \
	{ szExternalName, dispid, "", vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))pfnSet, 0 }, \

#define DISP_PROPERTY_PARAM_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType, vtsParams) \
	{ szExternalName, dispid, vtsParams, vtPropType, \
		(AFX_PMSG)(void (theClass::*)(void))pfnGet, \
		(AFX_PMSG)(void (theClass::*)(void))pfnSet, 0 }, \

// the DISP_DEFVALUE is a special case macro that creates an alias for DISPID_VALUE
#define DISP_DEFVALUE(theClass, szExternalName) \
	{ szExternalName, DISPID_UNKNOWN, "", VT_MFCVALUE, \
		(AFX_PMSG)0, (AFX_PMSG)0, 0 }, \

#define DISP_DEFVALUE_ID(theClass, dispid) \
	{ "", dispid, "", VT_MFCVALUE, (AFX_PMSG)0, (AFX_PMSG)0, 0 }, \

/////////////////////////////////////////////////////////////////////////////
// Macros for creating "creatable" automation classes.

#define DECLARE_OLECREATE(class_name) \
protected: \
	static COleObjectFactory NEAR factory; \
	static const GUID CDECL BASED_CODE guid;

#define IMPLEMENT_OLECREATE(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	static const char BASED_CODE _szProgID_##class_name[] = external_name; \
	COleObjectFactory NEAR class_name::factory(class_name::guid, \
		RUNTIME_CLASS(class_name), FALSE, _szProgID_##class_name); \
	const GUID CDECL BASED_CODE class_name::guid = \
		{ l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };

/////////////////////////////////////////////////////////////////////////////
// Helper class for driving IDispatch

class COleDispatchDriver
{
// Constructors
public:
	COleDispatchDriver();

// Operations
	BOOL CreateDispatch(REFCLSID clsid, COleException* pError = NULL);
	BOOL CreateDispatch(LPCSTR lpszProgID, COleException* pError = NULL);

	void AttachDispatch(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	LPDISPATCH DetachDispatch();
		// detach and get ownership of m_lpDispatch
	void ReleaseDispatch();

	// helpers for IDispatch::Invoke
	void InvokeHelper(DISPID dwDispID, WORD wFlags,
		VARTYPE vtRet, void* pvRet, const BYTE FAR* pbParamInfo, ...);
	void SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;

// Implementation
public:
	LPDISPATCH m_lpDispatch;

	~COleDispatchDriver();
	void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
		void* pvRet, const BYTE FAR* pbParamInfo, va_list argList);

protected:
	BOOL m_bAutoRelease;    // TRUE if destructor should call Release

private:
	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
	COleDispatchDriver(const COleDispatchDriver&);  // no implementation
	void operator=(const COleDispatchDriver&);  // no implementation
};

/////////////////////////////////////////////////////////////////////////////
// Class Factory implementation (binds OLE class factory -> runtime class)
//  (all specific class factories derive from this class factory)

class COleObjectFactory : public CCmdTarget
{
	DECLARE_DYNAMIC(COleObjectFactory)

// Construction
public:
	COleObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
		BOOL bMultiInstance, LPCSTR lpszProgID);

// Attributes
	BOOL IsRegistered() const;
	REFCLSID GetClassID() const;

// Operations
	BOOL Register();
	void Revoke();
	void UpdateRegistry(LPCSTR lpszProgID = NULL);
		// default uses m_lpszProgID if not NULL

	static BOOL PASCAL RegisterAll();
	static void PASCAL RevokeAll();
	static void PASCAL UpdateRegistryAll();

// Overridables
protected:
	virtual CCmdTarget* OnCreateObject();

// Implementation
public:
	virtual ~COleObjectFactory();
#ifdef _DEBUG
	void AssertValid() const;
	void Dump(CDumpContext& dc) const;
#endif

protected:
	COleObjectFactory* m_pNextFactory;  // list of factories maintained
	DWORD m_dwRegister;             // registry identifier
	CLSID m_clsid;                  // registered class ID
	CRuntimeClass* m_pRuntimeClass; // runtime class of CCmdTarget derivative
	BOOL m_bMultiInstance;          // multiple instance?
	LPCSTR m_lpszProgID;            // human readable class ID

// Interface Maps
protected:
	BEGIN_INTERFACE_PART(ClassFactory, IClassFactory)
		STDMETHOD(CreateInstance)(LPUNKNOWN, REFIID, LPVOID FAR*);
		STDMETHOD(LockServer)(BOOL);
	END_INTERFACE_PART(ClassFactory)

	DECLARE_INTERFACE_MAP()

#ifdef _AFXCTL
	friend HRESULT AfxDllGetClassObject(REFCLSID, REFIID, LPVOID FAR*);
#endif
	friend HRESULT STDAPICALLTYPE
		DllGetClassObject(REFCLSID, REFIID, LPVOID FAR*);
};

//////////////////////////////////////////////////////////////////////////////
// COleTemplateServer - COleObjectFactory using CDocTemplates

// This enumeration is used in AfxOleRegisterServerClass to pick the
//  correct registration entries given the application type.
enum OLE_APPTYPE
{
	OAT_INPLACE_SERVER = 0,     // server has full server user-interface
	OAT_SERVER = 1,             // server supports only embedding
	OAT_CONTAINER = 2,          // container supports links to embeddings
	OAT_DISPATCH_OBJECT = 3,    // IDispatch capable object
};

class COleTemplateServer : public COleObjectFactory
{
// Constructors
public:
	COleTemplateServer();

// Operations
	void ConnectTemplate(REFCLSID clsid, CDocTemplate* pDocTemplate,
		BOOL bMultiInstance);
		// set doc template after creating it in InitInstance
	void UpdateRegistry(OLE_APPTYPE nAppType = OAT_INPLACE_SERVER,
		LPCSTR FAR* rglpszRegister = NULL, LPCSTR FAR* rglpszOverwrite = NULL);
		// may want to UpdateRegistry if not run with /Embedded

// Implementation
protected:
	virtual CCmdTarget* OnCreateObject();
	CDocTemplate* m_pDocTemplate;

private:
	void UpdateRegistry(LPCSTR lpszProgID);
		// hide base class version of UpdateRegistry
};

/////////////////////////////////////////////////////////////////////////////
// helper functions for system registry maintenance

// Helper to register server in case of no .REG file loaded
BOOL AFXAPI AfxOleRegisterServerClass(
	REFCLSID clsid, LPCSTR lpszClassName,
	LPCSTR lpszShortTypeName, LPCSTR lpszLongTypeName,
	OLE_APPTYPE nAppType = OAT_SERVER,
	LPCSTR FAR* rglpszRegister = NULL, LPCSTR FAR* rglpszOverwrite = NULL);

// AfxOleRegisterHelper is a worker function used by AfxOleRegisterServerClass
//  (available for advanced registry work)
BOOL AFXAPI AfxOleRegisterHelper(LPCSTR FAR* rglpszRegister,
	LPCSTR FAR* rglpszSymbols, int nSymbols, BOOL bReplace);

/////////////////////////////////////////////////////////////////////////////
// Init & Term helpers

BOOL AFXAPI AfxOleInit();
void CALLBACK AfxOleTerm();

/////////////////////////////////////////////////////////////////////////////
// Global functions (may be overridden by replacing module OLELOCK?.CPP)

void AFXAPI AfxOleOnReleaseAllObjects();
BOOL AFXAPI AfxOleCanExitApp();
void AFXAPI AfxOleLockApp();
void AFXAPI AfxOleUnlockApp();

void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl);
BOOL AFXAPI AfxOleGetUserCtrl();

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

typedef CY CURRENCY;    // compatibility with 32-bit

#ifdef _AFX_ENABLE_INLINES
#define _AFXDISP_INLINE inline
#include <afxole.inl>
#undef _AFXDISP_INLINE
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

#endif //__AFXDISP_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxcoll.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXCOLL_H__
#define __AFXCOLL_H__

#ifndef __AFX_H__
#include <afx.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CObject
	// Arrays
	class CByteArray;           // array of BYTE
	class CWordArray;           // array of WORD
	class CDWordArray;          // array of DWORD
	class CUIntArray;           // array of UINT
	class CPtrArray;            // array of void*
	class CObArray;             // array of CObject*

	// Lists
	class CPtrList;             // list of void*
	class CObList;              // list of CObject*

	// Maps (aka Dictionaries)
	class CMapWordToOb;         // map from WORD to CObject*
	class CMapWordToPtr;        // map from WORD to void*
	class CMapPtrToWord;        // map from void* to WORD
	class CMapPtrToPtr;         // map from void* to void*

	// Special String variants
	class CStringArray;         // array of CStrings
	class CStringList;          // list of CStrings
	class CMapStringToPtr;      // map from CString to void*
	class CMapStringToOb;       // map from CString to CObject*
	class CMapStringToString;   // map from CString to CString

/////////////////////////////////////////////////////////////////////////////

#undef AFXAPP_DATA
#define AFXAPP_DATA     AFXAPI_DATA

////////////////////////////////////////////////////////////////////////////

class CByteArray : public CObject
{

	DECLARE_SERIAL(CByteArray)
public:

// Construction
	CByteArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	BYTE GetAt(int nIndex) const;
	void SetAt(int nIndex, BYTE newElement);
	BYTE& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, BYTE newElement);
	int Add(BYTE newElement);

	// overloaded operator helpers
	BYTE operator[](int nIndex) const;
	BYTE& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, BYTE newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CByteArray* pNewArray);

// Implementation
protected:
	BYTE* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CByteArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


////////////////////////////////////////////////////////////////////////////

class CWordArray : public CObject
{

	DECLARE_SERIAL(CWordArray)
public:

// Construction
	CWordArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(int nIndex) const;
	void SetAt(int nIndex, WORD newElement);
	WORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, WORD newElement);
	int Add(WORD newElement);

	// overloaded operator helpers
	WORD operator[](int nIndex) const;
	WORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, WORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CWordArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


////////////////////////////////////////////////////////////////////////////

class CDWordArray : public CObject
{

	DECLARE_SERIAL(CDWordArray)
public:

// Construction
	CDWordArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(int nIndex) const;
	void SetAt(int nIndex, DWORD newElement);
	DWORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, DWORD newElement);
	int Add(DWORD newElement);

	// overloaded operator helpers
	DWORD operator[](int nIndex) const;
	DWORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, DWORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CDWordArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


////////////////////////////////////////////////////////////////////////////

class CUIntArray : public CObject
{

	DECLARE_DYNAMIC(CUIntArray)
public:

// Construction
	CUIntArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	UINT GetAt(int nIndex) const;
	void SetAt(int nIndex, UINT newElement);
	UINT& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, UINT newElement);
	int Add(UINT newElement);

	// overloaded operator helpers
	UINT operator[](int nIndex) const;
	UINT& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, UINT newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CUIntArray* pNewArray);

// Implementation
protected:
	UINT* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CUIntArray();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray : public CObject
{

	DECLARE_DYNAMIC(CPtrArray)
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const;
	void SetAt(int nIndex, void* newElement);
	void*& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, void* newElement);
	int Add(void* newElement);

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


////////////////////////////////////////////////////////////////////////////

class CObArray : public CObject
{

	DECLARE_SERIAL(CObArray)
public:

// Construction
	CObArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CObject* GetAt(int nIndex) const;
	void SetAt(int nIndex, CObject* newElement);
	CObject*& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, CObject* newElement);
	int Add(CObject* newElement);

	// overloaded operator helpers
	CObject* operator[](int nIndex) const;
	CObject*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, CObject* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CObArray* pNewArray);

// Implementation
protected:
	CObject** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CObArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


////////////////////////////////////////////////////////////////////////////

class CStringArray : public CObject
{

	DECLARE_SERIAL(CStringArray)
public:

// Construction
	CStringArray();

// Attributes
	int GetSize() const;
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	CString GetAt(int nIndex) const;
	void SetAt(int nIndex, const char* newElement);
	CString& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, const char* newElement);
	int Add(const char* newElement);

	// overloaded operator helpers
	CString operator[](int nIndex) const;
	CString& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, const char* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CStringArray();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CPtrList : public CObject
{

	DECLARE_DYNAMIC(CPtrList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	CPtrList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	void* GetHead() const;
	void*& GetTail();
	void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	POSITION AddHead(void* newElement);
	POSITION AddTail(void* newElement);

	// add another list of elements before head or after tail
	void AddHead(CPtrList* pNewList);
	void AddTail(CPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	void*& GetNext(POSITION& rPosition); // return *Position++
	void* GetNext(POSITION& rPosition) const; // return *Position++
	void*& GetPrev(POSITION& rPosition); // return *Position--
	void* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	void*& GetAt(POSITION position);
	void* GetAt(POSITION position) const;
	void SetAt(POSITION pos, void* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, void* newElement);
	POSITION InsertAfter(POSITION position, void* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPtrList();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CObList : public CObject
{

	DECLARE_SERIAL(CObList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CObject* data;
	};
public:

// Construction
	CObList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CObject*& GetHead();
	CObject* GetHead() const;
	CObject*& GetTail();
	CObject* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	CObject* RemoveHead();
	CObject* RemoveTail();

	// add before head or after tail
	POSITION AddHead(CObject* newElement);
	POSITION AddTail(CObject* newElement);

	// add another list of elements before head or after tail
	void AddHead(CObList* pNewList);
	void AddTail(CObList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CObject*& GetNext(POSITION& rPosition); // return *Position++
	CObject* GetNext(POSITION& rPosition) const; // return *Position++
	CObject*& GetPrev(POSITION& rPosition); // return *Position--
	CObject* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CObject*& GetAt(POSITION position);
	CObject* GetAt(POSITION position) const;
	void SetAt(POSITION pos, CObject* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, CObject* newElement);
	POSITION InsertAfter(POSITION position, CObject* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(CObject* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CObList();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CStringList : public CObject
{

	DECLARE_SERIAL(CStringList)

protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		CString data;
	};
public:

// Construction
	CStringList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	CString& GetHead();
	CString GetHead() const;
	CString& GetTail();
	CString GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	CString RemoveHead();
	CString RemoveTail();

	// add before head or after tail
	POSITION AddHead(const char* newElement);
	POSITION AddTail(const char* newElement);

	// add another list of elements before head or after tail
	void AddHead(CStringList* pNewList);
	void AddTail(CStringList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	CString& GetNext(POSITION& rPosition); // return *Position++
	CString GetNext(POSITION& rPosition) const; // return *Position++
	CString& GetPrev(POSITION& rPosition); // return *Position--
	CString GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	CString& GetAt(POSITION position);
	CString GetAt(POSITION position) const;
	void SetAt(POSITION pos, const char* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, const char* newElement);
	POSITION InsertAfter(POSITION position, const char* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(const char* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CStringList();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapWordToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		WORD key;
		void* value;
	};
public:

// Construction
	CMapWordToPtr(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(WORD key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](WORD key);

	// add a new (key, value) pair
	void SetAt(WORD key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(WORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(WORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(WORD, UINT&) const;

public:
	~CMapWordToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToWord : public CObject
{

	DECLARE_DYNAMIC(CMapPtrToWord)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		void* key;
		WORD value;
	};
public:

// Construction
	CMapPtrToWord(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, WORD& rValue) const;

// Operations
	// Lookup and add if not there
	WORD& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, WORD newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, void*& rKey, WORD& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&) const;

public:
	~CMapPtrToWord();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapPtrToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapPtrToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		void* key;
		void* value;
	};
public:

// Construction
	CMapPtrToPtr(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(void* key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](void* key);

	// add a new (key, value) pair
	void SetAt(void* key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(void* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, void*& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(void* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(void*, UINT&) const;

public:
	~CMapPtrToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapWordToOb : public CObject
{

	DECLARE_SERIAL(CMapWordToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		WORD key;
		CObject* value;
	};
public:

// Construction
	CMapWordToOb(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(WORD key, CObject*& rValue) const;

// Operations
	// Lookup and add if not there
	CObject*& operator[](WORD key);

	// add a new (key, value) pair
	void SetAt(WORD key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(WORD key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, WORD& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(WORD key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(WORD, UINT&) const;

public:
	~CMapWordToOb();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToPtr : public CObject
{

	DECLARE_DYNAMIC(CMapStringToPtr)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CString key;
		void* value;
	};
public:

// Construction
	CMapStringToPtr(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const char* key, void*& rValue) const;

// Operations
	// Lookup and add if not there
	void*& operator[](const char* key);

	// add a new (key, value) pair
	void SetAt(const char* key, void* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(const char* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, void*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(const char* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(const char*, UINT&) const;

public:
	~CMapStringToPtr();
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToOb : public CObject
{

	DECLARE_SERIAL(CMapStringToOb)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CString key;
		CObject* value;
	};
public:

// Construction
	CMapStringToOb(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const char* key, CObject*& rValue) const;

// Operations
	// Lookup and add if not there
	CObject*& operator[](const char* key);

	// add a new (key, value) pair
	void SetAt(const char* key, CObject* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(const char* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CObject*& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(const char* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(const char*, UINT&) const;

public:
	~CMapStringToOb();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};


/////////////////////////////////////////////////////////////////////////////

class CMapStringToString : public CObject
{

	DECLARE_SERIAL(CMapStringToString)
protected:
	// Association
	struct CAssoc
	{
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
		CString key;
		CString value;
	};
public:

// Construction
	CMapStringToString(int nBlockSize=10);

// Attributes
	// number of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(const char* key, CString& rValue) const;

// Operations
	// Lookup and add if not there
	CString& operator[](const char* key);

	// add a new (key, value) pair
	void SetAt(const char* key, const char* newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(const char* key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;
	void GetNextAssoc(POSITION& rNextPosition, CString& rKey, CString& rValue) const;

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize);

// Overridables: special non-virtual (see map implementation for details)
	// Routine used to user-provided hash keys
	UINT HashKey(const char* key) const;

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	int m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CAssoc* NewAssoc();
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(const char*, UINT&) const;

public:
	~CMapStringToString();

	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXCOLL_INLINE inline
#include <afxcoll.inl>
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

#endif //!__AFXCOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdlgs.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXDLGS_H__
#define __AFXDLGS_H__

#ifndef __AFXWIN_H__
#include <afxwin.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXDLGS - MFC Standard dialogs

// Classes declared in this file

		// CDialog
			// modeless dialogs
			class CFindReplaceDialog; // Find/FindReplace dialog
			// modal dialogs
			class CFileDialog;    // FileOpen/FileSaveAs dialogs
			class CColorDialog;   // Color picker dialog
			class CFontDialog;    // Font chooser dialog
			class CPrintDialog;   // Print/PrintSetup dialogs

/////////////////////////////////////////////////////////////////////////////

#include <commdlg.h>    // common dialog APIs
#include <print.h>      // printer specific APIs (DEVMODE)

// AFXDLL support
#undef AFXAPP_DATA
#define AFXAPP_DATA     AFXAPI_DATA

/////////////////////////////////////////////////////////////////////////////
// CFileDialog - used for FileOpen... or FileSaveAs...

class CFileDialog : public CDialog
{
	DECLARE_DYNAMIC(CFileDialog)

public:
// Attributes
	// open file parameter block
	OPENFILENAME m_ofn;

// Constructors
	CFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCSTR lpszDefExt = NULL,
		LPCSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		LPCSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();

	// Helpers for parsing file name after successful return
	CString GetPathName() const;  // return full path name
	CString GetFileName() const;  // return only filename
	CString GetFileExt() const;   // return only ext
	CString GetFileTitle() const; // return file title
	BOOL GetReadOnlyPref() const; // return TRUE if readonly checked

// Overridable callbacks
protected:
	friend UINT CALLBACK AFX_EXPORT _AfxCommDlgProc(HWND, UINT, WPARAM, LPARAM);
	virtual UINT OnShareViolation(LPCSTR lpszPathName);
	virtual BOOL OnFileNameOK();
	virtual void OnLBSelChangedNotify(UINT nIDBox, UINT iCurSel, UINT nCode);

// Implementation
#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void OnOK();
	virtual void OnCancel();

	BOOL m_bOpenFileDialog;       // TRUE for file open, FALSE for file save
	CString m_strFilter;          // filter string
						// separate fields with '|', terminate with '||\0'
	char m_szFileTitle[64];       // contains file title after return
	char m_szFileName[_MAX_PATH]; // contains full path name after return
};

/////////////////////////////////////////////////////////////////////////////
// CFontDialog - used to select a font

class CFontDialog : public CDialog
{
	DECLARE_DYNAMIC(CFontDialog)

public:
// Attributes
	// font choosing parameter block
	CHOOSEFONT m_cf;

// Constructors
	CFontDialog(LPLOGFONT lplfInitial = NULL,
		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
		CDC* pdcPrinter = NULL,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();

	// Retrieve the currently selected font while dialog is displayed
	void GetCurrentFont(LPLOGFONT lplf);

	// Helpers for parsing information after successful return
	CString GetFaceName() const;  // return the face name of the font
	CString GetStyleName() const; // return the style name of the font
	int GetSize() const;          // return the pt size of the font
	COLORREF GetColor() const;    // return the color of the font
	int GetWeight() const;        // return the chosen font weight
	BOOL IsStrikeOut() const;     // return TRUE if strikeout
	BOOL IsUnderline() const;     // return TRUE if underline
	BOOL IsBold() const;          // return TRUE if bold font
	BOOL IsItalic() const;        // return TRUE if italic font

// Implementation
	LOGFONT m_lf; // default LOGFONT to store the info

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void OnOK();
	virtual void OnCancel();

	char m_szStyleName[64]; // contains style name after return
};


/////////////////////////////////////////////////////////////////////////////
// CColorDialog - used to select a color

class CColorDialog : public CDialog
{
	DECLARE_DYNAMIC(CColorDialog)

public:
// Attributes
	// color chooser parameter block
	CHOOSECOLOR m_cc;

// Constructors
	CColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0,
			CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();

	// Set the current color while dialog is displayed
	void SetCurrentColor(COLORREF clr);

	// Helpers for parsing information after successful return
	COLORREF GetColor() const;

	// Custom colors are held here and saved between calls
	static COLORREF AFXAPI_DATA clrSavedCustom[16];

// Overridable callbacks
protected:
	friend UINT CALLBACK AFX_EXPORT _AfxCommDlgProc(HWND, UINT, WPARAM, LPARAM);
	virtual BOOL OnColorOK();       // validate color

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void OnOK();
	virtual void OnCancel();

	//{{AFX_MSG(CColorDialog)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CPrintDialog - used for Print... and PrintSetup...

class CPrintDialog : public CDialog
{
	DECLARE_DYNAMIC(CPrintDialog)

public:
// Attributes
	// print dialog parameter block (note this is a reference)
#ifdef AFX_CLASS_MODEL
	PRINTDLG FAR& m_pd;
#else
	PRINTDLG& m_pd;
#endif

// Constructors
	CPrintDialog(BOOL bPrintSetupOnly,
		// TRUE for Print Setup, FALSE for Print Dialog
		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS
			| PD_HIDEPRINTTOFILE | PD_NOSELECTION,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();

	// GetDefaults will not display a dialog but will get
	// device defaults
	BOOL GetDefaults();

	// Helpers for parsing information after successful return
	int GetCopies() const;          // num. copies requested
	BOOL PrintCollate() const;      // TRUE if collate checked
	BOOL PrintSelection() const;    // TRUE if printing selection
	BOOL PrintAll() const;          // TRUE if printing all pages
	BOOL PrintRange() const;        // TRUE if printing page range
	int GetFromPage() const;        // starting page if valid
	int GetToPage() const;          // starting page if valid
	LPDEVMODE GetDevMode() const;   // return DEVMODE
	CString GetDriverName() const;  // return driver name
	CString GetDeviceName() const;  // return device name
	CString GetPortName() const;    // return output port name
	HDC GetPrinterDC() const;       // return HDC (caller must delete)

	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
	// This DC is returned, but also stored in m_pd.hDC as though it had been
	// returned by CommDlg.  It is assumed that any previously obtained DC
	// has been/will be deleted by the user.  This may be
	// used without ever invoking the print/print setup dialogs.

	HDC CreatePrinterDC();

// Implementation

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	PRINTDLG m_pdActual; // the Print/Print Setup need to share this
protected:
	virtual void OnOK();
	virtual void OnCancel();

	// The following handle the case of print setup... from the print dialog
#ifdef AFX_CLASS_MODEL
	CPrintDialog(PRINTDLG FAR& pdInit);
#else
	CPrintDialog(PRINTDLG& pdInit);
#endif
	virtual CPrintDialog* AttachOnSetup();

	//{{AFX_MSG(CPrintDialog)
	afx_msg void OnPrintSetup();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Find/FindReplace modeless dialogs

class CFindReplaceDialog : public CDialog
{
	DECLARE_DYNAMIC(CFindReplaceDialog)

public:
// Attributes
	FINDREPLACE m_fr;

// Constructors
	CFindReplaceDialog();
	// NOTE: you must allocate these on the heap.
	// If you do not, you must derive and override PostNcDestroy()

	BOOL Create(BOOL bFindDialogOnly, // TRUE for Find, FALSE for FindReplace
			LPCSTR lpszFindWhat,
			LPCSTR lpszReplaceWith = NULL,
			DWORD dwFlags = FR_DOWN,
			CWnd* pParentWnd = NULL);

	// find/replace parameter block
	static CFindReplaceDialog* PASCAL GetNotifier(LPARAM lParam);

// Operations
	// Helpers for parsing information after successful return
	CString GetReplaceString() const;// get replacement string
	CString GetFindString() const;   // get find string
	BOOL SearchDown() const;         // TRUE if search down, FALSE is up
	BOOL FindNext() const;           // TRUE if command is find next
	BOOL MatchCase() const;          // TRUE if matching case
	BOOL MatchWholeWord() const;     // TRUE if matching whole words only
	BOOL ReplaceCurrent() const;     // TRUE if replacing current string
	BOOL ReplaceAll() const;         // TRUE if replacing all occurrences
	BOOL IsTerminating() const;      // TRUE if terminating dialog

// Implementation
protected:
	virtual void OnOK();
	virtual void OnCancel();
	virtual void PostNcDestroy();

#ifdef _DEBUG
public:
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	char m_szFindWhat[128];
	char m_szReplaceWith[128];
};

////////////////////////////////////////////////////////////////////////////
// CPropertyPage -- one page of a tabbed dialog

class CPropertyPage : public CDialog
{
	DECLARE_DYNAMIC(CPropertyPage)

// Construction
public:
	CPropertyPage(UINT nIDTemplate, UINT nIDCaption = 0);
	CPropertyPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);

// Operations
public:
	void CancelToClose();           // called when the property sheet should display close instead of cancel
	// lets the property sheet activate the apply now button
	void SetModified(BOOL bChanged = TRUE);

// Overridables
public:
	virtual BOOL OnSetActive();     // called when this page gets the focus
	virtual BOOL OnKillActive();    // perform validation here
	virtual void OnOK();            // ok or apply now pressed -- KillActive is called first
	virtual void OnCancel();        // cancel pressed

// Implementation
public:
	virtual ~CPropertyPage();
	virtual BOOL PreTranslateMessage(MSG* pMsg); // handle tab, enter, and escape keys
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	// EndDialog is provided to generate an assert if it is called
	void EndDialog(int nEndID);
#endif

protected:
	CString m_strCaption;
	BOOL m_bChanged;

	void CommonConstruct(LPCTSTR lpszTemplateName, UINT nIDCaption);
		// loads the resource indicated by CDialog::m_lpDialogTemplate
	BOOL PreTranslateKeyDown(MSG* pMsg);
	BOOL ProcessTab(MSG* pMsg); // handles tab key from PreTranslateMessage
	BOOL CreatePage();  // called from CPropertySheet to create the dialog
						// by loading the dialog resource into memory and
						// turning off WS_CAPTION before creating
	void LoadCaption();
		// gets the caption of the dialog from the resource and puts it in m_strCaption

	// Generated message map functions
	//{{AFX_MSG(CPropertyPage)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPropertySheet;
};

////////////////////////////////////////////////////////////////////////////
// CTabControl -- internal use only
//  Implementation for a generic row of tabs along the top of dialog
//  Future versions of MFC may or may not include this exact class.

class CTabItem; // private to CTabControl implementation

// TCN_ messages are tab control notifications
#define TCN_TABCHANGING     1
#define TCN_TABCHANGED      2

class CTabControl : public CWnd
{
	DECLARE_DYNAMIC(CTabControl)

public:
// Construction
	CTabControl();

// Attributes
	BOOL m_bInSize;
	int m_nHeight;
	BOOL SetCurSel(int nTab);
	int GetCurSel() const;
	int GetItemCount() const;

// Operations
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	void AddTab(LPCTSTR lpszCaption);
	void RemoveTab(int nTab);

// Implementation
public:
	virtual ~CTabControl();
	BOOL NextTab(BOOL bNext);

protected:
	void Scroll(int nDirection);
	void ScrollIntoView(int nTab);
	void DrawFocusRect(CDC* pDC = NULL);
	void InvalidateTab(int nTab, BOOL bInflate = TRUE);
	int TabFromPoint(CPoint pt);
	void Capture(int nDirection);
	void LayoutTabsStacked(int nTab);
	void LayoutTabsSingle(int nTab);

	enum
	{
		SCROLL_LEFT = -5,       // all the SCROLL_ items must be less
		SCROLL_RIGHT = -6,      // than -1 to avoid ID conflict
		SCROLL_NULL = -7,
		TIMER_ID = 15,          // timer constants
		TIMER_DELAY = 500
	};

	void DrawScrollers(CDC* pDC);

	BOOL CanScroll();
	void SetFirstTab(int nTab);
	CTabItem* GetTabItem(int nTab) const;
	BOOL IsTabVisible(int nTab, BOOL bComplete = FALSE) const;

	// Member variables
	HFONT m_hBoldFont;
	HFONT m_hThinFont;
	CRect m_rectScroll; // location of scroll buttons
	int m_nCurTab;      // index of current selected tab
	int m_nFirstTab;    // index of leftmost visible tab
	int m_nScrollState; // shows whether left or right scroll btn is down
	BOOL m_bScrollPause;// if we have capture, has the mouse wandered off btn?

	CPtrArray m_tabs;   // list of CTabItems, in order

	// Generated message map functions
	//{{AFX_MSG(CTabControl)
	afx_msg void OnPaint();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////////////
// CPropertySheet -- a tabbed "dialog" (really a popup-window)

class CPropertySheet : public CWnd
{
	DECLARE_DYNAMIC(CPropertySheet)

// Construction
public:
	CPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);
	CPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL,
		UINT iSelectPage = 0);

	// for modeless creation
	BOOL Create(CWnd* pParentWnd = NULL, DWORD dwStyle =
		WS_SYSMENU | WS_POPUP | WS_CAPTION | DS_MODALFRAME | WS_VISIBLE,
		DWORD dwExStyle = WS_EX_DLGMODALFRAME);

// Attributes
public:
	int GetPageCount() const;
	CPropertyPage* GetPage(int nPage) const;

// Operations
public:
	int DoModal();
	void AddPage(CPropertyPage* pPage);
	void RemovePage(CPropertyPage* pPage);
	void RemovePage(int nPage);
	void EndDialog(int nEndID); // used to terminate a modal dialog

// Implementation
public:
	virtual ~CPropertySheet();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	void EnableStackedTabs(BOOL bStacked);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL DestroyWindow();
	BOOL SetActivePage(int nPage);

protected:
	HWND FindNextControl(HWND hWnd, TCHAR ch);
	void GotoControl(HWND hWnd, TCHAR ch);
	BOOL ProcessChars(MSG* pMsg);
	BOOL ProcessTab(MSG* pMsg);
	BOOL CreateStandardButtons();
	BOOL PumpMessage();
	void PageChanged();
	void CancelToClose();
	void CommonConstruct(CWnd* pParent, UINT iSelectPage);
	void RecalcLayout();
	CPropertyPage* GetActivePage() const;
	void CheckDefaultButton(HWND hFocusBefore, HWND hFocusAfter);
	void CheckFocusChange();

	// implementation data members
	HFONT m_hFont;          // sizes below dependent on this font
	CSize m_sizeButton;
	CSize m_sizeTabMargin;
	int m_cxButtonGap;
	BOOL m_bModeless;
	BOOL m_bStacked;

	int m_nCurPage;
	int m_nID;              // ID passed to EndDialog and returned from DoModal

	CPtrArray m_pages;      // array of CPropertyPage pointers
	HWND m_hWndDefault;     // current default push button if there is one
	HWND m_hFocusWnd;       // focus when we lost activation
	HWND m_hLastFocus;      // tracks last window with focus
	CWnd* m_pParentWnd;     // owner of the tabbed dialog
	CString m_strCaption;   // caption of the pseudo-dialog
	CTabControl m_tabRow;   // entire row of tabs at top of dialog
	BOOL m_bParentDisabled; // TRUE if parent was disabled by DoModal

	// Generated message map functions
	//{{AFX_MSG(CPropertySheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnClose();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnOK();
	afx_msg void OnCancel();
	afx_msg void OnApply();
	afx_msg LRESULT OnTabChanged(WPARAM, LPARAM);
	afx_msg LRESULT OnTabChanging(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class CPropertyPage; // for tab handler
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXDLGS_INLINE inline
#include <afxdlgs.inl>
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

/////////////////////////////////////////////////////////////////////////////
#endif //__AFXDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdllx.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXDLLX.H: Extra header for building an MFC Extension DLL
//  This file is really a source file that you should include in the
//   main source file of your DLL.
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

#include <stdarg.h>

extern "C" void CDECL
AfxTrace(const char FAR* pszFormat, ...)
{
	va_list args;
	va_start(args, pszFormat);

	(_AfxGetAppDebug()->lpfnTraceV)(pszFormat, args);
}

extern "C"
void AFXAPI AfxAssertFailedLine(LPCSTR lpszFileName, int nLine)
{
	(_AfxGetAppDebug()->lpfnAssertFailed)(lpszFileName, nLine);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// Memory allocation is done by app !

void* operator new(size_t nSize)
{
#ifdef _DEBUG
	ASSERT(_AfxGetAppData()->lpfnAppAlloc != NULL);
	ASSERT(_AfxGetAppDebug()->lpszAllocFileName == NULL);
	_AfxGetAppDebug()->bAllocObj = FALSE;
#endif //_DEBUG
	void* p = (_AfxGetAppData()->lpfnAppAlloc)(nSize);
	if (p == NULL)
		AfxThrowMemoryException();
	return p;
}

#ifdef _DEBUG
void* operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
{
	ASSERT(_AfxGetAppData()->lpfnAppAlloc != NULL);
	_AfxGetAppDebug()->lpszAllocFileName = lpszFileName;
	_AfxGetAppDebug()->nAllocLine = nLine;
	_AfxGetAppDebug()->bAllocObj = FALSE;

	void* p = (_AfxGetAppData()->lpfnAppAlloc)(nSize);

	_AfxGetAppDebug()->lpszAllocFileName = NULL;

	if (p == NULL)
		AfxThrowMemoryException();
	return p;
}
#endif //_DEBUG

void operator delete(void* pbData)
{
	if (pbData == NULL)
		return;
#ifdef _DEBUG
	ASSERT(_AfxGetAppData()->lpfnAppFree != NULL);
	_AfxGetAppDebug()->bAllocObj = FALSE;
#endif //_DEBUG
	(*_AfxGetAppData()->lpfnAppFree)(pbData);
}

/////////////////////////////////////////////////////////////////////////////
// Additional CObject new/delete operators for memory tracking

#ifdef _DEBUG
void* CObject::operator new(size_t nSize)
{
	ASSERT(_AfxGetAppData()->lpfnAppAlloc != NULL);
	ASSERT(_AfxGetAppDebug()->lpszAllocFileName == NULL);
	_AfxGetAppDebug()->bAllocObj = TRUE;
	void* p = (_AfxGetAppData()->lpfnAppAlloc)(nSize);
	if (p == NULL)
		AfxThrowMemoryException();
	return p;
}

void* CObject::operator new(size_t nSize, LPCSTR pFileName, int nLine)
{
	ASSERT(_AfxGetAppData()->lpfnAppAlloc != NULL);
	_AfxGetAppDebug()->lpszAllocFileName = pFileName;
	_AfxGetAppDebug()->nAllocLine = nLine;
	_AfxGetAppDebug()->bAllocObj = TRUE;

	void* p = (_AfxGetAppData()->lpfnAppAlloc)(nSize);
	_AfxGetAppDebug()->lpszAllocFileName = NULL;
	if (p == NULL)
		AfxThrowMemoryException();
	return p;
}

void CObject::operator delete(void* pbData)
{
	if (pbData == NULL)
		return;
	ASSERT(_AfxGetAppData()->lpfnAppFree != NULL);
	_AfxGetAppDebug()->bAllocObj = TRUE;
	(*_AfxGetAppData()->lpfnAppFree)(pbData);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// we must also replace any direct calls to malloc/free

extern "C"
void __far* __cdecl _fmalloc(size_t nSize)
{
#ifdef _DEBUG
	ASSERT(_AfxGetAppData()->lpfnAppAlloc != NULL);
	ASSERT(_AfxGetAppDebug()->lpszAllocFileName == NULL);
	_AfxGetAppDebug()->bAllocObj = FALSE;
#endif //_DEBUG
	void* p = (_AfxGetAppData()->lpfnAppAlloc)(nSize);
	if (p == NULL)
		AfxThrowMemoryException();
	return p;
}

extern "C"
void __cdecl _ffree(void __far* p)
{
#ifdef _DEBUG
	ASSERT(_AfxGetAppData()->lpfnAppFree != NULL);
	_AfxGetAppDebug()->bAllocObj = FALSE;
#endif //_DEBUG
	(*_AfxGetAppData()->lpfnAppFree)(p);
}

extern "C"
void __far* __cdecl _frealloc(void __far* pOld, size_t nSize)
{
#ifdef _DEBUG
	ASSERT(_AfxGetAppData()->lpfnAppReAlloc != NULL);
	_AfxGetAppDebug()->bAllocObj = FALSE;
#endif //_DEBUG
	return (_AfxGetAppData()->lpfnAppReAlloc)(pOld, nSize);
}

/////////////////////////////////////////////////////////////////////////////
// Also stub out the runtime init 'setenvp' routine to avoid malloc calls

extern "C" void _cdecl _setenvp()
{
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdlgs.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXDLGS.H

#ifdef _AFXDLGS_INLINE

/////////////////////////////////////////////////////////////////////////////

_AFXDLGS_INLINE CString CFileDialog::GetPathName() const
	{ return m_ofn.lpstrFile; }
_AFXDLGS_INLINE CString CFileDialog::GetFileExt() const
	{ if (m_ofn.nFileExtension == 0) return (char)'\0';
		else return m_ofn.lpstrFile + m_ofn.nFileExtension; }
_AFXDLGS_INLINE CString CFileDialog::GetFileTitle() const
	{ return m_ofn.lpstrFileTitle; }
_AFXDLGS_INLINE BOOL CFileDialog::GetReadOnlyPref() const
	{ return m_ofn.Flags & OFN_READONLY ? TRUE : FALSE; }
_AFXDLGS_INLINE void CFontDialog::GetCurrentFont(LPLOGFONT lplf)
	{ ASSERT(m_hWnd != NULL); SendMessage(WM_CHOOSEFONT_GETLOGFONT,
		0, (DWORD)(LPSTR)lplf); }
_AFXDLGS_INLINE CString CFontDialog::GetFaceName() const
	{ return (LPCSTR)m_cf.lpLogFont->lfFaceName; }
_AFXDLGS_INLINE CString CFontDialog::GetStyleName() const
	{ return m_cf.lpszStyle; }
_AFXDLGS_INLINE int CFontDialog::GetSize() const
	{ return m_cf.iPointSize; }
_AFXDLGS_INLINE int CFontDialog::GetWeight() const
	{ return m_cf.lpLogFont->lfWeight; }
_AFXDLGS_INLINE BOOL CFontDialog::IsItalic() const
	{ return m_cf.lpLogFont->lfItalic ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsStrikeOut() const
	{ return m_cf.lpLogFont->lfStrikeOut ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsBold() const
	{ return m_cf.lpLogFont->lfWeight == FW_BOLD ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFontDialog::IsUnderline() const
	{ return m_cf.lpLogFont->lfUnderline ? TRUE : FALSE; }
_AFXDLGS_INLINE COLORREF CFontDialog::GetColor() const
	{ return m_cf.rgbColors; }
_AFXDLGS_INLINE COLORREF CColorDialog::GetColor() const
	{ return m_cc.rgbResult; }
_AFXDLGS_INLINE BOOL CPrintDialog::GetDefaults()
	{ m_pd.Flags |= PD_RETURNDEFAULT;
	return ::PrintDlg(&m_pd); }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintSelection() const
	{ return m_pd.Flags & PD_SELECTION ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintRange() const
	{ return m_pd.Flags & PD_PAGENUMS ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintAll() const
	{ return !PrintRange() && !PrintSelection() ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CPrintDialog::PrintCollate() const
	{ return m_pd.Flags & PD_COLLATE ? TRUE : FALSE; }
_AFXDLGS_INLINE int CPrintDialog::GetFromPage() const
	{ return (PrintRange() ? m_pd.nFromPage :-1); }
_AFXDLGS_INLINE int CPrintDialog::GetToPage() const
	{ return (PrintRange() ? m_pd.nToPage :-1); }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::IsTerminating() const
	{ return m_fr.Flags & FR_DIALOGTERM ? TRUE : FALSE ; }
_AFXDLGS_INLINE CString CFindReplaceDialog::GetReplaceString() const
	{ return m_fr.lpstrReplaceWith; }
_AFXDLGS_INLINE CString CFindReplaceDialog::GetFindString() const
	{ return m_fr.lpstrFindWhat; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::SearchDown() const
	{ return m_fr.Flags & FR_DOWN ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::FindNext() const
	{ return m_fr.Flags & FR_FINDNEXT ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::MatchCase() const
	{ return m_fr.Flags & FR_MATCHCASE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::MatchWholeWord() const
	{ return m_fr.Flags & FR_WHOLEWORD ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::ReplaceCurrent() const
	{ return m_fr. Flags & FR_REPLACE ? TRUE : FALSE; }
_AFXDLGS_INLINE BOOL CFindReplaceDialog::ReplaceAll() const
	{ return m_fr.Flags & FR_REPLACEALL ? TRUE : FALSE; }

// CPropertySheet/CPropertyPage/CTabControl inlines
_AFXDLGS_INLINE int CTabControl::GetCurSel() const
	{ return m_nCurTab; }
_AFXDLGS_INLINE CTabItem* CTabControl::GetTabItem(int nTab) const
	{ return (CTabItem*)m_tabs[nTab]; }
_AFXDLGS_INLINE int CTabControl::GetItemCount() const
	{ return m_tabs.GetSize(); }
_AFXDLGS_INLINE void CPropertySheet::EnableStackedTabs(BOOL bStacked)
	{ m_bStacked = bStacked; }
_AFXDLGS_INLINE int CPropertySheet::GetPageCount() const
	{ return m_pages.GetSize(); }
_AFXDLGS_INLINE CPropertyPage* CPropertySheet::GetPage(int nPage) const
	{ return (CPropertyPage*)m_pages[nPage]; }
_AFXDLGS_INLINE CPropertyPage* CPropertySheet::GetActivePage() const
	{return GetPage(m_nCurPage);}

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXDLGS_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxdll_.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxdll_.h - extensions to AFXWIN.H used for the 'AFXDLL' version
// This file contains MFC library implementation details as well
//   as APIs for writing MFC Extension DLLs.
// Please refer to Technical Note 033 (TN033) for more details.

/////////////////////////////////////////////////////////////////////////////

#ifndef _AFXDLL
#error illegal file inclusion
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     AFXAPI_DATA

/////////////////////////////////////////////////////////////////////////////

// get best fitting resource
HINSTANCE AFXAPI AfxFindResourceHandle(LPCSTR lpszName, LPCSTR lpszType);

/////////////////////////////////////////////////////////////////////////////
// CDynLinkLibrary - for implementation of MFC Extension DLLs

struct AFX_EXTENSION_MODULE
{
	HMODULE hModule;
	CRuntimeClass* pFirstSharedClass;
};

// Call in DLL's LibMain
void AFXAPI AfxInitExtensionModule(AFX_EXTENSION_MODULE& state, HMODULE hMod);

// there is one CDynLinkLibrary in each client application using an
//   MFC Extension DLL

class CDynLinkLibrary : public CCmdTarget
{
	DECLARE_DYNAMIC(CDynLinkLibrary)
public:

// Constructor
	CDynLinkLibrary(AFX_EXTENSION_MODULE& state);

// Attributes
	HMODULE m_hModule;
	HMODULE m_hResource;                // for shared resources
	CRuntimeClass* m_pFirstSharedClass; // for shared CRuntimeClasses
#ifdef _AFXCTL
	BOOL m_bSystem;                     // TRUE only for MFC DLLs
#endif

// Implementation
public:
	CDynLinkLibrary* m_pNextDLL;        // simple singly linked list
	virtual ~CDynLinkLibrary();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif //_DEBUG
};

/////////////////////////////////////////////////////////////////////////////
// Diagnostic support (exported by App, used by MFC250D.DLL)

class COleDebugMalloc;

#ifdef _DEBUG
//WARNING: Do not change this structure since AFXDLL.ASM depends on
//  the specific structure layout and size
struct AFX_APPDEBUG
{
	// Trace output
	void (CALLBACK* lpfnTraceV)(LPCSTR lpszFormat, const void FAR* lpArgs);

	// Assert failure reporting
	void (CALLBACK* lpfnAssertFailed)(LPCSTR lpszFileName, int nLine);

	BOOL appTraceEnabled;
	int appTraceFlags;

	// state for current memory allocation ('bAllocObj' used for free as well)
	LPCSTR  lpszAllocFileName;          // source file name (NULL => unknown)
	UINT    nAllocLine;                 // source line number
	BOOL    bAllocObj;                  // allocating CObject derived object
	BOOL    bMemoryTracking;            // tracking on

	// state for OLE debug allocations
	COleDebugMalloc* appDebugMalloc;    // OLE 2.0 debug allocator
};
#define _AfxGetAppDebug()   (_AfxGetAppData()->pAppDebug)
#define afxTraceEnabled     (_AfxGetAppDebug()->appTraceEnabled)
#define afxTraceFlags       (_AfxGetAppDebug()->appTraceFlags)
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// App specific data for _AFXDLL version

class CHandleMap;       // not NEAR in _AFXDLL version
struct AFX_VBSTATE;     // VB State
struct AFX_FRSTATE;     // Find/Replace state (for CEditView)
struct AFX_OLESTATE;    // OLE State
struct AFX_SOCKSTATE;   // Socket State

typedef void FAR* HENV; // must match SQL.H

#ifndef _AFXCTL

//WARNING: Do not change this structure since the assembler DLL init
//  the specific structure layout and size
struct AFX_APPDATA  // starts at SS:0010
{
	WORD    cbSize;             // size of this structure
	WORD    wVersion;           // 0x0250 for MFC 250

#ifdef _DEBUG
	AFX_APPDEBUG BASED_STACK* pAppDebug;
	UINT    wReserved;
#else
	DWORD   dwReserved;
#endif
	DWORD   dwReserved2;
	DWORD   dwReserved3;

	FARPROC lpfnVBApiEntry;                             // must be at SS:0020

	// App provided/exported memory allocation interface etc
	void (CALLBACK* lpfnAppAbort)();                    // SS:0024
	FARPROC (CALLBACK* lpfnAppSetNewHandler)(FARPROC);  // SS:0028
	void* (CALLBACK* lpfnAppAlloc)(size_t nBytes);      // SS:002C
	void (CALLBACK* lpfnAppFree)(void*);                // SS:0030
	void* (CALLBACK* lpfnAppReAlloc)(void* pOld, size_t nSize); // SS:0034

	DWORD   dwReserved4;        // SS:0038
	DWORD   dwReserved5;        // SS:0040

	// app state
	CWinApp* appCurrentWinApp;
	HINSTANCE appCurrentInstanceHandle;
	HINSTANCE appCurrentResourceHandle;
	AFX_EXCEPTION_CONTEXT appExceptionContext;
	const char* appCurrentAppName;
	DWORD appTempMapLock;

	// internal App initialization and state
	HBRUSH appDlgBkBrush;
	COLORREF appDlgTextClr;
	HHOOK appHHookOldMsgFilter;
	HHOOK appHHookOldCbtFilter;
	BOOL appUserAbort;              // for printing and other app modal states

	// splitter window state (used in winsplit.cpp)
	HCURSOR hcurSplitLast;
	HCURSOR hcurSplitDestroy;
	UINT    idcSplitPrimaryLast;

	// linkage to shared resources/classes
	CDynLinkLibrary* pFirstDLL;     // order is important for resource loads
	CRuntimeClass* pFirstAppClass;  // CRuntimeClass support
	CFrameWnd* appFirstFrameWnd;    // first frame window for this app

  // sub-system state storage

	// handle maps
	CHandleMap* appMapHGDIOBJ;
	CHandleMap* appMapHDC;
	CHandleMap* appMapHMENU;
	CHandleMap* appMapHWND;

	AFX_VBSTATE FAR* appVBState;
	AFX_FRSTATE FAR* appLastFRState;
	AFX_OLESTATE FAR* appOleState;

	WORD appWaitForDataSource;      // semaphore for async database access
	BOOL bDBExtensionDLL;
	HENV appHenvAllConnections;
	int appAllocatedConnections;

	HINSTANCE appInstMail;			// handle to MAPI.DLL

	AFX_SOCKSTATE FAR* appSockState;
};

#define _AfxGetAppData()         ((AFX_APPDATA BASED_STACK*)0x10)

#else

struct AFX_APPDATA_MODULE
{
	AFX_APPDATA_MODULE* m_pID;  // Uniquely identify where this data came from.

	// app state
	CWinApp* appCurrentWinApp;
	HINSTANCE appCurrentInstanceHandle;
	HINSTANCE appCurrentResourceHandle;
	const char* appCurrentAppName;

	// linkage to shared resources/classes
	CDynLinkLibrary* pFirstDLL;     // order is important for resource loads
	CFrameWnd* appFirstFrameWnd;    // first frame window for this app

	CRuntimeClass* pFirstAppClass;  // CRuntimeClass support
	AFX_OLESTATE FAR* appOleState;

	// dialog state
	HBRUSH appDlgBkBrush;
	COLORREF appDlgTextClr;
};


struct AFX_APPDATA : AFX_APPDATA_MODULE
{
#ifdef _DEBUG
	AFX_APPDEBUG *pAppDebug;
#endif

	// splitter window state (used in winsplit.cpp)
	HCURSOR hcurSplitLast;
	HCURSOR hcurSplitDestroy;
	UINT    idcSplitPrimaryLast;

	AFX_EXCEPTION_CONTEXT appExceptionContext;

	// internal App initialization and state
	HHOOK appHHookOldMsgFilter;
	HHOOK appHHookOldCbtFilter;
	BOOL appUserAbort;              // for printing and other app modal states

	// sub-system state storage

	WORD appWaitForDataSource;      // semaphore for async database access
	BOOL bDBExtensionDLL;

	// handle maps
	DWORD appTempMapLock;
	CHandleMap* appMapHGDIOBJ;
	CHandleMap* appMapHDC;
	CHandleMap* appMapHMENU;
	CHandleMap* appMapHWND;

	// App provided/exported memory allocation interface etc
	void (CALLBACK* lpfnAppAbort)();
	FARPROC (CALLBACK* lpfnAppSetNewHandler)(FARPROC);
	void* (CALLBACK* lpfnAppAlloc)(size_t nBytes);
	void (CALLBACK* lpfnAppFree)(void*);
	void* (CALLBACK* lpfnAppReAlloc)(void* pOld, size_t nSize);

	AFX_FRSTATE FAR* appLastFRState;

	WORD    cbSize;             // size of this structure
	WORD    wVersion;           // 0x0251 for OC 251

	HINSTANCE appLangDLL;       // Localized resources
	BOOL bLangDLLInit;          // TRUE if language DLL is initialized

	CMapPtrToPtr* appMapExtra;  // Extra data for controls

	HENV appHenvAllConnections;
	int appAllocatedConnections;
};

extern AFX_APPDATA_MODULE* AFXAPI AfxGetBaseModuleContext();
extern AFX_APPDATA_MODULE* AFXAPI AfxGetCurrentModuleContext();

extern AFX_APPDATA* _AfxGetAppData();
#define AfxGetExtraDataMap() (_AfxGetAppData()->appMapExtra);
#define _afxOleState (*_AfxGetAppData()->appOleState)
#define _afxFirstFactory (_AfxGetAppData()->appOleState->pFirstFactory)
#define _afxModuleAddrCurrent AfxGetCurrentModuleContext()

#define AFX_MANAGE_STATE(pData)     AFX_MAINTAIN_STATE _ctlState(pData);

#define METHOD_MANAGE_STATE(theClass, localClass) \
	METHOD_PROLOGUE(theClass, localClass) \
	AFX_MANAGE_STATE(pThis->m_pModuleState)

extern AFX_APPDATA_MODULE* AFXAPI AfxPushModuleContext(AFX_APPDATA_MODULE* psIn);
extern void AFXAPI AfxPopModuleContext(AFX_APPDATA_MODULE* psIn,
	BOOL bCopy = FALSE);

// When using this object, or the macros above that use this object
// it is necessary to insure that the object's destructor cannot be
// thrown past, by an unexpected exception.

class AFX_MAINTAIN_STATE
{
private:
	AFX_APPDATA_MODULE* m_psPrevious;

public:
	AFX_MAINTAIN_STATE(AFX_APPDATA_MODULE* psData);
	~AFX_MAINTAIN_STATE();
};
#endif

#define afxTempMapLock           (_AfxGetAppData()->appTempMapLock)

// Extra Initialization
extern "C" int PASCAL AfxWinMain(HINSTANCE, HINSTANCE, LPSTR, int);

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxext.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXEXT_H__
#define __AFXEXT_H__

#ifndef __AFXWIN_H__
#include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
#include <afxdlgs.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXEXT - MFC Advanced Extensions and Advanced Customizable classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CButton
				class CBitmapButton;    // Bitmap button (self-draw)

			class CControlBar;          // control bar
				class CStatusBar;       // status bar
				class CToolBar;         // toolbar
				class CDialogBar;       // dialog as control bar

			class CSplitterWnd;         // splitter manager

			//CView
				//CScrollView
				class CFormView;        // view with a dialog template
				class CEditView;        // simple text editor view

			class CVBControl;           // VBX control

	//CDC
		class CMetaFileDC;              // a metafile with proxy

class CRectTracker;                     // tracker for rectangle objects

// information structures
struct CPrintInfo;          // Printing context
struct CPrintPreviewState;  // Print Preview context/state
struct CCreateContext;      // Creation context

// AFXDLL support
#undef AFXAPP_DATA
#define AFXAPP_DATA     AFXAPI_DATA

/////////////////////////////////////////////////////////////////////////////
// Simple bitmap button

// CBitmapButton - push-button with 1->4 bitmap images
class CBitmapButton : public CButton
{
	DECLARE_DYNAMIC(CBitmapButton)
public:
// Construction
	CBitmapButton();

	BOOL LoadBitmaps(LPCSTR lpszBitmapResource,
			LPCSTR lpszBitmapResourceSel = NULL,
			LPCSTR lpszBitmapResourceFocus = NULL,
			LPCSTR lpszBitmapResourceDisabled = NULL);
	BOOL AutoLoad(UINT nID, CWnd* pParent);

// Operations
	void SizeToContent();

// Implementation:
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
protected:
	// all bitmaps must be the same size
	CBitmap m_bitmap;           // normal image (REQUIRED)
	CBitmap m_bitmapSel;        // selected image (OPTIONAL)
	CBitmap m_bitmapFocus;      // focused but not selected (OPTIONAL)
	CBitmap m_bitmapDisabled;   // disabled bitmap (OPTIONAL)

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);
};

/////////////////////////////////////////////////////////////////////////////
// Control Bars

class CControlBar : public CWnd
{
	DECLARE_DYNAMIC(CControlBar)
// Construction
protected:
	CControlBar();

// Attributes
public:
	int GetCount() const;

	BOOL m_bAutoDelete;

// Implementation
public:
	virtual ~CControlBar();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void DelayHide();
	virtual void DelayShow();
	virtual BOOL IsVisible() const;
		// works even if DelayShow or DelayHide is pending!

protected:
	// info about bar (for status bar and toolbar)
	int m_cxLeftBorder;
	int m_cyTopBorder, m_cyBottomBorder;
	int m_cxDefaultGap;     // default gap value
	CSize m_sizeFixedLayout; // fixed layout size

	// array of elements
	int m_nCount;
	void* m_pData;        // m_nCount elements - type depends on derived class

	// support for delayed hide/show
	enum StateFlags
		{ delayHide = 1, delayShow = 2 };
	UINT m_nStateFlags;

	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void DoPaint(CDC* pDC);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler) = 0;
	virtual void PostNcDestroy();

	BOOL AllocElements(int nElements, int cbElement);    // one time only
	LRESULT WindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	void CalcInsideRect(CRect& rect) const; // adjusts borders etc

	//{{AFX_MSG(CControlBar)
	afx_msg void OnPaint();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	afx_msg void OnInitialUpdate();
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////
// CStatusBar control

struct AFX_STATUSPANE;      // private to implementation

class CStatusBar : public CControlBar
{
	DECLARE_DYNAMIC(CStatusBar)
// Construction
public:
	CStatusBar();
	BOOL Create(CWnd* pParentWnd,
			DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM,
			UINT nID = AFX_IDW_STATUS_BAR);
	BOOL SetIndicators(const UINT FAR* lpIDArray, int nIDCount);

// Attributes
public: // standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	void GetItemRect(int nIndex, LPRECT lpRect) const;
public:
	void GetPaneText(int nIndex, CString& s) const;
	BOOL SetPaneText(int nIndex, LPCSTR lpszNewText, BOOL bUpdate = TRUE);
	void GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle, int& cxWidth) const;
	void SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth);

// Implementation
public:
	virtual ~CStatusBar();
	inline UINT _GetPaneStyle(int nIndex) const;
	void _SetPaneStyle(int nIndex, UINT nStyle);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	HFONT m_hFont;
	int m_cxRightBorder;    // right borders (panes get clipped)

	inline AFX_STATUSPANE* _GetPanePtr(int nIndex) const;
	static void PASCAL DrawStatusText(HDC hDC, CRect const& rect,
			LPCSTR lpszText, UINT nStyle);
	virtual void DoPaint(CDC* pDC);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	//{{AFX_MSG(CStatusBar)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetTextLength(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// Styles for status bar panes
#define SBPS_NORMAL     0x0000
#define SBPS_NOBORDERS  0x0100
#define SBPS_POPOUT     0x0200
#define SBPS_DISABLED   0x0400
#define SBPS_STRETCH    0x0800  // stretch to fill status bar - 1st pane only

////////////////////////////////////////////
// CToolBar control

struct AFX_TBBUTTON;        // private to implementation

HBITMAP AFXAPI AfxLoadSysColorBitmap(HINSTANCE hInst, HRSRC hRsrc);

class CToolBar : public CControlBar
{
	DECLARE_DYNAMIC(CToolBar)
// Construction
public:
	CToolBar();
	BOOL Create(CWnd* pParentWnd,
			DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_TOP,
			UINT nID = AFX_IDW_TOOLBAR);

	void SetSizes(SIZE sizeButton, SIZE sizeImage);
				// button size should be bigger than image
	void SetHeight(int cyHeight);
				// call after SetSizes, height overrides bitmap size
	BOOL LoadBitmap(LPCSTR lpszResourceName);
	BOOL LoadBitmap(UINT nIDResource);
	BOOL SetButtons(const UINT FAR* lpIDArray, int nIDCount);
				// lpIDArray can be NULL to allocate empty buttons

// Attributes
public: // standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	virtual void GetItemRect(int nIndex, LPRECT lpRect) const;

public:
	// for changing button info
	void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	void SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage);

// Implementation
public:
	virtual ~CToolBar();
	inline UINT _GetButtonStyle(int nIndex) const;
	void _SetButtonStyle(int nIndex, UINT nStyle);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	inline AFX_TBBUTTON* _GetButtonPtr(int nIndex) const;
	void InvalidateButton(int nIndex);
	void CreateMask(int iImage, CPoint offset,
		 BOOL bHilite, BOOL bHiliteShadow);

	// for custom drawing
	struct DrawState
	{
		HBITMAP hbmMono;
		HBITMAP hbmMonoOld;
		HBITMAP hbmOldGlyphs;
	};
	BOOL PrepareDrawButton(DrawState& ds);
	BOOL DrawButton(HDC hdC, int x, int y, int iImage, UINT nStyle);
	void EndDrawButton(DrawState& ds);

protected:
	CSize m_sizeButton;       // size of button
	CSize m_sizeImage;        // size of glyph
	HBITMAP m_hbmImageWell;     // glyphs only
	int m_iButtonCapture;   // index of button with capture (-1 => none)
	HRSRC m_hRsrcImageWell; // handle to loaded resource for image well
	HINSTANCE m_hInstImageWell; // instance handle to load image well from

	virtual void DoPaint(CDC* pDC);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual int HitTest(CPoint point);

	//{{AFX_MSG(CToolBar)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSysColorChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// Styles for toolbar buttons
#define TBBS_BUTTON     0x00    // this entry is button
#define TBBS_SEPARATOR  0x01    // this entry is a separator
#define TBBS_CHECKBOX   0x02    // this is an auto check/radio button

// styles for display states
#define TBBS_CHECKED        0x0100  // button is checked/down
#define TBBS_INDETERMINATE  0x0200  // third state
#define TBBS_DISABLED       0x0400  // element is disabled
#define TBBS_PRESSED        0x0800  // button is being depressed - mouse down

////////////////////////////////////////////
// CDialogBar control
// This is a control bar built from a dialog template. It is a modeless
// dialog that delegates all control notifications to the parent window
// of the control bar [the grandparent of the control]

class CDialogBar : public CControlBar
{
	DECLARE_DYNAMIC(CDialogBar)
// Construction
public:
	CDialogBar();
	BOOL Create(CWnd* pParentWnd, LPCSTR lpszTemplateName,
			UINT nStyle, UINT nID);
	BOOL Create(CWnd* pParentWnd, UINT nIDTemplate,
			UINT nStyle, UINT nID);

// Implementation
public:
	virtual ~CDialogBar();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
protected:
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual WNDPROC* GetSuperWndProcAddr();
};


/////////////////////////////////////////////////////////////////////////////
// Splitter Wnd

#define SPLS_DYNAMIC_SPLIT  0x0001

class CSplitterWnd : public CWnd
{
	DECLARE_DYNAMIC(CSplitterWnd)

// Construction
public:
	CSplitterWnd();
	// Create a single view type splitter with multiple splits
	BOOL Create(CWnd* pParentWnd,
				int nMaxRows, int nMaxCols, SIZE sizeMin,
				CCreateContext* pContext,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE |
					WS_HSCROLL | WS_VSCROLL | SPLS_DYNAMIC_SPLIT,
				UINT nID = AFX_IDW_PANE_FIRST);

	// Create a multiple view type splitter with static layout
	BOOL CreateStatic(CWnd* pParentWnd,
				int nRows, int nCols,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE,
				UINT nID = AFX_IDW_PANE_FIRST);

	virtual BOOL CreateView(int row, int col, CRuntimeClass* pViewClass,
			SIZE sizeInit, CCreateContext* pContext);

// Attributes
public:
	int GetRowCount() const;
	int GetColumnCount() const;

	// information about a specific row or column
	void GetRowInfo(int row, int& cyCur, int& cyMin) const;
	void SetRowInfo(int row, int cyIdeal, int cyMin);
	void GetColumnInfo(int col, int& cxCur, int& cxMin) const;
	void SetColumnInfo(int col, int cxIdeal, int cxMin);

	// views inside the splitter
	CWnd* GetPane(int row, int col) const;
	BOOL IsChildPane(CWnd* pWnd, int& row, int& col);
	int IdFromRowCol(int row, int col) const;

// Operations
public:
	void RecalcLayout();    // call after changing sizes

// Implementation Overridables
protected:
	// to customize the drawing
	enum ESplitType { splitBox, splitBar, splitIntersection };
	virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rect);
	virtual void OnInvertTracker(const CRect& rect);

	// for customizing scrollbar regions
	virtual BOOL CreateScrollBarCtrl(DWORD dwStyle, UINT nID);

	// for customizing DYNAMIC_SPLIT behavior
	virtual void DeleteView(int row, int col);
	virtual BOOL SplitRow(int cyBefore);
	virtual BOOL SplitColumn(int cxBefore);
	virtual void DeleteRow(int row);
	virtual void DeleteColumn(int row);

// Implementation
public:
	virtual ~CSplitterWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// high level command operations - called by default view implementation
	virtual BOOL CanActivateNext(BOOL bPrev = FALSE);
	virtual void ActivateNext(BOOL bPrev = FALSE);
	virtual BOOL DoKeyboardSplit();

	// implementation structure
	struct CRowColInfo
	{
		int nMinSize;       // below that try not to show
		int nIdealSize;     // user set size
		// variable depending on the available size layout
		int nCurSize;       // 0 => invisible, -1 => nonexistant
	};

	// syncronized scrolling
	BOOL DoScroll(CView* pViewFrom, UINT nScrollCode, BOOL bDoScroll = TRUE);
	BOOL DoScrollBy(CView* pViewFrom, CSize sizeScroll, BOOL bDoScroll = TRUE);

protected:
	// customizable implementation attributes (set by constructor or Create)
	CRuntimeClass* m_pDynamicViewClass;
	int m_nMaxRows, m_nMaxCols;
	int m_cxSplitter, m_cySplitter;     // size of box or splitter bar

	// current state information
	int m_nRows, m_nCols;
	BOOL m_bHasHScroll, m_bHasVScroll;
	CRowColInfo* m_pColInfo;
	CRowColInfo* m_pRowInfo;

	// Tracking info - only valid when 'm_bTracking' is set
	BOOL m_bTracking, m_bTracking2;
	CPoint m_ptTrackOffset;
	CRect m_rectLimit;
	CRect m_rectTracker, m_rectTracker2;
	int m_htTrack;

	// implementation routines
	BOOL CreateCommon(CWnd* pParentWnd, SIZE sizeMin, DWORD dwStyle, UINT nID);
	void StartTracking(int ht);
	void StopTracking(BOOL bAccept);
	int HitTest(CPoint pt) const;
	void GetInsideRect(CRect& rect) const;
	void GetHitRect(int ht, CRect& rect);
	void TrackRowSize(int y, int row);
	void TrackColumnSize(int x, int col);
	void DrawAllSplitBars(CDC* pDC, int cxInside, int cyInside);

	//{{AFX_MSG(CSplitterWnd)
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint pt);
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint pt);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint pt);
	afx_msg void OnCancelMode();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFormView - generic view constructed from a dialog template

class CFormView : public CScrollView
{
	DECLARE_DYNAMIC(CFormView)
// Construction
protected:      // must derive your own class
	CFormView(LPCSTR lpszTemplateName);
	CFormView(UINT nIDTemplate);

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnInitialUpdate();

protected:
	LPCSTR m_lpszTemplateName;
	CCreateContext* m_pCreateContext;
	HWND m_hWndFocus;   // last window to have focus

	virtual void OnDraw(CDC* pDC);      // default does nothing
	// special case override of child window creation
	virtual BOOL Create(LPCSTR, LPCSTR, DWORD,
		const RECT&, CWnd*, UINT, CCreateContext*);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual void OnActivateView(BOOL, CView*, CView*);
	virtual void OnActivateFrame(UINT, CFrameWnd*);
	BOOL SaveFocusControl();    // updates m_hWndFocus

	//{{AFX_MSG(CFormView)
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CEditView - simple text editor view

class CEditView : public CView
{
	DECLARE_DYNCREATE(CEditView)

// Construction
public:
	CEditView();
	static const DWORD dwStyleDefault;

// Attributes
public:
	// CEdit control access
	CEdit& GetEditCtrl() const;

	// presentation attributes
	CFont* GetPrinterFont() const;
	void SetPrinterFont(CFont* pFont);
	void SetTabStops(int nTabStops);

	// other attributes
	void GetSelectedText(CString& strResult) const;

// Operations
public:
	BOOL FindText(LPCSTR lpszFind, BOOL bNext = TRUE, BOOL bCase = TRUE);
	void SerializeRaw(CArchive& ar);
	UINT PrintInsideRect(CDC* pDC, RECT& rectLayout, UINT nIndexStart,
		UINT nIndexStop);

// Overrideables
protected:
	virtual void OnFindNext(LPCSTR lpszFind, BOOL bNext, BOOL bCase);
	virtual void OnReplaceSel(LPCSTR lpszFind, BOOL bNext, BOOL bCase,
		LPCSTR lpszReplace);
	virtual void OnReplaceAll(LPCSTR lpszFind, LPCSTR lpszReplace,
		BOOL bCase);
	virtual void OnTextNotFound(LPCSTR lpszFind);

// Implementation
public:
	virtual ~CEditView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void OnDraw(CDC* pDC);
	virtual void Serialize(CArchive& ar);
	virtual void DeleteContents();
	void ReadFromArchive(CArchive& ar, UINT nLen);
	void WriteToArchive(CArchive& ar);
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static const UINT nMaxSize; // maximum number of characters supported

protected:
	UINT m_segText;             // global segment for edit control data
	int m_nTabStops;            // tab stops in dialog units

	CUIntArray m_aPageStart;    // array of starting pages
	HFONT m_hPrinterFont;       // if NULL, mirror display font
	HFONT m_hMirrorFont;        // font object used when mirroring

	// construction
	WNDPROC* GetSuperWndProcAddr();
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// printing support
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL InitializeReplace();
	BOOL SameAsSelected(LPCSTR lpszCompare, BOOL bCase);

	// buffer access
	LPCSTR LockBuffer() const;
	void UnlockBuffer() const;
	UINT GetBufferLength() const;

	// special overrides for implementation
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);

	//{{AFX_MSG(CEditView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditChange();
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg LRESULT OnFindReplaceCmd(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// VBX control support

#ifndef NO_VBX_SUPPORT

// Implementation classes
class CVBControlModel;      // VBX Control Model Implementation
typedef LPVOID HCTL;        // Handle to a VBX Custom Control

// Implementation declarations
typedef char _based((_segment)_self) *BPSTR;
typedef BPSTR FAR*  HSZ;            // Long handle to a string

// definitions required by CVBControl
DECLARE_HANDLE(HPIC);       // Handle to a PIC structure

// DDX control aliasing - stores a pointer to true C++ object
void AFXAPI DDX_VBControl(CDataExchange* pDX, int nIDC, CVBControl*& rpControl);
	// Special DDX for subclassing since we don't permit 2 C++ windows !

// DDX for VB control properties
void AFXAPI DDX_VBText(CDataExchange* pDX, int nIDC, int nPropIndex,
	CString& value);
void AFXAPI DDX_VBBool(CDataExchange* pDX, int nIDC, int nPropIndex,
	BOOL& value);
void AFXAPI DDX_VBInt(CDataExchange* pDX, int nIDC, int nPropIndex,
	int& value);
void AFXAPI DDX_VBLong(CDataExchange* pDX, int nIDC, int nPropIndex,
	LONG& value);
void AFXAPI DDX_VBColor(CDataExchange* pDX, int nIDC, int nPropIndex,
	COLORREF& value);
void AFXAPI DDX_VBFloat(CDataExchange* pDX, int nIDC, int nPropIndex,
	float& value);

// DDX for VB read-only properties
void AFXAPI DDX_VBTextRO(CDataExchange* pDX, int nIDC, int nPropIndex,
	CString& value);
void AFXAPI DDX_VBBoolRO(CDataExchange* pDX, int nIDC, int nPropIndex,
	BOOL& value);
void AFXAPI DDX_VBIntRO(CDataExchange* pDX, int nIDC, int nPropIndex,
	int& value);
void AFXAPI DDX_VBLongRO(CDataExchange* pDX, int nIDC, int nPropIndex,
	LONG& value);
void AFXAPI DDX_VBColorRO(CDataExchange* pDX, int nIDC, int nPropIndex,
	COLORREF& value);
void AFXAPI DDX_VBFloatRO(CDataExchange* pDX, int nIDC, int nPropIndex,
	float& value);

/////////////////////////////////////////////////////////////////////////////

class CVBControl : public CWnd
{
	DECLARE_DYNAMIC(CVBControl)
// Constructors
public:
	CVBControl();

	BOOL Create(LPCSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pFile = NULL, BOOL bAutoDelete = FALSE);


// Attributes
	// Property Access Routines
	BOOL SetNumProperty(int nPropIndex, LONG lValue, int index = 0);
	BOOL SetNumProperty(LPCSTR lpszPropName, LONG lValue, int index = 0);

	BOOL SetFloatProperty(int nPropIndex, float value, int index = 0);
	BOOL SetFloatProperty(LPCSTR lpszPropName, float value, int index = 0);

	BOOL SetStrProperty(int nPropIndex, LPCSTR lpszValue, int index = 0);
	BOOL SetStrProperty(LPCSTR lpszPropName, LPCSTR lpszValue, int index = 0);

	BOOL SetPictureProperty(int nPropIndex, HPIC hPic, int index = 0);
	BOOL SetPictureProperty(LPCSTR lpszPropName, HPIC hPic, int index = 0);

	LONG GetNumProperty(int nPropIndex, int index = 0);
	LONG GetNumProperty(LPCSTR lpszPropName, int index = 0);

	float GetFloatProperty(int nPropIndex, int index = 0);
	float GetFloatProperty(LPCSTR lpszPropName, int index = 0);

	CString GetStrProperty(int nPropIndex, int index = 0);
	CString GetStrProperty(LPCSTR lpszPropName, int index = 0);

	HPIC GetPictureProperty(int nPropIndex, int index = 0);
	HPIC GetPictureProperty(LPCSTR lpszPropName, int index = 0);

	// Get the index of a property
	int GetPropIndex(LPCSTR lpszPropName) const;
	LPCSTR GetPropName(int nIndex) const;

	// Get the index of an Event
	int GetEventIndex(LPCSTR lpszEventName) const;
	LPCSTR GetEventName(int nIndex) const;

	// Class name of control
	LPCSTR GetVBXClass() const;

	// Class information
	int GetNumProps() const;
	int GetNumEvents() const;
	BOOL IsPropArray(int nIndex) const;

	UINT GetPropType(int nIndex) const;
	DWORD GetPropFlags(int nIndex) const;

	// Error reporting variable
	// Contains the VB error code returned by a control
	int m_nError;

// Operations
	// BASIC file number (channel) to CFile association

	static void PASCAL OpenChannel(CFile* pFile, WORD wChannel);
	static BOOL PASCAL CloseChannel(WORD wChannel);
	static CFile* PASCAL GetChannel(WORD wChannel);
	static void BeginNewVBHeap();

	void AddItem(LPCSTR lpszItem, LONG lIndex);
	void RemoveItem(LONG lIndex);
	void Refresh();
	void Move(RECT& rect);


// Implementation
public:
	virtual ~CVBControl();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	DWORD GetModelFlags();
	DWORD GetModelStyles();
	void ReferenceFile(BOOL bReference);
	static void EnableVBXFloat();

	static BOOL ParseWindowText(LPCSTR lpszWindowName, CString& strFileName,
								CString& strClassName, CString& strCaption);

	HCTL GetHCTL();

	// Control Defined Structure -- Dangerous to use directly
	BYTE FAR* GetUserSpace();

	struct CRecreateStruct  // Implementation structure
	{
		char* pText;
		DWORD dwStyle;
		CRect rect;
		HWND hWndParent;
		UINT nControlID;
	};

	enum
	{
		TYPE_FROMVBX,           // Coming from VBX, assume proper type
		TYPE_INTEGER,           // int or LONG
		TYPE_REAL,              // float
		TYPE_STRING,
		TYPE_PICTURE
	};

	virtual LRESULT DefControlProc(UINT message, WPARAM wParam, LPARAM lParam);
	void Recreate(CRecreateStruct& rs);
	CVBControlModel* GetModel();

public:
	int GetStdPropIndex(int nStdID) const;
	BOOL SetPropertyWithType(int nPropIndex, WORD wType,
									LONG lValue, int index);
	LONG GetNumPropertyWithType(int nPropIndex, UINT nType, int index);
	HSZ GetStrProperty(int nPropIndex, int index, BOOL& bTemp);
	CString m_ctlName;          // Read only at run-time

	// Trace routine to allow one library version
	static void CDECL Trace(BOOL bFatal, UINT nFormatIndex, ...);
	void VBXAssertValid() const;    // non-virtual helper

	static BOOL EnableMemoryTracking(BOOL bTracking);

protected:

	static CVBControl* NEW();
	void DELETE();

	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
	LRESULT CallControlProc(UINT message, WPARAM wParam, LPARAM lParam);

	BOOL CommonInit();
	void SetDefaultValue(int nPropIndex, BOOL bPreHwnd);

	BOOL SetStdProp(WORD wPropId, WORD wType, LONG lValue);
	LONG GetStdNumProp(WORD wPropId);
	CString GetStdStrProp(WORD wPropId);

	BOOL SetFontProperty(WORD wPropId, LONG lData);
	void BuildCurFont(HDC hDC, HFONT hCurFont, LOGFONT& logFont);
	LONG GetNumFontProperty(WORD wPropId);
	WORD GetCharSet(HDC hDC, LPCSTR lpFaceName);

	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();

	void FireMouseEvent(WORD event, WORD wButton, WPARAM wParam, LPARAM lParam);
	BOOL CreateAndSetFont(LPLOGFONT lplf);

	BOOL LoadProperties(CFile* pFile, BOOL bPreHwnd);
	BOOL LoadProp(int nPropIndex, CFile* pFile);
	BOOL LoadPropData(int nPropIndex, CFile* pFile);

	BOOL IsPropDefault(int nPropIndex);

	CVBControlModel* LoadControl(LPCSTR lpszFileName, LPCSTR lpszControlName);
	afx_msg void OnVBXLoaded();

	void AllocateHCTL(size_t nSize);
	void DeallocateHCTL();

	static int ConvertFontSizeToTwips(LONG lFontSize);
	// This actually returns a float masquerading as a long
	static LONG ConvertTwipsToFontSize(int nTwips);

protected:
	CVBControlModel* m_pModel;

	BOOL m_bRecreating;         // Do not destroy on this NCDestroy
	BOOL m_bAutoDelete;         // TRUE if automatically created
	BOOL m_bInPostNcDestroy;    // TRUE if deleting from Destroy
	BOOL m_bLoading;            // TRUE if loading properties from formfile
	int m_nCursorID;

	// variables for stack overrun protection
	UINT m_nInitialStack;       // SP when control recieved first message
	UINT m_nRecursionLevel;     // Level of control proc recursion
	BOOL m_bStackFault;         // TRUE if stack fault hit
	UINT m_nFaultRecurse;       // level at which stack faulted

	HBRUSH m_hbrBkgnd;            // brush used in WM_CTLCOLOR
	HFONT m_hFontCreated;              // Font created by control
	HCURSOR m_hcurMouse;
	HCTL m_hCtl;                // Control handle
	COLORREF m_clrBkgnd;
	COLORREF m_clrFore;
	CRect m_rectCreate;         // Created Size
	CString m_strTag;

	// friends required for VB API access
	friend LRESULT CALLBACK AFX_EXPORT _AfxVBWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	friend LRESULT CALLBACK AFX_EXPORT _AfxVBProxyProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	friend WORD CALLBACK AFX_EXPORT _AfxVBFireEvent(HCTL hControl, WORD idEvent, LPVOID lpParams);
	friend WORD CALLBACK AFX_EXPORT _AfxVBRecreateControlHwnd(HCTL hControl);

	DECLARE_MESSAGE_MAP()

	/////////////////////
	// Implementation
	// These APIs can not be referenced by applications
public:
	DWORD Save(CFile* pFile);
	BOOL Load(CFile* pData);

protected:
	BOOL m_bCreatedInDesignMode;
	BOOL m_bVisible;

	friend class CVBPopupWnd;

	BOOL SaveProperties(CFile* pFile, BOOL bPreHwnd);
	BOOL SaveProp(int nPropIndex, CFile* pFile);
	BOOL SavePropData(int nPropIndex, CFile* pFile);
	LONG InitPropPopup(WPARAM wParam, LPARAM lParam);
	void DoPictureDlg(int m_nPropId);
	void DoColorDlg(int m_nPropId);
	void DoFontDlg(int m_nPropId);
	void FillList(CListBox* pLB, LPCSTR lpszEnumList);
};

UINT AFXAPI AfxRegisterVBEvent(LPCSTR lpszEventName);

// Values for VBX Property Types

#define DT_HSZ        0x01
#define DT_SHORT      0x02
#define DT_LONG       0x03
#define DT_BOOL       0x04
#define DT_COLOR      0x05
#define DT_ENUM       0x06
#define DT_REAL       0x07
#define DT_XPOS       0x08  // Scaled from float to long twips
#define DT_XSIZE      0x09  //   _SIZE scales without origin
#define DT_YPOS       0x0A  //   _POS subtracts origin
#define DT_YSIZE      0x0B  // uses parent's scale properties
#define DT_PICTURE    0x0C

#define COLOR_SYSCOLOR  0x80000000L // defines a System color for a property
#define MAKESYSCOLOR(iColor)    ((COLORREF)(iColor + COLOR_SYSCOLOR))



/////////////////////////////////////////////////////////////////////////////
// VBX HPIC Functions

/////////////////////////////////////////////////////////////////////////////
// Picture structure
// This structure is taken from the VB Code and used to be compatible
// with that code

//NOTE:  This structure MUST be packed.
#pragma pack(1)
struct NEAR PIC
{
	BYTE    picType;
	union
	{
		struct
		{
			HBITMAP   hbitmap;      // bitmap
		} bmp;
		struct
		{
			HMETAFILE hmeta;        // Metafile
			int     xExt, yExt;     // extent
		} wmf;
		struct
		{
			HICON     hicon;        // Icon
		} icon;
	} picData;

	// Implementation
	WORD    nRefCount;
	BYTE    picReserved[2];
};
#pragma pack()

typedef PIC FAR* LPPIC;

#define PICTYPE_NONE        0
#define PICTYPE_BITMAP      1
#define PICTYPE_METAFILE    2
#define PICTYPE_ICON        3

#define HPIC_INVALID        ((HPIC)0xFFFF)

HPIC AFXAPI AfxSetPict(HPIC hPic, const PIC FAR* lpPic);
void AFXAPI AfxGetPict(HPIC hPic, LPPIC lpPic);
void AFXAPI AfxReferencePict(HPIC hPic, BOOL bReference);

#endif //!NO_VBX_SUPPORT

/////////////////////////////////////////////////////////////////////////////

class CMetaFileDC : public CDC
{
	DECLARE_DYNAMIC(CMetaFileDC)

// Constructors
public:
	CMetaFileDC();
	BOOL Create(LPCSTR lpszFilename = NULL);

// Operations
	HMETAFILE Close();

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC

protected:
	virtual void SetOutputDC(HDC hDC);  // Set the Output DC -- Not allowed
	virtual void ReleaseOutputDC();     // Release the Output DC -- Not allowed

public:
	virtual ~CMetaFileDC();

// Clipping Functions (use the Attribute DC's clip region)
	virtual int GetClipBox(LPRECT lpRect) const;
	virtual BOOL PtVisible(int x, int y) const;
	virtual BOOL RectVisible(LPCRECT lpRect) const;

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCSTR lpszString, int nCount);
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPRECT lpRect,
				LPCSTR lpszString, UINT nCount, LPINT lpDxWidths);
	virtual CSize TabbedTextOut(int x, int y, LPCSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
	virtual int DrawText(LPCSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);

// Printer Escape Functions
	virtual int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData);

// Viewport Functions
	virtual CPoint SetViewportOrg(int x, int y);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);
	virtual CSize SetViewportExt(int x, int y);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);

protected:
	void AdjustCP(int cx);
};

/////////////////////////////////////////////////////////////////////////////
// CRectTracker - simple rectangular tracking rectangle w/resize handles

class CRectTracker
{
public:
// Constructors
	CRectTracker();
	CRectTracker(LPCRECT lpSrcRect, UINT nStyle);

// Style Flags
	enum StyleFlags
	{
		solidLine = 1, dottedLine = 2, hatchedBorder = 4,
		resizeInside = 8, resizeOutside = 16, hatchInside = 32,
	};

// Hit-Test codes
	enum TrackerHit
	{
		hitNothing = -1,
		hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
		hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
	};

// Attributes
	UINT m_nStyle;      // current state
	CRect m_rect;       // current position (always in pixels)
	CSize m_sizeMin;    // minimum X and Y size during track operation
	int m_nHandleSize;  // size of resize handles (default from WIN.INI)

// Operations
	void Draw(CDC* pDC) const;
	void GetTrueRect(LPRECT lpTrueRect) const;
	BOOL SetCursor(CWnd* pWnd, UINT nHitTest) const;
	BOOL Track(CWnd* pWnd, CPoint point, BOOL bAllowInvert = FALSE,
		CWnd* pWndClipTo = NULL);
	BOOL TrackRubberBand(CWnd* pWnd, CPoint point, BOOL bAllowInvert = TRUE);
	int HitTest(CPoint point) const;
	int NormalizeHit(int nHandle) const;

// Overridables
	virtual void DrawTrackerRect(LPCRECT lpRect, CWnd* pWndClipTo,
		CDC* pDC, CWnd* pWnd);
	virtual void AdjustRect(int nHandle, LPRECT lpRect);
	virtual void OnChangedRect(const CRect& rectOld);

// Implementation
public:
	virtual ~CRectTracker();

protected:
	BOOL m_bAllowInvert;    // flag passed to Track or TrackRubberBand

	// implementation helpers
	int HitTestHandles(CPoint point) const;
	UINT GetHandleMask() const;
	void GetHandleRect(int nHandle, CRect* pHandleRect) const;
	void GetModifyPointers(int nHandle, int**ppx, int**ppy, int* px, int*py);
	int GetHandleSize() const;
	BOOL TrackHandle(int nHandle, CWnd* pWnd, CPoint point, CWnd* pWndClipTo);
	void Construct();
};

/////////////////////////////////////////////////////////////////////////////
// Informational data structures

struct CPrintInfo // Printing information structure
{
	CPrintInfo();
	~CPrintInfo();

	CPrintDialog* m_pPD;     // pointer to print dialog

	BOOL m_bPreview;         // TRUE if in preview mode
	BOOL m_bContinuePrinting;// set to FALSE to prematurely end printing
	UINT m_nCurPage;         // Current page
	UINT m_nNumPreviewPages; // Desired number of preview pages
	CString m_strPageDesc;   // Format string for page number display
	LPVOID m_lpUserData;     // pointer to user created struct
	CRect m_rectDraw;        // rectangle defining current usable page area

	void SetMinPage(UINT nMinPage);
	void SetMaxPage(UINT nMaxPage);
	UINT GetMinPage() const;
	UINT GetMaxPage() const;
	UINT GetFromPage() const;
	UINT GetToPage() const;
};

struct CPrintPreviewState   // Print Preview context/state
{
	UINT nIDMainPane;          // main pane ID to hide
	HMENU hMenu;               // saved hMenu
	DWORD dwStates;            // Control Bar Visible states (bit map)
	CView* pViewActiveOld;     // save old active view during preview
	BOOL (CALLBACK* lpfnCloseProc)(CFrameWnd* pFrameWnd);
	HACCEL hAccelTable;       // saved accelerator table

// Implementation
	CPrintPreviewState();
};

struct CCreateContext   // Creation information structure
	// All fields are optional and may be NULL
{
	// for creating new views
	CRuntimeClass* m_pNewViewClass; // runtime class of view to create or NULL
	CDocument* m_pCurrentDoc;

	// for creating MDI children (CMDIChildWnd::LoadFrame)
	CDocTemplate* m_pNewDocTemplate;

	// for sharing view/frame state from the original view/frame
	CView* m_pLastView;
	CFrameWnd* m_pCurrentFrame;

// Implementation
	CCreateContext();
};

/////////////////////////////////////////////////////////////////////////////
// VB inlines must ALWAYS be inlined if included at all

#ifndef NO_VBX_SUPPORT
#define _AFXVBX_INLINE inline
#include <afxext.inl>
#undef _AFXVBX_INLINE
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXEXT_INLINE inline
#include <afxext.inl>
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

/////////////////////////////////////////////////////////////////////////////
#endif //__AFXEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxext.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXEXT.H

/////////////////////////////////////////////////////////////////////////////
// main inlines

#ifdef _AFXEXT_INLINE

_AFXEXT_INLINE CCreateContext::CCreateContext()
	{ memset(this, 0, sizeof(*this)); }

// CSplitterWnd
_AFXEXT_INLINE int CSplitterWnd::GetRowCount() const
	{ return m_nRows; }
_AFXEXT_INLINE int CSplitterWnd::GetColumnCount() const
	{ return m_nCols; }

// control bars
_AFXEXT_INLINE int CControlBar::GetCount() const
	{ return m_nCount; }
_AFXEXT_INLINE BOOL CToolBar::LoadBitmap(UINT nIDResource)
	{ return LoadBitmap(MAKEINTRESOURCE(nIDResource)); }
_AFXEXT_INLINE BOOL CDialogBar::Create(CWnd* pParentWnd, UINT nIDTemplate,
		UINT nStyle, UINT nID)
	{ return Create(pParentWnd, MAKEINTRESOURCE(nIDTemplate), nStyle, nID); }

// CRectTracker
_AFXEXT_INLINE CRectTracker::CRectTracker()
	{ Construct(); }

// CBitmapButton
_AFXEXT_INLINE CBitmapButton::CBitmapButton()
	{ }

// CPrintInfo
_AFXEXT_INLINE void CPrintInfo::SetMinPage(UINT nMinPage)
	{ m_pPD->m_pd.nMinPage = nMinPage; }
_AFXEXT_INLINE void CPrintInfo::SetMaxPage(UINT nMaxPage)
	{ m_pPD->m_pd.nMaxPage = nMaxPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetMinPage() const
	{ return m_pPD->m_pd.nMinPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetMaxPage() const
	{ return m_pPD->m_pd.nMaxPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetFromPage() const
	{ return m_pPD->m_pd.nFromPage; }
_AFXEXT_INLINE UINT CPrintInfo::GetToPage() const
	{ return m_pPD->m_pd.nToPage; }
// CEditView
_AFXEXT_INLINE CEdit& CEditView::GetEditCtrl() const
	{ return *(CEdit*)this; }

#endif //_AFXEXT_INLINE

/////////////////////////////////////////////////////////////////////////////
// VBX specific inlines

#ifdef _AFXVBX_INLINE
_AFXVBX_INLINE BOOL CVBControl::SetNumProperty(int nPropIndex, LONG lValue,
		int index /* = 0 */)
	{ return SetPropertyWithType(nPropIndex, TYPE_INTEGER, lValue, index); }
_AFXVBX_INLINE BOOL CVBControl::SetNumProperty(LPCSTR lpszPropName, LONG lValue,
		int index /* = 0 */)
	{ return SetPropertyWithType(GetPropIndex(lpszPropName),TYPE_INTEGER,lValue,index); }
_AFXVBX_INLINE BOOL CVBControl::SetFloatProperty(LPCSTR lpszPropName, float value,
		int index /* = 0 */)
	{ return SetFloatProperty(GetPropIndex(lpszPropName), value, index); }
_AFXVBX_INLINE BOOL CVBControl::SetStrProperty(int nPropIndex, LPCSTR lpszValue,
		int index /* = 0 */)
	{ return SetPropertyWithType(nPropIndex, TYPE_STRING, (LONG)lpszValue, index); }
_AFXVBX_INLINE BOOL CVBControl::SetStrProperty(LPCSTR lpszPropName, LPCSTR lpszValue,
		int index /* = 0 */)
	{ return SetPropertyWithType(GetPropIndex(lpszPropName), TYPE_STRING,
		(LONG)lpszValue, index); }
_AFXVBX_INLINE BOOL CVBControl::SetPictureProperty(int nPropIndex, HPIC hPic,
		int index /* = 0 */)
	{ return SetPropertyWithType(nPropIndex, TYPE_PICTURE, (UINT)hPic,
		index); }
_AFXVBX_INLINE BOOL CVBControl::SetPictureProperty(LPCSTR lpszPropName, HPIC hPic,
		int index /* = 0 */)
	{ return SetPropertyWithType(GetPropIndex(lpszPropName), TYPE_PICTURE,
		(UINT)hPic, index); }
_AFXVBX_INLINE LONG CVBControl::GetNumProperty(int nPropIndex, int index /* = 0 */)
	{ return GetNumPropertyWithType(nPropIndex, TYPE_INTEGER, index); }
_AFXVBX_INLINE LONG CVBControl::GetNumProperty(LPCSTR lpszPropName, int index /* = 0 */)
	{ return GetNumPropertyWithType(GetPropIndex(lpszPropName), TYPE_INTEGER, index); }
_AFXVBX_INLINE float CVBControl::GetFloatProperty(LPCSTR lpszPropName,
		int index /* = 0 */)
	{ return GetFloatProperty(GetPropIndex(lpszPropName), index); }
_AFXVBX_INLINE CString CVBControl::GetStrProperty(LPCSTR lpszPropName,
		int index /* = 0 */)
	{ return GetStrProperty(GetPropIndex(lpszPropName), index); }
_AFXVBX_INLINE HPIC CVBControl::GetPictureProperty(int nPropIndex,
		int index /* = 0 */)
	{ return (HPIC) GetNumPropertyWithType(nPropIndex, TYPE_PICTURE, index); }
_AFXVBX_INLINE HPIC CVBControl::GetPictureProperty(LPCSTR lpszPropName,
		int index /* = 0 */)
	{ return (HPIC) GetNumPropertyWithType(GetPropIndex(lpszPropName), TYPE_PICTURE, index); }
_AFXVBX_INLINE HCTL CVBControl::GetHCTL()
	{ return m_hCtl; }
_AFXVBX_INLINE CVBControlModel* CVBControl::GetModel()
	{ return m_pModel; }

#endif //_AFXVBX_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxmsg_.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Do not include this file directly (included by AFXWIN.H)


/////////////////////////////////////////////////////////////////////////////

// Entries in a message map (a 'AFX_MSGMAP_ENTRY') table can be of six formats
// 1) control notification message (i.e. in response to WM_COMMAND)
//      nNotifyCode, nControlID, signature type, parameterless member function
//      (eg: LBN_SELCHANGE, IDC_LISTBOX, AfxSig_vv, ... )
// 2) Update Command UI
//      -1, nControlID, signature Unknown, parameterless member function
// 3) menu/accelerator notification message (i.e. special case of first format)
//      0, nID, signature type, parameterless member function
//      (eg: 0, IDM_FILESAVE, AfxSig_vv, ... )
// 4) constant windows message
//      nMessage, 0, signature type, member function
//      (eg: WM_PAINT, 0, ...)
// 5) variable windows message (using RegisterWindowMessage)
//      0xC000, 0, &nMessage, special member function
// 6) variable control notification message (i.e. in response to WM_VBXEVENT)
//      0xC001, nControlID, &nMessage, special member function
//      (eg: LBN_SELCHANGE, IDC_LISTBOX, AfxSig_vv, ... )

// The end of the message map is marked with a special value
//      0, 0, AfxSig_end, 0

/////////////////////////////////////////////////////////////////////////////

enum AfxSig
{
	AfxSig_end = 0,     // [marks end of message map]

	AfxSig_bD,      // BOOL (CDC*)
	AfxSig_bb,      // BOOL (BOOL)
	AfxSig_bWww,    // BOOL (CWnd*, UINT, UINT)
	AfxSig_hDWw,    // HBRUSH (CDC*, CWnd*, UINT)
	AfxSig_iwWw,    // int (UINT, CWnd*, UINT)
	AfxSig_iWww,    // int (CWnd*, UINT, UINT)
	AfxSig_is,      // int (LPSTR)
	AfxSig_lwl,     // LRESULT (WPARAM, LPARAM)
	AfxSig_lwwM,    // LRESULT (UINT, UINT, CMenu*)
	AfxSig_vv,      // void (void)

	AfxSig_vw,      // void (UINT)
	AfxSig_vww,     // void (UINT, UINT)
	AfxSig_vvii,    // void (int, int) // wParam is ignored
	AfxSig_vwww,    // void (UINT, UINT, UINT)
	AfxSig_vwii,    // void (UINT, int, int)
	AfxSig_vwl,     // void (UINT, LPARAM)
	AfxSig_vbWW,    // void (BOOL, CWnd*, CWnd*)
	AfxSig_vD,      // void (CDC*)
	AfxSig_vM,      // void (CMenu*)
	AfxSig_vMwb,    // void (CMenu*, UINT, BOOL)

	AfxSig_vW,      // void (CWnd*)
	AfxSig_vWww,    // void (CWnd*, UINT, UINT)
	AfxSig_vWh,     // void (CWnd*, HANDLE)
	AfxSig_vwW,     // void (UINT, CWnd*)
	AfxSig_vwWb,    // void (UINT, CWnd*, BOOL)
	AfxSig_vwwW,    // void (UINT, UINT, CWnd*)
	AfxSig_vs,      // void (LPSTR)
	AfxSig_vOWNER,  // void (int, LPSTR), force return TRUE
	AfxSig_iis,     // int (int, LPSTR)
	AfxSig_wp,      // UINT (CPoint)
	AfxSig_wv,      // UINT (void)
	AfxSig_vPOS,    // void (WINDOWPOS FAR*)
	AfxSig_vCALC,   // void (NCCALCSIZE_PARAMS FAR*)

	// signatures specific to CCmdTarget
	AfxSig_vbx,     // void (UINT, int, CVBControl*, LPVOID)
	AfxSig_cmdui,   // void (CCmdUI*)
	AfxSig_vpv,     // void (void*)
	AfxSig_bpv,     // BOOL (void*)

	// Other aliases (based on implementation)
	AfxSig_vwwh = AfxSig_vwww,  // void (UINT, UINT, HANDLE)
	AfxSig_vwp = AfxSig_vwl,    // void (UINT, CPoint)
	AfxSig_bw = AfxSig_bb,      // BOOL (UINT)
	AfxSig_bh = AfxSig_bb,      // BOOL (HANDLE)
	AfxSig_bv = AfxSig_wv,      // BOOL (void)
	AfxSig_hv = AfxSig_wv,      // HANDLE (void)
	AfxSig_vb = AfxSig_vw,      // void (BOOL)
	AfxSig_vbh = AfxSig_vww,    // void (BOOL, HANDLE)
	AfxSig_vbw = AfxSig_vww,    // void (BOOL, UINT)
	AfxSig_vhh = AfxSig_vww,    // void (HANDLE, HANDLE)
	AfxSig_vh = AfxSig_vw       // void (HANDLE)
};

/////////////////////////////////////////////////////////////////////////////
// Command notifications for CCmdTarget notifications

#define CN_COMMAND              0           // void ()
#define CN_UPDATE_COMMAND_UI    (-1)        // void (CCmdUI*)
// > 0 are control notifications

#define ON_COMMAND(id, memberFxn) \
	{ CN_COMMAND, id, AfxSig_vv, (AFX_PMSG)memberFxn },
		// ON_COMMAND(id, OnFoo) is the same as
		//   ON_CONTROL(0, id, OnFoo) or ON_BN_CLICKED(0, id, OnFoo)

#define ON_COMMAND_EX(id, memberFxn) \
	{ CN_COMMAND, id, AfxSig_bw, \
		(AFX_PMSG)(BOOL (AFX_MSG_CALL CCmdTarget::*)(UINT))memberFxn },

#define ON_UPDATE_COMMAND_UI(id, memberFxn) \
	{ CN_UPDATE_COMMAND_UI, id, AfxSig_cmdui, \
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(CCmdUI*))memberFxn },

// for general controls
#define ON_CONTROL(wNotifyCode, id, memberFxn) \
	{ wNotifyCode, id, AfxSig_vv, (AFX_PMSG)memberFxn },

/////////////////////////////////////////////////////////////////////////////
// Message map tables for Windows messages

#define ON_WM_CREATE() \
	{ WM_CREATE, 0, AfxSig_is, \
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(LPCREATESTRUCT))OnCreate },
#define ON_WM_DESTROY() \
	{ WM_DESTROY, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnDestroy },
#define ON_WM_MOVE() \
	{ WM_MOVE, 0, AfxSig_vvii, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, int))OnMove },
#define ON_WM_SIZE() \
	{ WM_SIZE, 0, AfxSig_vwii, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, int, int))OnSize },
#define ON_WM_ACTIVATE() \
	{ WM_ACTIVATE, 0, AfxSig_vwWb, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CWnd*, BOOL))OnActivate },
#define ON_WM_SETFOCUS() \
	{ WM_SETFOCUS, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*))OnSetFocus },
#define ON_WM_KILLFOCUS() \
	{ WM_KILLFOCUS, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*))OnKillFocus },
#define ON_WM_ENABLE() \
	{ WM_ENABLE, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL))OnEnable },
#define ON_WM_PAINT() \
	{ WM_PAINT, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnPaint },
#define ON_WM_CLOSE() \
	{ WM_CLOSE, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnClose },
#define ON_WM_QUERYENDSESSION() \
	{ WM_QUERYENDSESSION, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(void))OnQueryEndSession },
#define ON_WM_QUERYOPEN() \
	{ WM_QUERYOPEN, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(void))OnQueryOpen },
#define ON_WM_ERASEBKGND() \
	{ WM_ERASEBKGND, 0, AfxSig_bD, \
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(CDC*))OnEraseBkgnd },
#define ON_WM_SYSCOLORCHANGE() \
	{ WM_SYSCOLORCHANGE, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnSysColorChange },
#define ON_WM_ENDSESSION() \
	{ WM_ENDSESSION, 0, AfxSig_vb, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL))OnEndSession },
#define ON_WM_SHOWWINDOW() \
	{ WM_SHOWWINDOW, 0, AfxSig_vbw, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, UINT))OnShowWindow },
#define ON_WM_CTLCOLOR() \
	{ WM_CTLCOLOR, 0, AfxSig_hDWw, \
		(AFX_PMSG)(AFX_PMSGW)(HBRUSH (AFX_MSG_CALL CWnd::*)(CDC*, CWnd*, UINT))OnCtlColor },
#define ON_WM_WININICHANGE() \
	{ WM_WININICHANGE, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(LPCSTR))OnWinIniChange },
#define ON_WM_DEVMODECHANGE() \
	{ WM_DEVMODECHANGE, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(LPSTR))OnDevModeChange },
#define ON_WM_ACTIVATEAPP() \
	{ WM_ACTIVATEAPP, 0, AfxSig_vbh, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, HTASK))OnActivateApp },
#define ON_WM_FONTCHANGE() \
	{ WM_FONTCHANGE, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnFontChange },
#define ON_WM_TIMECHANGE() \
	{ WM_TIMECHANGE, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnTimeChange },
#define ON_WM_CANCELMODE() \
	{ WM_CANCELMODE, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnCancelMode },
#define ON_WM_SETCURSOR() \
	{ WM_SETCURSOR, 0, AfxSig_bWww, \
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT))OnSetCursor },
#define ON_WM_MOUSEACTIVATE() \
	{ WM_MOUSEACTIVATE, 0, AfxSig_iWww, \
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT))OnMouseActivate },
#define ON_WM_CHILDACTIVATE() \
	{ WM_CHILDACTIVATE, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnChildActivate },
#define ON_WM_GETMINMAXINFO() \
	{ WM_GETMINMAXINFO, 0, AfxSig_vs, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(MINMAXINFO FAR*))OnGetMinMaxInfo },
#define ON_WM_ICONERASEBKGND() \
	{ WM_ICONERASEBKGND, 0, AfxSig_vD, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CDC*))OnIconEraseBkgnd },
#define ON_WM_SPOOLERSTATUS() \
	{ WM_SPOOLERSTATUS, 0, AfxSig_vww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT))OnSpoolerStatus },
#define ON_WM_DRAWITEM() \
	{ WM_DRAWITEM, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, LPDRAWITEMSTRUCT))OnDrawItem },
#define ON_WM_MEASUREITEM() \
	{ WM_MEASUREITEM, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, LPMEASUREITEMSTRUCT))OnMeasureItem },
#define ON_WM_DELETEITEM() \
	{ WM_DELETEITEM, 0, AfxSig_vOWNER, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(int, LPDELETEITEMSTRUCT))OnDeleteItem },
#define ON_WM_CHARTOITEM() \
	{ WM_CHARTOITEM, 0, AfxSig_iwWw, \
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, UINT))OnCharToItem },
#define ON_WM_VKEYTOITEM() \
	{ WM_VKEYTOITEM, 0, AfxSig_iwWw, \
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(UINT, CListBox*, UINT))OnVKeyToItem },
#define ON_WM_QUERYDRAGICON() \
	{ WM_QUERYDRAGICON, 0, AfxSig_hv, \
		(AFX_PMSG)(AFX_PMSGW)(HCURSOR (AFX_MSG_CALL CWnd::*)())OnQueryDragIcon },
#define ON_WM_COMPAREITEM() \
	{ WM_COMPAREITEM, 0, AfxSig_iis, \
		(AFX_PMSG)(AFX_PMSGW)(int (AFX_MSG_CALL CWnd::*)(int, LPCOMPAREITEMSTRUCT))OnCompareItem },
#define ON_WM_COMPACTING() \
	{ WM_COMPACTING, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT))OnCompacting },
#define ON_WM_NCCREATE() \
	{ WM_NCCREATE, 0, AfxSig_is, \
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(LPCREATESTRUCT))OnNcCreate },
#define ON_WM_NCDESTROY() \
	{ WM_NCDESTROY, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnNcDestroy },
#define ON_WM_NCCALCSIZE() \
	{ WM_NCCALCSIZE, 0, AfxSig_vCALC, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, NCCALCSIZE_PARAMS FAR*))OnNcCalcSize },
#define ON_WM_NCHITTEST() \
	{ WM_NCHITTEST, 0, AfxSig_wp, \
		(AFX_PMSG)(AFX_PMSGW)(UINT (AFX_MSG_CALL CWnd::*)(CPoint))OnNcHitTest },
#define ON_WM_NCPAINT() \
	{ WM_NCPAINT, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnNcPaint },
#define ON_WM_NCACTIVATE() \
	{ WM_NCACTIVATE, 0, AfxSig_bb, \
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(BOOL))OnNcActivate },
#define ON_WM_GETDLGCODE() \
	{ WM_GETDLGCODE, 0, AfxSig_wv, \
		(AFX_PMSG)(AFX_PMSGW)(UINT (AFX_MSG_CALL CWnd::*)(void))OnGetDlgCode },
#define ON_WM_NCMOUSEMOVE() \
	{ WM_NCMOUSEMOVE, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcMouseMove },
#define ON_WM_NCLBUTTONDOWN() \
	{ WM_NCLBUTTONDOWN, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcLButtonDown },
#define ON_WM_NCLBUTTONUP() \
	{ WM_NCLBUTTONUP, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcLButtonUp },
#define ON_WM_NCLBUTTONDBLCLK() \
	{ WM_NCLBUTTONDBLCLK, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcLButtonDblClk },
#define ON_WM_NCRBUTTONDOWN() \
	{ WM_NCRBUTTONDOWN, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcRButtonDown },
#define ON_WM_NCRBUTTONUP() \
	{ WM_NCRBUTTONUP, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcRButtonUp },
#define ON_WM_NCRBUTTONDBLCLK() \
	{ WM_NCRBUTTONDBLCLK, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcRButtonDblClk },
#define ON_WM_NCMBUTTONDOWN() \
	{ WM_NCMBUTTONDOWN, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcMButtonDown },
#define ON_WM_NCMBUTTONUP() \
	{ WM_NCMBUTTONUP, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcMButtonUp },
#define ON_WM_NCMBUTTONDBLCLK() \
	{ WM_NCMBUTTONDBLCLK, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnNcMButtonDblClk },
#define ON_WM_KEYDOWN() \
	{ WM_KEYDOWN, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnKeyDown },
#define ON_WM_KEYUP() \
	{ WM_KEYUP, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnKeyUp },
#define ON_WM_CHAR() \
	{ WM_CHAR, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnChar },
#define ON_WM_DEADCHAR() \
	{ WM_DEADCHAR, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnDeadChar },
#define ON_WM_SYSKEYDOWN() \
	{ WM_SYSKEYDOWN, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnSysKeyDown },
#define ON_WM_SYSKEYUP() \
	{ WM_SYSKEYUP, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnSysKeyUp },
#define ON_WM_SYSCHAR() \
	{ WM_SYSCHAR, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnSysChar },
#define ON_WM_SYSDEADCHAR() \
	{ WM_SYSDEADCHAR, 0, AfxSig_vwww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, UINT))OnSysDeadChar },
#define ON_WM_SYSCOMMAND() \
	{ WM_SYSCOMMAND, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM))OnSysCommand },
#define ON_WM_TIMER() \
	{ WM_TIMER, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT))OnTimer },
#define ON_WM_HSCROLL() \
	{ WM_HSCROLL, 0, AfxSig_vwwW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CScrollBar*))OnHScroll },
#define ON_WM_VSCROLL() \
	{ WM_VSCROLL, 0, AfxSig_vwwW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, CScrollBar*))OnVScroll },
#define ON_WM_INITMENU() \
	{ WM_INITMENU, 0, AfxSig_vM, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CMenu*))OnInitMenu },
#define ON_WM_INITMENUPOPUP() \
	{ WM_INITMENUPOPUP, 0, AfxSig_vMwb, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CMenu*, UINT, BOOL))OnInitMenuPopup },
#define ON_WM_MENUSELECT() \
	{ WM_MENUSELECT, 0, AfxSig_vwwh, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, UINT, HMENU))OnMenuSelect },
#define ON_WM_MENUCHAR() \
	{ WM_MENUCHAR, 0, AfxSig_lwwM, \
		(AFX_PMSG)(AFX_PMSGW)(LRESULT (AFX_MSG_CALL CWnd::*)(UINT, UINT, CMenu*))OnMenuChar },
#define ON_WM_ENTERIDLE() \
	{ WM_ENTERIDLE, 0, AfxSig_vwW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CWnd*))OnEnterIdle },
#define ON_WM_MOUSEMOVE() \
	{ WM_MOUSEMOVE, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnMouseMove },
#define ON_WM_LBUTTONDOWN() \
	{ WM_LBUTTONDOWN, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnLButtonDown },
#define ON_WM_LBUTTONUP() \
	{ WM_LBUTTONUP, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnLButtonUp },
#define ON_WM_LBUTTONDBLCLK() \
	{ WM_LBUTTONDBLCLK, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnLButtonDblClk },
#define ON_WM_RBUTTONDOWN() \
	{ WM_RBUTTONDOWN, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnRButtonDown },
#define ON_WM_RBUTTONUP() \
	{ WM_RBUTTONUP, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnRButtonUp },
#define ON_WM_RBUTTONDBLCLK() \
	{ WM_RBUTTONDBLCLK, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnRButtonDblClk },
#define ON_WM_MBUTTONDOWN() \
	{ WM_MBUTTONDOWN, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnMButtonDown },
#define ON_WM_MBUTTONUP() \
	{ WM_MBUTTONUP, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnMButtonUp },
#define ON_WM_MBUTTONDBLCLK() \
	{ WM_MBUTTONDBLCLK, 0, AfxSig_vwp, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, CPoint))OnMButtonDblClk },
#define ON_WM_PARENTNOTIFY() \
	{ WM_PARENTNOTIFY, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, LPARAM))OnParentNotify },
#define ON_WM_MDIACTIVATE() \
	{ WM_MDIACTIVATE, 0, AfxSig_vbWW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(BOOL, CWnd*, CWnd*))OnMDIActivate },
#define ON_WM_RENDERFORMAT() \
	{ WM_RENDERFORMAT, 0, AfxSig_vw, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT))OnRenderFormat },
#define ON_WM_RENDERALLFORMATS() \
	{ WM_RENDERALLFORMATS, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnRenderAllFormats },
#define ON_WM_DESTROYCLIPBOARD() \
	{ WM_DESTROYCLIPBOARD, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnDestroyClipboard },
#define ON_WM_DRAWCLIPBOARD() \
	{ WM_DRAWCLIPBOARD, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(void))OnDrawClipboard },
#define ON_WM_PAINTCLIPBOARD() \
	{ WM_PAINTCLIPBOARD, 0, AfxSig_vWh, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, HGLOBAL))OnPaintClipboard },
#define ON_WM_VSCROLLCLIPBOARD() \
	{ WM_VSCROLLCLIPBOARD, 0, AfxSig_vWww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT))OnVScrollClipboard },
#define ON_WM_SIZECLIPBOARD() \
	{ WM_SIZECLIPBOARD, 0, AfxSig_vWh, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, HGLOBAL))OnSizeClipboard },
#define ON_WM_ASKCBFORMATNAME() \
	{ WM_ASKCBFORMATNAME, 0, AfxSig_vwl, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(UINT, LPSTR))OnAskCbFormatName },
#define ON_WM_CHANGECBCHAIN() \
	{ WM_CHANGECBCHAIN, 0, AfxSig_vhh, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(HWND, HWND))OnChangeCbChain },
#define ON_WM_HSCROLLCLIPBOARD() \
	{ WM_HSCROLLCLIPBOARD, 0, AfxSig_vWww, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*, UINT, UINT))OnHScrollClipboard },
#define ON_WM_QUERYNEWPALETTE() \
	{ WM_QUERYNEWPALETTE, 0, AfxSig_bv, \
		(AFX_PMSG)(AFX_PMSGW)(BOOL (AFX_MSG_CALL CWnd::*)(void))OnQueryNewPalette },
#define ON_WM_PALETTECHANGED() \
	{ WM_PALETTECHANGED, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*))OnPaletteChanged },

#if (WINVER >= 0x030a)
#define ON_WM_PALETTEISCHANGING() \
	{ WM_PALETTEISCHANGING, 0, AfxSig_vW, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(CWnd*))OnPaletteIsChanging },
#define ON_WM_DROPFILES() \
	{ WM_DROPFILES, 0, AfxSig_vh, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(HDROP))OnDropFiles },
#define ON_WM_WINDOWPOSCHANGING() \
	{ WM_WINDOWPOSCHANGING, 0, AfxSig_vPOS, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(WINDOWPOS FAR*))OnWindowPosChanging },
#define ON_WM_WINDOWPOSCHANGED() \
	{ WM_WINDOWPOSCHANGED, 0, AfxSig_vPOS, \
		(AFX_PMSG)(AFX_PMSGW)(void (AFX_MSG_CALL CWnd::*)(WINDOWPOS FAR*))OnWindowPosChanged },
#endif

/////////////////////////////////////////////////////////////////////////////
// Message map tables for Control Notification messages

// Edit Control Notification Codes
#define ON_EN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(EN_SETFOCUS, id, memberFxn)
#define ON_EN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(EN_KILLFOCUS, id, memberFxn)
#define ON_EN_CHANGE(id, memberFxn) \
	ON_CONTROL(EN_CHANGE, id, memberFxn)
#define ON_EN_UPDATE(id, memberFxn) \
	ON_CONTROL(EN_UPDATE, id, memberFxn)
#define ON_EN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(EN_ERRSPACE, id, memberFxn)
#define ON_EN_MAXTEXT(id, memberFxn) \
	ON_CONTROL(EN_MAXTEXT, id, memberFxn)
#define ON_EN_HSCROLL(id, memberFxn) \
	ON_CONTROL(EN_HSCROLL, id, memberFxn)
#define ON_EN_VSCROLL(id, memberFxn) \
	ON_CONTROL(EN_VSCROLL, id, memberFxn)

// User Button Notification Codes
#define ON_BN_CLICKED(id, memberFxn) \
	ON_CONTROL(BN_CLICKED, id, memberFxn)
#define ON_BN_DOUBLECLICKED(id, memberFxn) \
	ON_CONTROL(BN_DOUBLECLICKED, id, memberFxn)

#if (WINVER < 0x030a)
// old BS_USERBUTTON button notifications - obsolete in Win31
#define ON_BN_PAINT(id, memberFxn) \
	ON_CONTROL(BN_PAINT, id, memberFxn)
#define ON_BN_HILITE(id, memberFxn) \
	ON_CONTROL(BN_HILITE, id, memberFxn)
#define ON_BN_UNHILITE(id, memberFxn) \
	ON_CONTROL(BN_UNHILITE, id, memberFxn)
#define ON_BN_DISABLE(id, memberFxn) \
	ON_CONTROL(BN_DISABLE, id, memberFxn)
#endif

// Listbox Notification Codes
#define ON_LBN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(LBN_ERRSPACE, id, memberFxn)
#define ON_LBN_SELCHANGE(id, memberFxn) \
	ON_CONTROL(LBN_SELCHANGE, id, memberFxn)
#define ON_LBN_DBLCLK(id, memberFxn) \
	ON_CONTROL(LBN_DBLCLK, id, memberFxn)
#define ON_LBN_SELCANCEL(id, memberFxn) \
	ON_CONTROL(LBN_SELCANCEL, id, memberFxn)
#define ON_LBN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(LBN_SETFOCUS, id, memberFxn)
#define ON_LBN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(LBN_KILLFOCUS, id, memberFxn)

// Combo Box Notification Codes
#define ON_CBN_ERRSPACE(id, memberFxn) \
	ON_CONTROL(CBN_ERRSPACE, id, memberFxn)
#define ON_CBN_SELCHANGE(id, memberFxn) \
	ON_CONTROL(CBN_SELCHANGE, id, memberFxn)
#define ON_CBN_DBLCLK(id, memberFxn) \
	ON_CONTROL(CBN_DBLCLK, id, memberFxn)
#define ON_CBN_SETFOCUS(id, memberFxn) \
	ON_CONTROL(CBN_SETFOCUS, id, memberFxn)
#define ON_CBN_KILLFOCUS(id, memberFxn) \
	ON_CONTROL(CBN_KILLFOCUS, id, memberFxn)
#define ON_CBN_EDITCHANGE(id, memberFxn) \
	ON_CONTROL(CBN_EDITCHANGE, id, memberFxn)
#define ON_CBN_EDITUPDATE(id, memberFxn) \
	ON_CONTROL(CBN_EDITUPDATE, id, memberFxn)
#define ON_CBN_DROPDOWN(id, memberFxn) \
	ON_CONTROL(CBN_DROPDOWN, id, memberFxn)
#if (WINVER >= 0x030a)
#define ON_CBN_CLOSEUP(id, memberFxn)  \
	ON_CONTROL(CBN_CLOSEUP, id, memberFxn)
#define ON_CBN_SELENDOK(id, memberFxn)  \
	ON_CONTROL(CBN_SELENDOK, id, memberFxn)
#define ON_CBN_SELENDCANCEL(id, memberFxn)  \
	ON_CONTROL(CBN_SELENDCANCEL, id, memberFxn)
#endif

/////////////////////////////////////////////////////////////////////////////
// User extensions for message map entries

// for Windows messages
#define ON_MESSAGE(message, memberFxn) \
	{ message, 0, AfxSig_lwl, \
		(AFX_PMSG)(AFX_PMSGW)(LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM))memberFxn },

// for Registered Windows messages
#define ON_REGISTERED_MESSAGE(nMessageVariable, memberFxn) \
	{ 0xC000, 0, (UINT)(UINT NEAR*)(&nMessageVariable), \
		/*implied 'AfxSig_lwl'*/ \
		(AFX_PMSG)(AFX_PMSGW)(LRESULT (AFX_MSG_CALL CWnd::*)(WPARAM, LPARAM))memberFxn },

/////////////////////////////////////////////////////////////////////////////
// Routed VBX Event message

// for VBX control events
#define ON_VBXEVENT(wNotifyCode, id, memberFxn) \
	{ 0xC001, id, &wNotifyCode, \
		(AFX_PMSG)(void (AFX_MSG_CALL CCmdTarget::*)(UINT, int, CWnd*, LPVOID))memberFxn },

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxodlgs.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef __AFXODLGS_H__
#define __AFXODLGS_H__

#ifdef _AFXCTL
#error illegal file inclusion
#endif

#ifndef __AFXOLE_H__
#include <afxole.h>
#endif

// include OLE 2.0 dialog/helper APIs
#include <ole2ui.h>

/////////////////////////////////////////////////////////////////////////////
// AFXODLGS.H - MFC OLE dialogs

// Classes declared in this file

//CDialog
	class COleDialog;                   // base class for OLE dialog wrappers
		class COleInsertDialog;         // insert object dialog
		class COleConvertDialog;        // convert dialog
		class COleChangeIconDialog;     // change icon dialog
		class COlePasteSpecialDialog;   // paste special dialog
		class COleLinksDialog;          // edit links dialog
			class COleUpdateDialog;     // update links/embeddings dialog
		class COleBusyDialog;           // used for

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFXAPP_DATA
#define AFXAPP_DATA     AFXAPIEX_DATA

/////////////////////////////////////////////////////////////////////////////
// Wrappers for OLE UI dialogs

class COleDialog : public CDialog
{
	DECLARE_DYNAMIC(COleDialog)

// Attributes
public:
	UINT GetLastError() const;

// Implementation
public:
	int MapResult(UINT nResult);
	COleDialog(CWnd* pParentWnd);
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual void OnOK();
	virtual void OnCancel();

	UINT  m_nLastError;

protected:
	friend UINT CALLBACK AFX_EXPORT _AfxOleHookProc(HWND, UINT, WPARAM, LPARAM);
};

/////////////////////////////////////////////////////////////////////////////
// COleInsertDialog

class COleInsertDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleInsertDialog)

// Attributes
public:
	OLEUIINSERTOBJECT m_io; // structure for OleUIInsertObject

// Constructors
	COleInsertDialog(DWORD dwFlags = IOF_SELECTCREATENEW,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();
	BOOL CreateItem(COleClientItem* pItem);
		// call after DoModal to create item based on dialog data

// Attributes (after DoModal returns IDOK)
	enum Selection { createNewItem, insertFromFile, linkToFile };
	UINT GetSelectionType() const;
		// return type of selection made

	CString GetPathName() const;  // return full path name
	REFCLSID GetClassID() const;    // get class ID of new item

	DVASPECT GetDrawAspect() const;
		// DVASPECT_CONTENT or DVASPECT_ICON
	HGLOBAL GetIconicMetafile() const;
		// returns HGLOBAL to METAFILEPICT struct with iconic data

// Implementation
public:
	virtual ~COleInsertDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	char m_szFileName[OLEUI_CCHPATHMAX];
		// contains full path name after return
};

/////////////////////////////////////////////////////////////////////////////
// COleConvertDialog

class COleConvertDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleConvertDialog)

// Attributes
public:
	OLEUICONVERT m_cv;  // structure for OleUIConvert

// Constructors
	COleConvertDialog(COleClientItem* pItem,
		DWORD dwFlags = CF_SELECTCONVERTTO, CLSID FAR* pClassID = NULL,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();
		// just display the dialog and collect convert info
	BOOL DoConvert(COleClientItem* pItem);
		// do the conversion on pItem (after DoModal == IDOK)

// Attributes (after DoModal returns IDOK)
	enum Selection { noConversion, convertItem, activateAs };
	UINT GetSelectionType() const;

	HGLOBAL GetIconicMetafile() const;  // will return NULL if same as before
	REFCLSID GetClassID() const;    // get class ID to convert or activate as
	DVASPECT GetDrawAspect() const; // get new draw aspect

// Implementation
public:
	virtual ~COleConvertDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COleChangeIconDialog

class COleChangeIconDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleChangeIconDialog)

// Attributes
public:
	OLEUICHANGEICON m_ci;   // structure for OleUIChangeIcon

// Constructors
	COleChangeIconDialog(COleClientItem* pItem,
		DWORD dwFlags = CIF_SELECTCURRENT,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();
	BOOL DoChangeIcon(COleClientItem* pItem);

// Attributes
	HGLOBAL GetIconicMetafile() const;

// Implementation
public:
	virtual ~COleChangeIconDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// COlePasteSpecialDialog

class COlePasteSpecialDialog : public COleDialog
{
	DECLARE_DYNAMIC(COlePasteSpecialDialog)

// Attributes
public:
	OLEUIPASTESPECIAL m_ps; // structure for OleUIPasteSpecial

// Constructors
	COlePasteSpecialDialog(DWORD dwFlags = PSF_SELECTPASTE,
		COleDataObject* pDataObject = NULL, CWnd *pParentWnd = NULL);

// Operations
	OLEUIPASTEFLAG AddLinkEntry(UINT cf);
	void AddFormat(const FORMATETC& formatEtc, LPSTR lpstrFormat,
		LPSTR lpstrResult, DWORD flags);
	void AddFormat(UINT cf, DWORD tymed, UINT nFormatID, BOOL bEnableIcon,
		BOOL bLink);
	void AddStandardFormats(BOOL bEnableLink = TRUE);

	virtual int DoModal();
	BOOL CreateItem(COleClientItem *pNewItem);
		// creates a standard OLE item from selection data

// Attributes (after DoModal returns IDOK)
	int GetPasteIndex() const;      // resulting index to use for paste

	enum Selection { pasteLink = 1, pasteNormal = 2, pasteStatic = 3, pasteOther = 4};
	UINT GetSelectionType() const;
		// get selection type (pasteLink, pasteNormal, pasteStatic)

	DVASPECT GetDrawAspect() const;
		// DVASPECT_CONTENT or DVASPECT_ICON
	HGLOBAL GetIconicMetafile() const;
		// returns HGLOBAL to METAFILEPICT struct with iconic data

// Implementation
public:
	virtual ~COlePasteSpecialDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
	unsigned int m_arrLinkTypes[8];
		// size limit imposed by MFCOLEUI library
};

/////////////////////////////////////////////////////////////////////////////
// COleLinksDialog

class COleLinksDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleLinksDialog)

// Attributes
public:
	OLEUIEDITLINKS m_el;    // structure for OleUIEditLinks

// Constructors
	COleLinksDialog(COleDocument* pDoc, CView* pView, DWORD dwFlags = 0,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();  // display the dialog and edit links

// Implementation
public:
	virtual ~COleLinksDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif

protected:
	COleDocument* m_pDocument;          // document being manipulated
	COleClientItem* m_pSelectedItem;    // primary selected item in m_pDocument
	POSITION m_pos;                     // used during link enumeration
	BOOL m_bUpdateLinks;                // update links?
	BOOL m_bUpdateEmbeddings;           // update embeddings?

// Interface Maps
	BEGIN_INTERFACE_PART(OleUILinkContainer, IOleUILinkContainer)
		STDMETHOD_(DWORD,GetNextLink)(DWORD);
		STDMETHOD(SetLinkUpdateOptions)(DWORD, DWORD);
		STDMETHOD(GetLinkUpdateOptions)(DWORD, LPDWORD);
		STDMETHOD(SetLinkSource)(DWORD, LPSTR, ULONG, ULONG FAR*, BOOL);
		STDMETHOD(GetLinkSource)(DWORD, LPSTR FAR*, ULONG FAR*,
			LPSTR FAR*, LPSTR FAR*, BOOL FAR*, BOOL FAR*);
		STDMETHOD(OpenLinkSource)(DWORD);
		STDMETHOD(UpdateLink)(DWORD, BOOL, BOOL);
		STDMETHOD(CancelLink)(DWORD);
	END_INTERFACE_PART(OleUILinkContainer)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleUpdateDialog

class COleUpdateDialog : public COleLinksDialog
{
	DECLARE_DYNAMIC(COleUpdateDialog)

// Constructors
public:
	COleUpdateDialog(COleDocument* pDoc,
		BOOL bUpdateLinks = TRUE, BOOL bUpdateEmbeddings = FALSE,
		CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();

// Implementation
public:
	virtual ~COleUpdateDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CString m_strCaption;   // caption for the dialog
};

/////////////////////////////////////////////////////////////////////////////
// COleBusyDialog - useful in managing concurrency

class COleBusyDialog : public COleDialog
{
	DECLARE_DYNAMIC(COleBusyDialog)

// Attributes
public:
	OLEUIBUSY m_bz;

// Constructors
	COleBusyDialog(HTASK htaskBusy, BOOL bNotResponding = FALSE,
		DWORD dwFlags = 0, CWnd* pParentWnd = NULL);

// Operations
	virtual int DoModal();

	enum Selection { switchTo = 1, retry = 2, callUnblocked = 3 };
	UINT GetSelectionType() const;

// Implementation
public:
	~COleBusyDialog();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	Selection m_selection;  // selection after DoModal returns IDOK
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXODLGS_INLINE inline
#include <afxole.inl>
#undef _AFXODLGS_INLINE
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

#endif //__AFXODLGS_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\sdktools\msvc15\mfc\include\afxole.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#ifndef __AFXOLE_H__
#define __AFXOLE_H__

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#ifndef __AFXDISP_H__
#include <afxdisp.h>
#endif

// include OLE 2.0 Compound Document interfaces
#define FARSTRUCT
#include <ole2.h>

/////////////////////////////////////////////////////////////////////////////
// AFXOLE.H - MFC OLE support

// Classes declared in this file

//CDocument
	class COleDocument;             // OLE container document
		class COleLinkingDoc;       // supports links to embeddings
			class COleServerDoc;    // OLE server document

//CCmdTarget
	class CDocItem;                 // part of a document
		class COleClientItem;       // embedded ole object from outside
		class COleServerItem;       // ole object to export
	class COleDataSource;           // clipboard data source mechanism
	class COleDropSource;           // drag/drop source
	class COleDropTarget;           // drag/drop target
	class COleMessageFilter;        // concurrency management

//CFrameWnd
	class COleIPFrameWnd;           // frame window for in-place servers

//CControlBar
	class COleResizeBar;            // implements in-place resizing

//CFile
	class COleStreamFile;           // CFile wrapper for IStream interface

class COleDataObject;               // wrapper for IDataObject interface

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFXAPP_DATA
#define AFXAPP_DATA     AFXAPIEX_DATA

/////////////////////////////////////////////////////////////////////////////
// backward compatibility

// COleClientDoc is now obsolete -- use COleDocument instead
#define COleClientDoc COleDocument

// COleServer has been replaced by the more general COleObjectFactory
#define COleServer  COleObjectFactory

/////////////////////////////////////////////////////////////////////////////
// Useful OLE specific types (some from OLE 1.0 headers)

// Codes for CallBack events
enum OLE_NOTIFICATION
{
	OLE_CHANGED,        // representation of a draw aspect has changed
	OLE_SAVED,          // the item has committed its storage
	OLE_CLOSED,         // the item has closed
	OLE_RENAMED,        // the item has changed its moniker
	OLE_CHANGED_STATE,  // the item state (open, active, etc.) has changed
	OLE_CHANGED_ASPECT, // the item draw aspect has changed
};

// Object types
enum OLE_OBJTYPE
{
	OT_UNKNOWN = 0,

	// These are OLE 1.0 types and OLE 2.0 types as returned from GetType().
	OT_LINK = 1,
	OT_EMBEDDED = 2,
	OT_STATIC = 3,

	// All OLE2 objects are written with this tag when serialized.  This
	//  differentiates them from OLE 1.0 objects written with MFC 2.0.
	//  This value will never be returned from GetType().
	OT_OLE2 = 256,
};

/////////////////////////////////////////////////////////////////////////////
// COleDataObject -- simple wrapper for IDataObject

class COleDataObject
{
// Constructors
public:
	COleDataObject();

// Operations
	void Attach(LPDATAOBJECT lpDataObject, BOOL bAutoRelease = TRUE);
	LPDATAOBJECT Detach();  // detach and get ownership of m_lpDataObject
	void Release(); // detach and Release ownership of m_lpDataObject
	BOOL AttachClipboard(); // attach to current clipboard object

// Attributes
	void BeginEnumFormats();
	BOOL GetNextFormat(LPFORMATETC lpFormatEtc);
	CFile* GetFileData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	HGLOBAL GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	BOOL GetData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);
	BOOL IsDataAvailable(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Implementation
public:
	LPDATAOBJECT m_lpDataObject;
	LPENUMFORMATETC m_lpEnumerator;
	~COleDataObject();

protected:
	BOOL m_bAutoRelease;    // TRUE if destructor should call Release

private:
	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
	COleDataObject(const COleDataObject&);  // no implementation
	void operator=(const COleDataObject&);  // no implementation
};

/////////////////////////////////////////////////////////////////////////////
// COleDataSource -- wrapper for implementing IDataObject
//  (works similar to how data is provided on the clipboard)

struct AFX_DATACACHE_ENTRY;
class COleDropSource;

class COleDataSource : public CCmdTarget
{
// Constructors
public:
	COleDataSource();

// Operations
	void Empty();   // empty cache (similar to ::EmptyClipboard)

	// CacheData & DelayRenderData operations similar to ::SetClipboardData
	void CacheGlobalData(CLIPFORMAT cfFormat, HGLOBAL hGlobal,
		LPFORMATETC lpFormatEtc = NULL);    // for HGLOBAL based data
	void DelayRenderFileData(CLIPFORMAT cfFormat,
		LPFORMATETC lpFormatEtc = NULL);    // for CFile* based delayed render

	// Clipboard and Drag/Drop access
	DROPEFFECT DoDragDrop(
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE|DROPEFFECT_LINK,
		LPCRECT lpRectStartDrag = NULL,
		COleDropSource* pDropSource = NULL);
	void SetClipboard();
	static void PASCAL FlushClipboard();
	static COleDataSource* PASCAL GetClipboardOwner();

	// Advanced: STGMEDIUM based cached data
	void CacheData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);    // for LPSTGMEDIUM based data
	// Advanced: STGMEDIUM or HGLOBAL based delayed render
	void DelayRenderData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

	// Advanced: support for SetData in COleServerItem
	//  (not generally useful for clipboard or drag/drop operations)
	void DelaySetData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Overidables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// OnRenderFileData and OnRenderGlobalData are called by
		//  the default implementation of OnRenderData.

#ifdef _AFXCTL
	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium,
		BOOL fRelease);
#else
	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// used only in COleServerItem implementation
#endif

// Implementation
public:
	virtual ~COleDataSource();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	AFX_DATACACHE_ENTRY* m_pDataCache;  // data cache itself
	UINT m_nMaxSize;    // current allocated size
	UINT m_nSize;       // current size of the cache
	UINT m_nGrowBy;     // number of cache elements to grow by for new allocs

	AFX_DATACACHE_ENTRY* Lookup(LPFORMATETC lpFormatEtc,
		DATADIR dataDir) const;
	AFX_DATACACHE_ENTRY* AllocSpace();

// Interface Maps
public:
	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC FAR*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA FAR*);
	END_INTERFACE_PART(DataObject)

	DECLARE_INTERFACE_MAP()

	friend class COleServerItem;
};

//////////////////////////////////////////////////////////////////////////////
// DocItem support

class CDocItem : public CCmdTarget
{
	DECLARE_SERIAL(CDocItem)

// Constructors
protected:      // abstract class
	CDocItem();

// Attributes
public:
	CDocument* GetDocument() const; // return container document

// Overridables
public:
	// Raw data access (native format)
	virtual BOOL IsBlank() const;

// Implementation
protected:
	COleDocument* m_pDocument;

public:
	virtual void Serialize(CArchive& ar);   // for Native data
	virtual ~CDocItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	friend class COleDocument;              // for access to back pointer
};

//////////////////////////////////////////////////////////////////////////////
// COleDocument - common OLE container behavior (enables server functionality)

class COleDocument : public CDocument
{
	DECLARE_DYNAMIC(COleDocument)

// Constructors
public:
	COleDocument();

// Attributes
	BOOL HasBlankItems() const; // check for BLANK items
	COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
		// return in-place active item for this view or NULL if none

// Operations
	// iterating over existing items
	virtual POSITION GetStartPosition() const;
	virtual CDocItem* GetNextItem(POSITION& pos) const;

	// iterator helpers (helpers use virtual GetNextItem above)
	COleClientItem* GetNextClientItem(POSITION& pos) const;
	COleServerItem* GetNextServerItem(POSITION& pos) const;

	// adding new items - called from item constructors
	virtual void AddItem(CDocItem* pItem);
	virtual void RemoveItem(CDocItem* pItem);

	void EnableCompoundFile(BOOL bEnable = TRUE);
		// enable compound file support (only call during constructor)
	void UpdateModifiedFlag();
		// scan for modified items -- mark document modified

	// printer-device caching/control
	BOOL ApplyPrintDevice(const DVTARGETDEVICE FAR* ptd);
	BOOL ApplyPrintDevice(const PRINTDLG* ppd);
		// these apply the target device to all COleClientItem objects

// Overridables
	virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
		// return primary selected item or NULL if none
	virtual void OnShowViews(BOOL bVisible);
		// called during app-idle when visibility of a document has changed

// Implementation
public:
	CObList m_docItemList;  // not owned items

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	CFrameWnd* GetFirstFrame();

	// document handling overrides
	virtual void SetPathName(const char* pszPathName, BOOL bAddToMRU = TRUE);
	virtual ~COleDocument();
	virtual void DeleteContents(); // delete client items in list
	virtual void Serialize(CArchive& ar);   // serialize items to file
	virtual void PreCloseFrame(CFrameWnd* pFrame);
	virtual BOOL SaveModified();
	virtual void OnIdle();

	// compound file implementation
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(const char* pszPathName);
	virtual BOOL OnSaveDocument(const char* pszPathName);
	virtual void OnCloseDocument();
	void CommitItems(BOOL bSuccess);    // called during File.Save & File.Save As

	// minimal linking protocol
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);
	virtual LPOLEITEMCONTAINER GetContainer();

protected:
	DWORD m_dwNextItemNumber;   // serial number for next item in this document
	BOOL m_bLastVisible;    // TRUE if one or more views was last visible

	// 'docfile' support
	BOOL m_bCompoundFile;   // TRUE if use compound files
	LPSTORAGE m_lpRootStg;  // root storage for the document
	BOOL m_bSameAsLoad;     // TRUE = file-save, FALSE = Save [Copy] As
	BOOL m_bRemember;       // if FALSE, indicates Save Copy As

	DVTARGETDEVICE FAR* m_ptd;  // current document target device

	// implementation helpers
	virtual void LoadFromStorage();
	virtual void SaveToStorage(CObject* pObject = NULL);
	CDocItem* GetNextItemOfKind(POSITION& pos, CRuntimeClass* pClass) const;

	// command handling
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	afx_msg void OnUpdatePasteMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdatePasteLinkMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditLinksMenu(CCmdUI* pCmdUI);
	afx_msg void OnEditLinks();
	afx_msg void OnEditConvert();
	afx_msg void OnUpdateEditChangeIcon(CCmdUI* pCmdUI);
	afx_msg void OnEditChangeIcon();
	afx_msg void OnUpdateObjectVerbMenu(CCmdUI* pCmdUI);
	afx_msg void OnFileSendMail();

	friend class COleClientItem;
	friend class COleServerItem;
};

/////////////////////////////////////////////////////////////////////////////
// COleClientItem - Supports OLE2 non-inplace editing.
//      implements IOleClientSite, IAdviseSink, and IOleInPlaceSite

class COleFrameHook;    // special implementation class

class COleClientItem : public CDocItem
{
	DECLARE_DYNAMIC(COleClientItem)

// Constructors
public:
	COleClientItem(COleDocument* pContainerDoc = NULL);

	// create from the clipboard
	BOOL CreateFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateStaticFromClipboard(OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from a class ID (Insert New Object dialog)
	BOOL CreateNewItem(REFCLSID clsid, OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from COleDataObject
	BOOL CreateFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateStaticFromData(COleDataObject* pDataObject,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create from file (package support)
	BOOL CreateFromFile(LPCSTR lpszFileName, REFCLSID clsid = CLSID_NULL,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);
	BOOL CreateLinkFromFile(LPCSTR lpszFileName,
		OLERENDER render = OLERENDER_DRAW,
		CLIPFORMAT cfFormat = 0, LPFORMATETC lpFormatEtc = NULL);

	// create a copy
	BOOL CreateCloneFrom(COleClientItem* pSrcItem);

// General Attributes
public:
	SCODE GetLastStatus() const;
	OLE_OBJTYPE GetType() const; // OT_LINK, OT_EMBEDDED, OT_STATIC
	void GetClassID(CLSID FAR* pClassID) const;
	void GetUserType(USERCLASSTYPE nUserClassType, CString& rString);
	BOOL GetExtent(LPSIZE lpSize, DVASPECT nDrawAspect = (DVASPECT)-1);
		// will return FALSE if item is BLANK

	HGLOBAL GetIconicMetafile();
	BOOL SetIconicMetafile(HGLOBAL hMetaPict);
		// getting/setting iconic cache

	DVASPECT GetDrawAspect() const;
	void SetDrawAspect(DVASPECT nDrawAspect);
		// setting/getting default display aspect

	// for printer presentation cache
	BOOL SetPrintDevice(const DVTARGETDEVICE FAR* ptd);
	BOOL SetPrintDevice(const PRINTDLG* ppd);

	// Item state
	enum ItemState
		{ emptyState, loadedState, openState, activeState, activeUIState };
	UINT GetItemState() const;

	BOOL IsModified() const;
	BOOL IsRunning() const;
	BOOL IsInPlaceActive() const;
	BOOL IsOpen() const;
	CView* GetActiveView() const;

	// Data access
	void AttachDataObject(COleDataObject& rDataObject) const;

	// other rare access information
	COleDocument* GetDocument() const; // return container

	// helpers for checking clipboard data availability
	static BOOL PASCAL CanPaste();
	static BOOL PASCAL CanPasteLink();

	// helpers for checking COleDataObject, useful in drag drop
	static BOOL PASCAL CanCreateFromData(const COleDataObject* pDataObject);
	static BOOL PASCAL CanCreateLinkFromData(const COleDataObject* pDataObject);

// General Operations
	virtual void Release(OLECLOSE dwCloseOption = OLECLOSE_NOSAVE);
		// cleanup, detach (close if needed)
	void Close(OLECLOSE dwCloseOption = OLECLOSE_SAVEIFDIRTY);
		// close without releasing the item
	void Delete(BOOL bAutoDelete = TRUE);
		// logically delete from file -- not part of the document anymore
	void Run(); // insure item is in running state

	// Drawing
	BOOL Draw(CDC* pDC, LPCRECT lpBounds,
		DVASPECT nDrawAspect = (DVASPECT)-1);   // defaults to m_nDrawAspect

	// Activation
	virtual BOOL DoVerb(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);
	void Activate(LONG nVerb, CView* pView, LPMSG lpMsg = NULL);

	// In-place Activation
	void Deactivate();          // completely deactivate
	void DeactivateUI();        // deactivate the user interface
	BOOL ReactivateAndUndo();   // reactivate then perform undo command
	BOOL SetItemRects(LPCRECT lpPosRect = NULL, LPCRECT lpClipRect = NULL);
	CWnd* GetInPlaceWindow();

	// Clipboard operations
	void CopyToClipboard(BOOL bIncludeLink = FALSE);
	DROPEFFECT DoDragDrop(LPCRECT lpItemRect, CPoint ptOffset,
		BOOL bIncludeLink = FALSE,
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE,
		LPCRECT lpRectStartDrag = NULL);
	void GetClipboardData(COleDataSource* pDataSource,
		BOOL bIncludeLink = FALSE, LPPOINT lpOffset = NULL,
		LPSIZE lpSize = NULL);

	// called for creating a COleDataSource by CopyToClipboard and DoDragDrop
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);

	// Operations that apply to embedded items only
	void SetHostNames(LPCSTR lpszHost, LPCSTR lpszHostObj);
	void SetExtent(const CSize& size, DVASPECT nDrawAspect = DVASPECT_CONTENT);

	// Operations that apply to linked items only
	//  (link options are rarely changed, except through Links dialog)
	OLEUPDATE GetLinkUpdateOptions();
	void SetLinkUpdateOptions(OLEUPDATE dwUpdateOpt);

	// Link-source update status (also useful for embeddings that contain links)
	BOOL UpdateLink();  // make up-to-date
	BOOL IsLinkUpToDate() const;    // is link up-to-date

	// object conversion
	BOOL ConvertTo(REFCLSID clsidNew);
	BOOL ActivateAs(LPCSTR lpszUserType, REFCLSID clsidOld, REFCLSID clsidNew);
	BOOL Reload();  // for lazy reload after ActivateAs

// Overridables (notifications of IAdviseSink, IOleClientSite and IOleInPlaceSite)
	// Callbacks/notifications from the server you must/should implement
	virtual void OnChange(OLE_NOTIFICATION nCode, DWORD dwParam);
		// implement OnChange to invalidate when item changes

protected:
	virtual void OnGetItemPosition(CRect& rPosition);
		// implement OnGetItemPosition if you support in-place activation

	// Common overrides for in-place activation
	virtual BOOL OnScrollBy(CSize sizeExtent);

protected:
	// Common overrides for applications supporting undo
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual void OnDiscardUndoState();
	virtual void OnDeactivateAndUndo();

	// Common overrides for applications supporting links to embeddings
	virtual void OnShowItem();

	// Advanced overrides for in-place activation
	virtual void OnGetClipRect(CRect& rClipRect);
	virtual BOOL CanActivate();
	virtual void OnActivate();
	virtual void OnActivateUI();
	virtual BOOL OnGetWindowContext(CFrameWnd** ppMainFrame,
		CFrameWnd** ppDocFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	virtual void OnDeactivate();
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
		// default calls SetItemRects and caches the pos rect

public:
	// Advanced overrides for menu/title handling (rarely overridden)
	virtual void OnInsertMenus(CMenu* pMenuShared,
		LPOLEMENUGROUPWIDTHS lpMenuWidths);
	virtual void OnSetMenu(CMenu* pMenuShared, HOLEMENU holemenu,
		HWND hwndActiveObject);
	virtual void OnRemoveMenus(CMenu* pMenuShared);
	virtual void OnUpdateFrameTitle();

	// Advanced override for control bar handling
	virtual BOOL OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow);

// Implementation
public:
	// data to support non-inplace activated items
	LPOLEOBJECT m_lpObject; // in case you want direct access to the OLE object
	DWORD m_dwItemNumber;   // serial number for this item in this document
	DVASPECT m_nDrawAspect; // current default display aspect
	SCODE m_scLast;         // last error code encountered
	LPSTORAGE m_lpStorage;  // provides storage for m_lpObject
	LPLOCKBYTES m_lpLockBytes;  // part of implementation of m_lpStorage
	DWORD m_dwConnection;   // advise connection to the m_lpObject
	BYTE m_bLinkUnavail;    // TRUE if link is currently unavailable
	BYTE m_bMoniker;        // TRUE if moniker is assigned
	BYTE m_bLocked;         // TRUE if object has external lock
	BYTE m_bNeedCommit;     // TRUE if need CommitItem
	BYTE m_bClosing;        // TRUE if currently doing COleClientItem::Close
	BYTE m_bReserved;       // (reserved for future use)

	// for compound file support
	LPSTORAGE m_lpNewStorage;   // used during Save As situations

	// item state & item type
	ItemState m_nItemState; // item state (see ItemState enumeration)
	OLE_OBJTYPE m_nItemType;    // item type (depends on how created)

	// data valid when in-place activated
	CView* m_pView; // view when object is in-place activated
	DWORD m_dwContainerStyle;   // style of the container wnd before activation
	COleFrameHook* m_pInPlaceFrame;// frame window when in-place active
	COleFrameHook* m_pInPlaceDoc;   // doc window when in-place (may be NULL)
	HWND m_hWndServer;  // HWND of in-place server window

public:
	virtual ~COleClientItem();
	virtual void Serialize(CArchive& ar);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Implementation
public:
	virtual BOOL ReportError(SCODE sc) const;
	virtual BOOL FreezeLink();  // converts to static: for edit links dialog

	DWORD GetNewItemNumber();   // generates new item number
	void GetItemName(char* pszItemName) const; // gets readable item name

	void UpdateItemType();  // update m_nItemType

protected:
	// clipboard helpers
	void GetEmbeddedItemData(LPSTGMEDIUM lpStgMedium);
	void AddCachedData(COleDataSource* pDataSource);
	BOOL GetLinkSourceData(LPSTGMEDIUM lpStgMedium);
	void GetObjectDescriptorData(LPPOINT lpOffset, LPSIZE lpSize,
		LPSTGMEDIUM lpStgMedium);

	// interface helpers
	LPOLECLIENTSITE GetClientSite();

	// helpers for printer-cached representation
	BOOL GetPrintDeviceInfo(LPOLECACHE* plpOleCache,
		DVTARGETDEVICE FAR** pptd, DWORD* pdwConnection);

// Advanced Overridables for implementation
protected:
	virtual BOOL FinishCreate(HRESULT hr);
	virtual void CheckGeneral(HRESULT hr);

	virtual void OnDataChange(LPFORMATETC lpFormatEtc,
		LPSTGMEDIUM lpStgMedium);

public:
	// for storage hookability (override to use 'docfiles')
	virtual void GetItemStorage();  // allocate storage for new item
	virtual void ReadItem(CArchive& ar);    // read item from archive
	virtual void WriteItem(CArchive& ar);   // write item to archive
	virtual void CommitItem(BOOL bSuccess); // commit item's storage

	// compound & flat file implementations of above
	void GetItemStorageFlat();
	void ReadItemFlat(CArchive& ar);
	void WriteItemFlat(CArchive& ar);
	void GetItemStorageCompound();
	void ReadItemCompound(CArchive& ar);
	void WriteItemCompound(CArchive& ar);

private:
	static CView* pActivateView;    // activation view

// Interface Maps
protected:
	BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
		STDMETHOD(SaveObject)();
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER FAR*);
		STDMETHOD(GetContainer)(LPOLECONTAINER FAR*);
		STDMETHOD(ShowObject)();
		STDMETHOD(OnShowWindow)(BOOL);
		STDMETHOD(RequestNewObjectLayout)();
	END_INTERFACE_PART(OleClientSite)

	BEGIN_INTERFACE_PART(AdviseSink, IAdviseSink)
		STDMETHOD_(void,OnDataChange)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD_(void,OnViewChange)(DWORD, LONG);
		STDMETHOD_(void,OnRename)(LPMONIKER);
		STDMETHOD_(void,OnSave)();
		STDMETHOD_(void,OnClose)();
	END_INTERFACE_PART(AdviseSink)

	BEGIN_INTERFACE_PART(OleIPSite, IOleInPlaceSite)
		STDMETHOD(GetWindow)(HWND FAR*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME FAR*,
			LPOLEINPLACEUIWINDOW FAR*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);
	END_INTERFACE_PART(OleIPSite)

	DECLARE_INTERFACE_MAP()

// Friendship declarations (to avoid many public members)
	friend class COleUIWindow;
	friend class COleFrameWindow;
	friend class COleLinkingDoc;
};

/////////////////////////////////////////////////////////////////////////////
// COleServerItem - IOleObject & IDataObject OLE component

class COleServerItem : public CDocItem
{
	DECLARE_DYNAMIC(COleServerItem)
protected:
	// NOTE: many members in this class are protected - since everything
	//   in this class is designed for implementing an OLE server.
	// Requests will come from OLE containers through non-C++ mechanisms,
	//   which will result in virtual functions in this class being called.

// Constructors
	COleServerItem(COleServerDoc* pServerDoc, BOOL bAutoDelete);
		// If your COleServerItem is an integral part of your data,
		//  bAutoDelete should be FALSE.  If your COleServerItem can be
		//  deleted when a link is released, it can be TRUE.

	COleDataSource* GetDataSource();
		// Use this data source to add conversion formats that your
		//  server should support.  Usually such formats are
		//  added in the item's constructor.

// Public Attributes
public:
	COleServerDoc* GetDocument() const; // return server document

	// naming (for links only)
	const CString& GetItemName() const; // get name of linked item
	void SetItemName(const char* pszItemName);  // set name of linked item

	// link state
	BOOL IsConnected() const;   // returns TRUE if item has a client
	BOOL IsLinkedItem() const;  // returns TRUE if item is not embedded item

	// extents
	CSize m_sizeExtent;
		// HIMETRIC size -- the default implementation of OnSetExtent
		//  updates this member variable.  This member tells the server how
		//  much of the object is visible in the container document.

// Operations
public:
	void NotifyChanged(DVASPECT nDrawAspect = DVASPECT_CONTENT);
		// call this after you change item
	void CopyToClipboard(BOOL bIncludeLink = FALSE);
		// helper for implementing server 'copy to clipboard'
	DROPEFFECT DoDragDrop(LPCRECT lpRectItem, CPoint ptOffset,
		BOOL bIncludeLink = FALSE,
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE,
		LPCRECT lpRectStartDrag = NULL);
	void GetClipboardData(COleDataSource* pDataSource,
		BOOL bIncludeLink = FALSE, LPPOINT lpOffset = NULL,
		LPSIZE lpSize = NULL);

// Overridables
	// overridables you must implement for yourself
	virtual BOOL OnDraw(CDC* pDC, CSize& rSize) = 0;
		// drawing for metafile format (return FALSE if not supported or error)
		//  (called for DVASPECT_CONTENT only)

	// overridables you may want to implement yourself
	virtual void OnUpdate(COleServerItem* pSender,
		LPARAM lHint, CObject* pHint, DVASPECT nDrawAspect);
		// the default implementation always calls NotifyChanged

	virtual BOOL OnDrawEx(CDC* pDC, DVASPECT nDrawAspect, CSize& rSize);
		// advanced drawing -- called for DVASPECT other than DVASPECT_CONTENT
	virtual BOOL OnSetExtent(DVASPECT nDrawAspect, const CSize& size);
	virtual BOOL OnGetExtent(DVASPECT nDrawAspect, CSize& rSize);
		// default implementation uses m_sizeExtent

	// overridables you do not have to implement
	virtual void OnDoVerb(LONG iVerb);
		// default routes to OnShow &/or OnOpen
	virtual BOOL OnSetColorScheme(const LOGPALETTE FAR* lpLogPalette);
		// default does nothing
	virtual COleDataSource* OnGetClipboardData(BOOL bIncludeLink,
		LPPOINT lpOffset, LPSIZE lpSize);
		// called for access to clipboard data
	virtual BOOL OnQueryUpdateItems();
		// called to determine if there are any contained out-of-date links
	virtual void OnUpdateItems();
		// called to update any out-of-date links

protected:
	virtual void OnShow();
		// show item in the user interface (may edit in-place)
	virtual void OnOpen();
		// show item in the user interface (must open fully)
	virtual void OnHide();
		// hide document (and sometimes application)

	// very advanced overridables
public:
	virtual BOOL OnInitFromData(COleDataObject* pDataObject, BOOL bCreation);
		// initialize object from IDataObject

	// see COleDataSource for a description of these overridables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// HGLOBAL version will be called first, then CFile* version

	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// Rare -- only if you support SetData (programmatic paste)

	// advanced helpers for CopyToClipboard
	void GetEmbedSourceData(LPSTGMEDIUM lpStgMedium);
	void AddOtherClipboardData(COleDataSource* pDataSource);
	BOOL GetLinkSourceData(LPSTGMEDIUM lpStgMedium);
	void GetObjectDescriptorData(LPPOINT lpOffset, LPSIZE lpSize,
		LPSTGMEDIUM lpStgMedium);

// Implementation
public:
	BOOL m_bNeedUnlock;             // if TRUE need to pDoc->LockExternal(FALSE)
	BOOL m_bAutoDelete;             // if TRUE will OnRelease will 'delete this'

	// special version of OnFinalRelease to implement document locking
	virtual void OnFinalRelease();

protected:
	CString m_strItemName;          // simple item name

public:
	LPOLEADVISEHOLDER m_lpOleAdviseHolder;  // may be NULL
	LPDATAADVISEHOLDER m_lpDataAdviseHolder;    // may be NULL

	virtual ~COleServerItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// implementation helpers
	void NotifyClient(OLE_NOTIFICATION wNotification, DWORD dwParam);
	LPDATAOBJECT GetDataObject();
	LPOLEOBJECT GetOleObject();

protected:
	virtual BOOL GetMetafileData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM pmedium);
		// calls OnDraw or OnDrawEx
	virtual void OnSaveEmbedding(LPSTORAGE lpStorage);
	virtual BOOL IsBlank() const;

	// CItemDataSource implements OnRender reflections to COleServerItem
	class CItemDataSource : public COleDataSource
	{
	protected:
		// the GetData and SetData interfaces forward to m_pItem
		virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);
		virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CFile* pFile);
		virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
			// HGLOBAL version will be called first, then CFile* version

		virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
			// HGLOBAL version will be called first, then CFile* version
	};
	CItemDataSource m_dataSource;
		// data source used to implement IDataObject

// Interface Maps
//  (Note: these interface maps are used just for link implementation)
public:
	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE FAR*);
		STDMETHOD(SetHostNames)(LPCSTR, LPCSTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER FAR*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT FAR*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB FAR* FAR*);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID FAR*);
		STDMETHOD(GetUserType)(DWORD, LPSTR FAR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA FAR*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC FAR*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA FAR*);
	END_INTERFACE_PART(DataObject)

	DECLARE_INTERFACE_MAP()

	friend class CItemDataSource;
	friend class COleServerDoc;
	friend class COleLinkingDoc;
};

/////////////////////////////////////////////////////////////////////////////
// COleLinkingDoc -
//  (enables linking to embeddings - beginnings of server fuctionality)

class COleLinkingDoc : public COleDocument
{
	DECLARE_DYNAMIC(COleLinkingDoc)

// Constructors
public:
	COleLinkingDoc();

// Operations
	BOOL Register(COleObjectFactory* pFactory, const char* pszPathName);
		// notify the running object table and connect to pServer
	void Revoke();
		// revoke from running object table

// Overridables
protected:
	virtual COleServerItem* OnGetLinkedItem(LPCSTR lpszItemName);
		// return item for the named linked item (for supporting links)
	virtual COleClientItem* OnFindEmbeddedItem(LPCSTR lpszItemName);
		// return item for the named embedded item (for links to embeddings)

// Implementation
public:
	COleObjectFactory* m_pFactory;  // back-pointer to server

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleLinkingDoc();

	// overrides for updating of monikers & running object table registration
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(const char* pszPathName);
	virtual BOOL OnSaveDocument(const char* pszPathName);
	virtual void OnCloseDocument();
	virtual LPOLEITEMCONTAINER GetContainer();
	virtual void OnShowViews(BOOL bVisible);

protected:
	DWORD m_dwRegister;     // file moniker's registration in the ROT
	BOOL m_bVisibleLock;    // TRUE if user is holding lock on document

	// implementation helpers
	void RegisterIfServerAttached(const char* pszPathName);
	void LockExternal(BOOL bLock, BOOL bRemoveRefs);
	void UpdateVisibleLock(BOOL bVisible, BOOL bRemoveRefs);

	virtual void SaveToStorage(CObject* pObject = NULL);

// Interface Maps
protected:
	BEGIN_INTERFACE_PART(PersistFile, IPersistFile)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(Load)(LPCSTR, DWORD);
		STDMETHOD(Save)(LPCSTR, BOOL);
		STDMETHOD(SaveCompleted)(LPCSTR);
		STDMETHOD(GetCurFile)(LPSTR FAR*);
	END_INTERFACE_PART(PersistFile)

	BEGIN_INTERFACE_PART(OleItemContainer, IOleItemContainer)
		STDMETHOD(ParseDisplayName)(LPBC, LPSTR, ULONG FAR*, LPMONIKER FAR*);
		STDMETHOD(EnumObjects)(DWORD, LPENUMUNKNOWN FAR*);
		STDMETHOD(LockContainer)(BOOL);
		STDMETHOD(GetObject)(LPSTR, DWORD, LPBINDCTX, REFIID, LPVOID FAR*);
		STDMETHOD(GetObjectStorage)(LPSTR, LPBINDCTX, REFIID, LPVOID FAR*);
		STDMETHOD(IsRunning)(LPSTR);
	END_INTERFACE_PART(OleItemContainer)

	DECLARE_INTERFACE_MAP()

	friend class COleClientItem;
	friend class COleClientItem::XOleClientSite;
	friend class COleServerItem::XOleObject;
};

//////////////////////////////////////////////////////////////////////////////
// COleServerDoc - registered server document containing COleServerItems

class COleServerDoc : public COleLinkingDoc
{
	DECLARE_DYNAMIC(COleServerDoc)

// Constructors and Destructors
public:
	COleServerDoc();

// Attributes
	BOOL IsEmbedded() const;    // TRUE if document is an embedding
	COleServerItem* GetEmbeddedItem();
		// return embedded item for document (will allocate if necessary)

	// attributes specific to in-place activation
	BOOL IsInPlaceActive() const;
	void GetItemPosition(LPRECT lpPosRect) const;
		// get current position rectangle of in-place edit
	void GetItemClipRect(LPRECT lpClipRect) const;
		// get current clipping rectangle of in-place edit
	BOOL GetZoomFactor(LPSIZE lpSizeNum = NULL, LPSIZE lpSizeDenom = NULL,
		LPCRECT lpPosRect = NULL) const;
		// returns the zoom factor in pixels

// Operations
	void NotifyChanged();
		// call this after you change some global attribute like
		//  document dimensions
	void UpdateAllItems(COleServerItem* pSender,
		LPARAM lHint = 0L, CObject* pHint = NULL,
		DVASPECT nDrawAspect = DVASPECT_CONTENT);

	// changes to the entire document (automatically notifies clients)
	void NotifyRename(LPCSTR lpszNewName);
	void NotifySaved();
	void NotifyClosed();        // call this after you close document

	// specific operations for embedded documents
	void SaveEmbedding();       // call this to save embedded (before closing)

	// specific to in-place activation
	BOOL ActivateInPlace();
	void RequestPositionChange(LPCRECT lpPosRect);
	BOOL ScrollContainerBy(CSize sizeScroll);
	BOOL DeactivateAndUndo();
	BOOL DiscardUndoState();

public:
// Overridables for standard user interface (full server)
	virtual BOOL OnUpdateDocument(); // implementation of embedded update

protected:
// Overridables you must implement for yourself
	virtual COleServerItem* OnGetEmbeddedItem() = 0;
		// return item representing entire (embedded) document

// Overridables you do not have to implement
	virtual void OnClose(OLECLOSE dwCloseOption);
	virtual void OnSetHostNames(LPCSTR lpszHost, LPCSTR lpszHostObj);

// Advanced overridables
	virtual void OnShowDocument(BOOL bShow);
		// show first frame for document or hide all frames for document

// Advanced overridables for in-place activation
	virtual void OnDeactivate();
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual void OnSetItemRects(LPCRECT lpPosRect, LPCRECT lpClipRect);
	virtual BOOL OnReactivateAndUndo();

	virtual void OnFrameWindowActivate(BOOL bActivate);
	virtual void OnDocWindowActivate(BOOL bActivate);
	virtual void OnShowControlBars(LPOLEINPLACEUIWINDOW lpUIWindow, BOOL bShow);
	virtual void OnResizeBorder(LPCRECT lpRectBorder,
		LPOLEINPLACEUIWINDOW lpUIWindow, BOOL bFrame);

	virtual COleIPFrameWnd* CreateInPlaceFrame(CWnd* pParentWnd);
	virtual void DestroyInPlaceFrame(COleIPFrameWnd* pFrameWnd);

// Implementation
protected:
	LPOLECLIENTSITE m_lpClientSite;     // for embedded item
	CString m_strHostObj;               // name of document in container
	BOOL m_bCntrVisible;                // TRUE if OnShowWindow(TRUE) called
	BOOL m_bClosing;                    // TRUE if shutting down
	COleServerItem* m_pEmbeddedItem;    // pointer to embedded item for document

	COleIPFrameWnd* m_pInPlaceFrame;    // not NULL if in-place activated
	CWnd* m_pOrigParent;                // not NULL if existing view used
	DWORD m_dwOrigStyle;                // original style of in-place view

public:
	virtual ~COleServerDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// overridables for implementation
	virtual BOOL OnSaveDocument(const char* pszPathName);
	virtual void OnCloseDocument();
	virtual void DeleteContents(); // delete auto-delete server items
	virtual LPMONIKER GetMoniker(OLEGETMONIKER nAssign);
	virtual COleServerItem* OnGetLinkedItem(LPCSTR lpszItemName);
		// return item for the named linked item (only if supporting links)
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);

protected:
	// overrides to handle server user-interface
	virtual BOOL SaveModified();        // return TRUE if ok to continue
	virtual HMENU GetDefaultMenu();     // return menu based on doc type
	virtual HACCEL GetDefaultAccelerator(); // return accel table based on doc type
	virtual BOOL GetFileTypeString(CString& rString);

	// IPersistStorage implementation
	virtual void OnNewEmbedding(LPSTORAGE lpStorage);
	virtual void OnOpenEmbedding(LPSTORAGE lpStorage);
	virtual void OnSaveEmbedding(LPSTORAGE lpStorage);

	// Implementation helpers
	void NotifyAllItems(OLE_NOTIFICATION wNotification, DWORD dwParam);
	BOOL SaveModifiedPrompt();
	void ConnectView(CWnd* pParentWnd, CView* pView);
	void UpdateUsingHostObj(UINT nIDS, CCmdUI* pCmdUI);

// Message Maps
	//{{AFX_MSG(COleServerDoc)
	afx_msg void OnFileUpdate();
	afx_msg void OnFileSaveCopyAs();
	afx_msg void OnUpdateFileUpdate(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFileExit(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Interface Maps
protected:
	BEGIN_INTERFACE_PART(PersistStorage, IPersistStorage)
		STDMETHOD(GetClassID)(LPCLSID);
		STDMETHOD(IsDirty)();
		STDMETHOD(InitNew)(LPSTORAGE);
		STDMETHOD(Load)(LPSTORAGE);
		STDMETHOD(Save)(LPSTORAGE, BOOL);
		STDMETHOD(SaveCompleted)(LPSTORAGE);
		STDMETHOD(HandsOffStorage)();
	END_INTERFACE_PART(PersistStorage)

	BEGIN_INTERFACE_PART(OleObject, IOleObject)
		STDMETHOD(SetClientSite)(LPOLECLIENTSITE);
		STDMETHOD(GetClientSite)(LPOLECLIENTSITE FAR*);
		STDMETHOD(SetHostNames)(LPCSTR, LPCSTR);
		STDMETHOD(Close)(DWORD);
		STDMETHOD(SetMoniker)(DWORD, LPMONIKER);
		STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER FAR*);
		STDMETHOD(InitFromData)(LPDATAOBJECT, BOOL, DWORD);
		STDMETHOD(GetClipboardData)(DWORD, LPDATAOBJECT FAR*);
		STDMETHOD(DoVerb)(LONG, LPMSG, LPOLECLIENTSITE, LONG, HWND, LPCRECT);
		STDMETHOD(EnumVerbs)(IEnumOLEVERB FAR* FAR*);
		STDMETHOD(Update)();
		STDMETHOD(IsUpToDate)();
		STDMETHOD(GetUserClassID)(CLSID FAR*);
		STDMETHOD(GetUserType)(DWORD, LPSTR FAR*);
		STDMETHOD(SetExtent)(DWORD, LPSIZEL);
		STDMETHOD(GetExtent)(DWORD, LPSIZEL);
		STDMETHOD(Advise)(LPADVISESINK, LPDWORD);
		STDMETHOD(Unadvise)(DWORD);
		STDMETHOD(EnumAdvise)(LPENUMSTATDATA FAR*);
		STDMETHOD(GetMiscStatus)(DWORD, LPDWORD);
		STDMETHOD(SetColorScheme)(LPLOGPALETTE);
	END_INTERFACE_PART(OleObject)

	BEGIN_INTERFACE_PART(DataObject, IDataObject)
		STDMETHOD(GetData)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(GetDataHere)(LPFORMATETC, LPSTGMEDIUM);
		STDMETHOD(QueryGetData)(LPFORMATETC);
		STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC, LPFORMATETC);
		STDMETHOD(SetData)(LPFORMATETC, LPSTGMEDIUM, BOOL);
		STDMETHOD(EnumFormatEtc)(DWORD, LPENUMFORMATETC FAR*);
		STDMETHOD(DAdvise)(LPFORMATETC, DWORD, LPADVISESINK, LPDWORD);
		STDMETHOD(DUnadvise)(DWORD);
		STDMETHOD(EnumDAdvise)(LPENUMSTATDATA FAR*);
	END_INTERFACE_PART(DataObject)

	BEGIN_INTERFACE_PART(OleInPlaceObject, IOleInPlaceObject)
		STDMETHOD(GetWindow)(HWND FAR*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(InPlaceDeactivate)();
		STDMETHOD(UIDeactivate)();
		STDMETHOD(SetObjectRects)(LPCRECT, LPCRECT);
		STDMETHOD(ReactivateAndUndo)();
	END_INTERFACE_PART(OleInPlaceObject)

	BEGIN_INTERFACE_PART(OleInPlaceActiveObject, IOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND FAR*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(OleInPlaceActiveObject)

	DECLARE_INTERFACE_MAP()

	friend class COleServer;
	friend class COleServerItem;
};

//////////////////////////////////////////////////////////////////////////////
// COleIPFrameWnd

class COleIPFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(COleIPFrameWnd)

// Constructors
public:
	COleIPFrameWnd();

// Overridables
public:
	virtual BOOL OnCreateControlBars(CWnd* pWndFrame, CWnd* pWndDoc);
		// create control bars on container windows (pWndDoc can be NULL)
	void RepositionFrame(LPCRECT lpPosRect, LPCRECT lpClipRect);

// Implementation
public:
	BOOL m_bUIActive;   // TRUE if currently in uiacitve state

	virtual BOOL LoadFrame(UINT nIDResource,
		DWORD dwDefaultStyle = WS_CHILD|WS_BORDER|WS_CLIPSIBLINGS,
		CWnd* pParentWnd = NULL,
		CCreateContext* pContext = NULL);
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	virtual ~COleIPFrameWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	// in-place state
	OLEINPLACEFRAMEINFO m_frameInfo;
	LPOLEINPLACEFRAME m_lpFrame;
	LPOLEINPLACEUIWINDOW m_lpDocFrame;
	HWND m_hWndFrame;
	HWND m_hWndDocFrame;
	HMENU m_hSharedMenu;
	OLEMENUGROUPWIDTHS m_menuWidths;
	HOLEMENU m_hOleMenu;
	CRect m_rectPos;            // client area rect of the item
	CRect m_rectClip;           // area to which frame should be clipped
	BOOL m_bInsideRecalc;

	// in-place activation support
	BOOL BuildSharedMenu(COleServerDoc* pDoc);
	void DestroySharedMenu(COleServerDoc* pDoc);
	void UpdateControlBars(HWND hWnd);

protected:
	//{{AFX_MSG(COleIPFrameWnd)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnRecalcParent(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnResizeChild(WPARAM wParam, LPARAM lParam);
	afx_msg void OnContextHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	friend class COleServerDoc;
};

/////////////////////////////////////////////////////////////////////////////
// COleResizeBar - supports in-place resizing in server applications

class COleResizeBar : public CControlBar
{
	DECLARE_DYNAMIC(COleResizeBar)

// Constructors
public:
	COleResizeBar();
	BOOL Create(CWnd* pParentWnd, DWORD dwStyle = WS_CHILD | WS_VISIBLE,
		UINT nID = AFX_IDW_RESIZE_BAR);

// Implementation
public:
	virtual ~COleResizeBar();
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

protected:
	CRectTracker m_tracker;     // implemented with a tracker

protected:
	//{{AFX_MSG(COleResizeBar)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonDown(UINT, CPoint point);
	afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleStreamFile - implementation of CFile which uses an IStream

class COleStreamFile : public CFile
{
	DECLARE_DYNAMIC(COleStreamFile)

// Constructors and Destructors
public:
	COleStreamFile(LPSTREAM lpStream = NULL);

// Operations
	// Note: OpenStream and CreateStream can accept eith STGM_ flags or
	//  CFile::OpenFlags bits since common values are guaranteed to have
	//  the same semantics.
	BOOL OpenStream(LPSTORAGE lpStorage, LPCSTR lpszStreamName,
		DWORD nOpenFlags = modeReadWrite|shareExclusive,
		CFileException* pError = NULL);
	BOOL CreateStream(LPSTORAGE lpStorage, LPCSTR lpszStreamName,
		DWORD nOpenFlags = modeReadWrite|shareExclusive|modeCreate,
		CFileException* pError = NULL);

	BOOL CreateMemoryStream(CFileException* pError = NULL);

	// attach & detach can be used when Open/Create functions aren't adequate
	void Attach(LPSTREAM lpStream);
	LPSTREAM Detach();

// Implementation
public:
	LPSTREAM m_lpStream;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleStreamFile();

	// attributes for implementation
	BOOL GetStatus(CFileStatus& rStatus) const;
	virtual DWORD GetPosition() const;

	// overrides for implementation
	virtual CFile* Duplicate() const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void SetLength(DWORD dwNewLen);
	virtual DWORD GetLength() const;
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
	virtual void Abort();
	virtual void Flush();
	virtual void Close();
};

/////////////////////////////////////////////////////////////////////////////
// COleDropSource (advanced drop source support)

class COleDropSource : public CCmdTarget
{
// Constructors
public:
	COleDropSource();

// Overridables
	virtual SCODE QueryContinueDrag(BOOL bEscapePressed, DWORD dwKeyState);
	virtual SCODE GiveFeedback(DROPEFFECT dropEffect);
	virtual BOOL OnBeginDrag(CWnd* pWnd);

// Implementation
public:
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	BEGIN_INTERFACE_PART(DropSource, IDropSource)
		STDMETHOD(QueryContinueDrag)(BOOL, DWORD);
		STDMETHOD(GiveFeedback)(DWORD);
	END_INTERFACE_PART(DropSource)

	DECLARE_INTERFACE_MAP()

	CRect m_rectStartDrag;  // when mouse leaves this rect, drag drop starts
	BOOL m_bDragStarted;    // has drag really started yet?

	// metrics for drag start determination
	static UINT nDragMinDist;   // min. amount mouse must move for drag
	static UINT nDragDelay;     // delay before drag starts

	friend class COleDataSource;
};

/////////////////////////////////////////////////////////////////////////////
// COleDropTarget (advanced drop target support)

class COleDropTarget : public CCmdTarget
{
// Constructors
public:
	COleDropTarget();

// Operations
	BOOL Register(CWnd* pWnd);
	virtual void Revoke();  // virtual for implementation

// Overridables
	virtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual BOOL OnDrop(CWnd* pWnd, COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
	virtual void OnDragLeave(CWnd* pWnd);
	virtual BOOL OnDragScroll(CWnd* pWnd, DWORD dwKeyState, CPoint point);

// Implementation
public:
	virtual ~COleDropTarget();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	HWND m_hWnd;            // HWND this IDropTarget is attached to
	LPDATAOBJECT m_lpDataObject;    // != NULL between OnDragEnter, OnDragLeave
	UINT m_nTimerID;        // != MAKEWORD(-1, -1) when in scroll area
	DWORD m_dwLastTick;     // only valid when m_nTimerID valid
	UINT m_nScrollDelay;    // time to next scroll

	// metrics for drag-scrolling
	static int nScrollInset;
	static UINT nScrollDelay;
	static UINT nScrollInterval;

	// implementation helpers
	void SetupTimer(CView* pView, UINT nTimerID);
	void CancelTimer(CWnd* pWnd);

// Interface Maps
protected:
	BEGIN_INTERFACE_PART(DropTarget, IDropTarget)
		STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
		STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
		STDMETHOD(DragLeave)();
		STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL pt, LPDWORD);
	END_INTERFACE_PART(DropTarget)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// COleMessageFilter (implements IMessageFilter)

class COleMessageFilter : public CCmdTarget
{
// Constructors
public:
	COleMessageFilter();

// Operations
	BOOL Register();
	void Revoke();

	// for controlling the busy state of the server application (called app)
	virtual void BeginBusyState();
	virtual void EndBusyState();
	void SetBusyReply(SERVERCALL nBusyReply);

	// for controlling actions taken against rejected/retried calls
	void SetRetryReply(DWORD nRetryReply = 0);
		// only used when the "not responding" dialog is disabled
	void SetMessagePendingDelay(DWORD nTimeout = 5000);
		// used to determine amount of time before significant message
	void EnableBusyDialog(BOOL bEnableBusy = TRUE);
	void EnableNotRespondingDialog(BOOL bEnableNotResponding = TRUE);
		// used to enable/disable the two types of busy dialogs

// Overridables
	virtual BOOL OnMessagePending(const MSG* pMsg);
		// return TRUE to eat the message (usually only if processed)

// Implementation
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual ~COleMessageFilter();
	virtual BOOL IsSignificantMessage(MSG* pMsg);
		// determine if any significant messages are present in the queue
	virtual int OnBusyDialog(HTASK htaskBusy);
	virtual int OnNotRespondingDialog(HTASK htaskBusy);
		// these functions display the busy dialog

protected:
	BOOL m_bRegistered;
	LONG m_nBusyCount;  // for BeginBusyState & EndBusyState
	BOOL m_bEnableBusy;
	BOOL m_bEnableNotResponding;
	BOOL m_bUnblocking;
	DWORD m_nRetryReply;    // only used if m_bEnableNotResponding == FALSE
	DWORD m_nBusyReply;
	DWORD m_nTimeout;

// Interface Maps
protected:
	BEGIN_INTERFACE_PART(MessageFilter, IMessageFilter)
		STDMETHOD_(DWORD, HandleInComingCall)(DWORD, HTASK, DWORD, DWORD);
		STDMETHOD_(DWORD, RetryRejectedCall)(HTASK, DWORD, DWORD);
		STDMETHOD_(DWORD, MessagePending)(HTASK, DWORD, DWORD);
	END_INTERFACE_PART(MessageFilter)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// global helpers and debugging

void AFXAPI AfxOleSetEditMenu(COleClientItem* pClient, CMenu* pMenu,
	UINT iMenuItem, UINT nIDVerbMin, UINT nIDVerbMax = 0, UINT nIDConvert = 0);

#ifdef _DEBUG
// Mapping SCODEs to readable text
LPCSTR AFXAPI AfxGetFullScodeString(SCODE sc);
LPCSTR AFXAPI AfxGetScodeString(SCODE sc);
LPCSTR AFXAPI AfxGetScodeRangeString(SCODE sc);
LPCSTR AFXAPI AfxGetSeverityString(SCODE sc);
LPCSTR AFXAPI AfxGetFacilityString(SCODE sc);

// Mapping IIDs to readable text
LPCSTR AFXAPI AfxGetIIDString(REFIID iid);
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#ifndef _AFXCTL
#define _AFXOLE_INLINE inline
#define _AFXOLECLI_INLINE inline
#define _AFXOLESVR_INLINE inline
#endif
#define _AFXOLEDOBJ_INLINE inline
#include <afxole.inl>
#undef _AFXOLE_INLINE
#undef _AFXOLECLI_INLINE
#undef _AFXOLESVR_INLINE
#undef _AFXOLEDOBJ_INLINE
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

#endif //__AFXOLE