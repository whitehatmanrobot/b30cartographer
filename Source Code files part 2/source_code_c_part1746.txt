       *Call = ReadCall;
            *InOutData = Data;
            return Call->Status;
        }

        PUCHAR OutData;
        if (ReadCall.OutSize > 0)
        {
            DBG_ASSERT((ReadCall.Flags & DBGRPC_NO_RETURN) == 0);

            OutData = (PUCHAR)Conn->Alloc(ReadCall.OutSize);
            if (OutData == NULL)
            {
                if (Data)
                {
                    Conn->Free(Data);
                }
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            OutData = NULL;
        }

        if (ReadCall.Flags & DBGRPC_NO_RETURN)
        {
            Conn->m_Flags |= DBGRPC_IN_ASYNC_CALL;
        }

        DbgRpcStubFunction StubFn = DbgRpcGetStub(ReadCall.StubIndex);
        if (StubFn != NULL)
        {
            ReadCall.Status = StubFn((IUnknown*)ReadCall.ObjectId,
                                     Conn, &ReadCall, Data, OutData);
        }
        else
        {
            ReadCall.Status = RPC_E_INVALIDMETHOD;
        }

        Conn->m_Flags &= ~DBGRPC_IN_ASYNC_CALL;

        DRPC(("%X: %X: Called %s (%X), ret 0x%X, out %d\n",
              GetCurrentThreadId(), ReadCall.Sequence,
              DbgRpcGetStubName(ReadCall.StubIndex),
              ReadCall.StubIndex, ReadCall.Status, ReadCall.OutSize));

        Status = S_OK;
        if ((ReadCall.Flags & DBGRPC_NO_RETURN) == 0)
        {
            ReadCall.Flags |= DBGRPC_RETURN;

            // Take a lock here to make sure that the header
            // and body are sequential in the stream.
            EnterCriticalSection(&g_DbgRpcLock);

            if (Conn->m_Trans->Write(ReadCall.Sequence,
                                     &ReadCall, sizeof(ReadCall)) !=
                sizeof(ReadCall) ||
                (ReadCall.OutSize > 0 &&
                 Conn->m_Trans->Write(ReadCall.Sequence,
                                      OutData, ReadCall.OutSize) !=
                 ReadCall.OutSize))
            {
                Status = RPC_E_CANTTRANSMIT_CALL;
            }

            LeaveCriticalSection(&g_DbgRpcLock);
        }

        if (OutData) 
        {
            Conn->FreeData(OutData);
        }

        if (Data)
        {
            Conn->FreeData(Data);
        }

        if (Status != S_OK)
        {
            return Status;
        }
    }
}

//----------------------------------------------------------------------------
//
// DbgRpcConnection.
//
//----------------------------------------------------------------------------

DbgRpcConnection* g_DbgRpcConns;

DbgRpcConnection::DbgRpcConnection(DbgRpcTransport* Trans)
{
    m_Trans = Trans;
    m_Next = NULL;
    m_ThreadId = GetCurrentThreadId();
    m_Buffer = PTR_ALIGN2(PUCHAR, m_UnalignedBuffer,
                          DBGRPC_CONN_BUFFER_ALIGN);
    m_BufferUsed = 0;
    m_Flags = 0;
    m_Objects = 0;
}

DbgRpcConnection::~DbgRpcConnection(void)
{
    Disconnect();
}

PUCHAR
DbgRpcConnection::StartCall(DbgRpcCall* Call, DbgRpcObjectId ObjectId,
                            ULONG StubIndex, ULONG InSize, ULONG OutSize)
{
    PUCHAR Data;

    if (InSize > 0)
    {
        Data = (PUCHAR)Alloc(InSize);
        if (Data == NULL)
        {
            return NULL;
        }
    }
    else
    {
        // Have to return a non-zero pointer but
        // it doesn't need to be valid since it should
        // never be used.
        Data = DBGRPC_NO_DATA;
    }

    Call->ObjectId = ObjectId;
    DBG_ASSERT(StubIndex < 0x10000);
    Call->StubIndex = (USHORT)StubIndex;
    Call->Flags = 0;
    Call->InSize = InSize;
    Call->OutSize = OutSize;
    Call->Status = S_OK;
    Call->Sequence = InterlockedIncrement((PLONG)&g_DbgRpcCallSequence);
    Call->Reserved1 = 0;

    return Data;
}

HRESULT
DbgRpcConnection::SendReceive(DbgRpcCall* Call, PUCHAR* InOutData)
{
    //
    // Send call and in-parameter data.
    //

    DRPC(("%X: %X: Calling %s (%X), in %d, out %d\n",
          GetCurrentThreadId(), Call->Sequence,
          DbgRpcGetStubName(Call->StubIndex),
          Call->StubIndex, Call->InSize, Call->OutSize));

    if (m_Flags & DBGRPC_IN_ASYNC_CALL)
    {
        return RPC_E_CANTCALLOUT_INASYNCCALL;
    }

    // Take a lock here to make sure that the header
    // and body are sequential in the stream.
    EnterCriticalSection(&g_DbgRpcLock);

    if (m_Trans->Write(SEQ_CALL_HEADER, Call, sizeof(*Call)) != sizeof(*Call))
    {
        LeaveCriticalSection(&g_DbgRpcLock);
        return RPC_E_CANTTRANSMIT_CALL;
    }
    if (Call->InSize > 0)
    {
        if (m_Trans->Write(Call->Sequence, *InOutData, Call->InSize) !=
            Call->InSize)
        {
            LeaveCriticalSection(&g_DbgRpcLock);
            return RPC_E_CANTTRANSMIT_CALL;
        }

        // In data is no longer necessary.
        Free(*InOutData);
    }

    LeaveCriticalSection(&g_DbgRpcLock);

    // Clear out data pointer in case of later failures.
    *InOutData = NULL;

    HRESULT Status;

    if (Call->Flags & DBGRPC_NO_RETURN)
    {
        Status = S_OK;
    }
    else
    {
        USHORT StubIndex = Call->StubIndex;

        Status = DbgRpcReceiveCalls(this, Call, InOutData);

        if (Call->StubIndex != StubIndex)
        {
#if DBG
            DRPC_ERR(("%X: %X: Call to %s (%X) returned from %s (%d)\n",
                      GetCurrentThreadId(), Call->Sequence,
                      DbgRpcGetStubName(StubIndex), StubIndex,
                      DbgRpcGetStubName(Call->StubIndex),
                      Call->StubIndex));
#else
            DRPC_ERR(("%X: %X: Mismatched call return\n",
                      GetCurrentThreadId(), Call->Sequence));
#endif
            Status = RPC_E_INVALID_DATAPACKET;
        }
    }

    return Status;
}

PVOID
DbgRpcConnection::MallocAligned(ULONG Size)
{
    PVOID Data, Align;

    // Not enough buffer space left so allocate.  malloc
    // only gives out 8-byte-aligned memory so tweak things
    // to get it aligned.
    Data = malloc(Size + DBGRPC_CONN_BUFFER_ALIGN);
    if (Data != NULL)
    {
        if ((ULONG_PTR)Data & (DBGRPC_CONN_BUFFER_ALIGN - 1))
        {
            Align = PTR_ALIGN2(PVOID, Data, DBGRPC_CONN_BUFFER_ALIGN);
        }
        else
        {
            Align = (PVOID)((PUCHAR)Data + DBGRPC_CONN_BUFFER_ALIGN);
        }

        *((PVOID*)Align - 1) = Data;
    }
    else
    {
        Align = NULL;
    }

    return Align;
}

void
DbgRpcConnection::FreeAligned(PVOID Ptr)
{
    free(*((PVOID*)Ptr - 1));
}

PVOID
DbgRpcConnection::Alloc(ULONG Size)
{
    PVOID Data = NULL;

    // Keep every allocated chunk aligned.
    Size = INT_ALIGN2(Size, DBGRPC_CONN_BUFFER_ALIGN);

    // Don't burn up large parts of the buffer on big chunks
    // as that may force many smaller chunks into dynamic
    // allocations because the buffer is full.
    if (Size <= DBGRPC_CONN_BUFFER_DYNAMIC_LIMIT)
    {
        EnterCriticalSection(&g_DbgRpcLock);

        if (m_BufferUsed + Size <= DBGRPC_CONN_BUFFER_SIZE)
        {
            // Data is allocated in strict LIFO order so
            // we just need to mark the end of the buffer as used.
            Data = &m_Buffer[m_BufferUsed];
            m_BufferUsed += Size;
        }

        LeaveCriticalSection(&g_DbgRpcLock);
    }

    if (Data == NULL)
    {
        Data = MallocAligned(Size);
    }

    return Data;
}

void
DbgRpcConnection::Free(PVOID Ptr)
{
    if (Ptr >= m_Buffer && Ptr < m_Buffer + DBGRPC_CONN_BUFFER_SIZE)
    {
        EnterCriticalSection(&g_DbgRpcLock);

        // Data was allocated in the connection buffer.
        // Data is allocated in strict LIFO order so
        // we just need to back up prior to the data.
        m_BufferUsed = (ULONG)((PUCHAR)Ptr - m_Buffer);

        LeaveCriticalSection(&g_DbgRpcLock);
    }
    else
    {
        // Data was dynamically allocated.
        FreeAligned(Ptr);
    }
}

void
DbgRpcConnection::Disconnect(void)
{
    delete m_Trans;
    m_Trans = NULL;
}

DbgRpcConnection*
DbgRpcGetConnection(ULONG Tid)
{
    DbgRpcConnection* Conn;

    EnterCriticalSection(&g_DbgRpcLock);

    for (Conn = g_DbgRpcConns; Conn != NULL; Conn = Conn->m_Next)
    {
        if (Conn->m_ThreadId == Tid)
        {
            break;
        }
    }

    LeaveCriticalSection(&g_DbgRpcLock);
    return Conn;
}

void
DbgRpcAddConnection(DbgRpcConnection* Conn)
{
    EnterCriticalSection(&g_DbgRpcLock);

    Conn->m_Next = g_DbgRpcConns;
    g_DbgRpcConns = Conn;

    LeaveCriticalSection(&g_DbgRpcLock);
}

void
DbgRpcRemoveConnection(DbgRpcConnection* Conn)
{
    EnterCriticalSection(&g_DbgRpcLock);

    DbgRpcConnection* Prev = NULL;
    DbgRpcConnection* Cur;
    for (Cur = g_DbgRpcConns; Cur != NULL; Cur = Cur->m_Next)
    {
        if (Cur == Conn)
        {
            break;
        }

        Prev = Cur;
    }

    DBG_ASSERT(Cur != NULL);

    if (Prev == NULL)
    {
        g_DbgRpcConns = Conn->m_Next;
    }
    else
    {
        Prev->m_Next = Conn->m_Next;
    }

    LeaveCriticalSection(&g_DbgRpcLock);
}

void
DbgRpcDeleteConnection(DbgRpcConnection* Conn)
{
    DbgRpcRemoveConnection(Conn);

    // It's possible that another thread is in the middle
    // of using the connection for an async send.  Disconnect
    // the connection to force any pending calls to fail.
    // The connection is already removed from the list
    // so there shouldn't be any further usage.
    Conn->Disconnect();

    // Give up some time to let things fail.  This
    // could be made more deterministic by tracking
    // connection usage but it doesn't seem necessary.
    Sleep(1000);

    delete Conn;
}

//----------------------------------------------------------------------------
//
// DbgRpcProxy.
//
//----------------------------------------------------------------------------

DbgRpcProxy::DbgRpcProxy(ULONG InterfaceIndex)
{
    m_InterfaceIndex = InterfaceIndex;
    m_OwningThread = ::GetCurrentThreadId();
    m_LocalRefs = 0;
    m_RemoteRefs = 1;
    m_ObjectId = 0;
}

DbgRpcProxy::~DbgRpcProxy(void)
{
    // If this proxy was attached to a connection detach it.
    if (m_ObjectId)
    {
        DbgRpcConnection* Conn = DbgRpcGetConnection(m_OwningThread);
        if (Conn != NULL)
        {
            DRPC_REF(("Conn %p obj %2d proxy %p\n",
                      Conn, Conn->m_Objects - 1, this));
            if (InterlockedDecrement((PLONG)&Conn->m_Objects) == 0)
            {
                DbgRpcDeleteConnection(Conn);
            }
        }
    }
}

IUnknown*
DbgRpcProxy::InitializeProxy(DbgRpcObjectId ObjectId,
                             IUnknown* ExistingProxy)
{
    //
    // The current debugger remoting does not preserve
    // object identity as this simplifies proxy
    // management.  Nobody currently needs it, so
    // we're not bothering with it.  If object identity
    // becomes important this routine is the place
    // to implement proxy lookup and sharing.
    //
    
    // Handle NULL object case where proxy is unnecessary.
    if (ObjectId == 0)
    {
        // Proxies all have the same basic layout so this
        // cast works for any interface-specific proxy.
        DbgRpcDeleteProxy(this);
        return NULL;
    }
    
    DbgRpcConnection* Conn = DbgRpcGetConnection(m_OwningThread);
    if (Conn != NULL)
    {
        InterlockedIncrement((PLONG)&Conn->m_Objects);
        DRPC_REF(("Conn %p obj %2d proxy %p\n",
                  Conn, Conn->m_Objects, this));
    }
    
    m_ObjectId = ObjectId;
    return ExistingProxy;
}

//----------------------------------------------------------------------------
//
// DbgRpcClientObject.
//
//----------------------------------------------------------------------------

void
DbgRpcClientObject::Finalize(void)
{
    // Do-nothing convenience implementation.
}

//----------------------------------------------------------------------------
//
// Registration functions.
//
//----------------------------------------------------------------------------

#define DBGRPC_MAX_REG_SERVERS 16

ULONG g_DbgRpcRegServers[DBGRPC_MAX_REG_SERVERS][2];

void
DbgRpcRegisterServer(DbgRpcTransport* Trans,
                     DbgRpcClientObjectFactory* Factory)
{
#ifndef NT_NATIVE
    char Desc[2 * MAX_PARAM_VALUE];
    PSTR Tail;

    Factory->GetServerTypeName(Desc);
    Tail = Desc + strlen(Desc);
    DBG_ASSERT(Tail < Desc + 32);

    *Tail++ = ' ';
    *Tail++ = '-';
    *Tail++ = ' ';
    Trans->GetParameters(Tail, sizeof(Desc) - (ULONG)(Tail - Desc));

    HKEY Key;
    LONG Status;
    char ValName[32];
    ULONG Index;

    // No servers will survive a reboot so create a volatile
    // key to ensure that even if the key isn't cleaned up
    // at process exit it'll go away at the next reboot.
    if ((Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DEBUG_SERVER_KEY,
                                 0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                                 NULL, &Key, NULL)) != ERROR_SUCCESS)
    {
        DRPC_ERR(("%X: Unable to register server '%s'\n",
                  GetCurrentThreadId(), Desc));
        return;
    }

    // Prefix the value name with the thread ID to ensure that
    // every thread currently running has its own namespace.  This
    // makes it impossible for two threads to attempt to write
    // the same value at the same time.
    sprintf(ValName, "%08X.", GetCurrentThreadId());

    // Find an unused value and store the server information.
    Index = 0;
    for (;;)
    {
        DWORD Len;
        
        sprintf(ValName + 9, "%08X", Index);
        
        if (RegQueryValueEx(Key, ValName, NULL, NULL, NULL,
                            &Len) != ERROR_SUCCESS)
        {
            break;
        }

        Index++;
    }

    if ((Status = RegSetValueEx(Key, ValName, 0, REG_SZ, (LPBYTE)Desc,
                                strlen(Desc) + 1)) != ERROR_SUCCESS)
    {
        DRPC_ERR(("%X: Unable to register server '%s'\n",
                  GetCurrentThreadId(), Desc));
    }
    else
    {
        ULONG i;

        // Remember the value name used so that it can be
        // removed later.  This is done with a simple
        // static array since there shouldn't be that many
        // servers in a process and they don't die until
        // the process exits.
        for (i = 0; i < DBGRPC_MAX_REG_SERVERS; i++)
        {
            if (g_DbgRpcRegServers[i][0] == 0)
            {
                g_DbgRpcRegServers[i][0] = GetCurrentThreadId();
                g_DbgRpcRegServers[i][1] = Index;
                break;
            }
        }
    }
    
    RegCloseKey(Key);
#endif // #ifndef NT_NATIVE
}

void
DbgRpcDeregisterServers(void)
{
#ifndef NT_NATIVE
    HKEY Key;
    LONG Status;

    if ((Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, DEBUG_SERVER_KEY,
                                 0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                                 NULL, &Key, NULL)) != ERROR_SUCCESS)
    {
        return;
    }
       
    ULONG i;

    for (i = 0; i < DBGRPC_MAX_REG_SERVERS; i++)
    {
        if (g_DbgRpcRegServers[i][0] == 0)
        {
            continue;
        }

        char ValName[32];
        
        sprintf(ValName, "%08X.%08X", g_DbgRpcRegServers[i][0],
                g_DbgRpcRegServers[i][1]);
        RegDeleteValue(Key, ValName);
        g_DbgRpcRegServers[i][0] = 0;
        g_DbgRpcRegServers[i][1] = 0;
    }

    RegCloseKey(Key);
#endif // #ifndef NT_NATIVE
}

//----------------------------------------------------------------------------
//
// Initialization functions.
//
//----------------------------------------------------------------------------

BOOL
DbgRpcOneTimeInitialization(void)
{
    static BOOL s_Initialized = FALSE;

    if (s_Initialized)
    {
        return TRUE;
    }

#ifndef NT_NATIVE
    WSADATA WsData;

    if (WSAStartup(MAKEWORD(2, 0), &WsData) != 0)
    {
        return FALSE;
    }
#endif

    if (InitializeAllAccessSecObj() != S_OK)
    {
        return FALSE;
    }

    __try
    {
        InitializeCriticalSection(&g_DbgRpcLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }
    
    DbgRpcInitializeClient();

    return TRUE;
}

DbgRpcConnection*
DbgRpcCreateClientObject(DbgRpcTransport* Trans,
                         DbgRpcClientObjectFactory* Factory,
                         PSTR TransIdentity,
                         DbgRpcClientObject** ClientObject)
{
    if (strlen(TransIdentity) >= DBGRPC_MAX_IDENTITY - 16)
    {
        // This check is really just to placate PREfix,
        // as transport identities are always much shorter
        // than this.
        DRPC_ERR(("%X: Invalid transport identity\n",
                  GetCurrentThreadId()));
        delete Trans;
        return NULL;
    }
    
    DbgRpcConnection* Conn = new DbgRpcConnection(Trans);
    if (Conn == NULL)
    {
        DRPC_ERR(("%X: Unable to allocate client connection\n",
                  GetCurrentThreadId()));
        delete Trans;
        return NULL;
    }

    DRPC(("%X: Read handshake\n",
          GetCurrentThreadId()));
    
    DbgRpcHandshake Shake;
    
    if (Trans->Read(SEQ_HANDSHAKE, &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        DRPC_ERR(("%X: Unable to read handshake from remote client\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }

    DRPC(("%X: Read handshake, sig %X, ver %X, obj %I64X, id %d, pwd %d\n",
          GetCurrentThreadId(), Shake.Signature, Shake.ProtocolVersion,
          Shake.RemoteObject, Shake.IdentityLength, Shake.PasswordLength));
    
    if (Shake.Signature != DBGRPC_SIGNATURE ||
        Shake.ProtocolVersion != DBGRPC_PROTOCOL_VERSION ||
        Shake.RemoteObject != 0 ||
        Shake.IdentityLength > DBGRPC_MAX_IDENTITY ||
        (Shake.PasswordLength != 0 &&
         Shake.PasswordLength != MAX_PASSWORD_BUFFER))
    {
        DRPC_ERR(("%X: Invalid handshake from remote client\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }

    char Identity[DBGRPC_MAX_IDENTITY];
    
    if (Shake.IdentityLength > 0)
    {
        if (Trans->Read(SEQ_IDENTITY, Identity, Shake.IdentityLength) !=
            Shake.IdentityLength)
        {
            DRPC_ERR(("%X: Unable to read identity from remote client\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }

        Identity[Shake.IdentityLength - 1] = 0;
    }
    else
    {
        strcpy(Identity, "OldRpc\\NoIdentity");
    }

    //
    // Format the raw transport identity into something
    // that'll look better appended to the reported identity.
    //
    
    char TransIdentityFmt[DBGRPC_MAX_IDENTITY];
    sprintf(TransIdentityFmt, " (%s)", TransIdentity);

    strncat(Identity, TransIdentityFmt, 
            DBGRPC_MAX_IDENTITY - strlen(Identity) - 1);
    
    if (Shake.PasswordLength > 0)
    {
        if (!Trans->m_PasswordGiven)
        {
            DRPC_ERR(("%X: Password not given but client sent one\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }

        UCHAR Pwd[MAX_PASSWORD_BUFFER];

        if (Trans->Read(SEQ_PASSWORD, Pwd, Shake.PasswordLength) !=
            Shake.PasswordLength)
        {
            DRPC_ERR(("%X: Unable to read password from remote client\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }

        if (memcmp(Pwd, Trans->m_HashedPassword, MAX_PASSWORD_BUFFER) != 0)
        {
            DRPC_ERR(("%X: Client sent incorrect password\n",
                      GetCurrentThreadId()));
            goto EH_Conn;
        }
    }
    else if (Trans->m_PasswordGiven)
    {
        DRPC_ERR(("%X: Password given but client didn't send one\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }

    if (Shake.Flags & DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN)
    {
        Conn->m_Flags |= DBGRPC_FULL_REMOTE_UNKNOWN;
    }
    
    DbgRpcClientObject* Object;
    PVOID ObjInterface;

    if (Factory->CreateInstance(&Shake.DesiredObject, &Object) != S_OK)
    {
        DRPC_ERR(("%X: Unable to create client object instance\n",
                  GetCurrentThreadId()));
        goto EH_Conn;
    }
    if (Object->Initialize(Identity, &ObjInterface) != S_OK)
    {
        DRPC_ERR(("%X: Unable to initialize client object\n",
                  GetCurrentThreadId()));
        goto EH_Object;
    }
    
    ZeroMemory(&Shake, sizeof(Shake));
    Shake.Signature = DBGRPC_SIGNATURE;
    Shake.ProtocolVersion = DBGRPC_PROTOCOL_VERSION;
    Shake.RemoteObject = (DbgRpcObjectId)ObjInterface;
    Shake.Flags = DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN;
    if (Trans->Write(SEQ_HANDSHAKE,
                     &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        DRPC_ERR(("%X: Unable to write handshake to remote client\n",
                  GetCurrentThreadId()));
        goto EH_Object;
    }

    DRPC(("%X: Object %p created\n",
          GetCurrentThreadId(), Object));

    Object->Finalize();
    *ClientObject = Object;
    DbgRpcAddConnection(Conn);
    return Conn;

 EH_Object:
    Object->Uninitialize();
 EH_Conn:
    delete Conn;
    return NULL;
}

struct ClientThreadData
{
    DbgRpcTransport* Trans;
    DbgRpcClientObjectFactory* Factory;
    char Identity[DBGRPC_MAX_IDENTITY];
};

DWORD WINAPI
DbgRpcClientThread(PVOID ThreadParam)
{
    DbgRpcClientObject* Object;
    ClientThreadData* ThreadData = (ClientThreadData*)ThreadParam;
    DbgRpcTransport* Trans = ThreadData->Trans;
    DbgRpcClientObjectFactory* Factory = ThreadData->Factory;
    
    DbgRpcConnection* Conn =
        DbgRpcCreateClientObject(Trans, Factory,
                                 ThreadData->Identity, &Object);
    
    // Don't need this information any more.
    delete ThreadParam;
    
    if (Conn == NULL)
    {
        ExitUserThread(0);
    }

    if (DbgRpcServerThreadInitialize() != S_OK)
    {
        ExitUserThread(0);
    }
    
    DRPC(("%X: Created connection %p\n",
          GetCurrentThreadId(), Conn));

    DbgRpcCall Call;
    PUCHAR Data;
    HRESULT Status;

    // Take a reference on the connection to ensure that
    // it stays alive as long as this thread does.
    Conn->m_Objects++;
    
    for (;;)
    {
        Data = NULL;
        ZeroMemory(&Call, sizeof(Call));
        Status = DbgRpcReceiveCalls(Conn, &Call, &Data);
        Conn->FreeData(Data);
        if (Status != S_OK)
        {
            DRPC_ERR(("%X: Client thread call receive failed, 0x%X\n",
                      GetCurrentThreadId(), Status));
            if (Status == RPC_E_CLIENT_DIED)
            {
                break;
            }
        }
    }

    DRPC(("%X: Removing connection %p\n",
          GetCurrentThreadId(), Conn));

    DbgRpcDeleteConnection(Conn);
    Object->Uninitialize();
    DbgRpcServerThreadUninitialize();
    ExitUserThread(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

struct ServerThreadData
{
    DbgRpcTransport* Trans;
    DbgRpcClientObjectFactory* Factory;
};

DWORD WINAPI
DbgRpcServerThread(PVOID ThreadParam)
{
    ServerThreadData* ServerData = (ServerThreadData*)ThreadParam;
    DbgRpcTransport* ServerTrans = ServerData->Trans;
    DbgRpcClientObjectFactory* Factory = ServerData->Factory;

    // Values are now cached locally so free passed-in data.
    delete ServerData;
    
    HRESULT Status;
    ClientThreadData* ClientData = NULL;

    // Register this server for people browsing for servers.
    DbgRpcRegisterServer(ServerTrans, Factory);
    
    for (;;)
    {
        if (ClientData == NULL)
        {
            ClientData = new ClientThreadData;
            if (ClientData == NULL)
            {
                DRPC_ERR(("%X: Unable to allocate ClientThreadData\n",
                          GetCurrentThreadId()));
                Sleep(100);
                continue;
            }
        }
        
        Status = ServerTrans->AcceptConnection(&ClientData->Trans,
                                               ClientData->Identity);
        if (Status == S_OK)
        {
            DWORD Tid;

            ClientData->Factory = Factory;
            HANDLE Thread = CreateUserThread(DbgRpcClientThread,
                                             ClientData, &Tid);
            if (Thread == NULL)
            {
                DRPC_ERR(("%X: Client thread create failed, %d\n",
                          GetCurrentThreadId(), GetLastError()));
                Sleep(100);
            }
            else
            {
                CloseHandle(Thread);
                ClientData = NULL;
            }
        }
        else
        {
            DRPC_ERR(("%X: Accept failed, %X\n",
                      GetCurrentThreadId(), Status));
            Sleep(100);
        }
    }

    ExitUserThread(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

HRESULT
DbgRpcCreateServer(PCSTR Options, DbgRpcClientObjectFactory* Factory)
{
    DbgRpcTransport* Trans;
    HRESULT Status;

    if (!DbgRpcOneTimeInitialization())
    {
        return E_FAIL;
    }

    Trans = DbgRpcInitializeTransport(Options);
    if (Trans == NULL)
    {
        return E_INVALIDARG;
    }

    Status = Trans->CreateServer();
    if (Status != S_OK)
    {
        goto EH_Trans;
    }

    ServerThreadData* ThreadData;

    ThreadData = new ServerThreadData;
    if (ThreadData == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto EH_Trans;
    }

    ThreadData->Trans = Trans;
    ThreadData->Factory = Factory;
    
    DWORD Tid;
    HANDLE Thread;
    Thread = CreateUserThread(DbgRpcServerThread, ThreadData, &Tid);
    if (Thread == NULL)
    {
        Status = WIN32_LAST_STATUS();
        delete ThreadData;
        goto EH_Trans;
    }

    CloseHandle(Thread);
    return S_OK;

 EH_Trans:
    delete Trans;
    return Status;
}

#define MIN_CLIENT_IDENTITY (DBGRPC_MAX_IDENTITY * 3 / 4)

void
GetClientIdentity(PSTR Identity)
{
#ifndef NT_NATIVE
    char CompName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG CompSize;
    char UserName[UNLEN + 1];
    ULONG UserSize;

    CompSize = sizeof(CompName);
    if (!GetComputerName(CompName, &CompSize))
    {
        sprintf(CompName, "CErr%d", GetLastError());
        CompSize = strlen(CompName);
    }
    else if (CompSize == 0)
    {
        strcpy(CompName, "NoComp");
        CompSize = 6;
    }
    if (CompSize > DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1)
    {
        CompSize = DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1;
    }
    CompName[CompSize] = 0;

    UserSize = sizeof(UserName);
    if (!GetUserName(UserName, &UserSize))
    {
        sprintf(UserName, "UErr%d", GetLastError());
        UserSize = strlen(UserName);
    }
    else if (UserSize == 0)
    {
        strcpy(UserName, "NoUser");
        UserSize = 6;
    }
    if (UserSize > DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1)
    {
        UserSize = DBGRPC_MAX_IDENTITY - MIN_CLIENT_IDENTITY - 1;
    }
    UserName[UserSize] = 0;

    memcpy(Identity, CompName, CompSize);
    Identity[CompSize] = '\\';
    Identity[CompSize + 1] = 0;
    strncat(Identity + CompSize + 1, UserName,
            DBGRPC_MAX_IDENTITY - CompSize - 2);
#else // #ifndef NT_NATIVE
    strcpy(Identity, "NtNative");
#endif // #ifndef NT_NATIVE
}

HRESULT
DbgRpcCreateServerConnection(DbgRpcTransport* Trans,
                             const GUID* DesiredObject,
                             IUnknown** ClientObject)
{
    HRESULT Status;

    DbgRpcConnection* Conn = new DbgRpcConnection(Trans);
    if (Conn == NULL)
    {
        delete Trans;
        return E_OUTOFMEMORY;
    }

    IUnknown* Object;
    DbgRpcProxy* Proxy;
    ULONG IfUnique;

    Status = DbgRpcPreallocProxy(*DesiredObject, (void **)&Object,
                                 &Proxy, &IfUnique);
    if (Status != S_OK)
    {
        goto EH_Conn;
    }

    Status = Trans->ConnectServer();
    if (Status != S_OK)
    {
        goto EH_Proxy;
    }

    char Identity[DBGRPC_MAX_IDENTITY];
    
    GetClientIdentity(Identity);
    
    DbgRpcHandshake Shake;
    
    ZeroMemory(&Shake, sizeof(Shake));
    Shake.Signature = DBGRPC_SIGNATURE;
    Shake.ProtocolVersion = DBGRPC_PROTOCOL_VERSION;
    Shake.DesiredObject = *DesiredObject;
    Shake.IdentityLength = sizeof(Identity);
    Shake.PasswordLength = Trans->m_PasswordGiven ? MAX_PASSWORD_BUFFER : 0;
    Shake.Flags = DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN;
    if (Trans->Write(SEQ_HANDSHAKE, &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }
    if (Trans->Write(SEQ_IDENTITY, Identity, Shake.IdentityLength) !=
        Shake.IdentityLength)
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }
    if (Trans->m_PasswordGiven &&
        Trans->Write(SEQ_PASSWORD,
                     Trans->m_HashedPassword, Shake.PasswordLength) !=
        Shake.PasswordLength)
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }

    if (Trans->Read(SEQ_HANDSHAKE, &Shake, sizeof(Shake)) != sizeof(Shake))
    {
        Status = E_FAIL;
        goto EH_Proxy;
    }

    DRPC(("%X: Read handshake, sig %X, ver %X\n",
          GetCurrentThreadId(), Shake.Signature, Shake.ProtocolVersion));
    
    if (Shake.Signature != DBGRPC_SIGNATURE ||
        Shake.ProtocolVersion != DBGRPC_PROTOCOL_VERSION ||
        Shake.RemoteObject == 0)
    {
        Status = RPC_E_VERSION_MISMATCH;
        goto EH_Proxy;
    }

    if (Shake.Flags & DBGRPC_SHAKE_FULL_REMOTE_UNKNOWN)
    {
        Conn->m_Flags |= DBGRPC_FULL_REMOTE_UNKNOWN;
    }
    
    // Connection must be added first so it's looked up
    // by InitializeProxy.
    DbgRpcAddConnection(Conn);
    *ClientObject = Proxy->InitializeProxy(Shake.RemoteObject, Object);

    DRPC(("%X: Object %I64X proxied by %p\n",
          GetCurrentThreadId(), Shake.RemoteObject, *ClientObject));
    
    return S_OK;

 EH_Proxy:
    DbgRpcDeleteProxy(Proxy);
 EH_Conn:
    delete Conn;
    return Status;
}

HRESULT
DbgRpcConnectServer(PCSTR Options, const GUID* DesiredObject,
                    IUnknown** ClientObject)
{
    DbgRpcTransport* Trans;
    HRESULT Status;

    if (!DbgRpcOneTimeInitialization())
    {
        return E_FAIL;
    }

    Trans = DbgRpcInitializeTransport(Options);
    if (Trans == NULL)
    {
        return E_INVALIDARG;
    }

    return DbgRpcCreateServerConnection(Trans, DesiredObject, ClientObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgrpc\portio.h ===
//----------------------------------------------------------------------------
//
// Non-network I/O support.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __PORTIO_H__
#define __PORTIO_H__

HRESULT CreateOverlappedPair(LPOVERLAPPED Read, LPOVERLAPPED Write);
BOOL ComPortRead(HANDLE Port, PVOID Buffer, ULONG Len, PULONG Done,
                 LPOVERLAPPED Olap);
BOOL ComPortWrite(HANDLE Port, PVOID Buffer, ULONG Len, PULONG Done,
                  LPOVERLAPPED Olap);
void SetComPortName(PCSTR Name, PSTR Buffer);
ULONG SelectComPortBaud(ULONG NewRate);
HRESULT SetComPortBaud(HANDLE Port, ULONG NewRate, PULONG RateSet);
HRESULT OpenComPort(PSTR Port, ULONG BaudRate, ULONG Timeout,
                    PHANDLE Handle, PULONG BaudSet);

HRESULT Create1394Channel(ULONG Channel, PSTR Name, PHANDLE Handle);
HRESULT Open1394Channel(ULONG Channel, PSTR Name, PHANDLE Handle);

#endif // #ifndef __PORTIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsrv\dbgsrv.cpp ===
//----------------------------------------------------------------------------
//
// Starts a process server and sleeps forever.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <dbgeng.h>

PDEBUG_CLIENT2 g_Client2;

void DECLSPEC_NORETURN
Panic(HRESULT Status, char* Format, ...)
{
    va_list Args;
    char Msg[256];
    char Err[80];

    va_start(Args, Format);
    _vsnprintf(Msg, sizeof(Msg), Format, Args);
    va_end(Args);

    sprintf(Err, "Error 0x%08X", Status);
    MessageBox(GetDesktopWindow(), Msg, Err, MB_OK);
    exit(1);
}

void __cdecl
main(int Argc, char** Argv)
{
    PSTR Options;
    
    while (--Argc > 0)
    {
        Argv++;

        break;
    }

    if (Argc != 1)
    {
        Panic(E_INVALIDARG, "Usage: dbgsrv <transport>");
    }

    Options = *Argv;
    
    HRESULT Status;
    PDEBUG_CLIENT Client;

    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&Client)) != S_OK)
    {
        Panic(Status, "DebugCreate");
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugClient2),
                                         (void**)&g_Client2)) != S_OK)
    {
        Panic(Status, "dbgeng version 2 is required");
    }
    Client->Release();

    if ((Status = g_Client2->
         StartProcessServer(DEBUG_CLASS_USER_WINDOWS, Options, NULL)) != S_OK)
    {
        Panic(Status, "StartProcessServer");
    }

    g_Client2->WaitForProcessServerEnd(INFINITE);

    g_Client2->EndSession(DEBUG_END_REENTRANT);
    g_Client2->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgrpc\portio.cpp ===
//----------------------------------------------------------------------------
//
// Non-network I/O support.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <kdbg1394.h>
#include <ntdd1394.h>

//----------------------------------------------------------------------------
//
// COM.
//
//----------------------------------------------------------------------------

HRESULT
CreateOverlappedPair(LPOVERLAPPED Read, LPOVERLAPPED Write)
{
    ZeroMemory(Read, sizeof(*Read));
    ZeroMemory(Write, sizeof(*Write));
    
    Read->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (Read->hEvent == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    Write->hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (Write->hEvent == NULL)
    {
        CloseHandle(Read->hEvent);
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

BOOL
ComPortRead(HANDLE Port, PVOID Buffer, ULONG Len, PULONG Done,
            LPOVERLAPPED Olap)
{
    BOOL Status;

    Status = ReadFile(Port, Buffer, Len, Done, Olap);
    if (!Status)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            Status = GetOverlappedResult(Port, Olap, Done, TRUE);
        }
        else
        {
            DWORD TrashErr;
            COMSTAT TrashStat;
            
            // Device could be locked up.  Clear it just in case.
            ClearCommError(Port, &TrashErr, &TrashStat);
        }
    }

    return Status;
}

BOOL
ComPortWrite(HANDLE Port, PVOID Buffer, ULONG Len, PULONG Done,
             LPOVERLAPPED Olap)
{
    BOOL Status;

    Status = WriteFile(Port, Buffer, Len, Done, Olap);
    if (!Status)
    {
        if (GetLastError() == ERROR_IO_PENDING)
        {
            Status = GetOverlappedResult(Port, Olap, Done, TRUE);
        }
        else
        {
            DWORD TrashErr;
            COMSTAT TrashStat;
            
            // Device could be locked up.  Clear it just in case.
            ClearCommError(Port, &TrashErr, &TrashStat);
        }
    }

    return Status;
}

void
SetComPortName(PCSTR Name, PSTR Buffer)
{
    if (*Name == 'c' || *Name == 'C')
    {
        strcpy(Buffer, "\\\\.\\");
        strcpy(Buffer + 4, Name);
    }
    else if (*Name >= '0' && *Name <= '9')
    {
        PCSTR Scan = Name + 1;
        
        while (*Scan >= '0' && *Scan <= '9')
        {
            Scan++;
        }
        if (*Scan == 0)
        {
            // The name was all digits so assume it's
            // a plain com port number.
#ifndef NT_NATIVE
            strcpy(Buffer, "\\\\.\\com");
#else
            strcpy(Buffer, "\\Device\\Serial");
#endif
            strcat(Buffer, Name);
        }
        else
        {
            strcpy(Buffer, Name);
        }
    }
    else
    {
        strcpy(Buffer, Name);
    }
}

ULONG
SelectComPortBaud(ULONG NewRate)
{
#define NUM_RATES 4
    static DWORD s_Rates[NUM_RATES] = {19200, 38400, 57600, 115200};
    static DWORD s_CurRate = NUM_RATES;

    DWORD i;

    if (NewRate > 0)
    {
        for (i = 0; NewRate > s_Rates[i] && i < NUM_RATES - 1; i++)
        {
            // Empty.
        }
        s_CurRate = (NewRate < s_Rates[i]) ? i : i + 1;
    }
    else
    {
        s_CurRate++;
    }

    if (s_CurRate >= NUM_RATES)
    {
        s_CurRate = 0;
    }

    return s_Rates[s_CurRate];
}

HRESULT
SetComPortBaud(HANDLE Port, ULONG NewRate, PULONG RateSet)
{
    ULONG OldRate;
    DCB LocalDcb;

    if (Port == NULL)
    {
        return E_FAIL;
    }

    if (!GetCommState(Port, &LocalDcb))
    {
        return WIN32_LAST_STATUS();
    }

    OldRate = LocalDcb.BaudRate;

    if (!NewRate)
    {
        NewRate = SelectComPortBaud(OldRate);
    }

    LocalDcb.BaudRate = NewRate;
    LocalDcb.ByteSize = 8;
    LocalDcb.Parity = NOPARITY;
    LocalDcb.StopBits = ONESTOPBIT;
    LocalDcb.fDtrControl = DTR_CONTROL_ENABLE;
    LocalDcb.fRtsControl = RTS_CONTROL_ENABLE;
    LocalDcb.fBinary = TRUE;
    LocalDcb.fOutxCtsFlow = FALSE;
    LocalDcb.fOutxDsrFlow = FALSE;
    LocalDcb.fOutX = FALSE;
    LocalDcb.fInX = FALSE;

    if (!SetCommState(Port, &LocalDcb))
    {
        return WIN32_LAST_STATUS();
    }

    *RateSet = NewRate;
    return S_OK;
}

HRESULT
OpenComPort(PSTR Port, ULONG BaudRate, ULONG Timeout,
            PHANDLE Handle, PULONG BaudSet)
{
    HANDLE ComHandle;

#ifndef NT_NATIVE
    ComHandle = CreateFile(Port,
                           GENERIC_READ | GENERIC_WRITE,
                           0,
                           NULL,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                           NULL);
#else
    ComHandle = NtNativeCreateFileA(Port,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,
                                    OPEN_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL |
                                    FILE_FLAG_OVERLAPPED,
                                    NULL,
                                    FALSE);
#endif
    if (ComHandle == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }
    
    if (!SetupComm(ComHandle, 4096, 4096))
    {
        CloseHandle(ComHandle);
        return WIN32_LAST_STATUS();
    }

    HRESULT Status;
    
    if ((Status = SetComPortBaud(ComHandle, BaudRate, BaudSet)) != S_OK)
    {
        CloseHandle(ComHandle);
        return Status;
    }

    COMMTIMEOUTS To;
    
    if (Timeout)
    {
        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = 0;
        To.ReadTotalTimeoutConstant = Timeout;
        To.WriteTotalTimeoutMultiplier = 0;
        To.WriteTotalTimeoutConstant = Timeout;
    }
    else
    {
        To.ReadIntervalTimeout = 0;
        To.ReadTotalTimeoutMultiplier = 0xffffffff;
        To.ReadTotalTimeoutConstant = 0xffffffff;
        To.WriteTotalTimeoutMultiplier = 0xffffffff;
        To.WriteTotalTimeoutConstant = 0xffffffff;
    }

    if (!SetCommTimeouts(ComHandle, &To))
    {
        CloseHandle(ComHandle);
        return WIN32_LAST_STATUS();
    }

    *Handle = ComHandle;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// 1394.
//
//----------------------------------------------------------------------------

HRESULT
Create1394Channel(ULONG Channel, PSTR Name, PHANDLE Handle)
{
    char BusName[] = "\\\\.\\1394BUS0";
    HANDLE hDevice;
    
    //
    // we need to make sure the 1394vdbg driver is up and loaded.
    // send the ADD_DEVICE ioctl to eject the VDO
    // Assume one 1394 host controller...
    //

    hDevice = CreateFile(BusName,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );
    if (hDevice != INVALID_HANDLE_VALUE)
    {
        char DeviceId[] = "VIRTUAL_HOST_DEBUGGER";
        ULONG ulStrLen;
        PIEEE1394_API_REQUEST pApiReq;
        PIEEE1394_VDEV_PNP_REQUEST pDevPnpReq;
        DWORD dwBytesRet;
        
        ulStrLen = strlen(DeviceId) + 1;
        
        pApiReq = (PIEEE1394_API_REQUEST)
            malloc(sizeof(IEEE1394_API_REQUEST) + ulStrLen);
        if (pApiReq == NULL)
        {
            CloseHandle(hDevice);
            return E_OUTOFMEMORY;
        }

        pApiReq->RequestNumber = IEEE1394_API_ADD_VIRTUAL_DEVICE;
        pApiReq->Flags = IEEE1394_REQUEST_FLAG_PERSISTENT |
            IEEE1394_REQUEST_FLAG_USE_LOCAL_HOST_EUI;

        pDevPnpReq = &pApiReq->u.RemoveVirtualDevice;

        pDevPnpReq->fulFlags = 0;

        pDevPnpReq->Reserved = 0;
        pDevPnpReq->InstanceId.QuadPart = 0;
        strncpy((PSZ)&pDevPnpReq->DeviceId, DeviceId, ulStrLen);

        // Failure of this call is not fatal.
        DeviceIoControl( hDevice,
                         IOCTL_IEEE1394_API_REQUEST,
                         pApiReq,
                         sizeof(IEEE1394_API_REQUEST)+ulStrLen,
                         NULL,
                         0,
                         &dwBytesRet,
                         NULL
                         );

        if (pApiReq)
        {
            free(pApiReq);
        }
        
        CloseHandle(hDevice);
    }
    else
    {
        return WIN32_LAST_STATUS();
    }

    return Open1394Channel(Channel, Name, Handle);
}

HRESULT
Open1394Channel(ULONG Channel, PSTR Name, PHANDLE Handle)
{
    sprintf(Name, "\\\\.\\DBG1394_CHANNEL%02d", Channel);
    
    *Handle = CreateFile(Name,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL,
                         OPEN_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );
    if (*Handle == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsvc\dbgsvc.h ===
//----------------------------------------------------------------------------
//
// Low-level debugging service interfaces.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __DBGSVC_H__
#define __DBGSVC_H__

#include <stdarg.h>
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
//
// GUIDs and interface forward declarations.
//
//----------------------------------------------------------------------------

/* a7ba24c4-e4fb-4625-a8fc-b1cb1fd51f53 */
DEFINE_GUID(IID_IUserDebugServices, 0xa7ba24c4, 0xe4fb, 0x4625,
            0xa8, 0xfc, 0xb1, 0xcb, 0x1f, 0xd5, 0x1f, 0x53);

typedef interface DECLSPEC_UUID("a7ba24c4-e4fb-4625-a8fc-b1cb1fd51f53")
    IUserDebugServices* PUSER_DEBUG_SERVICES;
    
//----------------------------------------------------------------------------
//
// IUserDebugServices.
//
//----------------------------------------------------------------------------

// The service implementation does not implement Insert/RemoveCodeBreakpoints
// directly, instead it is the caller's responsibility to handle them
// via break instruction insertion and removal.
#define DBGSVC_GENERIC_CODE_BREAKPOINTS  0x00000001
// Handles returned in create process and create thread events
// are not automatically closed.  Instead it is the responsibility
// of the caller to close them when they are no longer needed.
#define DBGSVC_CLOSE_PROC_THREAD_HANDLES 0x00000002
    
// Handle to ULONG64 and back.
#define SERVICE_HANDLE(OsHandle) ((ULONG64)(OsHandle))
#define OS_HANDLE(SvcHandle) ((HANDLE)(ULONG_PTR)(SvcHandle))

typedef struct _USER_THREAD_INFO
{
    ULONG64 Handle;
    ULONG Id;
    ULONG Reserved;
} USER_THREAD_INFO, *PUSER_THREAD_INFO;
    
#undef INTERFACE
#define INTERFACE IUserDebugServices
DECLARE_INTERFACE_(IUserDebugServices, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IUserDebugServices.
    STDMETHOD(Initialize)(
        THIS_
        OUT PULONG Flags
        ) PURE;
    STDMETHOD(Uninitialize)(
        THIS_
        IN BOOL Global
        ) PURE;
    STDMETHOD(GetTargetInfo)(
        THIS_
        OUT PULONG MachineType,
        OUT PULONG NumberProcessors,
        OUT PULONG PlatformId,
        OUT PULONG BuildNumber,
        OUT PULONG CheckedBuild,
        OUT PSTR CsdString,
        IN ULONG CsdStringSize,
        OUT PSTR BuildString,
        IN ULONG BuildStringSize
        ) PURE;
    STDMETHOD(GetProcessorId)(
        THIS_
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT PULONG BufferUsed
        ) PURE;
    STDMETHOD(GetFileVersionInformation)(
        THIS_
        IN PCSTR File,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        ) PURE;

    STDMETHOD(GetProcessIds)(
        THIS_
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        ) PURE;
    STDMETHOD(GetProcessIdByExecutableName)(
        THIS_
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        ) PURE;
    STDMETHOD(GetProcessDescription)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        ) PURE;
    STDMETHOD(GetProcessInfo)(
        THIS_
        IN ULONG ProcessId,
        OUT OPTIONAL PULONG64 Handle,
        OUT OPTIONAL /* size_is(InfoCount) */ PUSER_THREAD_INFO Threads,
        IN ULONG InfoCount,
        OUT OPTIONAL PULONG ThreadCount
        ) PURE;
    
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG AttachFlags,
        OUT PULONG64 ProcessHandle,
        OUT PULONG ProcessOptions
        ) PURE;
    STDMETHOD(DetachProcess)(
        THIS_
        IN ULONG ProcessId
        ) PURE;
    STDMETHOD(CreateProcess)(
        THIS_
        IN PSTR CommandLine,
        IN ULONG CreateFlags,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT PULONG64 ProcessHandle,
        OUT PULONG64 ThreadHandle
        ) PURE;
    STDMETHOD(TerminateProcess)(
        THIS_
        IN ULONG64 Process,
        IN ULONG ExitCode
        ) PURE;
    STDMETHOD(AbandonProcess)(
        THIS_
        IN ULONG64 Process
        ) PURE;
    STDMETHOD(GetProcessExitCode)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG ExitCode
        ) PURE;
    STDMETHOD(CloseHandle)(
        THIS_
        IN ULONG64 Handle
        ) PURE;
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG64 Process,
        IN ULONG Options
        ) PURE;
    STDMETHOD(SetDebugObjectOptions)(
        THIS_
        IN ULONG64 DebugObject,
        IN ULONG Options
        ) PURE;
    STDMETHOD(GetProcessDebugObject)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 DebugObject
        ) PURE;
    STDMETHOD(DuplicateHandle)(
        THIS_
        IN ULONG64 InProcess,
        IN ULONG64 InHandle,
        IN ULONG64 OutProcess,
        IN ULONG DesiredAccess,
        IN ULONG Inherit,
        IN ULONG Options,
        OUT PULONG64 OutHandle
        ) PURE;
        
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        ) PURE;
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        ) PURE;
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        ) PURE;
    STDMETHOD(ProtectVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG NewProtect,
        OUT PULONG OldProtect
        ) PURE;
    STDMETHOD(AllocVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type,
        IN ULONG Protect,
        OUT PULONG64 AllocOffset
        ) PURE;
    STDMETHOD(FreeVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type
        ) PURE;
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        ) PURE;

    STDMETHOD(SuspendThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        ) PURE;
    STDMETHOD(ResumeThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        ) PURE;

    STDMETHOD(GetContext)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Flags,
        IN ULONG FlagsOffset,
        OUT PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        ) PURE;
    STDMETHOD(SetContext)(
        THIS_
        IN ULONG64 Thread,
        IN PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        ) PURE;

    STDMETHOD(GetProcessDataOffset)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetThreadDataOffset)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Offset
        ) PURE;
    
    STDMETHOD(DescribeSelector)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Selector,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        ) PURE;

    STDMETHOD(GetCurrentTimeDateN)(
        THIS_
        OUT PULONG64 TimeDate
        ) PURE;
    STDMETHOD(GetCurrentSystemUpTimeN)(
        THIS_
        OUT PULONG64 UpTime
        ) PURE;
    STDMETHOD(GetProcessUpTimeN)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 UpTime
        ) PURE;

    STDMETHOD(RequestBreakIn)(
        THIS_
        IN ULONG64 Process
        ) PURE;

    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Timeout,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        ) PURE;
    STDMETHOD(ContinueEvent)(
        THIS_
        IN ULONG ContinueStatus
        ) PURE;

    STDMETHOD(InsertCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        OUT PVOID Storage,
        IN ULONG StorageSize
        ) PURE;
    STDMETHOD(RemoveCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        IN PVOID Storage,
        IN ULONG StorageSize
        ) PURE;

    STDMETHOD(GetFunctionTableListHead)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        ) PURE;
    STDMETHOD(GetOutOfProcessFunctionTable)(
        THIS_
        IN ULONG64 Process,
        IN PSTR Dll,
        IN ULONG64 Table,
        IN OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TableSize
        ) PURE;
};

#ifdef __cplusplus
};
#endif

#endif // #ifndef __DBGSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgrpc\schan.cpp ===
//----------------------------------------------------------------------------
//
// Secure channel support.
// Code lifted from the SDK sample security\ssl.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

HMODULE g_hSecurity;
SecurityFunctionTable g_SecurityFunc;

HCERTSTORE g_hMyCertStore;

enum
{
    SEQ_INTERNAL = 0xffffff00
};

//----------------------------------------------------------------------------
//
// Basic schannel support functions.
//
//----------------------------------------------------------------------------

void
DbgDumpBuffers(PCSTR Name, SecBufferDesc* Desc)
{
#if 0
    ULONG i;
    
    g_NtDllCalls.DbgPrint("%s desc %p has %d buffers\n",
                          Name, Desc, Desc->cBuffers);
    for (i = 0; i < Desc->cBuffers; i++)
    {
        g_NtDllCalls.DbgPrint("  type %d, %X bytes at %p\n",
                              Desc->pBuffers[i].BufferType,
                              Desc->pBuffers[i].cbBuffer,
                              Desc->pBuffers[i].pvBuffer);
    }
#endif
}

#if 0
#define DSCHAN(Args) g_NtDllCalls.DbgPrint Args
#define DumpBuffers(Name, Desc) DbgDumpBuffers(Name, Desc)
#else
#define DSCHAN(Args)
#define DumpBuffers(Name, Desc)
#endif

#if 0
#define DSCHAN_IO(Args) g_NtDllCalls.DbgPrint Args
#define DumpBuffersIo(Name, Desc) DbgDumpBuffers(Name, Desc)
#else
#define DSCHAN_IO(Args)
#define DumpBuffersIo(Name, Desc)
#endif

HRESULT
LoadSecurityLibrary(void)
{
    HRESULT Status;

    if ((Status = InitDynamicCalls(&g_Crypt32CallsDesc)) != S_OK)
    {
        return Status;
    }
    
    PSecurityFunctionTable  pSecurityFunc;
    INIT_SECURITY_INTERFACE pInitSecurityInterface;

    if (g_hSecurity != NULL)
    {
        // Already loaded.
        return S_OK;
    }

    if (g_Crypt32Calls.CertOpenStore == NULL)
    {
        // Unable to load crypt32.dll.
        return HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
    }
    
    g_hSecurity = LoadLibrary("security.dll");
    if (g_hSecurity == NULL)
    {
        goto EH_Fail;
    }

    pInitSecurityInterface = (INIT_SECURITY_INTERFACE)
        GetProcAddress(g_hSecurity, "InitSecurityInterfaceA");
    if (pInitSecurityInterface == NULL)
    {
        goto EH_Dll;
    }

    pSecurityFunc = pInitSecurityInterface();
    if (pSecurityFunc == NULL)
    {
        goto EH_Dll;
    }

    memcpy(&g_SecurityFunc, pSecurityFunc, sizeof(g_SecurityFunc));

    return S_OK;

 EH_Dll:
    FreeLibrary(g_hSecurity);
    g_hSecurity = NULL;
 EH_Fail:
    return WIN32_LAST_STATUS();
}

HRESULT
CreateCredentials(LPSTR pszUserName,
                  BOOL fMachineStore,
                  BOOL Server,
                  ULONG dwProtocol,
                  SCHANNEL_CRED* ScCreds,
                  PCredHandle phCreds)
{
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;
    PCCERT_CONTEXT  pCertContext = NULL;

    // Open the "MY" certificate store.
    if (g_hMyCertStore == NULL)
    {
        if (fMachineStore)
        {
            g_hMyCertStore = g_Crypt32Calls.
                CertOpenStore(CERT_STORE_PROV_SYSTEM,
                              X509_ASN_ENCODING,
                              0,
                              CERT_SYSTEM_STORE_LOCAL_MACHINE,
                              L"MY");
        }
        else
        {
            g_hMyCertStore = g_Crypt32Calls.
                CertOpenSystemStore(0, "MY");
        }

        if (!g_hMyCertStore)
        {
            Status = WIN32_LAST_STATUS();
            goto Exit;
        }
    }

    //
    // If a user name is specified, then attempt to find a client
    // certificate. Otherwise, just create a NULL credential.
    //

    if (pszUserName != NULL && *pszUserName)
    {
        // Find certificate. Note that this sample just searches for a 
        // certificate that contains the user name somewhere in the subject
        // name.  A real application should be a bit less casual.
        pCertContext = g_Crypt32Calls.
            CertFindCertificateInStore(g_hMyCertStore, 
                                       X509_ASN_ENCODING, 
                                       0,
                                       CERT_FIND_SUBJECT_STR_A,
                                       pszUserName,
                                       NULL);
        if (pCertContext == NULL)
        {
            Status = WIN32_LAST_STATUS();
            goto Exit;
        }
    }


    //
    // Build Schannel credential structure. Currently, this sample only
    // specifies the protocol to be used (and optionally the certificate, 
    // of course). Real applications may wish to specify other parameters 
    // as well.
    //

    ZeroMemory(ScCreds, sizeof(*ScCreds));

    ScCreds->dwVersion = SCHANNEL_CRED_VERSION;

    if (pCertContext != NULL)
    {
        ScCreds->cCreds = 1;
        ScCreds->paCred = &pCertContext;
    }

    ScCreds->grbitEnabledProtocols = dwProtocol;

    if (!Server)
    {
        if (pCertContext != NULL)
        {
            ScCreds->dwFlags |= SCH_CRED_NO_DEFAULT_CREDS;
        }
        else
        {
            ScCreds->dwFlags |= SCH_CRED_USE_DEFAULT_CREDS;
        }
        ScCreds->dwFlags |= SCH_CRED_MANUAL_CRED_VALIDATION;
    }


    //
    // Create an SSPI credential.
    //

    //
    // NOTE: In theory, an application could enumerate the security packages 
    // until it finds one with attributes it likes. Some applications 
    // (such as IIS) enumerate the packages and call AcquireCredentialsHandle 
    // on each until it finds one that accepts the SCHANNEL_CRED structure. 
    // If an application has its heart set on using SSL, like this sample
    // does, then just hardcoding the UNISP_NAME package name when calling 
    // AcquireCredentialsHandle is not a bad thing.
    //

    Status = g_SecurityFunc.AcquireCredentialsHandle(
                        NULL,                   // Name of principal
                        UNISP_NAME_A,           // Name of package
                        Server ?                // Flags indicating use
                        SECPKG_CRED_INBOUND :
                        SECPKG_CRED_OUTBOUND,
                        NULL,                   // Pointer to logon ID
                        ScCreds,                // Package specific data
                        NULL,                   // Pointer to GetKey() func
                        NULL,                   // Value to pass to GetKey()
                        phCreds,                // (out) Cred Handle
                        &tsExpiry);             // (out) Lifetime (optional)

    //
    // Free the certificate context. Schannel has already made its own copy.
    //

    if (pCertContext)
    {
        g_Crypt32Calls.CertFreeCertificateContext(pCertContext);
    }

 Exit:
    DSCHAN(("CreateCredentials returns %X\n", Status));
    return Status;
}

HRESULT
VerifyRemoteCertificate(PCtxtHandle Context,
                        PSTR pszServerName,
                        DWORD dwCertFlags)
{
    SSL_EXTRA_CERT_CHAIN_POLICY_PARA SslPara;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChain = NULL;
    PCCERT_CONTEXT pCert = NULL;
    HRESULT Status;
    PWSTR pwszServerName;
    DWORD cchServerName;
    
    // Read the remote certificate.
    if ((Status = g_SecurityFunc.
         QueryContextAttributes(Context,
                                SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                &pCert)) != S_OK)
    {
        goto Exit;
    }

    if (pCert == NULL)
    {
        Status = SEC_E_WRONG_PRINCIPAL;
        goto EH_Cert;
    }

    if (pszServerName != NULL && *pszServerName)
    {
        //
        // Convert server name to unicode.
        //

        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName,
                                            -1, NULL, 0);
        pwszServerName = (PWSTR)
            LocalAlloc(LMEM_FIXED, cchServerName * sizeof(WCHAR));
        if (pwszServerName == NULL)
        {
            Status = SEC_E_INSUFFICIENT_MEMORY;
            goto EH_Cert;
        }
        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName,
                                            -1, pwszServerName, cchServerName);
        if (cchServerName == 0)
        {
            Status = SEC_E_WRONG_PRINCIPAL;
            goto EH_Name;
        }
    }
    else
    {
        pwszServerName = NULL;
    }

    //
    // Build certificate chain.
    //

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    if (!g_Crypt32Calls.CertGetCertificateChain(NULL,
                                                pCert,
                                                NULL,
                                                pCert->hCertStore,
                                                &ChainPara,
                                                0,
                                                NULL,
                                                &pChain))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Name;
    }


    //
    // Validate certificate chain.
    // 

    ZeroMemory(&SslPara, sizeof(SslPara));
    SslPara.cbStruct           = sizeof(SslPara);
    SslPara.dwAuthType         = pwszServerName == NULL ?
        AUTHTYPE_CLIENT : AUTHTYPE_SERVER;
    SslPara.fdwChecks          = dwCertFlags;
    SslPara.pwszServerName     = pwszServerName;

    ZeroMemory(&PolicyPara, sizeof(PolicyPara));
    PolicyPara.cbSize = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &SslPara;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if (!g_Crypt32Calls.CertVerifyCertificateChainPolicy(CERT_CHAIN_POLICY_SSL,
                                                         pChain,
                                                         &PolicyPara,
                                                         &PolicyStatus))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Chain;
    }

    if (PolicyStatus.dwError)
    {
        Status = PolicyStatus.dwError;
    }
    else
    {
        Status = S_OK;
    }

 EH_Chain:
    g_Crypt32Calls.CertFreeCertificateChain(pChain);
 EH_Name:
    if (pwszServerName != NULL)
    {
        LocalFree(pwszServerName);
    }
 EH_Cert:
    g_Crypt32Calls.CertFreeCertificateContext(pCert);
 Exit:
    DSCHAN(("VerifyRemoteCertificate returns %X\n", Status));
    return Status;
}

//----------------------------------------------------------------------------
//
// Schannel wrapper transport.
//
//----------------------------------------------------------------------------

#define SecHandleIsValid(Handle) \
    ((Handle)->dwLower != -1 || (Handle)->dwUpper != -1)

DbgRpcSecureChannelTransport::
DbgRpcSecureChannelTransport(ULONG ThisTransport,
                             ULONG BaseTransport)
{
    m_Name = g_DbgRpcTransportNames[ThisTransport];
    m_ThisTransport = ThisTransport;
    m_BaseTransport = BaseTransport;
    m_Stream = NULL;
    SecInvalidateHandle(&m_Creds);
    m_OwnCreds = FALSE;
    SecInvalidateHandle(&m_Context);
    m_OwnContext = FALSE;
    m_BufferUsed = 0;
    m_Server = FALSE;
}

DbgRpcSecureChannelTransport::~DbgRpcSecureChannelTransport(void)
{
    if (SecHandleIsValid(&m_Context))
    {
        if (m_Server)
        {
            DisconnectFromClient();
        }
        else
        {
            DisconnectFromServer();
        }
    }
    
    delete m_Stream;
    if (m_OwnContext && SecHandleIsValid(&m_Context))
    {
        g_SecurityFunc.DeleteSecurityContext(&m_Context);
    }
    if (m_OwnCreds && SecHandleIsValid(&m_Creds))
    {
        g_SecurityFunc.FreeCredentialsHandle(&m_Creds);
    }
}

ULONG
DbgRpcSecureChannelTransport::GetNumberParameters(void)
{
    return 2 + (m_Stream != NULL ? m_Stream->GetNumberParameters() : 0);
}

void
DbgRpcSecureChannelTransport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        if (m_Protocol)
        {
            strcpy(Name, "Proto");
            switch(m_Protocol)
            {
            case SP_PROT_PCT1:
                strcpy(Name, "PCT1");
                break;
            case SP_PROT_SSL2:
                strcpy(Name, "SSL2");
                break;
            case SP_PROT_SSL3:
                strcpy(Name, "SSL3");
                break;
            case SP_PROT_TLS1:
                strcpy(Name, "TLS1");
                break;
            }
        }
        break;
    case 1:
        if (m_User[0])
        {
            strcpy(Name, m_MachineStore ? "MachUser" : "CertUser");
            strcpy(Value, m_User);
        }
        break;
    default:
        if (m_Stream != NULL)
        {
            m_Stream->GetParameter(Index - 2, Name, Value);
        }
        break;
    }
}

void
DbgRpcSecureChannelTransport::ResetParameters(void)
{
    m_Protocol = 0;
    m_User[0] = 0;
    m_MachineStore = FALSE;

    if (m_Stream == NULL)
    {
        m_Stream = DbgRpcNewTransport(m_BaseTransport);
    }
    
    if (m_Stream != NULL)
    {
        m_Stream->ResetParameters();
    }
}

BOOL
DbgRpcSecureChannelTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (m_Stream == NULL)
    {
        // Force all initialization to fail.
        return FALSE;
    }
    
    if (!_stricmp(Name, "proto"))
    {
        if (Value == NULL)
        {
            DbgRpcError("%s parameters: "
                        "the protocol name was not specified correctly\n",
                        m_Name);
            return FALSE;
        }

        if (!_stricmp(Value, "pct1"))
        {
            m_Protocol = SP_PROT_PCT1;
        }
        else if (!_stricmp(Value, "ssl2"))
        {
            m_Protocol = SP_PROT_SSL2;
        }
        else if (!_stricmp(Value, "ssl3"))
        {
            m_Protocol = SP_PROT_SSL3;
        }
        else if (!_stricmp(Value, "tls1"))
        {
            m_Protocol = SP_PROT_TLS1;
        }
        else
        {
            DbgRpcError("%s parameters: unknown protocol '%s'\n", Value,
                        m_Name);
            return FALSE;
        }
    }
    else if (!_stricmp(Name, "machuser"))
    {
        if (Value == NULL)
        {
            DbgRpcError("%s parameters: "
                        "the user name was not specified correctly\n",
                        m_Name);
            return FALSE;
        }

        m_User[0] = 0;
        strncat(m_User, Value, sizeof(m_User) - 1);
        m_MachineStore = TRUE;
    }
    else if (!_stricmp(Name, "certuser"))
    {
        if (Value == NULL)
        {
            DbgRpcError("%s parameters: "
                        "the user name was not specified correctly\n",
                        m_Name);
            return FALSE;
        }

        m_User[0] = 0;
        strncat(m_User, Value, sizeof(m_User) - 1);
        m_MachineStore = FALSE;
    }
    else
    {
        if (!m_Stream->SetParameter(Name, Value))
        {
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcSecureChannelTransport::Clone(void)
{
    DbgRpcTransport* Stream = m_Stream->Clone();
    if (Stream == NULL)
    {
        return NULL;
    }
    DbgRpcSecureChannelTransport* Trans =
        new DbgRpcSecureChannelTransport(m_ThisTransport, m_BaseTransport);
    if (Trans != NULL)
    {
        Trans->m_Stream = Stream;
        Trans->m_Creds = m_Creds;
        Trans->m_OwnCreds = FALSE;
        Trans->m_Context = m_Context;
        Trans->m_OwnContext = FALSE;
        Trans->m_Protocol = m_Protocol;
        strcpy(Trans->m_User, m_User);
        Trans->m_MachineStore = m_MachineStore;
        Trans->m_Sizes = m_Sizes;
        Trans->m_MaxChunk = m_MaxChunk;
        Trans->m_Server = m_Server;
    }
    else
    {
        delete Stream;
    }
    return Trans;
}

HRESULT
DbgRpcSecureChannelTransport::CreateServer(void)
{
    HRESULT Status;

    if ((Status = LoadSecurityLibrary()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateCredentials(m_User, m_MachineStore, TRUE,
                                    m_Protocol, &m_ScCreds, &m_Creds)) != S_OK)
    {
        return Status;
    }
    m_OwnCreds = TRUE;

    if ((Status = m_Stream->CreateServer()) != S_OK)
    {
        return Status;
    }

    m_Server = TRUE;
    return S_OK;
}

HRESULT
DbgRpcSecureChannelTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                               PSTR Identity)
{
    HRESULT Status;
    DbgRpcTransport* Stream;
    
    if ((Status = m_Stream->AcceptConnection(&Stream, Identity)) != S_OK)
    {
        return Status;
    }
    DbgRpcSecureChannelTransport* Trans =
        new DbgRpcSecureChannelTransport(m_ThisTransport, m_BaseTransport);
    if (Trans == NULL)
    {
        delete Stream;
        return E_OUTOFMEMORY;
    }
    Trans->m_Stream = Stream;
    Trans->m_Creds = m_Creds;
    Trans->m_OwnCreds = FALSE;
    Trans->m_Server = TRUE;

    if ((Status = Trans->AuthenticateClientConnection()) != S_OK)
    {
        goto EH_Trans;
    }

    if ((Status = Trans->GetSizes()) != S_OK)
    {
        goto EH_Trans;
    }
    
    // Attempt to validate client certificate.
    if ((Status = VerifyRemoteCertificate(&Trans->m_Context, NULL, 0)) != S_OK)
    {
        goto EH_Trans;
    }

    *ClientTrans = Trans;
    return S_OK;

 EH_Trans:
    delete Trans;
    return Status;
}

HRESULT
DbgRpcSecureChannelTransport::ConnectServer(void)
{
    HRESULT Status = m_Stream->ConnectServer();
    if (Status != S_OK)
    {
        return Status;
    }

    if ((Status = LoadSecurityLibrary()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateCredentials(m_User, m_MachineStore, FALSE,
                                    m_Protocol, &m_ScCreds, &m_Creds)) != S_OK)
    {
        return Status;
    }
    m_OwnCreds = TRUE;

    if ((Status = InitiateServerConnection(m_Stream->m_ServerName)) != S_OK)
    {
        return Status;
    }

    if ((Status = AuthenticateServerConnection()) != S_OK)
    {
        return Status;
    }

    if ((Status = GetSizes()) != S_OK)
    {
        return Status;
    }
    
    // Attempt to validate server certificate.
    if ((Status = VerifyRemoteCertificate(&m_Context,
                                          m_Stream->m_ServerName, 0)) != S_OK)
    {
        // If this fails with CERT_E_CN_NO_MATCH it's most
        // likely that the server name wasn't given as a fully
        // qualified machine name.  We may just want to ignore that error.
        return Status;
    }

    return S_OK;
}

ULONG
DbgRpcSecureChannelTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    SecBufferDesc Message;
    SecBuffer Buffers[4];
    DWORD Status;
    ULONG Complete;

    DSCHAN_IO(("Start read(%X) with %X bytes cached\n",
               Len, m_BufferUsed));
    
    //
    // Initialize security buffer structs
    //

    Message.ulVersion = SECBUFFER_VERSION;
    Message.cBuffers = 4;
    Message.pBuffers = Buffers;

    //
    // Receive the data from the client.
    //

    Complete = 0;

    while (Complete < Len)
    {
        do
        {
            // Pass in the data we have so far.
            Buffers[0].pvBuffer = m_Buffer;
            Buffers[0].cbBuffer = m_BufferUsed;
            Buffers[0].BufferType = SECBUFFER_DATA;

            // Provide extra buffers for header, trailer
            // and possibly extra data.
            Buffers[1].BufferType = SECBUFFER_EMPTY;
            Buffers[2].BufferType = SECBUFFER_EMPTY;
            Buffers[3].BufferType = SECBUFFER_EMPTY;

            Status = g_SecurityFunc.DecryptMessage(&m_Context, &Message,
                                                   Seq, NULL);
            
            DSCHAN_IO(("Read DecryptMessage on %X bytes returns %X\n",
                       m_BufferUsed, Status));
            DumpBuffersIo("Read", &Message);
            
            if (Status == SEC_E_INCOMPLETE_MESSAGE)
            {
                DSCHAN_IO(("  Missing %X bytes\n", Buffers[1].cbBuffer));

                ULONG Read = StreamRead(Seq, m_Buffer + m_BufferUsed,
                                        sizeof(m_Buffer) - m_BufferUsed);
                if (Read == 0)
                {
                    return Complete;
                }

                m_BufferUsed += Read;
            }
            else if (Status == SEC_I_RENEGOTIATE)
            {
                // The server wants to perform another handshake
                // sequence.

                if ((Status = AuthenticateServerConnection()) != S_OK)
                {
                    break;
                }
            }
        }
        while (Status == SEC_E_INCOMPLETE_MESSAGE);

        if (Status != S_OK)
        {
            break;
        }

        // Buffers 0,1,2 should be header, data, trailer.
        DBG_ASSERT(Buffers[1].BufferType == SECBUFFER_DATA);

        DSCHAN_IO(("  %X bytes of %X read\n",
                   Buffers[1].cbBuffer, Len));
        
        memcpy((PUCHAR)Buffer + Complete,
               Buffers[1].pvBuffer, Buffers[1].cbBuffer);
        Complete += Buffers[1].cbBuffer;

        // Check for extra data in buffer 3.
        if (Buffers[3].BufferType == SECBUFFER_EXTRA)
        {
            DSCHAN_IO(("  %X bytes extra\n"));
            
            memmove(m_Buffer, Buffers[3].pvBuffer, Buffers[3].cbBuffer);
            m_BufferUsed = Buffers[3].cbBuffer;
        }
        else
        {
            m_BufferUsed = 0;
        }
    }

    DSCHAN_IO(("  Read returns %X bytes\n", Complete));
    return Complete;
}

ULONG
DbgRpcSecureChannelTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    SecBufferDesc Message;
    SecBuffer Buffers[3];
    DWORD Status;
    ULONG Complete;

    DSCHAN_IO(("Start write(%X) with %X bytes cached\n",
               Len, m_BufferUsed));
    
    Message.ulVersion = SECBUFFER_VERSION;
    Message.cBuffers = 3;
    Message.pBuffers = Buffers;

    Complete = 0;
    
    while (Complete < Len)
    {
        ULONG Chunk;
        
        //
        // Set up header, data and trailer buffers so
        // that EncryptMessage has room for everything
        // in one contiguous buffer.
        //

        Buffers[0].pvBuffer = m_Buffer + m_BufferUsed;
        Buffers[0].cbBuffer = m_Sizes.cbHeader;
        Buffers[0].BufferType = SECBUFFER_STREAM_HEADER;

        //
        // Data is encrypted in-place so copy data
        // from the user's buffer into the working buffer.
        // Part of the working buffer may be taken up
        // by queued data so work with what's left.
        //
        
        if (Len > m_MaxChunk - m_BufferUsed)
        {
            Chunk = m_MaxChunk - m_BufferUsed;
        }
        else
        {
            Chunk = Len;
        }

        DSCHAN_IO(("  write %X bytes of %X\n", Chunk, Len));
        
        Buffers[1].pvBuffer =
            (PUCHAR)Buffers[0].pvBuffer + Buffers[0].cbBuffer;
        Buffers[1].cbBuffer = Chunk;
        Buffers[1].BufferType = SECBUFFER_DATA;
        memcpy(Buffers[1].pvBuffer, (PUCHAR)Buffer + Complete, Chunk);
    
        Buffers[2].pvBuffer =
            (PUCHAR)Buffers[1].pvBuffer + Buffers[1].cbBuffer;
        Buffers[2].cbBuffer = m_Sizes.cbTrailer;
        Buffers[2].BufferType = SECBUFFER_STREAM_TRAILER;

        Status = g_SecurityFunc.EncryptMessage(&m_Context, 0, &Message, Seq);
        if (Status != S_OK)
        {
            break;
        }

        DumpBuffersIo("Write encrypt", &Message);
        
        ULONG Total, Written;
        
        Total = Buffers[0].cbBuffer + Buffers[1].cbBuffer +
            Buffers[2].cbBuffer;
        Written = StreamWrite(Seq, Buffers[0].pvBuffer, Total);
        if (Written != Total)
        {
            break;
        }

        Complete += Chunk;
    }

    DSCHAN_IO(("  Write returns %X bytes\n", Complete));
    return Complete;
}

HRESULT
DbgRpcSecureChannelTransport::GetSizes(void)
{
    HRESULT Status;
    
    //
    // Find out how big the header will be:
    //
    
    if ((Status = g_SecurityFunc.
         QueryContextAttributes(&m_Context, SECPKG_ATTR_STREAM_SIZES,
                                &m_Sizes)) != S_OK)
    {
        return Status;
    }

    // Compute the largest chunk that can be encrypted at
    // once in the transport's data buffer.
    m_MaxChunk = sizeof(m_Buffer) - (m_Sizes.cbHeader + m_Sizes.cbTrailer);
    if (m_MaxChunk > m_Sizes.cbMaximumMessage)
    {
        m_MaxChunk = m_Sizes.cbMaximumMessage;
    }

    return S_OK;
}
    
HRESULT
DbgRpcSecureChannelTransport::AuthenticateClientConnection(void)
{
    TimeStamp            tsExpiry;
    SECURITY_STATUS      Status;
    SecBufferDesc        InBuffer;
    SecBufferDesc        OutBuffer;
    SecBuffer            InBuffers[2];
    SecBuffer            OutBuffers[1];
    BOOL                 fInitContext = TRUE;
    DWORD                dwSSPIFlags, dwSSPIOutFlags;
    ULONG                Seq;

    Status = SEC_E_SECPKG_NOT_FOUND; //default error if we run out of packages

    dwSSPIFlags = ASC_REQ_SEQUENCE_DETECT     |
                  ASC_REQ_REPLAY_DETECT       |
                  ASC_REQ_CONFIDENTIALITY     |
                  ASC_REQ_EXTENDED_ERROR      |
                  ASC_REQ_ALLOCATE_MEMORY     |
                  ASC_REQ_STREAM              |
                  ASC_REQ_MUTUAL_AUTH;

    //
    // Set buffers for AcceptSecurityContext call
    //

    InBuffer.cBuffers = 2;
    InBuffer.pBuffers = InBuffers;
    InBuffer.ulVersion = SECBUFFER_VERSION;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = SEC_I_CONTINUE_NEEDED;
    m_BufferUsed = 0;

    while ( Status == SEC_I_CONTINUE_NEEDED ||
            Status == SEC_E_INCOMPLETE_MESSAGE ||
            Status == SEC_I_INCOMPLETE_CREDENTIALS) 
    {
        if (0 == m_BufferUsed || Status == SEC_E_INCOMPLETE_MESSAGE)
        {
            ULONG Read = StreamRead(SEQ_INTERNAL, m_Buffer + m_BufferUsed,
                                    sizeof(m_Buffer) - m_BufferUsed);
            if (Read == 0)
            {
                Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
                goto Exit;
            }
            else
            {
                m_BufferUsed += Read;
            }
        }


        //
        // InBuffers[1] is for getting extra data that
        //  SSPI/SCHANNEL doesn't proccess on this
        //  run around the loop.
        //

        InBuffers[0].pvBuffer = m_Buffer;
        InBuffers[0].cbBuffer = m_BufferUsed;
        InBuffers[0].BufferType = SECBUFFER_TOKEN;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;


        //
        // Initialize these so if we fail, pvBuffer contains NULL,
        // so we don't try to free random garbage at the quit
        //

        OutBuffers[0].pvBuffer   = NULL;
        OutBuffers[0].cbBuffer   = 0;
        OutBuffers[0].BufferType = SECBUFFER_TOKEN;

        Status = g_SecurityFunc.AcceptSecurityContext(
                        &m_Creds,
                        (fInitContext ? NULL : &m_Context),
                        &InBuffer,
                        dwSSPIFlags,
                        SECURITY_NATIVE_DREP,
                        (fInitContext ? &m_Context : NULL),
                        &OutBuffer,
                        &dwSSPIOutFlags,
                        &tsExpiry);

        DSCHAN(("ASC on %X bytes returns %X\n",
                m_BufferUsed, Status));
        DumpBuffers("ASC in", &InBuffer);
        DumpBuffers("ASC out", &OutBuffer);

        if (SUCCEEDED(Status))
        {
            fInitContext = FALSE;
            m_OwnContext = TRUE;
        }

        if ( Status == SEC_E_OK ||
             Status == SEC_I_CONTINUE_NEEDED ||
             (FAILED(Status) &&
              (0 != (dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR))))
        {
            if  (OutBuffers[0].cbBuffer != 0    &&
                 OutBuffers[0].pvBuffer != NULL )
            {
                ULONG Written;
                
                DSCHAN(("  write back %X bytes\n", OutBuffers[0].cbBuffer));
                
                //
                // Send response to server if there is one
                //
                Written = StreamWrite(SEQ_INTERNAL, OutBuffers[0].pvBuffer,
                                      OutBuffers[0].cbBuffer);

                g_SecurityFunc.FreeContextBuffer( OutBuffers[0].pvBuffer );
                OutBuffers[0].pvBuffer = NULL;

                if (Written != OutBuffers[0].cbBuffer)
                {
                    Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
                    goto Exit;
                }
            }
        }


        if ( Status == SEC_E_OK )
        {
            if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
            {
                DSCHAN_IO(("  ASC returns with %X extra bytes\n",
                           InBuffers[1].cbBuffer));
                
                memmove(m_Buffer,
                        m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                        InBuffers[1].cbBuffer);
                m_BufferUsed = InBuffers[1].cbBuffer;
            }
            else
            {
                m_BufferUsed = 0;
            }

            goto Exit;
        }
        else if (FAILED(Status) && (Status != SEC_E_INCOMPLETE_MESSAGE))
        {
            goto Exit;
        }

        if ( Status != SEC_E_INCOMPLETE_MESSAGE &&
             Status != SEC_I_INCOMPLETE_CREDENTIALS)
        {
            if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
            {
                DSCHAN_IO(("  ASC loops with %X extra bytes\n",
                           InBuffers[1].cbBuffer));
                
                memmove(m_Buffer,
                        m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                        InBuffers[1].cbBuffer);
                m_BufferUsed = InBuffers[1].cbBuffer;
            }
            else
            {
                //
                // prepare for next receive
                //

                m_BufferUsed = 0;
            }
        }
    }

 Exit:
    DSCHAN(("AuthClient returns %X\n", Status));
    return Status;
}

HRESULT
DbgRpcSecureChannelTransport::InitiateServerConnection(LPSTR pszServerName)
{
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;
    DWORD           cbData;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM            |
                  ISC_REQ_MUTUAL_AUTH;

    //
    //  Initiate a ClientHello message and generate a token.
    //

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.InitializeSecurityContextA(
                    &m_Creds,
                    NULL,
                    pszServerName,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,
                    &m_Context,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);

    DSCHAN(("First ISC returns %X\n", Status));
    DumpBuffers("First ISC out", &OutBuffer);
            
    if (Status != SEC_I_CONTINUE_NEEDED)
    {
        goto Exit;
    }

    m_OwnContext = TRUE;
    
    // Send response to server if there is one.
    if (OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
    {
        DSCHAN(("  write back %X bytes\n", OutBuffers[0].cbBuffer));
                
        cbData = StreamWrite(SEQ_INTERNAL, OutBuffers[0].pvBuffer,
                             OutBuffers[0].cbBuffer);
        if(cbData == 0)
        {
            g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
            if (m_OwnContext)
            {
                g_SecurityFunc.DeleteSecurityContext(&m_Context);
                SecInvalidateHandle(&m_Context);
            }
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto Exit;
        }

        // Free output buffer.
        g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
        OutBuffers[0].pvBuffer = NULL;
    }

    Status = S_OK;

 Exit:
    DSCHAN(("InitServer returns %X\n", Status));
    return Status;
}

HRESULT
DbgRpcSecureChannelTransport::AuthenticateServerConnection(void)
{
    SecBufferDesc   InBuffer;
    SecBuffer       InBuffers[2];
    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;
    DWORD           cbData;
    ULONG           ReadNeeded;

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

    m_BufferUsed = 0;
    ReadNeeded = 1;


    // 
    // Loop until the handshake is finished or an error occurs.
    //

    Status = SEC_I_CONTINUE_NEEDED;

    while(Status == SEC_I_CONTINUE_NEEDED        ||
          Status == SEC_E_INCOMPLETE_MESSAGE     ||
          Status == SEC_I_INCOMPLETE_CREDENTIALS) 
    {

        //
        // Read data from server.
        //

        if (0 == m_BufferUsed || Status == SEC_E_INCOMPLETE_MESSAGE)
        {
            if (ReadNeeded > 0)
            {
                cbData = StreamRead(SEQ_INTERNAL, m_Buffer + m_BufferUsed,
                                    sizeof(m_Buffer) - m_BufferUsed);
                if(cbData == 0)
                {
                    Status = HRESULT_FROM_WIN32(ERROR_READ_FAULT);
                    break;
                }

                m_BufferUsed += cbData;
            }
            else
            {
                ReadNeeded = 1;
            }
        }


        //
        // Set up the input buffers. Buffer 0 is used to pass in data
        // received from the server. Schannel will consume some or all
        // of this. Leftover data (if any) will be placed in buffer 1 and
        // given a buffer type of SECBUFFER_EXTRA.
        //

        InBuffers[0].pvBuffer   = m_Buffer;
        InBuffers[0].cbBuffer   = m_BufferUsed;
        InBuffers[0].BufferType = SECBUFFER_TOKEN;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        InBuffer.cBuffers       = 2;
        InBuffer.pBuffers       = InBuffers;
        InBuffer.ulVersion      = SECBUFFER_VERSION;

        //
        // Set up the output buffers. These are initialized to NULL
        // so as to make it less likely we'll attempt to free random
        // garbage later.
        //

        OutBuffers[0].pvBuffer  = NULL;
        OutBuffers[0].BufferType= SECBUFFER_TOKEN;
        OutBuffers[0].cbBuffer  = 0;

        OutBuffer.cBuffers      = 1;
        OutBuffer.pBuffers      = OutBuffers;
        OutBuffer.ulVersion     = SECBUFFER_VERSION;

        //
        // Call InitializeSecurityContext.
        //

        Status = g_SecurityFunc.InitializeSecurityContextA(
                                          &m_Creds,
                                          &m_Context,
                                          NULL,
                                          dwSSPIFlags,
                                          0,
                                          SECURITY_NATIVE_DREP,
                                          &InBuffer,
                                          0,
                                          NULL,
                                          &OutBuffer,
                                          &dwSSPIOutFlags,
                                          &tsExpiry);

        DSCHAN(("ISC on %X bytes returns %X\n",
                m_BufferUsed, Status));
        DumpBuffers("ISC in", &InBuffer);
        DumpBuffers("ISC out", &OutBuffer);
        
        //
        // If InitializeSecurityContext was successful (or if the error was 
        // one of the special extended ones), send the contends of the output
        // buffer to the server.
        //

        if(Status == SEC_E_OK                ||
           Status == SEC_I_CONTINUE_NEEDED   ||
           FAILED(Status) && (dwSSPIOutFlags & ISC_RET_EXTENDED_ERROR))
        {
            if(OutBuffers[0].cbBuffer != 0 && OutBuffers[0].pvBuffer != NULL)
            {
                DSCHAN(("  write back %X bytes\n", OutBuffers[0].cbBuffer));
                
                cbData = StreamWrite(SEQ_INTERNAL, OutBuffers[0].pvBuffer,
                                     OutBuffers[0].cbBuffer);
                if(cbData == 0)
                {
                    g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
                    if (m_OwnContext)
                    {
                        g_SecurityFunc.DeleteSecurityContext(&m_Context);
                        SecInvalidateHandle(&m_Context);
                    }
                    Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
                    goto Exit;
                }

                // Free output buffer.
                g_SecurityFunc.FreeContextBuffer(OutBuffers[0].pvBuffer);
                OutBuffers[0].pvBuffer = NULL;
            }
        }


        //
        // If InitializeSecurityContext returned SEC_E_INCOMPLETE_MESSAGE,
        // then we need to read more data from the server and try again.
        //

        if(Status == SEC_E_INCOMPLETE_MESSAGE)
        {
            continue;
        }


        //
        // If InitializeSecurityContext returned SEC_E_OK, then the 
        // handshake completed successfully.
        //

        if(Status == SEC_E_OK)
        {
            //
            // If the "extra" buffer contains data, this is encrypted application
            // protocol layer stuff. It needs to be saved. The application layer
            // will later decrypt it with DecryptMessage.
            //

            if(InBuffers[1].BufferType == SECBUFFER_EXTRA)
            {
                DSCHAN_IO(("  ISC returns with %X extra bytes\n",
                           InBuffers[1].cbBuffer));
                
                memmove(m_Buffer,
                        m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                        InBuffers[1].cbBuffer);
                m_BufferUsed = InBuffers[1].cbBuffer;
            }
            else
            {
                m_BufferUsed = 0;
            }

            //
            // Bail out to quit
            //

            break;
        }


        //
        // Check for fatal error.
        //

        if(FAILED(Status))
        {
            break;
        }


        //
        // If InitializeSecurityContext returned SEC_I_INCOMPLETE_CREDENTIALS,
        // then the server just requested client authentication. 
        //

        if(Status == SEC_I_INCOMPLETE_CREDENTIALS)
        {
            DSCHAN(("Get new client credentials\n"));
                   
            //
            // Display trusted issuers info. 
            //

            GetNewClientCredentials();

            //
            // Now would be a good time perhaps to prompt the user to select
            // a client certificate and obtain a new credential handle, 
            // but I don't have the energy nor inclination.
            //
            // As this is currently written, Schannel will send a "no 
            // certificate" alert to the server in place of a certificate. 
            // The server might be cool with this, or it might drop the 
            // connection.
            // 

            // Go around again.
            ReadNeeded = 0;
            Status = SEC_I_CONTINUE_NEEDED;
            continue;
        }


        //
        // Copy any leftover data from the "extra" buffer, and go around
        // again.
        //

        if ( InBuffers[1].BufferType == SECBUFFER_EXTRA )
        {
            DSCHAN(("  ISC loops with %X extra bytes\n",
                    InBuffers[1].cbBuffer));
            
            memmove(m_Buffer,
                    m_Buffer + (m_BufferUsed - InBuffers[1].cbBuffer),
                    InBuffers[1].cbBuffer);
            m_BufferUsed = InBuffers[1].cbBuffer;
        }
        else
        {
            m_BufferUsed = 0;
        }
    }

    // Delete the security context in the case of a fatal error.
    if(FAILED(Status))
    {
        if (m_OwnContext)
        {
            g_SecurityFunc.DeleteSecurityContext(&m_Context);
            SecInvalidateHandle(&m_Context);
        }
    }

 Exit:
    DSCHAN(("AuthServer returns %X\n", Status));
    return Status;
}

void
DbgRpcSecureChannelTransport::GetNewClientCredentials(void)
{
    CredHandle hCreds;
    SecPkgContext_IssuerListInfoEx IssuerListInfo;
    PCCERT_CHAIN_CONTEXT pChainContext;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara;
    PCCERT_CONTEXT  pCertContext;
    TimeStamp       tsExpiry;
    SECURITY_STATUS Status;

    //
    // Read list of trusted issuers from schannel.
    //

    Status = g_SecurityFunc.QueryContextAttributes(&m_Context,
                                    SECPKG_ATTR_ISSUER_LIST_EX,
                                    (PVOID)&IssuerListInfo);
    if (Status != SEC_E_OK)
    {
        goto Exit;
    }

    //
    // Enumerate the client certificates.
    //

    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = IssuerListInfo.cIssuers;
    FindByIssuerPara.rgIssuer  = IssuerListInfo.aIssuers;

    pChainContext = NULL;

    while(TRUE)
    {
        // Find a certificate chain.
        pChainContext = g_Crypt32Calls.
            CertFindChainInStore(g_hMyCertStore,
                                 X509_ASN_ENCODING,
                                 0,
                                 CERT_CHAIN_FIND_BY_ISSUER,
                                 &FindByIssuerPara,
                                 pChainContext);
        if(pChainContext == NULL)
        {
            break;
        }

        // Get pointer to leaf certificate context.
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

        // Create schannel credential.
        m_ScCreds.cCreds = 1;
        m_ScCreds.paCred = &pCertContext;

        Status = g_SecurityFunc.AcquireCredentialsHandleA(
                            NULL,                   // Name of principal
                            UNISP_NAME_A,           // Name of package
                            SECPKG_CRED_OUTBOUND,   // Flags indicating use
                            NULL,                   // Pointer to logon ID
                            &m_ScCreds,             // Package specific data
                            NULL,                   // Pointer to GetKey() func
                            NULL,                   // Value to pass to GetKey()
                            &hCreds,                // (out) Cred Handle
                            &tsExpiry);             // (out) Lifetime (optional)
        if(Status != SEC_E_OK)
        {
            continue;
        }

        // Destroy the old credentials.
        if (m_OwnCreds)
        {
            g_SecurityFunc.FreeCredentialsHandle(&m_Creds);
        }

        // XXX drewb - This doesn't really work if this
        // isn't the credential owner.
        m_Creds = hCreds;
        break;
    }

 Exit:
    DSCHAN(("GetNewClientCredentials returns %X\n", Status));
}
    
void
DbgRpcSecureChannelTransport::DisconnectFromClient(void)
{
    DWORD           dwType;
    PBYTE           pbMessage;
    DWORD           cbMessage;
    DWORD           cbData;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    DWORD           Status;

    //
    // Notify schannel that we are about to close the connection.
    //

    dwType = SCHANNEL_SHUTDOWN;

    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.ApplyControlToken(&m_Context, &OutBuffer);
    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    //
    // Build an SSL close notify message.
    //

    dwSSPIFlags = ASC_REQ_SEQUENCE_DETECT     |
                  ASC_REQ_REPLAY_DETECT       |
                  ASC_REQ_CONFIDENTIALITY     |
                  ASC_REQ_EXTENDED_ERROR      |
                  ASC_REQ_ALLOCATE_MEMORY     |
                  ASC_REQ_STREAM;

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.AcceptSecurityContext(
                    &m_Creds,
                    &m_Context,
                    NULL,
                    dwSSPIFlags,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);
    
    DSCHAN(("DisASC returns %X\n", Status));
    DumpBuffers("DisASC out", &OutBuffer);

    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    pbMessage = (PBYTE)OutBuffers[0].pvBuffer;
    cbMessage = OutBuffers[0].cbBuffer;

    //
    // Send the close notify message to the client.
    //

    if (pbMessage != NULL && cbMessage != 0)
    {
        DSCHAN(("  write back %X bytes\n", cbMessage));
        
        cbData = StreamWrite(SEQ_INTERNAL, pbMessage, cbMessage);
        if (cbData == 0)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto cleanup;
        }

        // Free output buffer.
        g_SecurityFunc.FreeContextBuffer(pbMessage);
    }
    
cleanup:
    DSCHAN(("DisconnectFromClient returns %X\n", Status));
}

void
DbgRpcSecureChannelTransport::DisconnectFromServer(void)
{
    DWORD           dwType;
    PBYTE           pbMessage;
    DWORD           cbMessage;
    DWORD           cbData;

    SecBufferDesc   OutBuffer;
    SecBuffer       OutBuffers[1];
    DWORD           dwSSPIFlags;
    DWORD           dwSSPIOutFlags;
    TimeStamp       tsExpiry;
    DWORD           Status;

    //
    // Notify schannel that we are about to close the connection.
    //

    dwType = SCHANNEL_SHUTDOWN;

    OutBuffers[0].pvBuffer   = &dwType;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = sizeof(dwType);

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.ApplyControlToken(&m_Context, &OutBuffer);
    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    //
    // Build an SSL close notify message.
    //

    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT   |
                  ISC_REQ_REPLAY_DETECT     |
                  ISC_REQ_CONFIDENTIALITY   |
                  ISC_REQ_EXTENDED_ERROR    |
                  ISC_REQ_ALLOCATE_MEMORY   |
                  ISC_REQ_STREAM;

    OutBuffers[0].pvBuffer   = NULL;
    OutBuffers[0].BufferType = SECBUFFER_TOKEN;
    OutBuffers[0].cbBuffer   = 0;

    OutBuffer.cBuffers  = 1;
    OutBuffer.pBuffers  = OutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    Status = g_SecurityFunc.InitializeSecurityContextA(
                    &m_Creds,
                    &m_Context,
                    NULL,
                    dwSSPIFlags,
                    0,
                    SECURITY_NATIVE_DREP,
                    NULL,
                    0,
                    &m_Context,
                    &OutBuffer,
                    &dwSSPIOutFlags,
                    &tsExpiry);
    
    DSCHAN(("DisISC returns %X\n", Status));
    DumpBuffers("DisISC out", &OutBuffer);

    if(FAILED(Status)) 
    {
        goto cleanup;
    }

    pbMessage = (PBYTE)OutBuffers[0].pvBuffer;
    cbMessage = OutBuffers[0].cbBuffer;


    //
    // Send the close notify message to the server.
    //

    if(pbMessage != NULL && cbMessage != 0)
    {
        DSCHAN(("  write back %X bytes\n", cbMessage));
        
        cbData = StreamWrite(SEQ_INTERNAL, pbMessage, cbMessage);
        if (cbData == 0)
        {
            Status = HRESULT_FROM_WIN32(ERROR_WRITE_FAULT);
            goto cleanup;
        }

        // Free output buffer.
        g_SecurityFunc.FreeContextBuffer(pbMessage);
    }
    
cleanup:
    DSCHAN(("DisconnectFromServer returns %X\n", Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsvc\dbgsvc.hpp ===
//----------------------------------------------------------------------------
//
// Low-level debugging service interface implementations.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __DBGSVC_HPP__
#define __DBGSVC_HPP__

//----------------------------------------------------------------------------
//
// UserDebugServices.
//
//----------------------------------------------------------------------------

class UserDebugServices
    : public IUserDebugServices,
      public DbgRpcClientObject
{
public:
    UserDebugServices(void);
    virtual ~UserDebugServices(void);
    
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IUserDebugServices.
    STDMETHOD(Initialize)(
        THIS_
        OUT PULONG Flags
        );
    STDMETHOD(Uninitialize)(
        THIS_
        IN BOOL Global
        );

    // DbgRpcClientObject.
    virtual HRESULT Initialize(PSTR Identity, PVOID* Interface);
    virtual void    Finalize(void);
    virtual void    Uninitialize(void);

    // UserDebugServices.
    ULONG m_Refs;
    BOOL m_Initialized;
};

//----------------------------------------------------------------------------
//
// LiveUserDebugServices.
//
//----------------------------------------------------------------------------

class LiveUserDebugServices
    : public UserDebugServices
{
public:
    LiveUserDebugServices(BOOL Remote);
    virtual ~LiveUserDebugServices(void);
    
    // IUserDebugServices.
    STDMETHOD(Initialize)(
        THIS_
        OUT PULONG Flags
        );
    STDMETHOD(Uninitialize)(
        THIS_
        IN BOOL Global
        );
    STDMETHOD(GetTargetInfo)(
        THIS_
        OUT PULONG MachineType,
        OUT PULONG NumberProcessors,
        OUT PULONG PlatformId,
        OUT PULONG BuildNumber,
        OUT PULONG CheckedBuild,
        OUT PSTR CsdString,
        IN ULONG CsdStringSize,
        OUT PSTR BuildString,
        IN ULONG BuildStringSize
        );
    STDMETHOD(GetProcessorId)(
        THIS_
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT PULONG BufferUsed
        );
    STDMETHOD(GetFileVersionInformation)(
        THIS_
        IN PCSTR File,
        IN PCSTR Item,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG VerInfoSize
        );
    STDMETHOD(GetProcessIds)(
        THIS_
        OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
        IN ULONG Count,
        OUT OPTIONAL PULONG ActualCount
        );
    STDMETHOD(GetProcessIdByExecutableName)(
        THIS_
        IN PCSTR ExeName,
        IN ULONG Flags,
        OUT PULONG Id
        );
    STDMETHOD(GetProcessDescription)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG Flags,
        OUT OPTIONAL PSTR ExeName,
        IN ULONG ExeNameSize,
        OUT OPTIONAL PULONG ActualExeNameSize,
        OUT OPTIONAL PSTR Description,
        IN ULONG DescriptionSize,
        OUT OPTIONAL PULONG ActualDescriptionSize
        );
    STDMETHOD(GetProcessInfo)(
        THIS_
        IN ULONG ProcessId,
        OUT OPTIONAL PULONG64 Handle,
        OUT OPTIONAL /* size_is(InfoCount) */ PUSER_THREAD_INFO Threads,
        IN ULONG InfoCount,
        OUT OPTIONAL PULONG ThreadCount
        );
    STDMETHOD(AttachProcess)(
        THIS_
        IN ULONG ProcessId,
        IN ULONG AttachFlags,
        OUT PULONG64 ProcessHandle,
        OUT PULONG ProcessOptions
        );
    STDMETHOD(DetachProcess)(
        THIS_
        IN ULONG ProcessId
        );
    STDMETHOD(CreateProcess)(
        THIS_
        IN PSTR CommandLine,
        IN ULONG CreateFlags,
        OUT PULONG ProcessId,
        OUT PULONG ThreadId,
        OUT PULONG64 ProcessHandle,
        OUT PULONG64 ThreadHandle
        );
    STDMETHOD(TerminateProcess)(
        THIS_
        IN ULONG64 Process,
        IN ULONG ExitCode
        );
    STDMETHOD(AbandonProcess)(
        THIS_
        IN ULONG64 Process
        );
    STDMETHOD(GetProcessExitCode)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG ExitCode
        );
    STDMETHOD(CloseHandle)(
        THIS_
        IN ULONG64 Handle
        );
    STDMETHOD(SetProcessOptions)(
        THIS_
        IN ULONG64 Process,
        IN ULONG Options
        );
    STDMETHOD(SetDebugObjectOptions)(
        THIS_
        IN ULONG64 DebugObject,
        IN ULONG Options
        );
    STDMETHOD(GetProcessDebugObject)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 DebugObject
        );
    STDMETHOD(DuplicateHandle)(
        THIS_
        IN ULONG64 InProcess,
        IN ULONG64 InHandle,
        IN ULONG64 OutProcess,
        IN ULONG DesiredAccess,
        IN ULONG Inherit,
        IN ULONG Options,
        OUT PULONG64 OutHandle
        );
    STDMETHOD(ReadVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesRead
        );
    STDMETHOD(WriteVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BytesWritten
        );
    STDMETHOD(QueryVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        );
    STDMETHOD(ProtectVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG NewProtect,
        OUT PULONG OldProtect
        );
    STDMETHOD(AllocVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type,
        IN ULONG Protect,
        OUT PULONG64 AllocOffset
        );
    STDMETHOD(FreeVirtual)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG64 Size,
        IN ULONG Type
        );
    STDMETHOD(ReadHandleData)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Handle,
        IN ULONG DataType,
        OUT OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG DataSize
        );
    STDMETHOD(SuspendThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        );
    STDMETHOD(ResumeThreads)(
        THIS_
        IN ULONG Count,
        IN /* size_is(Count) */ PULONG64 Threads,
        OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
        );
    STDMETHOD(GetContext)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Flags,
        IN ULONG FlagsOffset,
        OUT PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        );
    STDMETHOD(SetContext)(
        THIS_
        IN ULONG64 Thread,
        IN PVOID Context,
        IN ULONG ContextSize,
        OUT OPTIONAL PULONG ContextUsed
        );
    STDMETHOD(GetProcessDataOffset)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetThreadDataOffset)(
        THIS_
        IN ULONG64 Thread,
        OUT PULONG64 Offset
        );
    STDMETHOD(DescribeSelector)(
        THIS_
        IN ULONG64 Thread,
        IN ULONG Selector,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        );
    STDMETHOD(GetCurrentTimeDateN)(
        THIS_
        OUT PULONG64 TimeDate
        );
    STDMETHOD(GetCurrentSystemUpTimeN)(
        THIS_
        OUT PULONG64 UpTime
        );
    STDMETHOD(GetProcessUpTimeN)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 UpTime
        );

    STDMETHOD(RequestBreakIn)(
        THIS_
        IN ULONG64 Process
        );
    STDMETHOD(WaitForEvent)(
        THIS_
        IN ULONG Timeout,
        OUT PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG BufferUsed
        );
    STDMETHOD(ContinueEvent)(
        THIS_
        IN ULONG ContinueStatus
        );
    STDMETHOD(InsertCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        OUT PVOID Storage,
        IN ULONG StorageSize
        );
    STDMETHOD(RemoveCodeBreakpoint)(
        THIS_
        IN ULONG64 Process,
        IN ULONG64 Offset,
        IN ULONG MachineType,
        IN PVOID Storage,
        IN ULONG StorageSize
        );

    STDMETHOD(GetFunctionTableListHead)(
        THIS_
        IN ULONG64 Process,
        OUT PULONG64 Offset
        );
    STDMETHOD(GetOutOfProcessFunctionTable)(
        THIS_
        IN ULONG64 Process,
        IN PSTR Dll,
        IN ULONG64 Table,
        IN OPTIONAL PVOID Buffer,
        IN ULONG BufferSize,
        OUT OPTIONAL PULONG TableSize
        );

    // LiveUserDebugServices.
    ULONG m_ContextSize;
    ULONG m_SysProcInfoSize;
    BOOL m_Remote;
    ULONG m_EventProcessId;
    ULONG m_EventThreadId;
    ULONG m_PlatformId;
    HANDLE m_DebugObject;
    BOOL m_UseDebugObject;

    HRESULT SysGetProcessOptions(HANDLE Process, PULONG Options);
    HRESULT OpenDebugActiveProcess(ULONG ProcessId, HANDLE Process);
    HRESULT CreateDebugActiveProcess(ULONG ProcessId, HANDLE Process);
};

// This global instance is intended for direct use only
// by routines which need a temporary local service instance.
extern LiveUserDebugServices g_LiveUserDebugServices;

#define SERVER_SERVICES(Server) \
    ((Server) != 0 ? (PUSER_DEBUG_SERVICES)(Server) : &g_LiveUserDebugServices)

// A client of the services can watch this variable to
// see if any instance has received an Uninitialize request.
extern ULONG g_UserServicesUninitialized;

#endif // #ifndef __DBGSVC_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsvc\dbgsvc.cpp ===
//----------------------------------------------------------------------------
//
// Low-level debugging service interface implementations.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

#include <time.h>
#include <comsvcs.h>

#include "dbgsvc.hpp"

#ifndef NT_NATIVE

// #include <winbasep.h>
extern "C" {
BOOL
WINAPI
CloseProfileUserMapping(
    VOID
    );
};
// winbasep.h

#else

#define CloseProfileUserMapping()

#endif

// SYSTEM_PROCESS_INFORMATION can change in size, requiring
// different offsets to get to thread information.
#define NT4_SYSTEM_PROCESS_INFORMATION_SIZE 136
#define W2K_SYSTEM_PROCESS_INFORMATION_SIZE 184

#define SYSTEM_PROCESS_NAME "System Process"
#define SYSTEM_PROCESS_NAME_W L"System Process"
#define PEBLESS_PROCESS_NAME "System"

ULONG g_UserServicesUninitialized;

//----------------------------------------------------------------------------
//
// UserDebugServices.
//
//----------------------------------------------------------------------------

UserDebugServices::UserDebugServices(void)
{
    m_Refs = 1;
    m_Initialized = FALSE;
}

UserDebugServices::~UserDebugServices(void)
{
}

STDMETHODIMP
UserDebugServices::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;
    
    *Interface = NULL;
    Status = S_OK;

    if (DbgIsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
        DbgIsEqualIID(InterfaceId, __uuidof(IUserDebugServices)))
    {
        *Interface = (IUserDebugServices *)this;
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    if (Status == S_OK)
    {
        AddRef();
    }
    
    return Status;
}

STDMETHODIMP_(ULONG)
UserDebugServices::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
UserDebugServices::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        delete this;
    }
    return Refs;
}

HRESULT
UserDebugServices::Initialize(
    THIS_
    OUT PULONG Flags
    )
{
    m_Initialized = TRUE;
    *Flags = 0;
    return S_OK;
}

HRESULT
UserDebugServices::Uninitialize(
    THIS_
    IN BOOL Global
    )
{
    m_Initialized = FALSE;
    if (Global)
    {
        g_UserServicesUninitialized++;
    }
    return S_OK;
}

HRESULT
UserDebugServices::Initialize(PSTR Identity, PVOID* Interface)
{
    HRESULT Status;
    ULONG Flags;

    if ((Status = Initialize(&Flags)) != S_OK)
    {
        return Status;
    }
    
    *Interface = (IUserDebugServices*)this;
    return S_OK;
}

void
UserDebugServices::Finalize(void)
{
    // Take a reference on this object for the RPC client
    // thread to hold.
    AddRef();
}

void
UserDebugServices::Uninitialize(void)
{
    // Directly destroy the client object rather than releasing
    // as the remote client may have exited without politely
    // cleaning up references.
    delete this;
}

//----------------------------------------------------------------------------
//
// LiveUserDebugServices.
//
//----------------------------------------------------------------------------

// This global instance is intended for direct use only
// by routines which need a temporary local service instance.
LiveUserDebugServices g_LiveUserDebugServices(FALSE);

LiveUserDebugServices::LiveUserDebugServices(BOOL Remote)
{
    m_Remote = Remote;
    m_EventProcessId = 0;
    m_ContextSize = 0;
    m_SysProcInfoSize = 0;
    m_PlatformId = VER_PLATFORM_WIN32s;
    m_DebugObject = NULL;
}

LiveUserDebugServices::~LiveUserDebugServices(void)
{
    if (m_DebugObject != NULL)
    {
        g_NtDllCalls.NtClose(m_DebugObject);
    }
}

HRESULT
GetOsVerInfo(LPOSVERSIONINFOW OsVersionInfo, PBOOL WideCsd)
{
    *WideCsd = TRUE;
    ZeroMemory(OsVersionInfo, sizeof(*OsVersionInfo));
    OsVersionInfo->dwOSVersionInfoSize = sizeof(*OsVersionInfo);
#ifdef NT_NATIVE
    NTSTATUS NtStatus;

    if (!NT_SUCCESS(NtStatus = RtlGetVersion(OsVersionInfo)))
    {
        return HRESULT_FROM_NT(NtStatus);
    }
#else
    if (!GetVersionExW(OsVersionInfo))
    {
        if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
        {
            OSVERSIONINFOA InfoA;
            
            // Must be Win9x.
            ZeroMemory(&InfoA, sizeof(InfoA));
            InfoA.dwOSVersionInfoSize = sizeof(InfoA);
            if (!::GetVersionExA(&InfoA))
            {
                return WIN32_LAST_STATUS();
            }

            OsVersionInfo->dwMajorVersion = InfoA.dwMajorVersion;
            OsVersionInfo->dwMinorVersion = InfoA.dwMinorVersion;
            OsVersionInfo->dwBuildNumber = InfoA.dwBuildNumber;
            OsVersionInfo->dwPlatformId = InfoA.dwPlatformId;
            memcpy(OsVersionInfo->szCSDVersion, InfoA.szCSDVersion,
                   sizeof(InfoA.szCSDVersion));
            *WideCsd = FALSE;
        }
        else
        {
            return WIN32_LAST_STATUS();
        }
    }
#endif
    return S_OK;
}

HRESULT
LiveUserDebugServices::Initialize(
    THIS_
    OUT PULONG Flags
    )
{
    HRESULT Status;
    OSVERSIONINFOW OsVersionInfo;
    BOOL WideCsd;

    if ((Status = GetOsVerInfo(&OsVersionInfo, &WideCsd)) != S_OK)
    {
        return Status;
    }

    ULONG BaseFlags;
        
    if ((Status = UserDebugServices::Initialize(&BaseFlags)) != S_OK)
    {
        return Status;
    }
    
    m_PlatformId = OsVersionInfo.dwPlatformId;

    // System structures may change size depending on the OS
    // version.  Pick the right size to use later.
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        if (OsVersionInfo.dwBuildNumber <= 1381)
        {
            m_SysProcInfoSize = NT4_SYSTEM_PROCESS_INFORMATION_SIZE;
        }
        else if (OsVersionInfo.dwBuildNumber <= 2195)
        {
            m_SysProcInfoSize = W2K_SYSTEM_PROCESS_INFORMATION_SIZE;
        }
        else
        {
            m_SysProcInfoSize = sizeof(SYSTEM_PROCESS_INFORMATION);
        }
    }

    // If the direct NT debugging APIs are available use them
    // as they offer more flexibility.
    if (g_NtDllCalls.DbgUiSetThreadDebugObject != NULL)
    {
        // The NtWait/Continue APIs do not automatically manage
        // process and thread handles so the caller must close them.
        BaseFlags |= DBGSVC_CLOSE_PROC_THREAD_HANDLES;
        m_UseDebugObject = TRUE;
    }
    else
    {
        m_UseDebugObject = FALSE;
    }
    
    *Flags = BaseFlags | DBGSVC_GENERIC_CODE_BREAKPOINTS;
    return S_OK;
}

HRESULT
LiveUserDebugServices::Uninitialize(
    THIS_
    IN BOOL Global
    )
{
    HRESULT Status;
    
    if ((Status = UserDebugServices::Uninitialize(Global)) != S_OK)
    {
        return Status;
    }
    
    m_Remote = FALSE;
    m_EventProcessId = 0;
    m_ContextSize = 0;
    m_PlatformId = VER_PLATFORM_WIN32s;
    if (m_DebugObject != NULL)
    {
        ::CloseHandle(m_DebugObject);
        m_DebugObject = NULL;
    }
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetTargetInfo(
    THIS_
    OUT PULONG MachineType,
    OUT PULONG NumberProcessors,
    OUT PULONG PlatformId,
    OUT PULONG BuildNumber,
    OUT PULONG CheckedBuild,
    OUT PSTR CsdString,
    IN ULONG CsdStringSize,
    OUT PSTR BuildString,
    IN ULONG BuildStringSize
    )
{
    HRESULT Status;
    OSVERSIONINFOW OsVersionInfo;
    BOOL WideCsd;

    if ((Status = GetOsVerInfo(&OsVersionInfo, &WideCsd)) != S_OK)
    {
        return Status;
    }

    ULONG ProcArch, NumProc;
    
#ifdef NT_NATIVE
    NTSTATUS NtStatus;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    SYSTEM_PROCESSOR_INFORMATION ProcInfo;
    
    if (!NT_SUCCESS(NtStatus =
                    NtQuerySystemInformation(SystemBasicInformation,
                                             &BasicInfo, sizeof(BasicInfo),
                                             NULL)) ||
        !NT_SUCCESS(NtStatus =
                    NtQuerySystemInformation(SystemProcessorInformation,
                                             &ProcInfo, sizeof(ProcInfo),
                                             NULL)))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    ProcArch = ProcInfo.ProcessorArchitecture;
    NumProc = BasicInfo.NumberOfProcessors;
#else
    SYSTEM_INFO SystemInfo;

    ::GetSystemInfo(&SystemInfo);
    ProcArch = SystemInfo.wProcessorArchitecture;
    NumProc = SystemInfo.dwNumberOfProcessors;
#endif
    
    switch(ProcArch)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        *MachineType = IMAGE_FILE_MACHINE_I386;
        if (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            if (OsVersionInfo.dwBuildNumber <= 1381)
            {
                m_ContextSize = sizeof(X86_CONTEXT);
            }
            else
            {
                m_ContextSize = sizeof(X86_NT5_CONTEXT);
            }
        }
        else if ((OsVersionInfo.dwBuildNumber & 0xffff) <= 1998)
        {
            // Win9x prior to Win98SE didn't support the extended context.
            m_ContextSize = sizeof(X86_CONTEXT);
        }
        else
        {
            m_ContextSize = sizeof(X86_NT5_CONTEXT);
        }
        break;
    case PROCESSOR_ARCHITECTURE_ALPHA:
        *MachineType = IMAGE_FILE_MACHINE_ALPHA;
        // The "NT5" is a misnomer, this context
        // applies to all versions.
        m_ContextSize = sizeof(ALPHA_NT5_CONTEXT);
        break;
    case PROCESSOR_ARCHITECTURE_ALPHA64:
        *MachineType = IMAGE_FILE_MACHINE_AXP64;
        m_ContextSize = sizeof(ALPHA_NT5_CONTEXT);
        break;
    case PROCESSOR_ARCHITECTURE_IA64:
        *MachineType = IMAGE_FILE_MACHINE_IA64;
        m_ContextSize = sizeof(IA64_CONTEXT);
        break;
    default:
        return E_UNEXPECTED;
    }

    *NumberProcessors = NumProc;
    *PlatformId = OsVersionInfo.dwPlatformId;
    *BuildNumber = OsVersionInfo.dwBuildNumber;
    *CheckedBuild = 0;
    if (WideCsd)
    {
        if (!WideCharToMultiByte(CP_ACP, 0, OsVersionInfo.szCSDVersion, -1,
                                 CsdString, CsdStringSize, NULL, NULL))
        {
            CsdString[0] = 0;
        }
    }
    else
    {
        CsdString[0] = 0;
        strncat(CsdString, (PSTR)OsVersionInfo.szCSDVersion, CsdStringSize);
    }
    BuildString[0] = 0;

#ifndef NT_NATIVE
    if (VER_PLATFORM_WIN32_NT == OsVersionInfo.dwPlatformId)
    {
        HKEY hkey = NULL;
        TCHAR sz[40] = {0};
        DWORD dwType;
        DWORD dwSize = sizeof(sz);

        if (ERROR_SUCCESS ==
            RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         "Software\\Microsoft\\Windows NT\\CurrentVersion",
                         0,
                         KEY_READ,
                         &hkey))
        {
            if (ERROR_SUCCESS ==
                RegQueryValueEx(hkey,
                                "CurrentType",
                                NULL,
                                &dwType,
                                (PUCHAR) sz,
                                &dwSize))
            {
                if (*sz)
                {
                    _strlwr(sz);
                    if (strstr(sz, "checked"))
                    {
                        *CheckedBuild = 0xC;
                    }
                }
            }

            RegCloseKey(hkey);
        }

        if (OsVersionInfo.dwBuildNumber > 2195)
        {
            char RawString[128];
            
            // Look up the file version string for a system DLL to
            // try and get the build lab information.
            strcpy(RawString, "kernel32.dll version: ");
            GetFileStringFileInfo("kernel32.dll", "FileVersion",
                                  RawString + strlen(RawString),
                                  sizeof(RawString) - strlen(RawString));
            strncat(BuildString, RawString, BuildStringSize);
        }
    }
#endif // #ifndef NT_NATIVE

    return S_OK;
}

BOOL
X86CpuId(
    IN ULONG SubFunction,
    OUT PULONG EaxRegister,
    OUT PULONG EbxRegister,
    OUT PULONG EcxRegister,
    OUT PULONG EdxRegister
    )
{
#ifdef _X86_
    ULONG _Eax;
    ULONG _Ebx;
    ULONG _Ecx;
    ULONG _Edx;

    __asm
    {
        mov eax, SubFunction
                
        __emit 0x0F
        __emit 0xA2  ;; CPUID

        mov _Eax, eax
        mov _Ebx, ebx
        mov _Ecx, ecx
        mov _Edx, edx
    }

    *EaxRegister = _Eax;
    *EbxRegister = _Ebx;
    *EcxRegister = _Ecx;
    *EdxRegister = _Edx;

    return TRUE;
#else
    return FALSE;
#endif // #ifdef _X86_
}

BOOL
Ia64CpuId(ULONG Reg, PULONG64 Val)
{
    // XXX drewb - How should this be implemented?
#if defined(_IA64_) && defined(IA64_INLINE_ASSEMBLY)
    ULONG64 _Val;

    __asm mov t0, Reg;
    __asm mov _Val, cpuid[t0];
    *Val = _Val;
    return TRUE;
#else
    return FALSE;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessorId(
    THIS_
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG BufferUsed
    )
{
    if (BufferSize < sizeof(DEBUG_PROCESSOR_IDENTIFICATION_ALL))
    {
        return E_INVALIDARG;
    }

    ZeroMemory(Buffer, sizeof(DEBUG_PROCESSOR_IDENTIFICATION_ALL));

    ULONG ProcArch, ProcLevel, ProcRevision;
    
#ifdef NT_NATIVE
    NTSTATUS NtStatus;
    SYSTEM_PROCESSOR_INFORMATION ProcInfo;
    
    if (!NT_SUCCESS(NtStatus =
                    NtQuerySystemInformation(SystemProcessorInformation,
                                             &ProcInfo, sizeof(ProcInfo),
                                             NULL)))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    ProcArch = ProcInfo.ProcessorArchitecture;
    ProcLevel = ProcInfo.ProcessorLevel;
    ProcRevision = ProcInfo.ProcessorRevision;
#else
    SYSTEM_INFO SystemInfo;

    ::GetSystemInfo(&SystemInfo);
    ProcArch = SystemInfo.wProcessorArchitecture;
    ProcLevel = SystemInfo.wProcessorLevel;
    ProcRevision = SystemInfo.wProcessorRevision;
#endif
    
    PDEBUG_PROCESSOR_IDENTIFICATION_ALL Id =
        (PDEBUG_PROCESSOR_IDENTIFICATION_ALL)Buffer;
    ULONG64 Val;

    switch(ProcArch)
    {
    case PROCESSOR_ARCHITECTURE_INTEL:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_X86);
        Id->X86.Family = ProcLevel;
        Id->X86.Model = (ProcRevision >> 8) & 0xf;
        Id->X86.Stepping = ProcRevision & 0xf;

        if (ProcLevel >= 5)
        {
            ULONG Eax, Ebx, Ecx, Edx;

            if (X86CpuId(0, &Eax, &Ebx, &Ecx, &Edx))
            {
                *(PULONG)(Id->X86.VendorString + 0 * sizeof(ULONG)) = Ebx;
                *(PULONG)(Id->X86.VendorString + 1 * sizeof(ULONG)) = Edx;
                *(PULONG)(Id->X86.VendorString + 2 * sizeof(ULONG)) = Ecx;
            }
        }
        break;

    case PROCESSOR_ARCHITECTURE_ALPHA:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_ALPHA);
        Id->Alpha.Type = ProcLevel;
        Id->Alpha.Revision = ProcRevision;
        break;
        
    case PROCESSOR_ARCHITECTURE_IA64:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_IA64);
        Id->Ia64.Model = ProcLevel;
        Id->Ia64.Revision = ProcRevision;

        if (Ia64CpuId(3, &Val))
        {
            Id->Ia64.ArchRev = (ULONG)((Val >> 32) & 0xff);
            Id->Ia64.Family = (ULONG)((Val >> 24) & 0xff);
            Ia64CpuId(0, (PULONG64)
                      (Id->Ia64.VendorString + 0 * sizeof(ULONG64)));
            Ia64CpuId(1, (PULONG64)
                      (Id->Ia64.VendorString + 1 * sizeof(ULONG64)));
        }
        break;
        
    case PROCESSOR_ARCHITECTURE_AMD64:
        *BufferUsed = sizeof(DEBUG_PROCESSOR_IDENTIFICATION_AMD64);
        Id->Amd64.Family = ProcLevel;
        Id->Amd64.Model = (ProcRevision >> 8) & 0xf;
        Id->Amd64.Stepping = ProcRevision & 0xf;
        break;
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetFileVersionInformation(
    THIS_
    IN PCSTR File,
    IN PCSTR Item,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG VerInfoSize
    )
{
#ifndef NT_NATIVE
    PVOID AllInfo = GetAllFileVersionInfo((PSTR)File);
    if (AllInfo == NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT Status;
    PVOID Val;
    UINT ValSize;

    if (VerQueryValue(AllInfo, (PSTR)Item, &Val, &ValSize))
    {
        Status = FillDataBuffer(Val, ValSize,
                                Buffer, BufferSize, VerInfoSize);
    }
    else
    {
        Status = WIN32_LAST_STATUS();
    }

    free(AllInfo);
    return Status;
#else // #ifndef NT_NATIVE
    return E_UNEXPECTED;
#endif // #ifndef NT_NATIVE
}

HRESULT
GetNtSystemProcessInformation(PSYSTEM_PROCESS_INFORMATION* ProcInfo)
{
    NTSTATUS NtStatus;
    PVOID Buffer;
    SIZE_T BufferSize = 8192;

    for (;;)
    {
        Buffer = NULL;
        NtStatus = g_NtDllCalls.
            NtAllocateVirtualMemory(NtCurrentProcess(),
                                    &Buffer, 0, &BufferSize,
                                    MEM_COMMIT, PAGE_READWRITE);
        if (!NT_SUCCESS(NtStatus))
        {
            return HRESULT_FROM_NT(NtStatus);
        }

        NtStatus = g_NtDllCalls.
            NtQuerySystemInformation(SystemProcessInformation,
                                     Buffer, (ULONG)BufferSize, NULL);
        if (NT_SUCCESS(NtStatus))
        {
            break;
        }
        
        g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                         &Buffer, &BufferSize, MEM_RELEASE);
        if (NtStatus == STATUS_INFO_LENGTH_MISMATCH)
        {
            BufferSize += 8192;
        }
        else
        {
            return HRESULT_FROM_NT(NtStatus);
        }
    }

    *ProcInfo = (PSYSTEM_PROCESS_INFORMATION)Buffer;
    return S_OK;
}

HRESULT
NtGetProcessIds(PULONG Ids, ULONG Count, PULONG ActualCount)
{
    HRESULT Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo, ProcInfoBuffer;

    if ((Status = GetNtSystemProcessInformation(&ProcInfoBuffer)) != S_OK)
    {
        return Status;
    }
    
    ULONG TotalOffset;
    ULONG ProcessCount;

    ProcessInfo = ProcInfoBuffer;
    TotalOffset = 0;
    ProcessCount = 0;
    for (;;)
    {
        if (ProcessCount < Count)
        {
            Ids[ProcessCount] = (ULONG)(ULONG_PTR)ProcessInfo->UniqueProcessId;
        }

        ProcessCount++;

        if (ProcessInfo->NextEntryOffset == 0)
        {
            break;
        }
        
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PUCHAR)ProcInfoBuffer + TotalOffset);
    }

    if (ActualCount != NULL)
    {
        *ActualCount = ProcessCount;
    }

    SIZE_T MemSize;
    
    g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                     (PVOID*)&ProcInfoBuffer, &MemSize,
                                     MEM_RELEASE);
    return Status;
}

HRESULT
W9xGetProcessIds(PULONG Ids, ULONG Count, PULONG ActualCount)
{
#ifndef NT_NATIVE
    HRESULT Status;
    HANDLE Snap;

    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    ULONG ProcessCount = 0;

    for (;;)
    {
        PROCESSENTRY32 Proc;
        BOOL Succ;
        
        Proc.dwSize = sizeof(Proc);
        if (ProcessCount == 0)
        {
            Succ = g_Kernel32Calls.Process32First(Snap, &Proc);
        }
        else
        {
            Succ = g_Kernel32Calls.Process32Next(Snap, &Proc);
        }
        if (!Succ)
        {
            break;
        }

        if (ProcessCount < Count)
        {
            Ids[ProcessCount] = Proc.th32ProcessID;
        }

        ProcessCount++;
    }
                
    if (ActualCount != NULL)
    {
        *ActualCount = ProcessCount;
    }

    CloseHandle(Snap);
    return S_OK;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessIds(
    THIS_
    OUT OPTIONAL /* size_is(Count) */ PULONG Ids,
    IN ULONG Count,
    OUT OPTIONAL PULONG ActualCount
    )
{
    HRESULT Status;

    // Allow privileged enumeration.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    switch(m_PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        return NtGetProcessIds(Ids, Count, ActualCount);
    case VER_PLATFORM_WIN32_WINDOWS:
        return W9xGetProcessIds(Ids, Count, ActualCount);
    default:
        return E_UNEXPECTED;
    }
}

HRESULT
NtGetPidByExe(PCSTR ExeName, ULONG Flags, PULONG Id)
{
    HRESULT Status;
    
    // Rather than converting each process name to ANSI and
    // comparing, convert the incoming name to Unicode so
    // only one conversion is needed.
    WCHAR WideName[MAX_PATH];
    BOOL WideHasPath;

    if (!MultiByteToWideChar(CP_ACP, 0, ExeName, -1,
                             WideName, sizeof(WideName) / sizeof(WCHAR)))
    {
        return WIN32_LAST_STATUS();
    }

    // Check if the given name has path components.
    WideHasPath =
        wcschr(WideName, '\\') != NULL ||
        wcschr(WideName, '/') != NULL ||
        (WideName[0] && WideName[1] == ':');
    
    PSYSTEM_PROCESS_INFORMATION ProcessInfo, ProcInfoBuffer;

    if ((Status = GetNtSystemProcessInformation(&ProcInfoBuffer)) != S_OK)
    {
        return Status;
    }
    
    ULONG TotalOffset;
    ULONG FoundId;

    ProcessInfo = ProcInfoBuffer;
    TotalOffset = 0;
    FoundId = DEBUG_ANY_ID;
    Status = E_NOINTERFACE;
    for (;;)
    {
        PWSTR ImageName;
        
        if (ProcessInfo->ImageName.Buffer == NULL)
        {
            ImageName = SYSTEM_PROCESS_NAME_W;
        }
        else
        {
            ImageName = ProcessInfo->ImageName.Buffer;
        }
        if ((Flags & DEBUG_GET_PROC_FULL_MATCH) == 0 &&
            !WideHasPath)
        {
            PWSTR Slash;
            
            Slash = wcsrchr(ImageName, '\\');
            if (Slash == NULL)
            {
                Slash = wcsrchr(ImageName, '/');
            }
            if (Slash != NULL)
            {
                ImageName = Slash + 1;
            }
        }

        if (!_wcsicmp(ImageName, WideName))
        {
            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) &&
                FoundId != DEBUG_ANY_ID)
            {
                Status = S_FALSE;
                break;
            }
            
            Status = S_OK;
            FoundId = (ULONG)(ULONG_PTR)ProcessInfo->UniqueProcessId;
            *Id = FoundId;

            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) == 0)
            {
                break;
            }
        }

        if (ProcessInfo->NextEntryOffset == 0)
        {
            break;
        }
        
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PUCHAR)ProcInfoBuffer + TotalOffset);
    }

    SIZE_T MemSize;
    
    g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                     (PVOID*)&ProcInfoBuffer, &MemSize,
                                     MEM_RELEASE);
    return Status;
}

HRESULT
W9xGetPidByExe(PCSTR ExeName, ULONG Flags, PULONG Id)
{
#ifndef NT_NATIVE
    HRESULT Status;
    HANDLE Snap;

    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    // Check if the given name has path components.
    BOOL HasPath =
        strchr(ExeName, '\\') != NULL ||
        strchr(ExeName, '/') != NULL ||
        (ExeName[0] && ExeName[1] == ':');

    ULONG FoundId = DEBUG_ANY_ID;
    BOOL First = TRUE;
    
    for (;;)
    {
        PROCESSENTRY32 Proc;
        BOOL Succ;
        
        Proc.dwSize = sizeof(Proc);
        if (First)
        {
            Succ = g_Kernel32Calls.Process32First(Snap, &Proc);
            First = FALSE;
        }
        else
        {
            Succ = g_Kernel32Calls.Process32Next(Snap, &Proc);
        }
        if (!Succ)
        {
            break;
        }

        PSTR ImageName = Proc.szExeFile;
        
        if ((Flags & DEBUG_GET_PROC_FULL_MATCH) == 0 &&
            !HasPath)
        {
            PSTR Slash;
            
            Slash = strrchr(ImageName, '\\');
            if (Slash == NULL)
            {
                Slash = strrchr(ImageName, '/');
            }
            if (Slash != NULL)
            {
                ImageName = Slash + 1;
            }
        }

        if (!_stricmp(ImageName, ExeName))
        {
            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) &&
                FoundId != DEBUG_ANY_ID)
            {
                Status = S_FALSE;
                break;
            }
            
            Status = S_OK;
            FoundId = Proc.th32ProcessID;
            *Id = FoundId;

            if ((Flags & DEBUG_GET_PROC_ONLY_MATCH) == 0)
            {
                break;
            }
        }
    }
                
    CloseHandle(Snap);
    return S_OK;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessIdByExecutableName(
    THIS_
    IN PCSTR ExeName,
    IN ULONG Flags,
    OUT PULONG Id
    )
{
    HRESULT Status;

    // Allow privileged enumeration.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }
    
    switch(m_PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        return NtGetPidByExe(ExeName, Flags, Id);
    case VER_PLATFORM_WIN32_WINDOWS:
        return W9xGetPidByExe(ExeName, Flags, Id);
    default:
        return E_UNEXPECTED;
    }
}

HRESULT
ConvertProcessUnicodeString(HANDLE Process,
                            PUNICODE_STRING UniString,
                            PSTR* AnsiString)
{
    HRESULT Status;
    PSTR Ansi = NULL;
    PWSTR Wide = NULL;
    SIZE_T Done;
    
    Wide = new WCHAR[UniString->Length + 1];
    if (Wide == NULL)
    {
        return E_OUTOFMEMORY;
    }
    Ansi = new CHAR[UniString->Length + 1];
    if (Ansi == NULL)
    {
        Status = E_OUTOFMEMORY;
        goto Exit;
    }

    if (!::ReadProcessMemory(Process, UniString->Buffer, Wide,
                             (UniString->Length + 1) * sizeof(WCHAR), &Done))
    {
        Status = WIN32_LAST_STATUS();
        goto Exit;
    }
    if (Done != (UniString->Length + 1) * sizeof(WCHAR))
    {
        Status = E_FAIL;
        goto Exit;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, Wide, UniString->Length + 1,
                             Ansi, UniString->Length + 1, NULL, NULL))
    {
        Status = WIN32_LAST_STATUS();
        goto Exit;
    }

    *AnsiString = Ansi;
    Ansi = NULL;
    Status = S_OK;
    
 Exit:
    delete Ansi;
    delete Wide;
    return Status;
}

#ifndef NT_NATIVE

HRESULT
NtGetServiceStatus(PULONG NumServices,
                   LPENUM_SERVICE_STATUS_PROCESS* ServiceStatus)
{
    SC_HANDLE Scm;

    Scm = g_Advapi32Calls.OpenSCManagerA(NULL, NULL,
                                         SC_MANAGER_CONNECT |
                                         SC_MANAGER_ENUMERATE_SERVICE);
    if (!Scm)
    {
        return WIN32_LAST_STATUS();
    }

    HRESULT Status;
    LPENUM_SERVICE_STATUS_PROCESS Info;
    ULONG InfoSize = 8 * 1024;
    ULONG ExtraNeeded;
    ULONG Resume;
    ULONG Loop = 0;

    //
    // First pass through the loop allocates from an initial guess.
    // If that isn't sufficient, we make another pass and allocate
    // what is actually needed.  Things may have changed due to
    // other machine changes, so loop around a few times before
    // giving up.
    //
    
    for (;;)
    {
        Info = (LPENUM_SERVICE_STATUS_PROCESS)malloc(InfoSize);
        if (!Info)
        {
            Status = E_OUTOFMEMORY;
            break;
        }

        Resume = 0;
        if (!g_Advapi32Calls.EnumServicesStatusExA(Scm,
                                                   SC_ENUM_PROCESS_INFO,
                                                   SERVICE_WIN32,
                                                   SERVICE_ACTIVE,
                                                   (LPBYTE)Info,
                                                   InfoSize,
                                                   &ExtraNeeded,
                                                   NumServices,
                                                   &Resume,
                                                   NULL))
        {
            free(Info);
            
            if (Loop > 2 || GetLastError() != ERROR_MORE_DATA)
            {
                Status = WIN32_LAST_STATUS();
                break;
            }
        }
        else
        {
            *ServiceStatus = Info;
            Status = S_OK;
            break;
        }
        
        InfoSize += ExtraNeeded;
        Loop++;
    }

    CloseServiceHandle(Scm);
    return Status;
}

HRESULT
NtGetProcessServiceNames(HRESULT RetStatus, ULONG ProcessId,
                         PSTR* Description, ULONG* DescriptionSize,
                         PULONG ActualDescriptionSize, PBOOL Any)
{
    HRESULT Status;
    
    if (!g_Advapi32Calls.EnumServicesStatusExA ||
        !g_Advapi32Calls.OpenSCManagerA)
    {
        return RetStatus;
    }

    ULONG i, NumServices;
    LPENUM_SERVICE_STATUS_PROCESS ServiceStatus;
    BOOL AnyServices = FALSE;

    if ((Status = NtGetServiceStatus(&NumServices, &ServiceStatus)) != S_OK)
    {
        // If we can't get the service status just leave the
        // string unchanged and do not consider it a serious error.
        return RetStatus;
    }

    for (i = 0; i < NumServices; i++)
    {
        if (ServiceStatus[i].ServiceStatusProcess.dwProcessId != ProcessId ||
            !ServiceStatus[i].lpServiceName ||
            !ServiceStatus[i].lpServiceName[0])
        {
            continue;
        }

        PSTR Intro;

        if (AnyServices)
        {
            Intro = ",";
        }
        else if (*Any)
        {
            Intro = "  Services: ";
        }
        else
        {
            Intro = "Services: ";
        }

        RetStatus = AppendToStringBuffer(RetStatus, Intro, !*Any,
                                         Description, DescriptionSize,
                                         ActualDescriptionSize);
        RetStatus = AppendToStringBuffer(RetStatus,
                                         ServiceStatus[i].lpServiceName, FALSE,
                                         Description, DescriptionSize,
                                         ActualDescriptionSize);

        *Any = TRUE;
        AnyServices = TRUE;
    }

    free(ServiceStatus);
    return RetStatus;
}

HRESULT
NtGetProcessMtsPackageNames(HRESULT RetStatus, ULONG ProcessId,
                            PSTR* Description, ULONG* DescriptionSize,
                            PULONG ActualDescriptionSize, PBOOL Any)
{
    HRESULT Status;
    
    // Load and initialize ole32.dll so we can call CoCreateInstance.
    if ((Status = InitDynamicCalls(&g_Ole32CallsDesc)) != S_OK ||
        (Status = InitDynamicCalls(&g_OleAut32CallsDesc)) != S_OK ||
        (Status = g_Ole32Calls.
         CoInitializeEx(NULL, COINIT_MULTITHREADED)) != S_OK)
    {
        // Just leave things unchanged on failure.
        return RetStatus;
    }

    IMtsGrp* MtsGrp = NULL;
    long Packages;
    long i;
    BOOL AnyPackages = FALSE;

    if ((Status = g_Ole32Calls.
         CoCreateInstance(CLSID_MtsGrp, NULL, CLSCTX_ALL,
                          __uuidof(IMtsGrp), (void **)&MtsGrp)) != S_OK ||
        (Status = MtsGrp->Refresh()) != S_OK ||
        (Status = MtsGrp->get_Count(&Packages)) != S_OK)
    {
        goto Exit;
    }
        
    for (i = 0; i < Packages; i++)
    {
        IUnknown* Unk;
        IMtsEvents* Events;
        BSTR Name;
        ULONG Pid;
        
        if ((Status = MtsGrp->Item(i, &Unk)) != S_OK)
        {
            continue;
        }

        Status = Unk->QueryInterface(IID_IMtsEvents, (void **)&Events);

        Unk->Release();

        if (Status != S_OK)
        {
            continue;
        }
        
        Status = Events->GetProcessID((PLONG)&Pid);
        if (Status == S_OK && Pid == ProcessId)
        {
            Status = Events->get_PackageName(&Name);
        }

        Events->Release();

        if (Status != S_OK || Pid != ProcessId)
        {
            continue;
        }

        char NameA[MAX_PATH];
        int Conv;

        Conv = WideCharToMultiByte(CP_ACP, 0, Name, -1, NameA, sizeof(NameA),
                                   NULL, NULL);

        g_OleAut32Calls.SysFreeString(Name);

        if (Conv > 0)
        {
            PSTR Intro;

            if (AnyPackages)
            {
                Intro = ",";
            }
            else if (*Any)
            {
                Intro = "  MTS Packages: ";
            }
            else
            {
                Intro = "MTS Packages: ";
            }

            RetStatus = AppendToStringBuffer(RetStatus, Intro, !*Any,
                                             Description, DescriptionSize,
                                             ActualDescriptionSize);
            RetStatus = AppendToStringBuffer(RetStatus, NameA, FALSE,
                                             Description, DescriptionSize,
                                             ActualDescriptionSize);

            *Any = TRUE;
            AnyPackages = TRUE;
        }
    }

 Exit:
    if (MtsGrp)
    {
        MtsGrp->Release();
    }
    g_Ole32Calls.CoUninitialize();
    return RetStatus;
}

#endif // #ifndef NT_NATIVE

HRESULT
NtGetProcDesc(ULONG ProcessId, ULONG Flags,
              PSTR ExeName, ULONG ExeNameSize, PULONG ActualExeNameSize,
              PSTR Description, ULONG DescriptionSize,
              PULONG ActualDescriptionSize)
{
    HRESULT Status;

    if (ProcessId == 0)
    {
        // This is base system process so fake the description.
        Status = FillStringBuffer(SYSTEM_PROCESS_NAME, 0,
                                  ExeName, ExeNameSize, ActualExeNameSize);
        FillStringBuffer("", 0,
                         Description, DescriptionSize, ActualDescriptionSize);
        return Status;
    }
    
    NTSTATUS NtStatus;
    HANDLE Process;

    OBJECT_ATTRIBUTES ObjAttr;
    CLIENT_ID ClientId;

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = (HANDLE)(ULONG_PTR)ProcessId;
    InitializeObjectAttributes(&ObjAttr, NULL, 0, NULL, NULL);
    NtStatus = g_NtDllCalls.NtOpenProcess(&Process, PROCESS_ALL_ACCESS,
                                          &ObjAttr, &ClientId);
    if (!NT_SUCCESS(NtStatus))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto EH_Exit;
    }

    PROCESS_BASIC_INFORMATION ProcBasic;
    ULONG Done;
    
    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(Process, ProcessBasicInformation,
                                  &ProcBasic, sizeof(ProcBasic), &Done);
    if (!NT_SUCCESS(NtStatus))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto EH_Process;
    }
    if (Done != sizeof(ProcBasic))
    {
        Status = E_FAIL;
        goto EH_Process;
    }

    if (ProcBasic.PebBaseAddress == 0)
    {
        // This process has no PEB so fake the description.
        Status = FillStringBuffer(PEBLESS_PROCESS_NAME, 0,
                                  ExeName, ExeNameSize, ActualExeNameSize);
        FillStringBuffer("", 0,
                         Description, DescriptionSize, ActualDescriptionSize);
        goto EH_Process;
    }
    
    PEB Peb;
    SIZE_T DoneSize;

    if (!::ReadProcessMemory(Process, ProcBasic.PebBaseAddress,
                             &Peb, sizeof(Peb), &DoneSize))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Process;
    }
    if (DoneSize != sizeof(Peb))
    {
        Status = E_FAIL;
        goto EH_Process;
    }

    RTL_USER_PROCESS_PARAMETERS Params;

    if (!::ReadProcessMemory(Process, Peb.ProcessParameters,
                             &Params, sizeof(Params), &DoneSize))
    {
        Status = WIN32_LAST_STATUS();
        goto EH_Process;
    }
    if (DoneSize != sizeof(Params))
    {
        Status = E_FAIL;
        goto EH_Process;
    }
    
    if (Params.ImagePathName.Buffer != NULL)
    {
        PSTR AnsiImage, ImageName;

        if ((Status = ConvertProcessUnicodeString(Process,
                                                  &Params.ImagePathName,
                                                  &AnsiImage)) != S_OK)
        {
            goto EH_Process;
        }

        if (Flags & DEBUG_PROC_DESC_NO_PATHS)
        {
            ImageName = strrchr(AnsiImage, '\\');
            if (ImageName == NULL)
            {
                ImageName = strrchr(AnsiImage, '/');
            }
            if (ImageName == NULL)
            {
                ImageName = AnsiImage;
            }
            else
            {
                ImageName++;
            }
        }
        else
        {
            ImageName = AnsiImage;
        }
        
        Status = FillStringBuffer(ImageName, 0,
                                  ExeName, ExeNameSize, ActualExeNameSize);

        delete AnsiImage;
    }
    else
    {
        Status = FillStringBuffer(SYSTEM_PROCESS_NAME, 0,
                                  ExeName, ExeNameSize, ActualExeNameSize);
    }

#ifndef NT_NATIVE
    if ((Description && DescriptionSize) || ActualDescriptionSize)
    {
        BOOL Any = FALSE;

        Status = NtGetProcessServiceNames(Status, ProcessId,
                                          &Description, &DescriptionSize,
                                          ActualDescriptionSize, &Any);
        Status = NtGetProcessMtsPackageNames(Status, ProcessId,
                                             &Description, &DescriptionSize,
                                             ActualDescriptionSize, &Any);
        if (!Any)
        {
            if (FillStringBuffer("", 0,
                                 Description, DescriptionSize,
                                 ActualDescriptionSize) == S_FALSE)
            {
                Status = S_FALSE;
            }
        }
    }
    else
#endif // #ifndef NT_NATIVE
    {
        FillStringBuffer("", 0,
                         Description, DescriptionSize, ActualDescriptionSize);
    }

 EH_Process:
    g_NtDllCalls.NtClose(Process);
 EH_Exit:
    return Status;
}

HRESULT
W9xGetProcDesc(ULONG ProcessId, ULONG Flags,
               PSTR ExeName, ULONG ExeNameSize, PULONG ActualExeNameSize,
               PSTR Description, ULONG DescriptionSize,
               PULONG ActualDescriptionSize)
{
#ifndef NT_NATIVE
    HRESULT Status;
    HANDLE Snap;

    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    BOOL First = TRUE;

    Status = E_NOINTERFACE;
    for (;;)
    {
        PROCESSENTRY32 Proc;
        BOOL Succ;
        
        Proc.dwSize = sizeof(Proc);
        if (First)
        {
            Succ = g_Kernel32Calls.Process32First(Snap, &Proc);
            First = FALSE;
        }
        else
        {
            Succ = g_Kernel32Calls.Process32Next(Snap, &Proc);
        }
        if (!Succ)
        {
            break;
        }

        if (Proc.th32ProcessID == ProcessId)
        {
            PSTR AnsiImage = Proc.szExeFile;
            PSTR ImageName;
            
            if (Flags & DEBUG_PROC_DESC_NO_PATHS)
            {
                ImageName = strrchr(AnsiImage, '\\');
                if (ImageName == NULL)
                {
                    ImageName = strrchr(AnsiImage, '/');
                }
                if (ImageName == NULL)
                {
                    ImageName = AnsiImage;
                }
                else
                {
                    ImageName++;
                }
            }
            else
            {
                ImageName = AnsiImage;
            }

            Status = FillStringBuffer(ImageName, 0,
                                      ExeName, ExeNameSize, ActualExeNameSize);
            break;
        }
    }
                
    CloseHandle(Snap);

    // Win9x doesn't have services and we don't have to
    // worry about IIS so there's currently nothing we provide
    // as a description.
    FillStringBuffer("", 0,
                     Description, DescriptionSize, ActualDescriptionSize);
    return Status;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessDescription(
    THIS_
    IN ULONG ProcessId,
    IN ULONG Flags,
    OUT OPTIONAL PSTR ExeName,
    IN ULONG ExeNameSize,
    OUT OPTIONAL PULONG ActualExeNameSize,
    OUT OPTIONAL PSTR Description,
    IN ULONG DescriptionSize,
    OUT OPTIONAL PULONG ActualDescriptionSize
    )
{
    HRESULT Status;

    // Allow privileged access.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    switch(m_PlatformId)
    {
    case VER_PLATFORM_WIN32_NT:
        return NtGetProcDesc(ProcessId, Flags, ExeName, ExeNameSize,
                             ActualExeNameSize, Description, DescriptionSize,
                             ActualDescriptionSize);
    case VER_PLATFORM_WIN32_WINDOWS:
        return W9xGetProcDesc(ProcessId, Flags, ExeName, ExeNameSize,
                              ActualExeNameSize, Description, DescriptionSize,
                              ActualDescriptionSize);
    default:
        return E_UNEXPECTED;
    }
}

HRESULT
InsertUserThread(PUSER_THREAD_INFO Threads, ULONG Index,
                 HRESULT Status, ULONG ThreadId, HANDLE ThreadHandle,
                 PUSER_THREAD_INFO PrevThreads, ULONG PrevInfoCount)
{
    // Suspend the thread immediately to try and keep the
    // process state as static as we can.
    if (::SuspendThread(ThreadHandle) == -1)
    {
        Status = WIN32_LAST_STATUS();
        ::CloseHandle(ThreadHandle);
    }
    
    if (Status != S_OK)
    {
        while (Index-- > 0)
        {
            ::ResumeThread(OS_HANDLE(Threads[Index].Handle));
            ::CloseHandle(OS_HANDLE(Threads[Index].Handle));
        }
        return Status;
    }

    Threads[Index].Handle = SERVICE_HANDLE(ThreadHandle);
    Threads[Index].Id = ThreadId;
    Threads[Index].Reserved = 0;

    //
    // Search for this thread in any previous information.
    //
    
    if (PrevThreads == NULL)
    {
        return S_OK;
    }

    ULONG i;

    Status = S_FALSE;
    for (i = 0; i < PrevInfoCount; i++)
    {
        if (PrevThreads[i].Id == ThreadId)
        {
            // Found a match.
            Status = S_OK;
            break;
        }
    }
    
    return Status;
}

HRESULT
NtGetProcThreads(ULONG ProcessId, PUSER_THREAD_INFO Threads,
                 ULONG InfoCount, PULONG ThreadCount,
                 ULONG SysProcInfoSize,
                 PUSER_THREAD_INFO PrevThreads, ULONG PrevInfoCount)
{
    HRESULT Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo, ProcInfoBuffer;
    
    if ((Status = GetNtSystemProcessInformation(&ProcInfoBuffer)) != S_OK)
    {
        return Status;
    }
    
    ULONG TotalOffset;

    ProcessInfo = ProcInfoBuffer;
    TotalOffset = 0;
    for (;;)
    {
        if (ProcessInfo->UniqueProcessId == (HANDLE)(ULONG_PTR)ProcessId ||
            ProcessInfo->NextEntryOffset == 0)
        {
            break;
        }
        
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((PUCHAR)ProcInfoBuffer + TotalOffset);
    }

    if (ProcessInfo->UniqueProcessId == (HANDLE)(ULONG_PTR)ProcessId)
    {
        if (ThreadCount != NULL)
        {
            *ThreadCount = ProcessInfo->NumberOfThreads;
        }

        if (ProcessInfo->NumberOfThreads < InfoCount)
        {
            InfoCount = ProcessInfo->NumberOfThreads;
        }

        // If the last iteration returned a different number
        // of threads there's a mismatch so we need to return S_FALSE.
        Status = (PrevThreads != NULL &&
                  PrevInfoCount != ProcessInfo->NumberOfThreads) ?
            S_FALSE : S_OK;
        
        PSYSTEM_THREAD_INFORMATION ThreadInfo = (PSYSTEM_THREAD_INFORMATION)
            ((PUCHAR)ProcessInfo + SysProcInfoSize);
        for (ULONG i = 0; i < InfoCount; i++)
        {
            NTSTATUS NtStatus;
            OBJECT_ATTRIBUTES ObjAttr;
            HANDLE Thread;
            HRESULT SingleStatus;

            InitializeObjectAttributes(&ObjAttr, NULL, 0, NULL, NULL);
            NtStatus = g_NtDllCalls.
                NtOpenThread(&Thread, THREAD_ALL_ACCESS, &ObjAttr,
                             &ThreadInfo->ClientId);

            SingleStatus = InsertUserThread
                (Threads, i, CONV_NT_STATUS(NtStatus),
                 (ULONG)(ULONG_PTR)ThreadInfo->ClientId.UniqueThread,
                 Thread, PrevThreads, PrevInfoCount);
            if (SingleStatus == S_FALSE)
            {
                // Inserted thread didn't match so return S_FALSE.
                Status = S_FALSE;
            }
            else if (SingleStatus != S_OK)
            {
                Status = SingleStatus;
                break;
            }

            ThreadInfo++;
        }
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    SIZE_T MemSize;
        
    g_NtDllCalls.NtFreeVirtualMemory(NtCurrentProcess(),
                                     (PVOID*)&ProcInfoBuffer, &MemSize,
                                     MEM_RELEASE);
    return Status;
}

// These functions are in the minidump library and are
// not really public functions, but we need them so
// just extern them here.
#ifdef _X86_
extern "C" BOOL WinInitialize(void);
extern "C" HANDLE WINAPI WinOpenThread(DWORD dwAccess, BOOL bInheritHandle,
                                       DWORD ThreadId);
#else
#define WinInitialize() FALSE
#define WinOpenThread(dwAccess, bInheritHandle, ThreadId) NULL
#endif

HRESULT
W9xGetProcThreads(ULONG ProcessId, PUSER_THREAD_INFO Threads,
                  ULONG InfoCount, PULONG ThreadCount,
                  PUSER_THREAD_INFO PrevThreads, ULONG PrevInfoCount)
{
#ifndef NT_NATIVE
    HRESULT Status;
    HANDLE Snap;

    if (!WinInitialize())
    {
        return WIN32_LAST_STATUS();
    }
    
    Snap = g_Kernel32Calls.CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD,
                                                    ProcessId);
    if (Snap == INVALID_HANDLE_VALUE)
    {
        return WIN32_LAST_STATUS();
    }

    BOOL First = TRUE;
    ULONG NumThreads = 0;

    Status = S_OK;
    for (;;)
    {
        THREADENTRY32 Thread;
        BOOL Succ;
        
        Thread.dwSize = sizeof(Thread);
        if (First)
        {
            Succ = g_Kernel32Calls.Thread32First(Snap, &Thread);
            First = FALSE;
        }
        else
        {
            Succ = g_Kernel32Calls.Thread32Next(Snap, &Thread);
        }
        if (!Succ)
        {
            break;
        }

        if (Thread.th32OwnerProcessID == ProcessId)
        {
            if (NumThreads < InfoCount)
            {
                HRESULT SingleStatus;
                
                HANDLE Handle = WinOpenThread(THREAD_ALL_ACCESS, FALSE,
                                              Thread.th32ThreadID);
                
                SingleStatus = InsertUserThread
                    (Threads, NumThreads, CONV_W32_STATUS(Handle != NULL),
                     Thread.th32ThreadID, Handle, PrevThreads, PrevInfoCount);
                if (SingleStatus == S_FALSE)
                {
                    // Inserted thread didn't match so return S_FALSE.
                    Status = S_FALSE;
                }
                else if (SingleStatus != S_OK)
                {
                    Status = SingleStatus;
                    break;
                }
            }

            NumThreads++;
        }
    }
                
    if (ThreadCount != NULL)
    {
        *ThreadCount = NumThreads;
    }

    if (Status == S_OK)
    {
        // If no threads were found the process must be invalid.
        if (NumThreads == 0)
        {
            Status = E_NOINTERFACE;
        }
        else if (PrevThreads != NULL && NumThreads != PrevInfoCount)
        {
            // Thread count didn't match so return S_FALSE.
            Status = S_FALSE;
        }
    }
    
    CloseHandle(Snap);
    return Status;
#else
    return E_UNEXPECTED;
#endif
}

STDMETHODIMP
LiveUserDebugServices::GetProcessInfo(
    THIS_
    IN ULONG ProcessId,
    OUT OPTIONAL PULONG64 Handle,
    OUT OPTIONAL /* size_is(InfoCount) */ PUSER_THREAD_INFO Threads,
    IN ULONG InfoCount,
    OUT OPTIONAL PULONG ThreadCount
    )
{
    HANDLE Process;
    HRESULT Status;

    // Enable the privilege that allows the user to debug
    // another process.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    if (Handle != NULL)
    {
        // This should always be a real process ID so there's
        // no need to look for the special CSR value.
        Process = ::OpenProcess(PROCESS_ALL_ACCESS, 0, ProcessId);
        if (Process == NULL)
        {
            return WIN32_LAST_STATUS();
        }
        
        *Handle = SERVICE_HANDLE(Process);
    }
    else
    {
        Process = NULL;
    }

    if (Threads != NULL || ThreadCount != NULL)
    {
        PUSER_THREAD_INFO PrevThreads;
        ULONG PrevInfoCount;
        ULONG _ThreadCount;
        
        //
        // We need to enumerate the threads in the process.
        // This is a difficult thing to get right as
        // the thread state for the process can continuously
        // change.  In order to try and get a clean snapshot
        // of the thread state we iteratively enumerate until
        // we get two consecutive snapshots that match.
        //
        // We suspend enumerated threads immediately to
        // reduce churn from inside the process itself.
        // We can't do anything about external processes so
        // the enumeration could still get stale right after
        // we return but by stopping everything in the process
        // itself we do what we can.
        //
        // If the caller is just getting the count and
        // not the actual thread information we don't bother
        // iterating as there's no expectation that the
        // thread state will be the same from one call to
        // the next so there's no need to do the extra work.
        //

        if (Threads != NULL)
        {
            // Allocate an array to hold previous results.  This
            // can always be the same size as the return array
            // because if there are more threads than can fit in
            // the return array the snapshot will be wrong anyway
            // so we just return without doing comparisons.
            PrevThreads = new USER_THREAD_INFO[InfoCount];
            if (PrevThreads == NULL)
            {
                Status = E_OUTOFMEMORY;
                goto EH_CloseProc;
            }
        }
        else
        {
            PrevThreads = NULL;
        }
        PrevInfoCount = 0;

        for (;;)
        {
            switch(m_PlatformId)
            {
            case VER_PLATFORM_WIN32_NT:
                Status = NtGetProcThreads(ProcessId, Threads, InfoCount,
                                          &_ThreadCount, m_SysProcInfoSize,
                                          PrevThreads, PrevInfoCount);
                break;
            case VER_PLATFORM_WIN32_WINDOWS:
                Status = W9xGetProcThreads(ProcessId, Threads, InfoCount,
                                           &_ThreadCount, PrevThreads,
                                           PrevInfoCount);
                break;
            default:
                Status = E_UNEXPECTED;
                break;
            }

            //
            // We can clean up any previous information now.
            //
            
            ULONG i;

            for (i = 0; i < PrevInfoCount; i++)
            {
                ::ResumeThread(OS_HANDLE(PrevThreads[i].Handle));
                ::CloseHandle(OS_HANDLE(PrevThreads[i].Handle));
            }

            if (Status != S_FALSE ||
                _ThreadCount > InfoCount)
            {
                // The snapshot either matched the previous
                // snapshot or there was an error.  Also,
                // if the snapshot overflowed the return array
                // quit and give the caller the option of
                // calling again when they notice they didn't
                // get a complete snapshot.
                break;
            }

            // There was a snapshot mismatch so loop again
            // with this snapshot as the previous data.
            PrevInfoCount = _ThreadCount;
            if (PrevInfoCount > InfoCount)
            {
                PrevInfoCount = InfoCount;
            }

            RtlCopyMemory(PrevThreads, Threads,
                          PrevInfoCount * sizeof(*PrevThreads));
        }

        if (ThreadCount != NULL)
        {
            *ThreadCount = _ThreadCount;
        }

        delete PrevThreads;

    EH_CloseProc:
        if (Status != S_OK && Process != NULL)
        {
            ::CloseHandle(Process);
        }
    }
    else
    {
        Status = S_OK;
    }

    return Status;
}

HRESULT
ProcessIdToHandle(ULONG ProcessId, PHANDLE Process)
{
    if (ProcessId == CSRSS_PROCESS_ID)
    {
        if (g_NtDllCalls.CsrGetProcessId != NULL)
        {
            ProcessId = (ULONG)(ULONG_PTR)g_NtDllCalls.CsrGetProcessId();
        }
        else
        {
            *Process = NULL;
            return S_OK;
        }
    }
    
    *Process = ::OpenProcess(PROCESS_ALL_ACCESS, 0, ProcessId);
    if (*Process == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

NTSTATUS
CreateDebugObject(PHANDLE Object)
{
    if (*Object != NULL)
    {
        return STATUS_SUCCESS;
    }
    
    OBJECT_ATTRIBUTES Attr;
    
    InitializeObjectAttributes(&Attr, NULL, 0, NULL, g_AllAccessSecDesc);
    return g_NtDllCalls.NtCreateDebugObject(Object, DEBUG_ALL_ACCESS,
                                            &Attr, DEBUG_KILL_ON_CLOSE);
}

HRESULT
LiveUserDebugServices::SysGetProcessOptions(HANDLE Process, PULONG Options)
{
    NTSTATUS NtStatus;
    ULONG Flags;

    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        NtStatus = g_NtDllCalls.
            NtQueryInformationProcess(Process, ProcessDebugFlags,
                                      &Flags, sizeof(Flags), NULL);
    }
    else
    {
        NtStatus = STATUS_INVALID_INFO_CLASS;
    }
    if (NtStatus == STATUS_INVALID_INFO_CLASS)
    {
        // The system doesn't support control over the
        // debug flags.  In the attach case this means
        // the flags will be DEBUG_ONLY_THIS_PROCESS.
        *Options = DEBUG_PROCESS_ONLY_THIS_PROCESS;
        NtStatus = STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(NtStatus))
    {
        *Options = 0;
        if ((Flags & PROCESS_DEBUG_INHERIT) == 0)
        {
            *Options = DEBUG_PROCESS_ONLY_THIS_PROCESS;
        }
    }

    return CONV_NT_STATUS(NtStatus);
}

HRESULT
LiveUserDebugServices::OpenDebugActiveProcess(ULONG ProcessId,
                                              HANDLE Process)
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT ||
        !m_UseDebugObject)
    {
        return E_NOTIMPL;
    }
    
    // We're going to open the process's existing debug
    // object and use it so we can't already have a debug object.
    if (Process == NULL || m_DebugObject != NULL)
    {
        return E_UNEXPECTED;
    }

    NTSTATUS NtStatus;

    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(Process, ProcessDebugObjectHandle,
                                  &m_DebugObject, sizeof(m_DebugObject), NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    return S_OK;
}

HRESULT
LiveUserDebugServices::CreateDebugActiveProcess(ULONG ProcessId,
                                                HANDLE Process)
{
    if (m_UseDebugObject)
    {
        if (Process == NULL)
        {
            return E_FAIL;
        }
        if (g_NtDllCalls.NtDebugActiveProcess == NULL)
        {
            return E_NOTIMPL;
        }
        
        NTSTATUS NtStatus;

        NtStatus = CreateDebugObject(&m_DebugObject);
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = g_NtDllCalls.NtDebugActiveProcess(Process,
                                                         m_DebugObject);
            if (NT_SUCCESS(NtStatus))
            {
                g_NtDllCalls.DbgUiIssueRemoteBreakin(Process);
            }
        }
        if (!NT_SUCCESS(NtStatus))
        {
            return HRESULT_FROM_NT(NtStatus);
        }
    }
#ifndef NT_NATIVE
    else if (!::DebugActiveProcess(ProcessId))
    {
        return WIN32_LAST_STATUS();
    }
#else
    else
    {
        return E_UNEXPECTED;
    }
#endif

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::AttachProcess(
    THIS_
    IN ULONG ProcessId,
    IN ULONG AttachFlags,
    OUT PULONG64 ProcessHandle,
    OUT PULONG ProcessOptions
    )
{
    HRESULT Status;
    
    // Enable the privilege that allows the user to debug
    // another process.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    HANDLE Process;
    
    if (ProcessId == CSRSS_PROCESS_ID)
    {
        CloseProfileUserMapping();
    }

    if ((Status = ProcessIdToHandle(ProcessId, &Process)) != S_OK)
    {
        return Status;
    }

    if ((Status = SysGetProcessOptions(Process, ProcessOptions)) != S_OK)
    {
        if (Process != NULL)
        {
            ::CloseHandle(Process);
        }
        return Status;
    }

    if (AttachFlags & DEBUG_ATTACH_EXISTING)
    {
        Status = OpenDebugActiveProcess(ProcessId, Process);
    }
    else
    {
        Status = CreateDebugActiveProcess(ProcessId, Process);
    }
    if (Status != S_OK)
    {
        if (Process != NULL)
        {
            ::CloseHandle(Process);
        }
        return Status;
    }

    *ProcessHandle = SERVICE_HANDLE(Process);
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::DetachProcess(
    THIS_
    IN ULONG ProcessId
    )
{
    HRESULT Status;

    //
    // A ProcessId of zero means that the caller is just
    // checking for detach support and no actual detach
    // should occur.
    //

    if (m_UseDebugObject)
    {
        if (g_NtDllCalls.NtRemoveProcessDebug == NULL)
        {
            return E_NOTIMPL;
        }

        // Check for the query before checking the debug
        // object as the query may come in early.
        if (ProcessId == 0)
        {
            return S_OK;
        }
        
        if (m_DebugObject == NULL)
        {
            return E_UNEXPECTED;
        }

        HANDLE Process;

        if ((Status = ProcessIdToHandle(ProcessId, &Process)) != S_OK)
        {
            return Status;
        }
        if (Process == NULL)
        {
            return E_FAIL;
        }

        NTSTATUS NtStatus;

        NtStatus = g_NtDllCalls.
            NtRemoveProcessDebug(Process, m_DebugObject);
        Status = CONV_NT_STATUS(NtStatus);
            
        ::CloseHandle(Process);
    }
    else
    {
        if (g_Kernel32Calls.DebugActiveProcessStop == NULL)
        {
            return E_NOTIMPL;
        }

        if (ProcessId == 0)
        {
            return S_OK;
        }
        
        if (!g_Kernel32Calls.DebugActiveProcessStop(ProcessId))
        {
            return WIN32_LAST_STATUS();
        }
    }

    return S_OK;
}

#ifdef NT_NATIVE

NTSTATUS
NtSimpleCreateProcess(PCSTR CommandLine, ULONG CreateFlags,
                      HANDLE DebugObject, PPROCESS_INFORMATION RetInfo)
{
    NTSTATUS Status;
    ANSI_STRING Ansi;
    UNICODE_STRING RawAppName, AppName;
    UNICODE_STRING WideCmdLine;
    PRTL_USER_PROCESS_PARAMETERS Params;
    RTL_USER_PROCESS_INFORMATION Info;

    if (CreateFlags & DEBUG_ONLY_THIS_PROCESS)
    {
        // The hacked way of controlling debug inheritance
        // is via the low bit of the debug object handle.
        // If the bit is set it means do not inherit.
        DebugObject = (HANDLE)((ULONG_PTR)DebugObject | 1);
    }

    //
    // This is a simple interface, so assume the first
    // space-delimited token is the executable to run.
    //
    
    PCSTR ExeStart, ExeEnd;

    ExeStart = CommandLine;
    while (*ExeStart == ' ' || *ExeStart == '\t')
    {
        ExeStart++;
    }
    if (*ExeStart == 0)
    {
        return STATUS_INVALID_PARAMETER;
    }
    ExeEnd = ExeStart;
    while (*ExeEnd && !(*ExeEnd == ' ' || *ExeEnd == '\t'))
    {
        ExeEnd++;
    }
    
    Ansi.Buffer = (PSTR)ExeStart;
    Ansi.Length = (USHORT)(ExeEnd - ExeStart);
    Ansi.MaximumLength = Ansi.Length;
    Status = RtlAnsiStringToUnicodeString(&RawAppName, &Ansi, TRUE);
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    Status = RtlDosPathNameToNtPathName_U(RawAppName.Buffer, &AppName,
                                          NULL, NULL);
    if (!NT_SUCCESS(Status))
    {
        goto EH_RawAppName;
    }

    RtlInitAnsiString(&Ansi, CommandLine);
    Status = RtlAnsiStringToUnicodeString(&WideCmdLine, &Ansi, TRUE);
    if (!NT_SUCCESS(Status))
    {
        goto EH_AppName;
    }

    Status = RtlCreateProcessParameters(&Params, &AppName, NULL, NULL,
                                        &WideCmdLine, NULL, NULL, NULL,
                                        NULL, NULL);
    if (!NT_SUCCESS(Status))
    {
        goto EH_WideCmdLine;
    }

    Info.Length = sizeof(Info);
    
    Status = RtlCreateUserProcess(&AppName, OBJ_CASE_INSENSITIVE,
                                  Params, NULL, NULL, NULL, FALSE,
                                  DebugObject, NULL, &Info);

    RtlDestroyProcessParameters(Params);

    if (NT_SUCCESS(Status))
    {
        RetInfo->dwProcessId = HandleToUlong(Info.ClientId.UniqueProcess);
        RetInfo->dwThreadId = HandleToUlong(Info.ClientId.UniqueThread);
        RetInfo->hProcess = Info.Process;
        RetInfo->hThread = Info.Thread;
        if ((CreateFlags & CREATE_SUSPENDED) == 0)
        {
            NtResumeThread(Info.Thread, NULL);
        }
    }

 EH_WideCmdLine:
    RtlFreeUnicodeString(&WideCmdLine);
 EH_AppName:
    RtlFreeUnicodeString(&AppName);
 EH_RawAppName:
    RtlFreeUnicodeString(&RawAppName);
    return Status;
}

#endif // #ifdef NT_NATIVE

#define DHEAP_ENV "_NO_DEBUG_HEAP"

STDMETHODIMP
LiveUserDebugServices::CreateProcess(
    THIS_
    IN PSTR CommandLine,
    IN ULONG CreateFlags,
    OUT PULONG ProcessId,
    OUT PULONG ThreadId,
    OUT PULONG64 ProcessHandle,
    OUT PULONG64 ThreadHandle
    )
{
    HRESULT Status;

    // Enable the privilege that allows the user to debug
    // another process.
    if ((Status = EnableDebugPrivilege()) != S_OK)
    {
        return Status;
    }

    // The system looks at the environment variable
    // _NO_DEBUG_HEAP to determine whether the new
    // process should use the debug heap or not.  If
    // the caller has requested the normal heap
    // set this environment variable so that it's
    // inherited.
    if (CreateFlags & DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP)
    {
        ::SetEnvironmentVariable(DHEAP_ENV, "1");
        // Turn off this flag since it's not meaningful
        // to CreateProcess itself.
        CreateFlags &= ~DEBUG_CREATE_PROCESS_NO_DEBUG_HEAP;
    }
    
    PROCESS_INFORMATION ProcInfo;

#ifndef NT_NATIVE
    
    HANDLE OldDebugObject;
    BOOL SetOldDebugObject = FALSE;

    Status = S_OK;

    if (m_UseDebugObject)
    {
        //
        // Set up this thread's debug object to the one that
        // we're using so that our debug object is used when
        // debugging the new process.  This lets us continue
        // to use the normal Win32 CreateProcess call rather
        // than trying to go through NtCreateProcessEx and
        // guarantees we get all the Win32 process creation logic.
        //
        
        if (g_NtDllCalls.DbgUiSetThreadDebugObject == NULL)
        {
            Status = E_NOTIMPL;
        }
        else
        {
            NTSTATUS NtStatus;
            
            OldDebugObject = g_NtDllCalls.DbgUiGetThreadDebugObject();

            NtStatus = CreateDebugObject(&m_DebugObject);
            if (NT_SUCCESS(NtStatus))
            {
                g_NtDllCalls.DbgUiSetThreadDebugObject(m_DebugObject);
                SetOldDebugObject = TRUE;
            }
            else
            {
                Status = HRESULT_FROM_NT(NtStatus);
            }
        }
    }

    if (Status == S_OK)
    {
        STARTUPINFO StartupInfo;
    
        ZeroMemory(&StartupInfo, sizeof(StartupInfo));
        StartupInfo.cb = sizeof(StartupInfo);
        
        if (!::CreateProcess(NULL, CommandLine, NULL, NULL, TRUE,
                             CreateFlags, NULL, NULL,
                             &StartupInfo, &ProcInfo))
        {
            Status = WIN32_LAST_STATUS();
        }
        else
        {
            Status = S_OK;
        }
    }

    if (SetOldDebugObject)
    {
        g_NtDllCalls.DbgUiSetThreadDebugObject(OldDebugObject);
    }

#else // #ifndef NT_NATIVE

    if (!m_UseDebugObject)
    {
        Status = E_UNEXPECTED;
    }
    else
    {
        NTSTATUS NtStatus;

        NtStatus = CreateDebugObject(&m_DebugObject);
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = NtSimpleCreateProcess(CommandLine, CreateFlags,
                                             m_DebugObject, &ProcInfo);
        }
        Status = CONV_NT_STATUS(NtStatus);
    }
    
#endif // #ifndef NT_NATIVE

    // Clear the special debug heap variable so it
    // isn't inadvertently used somewhere else.
    ::SetEnvironmentVariable(DHEAP_ENV, NULL);

    if (Status == S_OK)
    {
        *ProcessId = ProcInfo.dwProcessId;
        *ThreadId = ProcInfo.dwThreadId;
        *ProcessHandle = SERVICE_HANDLE(ProcInfo.hProcess);
        *ThreadHandle = SERVICE_HANDLE(ProcInfo.hThread);
    }
    
    return Status;
}

STDMETHODIMP
LiveUserDebugServices::TerminateProcess(
    THIS_
    IN ULONG64 Process,
    IN ULONG ExitCode
    )
{
    if (!::TerminateProcess(OS_HANDLE(Process), ExitCode))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::AbandonProcess(
    THIS_
    IN ULONG64 Process
    )
{
    HRESULT Status;

    //
    // In order to abandon a process but still leave it
    // as being debugged we need to get the process's
    // debug object and duplicate it into the debuggee
    // process.  This gives the debuggee process itself
    // a reference to its debug object, creating a circle
    // that will keep the process alive and in the debugged
    // state.
    //
    // This circular reference will also mean that the
    // process must be manually killed.  This may be
    // something interesting to address at some point.
    //

    if (m_DebugObject == NULL)
    {
        return E_NOTIMPL;
    }

    HANDLE Dup;
    
    if (!::DuplicateHandle(GetCurrentProcess(), m_DebugObject,
                           OS_HANDLE(Process), &Dup, 0, FALSE,
                           DUPLICATE_SAME_ACCESS))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetProcessExitCode(
    THIS_
    IN ULONG64 Process,
    OUT PULONG ExitCode
    )
{
    if (!::GetExitCodeProcess(OS_HANDLE(Process), ExitCode))
    {
        return WIN32_LAST_STATUS();
    }

    return *ExitCode == STILL_ACTIVE ? S_FALSE : S_OK;
}

STDMETHODIMP
LiveUserDebugServices::CloseHandle(
    THIS_
    IN ULONG64 Handle
    )
{
    if (Handle == 0)
    {
        return S_FALSE;
    }

    if (!::CloseHandle(OS_HANDLE(Handle)))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::SetProcessOptions(
    THIS_
    IN ULONG64 Process,
    IN ULONG Options
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    ULONG NtFlags = 0;

    if ((Options & DEBUG_PROCESS_ONLY_THIS_PROCESS) == 0)
    {
        NtFlags |= PROCESS_DEBUG_INHERIT;
    }
    
    NtStatus = g_NtDllCalls.
        NtSetInformationProcess(OS_HANDLE(Process), ProcessDebugFlags,
                                &NtFlags, sizeof(NtFlags));
    if (NtStatus == STATUS_INVALID_INFO_CLASS)
    {
        return E_NOTIMPL;
    }
    else
    {
        return CONV_NT_STATUS(NtStatus);
    }
}
        
STDMETHODIMP
LiveUserDebugServices::SetDebugObjectOptions(
    THIS_
    IN ULONG64 DebugObject,
    IN ULONG Options
    )
{
    if (DebugObject == 0)
    {
        if (m_DebugObject == NULL)
        {
            if (g_Kernel32Calls.DebugSetProcessKillOnExit == NULL)
            {
                return E_NOTIMPL;
            }

            if (!g_Kernel32Calls.
                DebugSetProcessKillOnExit((Options &
                                           DEBUG_PROCESS_DETACH_ON_EXIT) == 0))
            {
                return WIN32_LAST_STATUS();
            }

            return S_OK;
        }
        
        DebugObject = SERVICE_HANDLE(m_DebugObject);
    }
    
    if (g_NtDllCalls.NtSetInformationDebugObject == NULL)
    {
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    ULONG NtFlags = 0;

    if ((Options & DEBUG_PROCESS_DETACH_ON_EXIT) == 0)
    {
        NtFlags |= DEBUG_KILL_ON_CLOSE;
    }
    NtStatus = g_NtDllCalls.
        NtSetInformationDebugObject(OS_HANDLE(DebugObject), DebugObjectFlags,
                                    &NtFlags, sizeof(NtFlags), NULL);
    return CONV_NT_STATUS(NtStatus);
}

STDMETHODIMP
LiveUserDebugServices::GetProcessDebugObject(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 DebugObject
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    HANDLE ObjHandle;

    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(OS_HANDLE(Process), ProcessDebugObjectHandle,
                                  &ObjHandle, sizeof(ObjHandle), NULL);
    if (!NT_SUCCESS(NtStatus))
    {
        return HRESULT_FROM_NT(NtStatus);
    }

    *DebugObject = SERVICE_HANDLE(ObjHandle);
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::DuplicateHandle(
    THIS_
    IN ULONG64 InProcess,
    IN ULONG64 InHandle,
    IN ULONG64 OutProcess,
    IN ULONG DesiredAccess,
    IN ULONG Inherit,
    IN ULONG Options,
    OUT PULONG64 OutHandle
    )
{
    HANDLE Dup;
    
    if (!::DuplicateHandle(OS_HANDLE(InProcess), OS_HANDLE(InHandle),
                           OS_HANDLE(OutProcess), &Dup,
                           DesiredAccess, Inherit, Options))
    {
        return WIN32_LAST_STATUS();
    }

    *OutHandle = SERVICE_HANDLE(Dup);
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::ReadVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesRead
    )
{
    SIZE_T SizeRead;
    
    if (!::ReadProcessMemory(OS_HANDLE(Process),
                             (LPCVOID)(ULONG_PTR)Offset,
                             Buffer, BufferSize, &SizeRead))
    {
        return WIN32_LAST_STATUS();
    }

    if (BytesRead != NULL)
    {
        *BytesRead = (ULONG)SizeRead;
    }
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::WriteVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BytesWritten
    )
{
    SIZE_T SizeWritten;
    
    if (!::WriteProcessMemory(OS_HANDLE(Process),
                              (LPVOID)(ULONG_PTR)Offset,
                              Buffer, BufferSize, &SizeWritten))
    {
        return WIN32_LAST_STATUS();
    }

    if (BytesWritten != NULL)
    {
        *BytesWritten = (ULONG)SizeWritten;
    }
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::QueryVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BufferUsed
    )
{
    if (BufferSize < sizeof(MEMORY_BASIC_INFORMATION))
    {
        return E_INVALIDARG;
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = sizeof(MEMORY_BASIC_INFORMATION);
    }

    if (!::VirtualQueryEx(OS_HANDLE(Process),
                          (LPCVOID)(ULONG_PTR)Offset,
                          (PMEMORY_BASIC_INFORMATION)Buffer,
                          sizeof(MEMORY_BASIC_INFORMATION)))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::ProtectVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG64 Size,
    IN ULONG NewProtect,
    OUT PULONG OldProtect
    )
{
    BOOL Status = ::VirtualProtectEx(OS_HANDLE(Process),
                                     (PVOID)(ULONG_PTR)Offset, (SIZE_T)Size,
                                     NewProtect, OldProtect);
    return CONV_W32_STATUS(Status);
}

STDMETHODIMP
LiveUserDebugServices::AllocVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG64 Size,
    IN ULONG Type,
    IN ULONG Protect,
    OUT PULONG64 AllocOffset
    )
{
    PVOID Addr = ::VirtualAllocEx(OS_HANDLE(Process), (PVOID)(ULONG_PTR)Offset,
                                  (SIZE_T)Size, Type, Protect);
    if (Addr == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    *AllocOffset = (ULONG64)(LONG64)(ULONG_PTR)Addr;
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::FreeVirtual(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG64 Size,
    IN ULONG Type
    )
{
    BOOL Status = ::VirtualFreeEx(OS_HANDLE(Process), (PVOID)(ULONG_PTR)Offset,
                                  (SIZE_T)Size, Type);
    return CONV_W32_STATUS(Status);
}

STDMETHODIMP
LiveUserDebugServices::ReadHandleData(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Handle,
    IN ULONG DataType,
    OUT OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG DataSize
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        return E_NOTIMPL;
    }

    HANDLE Dup = NULL;
    
    if (DataType != DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT &&
        !::DuplicateHandle(OS_HANDLE(Process), OS_HANDLE(Handle),
                           GetCurrentProcess(), &Dup, 0, FALSE,
                           DUPLICATE_SAME_ACCESS))
    {
        return WIN32_LAST_STATUS();
    }

    ULONG64 NtBuffer[1024 / sizeof(ULONG64)];
    ULONG Used = 0;
    NTSTATUS NtStatus;
    HRESULT Status = S_OK;
    
    switch(DataType)
    {
    case DEBUG_HANDLE_DATA_TYPE_BASIC:
        Used = sizeof(DEBUG_HANDLE_DATA_BASIC);
        if (Buffer == NULL)
        {
            break;
        }
        
        if (BufferSize < Used)
        {
            Status = E_INVALIDARG;
            break;
        }
        
        POBJECT_BASIC_INFORMATION NtBasic;

        NtBasic = (POBJECT_BASIC_INFORMATION)NtBuffer;
        NtStatus = g_NtDllCalls.NtQueryObject(Dup, ObjectBasicInformation,
                                              NtBasic, sizeof(*NtBasic), NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
            break;
        }

        PDEBUG_HANDLE_DATA_BASIC Basic;
        
        Basic = (PDEBUG_HANDLE_DATA_BASIC)Buffer;
        Basic->TypeNameSize = NtBasic->TypeInfoSize / sizeof(WCHAR);
        Basic->ObjectNameSize = NtBasic->NameInfoSize / sizeof(WCHAR);
        Basic->Attributes = NtBasic->Attributes;
        Basic->GrantedAccess = NtBasic->GrantedAccess;
        Basic->HandleCount = NtBasic->HandleCount;
        Basic->PointerCount = NtBasic->PointerCount;
        break;
        
    case DEBUG_HANDLE_DATA_TYPE_TYPE_NAME:
        POBJECT_TYPE_INFORMATION NtType;

        NtType = (POBJECT_TYPE_INFORMATION)NtBuffer;
        NtStatus = g_NtDllCalls.NtQueryObject(Dup, ObjectTypeInformation,
                                              NtType, sizeof(NtBuffer), NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
            break;
        }

        if (NtType->TypeName.Buffer == NULL)
        {
            Used = 1;
            if (Buffer != NULL && BufferSize > 0)
            {
                *(PCHAR)Buffer = 0;
            }
            break;
        }
        
        Used = NtType->TypeName.Length / sizeof(WCHAR) + 1;
        NtType->TypeName.Buffer[Used - 1] = 0;
        
        if (Buffer != NULL &&
            WideCharToMultiByte(CP_ACP, 0, NtType->TypeName.Buffer,
                                -1, (LPSTR)Buffer, BufferSize,
                                NULL, NULL) == 0)
        {
            Status = WIN32_LAST_STATUS();
            break;
        }
        break;
        
    case DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME:
        POBJECT_NAME_INFORMATION NtName;
        
        NtName = (POBJECT_NAME_INFORMATION)NtBuffer;
        NtStatus = g_NtDllCalls.NtQueryObject(Dup, ObjectNameInformation,
                                              NtName, sizeof(NtBuffer), NULL);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
            break;
        }

        if (NtName->Name.Buffer == NULL)
        {
            Used = 1;
            if (Buffer != NULL && BufferSize > 0)
            {
                *(PCHAR)Buffer = 0;
            }
            break;
        }
        
        Used = NtName->Name.Length / sizeof(WCHAR) + 1;
        NtName->Name.Buffer[Used - 1] = 0;
        
        if (Buffer != NULL &&
            WideCharToMultiByte(CP_ACP, 0, NtName->Name.Buffer,
                                -1, (LPSTR)Buffer, BufferSize,
                                NULL, NULL) == 0)
        {
            Status = WIN32_LAST_STATUS();
            break;
        }
        break;

    case DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT:
        NtStatus = g_NtDllCalls.
            NtQueryInformationProcess(OS_HANDLE(Process), ProcessHandleCount,
                                      Buffer, BufferSize, &Used);
        if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
        }
        break;
    }

    if (DataSize != NULL)
    {
        *DataSize = Used;
    }

    if (Dup != NULL)
    {
        ::CloseHandle(Dup);
    }
    return Status;
}

STDMETHODIMP
LiveUserDebugServices::SuspendThreads(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PULONG64 Threads,
    OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
    )
{
    ULONG i;
    HRESULT Status;

    Status = S_OK;
    for (i = 0; i < Count; i++)
    {
        ULONG OldCount = ::SuspendThread(OS_HANDLE(Threads[i]));
        if (OldCount == -1)
        {
            Status = WIN32_LAST_STATUS();
        }
        if (SuspendCounts != NULL)
        {
            SuspendCounts[i] = OldCount + 1;
        }
    }

    return Status;
}

STDMETHODIMP
LiveUserDebugServices::ResumeThreads(
    THIS_
    IN ULONG Count,
    IN /* size_is(Count) */ PULONG64 Threads,
    OUT OPTIONAL /* size_is(Count) */ PULONG SuspendCounts
    )
{
    ULONG i;
    HRESULT Status;

    Status = S_OK;
    for (i = 0; i < Count; i++)
    {
        ULONG OldCount = ::ResumeThread(OS_HANDLE(Threads[i]));
        if (OldCount == -1)
        {
            Status = WIN32_LAST_STATUS();
        }
        if (SuspendCounts != NULL)
        {
            SuspendCounts[i] = OldCount - 1;
        }
    }

    return Status;
}

STDMETHODIMP
LiveUserDebugServices::GetContext(
    THIS_
    IN ULONG64 Thread,
    IN ULONG Flags,
    IN ULONG FlagsOffset,
    OUT PVOID Context,
    IN ULONG ContextSize,
    OUT OPTIONAL PULONG ContextUsed
    )
{
    if (ContextSize < m_ContextSize)
    {
        return E_INVALIDARG;
    }

    if (ContextUsed != NULL)
    {
        *ContextUsed = m_ContextSize;
    }
    
    // Some platforms have alignment requirements for
    // context information, so just get data into a
    // local context structure, which presumably the
    // compiler will properly align, and then copy
    // it into the output buffer.
#ifndef _X86_
    CONTEXT _LocalContext;
    PCONTEXT LocalContext = &_LocalContext;
#else
    PCONTEXT LocalContext = (PCONTEXT)Context;
#endif
    
    // Initialize context flags here rather than making Context
    // IN OUT to avoid sending a full CONTEXT just for a
    // ULONG's worth of flags.
    *(PULONG)((PUCHAR)LocalContext + FlagsOffset) = Flags;
    
    if (!::GetThreadContext(OS_HANDLE(Thread), LocalContext))
    {
        return WIN32_LAST_STATUS();
    }

#ifndef _X86_
    memcpy(Context, LocalContext, m_ContextSize);
#endif
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::SetContext(
    THIS_
    IN ULONG64 Thread,
    IN PVOID Context,
    IN ULONG ContextSize,
    OUT OPTIONAL PULONG ContextUsed
    )
{
    if (ContextSize < m_ContextSize)
    {
        return E_INVALIDARG;
    }
    
    if (ContextUsed != NULL)
    {
        *ContextUsed = m_ContextSize;
    }
    
    // Some platforms have alignment requirements for
    // context information, so just get data into a
    // local context structure, which presumably the
    // compiler will properly align.
#ifndef _X86_
    CONTEXT _LocalContext;
    PCONTEXT LocalContext = &_LocalContext;
    memcpy(LocalContext, Context, m_ContextSize);
#else
    PCONTEXT LocalContext = (PCONTEXT)Context;
#endif
    
    if (!::SetThreadContext(OS_HANDLE(Thread), LocalContext))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetProcessDataOffset(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 Offset
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        // XXX drewb - Equivalent?
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    PROCESS_BASIC_INFORMATION ProcessInformation;
        
    NtStatus = g_NtDllCalls.
        NtQueryInformationProcess(OS_HANDLE(Process),
                                  ProcessBasicInformation,
                                  &ProcessInformation,
                                  sizeof(ProcessInformation),
                                  NULL);
    *Offset = (ULONG64)(ProcessInformation.PebBaseAddress);
    return CONV_NT_STATUS(NtStatus);
}

STDMETHODIMP
LiveUserDebugServices::GetThreadDataOffset(
    THIS_
    IN ULONG64 Thread,
    OUT PULONG64 Offset
    )
{
    if (m_PlatformId != VER_PLATFORM_WIN32_NT)
    {
        // XXX drewb - Equivalent?
        return E_NOTIMPL;
    }
    
    NTSTATUS NtStatus;
    THREAD_BASIC_INFORMATION ThreadInformation;

    NtStatus = g_NtDllCalls.
        NtQueryInformationThread(OS_HANDLE(Thread),
                                 ThreadBasicInformation,
                                 &ThreadInformation,
                                 sizeof(ThreadInformation),
                                 NULL);
    *Offset = (ULONG64)(ThreadInformation.TebBaseAddress);
    return CONV_NT_STATUS(NtStatus);
}

STDMETHODIMP
LiveUserDebugServices::DescribeSelector(
    THIS_
    IN ULONG64 Thread,
    IN ULONG Selector,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BufferUsed
    )
{
#ifdef _X86_
    if (BufferSize < sizeof(LDT_ENTRY))
    {
        return E_INVALIDARG;
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = sizeof(LDT_ENTRY);
    }
#endif

    if (!::GetThreadSelectorEntry(OS_HANDLE(Thread), Selector,
                                  (LPLDT_ENTRY)Buffer))
    {
        return WIN32_LAST_STATUS();
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetCurrentTimeDateN(
    THIS_
    OUT PULONG64 TimeDate
    )
{
    // On NT only: *TimeDate = USER_SHARED_DATA->SystemTime;

    *TimeDate = TimeDateStampToFileTime((ULONG)time(NULL));

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetCurrentSystemUpTimeN(
    THIS_
    OUT PULONG64 UpTime
    )
{
    // On NT only: *UpTime = USER_SHARED_DATA->InterruptTime;

    *UpTime = TimeToFileTime(GetTickCount() / 1000);

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::GetProcessUpTimeN(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 UpTime
    )
{
    if (m_PlatformId == VER_PLATFORM_WIN32_NT)
    {
        NTSTATUS NtStatus;
        KERNEL_USER_TIMES KernelUserTimes;
        
        NtStatus = g_NtDllCalls.
            NtQueryInformationProcess(OS_HANDLE(Process),
                                      ProcessTimes,
                                      &KernelUserTimes,
                                      sizeof(KernelUserTimes),
                                      NULL);
        if (NT_SUCCESS(NtStatus))
        {
            ULONG64 SystemUpTime;
            GetCurrentTimeDateN(&SystemUpTime);

            *UpTime = SystemUpTime - KernelUserTimes.CreateTime.QuadPart;
        }

        return CONV_NT_STATUS(NtStatus);
    }
    else
    {
        return E_NOTIMPL;
    }

}

STDMETHODIMP
LiveUserDebugServices::RequestBreakIn(
    THIS_
    IN ULONG64 Process
    )
{
    if (g_Kernel32Calls.DebugBreakProcess != NULL)
    {
        if (!g_Kernel32Calls.DebugBreakProcess(OS_HANDLE(Process)))
        {
            return WIN32_LAST_STATUS();
        }
    }
    else if (g_NtDllCalls.DbgUiIssueRemoteBreakin != NULL)
    {
        NTSTATUS Status;
        
        Status = g_NtDllCalls.DbgUiIssueRemoteBreakin(OS_HANDLE(Process));
        return CONV_NT_STATUS(Status);
    }
    else
    {
        HANDLE Thread;
        DWORD ThreadId;
        LPTHREAD_START_ROUTINE BreakFn;

#if defined(_WIN64)
        BreakFn = (LPTHREAD_START_ROUTINE)g_NtDllCalls.DbgBreakPoint;
#else
        BreakFn = (LPTHREAD_START_ROUTINE)g_Kernel32Calls.DebugBreak;
#endif
        
        Thread =
            ::CreateRemoteThread(OS_HANDLE(Process), NULL, 0, BreakFn,
                                 NULL, 0, &ThreadId);
        if (Thread != NULL)
        {
            ::CloseHandle(Thread);
        }
        else
        {
            return WIN32_LAST_STATUS();
        }
    }

    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::WaitForEvent(
    THIS_
    IN ULONG Timeout,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG BufferUsed
    )
{
    if (BufferSize < sizeof(DEBUG_EVENT))
    {
        return E_INVALIDARG;
    }

    if (BufferUsed != NULL)
    {
        *BufferUsed = sizeof(DEBUG_EVENT);
    }

    LPDEBUG_EVENT Event = (LPDEBUG_EVENT)Buffer;
    HRESULT Status = E_NOTIMPL;

    if (m_DebugObject == NULL)
    {
#ifndef NT_NATIVE
        if (!::WaitForDebugEvent(Event, Timeout))
        {
            if (GetLastError() == ERROR_SEM_TIMEOUT)
            {
                Status = S_FALSE;
            }
            else
            {
                Status = WIN32_LAST_STATUS();
            }
        }
        else
        {
            Status = S_OK;
        }
#endif
    }
    else if (g_NtDllCalls.NtWaitForDebugEvent != NULL &&
             g_NtDllCalls.DbgUiConvertStateChangeStructure != NULL)
    {
        NTSTATUS NtStatus;
        LARGE_INTEGER NtTimeout;
        DBGUI_WAIT_STATE_CHANGE StateChange;

        Win32ToNtTimeout(Timeout, &NtTimeout);
        NtStatus = g_NtDllCalls.NtWaitForDebugEvent(m_DebugObject, FALSE,
                                                    &NtTimeout, &StateChange);
        if (NtStatus == STATUS_TIMEOUT)
        {
            Status = S_FALSE;
        }
        else if (!NT_SUCCESS(NtStatus))
        {
            Status = HRESULT_FROM_NT(NtStatus);
        }
        else
        {
            NtStatus = g_NtDllCalls.
                DbgUiConvertStateChangeStructure(&StateChange, Event);
            // If the conversion fails we'll lose an event, but
            // there's nothing else that can be done.  Conversion
            // failures will only occur in out-of-resource situations
            // so normal debugging will not be affected.
            Status = CONV_NT_STATUS(NtStatus);
        }
    }

    if (Status != S_OK)
    {
        return Status;
    }
    
    m_EventProcessId = Event->dwProcessId;
    m_EventThreadId = Event->dwThreadId;

#ifdef DBG_WAITFOREVENT
    g_NtDllCalls.DbgPrint("Event %d for %X.%X\n",
                          Event->dwDebugEventCode, Event->dwProcessId,
                          Event->dwThreadId);
#endif
    
    // If this is responding to a remote request then
    // we can't return file handles.
    if (m_Remote)
    {
        switch(Event->dwDebugEventCode)
        {
        case CREATE_PROCESS_DEBUG_EVENT:
            ::CloseHandle(Event->u.CreateProcessInfo.hFile);
            Event->u.CreateProcessInfo.hFile = NULL;
            break;
        case LOAD_DLL_DEBUG_EVENT:
            ::CloseHandle(Event->u.LoadDll.hFile);
            Event->u.LoadDll.hFile = NULL;
            break;
        }
    }
    
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::ContinueEvent(
    THIS_
    IN ULONG ContinueStatus
    )
{
#ifdef DBG_WAITFOREVENT
    g_NtDllCalls.DbgPrint("Continue event for %X.%X\n",
                          m_EventProcessId, m_EventThreadId);
#endif
    
    if (m_EventProcessId == 0)
    {
        return E_UNEXPECTED;
    }

    if (m_DebugObject != NULL && g_NtDllCalls.NtDebugContinue != NULL)
    {
        NTSTATUS NtStatus;
        CLIENT_ID ClientId;

        ClientId.UniqueProcess = UlongToHandle(m_EventProcessId);
        ClientId.UniqueThread = UlongToHandle(m_EventThreadId);
        NtStatus = g_NtDllCalls.NtDebugContinue(m_DebugObject, &ClientId,
                                                ContinueStatus);
        if (!NT_SUCCESS(NtStatus))
        {
            return HRESULT_FROM_NT(NtStatus);
        }
    }
#ifndef NT_NATIVE
    else if (!::ContinueDebugEvent(m_EventProcessId, m_EventThreadId,
                                   ContinueStatus))
    {
        return WIN32_LAST_STATUS();
    }
#else
    else
    {
        return E_UNEXPECTED;
    }
#endif

    m_EventProcessId = 0;
    return S_OK;
}

STDMETHODIMP
LiveUserDebugServices::InsertCodeBreakpoint(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG MachineType,
    OUT PVOID Storage,
    IN ULONG StorageSize
    )
{
    // Generic breakpoint support is used so this method
    // does not do anything.
    return E_UNEXPECTED;
}

STDMETHODIMP
LiveUserDebugServices::RemoveCodeBreakpoint(
    THIS_
    IN ULONG64 Process,
    IN ULONG64 Offset,
    IN ULONG MachineType,
    IN PVOID Storage,
    IN ULONG StorageSize
    )
{
    // Generic breakpoint support is used so this method
    // does not do anything.
    return E_UNEXPECTED;
}

STDMETHODIMP
LiveUserDebugServices::GetFunctionTableListHead(
    THIS_
    IN ULONG64 Process,
    OUT PULONG64 Offset
    )
{
    if (!g_NtDllCalls.RtlGetFunctionTableListHead)
    {
        *Offset = 0;
        return E_NOINTERFACE;
    }
    else
    {
        *Offset = (ULONG64)(ULONG_PTR)
            g_NtDllCalls.RtlGetFunctionTableListHead();
        return S_OK;
    }
}

STDMETHODIMP
LiveUserDebugServices::GetOutOfProcessFunctionTable(
    THIS_
    IN ULONG64 Process,
    IN PSTR Dll,
    IN ULONG64 Table,
    IN OPTIONAL PVOID Buffer,
    IN ULONG BufferSize,
    OUT OPTIONAL PULONG TableSize
    )
{
#if !defined(NT_NATIVE) && defined(OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME)
    HRESULT Status;
    NTSTATUS NtStatus;
    HMODULE DllHandle;
    POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK Callback;
    ULONG Entries;
    PRUNTIME_FUNCTION Functions;

    if ((DllHandle = LoadLibrary(Dll)) == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    Callback = (POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK)GetProcAddress
        (DllHandle, OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME);
    if (!Callback)
    {
        Status = WIN32_LAST_STATUS();
        goto Exit;
    }

    NtStatus = Callback(OS_HANDLE(Process), (PVOID)(ULONG_PTR)Table,
                        &Entries, &Functions);
    if (!NT_SUCCESS(NtStatus))
    {
        Status = HRESULT_FROM_NT(NtStatus);
        goto Exit;
    }
    if (Functions == NULL)
    {
        Status = E_NOINTERFACE;
        goto Exit;
    }

    Status = FillDataBuffer(Functions, Entries * sizeof(RUNTIME_FUNCTION),
                            Buffer, BufferSize, TableSize);

    // RtlProcessHeap turns into a TEB reference so it doesn't
    // need to (and can't) be a dynamic reference.
    g_NtDllCalls.RtlFreeHeap(RtlProcessHeap(), 0, Functions);
    
 Exit:
    FreeLibrary(DllHandle);
    return Status;
#else
    return E_UNEXPECTED;
#endif
}

//----------------------------------------------------------------------------
//
// Generated RPC proxies and stubs.
//
//----------------------------------------------------------------------------

// Generated headers.
#include "dbgsvc_p.hpp"
#include "dbgsvc_s.hpp"

#include "dbgsvc_p.cpp"
#include "dbgsvc_s.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgrpc\trans.cpp ===
//----------------------------------------------------------------------------
//
// DbgRpc transports.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "pch.hpp"

// Crypto hashing requires a crypto provider to be available
// (this may not always be the case on Win9x or NT4) so just go with Base64.
#define HashPassword(Password, Buffer) Base64HashPassword(Password, Buffer)

#ifndef NT_NATIVE

BOOL
CryptoHashPassword(PCSTR Password, PUCHAR Buffer)
{
    BOOL Status = FALSE;
    HCRYPTPROV Prov;
    HCRYPTHASH Hash;
    ULONG HashSize;

    if (!CryptAcquireContext(&Prov, NULL, MS_DEF_PROV, PROV_RSA_FULL,
                             CRYPT_VERIFYCONTEXT))
    {
        goto EH_Fail;
    }
    if (!CryptCreateHash(Prov, CALG_MD5, NULL, 0, &Hash))
    {
        goto EH_Prov;
    }
    if (!CryptHashData(Hash, (PBYTE)Password, strlen(Password), 0))
    {
        goto EH_Hash;
    }
    
    ZeroMemory(Buffer, MAX_PASSWORD_BUFFER);
    HashSize = MAX_PASSWORD_BUFFER;
    if (!CryptGetHashParam(Hash, HP_HASHVAL, Buffer, &HashSize, 0))
    {
        goto EH_Hash;
    }
    
    Status = TRUE;

 EH_Hash:
    CryptDestroyHash(Hash);
 EH_Prov:
    CryptReleaseContext(Prov, 0);
 EH_Fail:
    if (!Status)
    {
        DRPC_ERR(("Unable to hash password, %d\n", GetLastError()));
    }
    return Status;
}

#endif // #ifndef NT_NATIVE

UCHAR g_Base64Table[64] =
{
    'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P',
    'Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f',
    'g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v',
    'w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/'
};

BOOL
Base64HashPassword(PCSTR Password, PUCHAR Buffer)
{
    ULONG Len = strlen(Password);
    if ((Len * 4 + 2) / 3 > MAX_PASSWORD_BUFFER)
    {
        DRPC_ERR(("Unable to hash password\n"));
        return FALSE;
    }
    
    ZeroMemory(Buffer, MAX_PASSWORD_BUFFER);

    ULONG Collect;
    
    while (Len >= 3)
    {
        //
        // Collect three characters and turn them
        // into four output bytes.
        //
        
        Collect = *Password++;
        Collect = (Collect << 8) | *Password++;
        Collect = (Collect << 8) | *Password++;

        *Buffer++ = g_Base64Table[(Collect >> 18) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 12) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 6) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 0) & 0x3f];

        Len -= 3;
    }

    switch(Len)
    {
    case 2:
        Collect = *Password++;
        Collect = (Collect << 8) | *Password++;
        Collect <<= 8;
        *Buffer++ = g_Base64Table[(Collect >> 18) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 12) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 6) & 0x3f];
        *Buffer++ = '=';
        break;
        
    case 1:
        Collect = *Password++;
        Collect <<= 16;
        *Buffer++ = g_Base64Table[(Collect >> 18) & 0x3f];
        *Buffer++ = g_Base64Table[(Collect >> 12) & 0x3f];
        *Buffer++ = '=';
        *Buffer++ = '=';
        break;
    }
    
    return TRUE;
}

//----------------------------------------------------------------------------
//
// DbgRpcTransport.
//
//----------------------------------------------------------------------------

PCSTR g_DbgRpcTransportNames[TRANS_COUNT] =
{
    "tcp", "npipe", "ssl", "spipe", "1394", "com",
};

DbgRpcTransport::~DbgRpcTransport(void)
{
    // Nothing to do.
}

ULONG
DbgRpcTransport::GetNumberParameters(void)
{
    return 2;
}

void
DbgRpcTransport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        if (m_ServerName[0])
        {
            strcpy(Name, "Server");
            strcpy(Value, m_ServerName);
        }
        break;
    case 1:
        if (m_PasswordGiven)
        {
            strcpy(Name, "Password");
            strcpy(Value, "*");
        }
        break;
    }
}

void
DbgRpcTransport::ResetParameters(void)
{
    m_PasswordGiven = FALSE;
    m_ServerName[0] = 0;
}

BOOL
DbgRpcTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "Password"))
    {
        if (Value == NULL)
        {
            DbgRpcError("Remoting password was not specified correctly\n");
            return FALSE;
        }

        if (!HashPassword(Value, m_HashedPassword))
        {
            return FALSE;
        }
        
        m_PasswordGiven = TRUE;
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

void
DbgRpcTransport::CloneData(DbgRpcTransport* Trans)
{
    strcpy(Trans->m_ServerName, m_ServerName);
    Trans->m_PasswordGiven = m_PasswordGiven;
    memcpy(Trans->m_HashedPassword, m_HashedPassword,
           sizeof(m_HashedPassword));
}

//----------------------------------------------------------------------------
//
// DbgRpcTcpTransport.
//
//----------------------------------------------------------------------------

#ifndef NT_NATIVE

DbgRpcTcpTransport::~DbgRpcTcpTransport(void)
{
    if (m_Sock != INVALID_SOCKET)
    {
        shutdown(m_Sock, 2);
        closesocket(m_Sock);
        m_Sock = INVALID_SOCKET;
    }
    if (m_OlRead.hEvent != NULL)
    {
        WSACloseEvent(m_OlRead.hEvent);
        ZeroMemory(&m_OlRead, sizeof(m_OlRead));
    }
    if (m_OlWrite.hEvent != NULL)
    {
        WSACloseEvent(m_OlWrite.hEvent);
        ZeroMemory(&m_OlWrite, sizeof(m_OlWrite));
    }
}

ULONG
DbgRpcTcpTransport::GetNumberParameters(void)
{
    return 1 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpcTcpTransport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        if (m_Addr.sin_port)
        {
            strcpy(Name, "Port");
            sprintf(Value, "%d", ntohs(m_Addr.sin_port));
            if (m_TopPort)
            {
                sprintf(Value + strlen(Value), ":%d", m_TopPort);
            }
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 1, Name, Value);
        break;
    }
}

void
DbgRpcTcpTransport::ResetParameters(void)
{
    ZeroMemory(&m_Addr, sizeof(m_Addr));
    m_Addr.sin_family = AF_INET;
    m_Addr.sin_addr.s_addr = INADDR_ANY;
    m_TopPort = 0;

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpcTcpTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "server"))
    {
        if (Value == NULL)
        {
            DbgRpcError("TCP parameters: "
                        "the server name was not specified correctly\n");
            return FALSE;
        }

        // Skip leading \\ if they were given.
        if (Value[0] == '\\' && Value[1] == '\\')
        {
            Value += 2;
        }
        
        m_Addr.sin_addr.s_addr = inet_addr(Value);
        if (m_Addr.sin_addr.s_addr == INADDR_NONE)
        {
            struct hostent *Host = gethostbyname(Value);
            if (Host == NULL)
            {
                DbgRpcError("TCP parameters: "
                            "the specified server (%s) does not exist\n",
                            Value);
                return FALSE;
            }

            m_Addr.sin_family = Host->h_addrtype;
            memcpy(&m_Addr.sin_addr, Host->h_addr, Host->h_length);
        }

        strcpy(m_ServerName, Value);
    }
    else if (!_stricmp(Name, "port"))
    {
        if (Value == NULL)
        {
            DbgRpcError("TCP parameters: "
                        "the port number was not specified correctly\n");
            return FALSE;
        }

        ULONG Port;

        // Allow a range of ports to be specified if so desired.
        switch(sscanf(Value, "%i:%i", &Port, &m_TopPort))
        {
        case 0:
            Port = 0;
            // Fall through.
        case 1:
            m_TopPort = 0;
            break;
        }

        if (Port > 0xffff || m_TopPort > 0xffff)
        {
            DbgRpcError("TCP parameters: port numbers are "
                        "limited to 16 bits\n");
            return FALSE;
        }
        
        m_Addr.sin_port = htons((USHORT)Port);
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("TCP parameters: %s is not a valid parameter\n", Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcTcpTransport::Clone(void)
{
    DbgRpcTcpTransport* Trans = new DbgRpcTcpTransport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        memcpy(&Trans->m_Addr, &m_Addr, sizeof(m_Addr));
        Trans->m_TopPort = m_TopPort;
    }
    return Trans;
}

HRESULT
DbgRpcTcpTransport::CreateServer(void)
{
    HRESULT Status;

    //
    // We must create our sockets overlapped so that
    // we can control waiting for I/O completion.
    // If we leave the waiting to Winsock by using
    // synchronous sockets it uses an alertable wait
    // which can cause our event notification APCs to
    // be received in the middle of reading packets.
    //
    
    m_Sock = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0,
                       WSA_FLAG_OVERLAPPED);
    if (m_Sock == INVALID_SOCKET)
    {
        Status = WIN32_STATUS(WSAGetLastError());
        goto EH_Fail;
    }

    for (;;)
    {
        if (bind(m_Sock, (struct sockaddr *)&m_Addr,
                 sizeof(m_Addr)) != SOCKET_ERROR)
        {
            break;
        }

        ULONG Port = ntohs(m_Addr.sin_port);
        
        Status = WIN32_STATUS(WSAGetLastError());
        if (Status == HRESULT_FROM_WIN32(WSAEADDRINUSE) &&
            m_TopPort > Port)
        {
            // The user has given a range of ports and
            // we haven't checked them all yet, so go
            // around again.
            m_Addr.sin_port = htons((USHORT)(Port + 1));
        }
        else
        {
            goto EH_Sock;
        }
    }

    //
    // Retrieve the port actually used in case port
    // zero was used to let TCP pick a port.
    //
    
    struct sockaddr_in Name;
    int Len;

    Len = sizeof(Name);
    if (getsockname(m_Sock, (struct sockaddr *)&Name, &Len) != 0)
    {
        Status = WIN32_STATUS(WSAGetLastError());
        goto EH_Sock;
    }

    // Copy just the port as we do not want
    // to update the rest of the address.
    m_Addr.sin_port = Name.sin_port;
        
    // Turn off linger-on-close.
    int On;
    On = TRUE;
    setsockopt(m_Sock, SOL_SOCKET, SO_DONTLINGER,
               (char *)&On, sizeof(On));

    if (listen(m_Sock, SOMAXCONN) == SOCKET_ERROR)
    {
        Status = WIN32_STATUS(WSAGetLastError());
        goto EH_Sock;
    }

    return S_OK;

 EH_Sock:
    closesocket(m_Sock);
    m_Sock = INVALID_SOCKET;
 EH_Fail:
    return Status;
}

HRESULT
DbgRpcTcpTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity)
{
    DbgRpcTcpTransport* Trans = new DbgRpcTcpTransport;
    if (Trans == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);

    DRPC(("%X: Waiting to accept connection on socket %p\n",
          GetCurrentThreadId(), m_Sock));
    
    int AddrLen = sizeof(Trans->m_Addr);
    Trans->m_Sock = accept(m_Sock, (struct sockaddr *)&Trans->m_Addr,
                           &AddrLen);
    if (Trans->m_Sock == INVALID_SOCKET)
    {
        DRPC(("%X: Accept failed, %X\n",
              GetCurrentThreadId(), WSAGetLastError()));
        
        delete Trans;
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    HRESULT Status = Trans->InitOl();
    if (Status != S_OK)
    {
        DRPC(("%X: InitOl failed, %X\n",
              GetCurrentThreadId(), Status));
        
        delete Trans;
        return Status;
    }
    
    int On = TRUE;
    setsockopt(Trans->m_Sock, IPPROTO_TCP, TCP_NODELAY,
               (PSTR)&On, sizeof(On));

    DRPC(("%X: Accept connection on socket %p\n",
          GetCurrentThreadId(), Trans->m_Sock));

    *ClientTrans = Trans;
    if (Trans->m_Addr.sin_family == AF_INET)
    {
        strcpy(Identity, "tcp ");

        struct hostent* Host =
#if 0
            // This lookup is really slow and doesn't seem to work
            // very often so just don't bother.
            gethostbyaddr((PCSTR)&Trans->m_Addr, AddrLen, AF_INET);
#else
            NULL;
#endif
        if (Host != NULL)
        {
            strcat(Identity, Host->h_name);
            strcat(Identity, " ");
        }

        sprintf(Identity + strlen(Identity), "%s, port %d",
                inet_ntoa(Trans->m_Addr.sin_addr), ntohs(m_Addr.sin_port));
    }
    else
    {
        sprintf(Identity, "tcp family %d, bytes %d",
                Trans->m_Addr.sin_family, AddrLen);
    }
    
    return S_OK;
}

HRESULT
DbgRpcTcpTransport::ConnectServer(void)
{
    //
    // We must create our sockets overlapped so that
    // we can control waiting for I/O completion.
    // If we leave the waiting to Winsock by using
    // synchronous sockets it uses an alertable wait
    // which can cause our event notification APCs to
    // be received in the middle of reading packets.
    //
    
    m_Sock = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0,
                       WSA_FLAG_OVERLAPPED);
    if (m_Sock != INVALID_SOCKET)
    {
        if (connect(m_Sock, (struct sockaddr *)&m_Addr,
                    sizeof(m_Addr)) == SOCKET_ERROR ||
            InitOl() != S_OK)
        {
            closesocket(m_Sock);
            m_Sock = INVALID_SOCKET;
        }
        else
        {
            int On = TRUE;
            setsockopt(m_Sock, IPPROTO_TCP, TCP_NODELAY,
                       (PSTR)&On, sizeof(On));

            DRPC(("%X: Connect on socket %p\n",
                  GetCurrentThreadId(), m_Sock));
        }
    }

    return m_Sock != INVALID_SOCKET ? S_OK : RPC_E_SERVER_DIED;
}

ULONG
DbgRpcTcpTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done;

    Done = 0;
    while (Len > 0)
    {
        if (!WSAResetEvent(m_OlRead.hEvent))
        {
            break;
        }

        WSABUF SockBuf;
        ULONG SockDone;
        ULONG SockFlags;

        SockBuf.buf = (PSTR)Buffer;
        SockBuf.len = Len;
        SockFlags = 0;
        
        if (WSARecv(m_Sock, &SockBuf, 1, &SockDone, &SockFlags,
                    &m_OlRead, NULL) == SOCKET_ERROR)
        {
            if (WSAGetLastError() == WSA_IO_PENDING)
            {
                if (!WSAGetOverlappedResult(m_Sock, &m_OlRead, &SockDone,
                                            TRUE, &SockFlags))
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }
        else if (SockDone == 0)
        {
            // Socket connection was broken.
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + SockDone);
        Len -= SockDone;
        Done += SockDone;
    }

    return Done;
}

ULONG
DbgRpcTcpTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done;

    Done = 0;
    while (Len > 0)
    {
        if (!WSAResetEvent(m_OlWrite.hEvent))
        {
            break;
        }

        WSABUF SockBuf;
        ULONG SockDone;
        ULONG SockFlags;

        SockBuf.buf = (PSTR)Buffer;
        SockBuf.len = Len;
        SockFlags = 0;
        
        if (WSASend(m_Sock, &SockBuf, 1, &SockDone, SockFlags,
                    &m_OlWrite, NULL) == SOCKET_ERROR)
        {
            if (WSAGetLastError() == WSA_IO_PENDING)
            {
                if (!WSAGetOverlappedResult(m_Sock, &m_OlWrite, &SockDone,
                                            TRUE, &SockFlags))
                {
                    break;
                }
            }
            else
            {
                break;
            }
        }

        Buffer = (PVOID)((PUCHAR)Buffer + SockDone);
        Len -= SockDone;
        Done += SockDone;
    }

    return Done;
}

HRESULT
DbgRpcTcpTransport::InitOl(void)
{
    m_OlRead.hEvent = WSACreateEvent();
    if (m_OlRead.hEvent == NULL)
    {
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }
    m_OlWrite.hEvent = WSACreateEvent();
    if (m_OlWrite.hEvent == NULL)
    {
        WSACloseEvent(m_OlRead.hEvent);
        m_OlRead.hEvent = NULL;
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }
    return S_OK;
}

#endif // #ifndef NT_NATIVE

//----------------------------------------------------------------------------
//
// DbgRpcNamedPipeTransport.
//
//----------------------------------------------------------------------------

DbgRpcNamedPipeTransport::~DbgRpcNamedPipeTransport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
    }
    if (m_ReadOlap.hEvent != NULL)
    {
        CloseHandle(m_ReadOlap.hEvent);
    }
    if (m_WriteOlap.hEvent != NULL)
    {
        CloseHandle(m_WriteOlap.hEvent);
    }
}

ULONG
DbgRpcNamedPipeTransport::GetNumberParameters(void)
{
    return 1 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpcNamedPipeTransport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        if (m_Pipe[0])
        {
            strcpy(Name, "Pipe");
            strcpy(Value, m_Pipe);
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 1, Name, Value);
        break;
    }
}

void
DbgRpcNamedPipeTransport::ResetParameters(void)
{
    m_Pipe[0] = 0;
    m_Handle = NULL;

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpcNamedPipeTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "server"))
    {
        if (Value == NULL)
        {
            DbgRpcError("NPIPE parameters: "
                        "the server name was not specified correctly\n");
            return FALSE;
        }

        // Skip leading \\ if they were given.
        if (Value[0] == '\\' && Value[1] == '\\')
        {
            Value += 2;
        }
        
        strcpy(m_ServerName, Value);
    }
    else if (!_stricmp(Name, "pipe"))
    {
        if (Value == NULL)
        {
            DbgRpcError("NPIPE parameters: "
                        "the pipe name was not specified correctly\n");
            return FALSE;
        }

        // Use the value as a printf format string so that
        // users can create unique names using the process and
        // thread IDs in their own format.
        _snprintf(m_Pipe, sizeof(m_Pipe), Value,
                  GetCurrentProcessId(), GetCurrentThreadId());
        m_Pipe[sizeof(m_Pipe) - 1] = 0;
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("NPIPE parameters: %s is not a valid parameter\n",
                        Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcNamedPipeTransport::Clone(void)
{
    DbgRpcNamedPipeTransport* Trans = new DbgRpcNamedPipeTransport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        strcpy(Trans->m_Pipe, m_Pipe);
    }
    return Trans;
}

HRESULT
DbgRpcNamedPipeTransport::CreateServer(void)
{
    HANDLE Pipe;
    char PipeName[MAX_PARAM_VALUE + 16];
#ifndef NT_NATIVE
    strcpy(PipeName, "\\\\.\\pipe\\");
#else
    strcpy(PipeName, "\\Device\\NamedPipe\\");
#endif
    strcat(PipeName, m_Pipe);

    // Check and see if this pipe already exists.
    // This might mess up whoever created the pipe if
    // there is one but it's better than creating a
    // duplicate pipe and having clients get messed up.
#ifndef NT_NATIVE
    Pipe = CreateFile(PipeName, GENERIC_READ | GENERIC_WRITE,
                      0, NULL, OPEN_EXISTING, 0, NULL);
#else
    Pipe = NtNativeCreateFileA(PipeName, GENERIC_READ | GENERIC_WRITE,
                               0, NULL, OPEN_EXISTING, 0, NULL, FALSE);
#endif
    if (Pipe != INVALID_HANDLE_VALUE)
    {
        // Pipe is already in use.
        DRPC_ERR(("%X: Pipe %s is already in use\n",
                  GetCurrentThreadId(), PipeName));
        CloseHandle(Pipe);
        return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
    }
        
    return S_OK;
}

HRESULT
DbgRpcNamedPipeTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                           PSTR Identity)
{
    DbgRpcNamedPipeTransport* Trans = new DbgRpcNamedPipeTransport;
    if (Trans == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);

    char PipeName[MAX_PARAM_VALUE + 16];
#ifndef NT_NATIVE
    strcpy(PipeName, "\\\\.\\pipe\\");
#else
    strcpy(PipeName, "\\Device\\NamedPipe\\");
#endif
    strcat(PipeName, m_Pipe);

#ifndef NT_NATIVE
    Trans->m_Handle =
        CreateNamedPipe(PipeName,
                        PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                        PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE,
                        PIPE_UNLIMITED_INSTANCES, 4096, 4096, INFINITE,
                        &g_AllAccessSecAttr);
#else
    Trans->m_Handle =
        NtNativeCreateNamedPipeA(PipeName,
                                 PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                                 PIPE_WAIT | PIPE_READMODE_BYTE |
                                 PIPE_TYPE_BYTE,
                                 PIPE_UNLIMITED_INSTANCES, 4096, 4096,
                                 INFINITE,
                                 &g_AllAccessSecAttr, FALSE);
#endif
    if (Trans->m_Handle == INVALID_HANDLE_VALUE)
    {
        Trans->m_Handle = NULL;
        delete Trans;
        return WIN32_LAST_STATUS();
    }

    HRESULT Status;

    if ((Status = CreateOverlappedPair(&Trans->m_ReadOlap,
                                       &Trans->m_WriteOlap)) != S_OK)
    {
        delete Trans;
        return Status;
    }
    
    DRPC(("%X: Waiting to accept connection on pipe %s\n",
          GetCurrentThreadId(), m_Pipe));

    if (!ConnectNamedPipe(Trans->m_Handle, &Trans->m_ReadOlap))
    {
        if (GetLastError() == ERROR_PIPE_CONNECTED)
        {
            goto Connected;
        }
        else if (GetLastError() == ERROR_IO_PENDING)
        {
            DWORD Unused;
            
            if (GetOverlappedResult(Trans->m_Handle, &Trans->m_ReadOlap,
                                    &Unused, TRUE))
            {
                goto Connected;
            }
        }
        
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        
        delete Trans;
        return WIN32_LAST_STATUS();
    }

 Connected:
    DRPC(("%X: Accept connection on pipe %s\n",
          GetCurrentThreadId(), m_Pipe));

    *ClientTrans = Trans;
    _snprintf(Identity, DBGRPC_MAX_IDENTITY, "npipe %s", m_Pipe);
    Identity[DBGRPC_MAX_IDENTITY - 1] = 0;
    
    return S_OK;
}

HRESULT
DbgRpcNamedPipeTransport::ConnectServer(void)
{
    HRESULT Status;
    char PipeName[2 * MAX_PARAM_VALUE + 16];
    sprintf(PipeName, "\\\\%s\\pipe\\%s", m_ServerName, m_Pipe);

    if ((Status = CreateOverlappedPair(&m_ReadOlap, &m_WriteOlap)) != S_OK)
    {
        return Status;
    }
    
    for (;;)
    {
        m_Handle = CreateFile(PipeName, GENERIC_READ | GENERIC_WRITE,
                              0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED,
                              NULL);
        if (m_Handle != INVALID_HANDLE_VALUE)
        {
            break;
        }
        m_Handle = NULL;

        if (GetLastError() != ERROR_PIPE_BUSY)
        {
            return WIN32_LAST_STATUS();
        }

        if (!WaitNamedPipe(PipeName, NMPWAIT_WAIT_FOREVER))
        {
            return WIN32_LAST_STATUS();
        }
    }

    DRPC(("%X: Connect on pipe %s\n",
          GetCurrentThreadId(), m_Pipe));
    
    return S_OK;
}

ULONG
DbgRpcNamedPipeTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!ReadFile(m_Handle, Buffer, Len, &Ret, &m_ReadOlap))
        {
            if (GetLastError() != ERROR_IO_PENDING ||
                !GetOverlappedResult(m_Handle, &m_ReadOlap, &Ret, TRUE))
            {
                break;
            }
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

ULONG
DbgRpcNamedPipeTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!WriteFile(m_Handle, Buffer, Len, &Ret, &m_WriteOlap))
        {
            if (GetLastError() != ERROR_IO_PENDING ||
                !GetOverlappedResult(m_Handle, &m_WriteOlap, &Ret, TRUE))
            {
                break;
            }
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

//----------------------------------------------------------------------------
//
// DbgRpc1394Transport.
//
//----------------------------------------------------------------------------

DbgRpc1394Transport::~DbgRpc1394Transport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
    }
}

ULONG
DbgRpc1394Transport::GetNumberParameters(void)
{
    return 1 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpc1394Transport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        if (m_AcceptChannel != 0)
        {
            strcpy(Name, "Channel");
            sprintf(Value, "%d", m_AcceptChannel);
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 1, Name, Value);
        break;
    }
}

void
DbgRpc1394Transport::ResetParameters(void)
{
    m_AcceptChannel = 0;
    m_StreamChannel = 0;
    m_Handle = NULL;

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpc1394Transport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "Channel"))
    {
        if (Value == NULL)
        {
            DbgRpcError("1394 parameters: "
                        "the channel was not specified correctly\n");
            return FALSE;
        }

        m_AcceptChannel = atol(Value);
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("1394 parameters: %s is not a valid parameter\n",
                        Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpc1394Transport::Clone(void)
{
    DbgRpc1394Transport* Trans = new DbgRpc1394Transport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        Trans->m_AcceptChannel = m_AcceptChannel;
    }
    return Trans;
}

HRESULT
DbgRpc1394Transport::CreateServer(void)
{
    char Name[64];
    m_StreamChannel = m_AcceptChannel;
    return Create1394Channel(m_AcceptChannel, Name, &m_Handle);
}

#define DBGRPC_1394_CONNECT '4931'

struct DbgRpc1394Connect
{
    ULONG Signature;
    ULONG Flags;
    ULONG StreamChannel;
    ULONG Reserved[5];
};
    
HRESULT
DbgRpc1394Transport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                      PSTR Identity)
{
    DbgRpc1394Transport* Trans = new DbgRpc1394Transport;
    if (Trans == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);
    
    DRPC(("%X: Waiting to accept connection on channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel));

    DbgRpc1394Connect Conn, CheckConn;
    ULONG Done;

    ZeroMemory(&CheckConn, sizeof(CheckConn));
    CheckConn.Signature = DBGRPC_1394_CONNECT;
    
    if (!ReadFile(m_Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        DRPC(("%X: Accept information invalid\n",
              GetCurrentThreadId()));
        delete Trans;
        return E_FAIL;
    }

    char StreamName[64];
    HRESULT Status;

    Conn.StreamChannel = m_StreamChannel + 1;
    if ((Status = Open1394Channel(Conn.StreamChannel, StreamName,
                                  &Trans->m_Handle)) != S_OK)
    {
        DRPC(("%X: Accept failed, 0x%X\n",
              GetCurrentThreadId(), Status));
        delete Trans;
        return Status;
    }

    if (!WriteFile(m_Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }
    
    Trans->m_AcceptChannel = m_AcceptChannel;
    Trans->m_StreamChannel = Conn.StreamChannel;
    m_StreamChannel++;
    
    DRPC(("%X: Accept connection on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, Conn.StreamChannel));

    *ClientTrans = Trans;
    _snprintf(Identity, DBGRPC_MAX_IDENTITY, "1394 %d", m_AcceptChannel);
    Identity[DBGRPC_MAX_IDENTITY - 1] = 0;
    
    return S_OK;
}

HRESULT
DbgRpc1394Transport::ConnectServer(void)
{
    char Name[64];
    HRESULT Status;
    HANDLE Handle;
    ULONG Done;

    if ((Status = Create1394Channel(m_AcceptChannel, Name, &Handle)) != S_OK)
    {
        return Status;
    }

    DbgRpc1394Connect Conn, CheckConn;

    ZeroMemory(&Conn, sizeof(Conn));
    Conn.Signature = DBGRPC_1394_CONNECT;
    CheckConn = Conn;

    if (!WriteFile(Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        CloseHandle(Handle);
        return WIN32_LAST_STATUS();
    }
    if (!ReadFile(Handle, &Conn, sizeof(Conn), &Done, NULL) ||
        Done != sizeof(Conn))
    {
        CloseHandle(Handle);
        return WIN32_LAST_STATUS();
    }
    
    CloseHandle(Handle);

    CheckConn.StreamChannel = Conn.StreamChannel;
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        return E_FAIL;
    }

    if ((Status = Open1394Channel(Conn.StreamChannel, Name,
                                  &m_Handle)) != S_OK)
    {
        return Status;
    }

    m_StreamChannel = Conn.StreamChannel;
    
    DRPC(("%X: Connect on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, m_StreamChannel));
    
    return S_OK;
}

ULONG
DbgRpc1394Transport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!ReadFile(m_Handle, Buffer, Len, &Ret, NULL))
        {
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

ULONG
DbgRpc1394Transport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;
    ULONG Ret;

    while (Len > 0)
    {
        if (!WriteFile(m_Handle, Buffer, Len, &Ret, NULL))
        {
            break;
        }

        Buffer = (PVOID)((PUCHAR)Buffer + Ret);
        Len -= Ret;
        Done += Ret;
    }

    return Done;
}

//----------------------------------------------------------------------------
//
// DbgRpcComTransport.
//
//----------------------------------------------------------------------------

DbgRpcComTransport::~DbgRpcComTransport(void)
{
    if (m_Handle != NULL)
    {
        CloseHandle(m_Handle);
    }
    if (m_ReadOlap.hEvent != NULL)
    {
        CloseHandle(m_ReadOlap.hEvent);
    }
    if (m_WriteOlap.hEvent != NULL)
    {
        CloseHandle(m_WriteOlap.hEvent);
    }
}

ULONG
DbgRpcComTransport::GetNumberParameters(void)
{
    return 3 + DbgRpcTransport::GetNumberParameters();
}

void
DbgRpcComTransport::GetParameter(ULONG Index, PSTR Name, PSTR Value)
{
    switch(Index)
    {
    case 0:
        if (m_PortName[0])
        {
            strcpy(Name, "Port");
            strcpy(Value, m_PortName);
        }
        break;
    case 1:
        if (m_BaudRate)
        {
            strcpy(Name, "Baud");
            sprintf(Value, "%d", m_BaudRate);
        }
        break;
    case 2:
        if (m_AcceptChannel)
        {
            strcpy(Name, "Channel");
            sprintf(Value, "%d", m_AcceptChannel);
        }
        break;
    default:
        DbgRpcTransport::GetParameter(Index - 1, Name, Value);
        break;
    }
}

void
DbgRpcComTransport::ResetParameters(void)
{
    m_PortName[0] = 0;
    m_BaudRate = 0;
    m_AcceptChannel = 0;
    m_StreamChannel = 0;
    m_Handle = NULL;

    DbgRpcTransport::ResetParameters();
}

BOOL
DbgRpcComTransport::SetParameter(PCSTR Name, PCSTR Value)
{
    if (!_stricmp(Name, "Port"))
    {
        if (Value == NULL)
        {
            DbgRpcError("COM parameters: "
                        "the port was not specified correctly\n");
            return FALSE;
        }

        SetComPortName(Value, m_PortName);
    }
    else if (!_stricmp(Name, "Baud"))
    {
        if (Value == NULL)
        {
            DbgRpcError("COM parameters: "
                        "the baud rate was not specified correctly\n");
            return FALSE;
        }

        m_BaudRate = atol(Value);
    }
    else if (!_stricmp(Name, "Channel"))
    {
        ULONG ValChan;

        if (Value == NULL ||
            (ValChan = atol(Value)) > 0xfe)
        {
            DbgRpcError("COM parameters: "
                        "the channel was not specified correctly\n");
            return FALSE;
        }

        m_AcceptChannel = (UCHAR)ValChan;
    }
    else
    {
        if (!DbgRpcTransport::SetParameter(Name, Value))
        {
            DbgRpcError("COM parameters: %s is not a valid parameter\n", Name);
            return FALSE;
        }
    }

    return TRUE;
}

DbgRpcTransport*
DbgRpcComTransport::Clone(void)
{
    DbgRpcComTransport* Trans = new DbgRpcComTransport;
    if (Trans != NULL)
    {
        DbgRpcTransport::CloneData(Trans);
        strcpy(Trans->m_PortName, m_PortName);
        Trans->m_BaudRate = m_BaudRate;
        Trans->m_AcceptChannel = m_AcceptChannel;
        // The serial port can only be opened once so
        // just dup the handle for the new transport.
        if (!DuplicateHandle(GetCurrentProcess(), m_Handle,
                             GetCurrentProcess(), &Trans->m_Handle,
                             0, FALSE, DUPLICATE_SAME_ACCESS))
        {
            delete Trans;
            Trans = NULL;
        }
    }
    return Trans;
}

HRESULT
DbgRpcComTransport::CreateServer(void)
{
    HRESULT Status;

    if ((Status = InitializeChannels()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateOverlappedPair(&m_ReadOlap, &m_WriteOlap)) != S_OK)
    {
        return Status;
    }
        
    m_StreamChannel = m_AcceptChannel;
    return OpenComPort(m_PortName, m_BaudRate, 0, &m_Handle, &m_BaudRate);
}

#define DBGRPC_COM_CONNECT 'mCrD'

struct DbgRpcComConnect
{
    ULONG Signature;
    ULONG Flags;
    ULONG StreamChannel;
    ULONG Reserved[5];
};
    
HRESULT
DbgRpcComTransport::AcceptConnection(DbgRpcTransport** ClientTrans,
                                     PSTR Identity)
{
    // Check for channel number overflow.
    if (m_StreamChannel == 0xff)
    {
        return E_OUTOFMEMORY;
    }
    
    DbgRpcComTransport* Trans = new DbgRpcComTransport;
    if (Trans == NULL)
    {
        return E_OUTOFMEMORY;
    }

    DbgRpcTransport::CloneData(Trans);
    
    DRPC(("%X: Waiting to accept connection on port %s baud %d channel %d\n",
          GetCurrentThreadId(), m_PortName, m_BaudRate, m_AcceptChannel));

    DbgRpcComConnect Conn, CheckConn;

    ZeroMemory(&CheckConn, sizeof(CheckConn));
    CheckConn.Signature = DBGRPC_COM_CONNECT;
    
    if (ChanRead(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        DRPC(("%X: Accept information invalid\n",
              GetCurrentThreadId()));
        delete Trans;
        return E_FAIL;
    }

    Conn.StreamChannel = m_StreamChannel + 1;
    if (ChanWrite(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }

    // Duplicate the handle so that every transport instance
    // has its own to close.
    if (!DuplicateHandle(GetCurrentProcess(), m_Handle,
                         GetCurrentProcess(), &Trans->m_Handle,
                         0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        DRPC(("%X: Accept failed, %d\n",
              GetCurrentThreadId(), GetLastError()));
        delete Trans;
        return WIN32_LAST_STATUS();
    }

    HRESULT Status;
    
    if ((Status = CreateOverlappedPair(&Trans->m_ReadOlap,
                                       &Trans->m_WriteOlap)) != S_OK)
    {
        DRPC(("%X: Accept failed, 0x%X\n",
              GetCurrentThreadId(), Status));
        delete Trans;
        return Status;
    }

    strcpy(Trans->m_PortName, m_PortName);
    Trans->m_BaudRate = m_BaudRate;
    Trans->m_AcceptChannel = m_AcceptChannel;
    Trans->m_StreamChannel = (UCHAR)Conn.StreamChannel;
    m_StreamChannel++;
    
    DRPC(("%X: Accept connection on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, Conn.StreamChannel));

    *ClientTrans = Trans;
    _snprintf(Identity, DBGRPC_MAX_IDENTITY, "COM %s@%d chan %d",
              m_PortName, m_BaudRate, m_AcceptChannel);
    Identity[DBGRPC_MAX_IDENTITY - 1] = 0;
    
    return S_OK;
}

HRESULT
DbgRpcComTransport::ConnectServer(void)
{
    HRESULT Status;

    if ((Status = InitializeChannels()) != S_OK)
    {
        return Status;
    }
    if ((Status = CreateOverlappedPair(&m_ReadOlap, &m_WriteOlap)) != S_OK)
    {
        return Status;
    }

    // If this is a clone it'll already have a handle.
    // Otherwise this is the first connecting transport
    // so it needs to really open the COM port.
    if (m_Handle == NULL)
    {
        if ((Status = OpenComPort(m_PortName, m_BaudRate, 0,
                                  &m_Handle, &m_BaudRate)) != S_OK)
        {
            return Status;
        }
    }

    DbgRpcComConnect Conn, CheckConn;

    ZeroMemory(&Conn, sizeof(Conn));
    Conn.Signature = DBGRPC_COM_CONNECT;
    CheckConn = Conn;

    if (ChanWrite(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
        return WIN32_LAST_STATUS();
    }
    if (ChanRead(m_AcceptChannel, &Conn, sizeof(Conn)) != sizeof(Conn))
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
        return WIN32_LAST_STATUS();
    }
    
    CheckConn.StreamChannel = Conn.StreamChannel;
    if (memcmp(&Conn, &CheckConn, sizeof(Conn)) != 0)
    {
        CloseHandle(m_Handle);
        m_Handle = NULL;
        return E_FAIL;
    }

    m_StreamChannel = (UCHAR)Conn.StreamChannel;
    
    DRPC(("%X: Connect on channel %d, route to channel %d\n",
          GetCurrentThreadId(), m_AcceptChannel, m_StreamChannel));
    
    return S_OK;
}

#if 0
#define DCOM(Args) g_NtDllCalls.DbgPrint Args
#else
#define DCOM(Args)
#endif

#define DBGRPC_COM_FAILURE 0xffff

#define DBGRPC_COM_HEAD_SIG 0xdc
#define DBGRPC_COM_TAIL_SIG 0xcd

// In order to avoid overflowing the serial port when
// used at boot time, restrict the maximum size of
// a single chunk of data written.  This must be
// less than 0xffff.
#ifdef NT_NATIVE
#define DBGRPC_COM_MAX_CHUNK (16 - sizeof(DbgRpcComStream))
#else
#define DBGRPC_COM_MAX_CHUNK 0xfffe
#endif

struct DbgRpcComStream
{
    UCHAR Signature;
    UCHAR Channel;
    USHORT Len;
};

struct DbgRpcComQueue
{
    DbgRpcComQueue* Next;
    PUCHAR Data;
    UCHAR Channel;
    USHORT Len;
};

BOOL DbgRpcComTransport::s_ChanInitialized;
CRITICAL_SECTION DbgRpcComTransport::s_QueueLock;
HANDLE DbgRpcComTransport::s_QueueChangedEvent;
LONG DbgRpcComTransport::s_PortReadOwned;
CRITICAL_SECTION DbgRpcComTransport::s_PortWriteLock;
CRITICAL_SECTION DbgRpcComTransport::s_WriteAckLock;
HANDLE DbgRpcComTransport::s_WriteAckEvent;
DbgRpcComQueue* DbgRpcComTransport::s_QueueHead;
DbgRpcComQueue* DbgRpcComTransport::s_QueueTail;

ULONG
DbgRpcComTransport::Read(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;

    while (Len > 0)
    {
        USHORT Chunk = (USHORT)min(Len, DBGRPC_COM_MAX_CHUNK);
        USHORT ChunkDone = ChanRead(m_StreamChannel, Buffer, Chunk);

        Done += ChunkDone;
        Buffer = (PUCHAR)Buffer + ChunkDone;
        Len -= ChunkDone;
        
        if (ChunkDone < Chunk)
        {
            break;
        }
    }

    return Done;
}

ULONG
DbgRpcComTransport::Write(ULONG Seq, PVOID Buffer, ULONG Len)
{
    ULONG Done = 0;

    while (Len > 0)
    {
        USHORT Chunk = (USHORT)min(Len, DBGRPC_COM_MAX_CHUNK);
        USHORT ChunkDone = ChanWrite(m_StreamChannel, Buffer, Chunk);

        Done += ChunkDone;
        Buffer = (PUCHAR)Buffer + ChunkDone;
        Len -= ChunkDone;
        
        if (ChunkDone < Chunk)
        {
            break;
        }
    }

    return Done;
}

USHORT
DbgRpcComTransport::ScanQueue(UCHAR Chan, PVOID Buffer, USHORT Len)
{
    USHORT Done = 0;
    
    EnterCriticalSection(&s_QueueLock);
        
    DbgRpcComQueue* Ent;
    DbgRpcComQueue* Next;
    DbgRpcComQueue* Prev;

    Prev = NULL;
    for (Ent = s_QueueHead; Ent != NULL && Len > 0; Ent = Next)
    {
        Next = Ent->Next;
        
        DCOM(("%03X:    Queue entry %p->%p %d,%d\n",
              GetCurrentThreadId(),
              Ent, Next, Ent->Channel, Ent->Len));
        
        if (Ent->Channel == Chan)
        {
            // Found some input for this channel.
            if (Len < Ent->Len)
            {
                DCOM(("%03X:    Eat %d, leave %d\n",
                      GetCurrentThreadId(), Len, Ent->Len - Len));
                
                memcpy(Buffer, Ent->Data, Len);
                Ent->Data += Len;
                Ent->Len -= Len;
                Done += Len;
                Len = 0;
            }
            else
            {
                DCOM(("%03X:    Eat all %d\n",
                      GetCurrentThreadId(), Len));
                
                memcpy(Buffer, Ent->Data, Ent->Len);
                Buffer = (PVOID)((PUCHAR)Buffer + Ent->Len);
                Done += Ent->Len;
                Len -= Ent->Len;

                // Remove used-up entry from list.
                if (Prev == NULL)
                {
                    s_QueueHead = Ent->Next;
                }
                else
                {
                    Prev->Next = Ent->Next;
                }
                if (s_QueueTail == Ent)
                {
                    s_QueueTail = Prev;
                }
                free(Ent);
                continue;
            }
        }

        Prev = Ent;
    }
    
    LeaveCriticalSection(&s_QueueLock);
    return Done;
}

USHORT
DbgRpcComTransport::ScanPort(UCHAR Chan, PVOID Buffer, USHORT Len,
                             BOOL ScanForAck, UCHAR AckChan)
{
    DbgRpcComStream Stream;
    ULONG ReadDone;
    USHORT Ret = 0;

    if (ScanForAck)
    {
        DCOM(("%03X:  Waiting to read header (ack chan %d)\n",
              GetCurrentThreadId(), AckChan));
    }
    else
    {
        DCOM(("%03X:  Waiting to read header\n",
              GetCurrentThreadId()));
    }

 Rescan:
    for (;;)
    {
        if (!ComPortRead(m_Handle, &Stream, sizeof(Stream), &ReadDone,
                         &m_ReadOlap) ||
            ReadDone != sizeof(Stream))
        {
            return DBGRPC_COM_FAILURE;
        }

        // If a write ack came through release the waiting writer.
        if (Stream.Signature == DBGRPC_COM_TAIL_SIG &&
            Stream.Len == DBGRPC_COM_FAILURE)
        {
            DCOM(("%03X:    Read write ack for chan %d\n",
                  GetCurrentThreadId(), Stream.Channel));
            
            if (ScanForAck)
            {
                if (AckChan == Stream.Channel)
                {
                    return (USHORT)ReadDone;
                }
                else
                {
                    DCOM(("%03X:    Read mismatched write ack, "
                          "read chan %d waiting for chan %d\n",
                          GetCurrentThreadId(), Stream.Channel, AckChan));
                    return DBGRPC_COM_FAILURE;
                }
            }
            
            SetEvent(s_WriteAckEvent);
        }
        else if (Stream.Signature != DBGRPC_COM_HEAD_SIG ||
                 Stream.Len == DBGRPC_COM_FAILURE)
        {
            return DBGRPC_COM_FAILURE;
        }
        else
        {
            break;
        }
    }

    DCOM(("%03X:  Read %d,%d\n",
          GetCurrentThreadId(), Stream.Channel, Stream.Len));
    
    // If the data available is for this channel
    // read it directly into the buffer.
    if (!ScanForAck && Stream.Channel == Chan)
    {
        Ret = min(Stream.Len, Len);
        DCOM(("%03X:  Read direct body %d\n",
              GetCurrentThreadId(), Ret));
        if (!ComPortRead(m_Handle, Buffer, Ret, &ReadDone, &m_ReadOlap) ||
            ReadDone != Ret)
        {
            return DBGRPC_COM_FAILURE;
        }

        Stream.Len -= Ret;
    }

    // If the data is for another channel or there's
    // more than we need queue the remainder for
    // later use.
    if (Stream.Len > 0)
    {
        DbgRpcComQueue* Ent =
            (DbgRpcComQueue*)malloc(sizeof(*Ent) + Stream.Len);
        if (Ent == NULL)
        {
            return DBGRPC_COM_FAILURE;
        }

        Ent->Next = NULL;
        Ent->Channel = Stream.Channel;
        Ent->Len = Stream.Len;
        Ent->Data = (PUCHAR)Ent + sizeof(*Ent);

        DCOM(("%03X:  Read queue body %d\n",
              GetCurrentThreadId(), Ent->Len));

        if (!ComPortRead(m_Handle, Ent->Data, Ent->Len, &ReadDone,
                         &m_ReadOlap) ||
            ReadDone != Ent->Len)
        {
            free(Ent);
            return DBGRPC_COM_FAILURE;
        }

        DCOM(("%03X:  Queue add %p %d,%d\n",
              GetCurrentThreadId(), Ent, Ent->Channel, Ent->Len));
        
        EnterCriticalSection(&s_QueueLock);

        if (s_QueueHead == NULL)
        {
            s_QueueHead = Ent;
        }
        else
        {
            s_QueueTail->Next = Ent;
        }
        s_QueueTail = Ent;
        
        LeaveCriticalSection(&s_QueueLock);
    }

    //
    // Acknowledge full receipt of the data.
    //
    
    Stream.Signature = DBGRPC_COM_TAIL_SIG;
    Stream.Channel = Stream.Channel;
    Stream.Len = DBGRPC_COM_FAILURE;
    
    EnterCriticalSection(&s_PortWriteLock);
    
    if (!ComPortWrite(m_Handle, &Stream, sizeof(Stream),
                      &ReadDone, &m_ReadOlap))
    {
        ReadDone = 0;
    }
    else
    {
        DCOM(("%03X:    Wrote write ack for chan %d\n",
              GetCurrentThreadId(), Stream.Channel));
    }

    LeaveCriticalSection(&s_PortWriteLock);
    
    if (ReadDone != sizeof(Stream))
    {
        return DBGRPC_COM_FAILURE;
    }

    // Don't exit if we're waiting for an ack as
    // we haven't received it yet.
    if (ScanForAck)
    {
        SetEvent(s_QueueChangedEvent);
        goto Rescan;
    }
    
    return Ret;
}

USHORT
DbgRpcComTransport::ChanRead(UCHAR Chan, PVOID Buffer, USHORT InLen)
{
    USHORT Done = 0;
    USHORT Len = InLen;
    
    // The virtual channels require that all reads and writes
    // be complete.  A partial read or write will not match
    // its channel header and will throw everything off.

    DCOM(("%03X:ChanRead %d,%d\n",
          GetCurrentThreadId(), Chan, Len));
    
    while (Len > 0)
    {
        USHORT Queued;
        
        // First check and see if input for this channel
        // is already present in the queue.
        Queued = ScanQueue(Chan, Buffer, Len);
        Done += Queued;
        Buffer = (PVOID)((PUCHAR)Buffer + Queued);
        Len -= Queued;

        if (Queued > 0)
        {
            DCOM(("%03X:  Scan pass 1 gets %d from queue\n",
                  GetCurrentThreadId(), Queued));
        }
        
        if (Len == 0)
        {
            break;
        }

        //
        // There wasn't enough queued input so try and
        // read some more from the port.
        //

        if (InterlockedExchange(&s_PortReadOwned, TRUE) == TRUE)
        {
            // Somebody else owns the port so we can't
            // read it.  Just wait for the queue to change
            // so we can check for data again.

            // Set things to wait.
            ResetEvent(s_QueueChangedEvent);

            // There's a chance that the queue changed just before
            // the event was reset and therefore that event set
            // has been lost.  Time out of this wait to ensure
            // that nothing ever gets hung up indefinitely here.
            if (WaitForSingleObject(s_QueueChangedEvent, 250) ==
                WAIT_FAILED)
            {
                DCOM(("%03X:  Change wait failed\n",
                      GetCurrentThreadId()));
                return 0;
            }

            continue;
        }
        
        // We now own the port.  The queue may have changed
        // during the time we were acquiring ownership, though,
        // so check it again.
        Queued = ScanQueue(Chan, Buffer, Len);
        Done += Queued;
        Buffer = (PVOID)((PUCHAR)Buffer + Queued);
        Len -= Queued;

        if (Queued > 0)
        {
            DCOM(("%03X:  Scan pass 2 gets %d from queue\n",
                  GetCurrentThreadId(), Queued));
        }
        
        if (Len > 0)
        {
            // Still need more input and we're now the
            // owner of the port, so read.
            USHORT Port = ScanPort(Chan, Buffer, Len, FALSE, 0);
            if (Port == DBGRPC_COM_FAILURE)
            {
                // Critical error, fail immediately.
                InterlockedExchange(&s_PortReadOwned, FALSE);
                SetEvent(s_QueueChangedEvent);
                DCOM(("%03X:  Critical failure\n",
                      GetCurrentThreadId()));
                return 0;
            }
            
            Done += Port;
            Buffer = (PVOID)((PUCHAR)Buffer + Port);
            Len -= Port;

            if (Port > 0)
            {
                DCOM(("%03X:  Scan %d from port\n",
                      GetCurrentThreadId(), Port));
            }
        }
        
        InterlockedExchange(&s_PortReadOwned, FALSE);
        SetEvent(s_QueueChangedEvent);
    }

    DCOM(("%03X:  ChanRead %d,%d returns %d\n",
          GetCurrentThreadId(), Chan, InLen, Done));
    return Done;
}

USHORT
DbgRpcComTransport::ChanWrite(UCHAR Chan, PVOID Buffer, USHORT InLen)
{
    USHORT Len = InLen;
    
    DCOM(("%03X:ChanWrite %d,%d\n",
          GetCurrentThreadId(), Chan, Len));

    ULONG Done;
    DbgRpcComStream Stream;

    // The virtual channels require that all reads and writes
    // be complete.  A partial read or write will not match
    // its channel header and will throw everything off.

    Stream.Signature = DBGRPC_COM_HEAD_SIG;
    Stream.Channel = Chan;
    Stream.Len = Len;

    // The write ack lock restricts things to a single
    // unacknowledged write.  The port write lock
    // ensures that the multiple pieces of a write
    // are sequential in the stream.
    EnterCriticalSection(&s_WriteAckLock);
    EnterCriticalSection(&s_PortWriteLock);

    if (!ComPortWrite(m_Handle, &Stream, sizeof(Stream), &Done,
                      &m_WriteOlap) ||
        Done != sizeof(Stream) ||
        !ComPortWrite(m_Handle, Buffer, Len, &Done, &m_WriteOlap) ||
        Done != Len)
    {
        Done = 0;
    }
    
    LeaveCriticalSection(&s_PortWriteLock);

    //
    // Wait for data ack.  This prevents too much data from
    // being written to the serial port at once by limiting
    // the amount of outstanding data to a single chunk's worth.
    //

    for (;;)
    {
        if (InterlockedExchange(&s_PortReadOwned, TRUE) == TRUE)
        {
            HANDLE Waits[2];
            ULONG Wait;

            // Somebody else owns the port so wait for their signal.
            // Also wait for a port ownership change as we may
            // need to switch to a direct port read.
            Waits[0] = s_WriteAckEvent;
            Waits[1] = s_QueueChangedEvent;
            
            // Set things to wait.
            ResetEvent(s_QueueChangedEvent);
            
            Wait = WaitForMultipleObjects(2, Waits, FALSE, 250);
            if (Wait == WAIT_OBJECT_0)
            {
                break;
            }
            else if (Wait == WAIT_FAILED)
            {
                DCOM(("%03X:  Write ack wait failed, %d\n",
                      GetCurrentThreadId(), GetLastError()));
                Done = 0;
                break;
            }
        }
        else
        {
            USHORT AckDone;
        
            // We now own the port so directly read the ack.
            // However, before we do we need to make one last
            // check and see if somebody else read our ack
            // in the time leading up to us acquiring port
            // ownership.
            if (WaitForSingleObject(s_WriteAckEvent, 0) != WAIT_OBJECT_0)
            {
                AckDone = ScanPort(Chan, &Stream, sizeof(Stream),
                                   TRUE, Chan);
                if (AckDone == DBGRPC_COM_FAILURE)
                {
                    DCOM(("%03X:  Failed scan for write ack\n",
                          GetCurrentThreadId()));
                    Done = 0;
                }
            }
        
            InterlockedExchange(&s_PortReadOwned, FALSE);
            SetEvent(s_QueueChangedEvent);
            break;
        }
    }
    
    LeaveCriticalSection(&s_WriteAckLock);
    
    DCOM(("%03X:  ChanWrite %d,%d returns %d\n",
          GetCurrentThreadId(), Chan, InLen, Done));
    return (USHORT)Done;
}

HRESULT
DbgRpcComTransport::InitializeChannels(void)
{
    if (s_ChanInitialized)
    {
        return S_OK;
    }

    if ((s_QueueChangedEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    if ((s_WriteAckEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
    {
        return WIN32_LAST_STATUS();
    }

    __try
    {
        InitializeCriticalSection(&s_QueueLock);
        InitializeCriticalSection(&s_PortWriteLock);
        InitializeCriticalSection(&s_WriteAckLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return E_OUTOFMEMORY;
    }

    s_ChanInitialized = TRUE;
    return S_OK;
}

//----------------------------------------------------------------------------
//
// Transport functions.
//
//----------------------------------------------------------------------------

DbgRpcTransport*
DbgRpcNewTransport(ULONG Trans)
{
    switch(Trans)
    {
#ifndef NT_NATIVE
    case TRANS_TCP:
        return new DbgRpcTcpTransport;
    case TRANS_SSL:
        return new DbgRpcSecureChannelTransport(Trans, TRANS_TCP);
    case TRANS_SPIPE:
        return new DbgRpcSecureChannelTransport(Trans, TRANS_NPIPE);
#endif
    case TRANS_NPIPE:
        return new DbgRpcNamedPipeTransport;
    case TRANS_1394:
        return new DbgRpc1394Transport;
    case TRANS_COM:
        return new DbgRpcComTransport;
    default:
        return NULL;
    }
}

DbgRpcTransport*
DbgRpcCreateTransport(PCSTR Options)
{
    ULONG Trans = ParameterStringParser::
        GetParser(Options, TRANS_COUNT, g_DbgRpcTransportNames);
    return DbgRpcNewTransport(Trans);
}

DbgRpcTransport*
DbgRpcInitializeTransport(PCSTR Options)
{
    DbgRpcTransport* Trans = DbgRpcCreateTransport(Options);
    if (Trans != NULL)
    {
        // Clean out any old parameter state.
        Trans->ResetParameters();

        if (!Trans->ParseParameters(Options))
        {
            delete Trans;
            return NULL;
        }
    }

    return Trans;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsvc\makefile.inc ===
$O\dbgsvc_p.hpp $O\dbgsvc_p.cpp $O\dbgsvc_s.hpp $O\dbgsvc_s.cpp: \
            ..\dbgsvc.h ..\..\dbg-common\rremgen.pl
        perl ..\..\dbg-common\rremgen.pl -g $O ..\dbgsvc.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsvc\nt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsvc\pch.hpp ===
//----------------------------------------------------------------------------
//
// Global header file.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifdef NT_NATIVE
#define _CRTIMP
#endif

#include <stdlib.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef NT_NATIVE
#define _ADVAPI32_
#define _KERNEL32_
#endif

#include <windows.h>
#include <objbase.h>

#define NOEXTAPI
#include <wdbgexts.h>
#include <dbgeng.h>
#include <dbgsvc.h>
#include <ntdbg.h>

#include <dllimp.h>
#include <cmnutil.hpp>

#include <dbgrpc.hpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dbgsvc\w32\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\browse.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    browse.cpp

Abstract:
    This file implements the functions that make use of the common
    file open dialogs for browsing for files/directories.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


static _TCHAR  szHelpFileName[MAX_PATH];
static _TCHAR  szLastWaveFile[MAX_PATH];
static _TCHAR  szLastDumpFile[MAX_PATH];



int CALLBACK
BrowseHookProc(
    HWND hwnd,
    UINT message,
    LPARAM lParam,
    LPARAM lpData
    )

/*++

Routine Description:

    Hook procedure for directory browse common file dialog.  This hook
    procedure is required to provide help, put the window in the
    foreground, and set the edit so that the common file dialog dll
    thinks the user entered a value.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - Caller's data

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    POINT pt;
    DWORD ctlId;

    switch (message) {
#if 0
    case WM_COMMAND:
        if (wParam==psh15) {
            //
            // get the help file name
            //
            GetHtmlHelpFileName(szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR)  );
            //GetWinHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );

            //
            // call for Help
            //
            HtmlHelp(hwnd,
                     szHelpFileName,
                     HH_DISPLAY_TOPIC,
                     (DWORD_PTR)(IDHH_LOGFILELOCATION)
                     );
            //WinHelp( hwnd, szHelpFileName, HELP_FINDER, IDH_LOGFILELOCATION );
        }
        break;

    case WM_CONTEXTMENU: // right mouse click
        if( hwnd == (HWND) wParam ) {
            GetCursorPos(&pt);
            ScreenToClient(hwnd, &pt);
            wParam = (WPARAM) ChildWindowFromPoint(hwnd, pt);
        }

        //
        // only mess with our controls
        //
        ctlId = GetDlgCtrlID((HWND) wParam);
        if (ctlId != psh15) {
            break;
        }

        GetWinHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
        WinHelp((HWND)wParam,
                szHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR) DrWatsonHelpIds
                );
        return TRUE;
#endif    
    case BFFM_INITIALIZED:
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
        break;
    }

    return FALSE;
}

BOOL
BrowseForDirectory(
    HWND hwnd,
    _TCHAR *szCurrDir
    )

/*++

Routine Description:

    Presents a common file open dialog that contains only the directory
    tree.  The use can select a directory for use as a storage location
    for the DRWTSN32 log file.

Arguments:

    szCurrDir  - current directory

Return Value:

    TRUE       - got a good directory (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the szCurrDir is also changed to have the selected directory.

--*/

{
    BROWSEINFO    browseinfo;
    LPITEMIDLIST  pitemidlist;
    _TCHAR          ftitle     [MAX_PATH];
    _TCHAR          title      [MAX_PATH];
    _TCHAR          fname      [MAX_PATH];
    _TCHAR          szDir      [_MAX_DIR];

    browseinfo.hwndOwner = hwnd;
    browseinfo.pidlRoot  = NULL;
    browseinfo.pszDisplayName = fname;
    _tcscpy( title, LoadRcString( IDS_LOGBROWSE_TITLE ) );
    browseinfo.lpszTitle = title;
    browseinfo.ulFlags = BIF_NEWDIALOGSTYLE |
                         BIF_RETURNONLYFSDIRS ;
    browseinfo.lpfn = BrowseHookProc;
    browseinfo.lParam = (LPARAM) szCurrDir;
    
    if (pitemidlist = SHBrowseForFolder(&browseinfo)) {
        SHFILEINFO FolderData;
        if (SHGetPathFromIDList(pitemidlist, 
                                szDir )) {
            _tcscpy( szCurrDir, szDir );
            szCurrDir[_tcslen(szCurrDir)] = _T('\0');
            return TRUE;
        }
    }
    return FALSE;
}

UINT_PTR
WaveHookProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure for wave file selection common file dialog.  This hook
    procedure is required to provide help, put the window in the
    foreground, and provide a test button for listening to a wave file.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    _TCHAR szWave[MAX_PATH];
    DWORD ctlId;
    NMHDR *pnmhdr;

    switch (message) {
        case WM_INITDIALOG:
            SetForegroundWindow( hwnd );
            return (TRUE);
            break;

        case WM_COMMAND:
            switch (wParam) {
            case ID_TEST_WAVE:
                CommDlg_OpenSave_GetFilePath(GetParent(hwnd), szWave, sizeof(szWave) / sizeof(_TCHAR));
                PlaySound( szWave, NULL, SND_FILENAME );
                break;

#if 0
                case psh15:
                    //
                    // get the help file name
                    //
                    GetHtmlHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );
                    //GetWinHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );

                    //
                    // call for Help
                    //
                    HtmlHelp(hwnd,
                             szHelpFileName,
                             HH_DISPLAY_TOPIC,
                             (DWORD_PTR)(IDHH_WAVEFILE)
                            );
                    //WinHelp( hwnd, szHelpFileName, HELP_FINDER, IDH_WAVEFILE );
                    break;
#endif            
            }
            break;

#if 0
        case WM_CONTEXTMENU: // right mouse click
            if( hwnd == (HWND) wParam ) {
                POINT pt;
                GetCursorPos(&pt);
                ScreenToClient(hwnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hwnd, pt);
            }

            //
            // only mess with our controls
            //
            ctlId = GetDlgCtrlID((HWND) wParam);
            if (ctlId != psh15 && ctlId != ID_TEST_WAVE) {
                break;
            }

            GetWinHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            WinHelp((HWND)wParam,
                    szHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR) DrWatsonHelpIds
                    );
            return TRUE;
#endif
    case WM_NOTIFY:
        pnmhdr = (NMHDR *) lParam;
        if (pnmhdr->code == CDN_HELP) {
            LPOFNOTIFY pofn = (LPOFNOTIFY) lParam;
            
            PostMessage(pofn->lpOFN->hwndOwner, IDH_WAVE_FILE, 0 , 0);
            
            return TRUE;


            GetHtmlHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );
            HtmlHelp(pofn->lpOFN->hwndOwner,
                    szHelpFileName,
                    HH_DISPLAY_TOPIC,
                    (DWORD_PTR) (IDHH_WAVEFILE)
                    );
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
GetWaveFileName(
    HWND hwnd,
    _TCHAR *szWaveName
    )

/*++

Routine Description:

    Presents a common file open dialog for the purpose of selecting a
    wave file to be played when an application error occurs.

Arguments:

    szWaveName - name of the selected wave file

Return Value:

    TRUE       - got a good wave file name (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the szWaveName is changed to have the selected wave file name.

--*/

{
    OPENFILENAME   of;
    _TCHAR           ftitle[MAX_PATH];
    _TCHAR           title[MAX_PATH];
    _TCHAR           fname[MAX_PATH];
    _TCHAR           filter[1024];
    _TCHAR           szDrive    [_MAX_DRIVE];
    _TCHAR           szDir      [_MAX_DIR];
    _TCHAR           szDefExt[]=_T("wav");

    LPTSTR           pszfil;

    ZeroMemory(&of, sizeof(OPENFILENAME));
    ftitle[0] = 0;
    _tcscpy( fname, *szWaveName ? szWaveName : _T("*.wav") );
    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = hwnd;
    of.hInstance = GetModuleHandle( NULL );
    _tcscpy( filter, LoadRcString( IDS_WAVE_FILTER ) );
    pszfil=&filter[_tcslen(filter)+1];
    _tcscpy( pszfil, _T("*.wav") );
    pszfil[_tcslen(pszfil)+1] = _T('\0');
    of.lpstrFilter = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 0;
    of.lpstrFile = fname;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = ftitle;
    of.nMaxFileTitle = MAX_PATH;
    _tcscpy( title, LoadRcString( IDS_WAVEBROWSE_TITLE ) );
    of.lpstrTitle = title;
    of.Flags = OFN_NONETWORKBUTTON |
               OFN_HIDEREADONLY    |
               OFN_ENABLEHOOK      |
               OFN_ENABLETEMPLATE  |
#if 1
               OFN_SHOWHELP        |
#endif               
               OFN_NOCHANGEDIR     |
               OFN_EXPLORER        |
               OFN_ENABLESIZING    |
               OFN_NODEREFERENCELINKS;
    of.nFileOffset = 0;
    of.nFileExtension = 0;
    of.lpstrDefExt = szDefExt;
    of.lCustData = 0;
    of.lpfnHook = WaveHookProc;
    of.lpTemplateName = MAKEINTRESOURCE(WAVEFILEOPENDIALOG2);
    if (GetOpenFileName( &of )) {
        _tcscpy( szWaveName, fname );
        _tsplitpath( fname, szDrive, szDir, NULL, NULL );
        _tcscpy( szLastWaveFile, szDrive );
        _tcscat( szLastWaveFile, szDir );
        return TRUE;
    }
    return FALSE;
}

UINT_PTR
DumpHookProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Hook procedure for wave file selection common file dialog.  This hook
    procedure is required to provide help, put the window in the
    foreground, and provide a test button for listening to a wave file.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    DWORD ctlId;
    NMHDR *pnmhdr;

    switch (message) {
#if 0
        case WM_INITDIALOG:
            SetForegroundWindow( hwnd );
            return (TRUE);
            break;

        case WM_COMMAND:
            switch (wParam) {
                case psh15:
                    //
                    // get the help file name
                    //
                    GetHtmlHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );
                    //GetWinHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );

                    //
                    // call HtmlHelp
                    //
                    HtmlHelp(hwnd,
                             szHelpFileName,
                             HH_DISPLAY_TOPIC,
                             (DWORD_PTR)(IDHH_CRASH_DUMP)
                            );
                    //WinHelp( hwnd, szHelpFileName, HELP_FINDER, IDH_CRASH_DUMP );
                    break;
            }
            break;

        case WM_CONTEXTMENU: // right mouse click
            if( hwnd == (HWND) wParam ) {
                POINT pt;
                GetCursorPos(&pt);
                ScreenToClient(hwnd, &pt);
                wParam = (WPARAM) ChildWindowFromPoint(hwnd, pt);
            }

            //
            // only mess with our controls
            //
            ctlId = GetDlgCtrlID((HWND) wParam);
            if (ctlId != psh15) {
                break;
            }

            GetWinHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            WinHelp((HWND)wParam,
                    szHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR) DrWatsonHelpIds
                    );
            return TRUE;
#endif    
    case WM_NOTIFY:
        pnmhdr = (NMHDR *) lParam;
        if (pnmhdr->code == CDN_HELP) {
            LPOFNOTIFY pofn = (LPOFNOTIFY) lParam;

            PostMessage(pofn->lpOFN->hwndOwner, IDH_CRASH_DUMP, 0 , 0);
            
            return TRUE;
            
            GetHtmlHelpFileName( szHelpFileName, sizeof( szHelpFileName ) / sizeof(_TCHAR) );
            
            HtmlHelp(pofn->lpOFN->hwndOwner,
                    szHelpFileName,
                    HH_DISPLAY_TOPIC,
                    (DWORD_PTR) (IDHH_CRASH_DUMP)
                    );
            return TRUE;
        }
    case WM_CLOSE:
        HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
        break;
    }

    return FALSE;
}

BOOL
GetDumpFileName(
    HWND hwnd,
    _TCHAR *szDumpName
    )

/*++

Routine Description:

    Presents a common file open dialog for the purpose of selecting a
    wave file to be played when an application error occurs.

Arguments:

    szWaveName - name of the selected wave file

Return Value:

    TRUE       - got a good wave file name (user pressed the OK button)
    FALSE      - got nothing (user pressed the CANCEL button)

    the szWaveName is changed to have the selected wave file name.

--*/

{
    OPENFILENAME   of;
    _TCHAR           ftitle[MAX_PATH];
    _TCHAR           title[MAX_PATH];
    _TCHAR           fname[MAX_PATH];
    _TCHAR           filter[1024];
    _TCHAR           szDrive    [_MAX_DRIVE];
    _TCHAR           szDir      [_MAX_DIR];
    _TCHAR           szDefExt[]=_T("dmp");

    LPTSTR           pszfil;

    ZeroMemory(&of, sizeof(OPENFILENAME));
    ftitle[0] = 0;
    _tcscpy( fname, *szDumpName ? szDumpName : _T("*.dmp") );
    of.lStructSize = sizeof(OPENFILENAME);
    of.hwndOwner = hwnd;
    of.hInstance = GetModuleHandle( NULL );
    _tcscpy( filter, LoadRcString( IDS_DUMP_FILTER ) );
    pszfil=&filter[_tcslen(filter)+1];
    _tcscpy( pszfil, _T("*.dmp") );
    pszfil[_tcslen(pszfil) +1] = _T('\0');
    of.lpstrFilter = filter;
    of.lpstrCustomFilter = NULL;
    of.nMaxCustFilter = 0;
    of.nFilterIndex = 0;
    of.lpstrFile = fname;
    of.nMaxFile = MAX_PATH;
    of.lpstrFileTitle = ftitle;
    of.nMaxFileTitle = MAX_PATH;
    _tcscpy( title, LoadRcString( IDS_DUMPBROWSE_TITLE ) );
    of.lpstrTitle = title;
    of.Flags = //OFN_NONETWORKBUTTON |
               OFN_HIDEREADONLY    |
               OFN_ENABLEHOOK      |
#if 1
               OFN_SHOWHELP        |
#endif               
               OFN_NOCHANGEDIR     |
               OFN_EXPLORER        |
               OFN_ENABLESIZING;
    of.nFileOffset = 0;
    of.nFileExtension = 0;
    of.lpstrDefExt = szDefExt;
    of.lCustData = 0;
    of.lpfnHook = DumpHookProc;
    of.lpTemplateName = MAKEINTRESOURCE(DUMPFILEOPENDIALOG);
    if (GetOpenFileName( &of )) {
        _tcscpy( szDumpName, fname );
        _tsplitpath( fname, szDrive, szDir, NULL, NULL );
        _tcscpy( szLastDumpFile, szDrive );
        _tcscat( szLastDumpFile, szDir );
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\drwatson.h ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    drwatson.h

Abstract:

    Common header file for drwatson data structures.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

typedef enum _CrashDumpType {
    FullDump  = 0,
    MiniDump  = 1,
    FullMiniDump = 2,
} CrashDumpType;

typedef struct _tagOPTIONS {
    _TCHAR                      szLogPath[MAX_PATH];
    _TCHAR                      szWaveFile[MAX_PATH];
    _TCHAR                      szCrashDump[MAX_PATH];
    BOOL                        fDumpSymbols;
    BOOL                        fDumpAllThreads;
    BOOL                        fAppendToLogFile;
    BOOL                        fVisual;
    BOOL                        fSound;
    BOOL                        fCrash;
    // true: Generate user dump name in the range from fname000.dmp to fname999.dmp
    // false: standard behavior, always overwrite fname.dmp when generating a new
    //      dump file.
    BOOL                        fUseSequentialNaming;
    // If TRUE use long file names when sequentially naming the dumps
    // If FALSE use 8.3 file names when sequentially naming the dumps
    //      causes the 'n' of characters to be removed from the end of the
    //      file name to make it fit in the 8.3 format. ie longuser.dmp -> longus00.dmp
    BOOL                        fUseLongFileNames;
    int                         nNextDumpSequence;
    DWORD                       dwInstructions;
    DWORD                       dwMaxCrashes;
    CrashDumpType               dwType;
} OPTIONS, *POPTIONS;

typedef struct _tagCRASHES {
    _TCHAR                      szAppName[256];
    _TCHAR                      szFunction[256];
    SYSTEMTIME                  time;
    DWORD                       dwExceptionCode;
    DWORD_PTR                   dwAddress;
} CRASHES, *PCRASHES;

typedef struct _tagCRASHINFO {
    HWND       hList;
    CRASHES    crash;
    HDC        hdc;
    DWORD      cxExtent;
    DWORD      dwIndex;
    DWORD      dwIndexDesired;
    BYTE      *pCrashData;
    DWORD      dwCrashDataSize;
} CRASHINFO, *PCRASHINFO;

typedef struct _tagDEBUGPACKET {
    HWND                    hwnd;
    OPTIONS                 options;
    DWORD                   dwPidToDebug;
    HANDLE                  hEventToSignal;
    HANDLE                  hProcess;
    DWORD                   dwProcessId;
    DWORD                   ExitStatus;
    
    // Debug engine interfaces.
    PDEBUG_CLIENT2          DbgClient;
    PDEBUG_CONTROL          DbgControl;
    PDEBUG_DATA_SPACES      DbgData;
    PDEBUG_REGISTERS        DbgRegisters;
    PDEBUG_SYMBOLS          DbgSymbols;
    PDEBUG_SYSTEM_OBJECTS   DbgSystem;
} DEBUGPACKET, *PDEBUGPACKET;

typedef BOOL (CALLBACK* CRASHESENUMPROC)(PCRASHINFO);

#if DBG
#define Assert(exp)    if(!(exp)) {AssertError(_T(#exp),_T(__FILE__),__LINE__);}
#else
#define Assert(exp)
#endif

#define WM_DUMPCOMPLETE       WM_USER+500
#define WM_EXCEPTIONINFO      WM_USER+501
#define WM_ATTACHCOMPLETE     WM_USER+502
#define WM_FINISH             WM_USER+503

extern const DWORD DrWatsonHelpIds[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\controls.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    controls.cpp

Abstract:
    This file implements the sun-classing and message processing of
    the controls on the main ui dialog.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


typedef struct _tagDWCONTROLINFO {
    struct _tagDWCONTROLINFO   *next;
    HWND                       hwnd;
    WNDPROC                    wndProc;
} DWCONTROLINFO, *PDWCONTROLINFO;


PDWCONTROLINFO   ciHead    = NULL;
PDWCONTROLINFO   ciTail    = NULL;
PDWCONTROLINFO   ciFocus   = NULL;
PDWCONTROLINFO   ciDefault = NULL;



void
SetFocusToCurrentControl(
    void
    )

/*++

Routine Description:

    Sets the focus  to the current control.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (ciFocus != NULL) {
        SetFocus( ciFocus->hwnd );
        SendMessage( ciFocus->hwnd, BM_SETSTATE, 0, 0 );
    }
}

LRESULT
ControlWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Processes focus messages and ensures that when the focus changes
    from one button to another that the old button looses the focus
    and the "default" state.

Arguments:

    Standard WNDPROC entry.

Return Value:

    LRESULT - Depending on input message and processing options.

--*/

{
    PDWCONTROLINFO ci = ciHead;

    while (ci->hwnd != hwnd) {
        ci = ci->next;
        if (ci == NULL) {
            return FALSE;
        }
    }

    switch(message) {
        case WM_SETFOCUS:
            ciFocus = ci;
            break;

        case BM_SETSTYLE:
            if (wParam == BS_DEFPUSHBUTTON) {
                ciDefault = ci;
            }
            break;

        case BM_SETSTATE:
            if ((GetWindowLong( hwnd, GWL_STYLE ) & 0xff) < BS_CHECKBOX) {
                //
                // change the button that had the focus
                //
                SendMessage( ciDefault->hwnd,
                             BM_SETSTYLE,
                             ( WPARAM ) BS_PUSHBUTTON,
                             ( LPARAM ) TRUE
                           );
                UpdateWindow( ciDefault->hwnd );

                //
                // change the button that is getting the focus
                //
                SendMessage( hwnd,
                             BM_SETSTYLE,
                             ( WPARAM ) BS_DEFPUSHBUTTON,
                             ( LPARAM ) TRUE
                           );
                SetFocus( hwnd );
                UpdateWindow( hwnd );
            }
            break;
    }

    return CallWindowProc( ci->wndProc, hwnd, message, wParam, lParam );
}


BOOL
CALLBACK
EnumChildProc(
    HWND hwnd,
    LPARAM lParam
    )

/*++

Routine Description:

    Subclass a controls in DrWatson's main window.

Arguments:

    hwnd    - Supplies the window handle for the main window.

    lParam  - non used

Return Value:

    BOOL    - Returns TRUE if each of the buttons in the ButtonHelpTable is
              subclassed.

--*/

{
    PDWCONTROLINFO ci;

    //
    // add the control to the linked list
    //
    ci = (PDWCONTROLINFO) calloc( sizeof(DWCONTROLINFO), sizeof(BYTE) );
    if (ci == NULL) {
        return FALSE;
    }

    if (ciHead == NULL) {
        ciHead = ciTail = ci;
    }
    else {
        ciTail->next = ci;
        ciTail = ci;
    }

    //
    // save the HWND
    //
    ci->hwnd = hwnd;

    //
    // change the WNDPROC and save the address of the old one
    //
    ci->wndProc = (WNDPROC) SetWindowLongPtr( hwnd,
                                           GWLP_WNDPROC,
                                           (LONG_PTR)ControlWndProc
                                         );

    if (GetWindowLong( hwnd, GWL_STYLE ) & BS_DEFPUSHBUTTON) {
        ciDefault = ci;
    }

    return TRUE;
}

BOOL
SubclassControls(
    HWND hwnd
    )

/*++

Routine Description:

    Subclass the controls in DrWatson's main window.

Arguments:

    hWnd    - Supplies the window handle for the main window.

Return Value:

    BOOL    - Returns TRUE if each of the buttons in the ButtonHelpTable is
              subclassed.

--*/

{
    EnumChildWindows( hwnd, EnumChildProc, 0 );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\drwtsn32.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    drwtsn32.cpp

Abstract:

    This file implements the user interface for DRWTSN32.  this includes
    both dialogs: the ui for the control of the options & the popup
    ui for application errors.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


int
__cdecl
main(
    int argc,
    _TCHAR *argv[]
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    argc           - argument count

    argv           - array of arguments

Return Value:

    always zero.

--*/

{
    DWORD   dwPidToDebug = 0;
    HANDLE  hEventToSignal = 0;
    BOOLEAN rc;

    // Keep Dr. Watson from recursing
    __try {

        rc = GetCommandLineArgs( &dwPidToDebug, &hEventToSignal );

        if (dwPidToDebug > 0) {
            
            NotifyWinMain();

        } else if (!rc) {
            
            DrWatsonWinMain();

        }

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        // We suffered an error, fail gracefully
        return 1;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\debug.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    This file implements the debug module for drwatson.  This module
    processes all debug events and generates the postmortem dump.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


#define STATUS_POSSIBLE_DEADLOCK        ((DWORD)0xC0000194L)
#define STATUS_VDM_EVENT                STATUS_SEGMENT_NOTIFICATION

typedef struct tagSYSINFO {
    _TCHAR   szUserName[MAX_PATH];
    _TCHAR   szMachineName[MAX_PATH];
} SYSINFO, *PSYSINFO;

//----------------------------------------------------------------------------
//
// Log output callbacks.
//
//----------------------------------------------------------------------------

class LogOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

LogOutputCallbacks g_LogOutCb;

STDMETHODIMP
LogOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
        IsEqualIID(InterfaceId, __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
LogOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
LogOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
LogOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    PCSTR Scan;

    for (;;)
    {
        Scan = strchr(Text, '\n');
        if (Scan == NULL)
        {
            break;
        }

        lprintfs(_T("%.*hs\r\n"), (int)(Scan - Text), Text);
        Text = Scan + 1;
    }
    
    lprintfs(_T("%hs"), Text);
    return S_OK;
}


_TCHAR *
GetExceptionText(
    DWORD dwExceptionCode
    )
{
    static _TCHAR buf[80];
    DWORD dwFormatId = 0;

    memset( buf, 0, sizeof(buf) );

    switch (dwExceptionCode) {
        case STATUS_SINGLE_STEP:
            dwFormatId = MSG_SINGLE_STEP_EXCEPTION;
            break;

        case DBG_CONTROL_C:
            dwFormatId = MSG_CONTROLC_EXCEPTION;
            break;

        case DBG_CONTROL_BREAK:
            dwFormatId = MSG_CONTROL_BRK_EXCEPTION;
            break;

        case STATUS_ACCESS_VIOLATION:
            dwFormatId = MSG_ACCESS_VIOLATION_EXCEPTION;
            break;

        case STATUS_STACK_OVERFLOW:
            dwFormatId = MSG_STACK_OVERFLOW_EXCEPTION;
            break;

        case STATUS_INTEGER_DIVIDE_BY_ZERO:
            dwFormatId = MSG_INTEGER_DIVIDE_BY_ZERO_EXCEPTION;
            break;

        case STATUS_PRIVILEGED_INSTRUCTION:
            dwFormatId = MSG_PRIVILEGED_INSTRUCTION_EXCEPTION;
            break;

        case STATUS_ILLEGAL_INSTRUCTION:
            dwFormatId = MSG_ILLEGAL_INSTRUCTION_EXCEPTION;
            break;

        case STATUS_IN_PAGE_ERROR:
            dwFormatId = MSG_IN_PAGE_IO_EXCEPTION;
            break;

        case STATUS_DATATYPE_MISALIGNMENT:
            dwFormatId = MSG_DATATYPE_EXCEPTION;
            break;

        case STATUS_POSSIBLE_DEADLOCK:
            dwFormatId = MSG_DEADLOCK_EXCEPTION;
            break;

        case STATUS_VDM_EVENT:
            dwFormatId = MSG_VDM_EXCEPTION;
            break;

        case STATUS_BREAKPOINT:
            dwFormatId = MSG_BREAKPOINT_EXCEPTION;
            break;

        default:
            lprintfs( _T("\r\n") );
            break;
    }

    FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   NULL,
                   dwFormatId,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                   buf,
                   sizeof(buf) / sizeof(_TCHAR),
                   NULL
                 );

    return buf;
}

void
CreateEngineInterfaces(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;

    if ((Status = DebugCreate(__uuidof(IDebugClient2),
                              (void **)&dp->DbgClient)) != S_OK) {
        goto Error;
    }

    if ((Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugControl),
                        (void **)&dp->DbgControl)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugDataSpaces),
                        (void **)&dp->DbgData)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugRegisters),
                        (void **)&dp->DbgRegisters)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugSymbols),
                        (void **)&dp->DbgSymbols)) != S_OK ||
        (Status = dp->DbgClient->
         QueryInterface(__uuidof(IDebugSystemObjects),
                        (void **)&dp->DbgSystem)) != S_OK) {
        goto Error;
    }

    if ((Status = dp->DbgSymbols->
         AddSymbolOptions(SYMOPT_FAIL_CRITICAL_ERRORS)) != S_OK ||
        (Status = dp->DbgControl->
         AddEngineOptions(DEBUG_ENGOPT_INITIAL_BREAK)) != S_OK ||
        (Status = dp->DbgControl->
         Execute(DEBUG_OUTCTL_IGNORE, "sxe et",
                 DEBUG_EXECUTE_DEFAULT)) != S_OK) {
        goto Error;
    }
    
    return;

 Error:
    if (dp->options.fVisual) {
        FatalError( Status, LoadRcString(IDS_CANT_INIT_ENGINE) );
    }
    else {
        ExitProcess( 1 );
    }
}

void
AttachToActiveProcess (
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    
    if ((Status = dp->DbgClient->
         AttachProcess(0, dp->dwPidToDebug, DEBUG_ATTACH_DEFAULT)) != S_OK) {
        if (dp->options.fVisual) {
            FatalError( Status, LoadRcString(IDS_ATTACHFAIL) );
        }
        else {
            ExitProcess( 1 );
        }
    }

    return;
}

DWORD
SysInfoThread(
    PSYSINFO si
    )
{
    DWORD len;

    len = sizeof(si->szMachineName) / sizeof(_TCHAR);
    GetComputerName( si->szMachineName, &len );
    len = sizeof(si->szUserName) / sizeof(_TCHAR);
    GetUserName( si->szUserName, &len );

    return 0;
}

void
LogSystemInformation(
    PDEBUGPACKET dp
    )
{
    _TCHAR         buf[1024];
    SYSTEM_INFO   si;
    DWORD         ver;
    SYSINFO       mySi;
    SYSINFO*      threadSi;
    DWORD         dwThreadId;
    HANDLE        hThread;
    DWORD         TSid;

    lprintf( MSG_SYSINFO_HEADER );

    // Initialize default unknown values.
    _tcscpy( mySi.szMachineName, LoadRcString( IDS_UNKNOWN_MACHINE ) );
    _tcscpy( mySi.szUserName,    LoadRcString( IDS_UNKNOWN_USER ) );

    // Attempt to get the actual values.
    // The storage passed to the get thread is not taken
    // from this thread's stack so that this function can exit
    // without leaving the other thread with stale stack pointers.
    threadSi = (SYSINFO*)malloc(sizeof(*threadSi));
    if (threadSi != NULL) {
        hThread = CreateThread( NULL,
                                16000,
                                (LPTHREAD_START_ROUTINE)SysInfoThread,
                                threadSi,
                                0,
                                &dwThreadId
                                );
        if (hThread != NULL) {
            // Let the thread run for a little while since
            // the get calls can be slow.  If the thread doesn't
            // finish in the time allotted we'll just go ahead
            // with the default values and forget about the get thread.
            Sleep( 0 );
            if (WaitForSingleObject( hThread, 30000 ) == WAIT_OBJECT_0) {
                // Thread finished so we have the real values.
                _tcscpy(mySi.szMachineName, threadSi->szMachineName);
                _tcscpy(mySi.szUserName, threadSi->szUserName);
                free(threadSi);
            }
            CloseHandle( hThread );
        } else {
            free(threadSi);
        }
    }

    lprintf( MSG_SYSINFO_COMPUTER, mySi.szMachineName );
    lprintf( MSG_SYSINFO_USER, mySi.szUserName );
    ProcessIdToSessionId(dp->dwPidToDebug, &TSid);
    _stprintf( buf, _T("%d"), TSid );
    lprintf( MSG_SYSINFO_TERMINAL_SESSION, buf );
    GetSystemInfo( &si );
    _stprintf( buf, _T("%d"), si.dwNumberOfProcessors );
    lprintf( MSG_SYSINFO_NUM_PROC, buf );
    RegLogProcessorType();
    ver = GetVersion();
    _stprintf( buf, _T("%d.%d"), LOBYTE(LOWORD(ver)), HIBYTE(LOWORD(ver)) );
    lprintf( MSG_SYSINFO_WINVER, buf );
    RegLogCurrentVersion();
    lprintfs( _T("\r\n") );
}

void
LogTaskList(
    PDEBUGPACKET dp
    )

/*++

Routine Description:

    This function gets the current task list and logs the process id &
    process name to the log file.

--*/

{
    HRESULT Status;
#define MAX_IDS 8192
    PULONG Ids = NULL;
    ULONG IdCount;
    ULONG i;

    Ids = (PULONG)malloc(sizeof(*Ids) * MAX_IDS);
    if (Ids == NULL) {
        goto Error;
    }
    
    if ((Status = dp->DbgClient->
         GetRunningProcessSystemIds(0, Ids, MAX_IDS,
                                    &IdCount)) != S_OK) {
        goto Error;
    }

    if (IdCount > MAX_IDS) {
        // Incomplete process list is good enough.
        IdCount = MAX_IDS;
    }

    lprintf( MSG_TASK_LIST );

    for (i = 0; i < IdCount; i++) {
        char ExeName[MAX_PATH];

        if ((Status = dp->DbgClient->
             GetRunningProcessDescription(0, Ids[i],
                                          DEBUG_PROC_DESC_NO_PATHS,
                                          ExeName, sizeof(ExeName),
                                          NULL, NULL, 0, NULL)) != S_OK) {
            lprintfs(_T("%4d Error 0x%08X\r\n"), Ids[i], Status);
        } else {
            lprintfs(_T("%4d %hs\r\n"), Ids[i], ExeName);
        }
    }

    lprintfs( _T("\r\n") );

    free(Ids);
    return;

 Error:
    _tprintf( _T("ERROR: could not get the task list\n") );
    free(Ids);
}

void
LogModuleList(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    ULONG NumMod;
    ULONG i;
    char Image[MAX_PATH];
    DEBUG_MODULE_PARAMETERS Params;
    
    lprintf( MSG_MODULE_LIST );

    if ((Status = dp->DbgSymbols->GetNumberModules(&NumMod, &i)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }

    for (i = 0; i < NumMod; i++) {
        if ((Status = dp->DbgSymbols->
             GetModuleParameters(1, NULL, i, &Params)) != S_OK ||
            FAILED(Status = dp->DbgSymbols->
                   GetModuleNames(i, 0, Image, sizeof(Image), NULL,
                                  NULL, 0, NULL, NULL, 0, NULL))) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        } else {
            lprintfs(_T("(%016I64x - %016I64x: %hs\r\n"),
                     Params.Base, Params.Base + Params.Size,
                     Image);
        }
    }

    lprintfs( _T("\r\n") );
}

void
LogStackDump(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    DWORD   i;
    DWORD   j;
    BYTE    stack[1024] = {0};
    ULONG64 StackOffset;

    if ((Status = dp->DbgRegisters->GetStackOffset(&StackOffset)) != S_OK ||
        (Status = dp->DbgData->ReadVirtual(StackOffset,
                                           stack,
                                           sizeof(stack),
                                           &i)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }

    lprintf( MSG_STACK_DUMP_HEADER );

    for( i = 0; i < 20; i++ ) {
        j = i * 16;
        lprintfs( _T("%016I64x  %02x %02x %02x %02x %02x %02x %02x %02x - ")
                  _T("%02x %02x %02x %02x %02x %02x %02x %02x  ")
                  _T("%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\r\n"),
                  j + StackOffset,
                  stack[ j +  0 ],
                  stack[ j +  1 ],
                  stack[ j +  2 ],
                  stack[ j +  3 ],
                  stack[ j +  4 ],
                  stack[ j +  5 ],
                  stack[ j +  6 ],
                  stack[ j +  7 ],
                  stack[ j +  8 ],
                  stack[ j +  9 ],
                  stack[ j + 10 ],
                  stack[ j + 11 ],
                  stack[ j + 12 ],
                  stack[ j + 13 ],
                  stack[ j + 14 ],
                  stack[ j + 15 ],
                  isprint( stack[ j +  0 ]) ? stack[ j +  0 ] : _T('.'),
                  isprint( stack[ j +  1 ]) ? stack[ j +  1 ] : _T('.'),
                  isprint( stack[ j +  2 ]) ? stack[ j +  2 ] : _T('.'),
                  isprint( stack[ j +  3 ]) ? stack[ j +  3 ] : _T('.'),
                  isprint( stack[ j +  4 ]) ? stack[ j +  4 ] : _T('.'),
                  isprint( stack[ j +  5 ]) ? stack[ j +  5 ] : _T('.'),
                  isprint( stack[ j +  6 ]) ? stack[ j +  6 ] : _T('.'),
                  isprint( stack[ j +  7 ]) ? stack[ j +  7 ] : _T('.'),
                  isprint( stack[ j +  8 ]) ? stack[ j +  8 ] : _T('.'),
                  isprint( stack[ j +  9 ]) ? stack[ j +  9 ] : _T('.'),
                  isprint( stack[ j + 10 ]) ? stack[ j + 10 ] : _T('.'),
                  isprint( stack[ j + 11 ]) ? stack[ j + 11 ] : _T('.'),
                  isprint( stack[ j + 12 ]) ? stack[ j + 12 ] : _T('.'),
                  isprint( stack[ j + 13 ]) ? stack[ j + 13 ] : _T('.'),
                  isprint( stack[ j + 14 ]) ? stack[ j + 14 ] : _T('.'),
                  isprint( stack[ j + 15 ]) ? stack[ j + 15 ] : _T('.')
                );
    }

    lprintfs( _T("\r\n") );
}

void
LogCurrentThreadInformation(
    PDEBUGPACKET dp,
    PCRASHES crash
    )
{
    HRESULT Status;
    ULONG ThreadId;
    _TCHAR IdBuf[16];
    ULONG64 InstrOffs;
    DWORD InstrWindow;
    // The size should match the size of pCrash->szFunction
    char FuncNameA[256];
    WCHAR FuncNameW[256];
    ULONG64 Displ;

    if ((Status = dp->DbgSystem->
         GetCurrentThreadSystemId(&ThreadId)) != S_OK) {
        ThreadId = 0xffffffff;
    }
    
    _stprintf( IdBuf, _T("%x"), ThreadId );
    lprintf( MSG_STATE_DUMP, IdBuf );

    dp->DbgClient->SetOutputCallbacks(&g_LogOutCb);
    
    if ((Status = dp->DbgRegisters->
         OutputRegisters(DEBUG_OUTCTL_THIS_CLIENT,
                         DEBUG_REGISTERS_DEFAULT)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
    }
    lprintfs( _T("\r\n") );

    InstrWindow = dp->options.dwInstructions;
    if (InstrWindow > 500) {
        InstrWindow = 500;
    }

    strcpy(FuncNameA, "<nosymbols>");
    wcscpy(FuncNameW, L"<nosymbols>");

    if ((Status = dp->DbgRegisters->
         GetInstructionOffset(&InstrOffs)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
    } else {
        if (FAILED(Status = dp->DbgSymbols->
                   GetNameByOffset(InstrOffs, FuncNameA, sizeof(FuncNameA),
                                   NULL, &Displ))) {
            strcpy(FuncNameA, "<nosymbols>");
        }

#ifdef UNICODE
        if (MultiByteToWideChar(CP_ACP, 0, FuncNameA, -1,
                                FuncNameW,
                                sizeof(FuncNameW) / sizeof(WCHAR)) == 0) {
            wcscpy(FuncNameW, L"<nosymbols");
        }
        lprintf( MSG_FUNCTION, FuncNameW );
#else
        lprintf( MSG_FUNCTION, FuncNameA );
#endif
        
        dp->DbgClient->SetOutputLinePrefix("        ");
        if ((Status = dp->DbgControl->
             OutputDisassemblyLines(DEBUG_OUTCTL_THIS_CLIENT, InstrWindow,
                                    InstrWindow, InstrOffs,
                                    DEBUG_DISASM_MATCHING_SYMBOLS,
                                    NULL, NULL, NULL, NULL)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        }

        // If this is the event thread output a message
        // indicating the faulting instruction.
        if (crash) {
            dp->DbgClient->SetOutputLinePrefix(NULL);
            lprintf( MSG_FAULT );
        }
        if ((Status = dp->DbgControl->
             OutputDisassembly(DEBUG_OUTCTL_THIS_CLIENT, InstrOffs,
                               DEBUG_DISASM_EFFECTIVE_ADDRESS |
                               DEBUG_DISASM_MATCHING_SYMBOLS,
                               &InstrOffs)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        }
        
        dp->DbgClient->SetOutputLinePrefix("        ");
        if ((Status = dp->DbgControl->
             OutputDisassemblyLines(DEBUG_OUTCTL_THIS_CLIENT, 0,
                                    InstrWindow, InstrOffs,
                                    DEBUG_DISASM_EFFECTIVE_ADDRESS |
                                    DEBUG_DISASM_MATCHING_SYMBOLS,
                                    NULL, NULL, NULL, NULL)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
        }
        
        dp->DbgClient->SetOutputLinePrefix(NULL);
    }
    lprintfs( _T("\r\n") );
                                   
    if (crash) {
#ifdef UNICODE
        wcscpy(crash->szFunction, FuncNameW);
#else
        strcpy(crash->szFunction, FuncNameA);
#endif
    }

    lprintf( MSG_STACKTRACE );
    if ((Status = dp->DbgControl->
         OutputStackTrace(DEBUG_OUTCTL_THIS_CLIENT, NULL, 100,
                          DEBUG_STACK_ARGUMENTS |
                          DEBUG_STACK_FUNCTION_INFO |
                          DEBUG_STACK_FRAME_ADDRESSES |
                          DEBUG_STACK_COLUMN_NAMES)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
    }
    lprintfs( _T("\r\n") );
    
    dp->DbgClient->SetOutputCallbacks(NULL);
    
    LogStackDump( dp );
}

void
LogAllThreadInformation(
    PDEBUGPACKET dp,
    PCRASHES crash
    )
{
    HRESULT Status;
    ULONG NumThreads;
    ULONG i;
    ULONG ThreadId;
    ULONG EventTid;

    if (!dp->options.fDumpAllThreads) {
        // Just log the current event thread's information.
        LogCurrentThreadInformation(dp, crash);
        return;
    }
    
    if ((Status = dp->DbgSystem->GetNumberThreads(&NumThreads)) != S_OK ||
        (Status = dp->DbgSystem->GetEventThread(&EventTid)) != S_OK) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }
    
    for (i = 0; i < NumThreads; i++) {
        if ((Status = dp->DbgSystem->
             GetThreadIdsByIndex(i, 1, &ThreadId, NULL)) != S_OK ||
            (Status = dp->DbgSystem->SetCurrentThreadId(ThreadId)) != S_OK) {
            lprintfs(_T("Error 0x%08X\r\n"), Status);
            continue;
        }

        LogCurrentThreadInformation(dp, ThreadId == EventTid ? crash : NULL);
    }

    dp->DbgSystem->SetCurrentThreadId(EventTid);
}

void
LogSymbols(
    PDEBUGPACKET dp
    )
{
    HRESULT Status;
    char ModName[64];
    char Buf[MAX_PATH];
    ULONG64 InstrOffs;
    ULONG64 ModBase;
    
    lprintf( MSG_SYMBOL_TABLE );
    
    if ((Status = dp->DbgRegisters->
         GetInstructionOffset(&InstrOffs)) != S_OK ||
        (Status = dp->DbgSymbols->
         GetModuleByOffset(InstrOffs, 0, NULL, &ModBase)) != S_OK ||
        FAILED(Status = dp->DbgSymbols->
               GetModuleNames(DEBUG_ANY_ID, ModBase,
                              Buf, sizeof(Buf), NULL,
                              ModName, sizeof(ModName), NULL,
                              NULL, 0, NULL))) {
        lprintfs(_T("Error 0x%08X\r\n"), Status);
        return;
    }
    
    lprintfs(_T("%hs\r\n\r\n"), Buf);
    sprintf(Buf, "x %s!*", ModName);
    dp->DbgClient->SetOutputCallbacks(&g_LogOutCb);
    dp->DbgControl->Execute(DEBUG_OUTCTL_THIS_CLIENT, Buf,
                          DEBUG_EXECUTE_DEFAULT);
    dp->DbgClient->SetOutputCallbacks(NULL);
}

void
PostMortemDump(
    PDEBUGPACKET dp,
    PDEBUG_LAST_EVENT_INFO_EXCEPTION Exception
    )
{
    _TCHAR            dbuf[MAX_PATH];
    _TCHAR            szDate[20];
    _TCHAR            szTime[20];
    CRASHES           crash = {0};
    DWORD             dwThreadId;
    HANDLE            hThread;
    char              ExeName[MAX_PATH];

    GetLocalTime( &crash.time );
    crash.dwExceptionCode = Exception->ExceptionRecord.ExceptionCode;
    crash.dwAddress = (DWORD_PTR)Exception->ExceptionRecord.ExceptionAddress;
        
    if (FAILED(dp->DbgSystem->
               GetCurrentProcessExecutableName(ExeName, sizeof(ExeName),
                                               NULL))) {
        strcpy(ExeName, "<unknown>");
    }
#ifdef UNICODE
    if (MultiByteToWideChar(CP_ACP, 0, ExeName, -1,
                            crash.szAppName,
                            sizeof(crash.szAppName) / sizeof(TCHAR)) == 0) {
        _tcscpy(crash.szAppName, _T("<unknown>"));
    }
#endif

    lprintf( MSG_APP_EXCEPTION );
    _stprintf( dbuf, _T("%d"), dp->dwPidToDebug );
    lprintf( MSG_APP_EXEP_NAME, crash.szAppName, dbuf );

    GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, &crash.time,
        NULL, szDate, sizeof(szDate) / sizeof(_TCHAR));

    _stprintf( szTime, _T("%02d:%02d:%02d.%03d"), crash.time.wHour,
                                     crash.time.wMinute,
                                     crash.time.wSecond,
                                     crash.time.wMilliseconds );
    lprintf( MSG_APP_EXEP_WHEN, szDate, szTime );
    _stprintf( dbuf, _T("%08lx"), Exception->ExceptionRecord.ExceptionCode );
    lprintf( MSG_EXCEPTION_NUMBER, dbuf );

    lprintfs( _T("(%s)\r\n\r\n"),
              GetExceptionText(Exception->ExceptionRecord.ExceptionCode) );

    LogSystemInformation( dp );

    LogTaskList( dp );

    LogModuleList( dp );

    LogAllThreadInformation(dp, &crash);

    if (dp->options.fDumpSymbols) {
        LogSymbols( dp );
    }

    ElSaveCrash( &crash, dp->options.dwMaxCrashes );

    dp->ExitStatus = Exception->ExceptionRecord.ExceptionCode;
    hThread = CreateThread( NULL,
                            16000,
                            (LPTHREAD_START_ROUTINE)TerminationThread,
                            dp,
                            0,
                            &dwThreadId
                          );

    WaitForSingleObject( hThread, 30000 );

    CloseHandle( hThread );

    return;
}

// Valid range: [1-7]
#define NUM_DIGITS_FNAME 2

void
CalcNextFileName(
    IN PTSTR            pszUserName,
    OUT PSTR            pszFileName,
    IN OUT PINT         pnCurrentValue,
    IN BOOL             bUseLongFileNames
    )
{
    TCHAR   szDrive[_MAX_DRIVE];
    TCHAR   szPath[_MAX_PATH];
    TCHAR   szFName[_MAX_FNAME];
    TCHAR   szExt[_MAX_EXT];
    int     nLargestPossibleNum;
    int     nCnt;

    Assert(pszUserName);
    Assert(pnCurrentValue);

    Assert(1 <= NUM_DIGITS_FNAME);
    Assert(NUM_DIGITS_FNAME <= 7);

    // Given the number of digits, this is the largest number +1
    // we can have. If we could raise int to an int, this would
    // be easy.
    // nLargestPossibleNum = 10^NUM_DIGITS_FNAME
    // We are intentionally over by one, the actual range is
    // [0, 10^NUM_DIGITS_FNAME-1]
    nLargestPossibleNum = 1;
    for (nCnt = 0; nCnt<NUM_DIGITS_FNAME; nCnt++) {
        nLargestPossibleNum *= 10;
    }

    _tsplitpath(pszUserName, szDrive, szPath, szFName, szExt);

    if (!bUseLongFileNames) {
        // Shorten the file name len to 6, so that we can
        // add the 2 digit sequence.
        // MSDOS FName len == 8
        szFName[8 - NUM_DIGITS_FNAME] = 0;
    }

    sprintf(pszFileName,
#ifdef UNICODE
            "%ls%ls%ls%0*d%ls",
#else
            "%s%s%s%0*d%s",
#endif
            szDrive,
            szPath,
            szFName,
            NUM_DIGITS_FNAME,
            *pnCurrentValue++,
            szExt
            );

    // Make sure we stay in the range [0, 10^NUM_DIGITS_FNAME]
    *pnCurrentValue = ++(*pnCurrentValue) % nLargestPossibleNum;
}

BOOL
CreateDumpFile(
    PDEBUGPACKET dp
    )

/*++

Routine Description:

    This function creates a crash dump file.

Arguments:

    dp              - debug packet for current process

Return Value:

    TRUE    - Crash dump was created
    FALSE   - Crash dump was NOT created

--*/

{
    PTSTR p;
    PCSTR Comment = "Dr. Watson generated MiniDump";
    ULONG Qual, Format = DEBUG_FORMAT_DEFAULT;
    HRESULT Status;
    char FileName[MAX_PATH];

    p = ExpandPath( dp->options.szCrashDump );
    if (!p) {
        return FALSE;
    }

    if (dp->options.fUseSequentialNaming) {
        // Figure out what the next file name should be.
        CalcNextFileName(p,
                         FileName,
                         &dp->options.nNextDumpSequence,
                         dp->options.fUseLongFileNames
                         );

        // Save the next value of nCurrent
        RegSave(&dp->options);
    } else {
#ifdef UNICODE
        if (WideCharToMultiByte(CP_ACP, 0, p, -1, FileName, sizeof(FileName),
                                NULL, NULL) == 0) {
            return FALSE;
        }
#else
        strcpy(FileName, p);
#endif
    }

    switch (dp->options.dwType) {
    case FullDump:
        Qual = DEBUG_USER_WINDOWS_DUMP;
        Comment = NULL;
	break;
    case FullMiniDump:
        Format = DEBUG_FORMAT_USER_SMALL_FULL_MEMORY |
            DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
        // Fall through.
    case MiniDump:
        Qual = DEBUG_USER_WINDOWS_SMALL_DUMP;
	break;
    default:
        return FALSE;
    }

    Status = dp->DbgClient->WriteDumpFile2(FileName, Qual, Format, Comment);
    
    free( p );
    return Status == S_OK;
}

DWORD
DispatchDebugEventThread(
    PDEBUGPACKET dp
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    None.

Return Value:

    None.

--*/

{
    _TCHAR        szLogFileName[1024];
    _TCHAR        buf[1024];
    PTSTR         p;


    if (dp->dwPidToDebug == 0) {
        goto exit;
    }

    CreateEngineInterfaces(dp);

    SetErrorMode( SEM_FAILCRITICALERRORS |
                  SEM_NOGPFAULTERRORBOX  |
                  SEM_NOOPENFILEERRORBOX   );

    AttachToActiveProcess( dp );

    p = ExpandPath(dp->options.szLogPath);

    if (p) {
        _tcscpy( szLogFileName, p );
        free( p );
    } else {
        _tcscpy( szLogFileName, dp->options.szLogPath );
    }

    MakeLogFileName( szLogFileName );
    OpenLogFile( szLogFileName,
                 dp->options.fAppendToLogFile,
                 dp->options.fVisual
               );

    for (;;) {

        ULONG Type, Process, Thread;
        DEBUG_LAST_EVENT_INFO_EXCEPTION LastEx;
        
        if (dp->DbgControl->
            WaitForEvent(DEBUG_WAIT_DEFAULT, 30000) != S_OK ||
            dp->DbgControl->
            GetLastEventInformation(&Type, &Process, &Thread,
                                    &LastEx, sizeof(LastEx), NULL,
                                    NULL, 0, NULL) != S_OK) {
            break;
        }

        switch (Type) {
        case DEBUG_EVENT_EXCEPTION:
            if (LastEx.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT) {
                //
                // If there is no event to signal, just use the first
                // breakpoint as the stop event.
                //
                if (dp->hEventToSignal && LastEx.FirstChance) {
                    //
                    // The aedebug event will be signalled AFTER this
                    // thread exits, so that it will disappear before
                    // the dump snapshot is taken.
                    //
                    dp->DbgControl->SetExecutionStatus(DEBUG_STATUS_GO_HANDLED);
                    break;
                }
            }
            if (dp->options.fVisual) {
                //
                // this notification is necessary because the shell must know when
                // the debugee has been attached.  if it doesn't know and the user is
                // allowed to terminate drwatson then the system may intervene with
                // a popup.
                //
                SendMessage( dp->hwnd, WM_ATTACHCOMPLETE, 0, 0 );
                _stprintf( buf,
                           LoadRcString( IDS_AE_TEXT ),
                           GetExceptionText(LastEx.ExceptionRecord.ExceptionCode),
                           LastEx.ExceptionRecord.ExceptionCode,
                           LastEx.ExceptionRecord.ExceptionAddress );
                SendMessage( dp->hwnd, WM_EXCEPTIONINFO, 0, (LPARAM) buf );
            }
            PostMortemDump( dp, &LastEx );
            if (dp->options.fCrash) {
                CreateDumpFile( dp );
            }
            dp->DbgControl->SetExecutionStatus(DEBUG_STATUS_GO_NOT_HANDLED);
            break;

        case DEBUG_EVENT_EXIT_THREAD:
            if ( dp->hEventToSignal ) {
                SetEvent(dp->hEventToSignal);
                dp->hEventToSignal = 0L;
            }
            dp->DbgControl->SetExecutionStatus(DEBUG_STATUS_GO);
            break;
        }
    }

exit:
    CloseLogFile();

    if (dp->options.fVisual) {
        SendMessage( dp->hwnd, WM_DUMPCOMPLETE, 0, 0 );
    }

    return 0;
}

DWORD
TerminationThread(
    PDEBUGPACKET dp
    )
{
    HANDLE hProcess;

    hProcess = OpenProcess( PROCESS_TERMINATE, FALSE, dp->dwPidToDebug );
    if (hProcess != NULL) {
        TerminateProcess( hProcess, dp->ExitStatus );
        CloseHandle( hProcess );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\log.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    log.cpp

Abstract:

    This file implements the access to the postmortem log file.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


#define BYTE_ORDER_MARK           0xFEFF
#define MAX_PRINTF_BUF_SIZE (1024 * 4)

enum LOG_TYPE {
    LT_ANSI,
    LT_UNICODE
};

//
// global variables for this module
//
static HANDLE  hFile = NULL;
static HANDLE  hLogProtect = NULL;
static DWORD   dwStartingPos = 0;
static WCHAR   wchBOM = BYTE_ORDER_MARK;
static DWORD   dwLogType = LT_ANSI;

void
WriteAnsiCharsToLogFile(
    WCHAR *pszUnicode,
    DWORD dwCharCount
    )
{
    char szAnsiBuf[MAX_PRINTF_BUF_SIZE] = {0};
    DWORD nCharTranslated;
    WCHAR szWcharBuf[MAX_PRINTF_BUF_SIZE] = {0};

    nCharTranslated = WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
        pszUnicode, dwCharCount,
        szAnsiBuf, sizeof(szAnsiBuf), NULL, NULL);

    WriteFile( hFile, szAnsiBuf, nCharTranslated, &nCharTranslated, NULL );
#if 0
    nCharTranslated = MultiByteToWideChar(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
                                          szAnsiBuf, nCharTranslated,
                                          szWcharBuf, sizeof(szWcharBuf)/sizeof(WCHAR));

    WriteFile( hFile, szWcharBuf, nCharTranslated, &nCharTranslated, NULL );
#endif
}

void
__cdecl
lprintf(
    DWORD dwFormatId,
    ...
    )

/*++

Routine Description:

    This is function is a printf style function for printing messages
    in a message file.

Arguments:

    dwFormatId    - format id in the message file

    ...           - var args

Return Value:

    None.

--*/

{
    _TCHAR       buf[MAX_PRINTF_BUF_SIZE] = {0};
    DWORD       dwCount;
    va_list     args;

    va_start( args, dwFormatId );

    dwCount = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE,
                NULL,
                dwFormatId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT), // Default language
                buf,
                sizeof(buf) / sizeof(_TCHAR),
                &args
                );

    va_end(args);

    Assert( dwCount != 0 );

#ifdef UNICODE
    // We currently want all of the output to be in ANSI
    if (dwLogType == LT_ANSI) {
        WriteAnsiCharsToLogFile(buf, dwCount);
    } else {
        WriteFile( hFile, buf, dwCount * sizeof(_TCHAR), &dwCount, NULL );
    }
#else
    WriteFile( hFile, buf, dwCount, &dwCount, NULL );
#endif

    return;
}

void
__cdecl
lprintfs(
    _TCHAR *format,
    ...
    )

/*++

Routine Description:

    This is function is a printf replacement that writes the output to
    the DrWatson log file.

Arguments:

    format        - print format

    ...           - var args

Return Value:

    None.

--*/

{
    _TCHAR   buf[MAX_PRINTF_BUF_SIZE] = {0};
    DWORD   cb;

    va_list arg_ptr;
    va_start(arg_ptr, format);
    cb = _vsntprintf(buf, sizeof(buf) / sizeof(_TCHAR), format, arg_ptr);
    va_end(arg_ptr);
    Assert( hFile != NULL );

#ifdef UNICODE
    // We currently want all of the output to be in ANSI
    if (dwLogType == LT_ANSI) {
        WriteAnsiCharsToLogFile(buf, cb);
    } else {
        WriteFile( hFile, buf, cb * sizeof(_TCHAR), &cb, NULL );
    }
#else
    WriteFile( hFile, buf, cb * sizeof(_TCHAR), &cb, NULL );
#endif
}

void
OpenLogFile(
    _TCHAR *szFileName,
    BOOL fAppend,
    BOOL fVisual
    )

/*++

Routine Description:

    Opens the DrWatson logfile for reading & writting.

Arguments:

    szFileName    - logfile name

    fAppend       - append the new data to the end of the file or
                    create a new file

    fVisual       - visual notification

Return Value:

    None.

--*/

{
    _TCHAR   szName[1024];
    SECURITY_ATTRIBUTES SecAttrib;
    SECURITY_DESCRIPTOR SecDescript;
    DWORD size;

    szName[0] = 0;
    GetAppName( szName, sizeof(szName) / sizeof(_TCHAR) );
    _tcscat( szName, _T("LogProtect") );

    hLogProtect = OpenSemaphore( SEMAPHORE_MODIFY_STATE | SYNCHRONIZE, FALSE, szName);
    if (hLogProtect == NULL) {
        hLogProtect = CreateSemaphore( NULL, 0, 1, szName );
        Assert( hLogProtect != NULL );
    }
    else {
        WaitForSingleObject( hLogProtect, INFINITE );
    }

openagain:

    // Create a DACL that allows all access to the directory
    SecAttrib.nLength=sizeof(SECURITY_ATTRIBUTES);
    SecAttrib.lpSecurityDescriptor=&SecDescript;
    SecAttrib.bInheritHandle=FALSE;

    InitializeSecurityDescriptor(&SecDescript, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SecDescript, TRUE, NULL, FALSE);


    hFile = CreateFile( szFileName,
                        GENERIC_WRITE | GENERIC_READ,
                        FILE_SHARE_READ,
                        &SecAttrib,
                        fAppend ? OPEN_EXISTING : CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                      );

    if (fAppend) {
        if (hFile == INVALID_HANDLE_VALUE) {
            //
            // file does not exist, so lets create a new file
            //
            hFile = CreateFile( szFileName,
                                GENERIC_WRITE | GENERIC_READ,
                                FILE_SHARE_READ,
                                &SecAttrib,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                              );
            if (hFile == INVALID_HANDLE_VALUE) {
                if (fVisual) {
                    NonFatalError( LoadRcString(IDS_INVALID_LOGFILE) );
                    _tgetcwd( szFileName, MAX_PATH );
                    if (!BrowseForDirectory(NULL, szFileName )) {
                        FatalError( GetLastError(),
                                    LoadRcString(IDS_CANT_OPEN_LOGFILE) );
                    }
                    MakeLogFileName( szFileName );
                    goto openagain;
                }
                else {
                    ExitProcess( 1 );
                }
            }

            //
            // write the file banner
            //
            dwLogType = LT_UNICODE;
            WriteFile( hFile, &wchBOM, sizeof(_TCHAR), &size, NULL );
            lprintfs( _T("\r\n") );
            lprintf( MSG_BANNER );
            lprintfs( _T("\r\n") );
        } else {
#ifdef UNICODE
            //
            // Check if the file is unicode or ANSI
            //
            WCHAR wchHdr = 0;

            dwLogType = LT_ANSI;
            SetFilePointer( hFile, 0, 0, FILE_BEGIN );
            if (ReadFile( hFile, &wchHdr, sizeof(TCHAR), &size, NULL )) {
                if (wchHdr == wchBOM) {
                    dwLogType = LT_UNICODE;
                }
            }
#endif
        }

        SetFilePointer( hFile, 0, 0, FILE_END );
        
        Assert( hFile != INVALID_HANDLE_VALUE );

    }
    else {
        
        Assert( hFile != INVALID_HANDLE_VALUE );

        if (hFile == INVALID_HANDLE_VALUE) {
            if (fVisual) {
                NonFatalError( LoadRcString(IDS_INVALID_LOGFILE) );
                _tgetcwd( szFileName, MAX_PATH );
                if (!BrowseForDirectory(NULL, szFileName )) {
                    FatalError( GetLastError(),
                                LoadRcString(IDS_CANT_OPEN_LOGFILE) );
                }
                MakeLogFileName( szFileName );
                goto openagain;
            }
            else {
                ExitProcess( 1 );
            }
        }
        
        //
        // write the file banner
        //
        WriteFile( hFile, &wchBOM, sizeof(_TCHAR), &size, NULL );
        dwLogType = LT_UNICODE;
        lprintfs( _T("\r\n") );
        lprintf( MSG_BANNER );
        lprintfs( _T("\r\n") );
    }

    dwStartingPos = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );

    return;
}

void
CloseLogFile(
    void
    )

/*++

Routine Description:

    Closes the DrWatson logfile & releases the semaphore that
    protects it.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CloseHandle( hFile );
    ReleaseSemaphore( hLogProtect, 1, NULL );
    CloseHandle( hLogProtect );
}

_TCHAR *
GetLogFileData(
    PDWORD pdwLogFileDataSize
    )

/*++

Routine Description:

    Reads in all of the logfile data that has been written since it was
    opened.  The data is placed into a buffer allocated by this function.
    The caller is responsible for freeing the memory.

Arguments:

    pdwLogFileDataSize     -  pointer to a dword that contains the size
                              in bytes of the data that is read.

Return Value:

    Valid character pointer to the logfile data

    NULL - could not read the data.

--*/

{
    DWORD   dwCurrPos;
    _TCHAR   *p;
    DWORD   size;


    dwCurrPos = SetFilePointer( hFile, 0, NULL, FILE_CURRENT );

    *pdwLogFileDataSize = 0;
    size = dwCurrPos - dwStartingPos;

    p = (_TCHAR *) calloc( size, sizeof(_TCHAR) );
    if (p == NULL) {
        return NULL;
    }

    SetFilePointer( hFile, dwStartingPos, NULL, FILE_BEGIN );

    if (!ReadFile( hFile, p, size, &size, NULL )) {
        free( p );
        p = NULL;
        size = 0;
    }

    SetFilePointer( hFile, dwCurrPos, NULL, FILE_BEGIN );

    *pdwLogFileDataSize = size;

    return p;
}

void
MakeLogFileName(
    _TCHAR *szName
    )

/*++

Routine Description:

    Concatenates the base logfile name on to the string passed in.

Arguments:

    szName                 -  buffer for the logfile name.

Return Value:

    None.

--*/

{
    _tcscat( szName, _T("\\drwtsn32.log") );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\eventlog.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    eventlog.cpp

Abstract:

    This file contains all functions that access the application event log.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


_TCHAR * AddString( _TCHAR *p, _TCHAR *s );
_TCHAR * AddNumber( _TCHAR *p, _TCHAR *f, DWORD dwNumber );
_TCHAR * AddAddr( _TCHAR *p, _TCHAR *f, ULONG_PTR dwNumber );
_TCHAR * GetADDR( ULONG_PTR *ppvData, _TCHAR *p );
_TCHAR * GetDWORD( PDWORD pdwData, _TCHAR *p );
_TCHAR * GetWORD( PWORD pwData, _TCHAR *p );
_TCHAR * GetString( _TCHAR *s, _TCHAR *p, DWORD size );


BOOL
ElClearAllEvents(
    void
    )
{
    HANDLE           hEventLog;
    _TCHAR            szAppName[MAX_PATH];


    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );
    hEventLog = OpenEventLog( NULL, szAppName );
    Assert( hEventLog != NULL );
    ClearEventLog( hEventLog, NULL );
    CloseEventLog( hEventLog );
    RegSetNumCrashes(0);

    return TRUE;
}

BOOL
ElEnumCrashes(
    PCRASHINFO crashInfo,
    CRASHESENUMPROC lpEnumFunc
    )
{
    _TCHAR            *p;
    HANDLE           hEventLog;
    _TCHAR            *szEvBuf;
    EVENTLOGRECORD   *pevlr;
    DWORD            dwRead;
    DWORD            dwNeeded;
    DWORD            dwBufSize = 4096 * sizeof(_TCHAR);
    BOOL             rc;
    BOOL             ec;
    _TCHAR            szAppName[MAX_PATH];


    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );
    hEventLog = OpenEventLog( NULL, szAppName );
    if (hEventLog == NULL) {
        return FALSE;
    }

    szEvBuf = (_TCHAR *) calloc( dwBufSize, sizeof(_TCHAR) );
    if (szEvBuf == NULL) {
        return FALSE;
    }

    while (TRUE) {
try_again:
        rc = ReadEventLog(hEventLog,
                        EVENTLOG_FORWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        (EVENTLOGRECORD *) szEvBuf,
                        dwBufSize,
                        &dwRead,
                        &dwNeeded);

        if (!rc) {
            ec = GetLastError();
            if (ec != ERROR_INSUFFICIENT_BUFFER) {
                goto exit;
            }

            free( szEvBuf );

            dwBufSize = dwNeeded + 1024;
            szEvBuf = (_TCHAR *) calloc( dwBufSize, sizeof(_TCHAR) );
            if (szEvBuf == NULL) {
                return FALSE;
            }

            goto try_again;
        }

        if (dwRead == 0) {
            break;
        }

        GetAppName( szAppName, sizeof(szAppName) );
        p = szEvBuf;

        do {

            pevlr = (EVENTLOGRECORD *) p;

            p = (PWSTR) ( (PBYTE)p + sizeof(EVENTLOGRECORD));

            if (!_tcscmp( p, szAppName)) {

                p = (PWSTR) ( (PBYTE)pevlr + pevlr->StringOffset );

                p = GetString( crashInfo->crash.szAppName,           p,
                    sizeof(crashInfo->crash.szAppName) / sizeof(crashInfo->crash.szAppName[0]) );
                p = GetWORD  ( &crashInfo->crash.time.wMonth,        p );
                p = GetWORD  ( &crashInfo->crash.time.wDay,          p );
                p = GetWORD  ( &crashInfo->crash.time.wYear,         p );
                p = GetWORD  ( &crashInfo->crash.time.wHour,         p );
                p = GetWORD  ( &crashInfo->crash.time.wMinute,       p );
                p = GetWORD  ( &crashInfo->crash.time.wSecond,       p );
                p = GetWORD  ( &crashInfo->crash.time.wMilliseconds, p );
                p = GetDWORD ( &crashInfo->crash.dwExceptionCode,    p );
                p = GetADDR  ( &crashInfo->crash.dwAddress,          p );
                p = GetString( crashInfo->crash.szFunction,          p,
                    sizeof(crashInfo->crash.szFunction) / sizeof(crashInfo->crash.szFunction[0]) );

                p = (_TCHAR *) (pevlr + 1);

                crashInfo->dwCrashDataSize = pevlr->DataLength;
                crashInfo->pCrashData = (PBYTE) ((DWORD_PTR)pevlr + pevlr->DataOffset);

                if (!lpEnumFunc( crashInfo )) {
                    goto exit;
                }
            }

            //
            // update the pointer & read count
            //
            if (dwRead <= pevlr->Length) {
                // Set it to 0 so that we don't wrap around
                dwRead = 0;
            } else {
                dwRead -= pevlr->Length;
            }

            p = (_TCHAR *) ((DWORD_PTR)pevlr + pevlr->Length);

        } while ( dwRead > 0 );
    }

exit:
    free( szEvBuf );
    CloseEventLog( hEventLog );
    return TRUE;
}

BOOL
ElSaveCrash(
    PCRASHES crash,
    DWORD dwMaxCrashes
    )
{
    _TCHAR   szStrings[4096] = {0};
    PTSTR   p = szStrings;
    HANDLE  hEventSrc;
    PTSTR   pp[20] = {0};
    _TCHAR  *pLogFileData;
    DWORD   dwLogFileDataSize;
    _TCHAR  szAppName[MAX_PATH];


    if (dwMaxCrashes > 0) {
        if (RegGetNumCrashes() >= dwMaxCrashes) {
            return FALSE;
        }
    }

    RegSetNumCrashes( RegGetNumCrashes()+1 );

    p = AddString( pp[0]  = p,              crash->szAppName           );
    p = AddNumber( pp[1]  = p, _T("%02d"),  crash->time.wMonth         );
    p = AddNumber( pp[2]  = p, _T("%02d"),  crash->time.wDay           );
    p = AddNumber( pp[3]  = p, _T("%4d"),   crash->time.wYear          );
    p = AddNumber( pp[4]  = p, _T("%02d"),  crash->time.wHour          );
    p = AddNumber( pp[5]  = p, _T("%02d"),  crash->time.wMinute        );
    p = AddNumber( pp[6]  = p, _T("%02d"),  crash->time.wSecond        );
    p = AddNumber( pp[7]  = p, _T("%03d"),  crash->time.wMilliseconds  );
    p = AddNumber( pp[8]  = p, _T("%08x"),  crash->dwExceptionCode     );
    p = AddAddr  ( pp[9]  = p, _T("%p"),    crash->dwAddress           );
    p = AddString( pp[10] = p,              crash->szFunction          );

    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );

    hEventSrc = RegisterEventSource( NULL, szAppName );

    if (hEventSrc == NULL) {
        return FALSE;
    }

    pLogFileData = GetLogFileData( &dwLogFileDataSize );

    ReportEvent( hEventSrc,
                 EVENTLOG_INFORMATION_TYPE,
                 0,
                 MSG_CRASH,
                 NULL,
                 11,
                 dwLogFileDataSize,
                 (PCTSTR*)pp,
                 pLogFileData
               );

    DeregisterEventSource( hEventSrc );

    free( pLogFileData );

    return TRUE;
}

_TCHAR *
AddString(
    _TCHAR *p,
    _TCHAR *s
    )
{
    _tcscpy( p, s );
    p += (_tcslen(s) + 1);
    return p;
}

_TCHAR *
AddNumber(
    _TCHAR *p,
    _TCHAR *f,
    DWORD dwNumber
    )
{
    _TCHAR buf[20];
    _stprintf( buf, f, dwNumber );
    return AddString( p, buf );
}

_TCHAR *
AddAddr(
    _TCHAR *p,
    _TCHAR *f,
    DWORD_PTR dwNumber
    )
{
    _TCHAR buf[20];
    _stprintf( buf, f, dwNumber );
    return AddString( p, buf );
}

_TCHAR *
GetString(
    _TCHAR *s,
    _TCHAR *p,
    DWORD size
    )
{
    _tcsncpy( s, p, size );
    return p + _tcslen(p) + 1;
}

_TCHAR *
GetDWORD(
    PDWORD pdwData,
    _TCHAR *p
    )
{
    _stscanf( p, _T("%x"), pdwData );
    return p + _tcslen(p) + 1;
}

_TCHAR *
GetADDR(
    ULONG_PTR *pAddrData,
    _TCHAR *p
    )
{
    _stscanf( p, _T("%p"), pAddrData );
    return p + _tcslen(p) + 1;
}



_TCHAR *
GetWORD(
    PWORD pwData,
    _TCHAR *p
    )
{
    *pwData = (WORD)_ttoi( p );
    return p + _tcslen(p) + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\error.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    error.cpp

Abstract:

    This file implements the error handeling functions for the
    entire DRWTSN32 application.  This includes error popups,
    debug prints, and assertions.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


void
__cdecl
FatalError(
    HRESULT Error,
    _TCHAR * pszFormat,
    ...
    )

/*++

Routine Description:

    This function is called when there is nothing else to do, hence
    the name FatalError.  It puts up a popup and then terminates.

Arguments:

    Same as printf.

Return Value:

    None.

--*/

{
    PTSTR        pszErrMsg = NULL;
    PTSTR        pszInternalMsgFormat = NULL;
    _TCHAR       szArgumentsBuffer[1024 * 2] = {0};
    _TCHAR       szMsg[1024 * 8] = {0};
    DWORD       dwCount;
    va_list     arg_ptr;

    va_start(arg_ptr, pszFormat);
    _vsntprintf(szArgumentsBuffer, sizeof(szArgumentsBuffer) / sizeof(_TCHAR), pszFormat, arg_ptr);
    va_end(arg_ptr);

    dwCount = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        Error,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (PTSTR) &pszErrMsg,
        0,
        NULL
        );

    _sntprintf(szMsg, sizeof(szMsg) / sizeof(_TCHAR), LoadRcString(IDS_ERROR_FORMAT_STRING),
        szArgumentsBuffer, Error);

    if (dwCount) {
        if ( (_tcslen(szMsg) + _tcslen(pszErrMsg) +1) * sizeof(_TCHAR) < sizeof(szMsg)) {
            _tcscat(szMsg, pszErrMsg);
        }
    }

    MessageBox(NULL, szMsg, LoadRcString(IDS_FATAL_ERROR), MB_TASKMODAL | MB_SETFOREGROUND | MB_OK);

    if (pszErrMsg) {
        LocalFree(pszErrMsg);
    }

    ExitProcess(0);
}

void
__cdecl
NonFatalError(
    PTSTR pszFormat,
    ...
    )

/*++

Routine Description:

    This function is used to generate a popup with some kind of
    warning message inside.

Arguments:

    Same as printf.

Return Value:

    None.

--*/

{
    PTSTR        pszErrMsg = NULL;
    PTSTR        pszInternalMsgFormat = NULL;
    _TCHAR       szArgumentsBuffer[1024 * 2] = {0};
    _TCHAR       szMsg[1024 * 8] = {0};
    DWORD       dwCount;
    va_list     arg_ptr;
    DWORD       dwError;

    dwError = GetLastError();

    va_start(arg_ptr, pszFormat);
    _vsntprintf(szArgumentsBuffer, sizeof(szArgumentsBuffer) / sizeof(_TCHAR), pszFormat, arg_ptr);
    va_end(arg_ptr);

    if (ERROR_SUCCESS == dwError) {
        // Don't bother getting an error message
        _tcscpy(szMsg, szArgumentsBuffer);
    } else {
        // We have a real error
        dwCount = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (PTSTR) &pszErrMsg,
            0,
            NULL
            );

        _sntprintf(szMsg, sizeof(szMsg) / sizeof(_TCHAR), LoadRcString(IDS_ERROR_FORMAT_STRING),
            szArgumentsBuffer, dwError);

        if (dwCount) {
            if ( (_tcslen(szMsg) + _tcslen(pszErrMsg) +1) * sizeof(_TCHAR) < sizeof(szMsg)) {
                _tcscat(szMsg, pszErrMsg);
            }
        }
    }

    MessageBox(NULL, szMsg, LoadRcString(IDS_NONFATAL_ERROR),
        MB_TASKMODAL | MB_SETFOREGROUND | MB_OK);

    if (pszErrMsg) {
        LocalFree(pszErrMsg);
    }
}

void
__cdecl
dprintf(
    _TCHAR *format,
    ...
    )

/*++

Routine Description:

    This function is a var-args version of OutputDebugString.

Arguments:

    Same as printf.

Return Value:

    None.

--*/

{
    _TCHAR    buf[1024];

    va_list arg_ptr;
    va_start(arg_ptr, format);
    _vsntprintf(buf, sizeof(buf) / sizeof(_TCHAR), format, arg_ptr);
    va_end(arg_ptr);
    OutputDebugString( buf );
    return;
}


void
AssertError(
    PTSTR    pszExpression,
    PTSTR    pszFile,
    DWORD   dwLineNumber
    )
/*++
Routine Description:
    Display an assertion failure message box which gives the user a choice
    as to whether the process should be aborted, the assertion ignored or
    a break exception generated.

Arguments:

    Expression  - Supplies a string representation of the failed assertion.

    File        - Supplies a pointer to the file name where the assertion
                  failed.

    LineNumber  - Supplies the line number in the file where the assertion
                  failed.

Return Value:

    None.

--*/
{
    int         nResponse;
    _TCHAR       szModuleBuffer[ MAX_PATH ];
    DWORD       dwLength;
    _TCHAR       szBuffer[ 4096 ];
    DWORD       dwError;
    LPTSTR      lpszMsgBuf = NULL;

    dwError = GetLastError();

    //
    // Get the last error string
    //
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |  FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpszMsgBuf,
        0,
        NULL);

    //
    // Get the asserting module's file name.
    //
    dwLength = GetModuleFileName( NULL, szModuleBuffer, sizeof(szModuleBuffer) / sizeof(_TCHAR));

    _sntprintf(szBuffer, sizeof(szBuffer) / sizeof(_TCHAR),
        _T("Assertion Failed : <%s> in file %s at line %u\n\nModule Name: %s\nLast system error: %u\n%s"),
        pszExpression, pszFile, dwLineNumber, szModuleBuffer, dwError, lpszMsgBuf);

    LocalFree( lpszMsgBuf );

    nResponse = MessageBox(NULL, szBuffer, _T("DrWatson Assertion"),
        MB_TASKMODAL | MB_ABORTRETRYIGNORE | MB_ICONERROR | MB_TASKMODAL);

    switch( nResponse ) {
    case IDABORT:
        //
        // Terminate the process.
        //
        ExitProcess( (UINT) -1 );
        break;

    case IDIGNORE:
        //
        // Ignore the failed assertion.
        //
        break;

    case IDRETRY:
        //
        // Break into a debugger.
        //
        DebugBreak();
        break;

    default:
        //
        // Break into a debugger because of a catastrophic failure.
        //
        DebugBreak( );
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\notify.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    notify.cpp

Abstract:
    This file implements the functions that make use of the common
    file open dialogs for browsing for files/directories.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


//
// defines
//
#define DEFAULT_WAIT_TIME   (1000 * 60 * 5)     // wait for 5 minutes
#define MAX_PRINTF_BUF_SIZE (1024 * 4)

HANDLE         hThreadDebug = 0;
PDEBUGPACKET   dp;


INT_PTR
CALLBACK
NotifyDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
UsageDialogProc (
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


void
NotifyWinMain (
    void
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    None.

Return Value:

    None.

--*/

{
    MSG            msg;
    DWORD          dwThreadId;
    HINSTANCE      hInst;


    dp = (PDEBUGPACKET) calloc( sizeof(DEBUGPACKET), sizeof(BYTE) );
    if ( dp == NULL) {
        return;
    }
    GetCommandLineArgs( &dp->dwPidToDebug, &dp->hEventToSignal );

    RegInitialize( &dp->options );

    if (dp->options.fVisual) {
        WNDCLASS wndclass;
        
        hInst                   = GetModuleHandle( NULL );
        wndclass.style          = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc    = (WNDPROC)NotifyDialogProc;
        wndclass.cbClsExtra     = 0;
        wndclass.cbWndExtra     = DLGWINDOWEXTRA;
        wndclass.hInstance      = hInst;
        wndclass.hIcon          = LoadIcon( hInst, MAKEINTRESOURCE(APPICON) );
        wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
        wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1);
        wndclass.lpszMenuName   = NULL;
        wndclass.lpszClassName  = _T("NotifyDialog");
        RegisterClass( &wndclass );

        dp->hwnd = CreateDialog( hInst,
                                 MAKEINTRESOURCE( NOTIFYDIALOG ),
                                 0,
                                 NotifyDialogProc );
	if (dp->hwnd == NULL) {
	    return;
	}
    }

    hThreadDebug = CreateThread( NULL,
                            16000,
                            (LPTHREAD_START_ROUTINE)DispatchDebugEventThread,
                            dp,
                            0,
                            &dwThreadId
                          );

    if (hThreadDebug == NULL) {
	return;
    }

    if (dp->options.fSound) {
        if ((waveOutGetNumDevs() == 0) || (!_tcslen(dp->options.szWaveFile))) {
            MessageBeep( MB_ICONHAND );
            MessageBeep( MB_ICONHAND );
        }
        else {
            PlaySound( dp->options.szWaveFile, NULL, SND_FILENAME );
        }
    }

    if (dp->options.fVisual) {
        ShowWindow( dp->hwnd, SW_SHOWNORMAL );
        while (GetMessage (&msg, NULL, 0, 0)) {
            if (!IsDialogMessage( dp->hwnd, &msg )) {
                TranslateMessage (&msg) ;
                DispatchMessage (&msg) ;
            }
        }
    }
    else {
        WaitForSingleObject( hThreadDebug, INFINITE );
    }

    CloseHandle( hThreadDebug );

    return;
}

INT_PTR
CALLBACK
NotifyDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the DRWTSN32.EXE popup.  This is the popup
    that is displayed when an application error occurs.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    DWORD          dwThreadId;
    DWORD          dwSize;
    HANDLE         hThread;
    _TCHAR         szTaskName[MAX_PATH];
    _TCHAR         szHelpFileName[MAX_PATH];

    static DWORD   AttachComplete=FALSE;
    static DWORD   Cancel=FALSE;

    _TCHAR         buf[MAX_PRINTF_BUF_SIZE];


    switch (message) {
        case WM_CREATE:
            return FALSE;

        case WM_INITDIALOG:

            SubclassControls( hwnd );

            //
            // OK is hidden until the debugger thread finishes
            //
            ShowWindow( GetDlgItem( hwnd, IDOK ), SW_HIDE );

            //
            // CANCEL is enabled right away
            //
            EnableWindow( GetDlgItem( hwnd, IDCANCEL ), TRUE );

            //
            //  make sure that the user can see the dialog box
            //
            SetForegroundWindow( hwnd );

            //
            // get the task name and display it on the dialog box
            //
            dwSize = sizeof(szTaskName) / sizeof(_TCHAR);
            GetTaskName( dp->dwPidToDebug, szTaskName, &dwSize );

            //
            // prevent recursion in the case where drwatson faults
            //
            if (_tcsicmp(szTaskName, _T("drwtsn32")) == 0) {
                ExitProcess(0);
            }


            //
            // Add the text in the dialog box
            //
            memset(buf,0,sizeof(buf));
            GetNotifyBuf( buf, MAX_PRINTF_BUF_SIZE, MSG_NOTIFY, szTaskName );
            SetDlgItemText( hwnd, ID_TEXT1, buf);

            memset(buf,0,sizeof(buf));
            GetNotifyBuf( buf, MAX_PRINTF_BUF_SIZE, MSG_NOTIFY2 );
            SetDlgItemText( hwnd, ID_TEXT2, buf );

            return TRUE;

        case WM_ACTIVATEAPP:
        case WM_SETFOCUS:
            SetFocusToCurrentControl();
            return 0;

        case WM_TIMER:
            SendMessage( hwnd, WM_COMMAND, IDOK, 0 );
            return 0;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    SendMessage( hwnd, WM_DESTROY, 0, 0 );
                    break;

                case IDCANCEL:
                    Cancel = TRUE;

                    // Make the window go away, but don't kill the
                    // the process until the WM_ATTACHCOMPLETE has
                    // occurred
                    ShowWindow( hwnd, SW_HIDE );
                    SendMessage( hwnd, WM_FINISH, 0, 0 );
                    
		    // Delete the dump file, since its invalid anyway
		    DeleteCrashDump();
		    break;
            }
            break;

        case WM_NEXTDLGCTL:
            DefDlgProc( hwnd, message, wParam, lParam );
            return 0;

        case WM_DUMPCOMPLETE:

            //
            // the message is received from the debugger thread
            // when the postmortem dump is finished.  all we need to do
            // is enable the OK button and wait for the user to press the
            // OK button or for the timer to expire.  in either case
            // DrWatson will terminate.
            //

            // Disable and hide the Cancel button
            EnableWindow( GetDlgItem( hwnd, IDCANCEL ), FALSE);
            ShowWindow( GetDlgItem(hwnd, IDCANCEL ), SW_HIDE);

            // Show and Enable the OK button
            ShowWindow( GetDlgItem( hwnd, IDOK ), SW_SHOW);
            EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE );
            SetFocus( GetDlgItem(hwnd, IDOK) );
            SetFocusToCurrentControl();

            SetTimer( hwnd, 1, DEFAULT_WAIT_TIME, NULL );
            return 0;

        case WM_ATTACHCOMPLETE:
            //
            // the message is received from the debugger thread when
            // the debugactiveprocess() is completed.
            //

            AttachComplete = TRUE;
            SendMessage( hwnd, WM_FINISH, 0, 0 );
            return 0;

        case WM_FINISH:
            if (AttachComplete && Cancel) {

                //
                // terminate the debugger thread
                //
                if ( hThreadDebug ) TerminateThread( hThreadDebug, 0 );

                //
                // create a thread to terminate the debuggee
                // this is necessary if cancel is pressed before the
                // debugger thread finishes the postmortem dump
                //
                hThread = CreateThread( NULL,
                          16000,
                          (LPTHREAD_START_ROUTINE)TerminationThread,
                          dp,
                          0,
                          &dwThreadId
                        );

                //
                // wait for the termination thread to kill the debuggee
                //
                WaitForSingleObject( hThread, 30000 );

                CloseHandle( hThread );

                //
                // now post a quit message so that DrWatson will go away
                //
                SendMessage( hwnd, WM_DESTROY, 0, 0 );
            }
            return 0;

        case WM_EXCEPTIONINFO:

            return 0;

        case WM_DESTROY:
            KillTimer( hwnd, 1 );
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}

BOOLEAN
GetCommandLineArgs(
    LPDWORD dwPidToDebug,
    LPHANDLE hEventToSignal
    )

/*++

Routine Description:

    Parses the command line for the 3 possible command lines
    arguments:

         -p %ld        process id
         -e %ld        event id
         -g            go

Arguments:

    dwPidToDebug - Returns the process id of the process to debug

    hEventToSignal - Returns the handle to an event which will be signalled
        when the attach is complete.

Return Value:

    None.

--*/

{
    _TCHAR      *lpstrCmd = GetCommandLine();
    _TUCHAR       ch;
    _TCHAR      buf[4096];
    BOOLEAN     rval = FALSE;

    // skip over program name
    do {
        ch = *lpstrCmd++;
    }
    while (ch != _T(' ') && ch != _T('\t') && ch != _T('\0'));

    //  skip over any following white space
    while (ch == _T(' ') || ch == _T('\t')) {
        ch = *lpstrCmd++;
    }

    //  process each switch character _T('-') as encountered

    while (ch == _T('-')) {
        ch = *lpstrCmd++;
        //  process multiple switch characters as needed
        do {
            switch (ch) {
                case _T('e'):
                case _T('E'):
                    // event to signal takes decimal argument
                    // skip whitespace
                    do {
                        ch = *lpstrCmd++;
                    }
                    while (ch == _T(' ') || ch == _T('\t'));
                    while (ch >= _T('0') && ch <= _T('9')) {
                        *hEventToSignal = (HANDLE)((DWORD_PTR)*hEventToSignal * 10 + ch - _T('0'));
                        ch = *lpstrCmd++;
                    }
                    rval = TRUE;
                    break;

                case _T('p'):
                case _T('P'):
                    // pid debug takes decimal argument

                    do
                        ch = *lpstrCmd++;
                    while (ch == _T(' ') || ch == _T('\t'));

                    if ( ch == _T('-') ) {
                        ch = *lpstrCmd++;
                        if ( ch == _T('1') ) {
                            *dwPidToDebug = (DWORD)-1;
                            ch = *lpstrCmd++;
                        }
                    }
                    else {
                        while (ch >= _T('0') && ch <= _T('9')) {
                            *dwPidToDebug = *dwPidToDebug * 10 + ch - _T('0');
                            ch = *lpstrCmd++;
                        }
                    }
                    rval = TRUE;
                    break;

                case _T('g'):
                case _T('G'):
                    // GO
                    // Ignored but provided for compatiblity with windbg & ntsd
                    ch = *lpstrCmd++;
                    break;

                case _T('?'):
                    DialogBox( GetModuleHandle(NULL),
                               MAKEINTRESOURCE(USAGEDIALOG),
                               NULL,
                               UsageDialogProc
                             );
                    rval = TRUE;
                    ch = *lpstrCmd++;
                    break;

                case _T('i'):
                case _T('I'):
                    FormatMessage(
                      FORMAT_MESSAGE_FROM_HMODULE,
                      NULL,
                      MSG_INSTALL_NOTIFY,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                      buf,
                      sizeof(buf) / sizeof(_TCHAR),
                      NULL
                      );
                    RegInstallDrWatson( tolower(lpstrCmd[0]) == _T('q') );
                    MessageBox( NULL,
                                buf,
                                _T("Dr. Watson"),
                                MB_ICONINFORMATION | MB_OK |
                                MB_SETFOREGROUND );
                    rval = TRUE;
                    ch = *lpstrCmd++;
                    break;

                default:
                    return rval;
            }
        } while (ch != _T(' ') && ch != _T('\t') && ch != _T('\0'));

        while (ch == _T(' ') || ch == _T('\t')) {
            ch = *lpstrCmd++;
        }
    }
    return rval;
}

INT_PTR
CALLBACK
UsageDialogProc (
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    This is the dialog procedure for the assert dialog box.  Normally
    an assertion box is simply a message box but in this case a Help
    button is desired so a dialog box is used.

Arguments:

    hDlg       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    _TCHAR        buf[4096];

    switch (message) {
        case WM_INITDIALOG:
            FormatMessage(
              FORMAT_MESSAGE_FROM_HMODULE,
              NULL,
              MSG_USAGE,
              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
              buf,
              sizeof(buf) / sizeof(_TCHAR),
              NULL
              );
            SetDlgItemText( hDlg, ID_USAGE, buf );
            break;

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    EndDialog( hDlg, 0 );
                    break;
            }
            break;
    }

    return FALSE;
}


void
__cdecl
GetNotifyBuf(
    LPTSTR buf,
    DWORD bufsize,
    DWORD dwFormatId,
    ...
    )

/*++

Routine Description:

    This is function is a printf style function for printing messages
    in a message file.

Arguments:

    dwFormatId    - format id in the message file

    ...           - var args

Return Value:

    None.

--*/

{
    DWORD       dwCount;
    va_list     args;

    va_start( args, dwFormatId );

    dwCount = FormatMessage(
                FORMAT_MESSAGE_FROM_HMODULE,
                NULL,
                dwFormatId,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //Default language
                buf,
                bufsize,
                &args
                );

    va_end(args);

    Assert( dwCount != 0 );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\pch.cpp ===
//----------------------------------------------------------------------------
//
// Precompiled header.
//
// Copyright (C) Microsoft Corporation, 1999-2001.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <tchar.h>

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <direct.h>
#include <htmlhelp.h>

#include <dbghelp.h>
#include <dbgeng.h>

#include <dhhelp.h>
#include <cmnutil.hpp>

#include "drwatson.h"
#include "messages.h"
#include "proto.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\proto.h ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Prototypes for drwatson.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

// error.cpp
void __cdecl NonFatalError(_TCHAR *format, ...);
void __cdecl FatalError(HRESULT Error, _TCHAR *format, ...);
void AssertError( _TCHAR *exp, _TCHAR * file, DWORD line );
void __cdecl dprintf(_TCHAR *format, ...);

// log.cpp
void OpenLogFile( _TCHAR *szFileName, BOOL fAppend, BOOL fVisual );
void CloseLogFile( void );
void __cdecl lprintfs(_TCHAR *format, ...);
void __cdecl lprintf(DWORD dwFormatId, ...);
void MakeLogFileName( _TCHAR *szName );
_TCHAR * GetLogFileData( LPDWORD dwLogFileDataSize );

// debug.cpp
DWORD DispatchDebugEventThread( PDEBUGPACKET dp );
DWORD TerminationThread( PDEBUGPACKET dp );

// registry.cpp
BOOL RegInitialize( POPTIONS o );
BOOL RegSave( POPTIONS o );
DWORD RegGetNumCrashes( void );
void RegSetNumCrashes( DWORD dwNumCrashes );
void RegLogCurrentVersion( void );
BOOLEAN RegInstallDrWatson( BOOL fQuiet );
void RegLogProcessorType( void );
void DeleteCrashDump();

// eventlog.cpp
BOOL ElSaveCrash( PCRASHES crash, DWORD dwNumCrashes );
BOOL ElEnumCrashes( PCRASHINFO crashInfo, CRASHESENUMPROC lpEnumFunc );
BOOL ElClearAllEvents( void );

// process.cpp
void GetTaskName( ULONG pid, _TCHAR *szTaskName, LPDWORD pdwSize );

// browse.cpp
BOOL BrowseForDirectory(HWND hwnd, _TCHAR *szCurrDir );
BOOL GetWaveFileName(HWND hwnd, _TCHAR *szWaveName );
BOOL GetDumpFileName(HWND hwnd, _TCHAR *szDumpName );

// notify.cpp
void NotifyWinMain ( void );
BOOLEAN GetCommandLineArgs( LPDWORD dwPidToDebug, LPHANDLE hEventToSignal );
void __cdecl GetNotifyBuf( LPTSTR buf, DWORD bufsize, DWORD dwFormatId, ...);

// ui.cpp
void DrWatsonWinMain ( void );

// util.cpp
void GetAppName( _TCHAR *pszAppName, DWORD len );
void GetWinHelpFileName( _TCHAR *pszHelpFileName, DWORD len );
void GetHtmlHelpFileName( _TCHAR *pszHelpFileName, DWORD len );
_TCHAR * LoadRcString( UINT wId );
PTSTR ExpandPath(PTSTR lpPath);

// controls.cpp
BOOL SubclassControls( HWND hwnd );
void SetFocusToCurrentControl( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\process.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    process.cpp

Abstract:

    This code provides access to the task list.

Author:

    Wesley Witt (wesw) 16-June-1993

Environment:

    User Mode

--*/

#include "pch.cpp"

#include <winperf.h>


//
// task list structure returned from GetTaskList()
//
typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    _TCHAR      ProcessName[MAX_PATH];
} TASK_LIST, *PTASK_LIST;


//
// defines
//
#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         _T("software\\microsoft\\windows nt\\currentversion\\perflib")
#define REGSUBKEY_COUNTERS  _T("Counters")
#define PROCESS_COUNTER     _T("process")
#define PROCESSID_COUNTER   _T("id process")
#define UNKNOWN_TASK        _T("unknown")


//
// prototypes
//
PTASK_LIST
GetTaskList(
    LPLONG pNumTasks
    );


void
GetTaskName(
    ULONG pid,
    _TCHAR *szTaskName,
    LPDWORD pdwSize
    )

/*++

Routine Description:

    Gets the task name for a given process id.

Arguments:

    pid              - Process id to look for.

    szTaskName       - Buffer to put the task name into.

    lpdwSize         - Pointer to a dword.  On entry it contains the
                       size of the szTaskName buffer in characters.
                       On exit it contains the number of characters
                       in the buffer.

Return Value:

    None.

--*/

{
    PTASK_LIST   pTask;
    PTASK_LIST   pTaskBegin;
    LONG         NumTasks;


    pTask = pTaskBegin = GetTaskList( &NumTasks );

    if (pTask == NULL) {
        if (szTaskName) {
            _tcsncpy( szTaskName, _T("unknown"), *pdwSize );
            szTaskName[(*pdwSize) -1] = 0;
        }
        *pdwSize = min( 7, *pdwSize );

    } else {

        while (NumTasks--) {
            if (pTask->dwProcessId == pid) {
                if (szTaskName) {
                    _tcsncpy( szTaskName, pTask->ProcessName, *pdwSize );
                    szTaskName[(*pdwSize) -1] = 0;
                }
                *pdwSize = min( _tcslen(pTask->ProcessName), *pdwSize );
                break;
            }
            pTask++;
        }

        if (NumTasks < 0) {
            if (szTaskName) {
                _tcsncpy( szTaskName, LoadRcString(IDS_APP_ALREADY_EXITED), *pdwSize );
                szTaskName[(*pdwSize) -1] = 0;
            }
            *pdwSize = min( 8, *pdwSize );
        }

        free( pTaskBegin );
    }
}

PTASK_LIST
GetTaskList(
    LPLONG pNumTasks
    )

/*++

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses the registry performance data to get the
    task list and is therefor straight WIN32 calls that anyone can call.

Arguments:

    pNumTasks      - pointer to a dword that will be set to the
                       number of tasks returned.

Return Value:

    PTASK_LIST       - pointer to an array of TASK_LIST records.

--*/

{
    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    DWORD                        dwSizeOffered;
    PTSTR                        buf = NULL;
    _TCHAR                       szSubKey[1024];
    LANGID                       lid;
    PTSTR                        p;
    PTSTR                        p2;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    PTASK_LIST                   pTask;
    PTASK_LIST                   pTaskReturn = NULL;
#ifndef UNICODE
    _TCHAR                       szProcessName[MAX_PATH];
#endif

    //
    // set the number of tasks to zero until we get some
    //
    *pNumTasks = 0;

    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    _stprintf( szSubKey, _T("%s\\%03x"), REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (PTSTR) calloc( dwSize, sizeof(BYTE) );
    if (buf == NULL) {
        goto exit;
    }

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          (PBYTE) buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //

    p = buf;
    while (*p) {
        if (_tcsicmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for ( p2=p-2; isdigit(*p2); p2--) {
                ;
            }
            _tcscpy( szSubKey, p2+1 );
        }
        else
        if (_tcsicmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) {
                ;
            }
            dwProcessIdTitle = _ttol( p2+1 );
        }
        //
        // next string
        //
        p += (_tcslen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    free( buf );


    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = (PTSTR) calloc( dwSize, sizeof(BYTE) );
    if (buf == NULL) {
        goto exit;
    }


    while (TRUE) {

        dwSizeOffered = dwSize;

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              (PBYTE) buf,
                              &dwSizeOffered
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)_T('P') &&
            (pPerf)->Signature[1] == (WCHAR)_T('E') &&
            (pPerf)->Signature[2] == (WCHAR)_T('R') &&
            (pPerf)->Signature[3] == (WCHAR)_T('F') ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            dwSize += EXTEND_SIZE;
            buf = (PTSTR) realloc( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD_PTR)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD_PTR)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    //
    // allocate a buffer for the returned task list
    //
    dwSize = pObj->NumInstances * sizeof(TASK_LIST);
    pTask = pTaskReturn = (PTASK_LIST) calloc( dwSize, sizeof(BYTE) );
    if (pTask == NULL) {
        goto exit;
    }

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //
    *pNumTasks = pObj->NumInstances;
    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pObj + pObj->DefinitionLength);
    for (i=0; i<(DWORD)pObj->NumInstances; i++) {
        //
        // pointer to the process name
        //
        p = (PTSTR) ((DWORD_PTR)pInst + pInst->NameOffset);

#ifdef UNICODE
        if (*p) {
            Assert( (_tcslen(p)+4) * sizeof(_TCHAR) < sizeof(pTask->ProcessName));

            _tcscpy( pTask->ProcessName, p );
            _tcscat( pTask->ProcessName, _T(".exe") );
        } else {
            //
            // if we cant convert the string then use a bogus value
            //
            _tcscpy( pTask->ProcessName, UNKNOWN_TASK );
        }
#else
        //
        // convert it to ascii
        //
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  (LPCWSTR)p,
                                  -1,
                                  szProcessName,
                                  sizeof(szProcessName) / sizeof(_TCHAR),
                                  NULL,
                                  NULL
                                );

        if (!rc) {
            //
            // if we cant convert the string then use a bogus value
            //
            _tcscpy( pTask->ProcessName, UNKNOWN_TASK );
        }

        if ( (_tcslen(szProcessName)+4) * sizeof(_TCHAR) < sizeof(pTask->ProcessName)) {
            _tcscpy( pTask->ProcessName, szProcessName );
            _tcscat( pTask->ProcessName, _T(".exe") );
        }
#endif

        //
        // get the process id
        //
        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD_PTR)pInst + pInst->ByteLength);
        pTask->dwProcessId = *((LPDWORD) ((DWORD_PTR)pCounter + dwProcessIdCounter));

        //
        // next process
        //
        pTask++;
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD_PTR)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        free( buf );
    }

    RegCloseKey( hKeyNames );

    return pTaskReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\registry.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This file implements the apis for DRWTSN32 to access the registry.
    All access to the registry are done in this file.  If additional
    registry control is needed then a function should be added in this file
    and exposed to the other files in DRWTSN32.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


//
// string constants for accessing the registry
// there is a string constant here for each key and each value
// that is accessed in the registry.
//
#define DRWATSON_EXE_NAME           _T("drwtsn32.exe")
#define REGKEY_SOFTWARE             _T("software\\microsoft")
#define REGKEY_MESSAGEFILE          _T("EventMessageFile")
#define REGKEY_TYPESSUPP            _T("TypesSupported")
#define REGKEY_SYSTEMROOT           _T("%SystemRoot%\\System32\\")
#define REGKEY_EVENTLOG             _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\")
#define REGKEY_APPNAME              _T("ApplicationName")
#define REGKEY_FUNCTION             _T("FunctionName")
#define REGKEY_EXCEPTIONCODE        _T("ExceptionCode")
#define REGKEY_ADDRESS              _T("Address")
#define REGKEY_LOG_PATH             _T("LogFilePath")
#define REGKEY_DUMPSYMBOLS          _T("DumpSymbols")
#define REGKEY_DUMPALLTHREADS       _T("DumpAllThreads")
#define REGKEY_APPENDTOLOGFILE      _T("AppendToLogFile")
#define REGKEY_INSTRUCTIONS         _T("Instructions")
#define REGKEY_VISUAL               _T("VisualNotification")
#define REGKEY_SOUND                _T("SoundNotification")
#define REGKEY_CRASH_DUMP           _T("CreateCrashDump")
#define REGKEY_CRASH_FILE           _T("CrashDumpFile")
#define REGKEY_CRASH_TYPE           _T("CrashDumpType")
#define REGKEY_WAVE_FILE            _T("WaveFile")
#define REGKEY_NUM_CRASHES          _T("NumberOfCrashes")
#define REGKEY_MAX_CRASHES          _T("MaximumCrashes")
#define REGKEY_CURRENTVERSION       _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define REGKEY_CONTROLWINDOWS       _T("SYSTEM\\CurrentControlSet\\Control\\Windows")
#define REGKEY_CSD_VERSION          _T("CSDVersion")
#define REGKEY_CURRENT_BUILD        _T("CurrentBuildNumber")
#define REGKEY_CURRENT_TYPE         _T("CurrentType")
#define REGKEY_REG_ORGANIZATION     _T("RegisteredOrganization")
#define REGKEY_REG_OWNER            _T("RegisteredOwner")
#define REGKEY_AEDEBUG              _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug")
#define REGKEY_AUTO                 _T("Auto")
#define REGKEY_DEBUGGER             _T("Debugger")
#define REGKEY_PROCESSOR            _T("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0")
#define REGKEY_PROCESSOR_ID         _T("Identifier")


//
// local prototypes
//
void
RegSetDWORD(
    HKEY hkey,
    PTSTR pszSubKey,
    DWORD dwValue
    );

void
RegSetBOOL(
    HKEY hkey,
    PTSTR pszSubKey,
    BOOL dwValue
    );

void
RegSetSZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue
    );

void
RegSetEXPANDSZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue
    );

BOOL
RegQueryBOOL(
    HKEY hkey,
    PTSTR pszSubKey
    );

DWORD
RegQueryDWORD(
    HKEY hkey,
    PTSTR pszSubKey
    );

void
RegQuerySZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue,
    DWORD   dwSizeValue
    );

BOOL
RegSaveAllValues(
    HKEY hKeyDrWatson,
    POPTIONS o
    );

BOOL
RegGetAllValues(
    POPTIONS o,
    HKEY hKeyDrWatson
    );

BOOL
RegInitializeDefaults(
    HKEY hKeyDrWatson
    );

HKEY
RegGetAppKey(
    BOOL ReadOnly
    );

BOOL
RegCreateEventSource(
    void
    );

void
GetDrWatsonLogPath(
    LPTSTR szPath
    );

void
GetDrWatsonCrashDump(
    LPTSTR szPath
    );

BOOL
RegGetAllValues(
    POPTIONS o,
    HKEY hKeyDrWatson
    )

/*++

Routine Description:

    This functions retrieves all registry data for DRWTSN32 and puts
    the data in the OPTIONS structure passed in.

Arguments:

    o              - pointer to an OPTIONS structure

    hKeyDrWatson   - handle to a registry key for DRWTSN32 registry data

Return Value:

    TRUE       - retrieved all data without error
    FALSE      - errors occurred and did not get all data

--*/

{
    RegQuerySZ(hKeyDrWatson, REGKEY_LOG_PATH, o->szLogPath, sizeof(o->szLogPath) );
    RegQuerySZ(hKeyDrWatson, REGKEY_WAVE_FILE, o->szWaveFile, sizeof(o->szWaveFile) );
    RegQuerySZ(hKeyDrWatson, REGKEY_CRASH_FILE, o->szCrashDump, sizeof(o->szCrashDump) );

    o->fDumpSymbols = RegQueryBOOL( hKeyDrWatson, REGKEY_DUMPSYMBOLS );
    o->fDumpAllThreads = RegQueryBOOL( hKeyDrWatson, REGKEY_DUMPALLTHREADS );
    o->fAppendToLogFile = RegQueryBOOL( hKeyDrWatson, REGKEY_APPENDTOLOGFILE );
    o->fVisual = RegQueryBOOL( hKeyDrWatson, REGKEY_VISUAL );
    o->fSound = RegQueryBOOL( hKeyDrWatson, REGKEY_SOUND );
    o->fCrash = RegQueryBOOL( hKeyDrWatson, REGKEY_CRASH_DUMP );
    o->dwInstructions = RegQueryDWORD( hKeyDrWatson, REGKEY_INSTRUCTIONS );
    o->dwMaxCrashes = RegQueryDWORD( hKeyDrWatson, REGKEY_MAX_CRASHES );
    o->dwType = (CrashDumpType)RegQueryDWORD(hKeyDrWatson, REGKEY_CRASH_TYPE);

    return TRUE;
}

BOOL
RegSaveAllValues(
    HKEY hKeyDrWatson,
    POPTIONS o
    )

/*++

Routine Description:

    This functions saves all registry data for DRWTSN32 that is passed
    in via the OPTIONS structure.

Arguments:

    hKeyDrWatson   - handle to a registry key for DRWTSN32 registry data

    o              - pointer to an OPTIONS structure

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
TCHAR szPATH[_MAX_PATH];

    RegSetSZ( hKeyDrWatson, REGKEY_LOG_PATH, o->szLogPath );
    RegSetSZ( hKeyDrWatson, REGKEY_WAVE_FILE, o->szWaveFile );
    RegSetSZ( hKeyDrWatson, REGKEY_CRASH_FILE, o->szCrashDump );
    RegSetBOOL( hKeyDrWatson, REGKEY_DUMPSYMBOLS, o->fDumpSymbols );
    RegSetBOOL( hKeyDrWatson, REGKEY_DUMPALLTHREADS, o->fDumpAllThreads );
    RegSetBOOL( hKeyDrWatson, REGKEY_APPENDTOLOGFILE, o->fAppendToLogFile );
    RegSetBOOL( hKeyDrWatson, REGKEY_VISUAL, o->fVisual );
    RegSetBOOL( hKeyDrWatson, REGKEY_SOUND, o->fSound );
    RegSetBOOL( hKeyDrWatson, REGKEY_CRASH_DUMP, o->fCrash );
    RegSetDWORD( hKeyDrWatson, REGKEY_INSTRUCTIONS, o->dwInstructions );
    RegSetDWORD( hKeyDrWatson, REGKEY_MAX_CRASHES, o->dwMaxCrashes );
    RegSetDWORD( hKeyDrWatson, REGKEY_CRASH_TYPE, o->dwType);

    return TRUE;
}

BOOL
RegInitializeDefaults(
    HKEY hKeyDrWatson
    )

/*++

Routine Description:

    This functions initializes the registry with the default values.

Arguments:

    hKeyDrWatson   - handle to a registry key for DRWTSN32 registry data

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
    OPTIONS o;

    GetDrWatsonLogPath(o.szLogPath);
    GetDrWatsonCrashDump(o.szCrashDump);
    o.szWaveFile[0] = _T('\0');
    o.fDumpSymbols = FALSE;
    o.fDumpAllThreads = TRUE;
    o.fAppendToLogFile = TRUE;
    o.fVisual = FALSE;
    o.fSound = FALSE;
    o.fCrash = TRUE;
    o.dwInstructions = 10;
    o.dwMaxCrashes = 10;
    o.dwType = MiniDump;

    RegSetNumCrashes( 0 );

    RegSaveAllValues( hKeyDrWatson, &o );

    RegCreateEventSource();

    return TRUE;
}

BOOL
RegCreateEventSource(
    void
    )

/*++

Routine Description:

    This function creates an event source in the registry.  The event
    source is used by the event viewer to display the data in a
    presentable manner.

Arguments:

    None.

Return Value:

    TRUE       - saved all data without error
    FALSE      - errors occurred and did not save all data

--*/

{
    HKEY        hk;
    _TCHAR      szBuf[1024];
    DWORD       dwDisp;
    _TCHAR      szAppName[MAX_PATH];

    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );
    _tcscpy( szBuf, REGKEY_EVENTLOG );
    _tcscat( szBuf, szAppName );
    if (RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                        szBuf,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_QUERY_VALUE | KEY_SET_VALUE,
                        NULL,
                        &hk,
                        &dwDisp
                      )) {
        return FALSE;
    }

    if (dwDisp == REG_OPENED_EXISTING_KEY) {
        RegCloseKey(hk);
        return TRUE;
    }

    _tcscpy( szBuf, REGKEY_SYSTEMROOT );
    _tcscat( szBuf, DRWATSON_EXE_NAME );
    RegSetEXPANDSZ( hk, REGKEY_MESSAGEFILE, szBuf );
    RegSetDWORD( hk, REGKEY_TYPESSUPP, EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE );

    RegCloseKey(hk);

    return TRUE;
}

HKEY
RegGetAppKey(
    BOOL ReadOnly
    )

/*++

Routine Description:

    This function gets a handle to the DRWTSN32 registry key.

Arguments:
    
    ReadOnly - Caller needs this foe reading purposes only
               Although, we could need to create it if its not present

Return Value:

    Valid handle   - handle opened ok
    NULL           - could not open the handle

--*/

{
    DWORD       rc;
    DWORD       dwDisp;
    HKEY        hKeyDrWatson;
    HKEY        hKeyMicrosoft;
    _TCHAR      szAppName[MAX_PATH];

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_SOFTWARE,
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE |
                       KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS,
                       &hKeyMicrosoft
                     );

    if (rc != ERROR_SUCCESS) {
        if (ReadOnly) {
            // Try oepning it for read only
            rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               REGKEY_SOFTWARE,
                               0,
                               KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                               &hKeyMicrosoft
                             );
        }
        if (rc != ERROR_SUCCESS) {
            return NULL;
        }
    }

    GetAppName( szAppName, sizeof(szAppName) / sizeof(_TCHAR) );

    rc = RegCreateKeyEx( hKeyMicrosoft,
                         szAppName,
                         0,
                         NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_READ | KEY_WRITE,
                         NULL,
                         &hKeyDrWatson,
                         &dwDisp
                       );

    if (rc != ERROR_SUCCESS) {
        if (ReadOnly) {
            // Try oepning it for read only
            rc = RegCreateKeyEx( hKeyMicrosoft,
                                 szAppName,
                                 0,
                                 NULL,
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ,
                                 NULL,
                                 &hKeyDrWatson,
                                 &dwDisp
                               );
        }
        if (rc != ERROR_SUCCESS) {
            return NULL;
        }
    }

    if (dwDisp == REG_CREATED_NEW_KEY) {
        RegInitializeDefaults( hKeyDrWatson );
    }


    return hKeyDrWatson;
}

BOOL
RegInitialize(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to initialize the OPTIONS structure passed in
    with the current values in the registry.  Note that if the registry
    is empty then the defaults are stored in the registry and also
    returned in the OPTIONS structure.

Arguments:

    o - Returns an OPTIONS struct with initial values

Return Value:

    TRUE           - all data was retrieved ok
    NULL           - could not get all data

--*/

{
    HKEY    hKeyDrWatson;

    UINT u1 = sizeof(*o);
    UINT u2 = sizeof(OPTIONS);

    hKeyDrWatson = RegGetAppKey( TRUE );
    Assert( hKeyDrWatson != NULL );

    ZeroMemory(o, sizeof(*o));

    if (!RegGetAllValues( o, hKeyDrWatson )) {
        return FALSE;
    }

    RegCloseKey( hKeyDrWatson );

    return TRUE;
}

BOOL
RegSave(
    POPTIONS o
    )

/*++

Routine Description:

    This function is used to save the data in the OPTIONS structure
    to the registry.

Arguments:

    o              - pointer to an OPTIONS structure

Return Value:

    TRUE           - all data was saved ok
    NULL           - could not save all data

--*/

{
    HKEY    hKeyDrWatson;

    hKeyDrWatson = RegGetAppKey( FALSE );
    Assert( hKeyDrWatson != NULL );

    if (hKeyDrWatson)
    {
        RegSaveAllValues( hKeyDrWatson, o );
        RegCloseKey( hKeyDrWatson );
    }

    return TRUE;
}

void
RegSetNumCrashes(
    DWORD dwNumCrashes
    )

/*++

Routine Description:

    This function changes the value in the registry that contains the
    number of crashes that have occurred.

Arguments:

    dwNumCrashes   - the number of craches to save

Return Value:

    None.

--*/

{
    HKEY    hKeyDrWatson;

    hKeyDrWatson = RegGetAppKey( FALSE );
    Assert( hKeyDrWatson != NULL );

    if (hKeyDrWatson)
    {
        RegSetDWORD( hKeyDrWatson, REGKEY_NUM_CRASHES, dwNumCrashes );
        RegCloseKey( hKeyDrWatson );
    }

    return;
}

DWORD
RegGetNumCrashes(
    void
    )

/*++

Routine Description:

    This function get the value in the registry that contains the
    number of crashes that have occurred.

Arguments:

    None.

Return Value:

    the number of craches that have occurred

--*/

{
    HKEY    hKeyDrWatson;
    DWORD   dwNumCrashes=0;

    hKeyDrWatson = RegGetAppKey( TRUE );
    Assert( hKeyDrWatson != NULL );

    if ( hKeyDrWatson != NULL ) {
        dwNumCrashes = RegQueryDWORD( hKeyDrWatson, REGKEY_NUM_CRASHES );
        RegCloseKey( hKeyDrWatson );
    }

    return dwNumCrashes;
}

BOOLEAN
RegInstallDrWatson(
    BOOL fQuiet
    )

/*++

Routine Description:

    This function sets the AEDebug registry values to automatically
    invoke drwtsn32 when a crash occurs.

Arguments:

    None.

Return Value:

    Valid handle   - handle opened ok
    NULL           - could not open the handle

--*/

{
    DWORD     rc;
    HKEY      hKeyMicrosoft;
    OPTIONS   o;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_AEDEBUG,
                       0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE,
                       &hKeyMicrosoft
                     );

    if (rc != ERROR_SUCCESS) {
        return FALSE;
    }

    RegSetSZ( hKeyMicrosoft, REGKEY_AUTO, _T("1") );
    RegSetSZ( hKeyMicrosoft, REGKEY_DEBUGGER, _T("drwtsn32 -p %ld -e %ld -g") );

    RegCloseKey( hKeyMicrosoft );

    RegInitialize( &o );
    if (fQuiet) {
        o.fVisual = FALSE;
        o.fSound = FALSE;
        RegSave( &o );
    }

    return TRUE;
}

void
RegSetDWORD(
    HKEY hkey,
    PTSTR pszSubKey,
    DWORD dwValue
    )

/*++

Routine Description:

    This function changes a DWORD value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key
    pszSubKey      - pointer to a subkey string
    dwValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;

    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue) );
    Assert( rc == ERROR_SUCCESS );
}

void
RegSetBOOL(
    HKEY hkey,
    PTSTR pszSubKey,
    BOOL dwValue
    )

/*++

Routine Description:

    This function changes a BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

    dwValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;

    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_DWORD, (LPBYTE)&dwValue, 4 );
    Assert( rc == ERROR_SUCCESS );
}

void
RegSetSZ(
    HKEY hkey,
    PTSTR pszSubKey,
    PTSTR pszValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

    pszValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;
    TCHAR szPath[_MAX_PATH];

    // If Dr Watson registry key for log path or crash file are
    // the defaults, don't write them to the registry.
    // The defaults for these are obtained by querying.

    if ( _tcscmp( pszSubKey, REGKEY_LOG_PATH ) == 0 ) { 
        GetDrWatsonLogPath( szPath );
        if (_tcscmp(szPath,pszValue) == 0 ) return;

    } else if ( _tcscmp( pszSubKey, REGKEY_CRASH_FILE) == 0 ) {
	RegQuerySZ(hkey, pszSubKey, szPath, _MAX_PATH);
        if ( _tcscmp(szPath, pszValue) == 0 ) return;
    }
    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_SZ, (PBYTE) pszValue, (_tcslen(pszValue) +1) * sizeof(_TCHAR) );
    Assert( rc == ERROR_SUCCESS );
}

void
RegSetEXPANDSZ(
    HKEY hkey,
    PTSTR pszSubKey,
    PTSTR pszValue
    )

/*++

Routine Description:

    This function changes a SZ value in the registry using the
    hkey and pszSubKey as the registry key info.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

    pszValue       - new registry value

Return Value:

    None.

--*/

{
    DWORD rc;

    rc = RegSetValueEx( hkey, pszSubKey, 0, REG_EXPAND_SZ, (PBYTE) pszValue, _tcslen(pszValue)+1 );
    Assert( rc == ERROR_SUCCESS );
}

BOOL
RegQueryBOOL(
    HKEY hkey,
    PTSTR pszSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a FALSE value.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

Return Value:

    TRUE or FALSE.

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    BOOL    fValue = FALSE;

    len = 4;
    rc = RegQueryValueEx( hkey, pszSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = FALSE;
            RegSetBOOL( hkey, pszSubKey, fValue );
        }
        else {
            Assert( rc == ERROR_SUCCESS );
        }
    }
    else {
        Assert( dwType == REG_DWORD );
    }

    return fValue;
}

DWORD
RegQueryDWORD(
    HKEY hkey,
    PTSTR pszSubKey
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    DWORD   rc;
    DWORD   len;
    DWORD   dwType;
    DWORD   fValue = 0;

    len = 4;
    rc = RegQueryValueEx( hkey, pszSubKey, 0, &dwType, (LPBYTE)&fValue, &len );
    if (rc != ERROR_SUCCESS) {
        if (rc == ERROR_FILE_NOT_FOUND) {
            fValue = 0;
            RegSetDWORD( hkey, pszSubKey, fValue );
        }
        else {
            Assert( rc == ERROR_SUCCESS );
        }
    }
    else {
        Assert( dwType == REG_DWORD );
    }

    return fValue;
}

void
RegQuerySZ(
    HKEY    hkey,
    PTSTR   pszSubKey,
    PTSTR   pszValue,
    DWORD   dwSizeValue
    )

/*++

Routine Description:

    This function queries BOOL value in the registry using the
    hkey and pszSubKey as the registry key info.  If the value is not
    found in the registry, it is added with a zero value.

Arguments:

    hkey          - handle to a registry key

    pszSubKey      - pointer to a subkey string

Return Value:

    registry value

--*/

{
    LONG    lRes;
    DWORD   dwLen;
    DWORD   dwType;

    lRes = RegQueryValueEx( hkey, pszSubKey, 0, &dwType, (PBYTE) pszValue, &dwSizeValue );

    if (lRes == ERROR_FILE_NOT_FOUND) {

        // If these two SubKeys already exist in the registry, then use the registry values.
        // If they don't exist, query for the value.
        if ( _tcscmp( pszSubKey, REGKEY_LOG_PATH) == 0 ) {
            GetDrWatsonLogPath( pszValue );
        } else if ( _tcscmp( pszSubKey, REGKEY_CRASH_FILE) == 0 ) {
            GetDrWatsonCrashDump( pszValue );
        } 
    } else {
        Assert( lRes == ERROR_SUCCESS );
        Assert( dwType == REG_SZ || dwType == REG_EXPAND_SZ );

        // If the old defaults for Beta 3 or NT4 log path and crash file
        // exist, then delete them and use the new and improved values

        if ( _tcscmp( pszSubKey, REGKEY_LOG_PATH) == 0  &&
            (_tcsicmp( pszValue, _T("%userprofile%")) == 0  ||
             _tcsicmp( pszValue, _T("%windir%")) == 0 ) ) {

            // Delete the key
            lRes = RegDeleteValue( hkey, pszSubKey);
            Assert ( lRes == ERROR_SUCCESS);
            GetDrWatsonLogPath( pszValue );

        } else if ( _tcscmp( pszSubKey, REGKEY_CRASH_FILE) == 0  &&
                    _tcsicmp( pszValue, _T("%windir%\\user.dmp")) == 0 ) { 
            // Delete the key
            lRes = RegDeleteValue( hkey, pszSubKey);
            Assert( lRes == ERROR_SUCCESS);
            GetDrWatsonCrashDump( pszValue );
        }
    }
}

void
RegLogCurrentVersion(
    void
    )

/*++

Routine Description:

    This function writes system and user info. to the log file

Arguments:

    None

Return Value:

    registry value

History:

    8/21/97 a-paulbr fixed bug 658

--*/

{
    _TCHAR  buf[1024];
    DWORD   rc;
    HKEY    hKeyCurrentVersion = NULL;
    HKEY    hKeyControlWindows = NULL;
    DWORD   dwSPNum = 0;
    DWORD   dwType = REG_DWORD;
    DWORD   dwSize = sizeof(DWORD);

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_CURRENTVERSION,
                       0,
                       KEY_QUERY_VALUE,
                       &hKeyCurrentVersion
                     );

    if (rc != ERROR_SUCCESS) {
        return;
    }
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_CONTROLWINDOWS,
                       0,
                       KEY_QUERY_VALUE,
                       &hKeyControlWindows);
    if (hKeyControlWindows) {
        //
        // I'm using RegQueryValueEx() because there is an assertion in
        // RegQueryDWORD() if the key does not exist.
        //
        RegQueryValueEx(hKeyControlWindows,
                        REGKEY_CSD_VERSION,
                        NULL,
                        &dwType,
                        (BYTE*)&dwSPNum,
                        &dwSize
                        );
    }

    RegQuerySZ(hKeyCurrentVersion, REGKEY_CURRENT_BUILD, buf, sizeof(buf) );
    lprintf( MSG_CURRENT_BUILD, buf );

    if ((hKeyControlWindows) &&
        (dwType == REG_DWORD) &&
        (HIBYTE(LOWORD(dwSPNum)) != 0)) {
        _stprintf(buf, _T("%hu"), HIBYTE(LOWORD(dwSPNum)));
        lprintf( MSG_CSD_VERSION, buf );
    } else {
        _stprintf(buf, _T("None"));
        lprintf( MSG_CSD_VERSION, buf );
    }

    RegQuerySZ( hKeyCurrentVersion,REGKEY_CURRENT_TYPE, buf, sizeof(buf) );
    lprintf( MSG_CURRENT_TYPE, buf );
    RegQuerySZ( hKeyCurrentVersion,REGKEY_REG_ORGANIZATION, buf, sizeof(buf) );
    lprintf( MSG_REG_ORGANIZATION, buf );
    RegQuerySZ( hKeyCurrentVersion,REGKEY_REG_OWNER, buf, sizeof(buf) );
    lprintf( MSG_REG_OWNER, buf );

    //
    // Close the keys that we opened
    //
    RegCloseKey(hKeyCurrentVersion);
    RegCloseKey(hKeyControlWindows);

    return;
}

void
RegLogProcessorType(
    void
    )
{
    _TCHAR  buf[1024];
    DWORD   rc;
    HKEY    hKey;

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REGKEY_PROCESSOR,
                       0,
                       KEY_QUERY_VALUE,
                       &hKey
                     );

    if (rc != ERROR_SUCCESS) {
        return;
    }

    RegQuerySZ( hKey, REGKEY_PROCESSOR_ID, buf, sizeof(buf) );
    lprintf( MSG_SYSINFO_PROC_TYPE, buf );

    return;
}


void
GetDrWatsonLogPath(
    LPTSTR szPath
    )
{
int rc;
SECURITY_ATTRIBUTES SecAttrib;
SECURITY_DESCRIPTOR SecDescript;

    SHGetFolderPath(NULL,
                 CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE, NULL, 0, szPath);
    Assert( _tcsicmp(szPath,_T("")) != 0 );
    _tcscat(szPath,_T("\\Microsoft\\Dr Watson") );

    // Create a DACL that allows all access to the directory
    SecAttrib.nLength=sizeof(SECURITY_ATTRIBUTES);
    SecAttrib.lpSecurityDescriptor=&SecDescript;
    SecAttrib.bInheritHandle=FALSE;

    InitializeSecurityDescriptor(&SecDescript, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SecDescript, TRUE, NULL, FALSE);

    if ( !CreateDirectory(szPath,&SecAttrib) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
            rc = GetLastError();
         }
    }
    return;
}

void
GetDrWatsonCrashDump(
    LPTSTR szPath
    )
{
    int rc;
    SECURITY_ATTRIBUTES SecAttrib;
    SECURITY_DESCRIPTOR SecDescript;

    SHGetFolderPath(NULL,
                 CSIDL_COMMON_APPDATA | CSIDL_FLAG_CREATE, NULL, 0, szPath);
    Assert( _tcsicmp(szPath,_T("")) != 0 );
    _tcscat(szPath,_T("\\Microsoft\\Dr Watson") );

    // Create a DACL that allows all access to the directory
    SecAttrib.nLength=sizeof(SECURITY_ATTRIBUTES);
    SecAttrib.lpSecurityDescriptor=&SecDescript;
    SecAttrib.bInheritHandle=FALSE;

    InitializeSecurityDescriptor(&SecDescript, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&SecDescript, TRUE, NULL, FALSE);

    if ( !CreateDirectory(szPath,&SecAttrib) ) {
        if( GetLastError() != ERROR_ALREADY_EXISTS ) {
            rc = GetLastError();
        }
    }
    _tcscat(szPath, _T("\\user.dmp") );

    return;
}

void
DeleteCrashDump()
{
    HKEY hKeyDrWatson;
    TCHAR szCrashDump[MAX_PATH];

    hKeyDrWatson = RegGetAppKey( TRUE );
    
    if (hKeyDrWatson) {
        RegQuerySZ(hKeyDrWatson, REGKEY_CRASH_FILE, szCrashDump, sizeof(szCrashDump) );

        DeleteFile(szCrashDump);
        RegCloseKey( hKeyDrWatson );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\resource.h ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Resource file constants.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

// Dr Watson Dialog
#define ID_LOGPATH_TEXT         101
#define ID_LOGPATH              102
#define ID_BROWSE_LOGPATH       103
#define ID_CRASH_DUMP_TEXT      104
#define ID_CRASH_DUMP           105
#define ID_BROWSE_CRASH         106
#define ID_WAVEFILE_TEXT        107
#define ID_WAVE_FILE            108
#define ID_BROWSE_WAVEFILE      109

#define ID_INSTRUCTIONS         110
#define ID_NUM_CRASHES          111

#define ID_DUMPSYMBOLS          112
#define ID_DUMPALLTHREADS       113
#define ID_APPENDTOLOGFILE      114
#define ID_VISUAL               115
#define ID_SOUND                116
#define ID_CRASH                117

#define ID_LOGFILE_VIEW         118
#define ID_CLEAR                119
#define ID_CRASHES              120

// Notify Dialog
#define ID_TEXT1                122
#define ID_TEXT2                123

// Wave File Open Dialog
#define ID_TEST_WAVE            124

// Assert Dialog - dead
#define ID_ASSERT_TEXT          125
#define ID_ASSERT_ICON          126

// Usage Dialog
#define ID_USAGE                127
#define ID_ABOUT                128

#define ID_DUMP_TYPE_TEXT       129          
#define ID_DUMP_TYPE_FULL_OLD   130          
#define ID_DUMP_TYPE_MINI       131          
#define ID_DUMP_TYPE_FULLMINI   132          

#define IDS_APPLICATION_NAME    201
#define IDS_FATAL_ERROR         202
#define IDS_NONFATAL_ERROR      203
#define IDS_ASSERTION_ERROR     204
#define IDS_MEMORY              205
#define IDS_DEBUGPRIV           206
#define IDS_ATTACHFAIL          207
#define IDS_INVALID_PATH        208
#define IDS_INVALID_WAVE        209
#define IDS_CANT_OPEN_LOGFILE   210
#define IDS_INVALID_LOGFILE     211
#define IDS_ABOUT_TITLE         212
#define IDS_ABOUT_EXTRA         213
#define IDS_AE_TEXT             214
#define IDS_LOGBROWSE_TITLE     215
#define IDS_WAVEBROWSE_TITLE    216
#define IDS_WAVE_FILTER         217
#define IDS_UNKNOWN_MACHINE     218
#define IDS_UNKNOWN_USER        219
#define IDS_ABOUT               220
#define IDS_DUMPBROWSE_TITLE    221
#define IDS_DUMP_FILTER         222
#define IDS_INVALID_CRASH_PATH  223
#define IDS_ERROR_FORMAT_STRING 224
#define IDS_APP_ALREADY_EXITED  225
#define IDS_CANT_INIT_ENGINE    226


// Help for Dr. Watson Dialog
#define IDH_BROWSE                      28496
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define IDH_CRASH_DUMP                  724
#define IDH_LOG_FILE_PATH               704
#define IDH_VIEW                        720
#define IDH_CREATE_CRASH_DUMP_FILE      723
#define IDH_VISUAL_NOTIFICATION         711
#define IDH_DUMP_ALL_THREAD_CONTEXTS    709
#define IDH_NUMBER_OF_ERRORS_TO_SAVE    707
#define IDH_WAVE_FILE                   705
#define IDH_NUMBER_OF_INSTRUCTIONS      706
#define IDH_DUMP_SYMBOL_TABLE           708
#define IDH_APPEND_TO_EXISTING_LOGFILE  710
#define IDH_SOUND_NOTIFICATION          712
#define IDH_CLEAR                       721
#define IDH_APPLICATION_ERRORS          722 

#define IDH_INDEX               701
#define IDH_WHAT                702
#define IDH_OPTIONS             703
#define IDH_REGISTRY            713
#define IDH_EVENTLOG            714
#define IDH_WINDOWSDIR          715
#define IDH_PC                  716
#define IDH_LOGFILE             717
#define IDH_INSTALLATION        718
#define IDH_ASSERT              719
#define IDH_VIEW                720
#define IDH_CLEAR               721

#define IDHH_INDEX              _T("drwatson_overview.htm")
#define IDHH_WHAT               _T("drwatson_overview.htm")
#define IDHH_LOGFILELOCATION    _T("drwatson_logfile.htm")
#define IDHH_WAVEFILE           _T("drwatson_options.htm")
#define IDHH_ASSERT             _T("drwatson_overview.htm")
#define IDHH_CRASH_DUMP         _T("drwatson_overview.htm")

#define NOTIFYDIALOG            501
#define DRWATSONDIALOG          502
#define DIRBROWSEDIALOG         503
#define WAVEFILEOPENDIALOG      504

#define DRWATSONICON            506
#define LOGFILEVIEWERDIALOG     507
#define DRWATSONACCEL           508
#define APPICON                 509
#define USAGEDIALOG             510
#define DUMPFILEOPENDIALOG      511
#define IDI_ICON1               512


#define DUMPFILEOPENDIALOG2     513
#define WAVEFILEOPENDIALOG2     514


#define stc1                 0x0440
#define stc2                 0x0441
#define stc3                 0x0442
#define stc4                 0x0443
#define edt1                 0x0480
#define lst1                 0x0460
#define lst2                 0x0461
#define cmb1                 0x0470
#define cmb2                 0x0471
#define cmb3                 0x0472
#define psh14                0x040d
#define psh15                0x040e
#define chx1                 0x0410
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\util.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    util.cpp

Abstract:
    This file implements common utilitarian functions.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


void
GetWinHelpFileName(
    _TCHAR *pszHelpFileName,
    DWORD len
    )
{
    _TCHAR           szDrive[_MAX_DRIVE];
    _TCHAR           szDir[_MAX_DIR];

    //
    // find out the path where DrWatson was run from
    //
    GetModuleFileName( GetModuleHandle(NULL), pszHelpFileName, len );

    //
    // take the path and append the help file name
    //
    _tsplitpath( pszHelpFileName, szDrive, szDir, NULL, NULL );
    _stprintf( pszHelpFileName, _T("%s%sdrwtsn32.hlp"), szDrive, szDir );

    return;
}

void
GetHtmlHelpFileName(
    _TCHAR *pszHelpFileName,
    DWORD len
    )
{
    _TCHAR           szDrive[_MAX_DRIVE];
    _TCHAR           szDir[_MAX_DIR];

    //
    // Make sure the array is at least initialized to zero.
    //

    *pszHelpFileName = 0;

    //
    // find out the path where DrWatson was run from
    //
    GetModuleFileName( GetModuleHandle(NULL), pszHelpFileName, len );

    //
    // take the path and append the help file name
    //
    _tsplitpath( pszHelpFileName, szDrive, szDir, NULL, NULL );
    _stprintf( pszHelpFileName, _T("%s%sdrwtsn32.chm"), szDrive, szDir );

    return;
}

/***************************************************************************\
* LoadStringOrError
*
* NOTE: Passing a NULL value for lpch returns the string length. (WRONG!)
*
* Warning: The return count does not include the terminating NULL WCHAR;
*
* History:
* 05-Apr-1991 ScottLu   Fixed - code is now shared between client and server
* 24-Sep-1990 MikeKe    From Win30
\***************************************************************************/

int
MyLoadStringOrError(
    HMODULE   hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       nLenInChars,        // cch in Unicode buffer
    WORD      wLangId
    )
{
    HRSRC  hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        //RIPMSG0(RIP_WARNING, _T("MyLoadStringOrError: lpBuffer == NULL"));
        return 0;
    }


    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    hResInfo = FindResourceExW(hModule,
                               MAKEINTRESOURCEW(6), /* RT_STRING */
                               (LPWSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)),
                               wLangId
                               );
    if (hResInfo) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);
        if (hStringSeg == NULL)
        {
            return 0;
        }

        lpsz = (LPWSTR) (hStringSeg);

        /*
         * Move past the other strings in this segment.
         * (16 strings in a segment -> & 0x0F)
         */
        wID &= 0x0F;
        while (TRUE) {
            cch = *((WCHAR *)lpsz++);       // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
            if (wID-- == 0) break;
            lpsz += cch;                    // Step to start if next string
        }

        /*
         * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
         */
        if (nLenInChars == 0) {
            *(LPWSTR *)lpBuffer = lpsz;
        } else {

            /*
             * Account for the NULL
             */
            nLenInChars--;

            /*
             * Don't copy more than the max allowed.
             */
            if (cch > nLenInChars) {
                cch = nLenInChars;
            }

            /*
             * Copy the string into the buffer.
             */
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
        }
    }

    /*
     * Append a NULL.
     */
    if (nLenInChars != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}


/***************************************************************************\
* LoadStringA (API)
* LoadStringW (API)
*
*
* 05-Apr-1991 ScottLu   Fixed to work with client/server.
\***************************************************************************/

int
WINAPI
MyLoadString(
    HINSTANCE hmod,
    UINT      wID,
    LPWSTR    lpBuffer,
    int       nLenInChars
    )
{
    return MyLoadStringOrError((HMODULE)hmod,
                               wID,
                               lpBuffer,
                               nLenInChars,
                               0);
}


_TCHAR *
LoadRcString(
    UINT wId
    )

/*++

Routine Description:

    Loads a resource string from DRWTSN32 and returns a pointer
    to the string.

Arguments:

    wId        - resource string id

Return Value:

    pointer to the string

--*/

{
    static _TCHAR buf[1024];

    MyLoadString( GetModuleHandle(NULL), wId, buf, sizeof(buf) / sizeof(_TCHAR) );

    return buf;
}

void
GetAppName(
    _TCHAR *pszAppName,
    DWORD len
    )
{
    MyLoadString( GetModuleHandle(NULL), IDS_APPLICATION_NAME, pszAppName, len );
}

PTSTR
ExpandPath(
    PTSTR lpPath
    )
/*++
Description
    Expands the path passed. Returns the expanded path in an dynamically
    allocated string. The dynamically allocated string is always at least
    _MAX_PATH is size. Note: size is calculated in characters.

Arguments
    lpPath - Path to be expanded.

Returns
    Dynamically allocated buffer at least _MAX_PATH in length.
--*/
{
    DWORD   len;
    PTSTR   p;


    len = ExpandEnvironmentStrings( lpPath, NULL, 0 );
    if (!len) {
        return NULL;
    }

    len++; // Null terminator
    len = max(len, _MAX_PATH);
    p = (PTSTR) calloc( len, sizeof(_TCHAR) );
    if (!p) {
        return NULL;
    }

    len = ExpandEnvironmentStrings( lpPath, p, len );
    if (!len) {
        free( p );
        return NULL;
    }

    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\drwatson\ui.cpp ===
/*++

Copyright (c) 1993-2001  Microsoft Corporation

Module Name:

    ui.cpp

Abstract:

    This function implements the ui (dialog) that controls the
    options maintenace for drwatson.

Author:

    Wesley Witt (wesw) 1-May-1993

Environment:

    User Mode

--*/

#include "pch.cpp"


void
InitializeDialog(
    HWND hwnd
    );

void
InitializeCrashList(
    HWND hwnd
    );

BOOL
GetDialogValues(
    HWND hwnd
    );

INT_PTR
CALLBACK
LogFileViewerDialogProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR
CALLBACK
DrWatsonDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

PTSTR
ExpandPath(
    PTSTR lpPath
    );

const
DWORD
DrWatsonHelpIds[] = {
    ID_LOGPATH_TEXT,    IDH_LOG_FILE_PATH,
    ID_LOGPATH,         IDH_LOG_FILE_PATH,
    ID_BROWSE_LOGPATH,  IDH_BROWSE,
    ID_CRASH_DUMP_TEXT, IDH_CRASH_DUMP,
    ID_CRASH_DUMP,      IDH_CRASH_DUMP,
    ID_BROWSE_CRASH,    IDH_BROWSE,
    ID_WAVEFILE_TEXT,   IDH_WAVE_FILE,
    ID_WAVE_FILE,       IDH_WAVE_FILE,
    ID_BROWSE_WAVEFILE, IDH_BROWSE,

    ID_INSTRUCTIONS,    IDH_NUMBER_OF_INSTRUCTIONS,
    ID_NUM_CRASHES,     IDH_NUMBER_OF_ERRORS_TO_SAVE,

    ID_DUMPSYMBOLS,     IDH_DUMP_SYMBOL_TABLE,
    ID_DUMPALLTHREADS,  IDH_DUMP_ALL_THREAD_CONTEXTS,
    ID_APPENDTOLOGFILE, IDH_APPEND_TO_EXISTING_LOGFILE,
    ID_VISUAL,          IDH_VISUAL_NOTIFICATION,
    ID_SOUND,           IDH_SOUND_NOTIFICATION,
    ID_CRASH,           IDH_CREATE_CRASH_DUMP_FILE,

    ID_LOGFILE_VIEW,    IDH_VIEW,
    ID_CLEAR,           IDH_CLEAR,
    ID_CRASHES,         IDH_APPLICATION_ERRORS,

    ID_TEST_WAVE,       IDH_WAVE_FILE,
    psh15,              IDH_INDEX,
    0,                  0
};


void
DrWatsonWinMain(
    void
    )

/*++

Routine Description:

    This is the entry point for DRWTSN32

Arguments:

    None.

Return Value:

    None.

--*/

{
    HWND           hwnd;
    MSG            msg;
    HINSTANCE      hInst;
    WNDCLASS wndclass;
        

    hInst                   = GetModuleHandle( NULL );
    wndclass.style          = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc    = (WNDPROC)DrWatsonDialogProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = DLGWINDOWEXTRA;
    wndclass.hInstance      = hInst;
    wndclass.hIcon          = LoadIcon( hInst, MAKEINTRESOURCE(APPICON) );
    wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = _T("DrWatsonDialog");
    RegisterClass( &wndclass );
    
    hwnd = CreateDialog( hInst,
                         MAKEINTRESOURCE( DRWATSONDIALOG ),
                         0,
                         DrWatsonDialogProc
                       );

    if (hwnd == NULL) {
        return;
    }

    ShowWindow( hwnd, SW_SHOWNORMAL );

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (!IsDialogMessage( hwnd, &msg )) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
    }

    return;
}


INT_PTR
CALLBACK
DrWatsonDialogProc (
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the DRWTSN32.EXE main user interface.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    DWORD       helpId;
    DWORD       ctlId;
    UINT        Checked;
    _TCHAR      szCurrDir[MAX_PATH];
    _TCHAR      szWave[MAX_PATH];
    _TCHAR      szDump[MAX_PATH];
    _TCHAR      szHelpFileName[MAX_PATH];
    PTSTR       p;
    PDWORD      pdw;


    switch (message) {
    case WM_CREATE:
        return 0;

    case WM_INITDIALOG:
        SubclassControls( hwnd );
        InitializeDialog( hwnd );
        return 1;

    case WM_HELP: // F1 key and ?

        ctlId = ((LPHELPINFO)lParam)->iCtrlId;
        helpId = IDH_INDEX;
        for (pdw = (PDWORD)DrWatsonHelpIds; *pdw; pdw+=2) {
            if (*pdw == ctlId) {
                helpId = pdw[1];
                break;
            }
        }
        if ( helpId == IDH_BROWSE ) {
               _tcscpy( szHelpFileName, _T("windows.hlp") );
        }
        else {
            GetWinHelpFileName( szHelpFileName,
                    sizeof(szHelpFileName) / sizeof(_TCHAR) );
        }

        WinHelp( (HWND)((LPHELPINFO) lParam)->hItemHandle,
                 szHelpFileName,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPVOID)DrWatsonHelpIds );
        return TRUE;

    case WM_CONTEXTMENU: // right mouse click
        if( hwnd == (HWND) wParam ) {
            POINT pt;
            GetCursorPos(&pt);
            ScreenToClient(hwnd, &pt);
            wParam = (WPARAM) ChildWindowFromPoint(hwnd, pt);
        }

        ctlId = GetDlgCtrlID((HWND)wParam);
        helpId = IDH_INDEX;
        for (pdw = (PDWORD)DrWatsonHelpIds; *pdw; pdw+=2) {
            if (*pdw == ctlId) {
                helpId = pdw[1];
                break;
            }
        }
        if ( helpId == IDH_BROWSE ) {
               _tcscpy( szHelpFileName, _T("windows.hlp") );
        }
        else {
            GetWinHelpFileName( szHelpFileName,
                    sizeof(szHelpFileName) / sizeof(_TCHAR) );
        }
        WinHelp((HWND)wParam,
                szHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)DrWatsonHelpIds
               );
        return TRUE;

    case WM_ACTIVATEAPP:
    case WM_SETFOCUS:
        SetFocusToCurrentControl();
        return 0;

    case WM_SYSCOMMAND:
        if (wParam == ID_ABOUT) {
            _TCHAR title[256];
            _TCHAR extra[256];

            _tcscpy( title, LoadRcString( IDS_ABOUT_TITLE ) );
            _tcscpy( extra, LoadRcString( IDS_ABOUT_EXTRA ) );

            ShellAbout( hwnd,
                title,
                extra,
                LoadIcon( GetModuleHandle(NULL), MAKEINTRESOURCE(APPICON) )
                );

            return 0;
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            if (GetDialogValues( hwnd )) {
                HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
                PostQuitMessage( 0 );
            }
            break;

        case IDCANCEL:
            HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
            PostQuitMessage( 0 );
            break;

        case ID_BROWSE_LOGPATH:
            GetDlgItemText( hwnd, ID_LOGPATH, szCurrDir, MAX_PATH );
            p = ExpandPath( szCurrDir );
            if (p) {
                _tcscpy( szCurrDir, p );
                free( p );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_LOGPATH ), FALSE );
            if (BrowseForDirectory(hwnd, szCurrDir )) {
                SetDlgItemText( hwnd, ID_LOGPATH, szCurrDir );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_LOGPATH ), TRUE );
            SetFocus( GetDlgItem(hwnd, ID_BROWSE_LOGPATH) );
            return FALSE;
            break;

        case ID_BROWSE_WAVEFILE:
            szWave[0] = _T('\0');
            GetDlgItemText( hwnd, ID_WAVE_FILE, szWave, MAX_PATH );
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), FALSE );
            if (GetWaveFileName(hwnd, szWave )) {
                SetDlgItemText( hwnd, ID_WAVE_FILE, szWave );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), TRUE );
            SetFocus( GetDlgItem(hwnd, ID_BROWSE_WAVEFILE) );
            return FALSE;
            break;

        case ID_BROWSE_CRASH:
            szDump[0] = _T('\0');
            GetDlgItemText( hwnd, ID_CRASH_DUMP, szDump, MAX_PATH );
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), FALSE );
            if (GetDumpFileName(hwnd, szDump )) {
                SetDlgItemText( hwnd, ID_CRASH_DUMP, szDump );
            }
            EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), TRUE );
            SetFocus( GetDlgItem(hwnd, ID_BROWSE_CRASH) );
            return FALSE;
            break;

        case ID_CLEAR:
            ElClearAllEvents();
            InitializeCrashList( hwnd );
            break;

        case ID_TEST_WAVE:
            GetDlgItemText( hwnd, ID_WAVE_FILE, szWave, sizeof(szWave) / sizeof(_TCHAR) );
            PlaySound( szWave, NULL, SND_FILENAME );
            break;

        case ID_LOGFILE_VIEW:
            DialogBoxParam( GetModuleHandle( NULL ),
                MAKEINTRESOURCE( LOGFILEVIEWERDIALOG ),
                hwnd,
                LogFileViewerDialogProc,
                SendMessage((HWND)GetDlgItem(hwnd,ID_CRASHES),
                LB_GETCURSEL,0,0)
                );
            break;

        case IDHELP:
            //
            // call HtmlHelp
            //
            GetHtmlHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            HtmlHelp( hwnd,
                szHelpFileName,
                HH_DISPLAY_TOPIC,
                (DWORD_PTR)(IDHH_INDEX)
                );
            SetFocus( GetDlgItem(hwnd, IDHELP) );
            break;

        default:
            if (((HWND)lParam == GetDlgItem( hwnd, ID_CRASHES )) &&
                (HIWORD( wParam ) == LBN_DBLCLK)) {
                DialogBoxParam( GetModuleHandle( NULL ),
                    MAKEINTRESOURCE( LOGFILEVIEWERDIALOG ),
                    hwnd,
                    LogFileViewerDialogProc,
                    SendMessage((HWND)lParam,LB_GETCURSEL,0,0)
                    );
            }
            if (((HWND)lParam == GetDlgItem( hwnd, ID_CRASH )) &&
                (HIWORD( wParam ) == BN_CLICKED)) {
                Checked = IsDlgButtonChecked( hwnd, ID_CRASH );
                EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP_TEXT ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_TEXT ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), Checked == 1 );
            }
            if (((HWND)lParam == GetDlgItem( hwnd, ID_SOUND )) &&
                (HIWORD( wParam ) == BN_CLICKED)) {
                Checked = IsDlgButtonChecked( hwnd, ID_SOUND );
                EnableWindow( GetDlgItem( hwnd, ID_WAVEFILE_TEXT ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_WAVE_FILE ), Checked == 1 );
                EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), Checked == 1 );
            }
            break;
        }
        break;

        case IDH_WAVE_FILE:
            //
            // call HtmlHelp
            //
            GetHtmlHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            HtmlHelp(hwnd,
                     szHelpFileName,
                     HH_DISPLAY_TOPIC,
                     (DWORD_PTR)(IDHH_WAVEFILE)
                     );
            break;
        case IDH_CRASH_DUMP:
            //
            // call HtmlHelp
            //
            GetHtmlHelpFileName( szHelpFileName, sizeof(szHelpFileName) / sizeof(_TCHAR) );
            HtmlHelp( hwnd,
                      szHelpFileName,
                      HH_DISPLAY_TOPIC,
                      (DWORD_PTR)(IDHH_LOGFILELOCATION)
                      );
            break;


        case WM_DESTROY:
            HtmlHelp( NULL, NULL,  HH_CLOSE_ALL,  0);
            PostQuitMessage( 0 );
            return 0;
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}

BOOL
CALLBACK
EnumCrashes(
    PCRASHINFO crashInfo
    )

/*++

Routine Description:

    Enumeration function for crash records.  This function is called
    once for each crash record.  This function places the formatted
    crash data in a listbox.

Arguments:

    crashInfo      - pointer to a CRASHINFO structure

Return Value:

    TRUE           - caller should continue calling the enum procedure
    FALSE          - caller should stop calling the enum procedure

--*/

{
    SIZE size;
    _TCHAR buf[1024];

    _stprintf( buf, _T("%s  %08x  %s(%08p)"),
              crashInfo->crash.szAppName,
              crashInfo->crash.dwExceptionCode,
              crashInfo->crash.szFunction,
              crashInfo->crash.dwAddress
            );
    SendMessage( crashInfo->hList, LB_ADDSTRING, 0, (LPARAM)buf );


    GetTextExtentPoint( crashInfo->hdc, buf, _tcslen(buf), &size );
    if (size.cx > (LONG)crashInfo->cxExtent) {
        crashInfo->cxExtent = size.cx;
    }

    return TRUE;
}


void
InitializeCrashList(
    HWND hwnd
    )

/*++

Routine Description:

    Initializes the listbox that contains the crash information.

Arguments:

    None.

Return Value:

    None.

--*/

{
    CRASHINFO     crashInfo;
    TEXTMETRIC    tm;
    HFONT         hFont;

    crashInfo.hList = GetDlgItem( hwnd, ID_CRASHES );
    SendMessage( crashInfo.hList, LB_RESETCONTENT, FALSE, 0L );
    SendMessage( crashInfo.hList, WM_SETREDRAW, FALSE, 0L );
    crashInfo.hdc = GetDC( crashInfo.hList );
    crashInfo.cxExtent = 0;

    ElEnumCrashes( &crashInfo, EnumCrashes );

    hFont = (HFONT)SendMessage( crashInfo.hList, WM_GETFONT, 0, 0L );
    if (hFont != NULL) {
        SelectObject( crashInfo.hdc, hFont );
    }
    if (crashInfo.hdc != NULL) {
        GetTextMetrics( crashInfo.hdc, &tm );
        ReleaseDC( crashInfo.hList, crashInfo.hdc );
    }
    SendMessage( crashInfo.hList, LB_SETHORIZONTALEXTENT, crashInfo.cxExtent, 0L );
    SendMessage( crashInfo.hList, WM_SETREDRAW, TRUE, 0L );

    return;
}

void
InitializeDialog(
    HWND hwnd
    )

/*++

Routine Description:

    Initializes the DRWTSN32 user interface dialog with the values
    stored in the registry.

Arguments:

    hwnd       - window handle to the dialog

Return Value:

    None.

--*/

{
    OPTIONS       o;
    _TCHAR        buf[256];
    HMENU         hMenu;


    RegInitialize( &o );
    SetDlgItemText( hwnd, ID_LOGPATH, o.szLogPath );
    SetDlgItemText( hwnd, ID_WAVE_FILE, o.szWaveFile );
    SetDlgItemText( hwnd, ID_CRASH_DUMP, o.szCrashDump );
    _stprintf( buf, _T("%d"), o.dwMaxCrashes );
    SetDlgItemText( hwnd, ID_NUM_CRASHES, buf );
    _stprintf( buf, _T("%d"), o.dwInstructions );
    SetDlgItemText( hwnd, ID_INSTRUCTIONS, buf );
    SendMessage( GetDlgItem( hwnd, ID_DUMPSYMBOLS ), BM_SETCHECK, o.fDumpSymbols, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMPALLTHREADS ), BM_SETCHECK, o.fDumpAllThreads, 0 );
    SendMessage( GetDlgItem( hwnd, ID_APPENDTOLOGFILE ), BM_SETCHECK, o.fAppendToLogFile, 0 );
    SendMessage( GetDlgItem( hwnd, ID_VISUAL ), BM_SETCHECK, o.fVisual, 0 );
    SendMessage( GetDlgItem( hwnd, ID_SOUND ), BM_SETCHECK, o.fSound, 0 );
    SendMessage( GetDlgItem( hwnd, ID_CRASH ), BM_SETCHECK, o.fCrash, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), BM_SETCHECK, o.dwType == FullDump, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), BM_SETCHECK, o.dwType == MiniDump, 0 );
    SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), BM_SETCHECK, o.dwType == FullMiniDump, 0 );

    if (waveOutGetNumDevs() == 0) {
        EnableWindow( GetDlgItem( hwnd, ID_WAVEFILE_TEXT ), FALSE );
        EnableWindow( GetDlgItem( hwnd, ID_WAVE_FILE ), FALSE );
        EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), FALSE );
    }
    else {
        EnableWindow( GetDlgItem( hwnd, ID_WAVEFILE_TEXT ), o.fSound );
        EnableWindow( GetDlgItem( hwnd, ID_WAVE_FILE ), o.fSound );
        EnableWindow( GetDlgItem( hwnd, ID_BROWSE_WAVEFILE ), o.fSound );
    }

    EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP_TEXT ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_CRASH_DUMP ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_BROWSE_CRASH ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_TEXT ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), o.fCrash );
    EnableWindow( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), o.fCrash );

    InitializeCrashList( hwnd );

    if (SendMessage( GetDlgItem( hwnd, ID_CRASHES ), LB_GETCOUNT, 0 ,0 ) == 0) {
        EnableWindow( GetDlgItem( hwnd, ID_CLEAR ), FALSE );
        EnableWindow( GetDlgItem( hwnd, ID_LOGFILE_VIEW ), FALSE );
    }

    hMenu = GetSystemMenu( hwnd, FALSE );
    if (hMenu != NULL) {
        AppendMenu( hMenu, MF_SEPARATOR, 0, NULL );
        AppendMenu( hMenu, MF_STRING, ID_ABOUT, LoadRcString( IDS_ABOUT ) );
    }

    return;
}

BOOL
GetDialogValues(
    HWND hwnd
    )

/*++

Routine Description:

    Retrieves the values in the DRWTSN32 dialog controls and saves
    them in the registry.

Arguments:

    hwnd       - window handle to the dialog

Return Value:

    TRUE       - all values were retrieved and saved
    FALSE      - an error occurred

--*/

{
    OPTIONS     o;
    _TCHAR      buf[256];
    DWORD       dwFa;
    PTSTR       p,p1;
    _TCHAR      szDrive    [_MAX_DRIVE];
    _TCHAR      szDir      [_MAX_DIR];
    _TCHAR      szPath     [MAX_PATH];


    RegInitialize( &o );

    GetDlgItemText( hwnd, ID_LOGPATH, buf, sizeof(buf) / sizeof(_TCHAR) );
    p = ExpandPath( buf );
    if (p) {
        dwFa = GetFileAttributes( p );
        free( p );
    } else {
        dwFa = GetFileAttributes( buf );
    }
    if ((dwFa == 0xffffffff) || (!(dwFa&FILE_ATTRIBUTE_DIRECTORY))) {
        NonFatalError( LoadRcString(IDS_INVALID_PATH) );
        return FALSE;
    }
    if (_tcslen(buf) > 0) {
        _tcscpy( o.szLogPath, buf );
    }

    o.fCrash = SendMessage( GetDlgItem( hwnd, ID_CRASH ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;

    GetDlgItemText( hwnd, ID_CRASH_DUMP, buf, sizeof(buf) / sizeof(_TCHAR) );
    if (o.fCrash) {
        p = ExpandPath( buf );
        if (p) {
            dwFa = GetFileAttributes( p );
            free( p );
        } else {
            dwFa = GetFileAttributes( buf );
        }
        if (dwFa == 0xffffffff) {
            //
            // file does not exist, check to see if the dir is ok
            //
            p = ExpandPath( buf );
            if (p) {
                p1 = p;
            } else {
                p1 = buf;
            }
            _tsplitpath( p1, szDrive, szDir, NULL, NULL );
            _tmakepath( szPath, szDrive, szDir, NULL, NULL );
            if (p) {
                free( p );
            }
            dwFa = GetFileAttributes( szPath );
            if (dwFa == 0xffffffff) {
                NonFatalError( LoadRcString(IDS_INVALID_CRASH_PATH) );
                return FALSE;
            }
        } else if (dwFa & FILE_ATTRIBUTE_DIRECTORY) {
            NonFatalError( LoadRcString(IDS_INVALID_CRASH_PATH) );
            return FALSE;
        }
        if (_tcslen(buf) > 0) {
            _tcscpy( o.szCrashDump, buf );
        }
        if (SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULL_OLD ), BM_GETCHECK, 0, 0 )) {
            o.dwType = FullDump;
        } else if (SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_MINI ), BM_GETCHECK, 0, 0 )) {
            o.dwType = MiniDump;
        } else if (SendMessage( GetDlgItem( hwnd, ID_DUMP_TYPE_FULLMINI ), BM_GETCHECK, 0, 0 )) {
            o.dwType = FullMiniDump;
        } 
    }

    GetDlgItemText( hwnd, ID_WAVE_FILE, buf, sizeof(buf) / sizeof(_TCHAR) );
    if (_tcslen(buf) > 0) {
        dwFa = GetFileAttributes( buf );
        if ((dwFa == 0xffffffff) || (dwFa&FILE_ATTRIBUTE_DIRECTORY)) {
            NonFatalError( LoadRcString(IDS_INVALID_WAVE) );
            return FALSE;
        }
    }

    _tcscpy( o.szWaveFile, buf );

    GetDlgItemText( hwnd, ID_NUM_CRASHES, buf, sizeof(buf) / sizeof(_TCHAR) );
    o.dwMaxCrashes = (DWORD) _ttol( buf );

    GetDlgItemText( hwnd, ID_INSTRUCTIONS, buf, sizeof(buf) / sizeof(_TCHAR) );
    o.dwInstructions = (DWORD) _ttol( buf );

    o.fDumpSymbols = SendMessage( GetDlgItem( hwnd, ID_DUMPSYMBOLS ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fDumpAllThreads = SendMessage( GetDlgItem( hwnd, ID_DUMPALLTHREADS ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fAppendToLogFile = SendMessage( GetDlgItem( hwnd, ID_APPENDTOLOGFILE ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fVisual = SendMessage( GetDlgItem( hwnd, ID_VISUAL ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;
    o.fSound = SendMessage( GetDlgItem( hwnd, ID_SOUND ), BM_GETCHECK, 0, 0 ) ? TRUE : FALSE;

    RegSave( &o );

    return TRUE;
}

BOOL
CALLBACK
EnumCrashesForViewer(
    PCRASHINFO crashInfo
    )

/*++

Routine Description:

    Enumeration function for crash records.  This function is called
    once for each crash record.  This function looks for s specific crash
    that is identified by the crashIndex.

Arguments:

    crashInfo      - pointer to a CRASHINFO structure

Return Value:

    TRUE           - caller should continue calling the enum procedure
    FALSE          - caller should stop calling the enum procedure

--*/

{
    PWSTR p;

    if ((crashInfo->dwIndex == crashInfo->dwIndexDesired) &&
        (crashInfo->dwCrashDataSize > 0) ) {
        p = (PWSTR)crashInfo->pCrashData;
        crashInfo->pCrashData = (PBYTE)
            calloc( crashInfo->dwCrashDataSize+10, sizeof(BYTE) );
        if (crashInfo->pCrashData != NULL) {
            if (IsTextUnicode(p, crashInfo->dwCrashDataSize, NULL)) {
                WideCharToMultiByte(CP_ACP, WC_SEPCHARS | WC_COMPOSITECHECK,
                                    p, crashInfo->dwCrashDataSize,
                                    (LPSTR)crashInfo->pCrashData, crashInfo->dwCrashDataSize + 10, NULL, NULL);
            } else {
                memcpy( crashInfo->pCrashData, p, crashInfo->dwCrashDataSize+10 );
            }
            crashInfo->pCrashData[crashInfo->dwCrashDataSize] = 0;
        }
        return FALSE;
    }

    crashInfo->dwIndex++;

    return TRUE;
}

INT_PTR
CALLBACK
LogFileViewerDialogProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Window procedure for the log file viewer dialog box.

Arguments:

    hwnd       - window handle to the dialog box

    message    - message number

    wParam     - first message parameter

    lParam     - second message parameter

Return Value:

    TRUE       - did not process the message
    FALSE      - did process the message

--*/

{
    static CRASHINFO    crashInfo;
    HFONT               hFont;

    switch (message) {
        case WM_INITDIALOG:
            hFont = (HFONT)GetStockObject( SYSTEM_FIXED_FONT );
            Assert( hFont != NULL );

            SendDlgItemMessage( hwnd,
                                ID_LOGFILE_VIEW,
                                WM_SETFONT,
                                (WPARAM) hFont,
                                (LPARAM) FALSE
                              );

            crashInfo.dwIndex = 0;
            crashInfo.dwIndexDesired = (DWORD)lParam;
            ElEnumCrashes( &crashInfo, EnumCrashesForViewer );
            if (crashInfo.dwIndex != crashInfo.dwIndexDesired) {
                MessageBeep( 0 );
                EndDialog( hwnd, 0 );
                return FALSE;
            }
            SetDlgItemTextA( hwnd, ID_LOGFILE_VIEW,
                             (LPSTR)crashInfo.pCrashData );

            return TRUE;

        case WM_COMMAND:
            if (wParam == IDOK) {
                free( crashInfo.pCrashData );
                EndDialog( hwnd, 0 );
            }
            break;
        case WM_CLOSE:
            free( crashInfo.pCrashData );
            EndDialog( hwnd, 0 );
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dumpchk\dumpchk.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <lmcons.h>
#include <lmalert.h>
#include <ntiodump.h>
#define INITGUID
#include <dbgeng.h>
#include <guiddef.h>

//
// Outputcallbacks for dumpcheck
//
class DumpChkOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

STDMETHODIMP
DumpChkOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, IID_IDebugOutputCallbacks))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
DumpChkOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
DumpChkOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
DumpChkOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    printf(Text);
    return S_OK;
}

DumpChkOutputCallbacks g_OutputCallback;

void Usage()
{
    fprintf(stderr, "Usage: DumpCheck [y <sympath>] <Dumpfile>\n");
}


BOOL
CheckDumpHeader(
    IN PTSTR DumpFileName
    )
{
    HANDLE File;
    ULONG Bytes;
    BOOL Succ;
    DUMP_HEADER Header;

    File = CreateFile (DumpFileName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (File == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Unable to open dumpfile %s\n", DumpFileName);
        return FALSE;
    }
    

    Succ = ReadFile (File,
                     &Header,
                     sizeof (Header),
                     &Bytes,
                     NULL);

    CloseHandle (File);

    if (Succ &&
        Header.Signature == DUMP_SIGNATURE &&
        Header.ValidDump == DUMP_VALID_DUMP) {
        fprintf(stderr, "Invalid dump header\n");
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

HRESULT
DoDumpCheck(
    PTSTR szDumpFile,
    PTSTR szSymbolPath
    )
{
    HRESULT Hr = E_FAIL;
    IDebugClient2 *DebugClient;
    IDebugControl2 *DebugControl;
    IDebugSymbols2 *DebugSymbols;
    IDebugSystemObjects2 *DebugSysObjects;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK) {
        fprintf(stderr, "Cannot initialize DebugClient\n");
        return Hr;
    }

    if ((DebugClient->QueryInterface(__uuidof(IDebugControl2),
                                    (void **)&DebugControl) != S_OK) ||
        (DebugClient->QueryInterface(__uuidof(IDebugSymbols2),
                                    (void **)&DebugSymbols) != S_OK) ||
        (DebugClient->QueryInterface(__uuidof(IDebugSystemObjects2),
                                    (void **)&DebugSysObjects) != S_OK)) {
        fprintf(stderr, "QueryInterface failed for DebugClient\n");
        return Hr;
    }

    fprintf(stderr,"Loading dump file %s\n", szDumpFile);
    if ((Hr = DebugClient->OpenDumpFile(szDumpFile)) != S_OK) {
        fprintf(stderr, "**** DebugClient cannot open DumpFile - error %lx\n", Hr);
        if (Hr == HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT)) {
            fprintf(stderr, "DumpFile is corrupt\n", Hr);

        }
        return Hr;
    }
    if (szSymbolPath) {
        DebugSymbols->SetSymbolPath(szSymbolPath);
    }

    DebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
    DebugClient->SetOutputCallbacks(&g_OutputCallback);

    DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, ".dumpdebug", DEBUG_EXECUTE_DEFAULT);
    g_OutputCallback.Output(0,"\n\n");
    DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "vertarget", DEBUG_EXECUTE_DEFAULT);
    
    ULONG Class, Qual;
    if ((Hr = DebugControl->GetDebuggeeType(&Class, &Qual)) != S_OK) {
        Class = Qual = 0;
    }
    if (Class == DEBUG_CLASS_USER_WINDOWS) {
        //
        // User Mode dump
        //
        
        DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "!peb", DEBUG_EXECUTE_DEFAULT);
    
    } else {
        //
        //  Kernel Mode dump
        //
        ULONG64 NtModBase = 0;

        Hr = DebugSymbols->GetModuleByModuleName("nt", 0, NULL, &NtModBase);

        if (Hr != S_OK || !NtModBase) {
            fprintf(stderr, "***** NT module not found - module list may be corrupt\n");
        } else {
            DebugControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, "lmt", DEBUG_EXECUTE_DEFAULT);
        }

        ULONG ThreadId;
        Hr = DebugSysObjects->GetCurrentThreadId(&ThreadId);
        if (Hr != S_OK) {
            fprintf(stderr, "***** Cannot get current thread ID, dump may be corrupt\n");
        }
    }
    g_OutputCallback.Output(0,"Finished dump check\n");
    
    DebugSysObjects->Release();
    DebugControl->Release();
    DebugSymbols->Release();
    DebugClient->Release();
    return S_OK;
}

void
__cdecl
main (
    int Argc,
    PCHAR *Argv
    )

{
    LONG arg;
    PCHAR DumpFileName = NULL;
    PCHAR SymbolPath = NULL;
    for (arg = 1; arg < Argc; arg++) {
        if (Argv[arg][0] == '-' || Argv[arg][0] == '/') {
            switch (Argv[arg][1]) {
            case 'y':
            case 'Y':
                if (++arg < Argc) {
                    SymbolPath = Argv[arg];
                }
                break;
            default:
                break;
            }
        } else {
            // Its a dumpfile name
            DumpFileName = Argv[arg];
        }
    }

    if (!DumpFileName) {
        Usage();
        return;
    }
    DoDumpCheck(DumpFileName, SymbolPath);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dumpconv\exe\dumpconv.cpp ===
//-----------------------------------------------------------------------
// @doc
//
// @module convert crash dump to triage dump for crash dump utilities
//
// Copyright 1999 Microsoft Corporation.  All Rights Reserved
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <tchar.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgeng.h>

BOOL
DoConversion(
    LPSTR szInputDumpFile,          // full or kernel dump
    HANDLE OutputDumpFile        // triage dump file
    );

void Usage()
{
    fprintf(stderr, "dmpconv -i input_dump_file -o output_dump_file\n");
    fprintf(stderr, "\tinput dump file is full or kernel crash dump.\n");
    fprintf(stderr, "\toutput is triage crash dump.\n");
}

int
WINAPIV
main(
    int argc,
    PTSTR argv[ ],
    PTSTR envp[]
    )
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    char *szInputDumpFile = NULL;
    char *szOutputTriageDumpFile = NULL;
    int iarg;

    for(iarg = 1; iarg < argc; iarg++)
    {
        if (argv[iarg][0] == '/' ||
            argv[iarg][0] == '-')
        {
            if (_tcslen(argv[iarg]) < 2)
            {
                Usage();
                exit(-1);
            }

            switch(argv[iarg][1])
            {
                default:
                    Usage();
                    exit(-1);

                case 'i':
                case 'I':
                    szInputDumpFile = argv[++iarg];
                    break;

                case 'o':
                case 'O':
                    szOutputTriageDumpFile = argv[++iarg];
                    break;
            }
        }
        else
        {
            Usage();
            exit(-1);
        }
    }

    if (szInputDumpFile == NULL ||
        szOutputTriageDumpFile == NULL)
    {
        Usage();
        exit(-1);
    }


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }

    if (DebugClient->QueryInterface(__uuidof(IDebugControl),
                                    (void **)&DebugControl) == S_OK)
    {
        if (DebugClient->OpenDumpFile(szInputDumpFile) == S_OK)
        {
            // Optional.  Conversion does not require symbols
            //if (DebugSymbols->SetSymbolPath("C:\\") == S_OK)

            DebugControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);

            if (DebugClient->WriteDumpFile(szOutputTriageDumpFile,
                                           DEBUG_DUMP_SMALL) == S_OK)
            {
                Hr = S_OK;
            }
        }

        DebugControl->Release();
    }

    DebugClient->Release();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dumpconv\lib\data.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <tchar.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <triage.h>
#include <crash.h>
#include <ntiodump.h>
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"

#if 0
KDDEBUGGER_DATA64 NT5FreeUPdata = {
    {0},          // Header;
    0x80400000,   // KernBase;
    0x80452e70,   // BreakpointWithStatus;
    0,            // SavedContext;
    0,            // ThCallbackStack;
    0,            // NextCallback;
    0,            // FramePointer;
    0,            // PaeEnabled:1;
    0x80401732,   // KiCallUserMode;
    0x77f9fb70,   // KeUserCallbackDispatcher;
    0x8046a4c0,   // PsLoadedModuleList;
    0x8046a180,   // PsActiveProcessHead;
    0x80469a28,   // PspCidTable;
    0x804733b0,   // ExpSystemResourcesList;
    0x80472f20,   // ExpPagedPoolDescriptor;
    0x8046aeb8,   // ExpNumberOfPagedPools;
    0x8046a864,   // KeTimeIncrement;
    0x8047e110,   // KeBugCheckCallbackListHead;
    0x8047e6c0,   // KiBugcheckData;
    0x80475950,   // IopErrorLogListHead;
    0x8046ac24,   // ObpRootDirectoryObject;
    0x8047f950,   // ObpTypeObjectType;
    0x8046ac00,   // MmSystemCacheStart;
    0x8047efd8,   // MmSystemCacheEnd;
    0x80469560,   // MmSystemCacheWs;
    0x8046a18c,   // MmPfnDatabase;
    0x8047e7f8,   // MmSystemPtesStart;
    0x8047e800,   // MmSystemPtesEnd;
    0x8046acb0,   // MmSubsectionBase;
    0x8047efe4,   // MmNumberOfPagingFiles;
    0x8046a044,   // MmLowestPhysicalPage;
    0x8046a04c,   // MmHighestPhysicalPage;
    0x8046a050,   // MmNumberOfPhysicalPages;
    0x8047f620,   // MmMaximumNonPagedPoolInBytes;
    0x8047f62c,   // MmNonPagedSystemStart;
    0x8047e750,   // MmNonPagedPoolStart;
    0x8046a85c,   // MmNonPagedPoolEnd;
    0x80471038,   // MmPagedPoolStart;
    0x8047e738,   // MmPagedPoolEnd;
    0x8047f140,   // MmPagedPoolInformation;
    0x00001000,   // MmPageSize;
    0x80470a98,   // MmSizeOfPagedPoolInBytes;
    0x80469b88,   // MmTotalCommitLimit;
    0x80469bd4,   // MmTotalCommittedPages;
    0x8046a188,   // MmSharedCommit;
    0x80469500,   // MmDriverCommit;
    0x8047ed64,   // MmProcessCommit;
    0x8047e8e4,   // MmPagedPoolCommit;
    0x8047e7a4,   // MmExtendedCommit;
    0x80470a00,   // MmZeroedPageListHead;
    0x80470a10,   // MmFreePageListHead;
    0x80470a20,   // MmStandbyPageListHead;
    0x80470a30,   // MmModifiedPageListHead;
    0x80470a40,   // MmModifiedNoWritePageListHead;
    0x80469b8c,   // MmAvailablePages;
    0x80469934,   // MmResidentAvailablePages;
    0x804725bc,   // PoolTrackTable;
    0x804725e0,   // NonPagedPoolDescriptor;
    0x8046a74c,   // MmHighestUserAddress;
    0x80469a2c,   // MmSystemRangeStart;
    0x80469ee8,   // MmUserProbeAddress;
    0x805430c0,   // KdPrintCircularBuffer;
    0x805440c0,   // KdPrintCircularBufferEnd;
    0x805440c0,   // KdPrintWritePointer;
    0x805440c4,   // KdPrintRolloverCount;
    0x804694c0,   // MmLoadedUserImageList;

    0x00000000,   // NtBuildLab;
    0x00000000,   // KiNormalSystemCall;

    0x80469ae0,   // KiProcessorBlock;
    0x8047edbc,   // MmUnloadedDrivers;
    0x8047eda0,   // MmLastUnloadedDriver;
    0x8047e754,   // MmTriageActionTaken;
    0x8047e854,   // MmSpecialPoolTag;
    0x80471de0,   // KernelVerifier;
    0x8047eab0,   // MmVerifierData;
    0x8047e870,   // MmAllocatedNonPagedPool;
    0x80469b60,   // MmPeakCommitment;
    0x8047efb8,   // MmTotalCommitLimitMaximum;
    0x8046a154    // CmNtCSDVersion
};

#endif


KDDEBUGGER_DATA64 aPServer = {{0}, 0x80400000, 0x80452f6c, 0, 0, 0, 0, 0, 0x8043141c,
0x77f9fb70, 0x80480320, 0x80481a68, 0x80481ae8,
0x804745e0, 0x80474140, 0x8046a6c8, 0x8047fb24,
0x8047f5f0, 0x8047fba0, 0x80476cf0, 0x804811c0,
0x804811b0, 0x804714d4, 0x80480598, 0x80480ee0,
0x804804e8, 0x8047fd38, 0x8047fd40, 0x8047ff40,
0x804805a4, 0x8047140c, 0x804805b8, 0x80480dd8,
0x80480d20, 0x80480d30, 0x8047fc98, 0x80471b98,
0x80471b9c, 0x8047fc80, 0x80480820, 0x00001000,
0x804714c8, 0x804804f4, 0x80480df4, 0x80472a30,
0x80480368, 0x804802c4, 0x8047fe24, 0x8047fce8,
0x80471430, 0x80471440, 0x80471450, 0x80471460,
0x80471470, 0x804805f8, 0x80480df8, 0x804737ec,
0x80473800, 0x80480ec0, 0x804806c4, 0x8048056c,
0x8053aa80, 0x8053ba80, 0x8053ba80, 0x8053ba84,
0x8047ff30, 0x00000000, 0x00000000,
0x8047f480, 0x80480384, 0x80480360, 0x8047fca0,
0x8047fd98, 0x80472a78, 0x8047ffc0, 0x8047fdb4,
0x8047fce4, 0x8048057c, 0x80474aa4};


KDDEBUGGER_DATA64 aPServer_3GB = {{0}, 0xdd400000, 0xdd452f6c, 0, 0, 0, 0, 0, 0xdd43141c,
0x00000000, 0xdd480320, 0xdd481a68, 0xdd481ae8,
0xdd4745e0, 0xdd474140, 0xdd46a6c8, 0xdd47fb24,
0xdd47f5f0, 0xdd47fba0, 0xdd476cf0, 0xdd4811c0,
0xdd4811b0, 0xdd4714d4, 0xdd480598, 0xdd480ee0,
0xdd4804e8, 0xdd47fd38, 0xdd47fd40, 0xdd47ff40,
0xdd4805a4, 0xdd47140c, 0xdd4805b8, 0xdd480dd8,
0xdd480d20, 0xdd480d30, 0xdd47fc98, 0xdd471b98,
0xdd471b9c, 0xdd47fc80, 0xdd480820, 0x00001000,
0xdd4714c8, 0xdd4804f4, 0xdd480df4, 0xdd472a30,
0xdd480368, 0xdd4802c4, 0xdd47fe24, 0xdd47fce8,
0xdd471430, 0xdd471440, 0xdd471450, 0xdd471460,
0xdd471470, 0xdd4805f8, 0xdd480df8, 0xdd4737ec,
0xdd473800, 0xdd480ec0, 0xdd4806c4, 0xdd48056c,
0xdd53aa80, 0xdd53ba80, 0xdd53ba80, 0xdd53ba84,
0xdd47ff30, 0x00000000, 0x00000000,
0xdd47f480, 0xdd480384, 0xdd480360, 0xdd47fca0,
0xdd47fd98, 0xdd472a78, 0xdd47ffc0, 0xdd47fdb4,
0xdd47fce4, 0xdd48057c, 0xdd474aa4};


KDDEBUGGER_DATA64 aPServer_PAE = {{0}, 0x80400000, 0x80455cf8, 0, 0, 0, 0, 0, 0x80431560,
0x77f9fb70, 0x804834a0, 0x80484be8, 0x80484c68,
0x80477620, 0x80477180, 0x8046d6c8, 0x80482b64,
0x80482630, 0x80482be0, 0x80479d30, 0x80484340,
0x80484330, 0x804744d4, 0x80483718, 0x80484060,
0x80483668, 0x80482e90, 0x80482e98, 0x804830a0,
0x80483724, 0x8047440c, 0x80483738, 0x80483f58,
0x80483ea0, 0x80483eb0, 0x80482dd0, 0x80474bc8,
0x80474bcc, 0x80482dbc, 0x804839a0, 0x00001000,
0x804744c8, 0x80483674, 0x80483f74, 0x80475a60,
0x804834e8, 0x80483448, 0x80482f84, 0x80482e28,
0x80474430, 0x80474440, 0x80474450, 0x80474460,
0x80474470, 0x80483778, 0x80483f78, 0x8047682c,
0x80476840, 0x80484040, 0x80483844, 0x804836ec,
0x8053e940, 0x8053f940, 0x8053f940, 0x8053f944,
0x80483090, 0x00000000, 0x00000000,
0x804824c0, 0x80483504, 0x804834e0, 0x80482dd8,
0x80482ef8, 0x80475aa8, 0x80483120, 0x80482f14,
0x80482e24, 0x804836fc, 0x80477ae4};


KDDEBUGGER_DATA64 aPServer_PAE_3GB = {{0}, 0xdd400000, 0xdd455cf8, 0, 0, 0, 0, 0, 0xdd431560,
0x77f9fb70, 0xdd4834a0, 0xdd484be8, 0xdd484c68,
0xdd477620, 0xdd477180, 0xdd46d6c8, 0xdd482b64,
0xdd482630, 0xdd482be0, 0xdd479d30, 0xdd484340,
0xdd484330, 0xdd4744d4, 0xdd483718, 0xdd484060,
0xdd483668, 0xdd482e90, 0xdd482e98, 0xdd4830a0,
0xdd483724, 0xdd47440c, 0xdd483738, 0xdd483f58,
0xdd483ea0, 0xdd483eb0, 0xdd482dd0, 0xdd474bc8,
0xdd474bcc, 0xdd482dbc, 0xdd4839a0, 0x00001000,
0xdd4744c8, 0xdd483674, 0xdd483f74, 0xdd475a60,
0xdd4834e8, 0xdd483448, 0xdd482f84, 0xdd482e28,
0xdd474430, 0xdd474440, 0xdd474450, 0xdd474460,
0xdd474470, 0xdd483778, 0xdd483f78, 0xdd47682c,
0xdd476840, 0xdd484040, 0xdd483844, 0xdd4836ec,
0xdd53e940, 0xdd53f940, 0xdd53f940, 0xdd53f944,
0xdd483090, 0x00000000, 0x00000000,
0xdd4824c0, 0xdd483504, 0xdd4834e0, 0xdd482dd8,
0xdd482ef8, 0xdd475aa8, 0xdd483120, 0xdd482f14,
0xdd482e24, 0xdd4836fc, 0xdd477ae4};


KDDEBUGGER_DATA64 bPServer = {{0}, 0x80400000, 0x80452e70, 0, 0, 0, 0, 0, 0x80401732,
0x77f9fb70, 0x8046a4c0, 0x8046a180, 0x80469a28,
0x804733b0, 0x80472f20, 0x8046aeb8, 0x8046a864,
0x8047e110, 0x8047e6c0, 0x80475950, 0x8046ac24,
0x8047f950, 0x8046ac00, 0x8047efd8, 0x80469560,
0x8046a18c, 0x8047e7f8, 0x8047e800, 0x8046acb0,
0x8047efe4, 0x8046a044, 0x8046a04c, 0x8046a050,
0x8047f620, 0x8047f62c, 0x8047e750, 0x8046a85c,
0x80471038, 0x8047e738, 0x8047f140, 0x00001000,
0x80470a98, 0x80469b88, 0x80469bd4, 0x8046a188,
0x80469500, 0x8047ed64, 0x8047e8e4, 0x8047e7a4,
0x80470a00, 0x80470a10, 0x80470a20, 0x80470a30,
0x80470a40, 0x80469b8c, 0x80469934, 0x804725bc,
0x804725e0, 0x8046a74c, 0x80469a2c, 0x80469ee8,
0x805430c0, 0x805440c0, 0x805440c0, 0x805440c4,
0x804694c0, 0x00000000, 0x00000000,
0x80469ae0, 0x8047edbc, 0x8047eda0, 0x8047e754,
0x8047e854, 0x80471de0, 0x8047ea60, 0x8047e870,
0x80469b60, 0x8047efb8, 0x8046a154};


KDDEBUGGER_DATA64 bPServer_3GB = {{0}, 0xdd400000, 0xdd452e70, 0, 0, 0, 0, 0, 0xdd401732,
0x77f9fb70, 0xdd46a4c0, 0xdd46a180, 0xdd469a28,
0xdd4733b0, 0xdd472f20, 0xdd46aeb8, 0xdd46a864,
0xdd47e110, 0xdd47e6c0, 0xdd475950, 0xdd46ac24,
0xdd47f950, 0xdd46ac00, 0xdd47efd8, 0xdd469560,
0xdd46a18c, 0xdd47e7f8, 0xdd47e800, 0xdd46acb0,
0xdd47efe4, 0xdd46a044, 0xdd46a04c, 0xdd46a050,
0xdd47f620, 0xdd47f62c, 0xdd47e750, 0xdd46a85c,
0xdd471038, 0xdd47e738, 0xdd47f140, 0x00001000,
0xdd470a98, 0xdd469b88, 0xdd469bd4, 0xdd46a188,
0xdd469500, 0xdd47ed64, 0xdd47e8e4, 0xdd47e7a4,
0xdd470a00, 0xdd470a10, 0xdd470a20, 0xdd470a30,
0xdd470a40, 0xdd469b8c, 0xdd469934, 0xdd4725bc,
0xdd4725e0, 0xdd46a74c, 0xdd469a2c, 0xdd469ee8,
0xdd5430c0, 0xdd5440c0, 0xdd5440c0, 0xdd5440c4,
0xdd4694c0, 0x00000000, 0x00000000,
0xdd469ae0, 0xdd47edbc, 0xdd47eda0, 0xdd47e754,
0xdd47e854, 0xdd471de0, 0xdd47ea60, 0xdd47e870,
0xdd469b60, 0xdd47efb8, 0xdd46a154};


KDDEBUGGER_DATA64 bPServer_PAE = {{0}, 0x80400000, 0x80453674, 0, 0, 0, 0, 0, 0x8042f3ec,
0x77f9fb70, 0x8047f6a0, 0x80480de8, 0x80480e68,
0x80473820, 0x80473380, 0x8046a788, 0x8047ed64,
0x8047e830, 0x8047ede0, 0x80475f30, 0x80480540,
0x80480530, 0x8047068c, 0x8047f918, 0x80480260,
0x8047f868, 0x8047f090, 0x8047f098, 0x8047f2a0,
0x8047f924, 0x804705c4, 0x8047f938, 0x80480158,
0x804800a0, 0x804800b0, 0x8047efd0, 0x80470db8,
0x80470dbc, 0x8047efbc, 0x8047fba0, 0x00001000,
0x80470680, 0x8047f874, 0x80480174, 0x80471c50,
0x8047f6e8, 0x8047f648, 0x8047f184, 0x8047f028,
0x804705e8, 0x804705f8, 0x80470608, 0x80470618,
0x80470628, 0x8047f978, 0x80480178, 0x80472a2c,
0x80472a40, 0x80480240, 0x8047fa44, 0x8047f8ec,
0x8053a6c0, 0x8053b6c0, 0x8053b6c0, 0x8053b6c4,
0x8047f290, 0x00000000, 0x00000000,
0x8047e6c0, 0x8047f704, 0x8047f6e0, 0x8047efd8,
0x8047f0f8, 0x80471c98, 0x8047f320, 0x8047f114,
0x8047f024, 0x8047f8fc, 0x80473ce4};


KDDEBUGGER_DATA64 bPServer_PAE_3GB = {{0}, 0xdd400000, 0xdd453674, 0, 0, 0, 0, 0, 0xdd42f3ec,
0x77f9fb70, 0xdd47f6a0, 0xdd480de8, 0xdd480e68,
0xdd473820, 0xdd473380, 0xdd46a788, 0xdd47ed64,
0xdd47e830, 0xdd47ede0, 0xdd475f30, 0xdd480540,
0xdd480530, 0xdd47068c, 0xdd47f918, 0xdd480260,
0xdd47f868, 0xdd47f090, 0xdd47f098, 0xdd47f2a0,
0xdd47f924, 0xdd4705c4, 0xdd47f938, 0xdd480158,
0xdd4800a0, 0xdd4800b0, 0xdd47efd0, 0xdd470db8,
0xdd470dbc, 0xdd47efbc, 0xdd47fba0, 0x00001000,
0xdd470680, 0xdd47f874, 0xdd480174, 0xdd471c50,
0xdd47f6e8, 0xdd47f648, 0xdd47f184, 0xdd47f028,
0xdd4705e8, 0xdd4705f8, 0xdd470608, 0xdd470618,
0xdd470628, 0xdd47f978, 0xdd480178, 0xdd472a2c,
0xdd472a40, 0xdd480240, 0xdd47fa44, 0xdd47f8ec,
0xdd53a6c0, 0xdd53b6c0, 0xdd53b6c0, 0xdd53b6c4,
0xdd47f290, 0x00000000, 0x00000000,
0xdd47e6c0, 0xdd47f704, 0xdd47f6e0, 0xdd47efd8,
0xdd47f0f8, 0xdd471c98, 0xdd47f320, 0xdd47f114,
0xdd47f024, 0xdd47f8fc, 0xdd473ce4};


KDDEBUGGER_DATA64 cPSvrHF5216 = {{0}, 0x80400000, 0x80453720, 0, 0, 0, 0, 0, 0x8043152c,
0x77f9fb70, 0x80480b00, 0x80482248, 0x804822c8,
0x80474dc0, 0x80474920, 0x8046ae88, 0x80480304,
0x8047fdd0, 0x80480380, 0x804774d0, 0x804819a0,
0x80481990, 0x80471c94, 0x80480d78, 0x804816c0,
0x80480ca8, 0x80480518, 0x80480520, 0x80480720,
0x80480d84, 0x80471bcc, 0x80480d98, 0x804815b8,
0x80481500, 0x80481510, 0x80480478, 0x80472358,
0x8047235c, 0x80480460, 0x80481000, 0x00001000,
0x80471c88, 0x80480cb8, 0x804815d4, 0x804731f8,
0x80480b48, 0x80480aa4, 0x80480604, 0x804804c8,
0x80471bf0, 0x80471c00, 0x80471c10, 0x80471c20,
0x80471c30, 0x80480dd8, 0x804815d8, 0x80473fcc,
0x80473fe0, 0x804816a0, 0x80480ea4, 0x80480d4c,
0x8053b780, 0x8053c780, 0x8053c780, 0x8053c784,
0x80480710, 0x00000000, 0x00000000,
0x8047fc60, 0x80480b60, 0x80480b40, 0x80480480,
0x80480578, 0x80473240, 0x804807a0, 0x80480594,
0x804804c4, 0x80480d5c, 0x80475284};


KDDEBUGGER_DATA64 cPSvrHF5216_3GB = {{0}, 0xdd400000, 0xdd453720, 0, 0, 0, 0, 0, 0xdd43152c,
0x77f9fb70, 0xdd480b00, 0xdd482248, 0xdd4822c8,
0xdd474dc0, 0xdd474920, 0xdd46ae88, 0xdd480304,
0xdd47fdd0, 0xdd480380, 0xdd4774d0, 0xdd4819a0,
0xdd481990, 0xdd471c94, 0xdd480d78, 0xdd4816c0,
0xdd480ca8, 0xdd480518, 0xdd480520, 0xdd480720,
0xdd480d84, 0xdd471bcc, 0xdd480d98, 0xdd4815b8,
0xdd481500, 0xdd481510, 0xdd480478, 0xdd472358,
0xdd47235c, 0xdd480460, 0xdd481000, 0x00001000,
0xdd471c88, 0xdd480cb8, 0xdd4815d4, 0xdd4731f8,
0xdd480b48, 0xdd480aa4, 0xdd480604, 0xdd4804c8,
0xdd471bf0, 0xdd471c00, 0xdd471c10, 0xdd471c20,
0xdd471c30, 0xdd480dd8, 0xdd4815d8, 0xdd473fcc,
0xdd473fe0, 0xdd4816a0, 0xdd480ea4, 0xdd480d4c,
0xdd53b780, 0xdd53c780, 0xdd53c780, 0xdd53c784,
0xdd480710, 0x00000000, 0x00000000,
0xdd47fc60, 0xdd480b60, 0xdd480b40, 0xdd480480,
0xdd480578, 0xdd473240, 0xdd4807a0, 0xdd480594,
0xdd4804c4, 0xdd480d5c, 0xdd475284};


KDDEBUGGER_DATA64 cPSvrHF5216_PAE = {{0}, 0x80400000, 0x804564a4, 0, 0, 0, 0, 0, 0x80431674,
0x77f9fb70, 0x80483c80, 0x804853c8, 0x80485448,
0x80477e00, 0x80477960, 0x8046de88, 0x80483344,
0x80482e10, 0x804833c0, 0x8047a510, 0x80484b20,
0x80484b10, 0x80474c94, 0x80483ef8, 0x80484840,
0x80483e28, 0x80483670, 0x80483678, 0x80483880,
0x80483f04, 0x80474bcc, 0x80483f18, 0x80484738,
0x80484680, 0x80484690, 0x804835b0, 0x80475388,
0x8047538c, 0x8048359c, 0x80484180, 0x00001000,
0x80474c88, 0x80483e38, 0x80484754, 0x80476228,
0x80483cc8, 0x80483c28, 0x80483764, 0x80483608,
0x80474bf0, 0x80474c00, 0x80474c10, 0x80474c20,
0x80474c30, 0x80483f58, 0x80484758, 0x8047700c,
0x80477020, 0x80484820, 0x80484024, 0x80483ecc,
0x8053f640, 0x80540640, 0x80540640, 0x80540644,
0x80483870, 0x00000000, 0x00000000,
0x80482ca0, 0x80483ce0, 0x80483cc0, 0x804835b8,
0x804836d8, 0x80476270, 0x80483900, 0x804836f4,
0x80483604, 0x80483edc, 0x804782c4};


KDDEBUGGER_DATA64 cPSvrHF5216_PAE_3G = {{0}, 0xdd400000, 0xdd4564a4, 0, 0, 0, 0, 0, 0xdd431674,
0x00000000, 0xdd483c80, 0xdd4853c8, 0xdd485448,
0xdd477e00, 0xdd477960, 0xdd46de88, 0xdd483344,
0xdd482e10, 0xdd4833c0, 0xdd47a510, 0xdd484b20,
0xdd484b10, 0xdd474c94, 0xdd483ef8, 0xdd484840,
0xdd483e28, 0xdd483670, 0xdd483678, 0xdd483880,
0xdd483f04, 0xdd474bcc, 0xdd483f18, 0xdd484738,
0xdd484680, 0xdd484690, 0xdd4835b0, 0xdd475388,
0xdd47538c, 0xdd48359c, 0xdd484180, 0x00001000,
0xdd474c88, 0xdd483e38, 0xdd484754, 0xdd476228,
0xdd483cc8, 0xdd483c28, 0xdd483764, 0xdd483608,
0xdd474bf0, 0xdd474c00, 0xdd474c10, 0xdd474c20,
0xdd474c30, 0xdd483f58, 0xdd484758, 0xdd47700c,
0xdd477020, 0xdd484820, 0xdd484024, 0xdd483ecc,
0xdd53f640, 0xdd540640, 0xdd540640, 0xdd540644,
0xdd483870, 0x00000000, 0x00000000,
0xdd482ca0, 0xdd483ce0, 0xdd483cc0, 0xdd4835b8,
0xdd4836d8, 0xdd476270, 0xdd483900, 0xdd4836f4,
0xdd483604, 0xdd483edc, 0xdd4782c4};


KDDEBUGGER_DATA64 dPSvrHF5216 = {{0}, 0x80400000, 0x80450d24, 0, 0, 0, 0, 0, 0x8042f4e4,
0x77f9fb70, 0x8047c980, 0x8047e0c8, 0x8047e148,
0x80470c40, 0x804707a0, 0x80467bc8, 0x8047c184,
0x8047bc50, 0x8047c200, 0x80473350, 0x8047d820,
0x8047d810, 0x8046dacc, 0x8047cbf8, 0x8047d540,
0x8047cb28, 0x8047c398, 0x8047c3a0, 0x8047c5a0,
0x8047cc04, 0x8046da04, 0x8047cc18, 0x8047d438,
0x8047d380, 0x8047d390, 0x8047c2f8, 0x8046e1c0,
0x8046e1c4, 0x8047c2e0, 0x8047ce80, 0x00001000,
0x8046dac0, 0x8047cb38, 0x8047d454, 0x8046f068,
0x8047c9c8, 0x8047c924, 0x8047c484, 0x8047c348,
0x8046da28, 0x8046da38, 0x8046da48, 0x8046da58,
0x8046da68, 0x8047cc58, 0x8047d458, 0x8046fe4c,
0x8046fe60, 0x8047d520, 0x8047cd24, 0x8047cbcc,
0x80536ec0, 0x80537ec0, 0x80537ec0, 0x80537ec4,
0x8047c590, 0x00000000, 0x00000000,
0x8047bae0, 0x8047c9e0, 0x8047c9c0, 0x8047c300,
0x8047c3f8, 0x8046f0b0, 0x8047c620, 0x8047c414,
0x8047c344, 0x8047cbdc, 0x80471104};


KDDEBUGGER_DATA64 dPSvrHF5216_3GB = {{0}, 0xdd400000, 0xdd450d24, 0, 0, 0, 0, 0, 0xdd42f4e4,
0x00000000, 0xdd47c980, 0xdd47e0c8, 0xdd47e148,
0xdd470c40, 0xdd4707a0, 0xdd467bc8, 0xdd47c184,
0xdd47bc50, 0xdd47c200, 0xdd473350, 0xdd47d820,
0xdd47d810, 0xdd46dacc, 0xdd47cbf8, 0xdd47d540,
0xdd47cb28, 0xdd47c398, 0xdd47c3a0, 0xdd47c5a0,
0xdd47cc04, 0xdd46da04, 0xdd47cc18, 0xdd47d438,
0xdd47d380, 0xdd47d390, 0xdd47c2f8, 0xdd46e1c0,
0xdd46e1c4, 0xdd47c2e0, 0xdd47ce80, 0x00001000,
0xdd46dac0, 0xdd47cb38, 0xdd47d454, 0xdd46f068,
0xdd47c9c8, 0xdd47c924, 0xdd47c484, 0xdd47c348,
0xdd46da28, 0xdd46da38, 0xdd46da48, 0xdd46da58,
0xdd46da68, 0xdd47cc58, 0xdd47d458, 0xdd46fe4c,
0xdd46fe60, 0xdd47d520, 0xdd47cd24, 0xdd47cbcc,
0xdd536ec0, 0xdd537ec0, 0xdd537ec0, 0xdd537ec4,
0xdd47c590, 0x00000000, 0x00000000,
0xdd47bae0, 0xdd47c9e0, 0xdd47c9c0, 0xdd47c300,
0xdd47c3f8, 0xdd46f0b0, 0xdd47c620, 0xdd47c414,
0xdd47c344, 0xdd47cbdc, 0xdd471104};


KDDEBUGGER_DATA64 dPSvrHF5216_PAE = {{0}, 0x80400000, 0x80453e24, 0, 0, 0, 0, 0, 0x8042f510,
0x77f9fb70, 0x8047fe80, 0x804815c8, 0x80481648,
0x80474000, 0x80473b60, 0x8046af48, 0x8047f544,
0x8047f010, 0x8047f5c0, 0x80476710, 0x80480d20,
0x80480d10, 0x80470e4c, 0x804800f8, 0x80480a40,
0x80480028, 0x8047f870, 0x8047f878, 0x8047fa80,
0x80480104, 0x80470d84, 0x80480118, 0x80480938,
0x80480880, 0x80480890, 0x8047f7b0, 0x80471578,
0x8047157c, 0x8047f79c, 0x80480380, 0x00001000,
0x80470e40, 0x80480038, 0x80480954, 0x80472418,
0x8047fec8, 0x8047fe28, 0x8047f964, 0x8047f808,
0x80470da8, 0x80470db8, 0x80470dc8, 0x80470dd8,
0x80470de8, 0x80480158, 0x80480958, 0x8047320c,
0x80473220, 0x80480a20, 0x80480224, 0x804800cc,
0x8053b340, 0x8053c340, 0x8053c340, 0x8053c344,
0x8047fa70, 0x00000000, 0x00000000,
0x8047eea0, 0x8047fee0, 0x8047fec0, 0x8047f7b8,
0x8047f8d8, 0x80472460, 0x8047fb00, 0x8047f8f4,
0x8047f804, 0x804800dc, 0x804744c4};


KDDEBUGGER_DATA64 dPSvrHF5216_PAE_3GB = {{0}, 0xdd400000, 0xdd453e24, 0, 0, 0, 0, 0, 0xdd42f510,
0x77f9fb70, 0xdd47fe80, 0xdd4815c8, 0xdd481648,
0xdd474000, 0xdd473b60, 0xdd46af48, 0xdd47f544,
0xdd47f010, 0xdd47f5c0, 0xdd476710, 0xdd480d20,
0xdd480d10, 0xdd470e4c, 0xdd4800f8, 0xdd480a40,
0xdd480028, 0xdd47f870, 0xdd47f878, 0xdd47fa80,
0xdd480104, 0xdd470d84, 0xdd480118, 0xdd480938,
0xdd480880, 0xdd480890, 0xdd47f7b0, 0xdd471578,
0xdd47157c, 0xdd47f79c, 0xdd480380, 0x00001000,
0xdd470e40, 0xdd480038, 0xdd480954, 0xdd472418,
0xdd47fec8, 0xdd47fe28, 0xdd47f964, 0xdd47f808,
0xdd470da8, 0xdd470db8, 0xdd470dc8, 0xdd470dd8,
0xdd470de8, 0xdd480158, 0xdd480958, 0xdd47320c,
0xdd473220, 0xdd480a20, 0xdd480224, 0xdd4800cc,
0xdd53b340, 0xdd53c340, 0xdd53c340, 0xdd53c344,
0xdd47fa70, 0x00000000, 0x00000000,
0xdd47eea0, 0xdd47fee0, 0xdd47fec0, 0xdd47f7b8,
0xdd47f8d8, 0xdd472460, 0xdd47fb00, 0xdd47f8f4,
0xdd47f804, 0xdd4800dc, 0xdd4744c4};


KDDEBUGGER_DATA64 ePSvrHF5697 = {{0}, 0x80400000, 0x8045060c, 0, 0, 0, 0, 0, 0x8042f46c,
0x77f9fb70, 0x8047c240, 0x8047d988, 0x8047da08,
0x80470500, 0x80470060, 0x80467488, 0x8047ba44,
0x8047b510, 0x8047bac0, 0x80472c10, 0x8047d0e0,
0x8047d0d0, 0x8046d38c, 0x8047c4b8, 0x8047ce00,
0x8047c408, 0x8047bc58, 0x8047bc60, 0x8047be60,
0x8047c4c4, 0x8046d2c4, 0x8047c4d8, 0x8047ccf8,
0x8047cc40, 0x8047cc50, 0x8047bbb8, 0x8046da80,
0x8046da84, 0x8047bba0, 0x8047c740, 0x00001000,
0x8046d380, 0x8047c414, 0x8047cd14, 0x8046e920,
0x8047c288, 0x8047c1e4, 0x8047bd44, 0x8047bc08,
0x8046d2e8, 0x8046d2f8, 0x8046d308, 0x8046d318,
0x8046d328, 0x8047c518, 0x8047cd18, 0x8046f70c,
0x8046f720, 0x8047cde0, 0x8047c5e4, 0x8047c48c,
0x80536280, 0x80537280, 0x80537280, 0x80537284,
0x8047be50, 0x00000000, 0x00000000,
0x8047b3a0, 0x8047c2a4, 0x8047c280, 0x8047bbc0,
0x8047bcb8, 0x8046e968, 0x8047bee0, 0x8047bcd4,
0x8047bc04, 0x8047c49c, 0x804709c4};


KDDEBUGGER_DATA64 ePSvrHF5697_3GB = {{0}, 0xdd400000, 0xdd45060c, 0, 0, 0, 0, 0, 0xdd42f46c,
0x77f9fb70, 0xdd47c240, 0xdd47d988, 0xdd47da08,
0xdd470500, 0xdd470060, 0xdd467488, 0xdd47ba44,
0xdd47b510, 0xdd47bac0, 0xdd472c10, 0xdd47d0e0,
0xdd47d0d0, 0xdd46d38c, 0xdd47c4b8, 0xdd47ce00,
0xdd47c408, 0xdd47bc58, 0xdd47bc60, 0xdd47be60,
0xdd47c4c4, 0xdd46d2c4, 0xdd47c4d8, 0xdd47ccf8,
0xdd47cc40, 0xdd47cc50, 0xdd47bbb8, 0xdd46da80,
0xdd46da84, 0xdd47bba0, 0xdd47c740, 0x00001000,
0xdd46d380, 0xdd47c414, 0xdd47cd14, 0xdd46e920,
0xdd47c288, 0xdd47c1e4, 0xdd47bd44, 0xdd47bc08,
0xdd46d2e8, 0xdd46d2f8, 0xdd46d308, 0xdd46d318,
0xdd46d328, 0xdd47c518, 0xdd47cd18, 0xdd46f70c,
0xdd46f720, 0xdd47cde0, 0xdd47c5e4, 0xdd47c48c,
0xdd536280, 0xdd537280, 0xdd537280, 0xdd537284,
0xdd47be50, 0x00000000, 0x00000000,
0xdd47b3a0, 0xdd47c2a4, 0xdd47c280, 0xdd47bbc0,
0xdd47bcb8, 0xdd46e968, 0xdd47bee0, 0xdd47bcd4,
0xdd47bc04, 0xdd47c49c, 0xdd4709c4};


KDDEBUGGER_DATA64 ePSvrHF5697_PAE = {{0}, 0x80400000, 0x80453674, 0, 0, 0, 0, 0, 0x8042f3ec,
0x77f9fb70, 0x8047f6a0, 0x80480de8, 0x80480e68,
0x80473820, 0x80473380, 0x8046a788, 0x8047ed64,
0x8047e830, 0x8047ede0, 0x80475f30, 0x80480540,
0x80480530, 0x8047068c, 0x8047f918, 0x80480260,
0x8047f868, 0x8047f090, 0x8047f098, 0x8047f2a0,
0x8047f924, 0x804705c4, 0x8047f938, 0x80480158,
0x804800a0, 0x804800b0, 0x8047efd0, 0x80470db8,
0x80470dbc, 0x8047efbc, 0x8047fba0, 0x00001000,
0x80470680, 0x8047f874, 0x80480174, 0x80471c50,
0x8047f6e8, 0x8047f648, 0x8047f184, 0x8047f028,
0x804705e8, 0x804705f8, 0x80470608, 0x80470618,
0x80470628, 0x8047f978, 0x80480178, 0x80472a2c,
0x80472a40, 0x80480240, 0x8047fa44, 0x8047f8ec,
0x8053a6c0, 0x8053b6c0, 0x8053b6c0, 0x8053b6c4,
0x8047f290, 0x00000000, 0x00000000,
0x8047e6c0, 0x8047f704, 0x8047f6e0, 0x8047efd8,
0x8047f0f8, 0x80471c98, 0x8047f320, 0x8047f114,
0x8047f024, 0x8047f8fc, 0x80473ce4};


KDDEBUGGER_DATA64 ePSvrHF5697_PAE_3gb = {{0}, 0xdd400000, 0xdd453674, 0, 0, 0, 0, 0, 0xdd42f3ec,
0x77f9fb70, 0xdd47f6a0, 0xdd480de8, 0xdd480e68,
0xdd473820, 0xdd473380, 0xdd46a788, 0xdd47ed64,
0xdd47e830, 0xdd47ede0, 0xdd475f30, 0xdd480540,
0xdd480530, 0xdd47068c, 0xdd47f918, 0xdd480260,
0xdd47f868, 0xdd47f090, 0xdd47f098, 0xdd47f2a0,
0xdd47f924, 0xdd4705c4, 0xdd47f938, 0xdd480158,
0xdd4800a0, 0xdd4800b0, 0xdd47efd0, 0xdd470db8,
0xdd470dbc, 0xdd47efbc, 0xdd47fba0, 0x00001000,
0xdd470680, 0xdd47f874, 0xdd480174, 0xdd471c50,
0xdd47f6e8, 0xdd47f648, 0xdd47f184, 0xdd47f028,
0xdd4705e8, 0xdd4705f8, 0xdd470608, 0xdd470618,
0xdd470628, 0xdd47f978, 0xdd480178, 0xdd472a2c,
0xdd472a40, 0xdd480240, 0xdd47fa44, 0xdd47f8ec,
0xdd53a6c0, 0xdd53b6c0, 0xdd53b6c0, 0xdd53b6c4,
0xdd47f290, 0x00000000, 0x00000000,
0xdd47e6c0, 0xdd47f704, 0xdd47f6e0, 0xdd47efd8,
0xdd47f0f8, 0xdd471c98, 0xdd47f320, 0xdd47f114,
0xdd47f024, 0xdd47f8fc, 0xdd473ce4};


KDDEBUGGER_DATA64 fPSvrHF5697 = {{0}, 0x80400000, 0x80453020, 0, 0, 0, 0, 0, 0x804314d0,
0x77f9fb70, 0x80480400, 0x80481b48, 0x80481bc8,
0x804746c0, 0x80474220, 0x8046a788, 0x8047fc04,
0x8047f6d0, 0x8047fc80, 0x80476dd0, 0x804812a0,
0x80481290, 0x80471594, 0x80480678, 0x80480fc0,
0x804805c8, 0x8047fe18, 0x8047fe20, 0x80480020,
0x80480684, 0x804714cc, 0x80480698, 0x80480eb8,
0x80480e00, 0x80480e10, 0x8047fd78, 0x80471c58,
0x80471c5c, 0x8047fd60, 0x80480900, 0x00001000,
0x80471588, 0x804805d4, 0x80480ed4, 0x80472af0,
0x80480448, 0x804803a4, 0x8047ff04, 0x8047fdc8,
0x804714f0, 0x80471500, 0x80471510, 0x80471520,
0x80471530, 0x804806d8, 0x80480ed8, 0x804738cc,
0x804738e0, 0x80480fa0, 0x804807a4, 0x8048064c,
0x8053ab80, 0x8053bb80, 0x8053bb80, 0x8053bb84,
0x80480010, 0x00000000, 0x00000000,
0x8047f560, 0x80480464, 0x80480440, 0x8047fd80,
0x8047fe78, 0x80472b38, 0x804800a0, 0x8047fe94,
0x8047fdc4, 0x8048065c, 0x80474b84};


KDDEBUGGER_DATA64 fPSvrHF5697_3GB = {{0}, 0xdd400000, 0xdd453020, 0, 0, 0, 0, 0, 0xdd4314d0,
0x00000000, 0xdd480400, 0xdd481b48, 0xdd481bc8,
0xdd4746c0, 0xdd474220, 0xdd46a788, 0xdd47fc04,
0xdd47f6d0, 0xdd47fc80, 0xdd476dd0, 0xdd4812a0,
0xdd481290, 0xdd471594, 0xdd480678, 0xdd480fc0,
0xdd4805c8, 0xdd47fe18, 0xdd47fe20, 0xdd480020,
0xdd480684, 0xdd4714cc, 0xdd480698, 0xdd480eb8,
0xdd480e00, 0xdd480e10, 0xdd47fd78, 0xdd471c58,
0xdd471c5c, 0xdd47fd60, 0xdd480900, 0x00001000,
0xdd471588, 0xdd4805d4, 0xdd480ed4, 0xdd472af0,
0xdd480448, 0xdd4803a4, 0xdd47ff04, 0xdd47fdc8,
0xdd4714f0, 0xdd471500, 0xdd471510, 0xdd471520,
0xdd471530, 0xdd4806d8, 0xdd480ed8, 0xdd4738cc,
0xdd4738e0, 0xdd480fa0, 0xdd4807a4, 0xdd48064c,
0xdd53ab80, 0xdd53bb80, 0xdd53bb80, 0xdd53bb84,
0xdd480010, 0x00000000, 0x00000000,
0xdd47f560, 0xdd480464, 0xdd480440, 0xdd47fd80,
0xdd47fe78, 0xdd472b38, 0xdd4800a0, 0xdd47fe94,
0xdd47fdc4, 0xdd48065c, 0xdd474b84};


KDDEBUGGER_DATA64 fPSvrHF5697_PAE = {{0}, 0x80400000, 0x80455cf8, 0, 0, 0, 0, 0, 0x80431560,
0x00000000, 0x804834a0, 0x80484be8, 0x80484c68,
0x80477620, 0x80477180, 0x8046d6c8, 0x80482b64,
0x80482630, 0x80482be0, 0x80479d30, 0x80484340,
0x80484330, 0x804744d4, 0x80483718, 0x80484060,
0x80483668, 0x80482e90, 0x80482e98, 0x804830a0,
0x80483724, 0x8047440c, 0x80483738, 0x80483f58,
0x80483ea0, 0x80483eb0, 0x80482dd0, 0x80474bc8,
0x80474bcc, 0x80482dbc, 0x804839a0, 0x00001000,
0x804744c8, 0x80483674, 0x80483f74, 0x80475a60,
0x804834e8, 0x80483448, 0x80482f84, 0x80482e28,
0x80474430, 0x80474440, 0x80474450, 0x80474460,
0x80474470, 0x80483778, 0x80483f78, 0x8047682c,
0x80476840, 0x80484040, 0x80483844, 0x804836ec,
0x8053e940, 0x8053f940, 0x8053f940, 0x8053f944,
0x80483090, 0x00000000, 0x00000000,
0x804824c0, 0x80483504, 0x804834e0, 0x80482dd8,
0x80482ef8, 0x80475aa8, 0x80483120, 0x80482f14,
0x80482e24, 0x804836fc, 0x80477ae4};


KDDEBUGGER_DATA64 fPSvrHF5697_PAE_3GB = {{0}, 0xdd400000, 0xdd455cf8, 0, 0, 0, 0, 0, 0xdd431560,
0x77f9fb70, 0xdd4834a0, 0xdd484be8, 0xdd484c68,
0xdd477620, 0xdd477180, 0xdd46d6c8, 0xdd482b64,
0xdd482630, 0xdd482be0, 0xdd479d30, 0xdd484340,
0xdd484330, 0xdd4744d4, 0xdd483718, 0xdd484060,
0xdd483668, 0xdd482e90, 0xdd482e98, 0xdd4830a0,
0xdd483724, 0xdd47440c, 0xdd483738, 0xdd483f58,
0xdd483ea0, 0xdd483eb0, 0xdd482dd0, 0xdd474bc8,
0xdd474bcc, 0xdd482dbc, 0xdd4839a0, 0x00001000,
0xdd4744c8, 0xdd483674, 0xdd483f74, 0xdd475a60,
0xdd4834e8, 0xdd483448, 0xdd482f84, 0xdd482e28,
0xdd474430, 0xdd474440, 0xdd474450, 0xdd474460,
0xdd474470, 0xdd483778, 0xdd483f78, 0xdd47682c,
0xdd476840, 0xdd484040, 0xdd483844, 0xdd4836ec,
0xdd53e940, 0xdd53f940, 0xdd53f940, 0xdd53f944,
0xdd483090, 0x00000000, 0x00000000,
0xdd4824c0, 0xdd483504, 0xdd4834e0, 0xdd482dd8,
0xdd482ef8, 0xdd475aa8, 0xdd483120, 0xdd482f14,
0xdd482e24, 0xdd4836fc, 0xdd477ae4};


KDDEBUGGER_DATA64 gPSvrHF5844 = {{0}, 0x80400000, 0x80453720, 0, 0, 0, 0, 0, 0x8043152c,
0x00000000, 0x80480b00, 0x80482248, 0x804822c8,
0x80474dc0, 0x80474920, 0x8046ae88, 0x80480304,
0x8047fdd0, 0x80480380, 0x804774d0, 0x804819a0,
0x80481990, 0x80471c94, 0x80480d78, 0x804816c0,
0x80480ca8, 0x80480518, 0x80480520, 0x80480720,
0x80480d84, 0x80471bcc, 0x80480d98, 0x804815b8,
0x80481500, 0x80481510, 0x80480478, 0x80472358,
0x8047235c, 0x80480460, 0x80481000, 0x00001000,
0x80471c88, 0x80480cb8, 0x804815d4, 0x804731f8,
0x80480b48, 0x80480aa4, 0x80480604, 0x804804c8,
0x80471bf0, 0x80471c00, 0x80471c10, 0x80471c20,
0x80471c30, 0x80480dd8, 0x804815d8, 0x80473fcc,
0x80473fe0, 0x804816a0, 0x80480ea4, 0x80480d4c,
0x8053b780, 0x8053c780, 0x8053c780, 0x8053c784,
0x80480710, 0x00000000, 0x00000000,
0x8047fc60, 0x80480b60, 0x80480b40, 0x80480480,
0x80480578, 0x80473240, 0x804807a0, 0x80480594,
0x804804c4, 0x80480d5c, 0x80475284};


KDDEBUGGER_DATA64 gPSvrHF58443GB = {{0}, 0xdd400000, 0xdd453720, 0, 0, 0, 0, 0, 0xdd43152c,
0x00000000, 0xdd480b00, 0xdd482248, 0xdd4822c8,
0xdd474dc0, 0xdd474920, 0xdd46ae88, 0xdd480304,
0xdd47fdd0, 0xdd480380, 0xdd4774d0, 0xdd4819a0,
0xdd481990, 0xdd471c94, 0xdd480d78, 0xdd4816c0,
0xdd480ca8, 0xdd480518, 0xdd480520, 0xdd480720,
0xdd480d84, 0xdd471bcc, 0xdd480d98, 0xdd4815b8,
0xdd481500, 0xdd481510, 0xdd480478, 0xdd472358,
0xdd47235c, 0xdd480460, 0xdd481000, 0x00001000,
0xdd471c88, 0xdd480cb8, 0xdd4815d4, 0xdd4731f8,
0xdd480b48, 0xdd480aa4, 0xdd480604, 0xdd4804c8,
0xdd471bf0, 0xdd471c00, 0xdd471c10, 0xdd471c20,
0xdd471c30, 0xdd480dd8, 0xdd4815d8, 0xdd473fcc,
0xdd473fe0, 0xdd4816a0, 0xdd480ea4, 0xdd480d4c,
0xdd53b780, 0xdd53c780, 0xdd53c780, 0xdd53c784,
0xdd480710, 0x00000000, 0x00000000,
0xdd47fc60, 0xdd480b60, 0xdd480b40, 0xdd480480,
0xdd480578, 0xdd473240, 0xdd4807a0, 0xdd480594,
0xdd4804c4, 0xdd480d5c, 0xdd475284};


KDDEBUGGER_DATA64 gPSvrHF5844_PAE = {{0}, 0x80400000, 0x804564a4, 0, 0, 0, 0, 0, 0x80431674,
0x00000000, 0x80483c80, 0x804853c8, 0x80485448,
0x80477e00, 0x80477960, 0x8046de88, 0x80483344,
0x80482e10, 0x804833c0, 0x8047a510, 0x80484b20,
0x80484b10, 0x80474c94, 0x80483ef8, 0x80484840,
0x80483e28, 0x80483670, 0x80483678, 0x80483880,
0x80483f04, 0x80474bcc, 0x80483f18, 0x80484738,
0x80484680, 0x80484690, 0x804835b0, 0x80475388,
0x8047538c, 0x8048359c, 0x80484180, 0x00001000,
0x80474c88, 0x80483e38, 0x80484754, 0x80476228,
0x80483cc8, 0x80483c28, 0x80483764, 0x80483608,
0x80474bf0, 0x80474c00, 0x80474c10, 0x80474c20,
0x80474c30, 0x80483f58, 0x80484758, 0x8047700c,
0x80477020, 0x80484820, 0x80484024, 0x80483ecc,
0x8053f640, 0x80540640, 0x80540640, 0x80540644,
0x80483870, 0x00000000, 0x00000000,
0x80482ca0, 0x80483ce0, 0x80483cc0, 0x804835b8,
0x804836d8, 0x80476270, 0x80483900, 0x804836f4,
0x80483604, 0x80483edc, 0x804782c4};


KDDEBUGGER_DATA64 gPSvrHF5844_PAE_3GB = {{0}, 0xdd400000, 0xdd4564a4, 0, 0, 0, 0, 0, 0xdd431674,
0x77f9fb70, 0xdd483c80, 0xdd4853c8, 0xdd485448,
0xdd477e00, 0xdd477960, 0xdd46de88, 0xdd483344,
0xdd482e10, 0xdd4833c0, 0xdd47a510, 0xdd484b20,
0xdd484b10, 0xdd474c94, 0xdd483ef8, 0xdd484840,
0xdd483e28, 0xdd483670, 0xdd483678, 0xdd483880,
0xdd483f04, 0xdd474bcc, 0xdd483f18, 0xdd484738,
0xdd484680, 0xdd484690, 0xdd4835b0, 0xdd475388,
0xdd47538c, 0xdd48359c, 0xdd484180, 0x00001000,
0xdd474c88, 0xdd483e38, 0xdd484754, 0xdd476228,
0xdd483cc8, 0xdd483c28, 0xdd483764, 0xdd483608,
0xdd474bf0, 0xdd474c00, 0xdd474c10, 0xdd474c20,
0xdd474c30, 0xdd483f58, 0xdd484758, 0xdd47700c,
0xdd477020, 0xdd484820, 0xdd484024, 0xdd483ecc,
0xdd53f640, 0xdd540640, 0xdd540640, 0xdd540644,
0xdd483870, 0x00000000, 0x00000000,
0xdd482ca0, 0xdd483ce0, 0xdd483cc0, 0xdd4835b8,
0xdd4836d8, 0xdd476270, 0xdd483900, 0xdd4836f4,
0xdd483604, 0xdd483edc, 0xdd4782c4};


KDDEBUGGER_DATA64 hPSvrHF5844 = {{0}, 0x80400000, 0x80450d24, 0, 0, 0, 0, 0, 0x8042f4e4,
0x00000000, 0x8047c980, 0x8047e0c8, 0x8047e148,
0x80470c40, 0x804707a0, 0x80467bc8, 0x8047c184,
0x8047bc50, 0x8047c200, 0x80473350, 0x8047d820,
0x8047d810, 0x8046dacc, 0x8047cbf8, 0x8047d540,
0x8047cb28, 0x8047c398, 0x8047c3a0, 0x8047c5a0,
0x8047cc04, 0x8046da04, 0x8047cc18, 0x8047d438,
0x8047d380, 0x8047d390, 0x8047c2f8, 0x8046e1c0,
0x8046e1c4, 0x8047c2e0, 0x8047ce80, 0x00001000,
0x8046dac0, 0x8047cb38, 0x8047d454, 0x8046f068,
0x8047c9c8, 0x8047c924, 0x8047c484, 0x8047c348,
0x8046da28, 0x8046da38, 0x8046da48, 0x8046da58,
0x8046da68, 0x8047cc58, 0x8047d458, 0x8046fe4c,
0x8046fe60, 0x8047d520, 0x8047cd24, 0x8047cbcc,
0x80536ec0, 0x80537ec0, 0x80537ec0, 0x80537ec4,
0x8047c590, 0x00000000, 0x00000000,
0x8047bae0, 0x8047c9e0, 0x8047c9c0, 0x8047c300,
0x8047c3f8, 0x8046f0b0, 0x8047c620, 0x8047c414,
0x8047c344, 0x8047cbdc, 0x80471104};


KDDEBUGGER_DATA64 hPSvrHF5844_3GB = {{0}, 0xdd400000, 0xdd450d24, 0, 0, 0, 0, 0, 0xdd42f4e4,
0x00000000, 0xdd47c980, 0xdd47e0c8, 0xdd47e148,
0xdd470c40, 0xdd4707a0, 0xdd467bc8, 0xdd47c184,
0xdd47bc50, 0xdd47c200, 0xdd473350, 0xdd47d820,
0xdd47d810, 0xdd46dacc, 0xdd47cbf8, 0xdd47d540,
0xdd47cb28, 0xdd47c398, 0xdd47c3a0, 0xdd47c5a0,
0xdd47cc04, 0xdd46da04, 0xdd47cc18, 0xdd47d438,
0xdd47d380, 0xdd47d390, 0xdd47c2f8, 0xdd46e1c0,
0xdd46e1c4, 0xdd47c2e0, 0xdd47ce80, 0x00001000,
0xdd46dac0, 0xdd47cb38, 0xdd47d454, 0xdd46f068,
0xdd47c9c8, 0xdd47c924, 0xdd47c484, 0xdd47c348,
0xdd46da28, 0xdd46da38, 0xdd46da48, 0xdd46da58,
0xdd46da68, 0xdd47cc58, 0xdd47d458, 0xdd46fe4c,
0xdd46fe60, 0xdd47d520, 0xdd47cd24, 0xdd47cbcc,
0xdd536ec0, 0xdd537ec0, 0xdd537ec0, 0xdd537ec4,
0xdd47c590, 0x00000000, 0x00000000,
0xdd47bae0, 0xdd47c9e0, 0xdd47c9c0, 0xdd47c300,
0xdd47c3f8, 0xdd46f0b0, 0xdd47c620, 0xdd47c414,
0xdd47c344, 0xdd47cbdc, 0xdd471104};


KDDEBUGGER_DATA64 hPSvrHF5844_PAE = {{0}, 0x80400000, 0x80453e24, 0, 0, 0, 0, 0, 0x8042f510,
0x00000000, 0x8047fe80, 0x804815c8, 0x80481648,
0x80474000, 0x80473b60, 0x8046af48, 0x8047f544,
0x8047f010, 0x8047f5c0, 0x80476710, 0x80480d20,
0x80480d10, 0x80470e4c, 0x804800f8, 0x80480a40,
0x80480028, 0x8047f870, 0x8047f878, 0x8047fa80,
0x80480104, 0x80470d84, 0x80480118, 0x80480938,
0x80480880, 0x80480890, 0x8047f7b0, 0x80471578,
0x8047157c, 0x8047f79c, 0x80480380, 0x00001000,
0x80470e40, 0x80480038, 0x80480954, 0x80472418,
0x8047fec8, 0x8047fe28, 0x8047f964, 0x8047f808,
0x80470da8, 0x80470db8, 0x80470dc8, 0x80470dd8,
0x80470de8, 0x80480158, 0x80480958, 0x8047320c,
0x80473220, 0x80480a20, 0x80480224, 0x804800cc,
0x8053b340, 0x8053c340, 0x8053c340, 0x8053c344,
0x8047fa70, 0x00000000, 0x00000000,
0x8047eea0, 0x8047fee0, 0x8047fec0, 0x8047f7b8,
0x8047f8d8, 0x80472460, 0x8047fb00, 0x8047f8f4,
0x8047f804, 0x804800dc, 0x804744c4};


KDDEBUGGER_DATA64 hPSvrHF5844_PAE_3GB = {{0}, 0xdd400000, 0xdd453e24, 0, 0, 0, 0, 0, 0xdd42f510,
0x00000000, 0xdd47fe80, 0xdd4815c8, 0xdd481648,
0xdd474000, 0xdd473b60, 0xdd46af48, 0xdd47f544,
0xdd47f010, 0xdd47f5c0, 0xdd476710, 0xdd480d20,
0xdd480d10, 0xdd470e4c, 0xdd4800f8, 0xdd480a40,
0xdd480028, 0xdd47f870, 0xdd47f878, 0xdd47fa80,
0xdd480104, 0xdd470d84, 0xdd480118, 0xdd480938,
0xdd480880, 0xdd480890, 0xdd47f7b0, 0xdd471578,
0xdd47157c, 0xdd47f79c, 0xdd480380, 0x00001000,
0xdd470e40, 0xdd480038, 0xdd480954, 0xdd472418,
0xdd47fec8, 0xdd47fe28, 0xdd47f964, 0xdd47f808,
0xdd470da8, 0xdd470db8, 0xdd470dc8, 0xdd470dd8,
0xdd470de8, 0xdd480158, 0xdd480958, 0xdd47320c,
0xdd473220, 0xdd480a20, 0xdd480224, 0xdd4800cc,
0xdd53b340, 0xdd53c340, 0xdd53c340, 0xdd53c344,
0xdd47fa70, 0x00000000, 0x00000000,
0xdd47eea0, 0xdd47fee0, 0xdd47fec0, 0xdd47f7b8,
0xdd47f8d8, 0xdd472460, 0xdd47fb00, 0xdd47f8f4,
0xdd47f804, 0xdd4800dc, 0xdd4744c4};




PKDDEBUGGER_DATA64 blocks[32] = {
&aPServer,
&aPServer_3GB,
&aPServer_PAE ,
&aPServer_PAE_3GB,
&bPServer,
&bPServer_3GB,
&bPServer_PAE,
&bPServer_PAE_3GB,
&cPSvrHF5216,
&cPSvrHF5216_3GB,
&cPSvrHF5216_PAE,
&cPSvrHF5216_PAE_3G,
&dPSvrHF5216,
&dPSvrHF5216_3GB,
&dPSvrHF5216_PAE,
&dPSvrHF5216_PAE_3GB,
&ePSvrHF5697,
&ePSvrHF5697_3GB,
&ePSvrHF5697_PAE,
&ePSvrHF5697_PAE_3gb,
&fPSvrHF5697,
&fPSvrHF5697_3GB,
&fPSvrHF5697_PAE ,
&fPSvrHF5697_PAE_3GB,
&gPSvrHF5844,
&gPSvrHF58443GB,
&gPSvrHF5844_PAE,
&gPSvrHF5844_PAE_3GB,
&hPSvrHF5844,
&hPSvrHF5844_3GB,
&hPSvrHF5844_PAE,
&hPSvrHF5844_PAE_3GB};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dumpexam\dumpexam.c ===
#include <windows.h>
#include <stdio.h>

void
__cdecl
main (
    int Argc,
    PUCHAR *Argv
    )

{

    fprintf(stderr, "\n\n\n\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   This tool is no longer supported.  It's functionality has been      **\n");
    fprintf(stderr, "**   merged into the kernel debugger.  You can examine a dump file by    **\n");
    fprintf(stderr, "**   loading it in the kernel debugger                                   **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   kd -z <dump_file_name> -y <symbol_path> [-i <image_path>]           **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   and running commands such as !vm, !process, !locks, etc...          **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "**   Please refer to the debugger documentation for more information     **\n");
    fprintf(stderr, "**   on analyzing system failures.                                       **\n");
    fprintf(stderr, "**                                                                       **\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "***************************************************************************\n");
    fprintf(stderr, "\n\n\n\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dumpconv\exe\parsetables.c ===
//-----------------------------------------------------------------------
// @doc
//
// @module convert crash dump to triage dump for crash dump utilities
//
// Copyright 1999 Microsoft Corporation.  All Rights Reserved
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <tchar.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

BOOL
DoConversion(
    LPSTR szInputDumpFile,          // full or kernel dump
    HANDLE OutputDumpFile        // triage dump file
    );

void Usage()
{
    fprintf(stderr, "dmpmgr -s symbol_path -i input_dump_file -o output_dump_file\n");
    fprintf(stderr, "\tinput dump file is full or kernel crash dump.\n");
    fprintf(stderr, "\toutput is triage crash dump.\n");
    fprintf(stderr, "\tsymbol path -- must have symbols for ntoskrnl.exe.\n\n");
}

ULONG Extra[11];
ULONG Base[500];
UCHAR Output[4000];

int
WINAPIV
main(
    int argc,
    PTSTR argv[ ],
    PTSTR envp[]
    )
{

    char *szInputDumpFile = NULL;
    char *szOutputTriageDumpFile = NULL;
    char *szIniFile = NULL;
    BOOL fVerbose = 0;
    BOOL fExamine = 0;
    BOOL fBuildIniFile = 0;
    int iarg;
    HANDLE fileHandle;
    HANDLE fileHandleIn;
    UCHAR Buffer[8192];
    PUCHAR ptmp;
    ULONG cbRead;
    ULONG i;

    for(iarg = 1; iarg < argc; iarg++)
    {
        if (argv[iarg][0] == '/' ||
            argv[iarg][0] == '-')
        {
            if (_tcslen(argv[iarg]) < 2)
            {
                Usage();
                exit(-1);
            }

            switch(argv[iarg][1])
            {
                default:
                    Usage();
                    exit(-1);

                case 'i':
                case 'I':
                    szInputDumpFile = argv[++iarg];
                    break;

                case 'o':
                case 'O':
                    szOutputTriageDumpFile = argv[++iarg];
                    break;
            }
        }
        else
        {
            Usage();
            exit(-1);
        }
    }

    if (szInputDumpFile == NULL ||
            szOutputTriageDumpFile == NULL)
    {
            Usage();
            exit(-1);
    }

    fileHandleIn = CreateFileA(szInputDumpFile,
                             GENERIC_READ,
                             0,
                             NULL,
                             FILE_OPEN_IF,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

    if (fileHandleIn == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "can not open input file\n");
        exit(-1);
    }


    if (!ReadFile(fileHandleIn,
                  Buffer,
                  sizeof(Buffer),
                  &cbRead,
                  NULL))
    {
        fprintf(stderr, "can not read input file\n");
        exit(-1);
    }

    ptmp = Buffer;

    for (i=0; i<11; i++) {

        ptmp = strstr(ptmp, "kd> x");
        ptmp = strstr(ptmp, "\n");
        ptmp++;
        sscanf(ptmp, "%08lx", &Extra[i]);
    }

    ptmp = strstr(ptmp, "kd> dd");

    for (i=0; i<40; i++) {

        ptmp = strstr(ptmp, "\n");
        ptmp++;
        sscanf(ptmp, "%08lx %08lx %08lx %08lx %08lx",
               &Base[i*10], &Base[i*10 + 1], &Base[i*10 + 2], &Base[i*10 + 3], &Base[i*10 + 4]);
    }

    sprintf(Output,
            "KDDEBUGGER_DATA64 %s = {"
            "{0}, 0x%08lx, 0x%08lx, 0, 0, 0, 0, 0, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x00000000, 0x00000000,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx, 0x%08lx,\n"
            "0x%08lx, 0x%08lx, 0x%08lx};\n\n\n",
            szInputDumpFile,
            Base[13], Base[21], Base[33],
            Base[41], Base[43], Base[51], Base[53],
            Base[61], Base[63], Base[71], Base[73],
            Base[81], Base[83], Base[91], Base[93],
            Base[101], Base[103], Base[111], Base[113],
            Base[121], Base[123], Base[131], Base[133],
            Base[141], Base[143], Base[151], Base[153],
            Base[161], Base[163], Base[171], Base[173],
            Base[181], Base[183], Base[191], Base[193],
            Base[201], Base[203], Base[211], Base[213],
            Base[221], Base[223], Base[231], Base[233],
            Base[241], Base[243], Base[251], Base[253],
            Base[261], Base[263], Base[271], Base[273],
            Base[281], Base[283], Base[291], Base[293],
            Base[301], Base[303], Base[311], Base[313],
            Base[321],
            Extra[0], Extra[1], Extra[2], Extra[3], Extra[4], Extra[5], Extra[6], Extra[7],
            Extra[8], Extra[9], Extra[10]);


    //
    // Create the minidump file
    //

    fileHandle = CreateFileA(szOutputTriageDumpFile,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        exit(-1);
    }

    WriteFile(fileHandle,
              Output,
              strlen(Output),
              &cbRead,
              NULL);

    CloseHandle(fileHandle);

    exit(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\automaticsessdlg.cpp ===
// AutomaticSessDlg.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "AutomaticSessDlg.h"
#include "Emshellview.h"
#include "comdef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAutomaticSessDlg dialog

extern PEmObject GetEmObj(BSTR bstrEmObj);

CAutomaticSessDlg::CAutomaticSessDlg(PSessionSettings pSettings, VARIANT *pVar, EmObjectType type, CWnd* pParent /*=NULL*/)
	: CDialog(CAutomaticSessDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAutomaticSessDlg)
	m_bNotifyAdmin = FALSE;
	m_bMiniDump = FALSE;
	m_bUserDump = FALSE;
	m_bRecursiveMode = FALSE;
	m_strNotifyAdmin = _T("");
	m_strAltSymbolPath = _T("");
	m_bRememberSettings = FALSE;
	//}}AFX_DATA_INIT

	m_pSettings = pSettings;
	m_pECXVariantList = pVar;
	m_emSessionType = type;
}


void CAutomaticSessDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAutomaticSessDlg)
	DDX_Control(pDX, IDC_CK_RECURSIVEMODE, m_btnRecursiveMode);
	DDX_Control(pDX, IDC_CK_NOTIFYADMIN, m_btnNotifyAdmin);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_EDIT_NOTIFYADMIN, m_NotifyAdminEditControl);
	DDX_Control(pDX, IDC_CK_COMMANDSET, m_btnCommandSet);
	DDX_Control(pDX, IDC_LIST_COMMANDSET, m_mainListControl);
	DDX_Check(pDX, IDC_CK_NOTIFYADMIN, m_bNotifyAdmin);
	DDX_Check(pDX, IDC_CK_MINIDUMP, m_bMiniDump);
	DDX_Check(pDX, IDC_CK_USERDUMP, m_bUserDump);
	DDX_Check(pDX, IDC_CK_RECURSIVEMODE, m_bRecursiveMode);
	DDX_Text(pDX, IDC_EDIT_NOTIFYADMIN, m_strNotifyAdmin);
	DDX_Text(pDX, IDC_EDIT_ALTSYMBOLPATH, m_strAltSymbolPath);
	DDX_Check(pDX, IDC_CK_REMEMBERSETTINGS, m_bRememberSettings);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAutomaticSessDlg, CDialog)
	//{{AFX_MSG_MAP(CAutomaticSessDlg)
	ON_NOTIFY(NM_CLICK, IDC_LIST_COMMANDSET, OnClickListCommandset)
	ON_BN_CLICKED(IDC_CK_NOTIFYADMIN, OnCkNotifyadmin)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAutomaticSessDlg message handlers

void CAutomaticSessDlg::UpdateSessionDlgData(bool bUpdate)
{
	LVFINDINFO findInfo;
	int nIndex = 0;

	//if bUpdate is TRUE, we are loading the dialog settings from m_pSettings
	if ( bUpdate ) {
		if ( m_pSettings != NULL ) {
			m_bNotifyAdmin			= m_pSettings->dwNotifyAdmin;
			m_bMiniDump			    = m_pSettings->dwProduceMiniDump;
			m_bUserDump			    = m_pSettings->dwProduceUserDump;
			m_strNotifyAdmin		= m_pSettings->strAdminName;
			m_strAltSymbolPath		= m_pSettings->strAltSymbolPath;
			m_strSelectedCommandSet	= m_pSettings->strCommandSet;
			
			m_NotifyAdminEditControl.EnableWindow( m_bNotifyAdmin );

			if (m_emSessionType == EMOBJ_SERVICE) {
				m_bRecursiveMode		= m_pSettings->dwRecursiveMode;
				m_btnRecursiveMode.EnableWindow(TRUE);
			} else {
				m_btnRecursiveMode.SetCheck(FALSE);
				m_btnRecursiveMode.EnableWindow(FALSE);
			}

			//Create and initialize a findInfo object to retrieve the index for the item were looking for
			findInfo.flags = LVFI_STRING;
			findInfo.psz = m_strSelectedCommandSet;

			if ( m_mainListControl.GetItemCount() > 0) {
				//Search for m_strSelectedCommandSet in the list control and select it.
				nIndex = m_mainListControl.FindItem(&findInfo);

				if ( nIndex != -1 ) {
					//We have found it, now hilight it
					m_mainListControl.SetItemState( nIndex,LVIS_SELECTED | LVIS_FOCUSED , LVIS_SELECTED | LVIS_FOCUSED);
					m_strSelectedCommandSet = m_mainListControl.GetItemText(nIndex, 0);
				} else {
					//Select the only item in the list
					m_mainListControl.SetItemState( 0,LVIS_SELECTED | LVIS_FOCUSED , LVIS_SELECTED | LVIS_FOCUSED);
					m_strSelectedCommandSet = m_mainListControl.GetItemText(0, 0);
				}
			}
			else {
				//We have no items in the list, disable the okay button
				m_btnOK.EnableWindow(FALSE);
			}
		}
	}
	//if bUpdate is FALSE, we are saving the dialog settings to m_pSettings
	else {
			m_pSettings->dwNotifyAdmin		= m_bNotifyAdmin;
			m_pSettings->dwProduceMiniDump	= m_bMiniDump;
			m_pSettings->dwProduceUserDump	= m_bUserDump;
			m_pSettings->dwRecursiveMode	= m_bRecursiveMode;
			m_pSettings->strAdminName		= m_strNotifyAdmin;
			m_pSettings->strAltSymbolPath	= m_strAltSymbolPath;
			m_pSettings->strCommandSet		= m_strSelectedCommandSet;
	}
}

BOOL CAutomaticSessDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	// TODO: Add extra initialization here
	//Populate the list control with the ECX files.
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	EmObject		CurrentObj;
	CString			strDescription;
	CString			strName;

	do {
		//Check mark the command set button, but disable it
		m_btnCommandSet.SetCheck(1);
		m_btnCommandSet.EnableWindow(FALSE);

		//Add the columns to the list control
		m_mainListControl.BeginSetColumn(2);
		strName.LoadString(IDS_AUTOSESSDLG_NAME);
		strDescription.LoadString(IDS_AUTOSESSDLG_DESCRIPTION);
		m_mainListControl.AddColumn(strName);
		m_mainListControl.AddColumn(strDescription);
		m_mainListControl.EndSetColumn();
		
		m_mainListControl.ResizeColumnsFitScreen();
		m_mainListControl.SetExtendedStyle(LVS_EX_FULLROWSELECT);

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(m_pECXVariantList->parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(m_pECXVariantList->parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(m_pECXVariantList->parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy
			CurrentObj = *GetEmObj(bstrEmObj);

            if (bstrEmObj != NULL ) {
                SysFreeString( bstrEmObj );
            }

            //Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayData(&CurrentObj);
		}
		//Synchronize the dialog with the view data
		UpdateSessionDlgData();
		UpdateData(FALSE);
	} while (FALSE);

    SysFreeString( bstrEmObj );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CAutomaticSessDlg::DisplayData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	TCHAR	szPid[20]		=	{0};
	LONG	lRow			=	0L;
	int		nImage			=	0;
	CString csPROCStatus;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		_ltot(pEmObject->nId, szPid, 10);
		
		lRow = m_mainListControl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		if ( pEmObject->dwBucket1 )
			lRow = m_mainListControl.SetItemText(lRow, 1, pEmObject->szBucket1);

		hr = S_OK;
	}
	while( false );

	return hr;
}

void CAutomaticSessDlg::OnClickListCommandset(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	//Set the m_strSelectedCommandSet to the value of the currently selected item
	//in the list
	//Get the currently selected item
	POSITION pos = NULL;
	int nIndex = 0;

	do {
		pos = m_mainListControl.GetFirstSelectedItemPosition();

		if ( pos != NULL ) {
			nIndex = m_mainListControl.GetNextSelectedItem(pos);
			m_strSelectedCommandSet = m_mainListControl.GetItemText(nIndex, 0);
		}

		//Enable the Okay button
		//m
	} while ( FALSE );

	*pResult = 0;
}

void CAutomaticSessDlg::OnCkNotifyadmin() 
{
	// TODO: Add your control notification handler code here
	// The user has checked the box, enable the edit box
	UpdateData(TRUE);
	m_NotifyAdminEditControl.EnableWindow( m_bNotifyAdmin );
}

void CAutomaticSessDlg::OnOK() 
{
	// TODO: Add extra validation here
	CDialog::OnOK();

	//Store off the current settings
	UpdateSessionDlgData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\automaticsessdlg.h ===
#if !defined(AFX_AUTOMATICSESSDLG_H__2F2BFF45_5F2D_49A2_B10F_5DC50893E8F1__INCLUDED_)
#define AFX_AUTOMATICSESSDLG_H__2F2BFF45_5F2D_49A2_B10F_5DC50893E8F1__INCLUDED_

#include "emobjdef.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AutomaticSessDlg.h : header file
//

#include "genlistctrl.h"
/////////////////////////////////////////////////////////////////////////////
// CAutomaticSessDlg dialog

class CAutomaticSessDlg : public CDialog
{
// Construction
public:
	EmObjectType m_emSessionType;
	VARIANT* m_pECXVariantList;
	CString m_strSelectedCommandSet;
	PSessionSettings m_pSettings;
	void UpdateSessionDlgData(bool bUpdate = TRUE);
	CAutomaticSessDlg(PSessionSettings pSettings, VARIANT *pVar, EmObjectType type, CWnd* pParent = NULL);   // standard constructor
	HRESULT DisplayData(PEmObject pEmObject);


// Dialog Data
	//{{AFX_DATA(CAutomaticSessDlg)
	enum { IDD = IDD_AUTO_SESS_DLG };
	CButton	m_btnRecursiveMode;
	CButton	m_btnNotifyAdmin;
	CButton	m_btnOK;
	CEdit	m_NotifyAdminEditControl;
	CButton	m_btnCommandSet;
	CGenListCtrl	m_mainListControl;
	BOOL	m_bNotifyAdmin;
	BOOL	m_bMiniDump;
	BOOL	m_bUserDump;
	BOOL	m_bRecursiveMode;
	CString	m_strNotifyAdmin;
	CString	m_strAltSymbolPath;
	BOOL	m_bRememberSettings;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutomaticSessDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAutomaticSessDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickListCommandset(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCkNotifyadmin();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTOMATICSESSDLG_H__2F2BFF45_5F2D_49A2_B10F_5DC50893E8F1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\dumpconv\lib\convert.cpp ===
//-----------------------------------------------------------------------
// @doc
//
// @module convert crash dump to triage dump for crash dump utilities
//
// Copyright 1999 Microsoft Corporation.  All Rights Reserved
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <tchar.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <triage.h>
#include <crash.h>
#include <ntiodump.h>
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"


inline ALIGN_8(unsigned offset)
{
    return (offset + 7) & 0xfffffff8;
}

typedef struct _MI_TRIAGE_STORAGE
{
    ULONG Version;
    ULONG Size;
    ULONG MmSpecialPoolTag;
    ULONG MiTriageActionTaken;

    ULONG MmVerifyDriverLevel;
    ULONG KernelVerifier;
    ULONG_PTR MmMaximumNonPagedPool;
    ULONG_PTR MmAllocatedNonPagedPool;

    ULONG_PTR PagedPoolMaximum;
    ULONG_PTR PagedPoolAllocated;

    ULONG_PTR CommittedPages;
    ULONG_PTR CommittedPagesPeak;
    ULONG_PTR CommitLimitMaximum;
} MI_TRIAGE_STORAGE, *PMI_TRIAGE_STORAGE;

KDDEBUGGER_DATA64 g_DebuggerData;

extern PKDDEBUGGER_DATA64 blocks[];


#define ExtractValue(NAME, val)  {                                    \
    if (!g_DebuggerData.NAME) {                                       \
        val = 0;                                                      \
        printf("g_DebuggerData.NAME is NULL");                        \
    } else {                                                          \
        DmpReadMemory(g_DebuggerData.NAME, &(val), sizeof(val));      \
    }                                                                 \
}


//BUGBUG
#define PAGE_SHIFT 12
#define PAGE_SIZE  0x1000


#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))


const MAX_UNLOADED_NAME_LENGTH = 12;

typedef struct _DUMP_UNLOADED_DRIVERS
{
    UNICODE_STRING Name;
    WCHAR DriverName[MAX_UNLOADED_NAME_LENGTH];
    PVOID StartAddress;
    PVOID EndAddress;
} DUMP_UNLOADED_DRIVERS, *PDUMP_UNLOADED_DRIVERS;

class CCrashDumpWrapper
{
public:
    // @cmember constructor
    CCrashDumpWrapper() { }

    ~CCrashDumpWrapper() {}

    unsigned GetCallStackSize();

    unsigned GetDriverCount(PULONG cbNames);

    void WriteDriverList(BYTE *pb, unsigned offset, unsigned stringOffset);

    void WriteCurrentProcess(BYTE *pb, ULONG offset);

    void WriteUnloadedDrivers(BYTE *pb, ULONG offset);

    void WriteMmTriageInformation(BYTE *pb, ULONG offset);

};


BOOL g_fVerbose;
PDUMP_HEADER m_pHeader;
PX86_CONTEXT m_pcontext;
PEXCEPTION_RECORD m_pexception;


const unsigned MAX_TRIAGE_STACK_SIZE = 16 * 1024;

extern "C" {
// processor block.  We fill this in and it is accessed by crashlib
PVOID KiProcessors[MAXIMUM_PROCESSORS];

// ignored but needed for linking
ULONG KiPcrBaseAddress = 0;
}


#define MI_UNLOADED_DRIVERS 50

typedef struct _UNLOADED_DRIVERS {
    UNICODE_STRING Name;
    PVOID StartAddress;
    PVOID EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS, *PUNLOADED_DRIVERS;







VOID
GetCurrentThread(LPBYTE pthread)
{
    // get current processor
    unsigned iProcessor = DmpGetCurrentProcessor();

    // get KPCRB for current processor
    PX86_PARTIAL_KPRCB pkprcb = (PX86_PARTIAL_KPRCB)(KiProcessors[iProcessor]);
    ULONG64 threadAddr = 0;

    // read current thread pointer from KPCRB
    DmpReadMemory((ULONG64) &pkprcb->CurrentThread, &threadAddr, sizeof(ULONG));

    // read current thread
    DmpReadMemory(threadAddr, pthread, X86_ETHREAD_SIZE);
}


unsigned CCrashDumpWrapper::GetDriverCount(PULONG cbNames)
{

    LIST_ENTRY le;
    PLIST_ENTRY pleNext;
    PLDR_DATA_TABLE_ENTRY pdte;
    LDR_DATA_TABLE_ENTRY dte;
    unsigned cModules = 0;
    *cbNames = 0;

    // first entry is pointed to by the the PsLoadedModuleList field in the dump header
    LIST_ENTRY *pleHead = (PLIST_ENTRY) m_pHeader->PsLoadedModuleList;

    // read list element
    if (!DmpReadMemory((ULONG64) pleHead, (PVOID) &le, sizeof(LIST_ENTRY)))
    {
        printf("Could not read base of PsLoadedModuleList");
    }

    // obtain pointer to next list element
    pleNext = le.Flink;
    if (pleNext == NULL)
    {
        printf("PsLoadedModuleList is empty");
    }

    // while next list element is not pointer to headed
    while(pleNext != pleHead)
    {
        // obtain pointerr to loader entry
        pdte = CONTAINING_RECORD
                    (
                    pleNext,
                    LDR_DATA_TABLE_ENTRY,
                    InLoadOrderLinks
                    );

        // read loader entry
        if (!DmpReadMemory((ULONG64) pdte, (PVOID) &dte, sizeof(dte)))
        {
            printf("memory read failed addr=0x%08x", (ULONG)(ULONG_PTR) pdte);
        }

        // compute length of module name
        *cbNames += ALIGN_8((dte.BaseDllName.Length + 1) * sizeof(WCHAR) + sizeof(DUMP_STRING));

        // get pointer to next loader entry
        pleNext = dte.InLoadOrderLinks.Flink;


        // if name is not null then this is a valid entry
        if (dte.BaseDllName.Length >= 0 && dte.BaseDllName.Buffer != NULL)
                 cModules++;

        if (cModules > 10000)
        {
            printf("PsLoadedModuleList is empty");
            exit(-1);
        }
    }

    // return # of modules
    return cModules;
}


unsigned CCrashDumpWrapper::GetCallStackSize()
{
    BYTE thread[X86_ETHREAD_SIZE];

    // get current thread
    GetCurrentThread(thread);

    // if kernel stack is not resident, then we can't do anything
    //if (!thread.Tcb.KernelStackResident)
    //    return 0;

    // obtain stack base from thread
    ULONG StackBase = ((X86_THREAD *)(&thread[0]))->InitialStack;

    // obtain top of stack from register ESP
    ULONG_PTR StackPtr = m_pcontext->Esp;

    // make sure pointers make sense
    if (StackBase < StackPtr)
    {
        printf("Stack base pointer is invalid StackBase = %08x, esp=%08x", StackBase, StackPtr);
        return MAX_TRIAGE_STACK_SIZE;
    }

    // return stack size limited by max triage stack size (16K)
    return min((ULONG) StackBase - (ULONG) StackPtr, MAX_TRIAGE_STACK_SIZE);
}

void CCrashDumpWrapper::WriteDriverList(
    BYTE *pb,
    unsigned offset,
    unsigned stringOffset
    )
{
    PLIST_ENTRY pleNext;
    PLDR_DATA_TABLE_ENTRY pdte;
    PDUMP_DRIVER_ENTRY pdde;
    PDUMP_STRING pds;
    PDUMP_STRING pdsInitial;
    LIST_ENTRY le;
    LDR_DATA_TABLE_ENTRY dte;
    ULONG i = 0;

    // pointer to first driver entry to write out
    pdde = (PDUMP_DRIVER_ENTRY) (pb + offset);

    // pointer to first module name to write out
    pds = (PDUMP_STRING) (pb + stringOffset);
    pdsInitial = pds;

    // obtain pointer to list head from dump header
    PLIST_ENTRY pleHead = (PLIST_ENTRY) m_pHeader->PsLoadedModuleList;

    // read in list head
    if (!DmpReadMemory((ULONG64) pleHead, &le, sizeof(le)))
    {
        printf("Could not read base of the PsModuleList");
    }

    // get pointer to first link
    pleNext = le.Flink;

    while (pleNext != pleHead)
    {
        // obtain pointer to loader entry
        pdte = CONTAINING_RECORD(pleNext,
                                 LDR_DATA_TABLE_ENTRY,
                                 InLoadOrderLinks
                                 );

        // read in loader entry
        if (!DmpReadMemory((ULONG64) pdte, (PVOID) &dte, sizeof(dte)))
        {
            printf("memory read failed addr=0x%08x", (DWORD)(ULONG_PTR) pdte);
        }

        // Build the entry in the string pool. We guarantee all strings are
        // NULL terminated as well as length prefixed.
        pds->Length = dte.BaseDllName.Length / 2;

        if (!DmpReadMemory((ULONG64) dte.BaseDllName.Buffer,
                           pds->Buffer,
                           pds->Length * sizeof (WCHAR)))
        {
            printf("memory read failed addr=0x%08x", (DWORD)(ULONG_PTR) dte.BaseDllName.Buffer);
        }

        // null terminate string
        pds->Buffer[pds->Length] = '\0';

        // read in loader entry
        memcpy(&pdde->LdrEntry, &dte, sizeof(pdde->LdrEntry));

        // replace pointer to string
        pdde->DriverNameOffset = (ULONG)((ULONG_PTR) pds - (ULONG_PTR) pb);

        // get pointer to next string
        pds = (PDUMP_STRING) ALIGN_UP_POINTER(((LPBYTE) pds) + sizeof(DUMP_STRING) +
                                                  sizeof(WCHAR) * (pds->Length + 1),
                                              ULONGLONG);

        // extract timestamp and image size
        IMAGE_DOS_HEADER hdr;
        IMAGE_NT_HEADERS nthdr;
        unsigned cb;
        cb = DmpReadMemory((ULONG64) dte.DllBase, &hdr, sizeof(hdr));
        if (cb == sizeof(IMAGE_DOS_HEADER) &&
            hdr.e_magic == IMAGE_DOS_SIGNATURE &&
           (hdr.e_lfanew & 3) == 0)
        {
        cb = DmpReadMemory((ULONG64) dte.DllBase + hdr.e_lfanew, &nthdr, sizeof(nthdr));
           if (cb == sizeof(IMAGE_NT_HEADERS) &&
               nthdr.Signature == IMAGE_NT_SIGNATURE)
           {
               // repoace next link with link date timestap and image size
               pdde->LdrEntry.TimeDateStamp = nthdr.FileHeader.TimeDateStamp;
               pdde->LdrEntry.SizeOfImage = nthdr.OptionalHeader.SizeOfImage;
           }
       }


        pleNext = dte.InLoadOrderLinks.Flink;
        pdde = (PDUMP_DRIVER_ENTRY)(((PUCHAR) pdde) + sizeof(*pdde));
    }
}


void CCrashDumpWrapper::WriteCurrentProcess(BYTE *pb, ULONG offset)
{
    BYTE thread[X86_ETHREAD_SIZE];

    // get current htread
    GetCurrentThread(thread);

    // read process from pointer from thread
    DmpReadMemory((DWORD) ((X86_THREAD *)(&thread[0]))->ApcState.Process,
                  pb + offset,
                  X86_NT5_EPROCESS_SIZE);

    // validate type of object
    //if (process.Pcb.Header.Type != ProcessObject)
    //{
    //    printf("Current process object type is incorrect.  The symbols are probably wrong.");
    //}
}



void CCrashDumpWrapper::WriteUnloadedDrivers(BYTE *pb, ULONG offset)
{
    ULONG64 addr;
    ULONG i;
    ULONG Index;
    UNLOADED_DRIVERS *pud;
    UNLOADED_DRIVERS ud;
    PDUMP_UNLOADED_DRIVERS pdud;
    PVOID pvMiUnloadedDrivers;
    ULONG ulMiLastUnloadedDriver;

    // find location of unloaded drivers
    if (!(addr = g_DebuggerData.MmUnloadedDrivers))
    {
        // if can't be found then no unloaded drivers
        *(PULONG) (pb + offset) = 0;
        return;
    }
    else
        // read in pointer to start of unloaded drivers
        DmpReadMemory(addr, &pvMiUnloadedDrivers, sizeof(PVOID));

    // try finding symbol indicating offset of last unloaded driver
    if (!(addr = g_DebuggerData.MmLastUnloadedDriver))
    {
        // if not found, then no unloaded drivers
        *(PULONG) (pb + offset) = 0;
        return;
    }
    else
        // read in offset of last unloaded driver
        DmpReadMemory(addr, &ulMiLastUnloadedDriver, sizeof(ULONG));


    if (pvMiUnloadedDrivers == NULL)
    {
        // if unloaded driver pointer is null, then no unloaded drivers
        *(PULONG)(pb + offset) = 0;
        return;
    }

    // point to last unloaded drivers
    pdud = (PDUMP_UNLOADED_DRIVERS)((PULONG)(pb + offset) + 1);
    PUNLOADED_DRIVERS rgud = (PUNLOADED_DRIVERS) pvMiUnloadedDrivers;

    //
    // Write the list with the most recently unloaded driver first to the
    // least recently unloaded driver last.
    //

    Index = ulMiLastUnloadedDriver - 1;

    for (i = 0; i < MI_UNLOADED_DRIVERS; i += 1)
    {
        if (Index >= MI_UNLOADED_DRIVERS)
            Index = MI_UNLOADED_DRIVERS - 1;

        // read in unloaded driver
        if (!DmpReadMemory((ULONG64) &rgud[Index], &ud, sizeof(ud)))
        {
            printf("can't read memory from %08x", (ULONG)(ULONG_PTR)(&rgud[Index]));
        }

        // copy name lengths
        pdud->Name.MaximumLength = ud.Name.MaximumLength;
        pdud->Name.Length = ud.Name.Length;
        if (ud.Name.Buffer == NULL)
            break;

        // copy start and end address
        pdud->StartAddress = ud.StartAddress;
        pdud->EndAddress = ud.EndAddress;

        // restrict name length and maximum name length to 12 characters
        if (pdud->Name.Length > MAX_UNLOADED_NAME_LENGTH * 2)
            pdud->Name.Length = MAX_UNLOADED_NAME_LENGTH * 2;

        if (pdud->Name.MaximumLength > MAX_UNLOADED_NAME_LENGTH * 2)
            pdud->Name.MaximumLength = MAX_UNLOADED_NAME_LENGTH * 2;

        // setup pointer to driver name and read it in
        pdud->Name.Buffer = pdud->DriverName;
        if (!DmpReadMemory((ULONG64) ud.Name.Buffer,
                           pdud->Name.Buffer,
                           pdud->Name.MaximumLength))
        {
            printf("cannot read memory at address %08x", (ULONG)(ULONG64)(ud.Name.Buffer));
        }

        // move to previous driver
        pdud += 1;
        Index -= 1;
    }

    // number of drivers in the list
    *(PULONG) (pb + offset) = i;
}

void CCrashDumpWrapper::WriteMmTriageInformation(BYTE *pb, ULONG offset)
{
    MI_TRIAGE_STORAGE TriageInformation;
    ULONG64 pMmVerifierData;
    ULONG64 pvMmPagedPoolInfo;
    ULONG_PTR cbNonPagedPool;
    ULONG_PTR cbPagedPool;


    // version information
    TriageInformation.Version = 1;

    // size information
    TriageInformation.Size = sizeof(MI_TRIAGE_STORAGE);

    // get special pool tag
    ExtractValue(MmSpecialPoolTag, TriageInformation.MmSpecialPoolTag);

    // get triage action taken
    ExtractValue(MmTriageActionTaken, TriageInformation.MiTriageActionTaken);
    pMmVerifierData = g_DebuggerData.MmVerifierData;

    // read in verifier level
    // BUGBUG - should not read internal data structures in MM
    //if (pMmVerifierData)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_DRIVER_VERIFIER_DATA *) pMmVerifierData)->Level,
    //        &TriageInformation.MmVerifyDriverLevel,
    //        sizeof(TriageInformation.MmVerifyDriverLevel));
    //else
        TriageInformation.MmVerifyDriverLevel = 0;

    // read in verifier
    ExtractValue(KernelVerifier, TriageInformation.KernelVerifier);

    // read non paged pool info
    ExtractValue(MmMaximumNonPagedPoolInBytes, cbNonPagedPool);
    TriageInformation.MmMaximumNonPagedPool = cbNonPagedPool >> PAGE_SHIFT;
    ExtractValue(MmAllocatedNonPagedPool, TriageInformation.MmAllocatedNonPagedPool);

    // read paged pool info
    ExtractValue(MmSizeOfPagedPoolInBytes, cbPagedPool);
    TriageInformation.PagedPoolMaximum = cbPagedPool >> PAGE_SHIFT;
    pvMmPagedPoolInfo = g_DebuggerData.MmPagedPoolInformation;

    // BUGBUG - should not read internal data structures in MM
    //if (pvMmPagedPoolInfo)
    //    DmpReadMemory(
    //        (ULONG64) &((MM_PAGED_POOL_INFO *) pvMmPagedPoolInfo)->AllocatedPagedPool,
    //        &TriageInformation.PagedPoolAllocated,
    //        sizeof(TriageInformation.PagedPoolAllocated));
    //else
        TriageInformation.PagedPoolAllocated = 0;

    // read committed pages info
    ExtractValue(MmTotalCommittedPages, TriageInformation.CommittedPages);
    ExtractValue(MmPeakCommitment, TriageInformation.CommittedPagesPeak);
    ExtractValue(MmTotalCommitLimitMaximum, TriageInformation.CommitLimitMaximum);
    memcpy(pb + offset, &TriageInformation, sizeof(TriageInformation));
}


//-------------------------------------------------------------------
// @mfunc initialize the triage dump header from a full or kernel
// dump
//
void InitTriageDumpHeader(
    TRIAGE_DUMP *ptdh,                       // out | triage dump header
    CCrashDumpWrapper &wrapper                      // in | wrapper for dump extraction functions
    )
{
    ULONG cbNames;

    // copy build number
    ExtractValue(CmNtCSDVersion, ptdh->ServicePackBuild);

    // set size of dump to 64K
    ptdh->SizeOfDump = TRIAGE_DUMP_SIZE;

    // valid offset is last DWORD in tiage dump
    ptdh->ValidOffset = TRIAGE_DUMP_SIZE - sizeof(ULONG);

    // context offset is fixed position on first page
    ptdh->ContextOffset = FIELD_OFFSET (DUMP_HEADER, ContextRecord);

    // exception offset is fixed position on first page
    ptdh->ExceptionOffset = FIELD_OFFSET (DUMP_HEADER, Exception);

    // starting offset in triage dump follows the triage dump header
    unsigned offset = ALIGN_8(PAGE_SIZE + sizeof(TRIAGE_DUMP));

    // mm information is first
    ptdh->MmOffset = offset;

    // mm information is fixed size structure
    offset += ALIGN_8(sizeof(MI_TRIAGE_STORAGE));

    // unloaded module list is next
    ptdh->UnloadedDriversOffset = offset;
    offset += sizeof(ULONG) + MI_UNLOADED_DRIVERS * sizeof(DUMP_UNLOADED_DRIVERS);

    // processor control block is next
    ptdh->PrcbOffset = offset;
    offset += ALIGN_8(X86_NT5_KPRCB_SIZE);

    // current process is next
    ptdh->ProcessOffset = offset;
    offset += ALIGN_8(X86_NT5_EPROCESS_SIZE);

    // current thread is next
    ptdh->ThreadOffset = offset;
    offset += ALIGN_8(X86_ETHREAD_SIZE);

    // call stack is next
    ptdh->CallStackOffset = offset;
    ptdh->SizeOfCallStack = wrapper.GetCallStackSize();
    ptdh->TopOfStack = m_pcontext->Esp;
    offset += ALIGN_8(ptdh->SizeOfCallStack);         // Offset of Driver List

    // loaded driver list is next
    ptdh->DriverListOffset = offset;
    ptdh->DriverCount = wrapper.GetDriverCount(&cbNames);
    offset += ALIGN_8(ptdh->DriverCount * sizeof(DUMP_DRIVER_ENTRY));
    ptdh->StringPoolOffset = offset;
    ptdh->StringPoolSize = (ULONG) cbNames;
    ptdh->BrokenDriverOffset = 0;

    // all options are enabled
    ptdh->TriageOptions = 0xffffffff;
}

//------------------------------------------------------------------------
// @func convert a full or kernel dump to a triage dump
//
extern "C"
BOOL
DoConversion(
    LPSTR szInputDumpFile,          // full or kernel dump
    HANDLE OutputDumpFile         // triage dump file
    )
{
    PDUMP_HEADER pNewHeader;
    ULONG64 addr;
    ULONG i;

    //
    // Open the full dump files
    // crash dump wrapper has extraction functions for full dump
    //

    if (!DmpInitialize(szInputDumpFile, (PCONTEXT *)&m_pcontext, &m_pexception, (PVOID *)&m_pHeader))
    {
        return 0;
    }

    //
    // Lets determine what version of the dump file we are looking at.
    // Read the appropriate data block based on that.
    //

    if (!m_pHeader) {
        return FALSE;
    }

    if ((m_pHeader->KdDebuggerDataBlock) &&
        (m_pHeader->KdDebuggerDataBlock != 'EGAP'))
    {
        DmpReadMemory((ULONG64)(m_pHeader->KdDebuggerDataBlock),
                      &g_DebuggerData,
                      sizeof(g_DebuggerData));
    } else {

        for (i=0; i<32; i++)
        {
            if (blocks[i]->PsLoadedModuleList == m_pHeader->PsLoadedModuleList)
            {
                g_DebuggerData = *(blocks[i]);
                break;
            }
        }

        if (i == 32) {
            return 0;
        }
    }

    CCrashDumpWrapper wrapper;

    if (addr = g_DebuggerData.KiProcessorBlock)
    {
        DmpReadMemory(addr, KiProcessors, sizeof(PVOID) * MAXIMUM_PROCESSORS);

        // validate dump file and throw if invalid
        DmpValidateDumpFile(1);

        // allocate block to hold triage dump
        pNewHeader = (PDUMP_HEADER) malloc(TRIAGE_DUMP_SIZE);

        if (pNewHeader) {

            // copy in first page (common between all dumps)
            memcpy(pNewHeader, m_pHeader, PAGE_SIZE);

            // set dump type to triage dump
            pNewHeader->DumpType = DUMP_TYPE_TRIAGE;

            // triage dump header begins on second page
            TRIAGE_DUMP *ptdh = (TRIAGE_DUMP *) ((BYTE *) pNewHeader + PAGE_SIZE);

            // setup triage dump header
            InitTriageDumpHeader(ptdh, wrapper);

            // write unloaded drivers
            wrapper.WriteUnloadedDrivers((PBYTE)pNewHeader, ptdh->UnloadedDriversOffset);

            // write mm information
            wrapper.WriteMmTriageInformation((PBYTE)pNewHeader, ptdh->MmOffset);

            // write stack
            if (ptdh->SizeOfCallStack > 0)
                DmpReadMemory(ptdh->TopOfStack,
                              ((PBYTE)pNewHeader) + ptdh->CallStackOffset,
                              ptdh->SizeOfCallStack);

            // write thread
            GetCurrentThread((PBYTE)pNewHeader + ptdh->ThreadOffset);

            // write process
            wrapper.WriteCurrentProcess((PBYTE)pNewHeader, ptdh->ProcessOffset);

            // write processor control block (KPRCB)
            DmpReadMemory((ULONG64) KiProcessors[DmpGetCurrentProcessor()],
                          ((PBYTE)pNewHeader) + ptdh->PrcbOffset,
                          X86_NT5_KPRCB_SIZE);

            // write loaded driver list
            wrapper.WriteDriverList((PBYTE)pNewHeader, ptdh->DriverListOffset, ptdh->StringPoolOffset);

            // end of triage dump validated
            ((ULONG *) pNewHeader)[TRIAGE_DUMP_SIZE/sizeof(ULONG) - 1] = TRIAGE_DUMP_VALID;
            ULONG cbWritten;

            if (!WriteFile(OutputDumpFile,
                           pNewHeader,
                           TRIAGE_DUMP_SIZE,
                           &cbWritten,
                           NULL
                           ))
            {
               printf("Write to minidump file failed for reason %08x.\n",
                       GetLastError());
                return 0;
            }

            if (cbWritten != TRIAGE_DUMP_SIZE)
            {
                printf("Write to minidump failed because disk is full.\n");
                return 0;
            }
        }
    }
    else
    {
        // not much we can do without the processor block
        printf("Cannot load KiProcessorBlock");
    }

    DmpUnInitialize();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\connectiondlg.cpp ===
// ConnectionDlg.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "ConnectionDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectionDlg dialog


CConnectionDlg::CConnectionDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConnectionDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConnectionDlg)
	m_nRadio = 0;
	m_strRemoteMachineName = _T("");
	//}}AFX_DATA_INIT

	TCHAR	szCompName[255]		=	_T("");
	DWORD	dwBufSize			=	255;

	//Get the local machine name and store it away
	GetComputerName(szCompName, &dwBufSize);
	m_strLocalMachineName = szCompName;
}


void CConnectionDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectionDlg)
	DDX_Control(pDX, IDCONNECT, m_btnConnect);
	DDX_Control(pDX, IDC_RADIO_LOCAL, m_btnLocalServer);
	DDX_Control(pDX, IDC_RADIO_REMOTE, m_btnRemoteServer);
	DDX_Control(pDX, IDC_STATIC_SERVERNAME, m_idc_StaticServerName);
	DDX_Control(pDX, IDC_EDIT_SERVERNAME, m_idc_ServerName);
	DDX_Radio(pDX, IDC_RADIO_LOCAL, m_nRadio);
	DDX_Text(pDX, IDC_EDIT_SERVERNAME, m_strRemoteMachineName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectionDlg, CDialog)
	//{{AFX_MSG_MAP(CConnectionDlg)
	ON_BN_CLICKED(IDCONNECT, OnConnect)
	ON_BN_CLICKED(IDC_RADIO_REMOTE, OnRadioRemote)
	ON_BN_CLICKED(IDC_RADIO_LOCAL, OnRadioLocal)
	ON_EN_CHANGE(IDC_EDIT_SERVERNAME, OnChangeEditServername)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectionDlg message handlers

void CConnectionDlg::OnConnect() 
{
	//Update what the user has typed in with DDE
	if (!m_bLocalServer) {
		UpdateData(TRUE);
	}

	CDialog::OnOK();
}

void CConnectionDlg::OnRadioRemote() 
{
	//Disable the local button, and enable the IDC_STATIC_SERVERNAME 
	m_idc_ServerName.EnableWindow(TRUE);
	m_idc_StaticServerName.EnableWindow(TRUE);
	m_bLocalServer = FALSE;
	
	//Set the state of the connect button to false if there's no text
	m_btnConnect.EnableWindow(m_idc_ServerName.LineLength());
}

void CConnectionDlg::OnRadioLocal() 
{
	//Disable the local button, and enable the IDC_STATIC_SERVERNAME 
	m_idc_ServerName.EnableWindow(FALSE);
	m_idc_StaticServerName.EnableWindow(FALSE);
	m_bLocalServer = TRUE;
	
	//Set the state of the connect button to TRUE
	m_btnConnect.EnableWindow();
}

void CConnectionDlg::OnChangeEditServername() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CDialog::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	
	//Check to see if we have text in us.  If we do, enable the Connect button
	m_btnConnect.EnableWindow(m_idc_ServerName.LineLength());
}

BOOL CConnectionDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	m_bLocalServer = (m_btnLocalServer.GetCheck() == 1);

	//Set the state of
	m_idc_ServerName.EnableWindow(!m_bLocalServer);
	m_idc_StaticServerName.EnableWindow(!m_bLocalServer);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emlistctrl.h ===
#if !defined(AFX_EMLISTCTRL_H__C01E0EF5_2194_4876_9832_40EB8180426B__INCLUDED_)
#define AFX_EMLISTCTRL_H__C01E0EF5_2194_4876_9832_40EB8180426B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EmListCtrl.h : header file
//
#pragma warning (disable:4355)

/////////////////////////////////////////////////////////////////////////////
// CEmListCtrl window

#include "GenListCtrl.h"
#include "Emsvc.h"

class CEmshellView;

class CEmListCtrl : public CGenListCtrl
{
// Construction
public:
	CEmListCtrl(CEmshellView *pShellView);
	CEmListCtrl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEmListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	void SelectItemBySZNAME(TCHAR*	pszName, int nId);
	void SelectItemByGUID(unsigned char* pszGUID);
	EmObject m_LastSelectedEmObject;
	void RefreshList();
	void SortList(int nColumn);
	void ShowProperties();
	virtual ~CEmListCtrl();

	// Generated message map functions
protected:
	int m_nSortedColumn;
	CEmshellView* m_pEmShell;
	//{{AFX_MSG(CEmListCtrl)
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnColumnclickRef(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChange(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EMLISTCTRL_H__C01E0EF5_2194_4876_9832_40EB8180426B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emobjdef.h ===
///////////////////////////////////////////////////////////////////////////
//
// Module       : Exception Monitor
// Description  : EM Shell et all.
//
// File         : emobjdefs.h
// Author       : kulor
// Date         : 05/09/2000
//
// History      :
//
///////////////////////////////////////////////////////////////////////////

#pragma once

#include "genobjdef.h"
#include "emsvc.h"

#define TIMER_REFRESH	30000

// Resource Ids for ExcepMonColumns
enum ExcepMonColumnResID{
};

//
// Column Headings for the list control
//
typedef struct ExcepMonColumn{
    CString     sText;
    LONG        nColPos;
    LONG        nFlags;
} ExcepMonColumn, PExcepMonColumn;

//
// Itemdata associated with the list conrol
//
typedef struct EMItemData {
} EMItemData, *PItemData;



//
// Session
//

typedef struct EMActiveSession {
	GUID				guid;
	PEmObject			pEmObject;
	IEmDebugSession		*pIDebugSession;
	BOOL				bMaster;
    short               nSessionType;
	EmObjectType		emObjType;
} ActiveSession, *PActiveSession;

typedef struct EMSessionSettings {
	CString		strAltSymbolPath;
	CString		strCommandSet;
	CString		strAdminName;
	CString		strUsername;
	CString		strPassword;
	CString		strPort;
    DWORD       dwCommandSet;
	DWORD		dwNotifyAdmin;
	DWORD		dwRecursiveMode;
	DWORD		dwProduceMiniDump;
	DWORD		dwProduceUserDump;
} SessionSettings, *PSessionSettings;

typedef enum EMShellViewState {
	SHELLVIEW_NONE,
	SHELLVIEW_ALL,
	SHELLVIEW_APPLICATIONS,
	SHELLVIEW_SERVICES,
	SHELLVIEW_COMPLETEDSESSIONS,
	SHELLVIEW_LOGFILES,
	SHELLVIEW_DUMPFILES,
    SHELLVIEW_MSINFOFILES
} EMShellViewState;

typedef enum EmOptionsFlds {

    // lRefreshRate member is valid.
    EMOPTS_FLD_REFRESHRATE  =   1<<0,

} EmOptionsFlds;

typedef struct EmOptions {

    // 
    ULONG   lRefreshRate;

} EmOptions, *PEmOptions;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\connectiondlg.h ===
#if !defined(AFX_CONNECTIONDLG_H__ED0892D9_99C7_4F37_A6C3_D201D448C9E9__INCLUDED_)
#define AFX_CONNECTIONDLG_H__ED0892D9_99C7_4F37_A6C3_D201D448C9E9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ConnectionDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConnectionDlg dialog

class CConnectionDlg : public CDialog
{
// Construction
public:
	bool m_bLocalServer;
	CConnectionDlg(CWnd* pParent = NULL);   // standard constructor
	CString m_strLocalMachineName;

// Dialog Data
	//{{AFX_DATA(CConnectionDlg)
	enum { IDD = IDD_CONNECTION };
	CButton	m_btnConnect;
	CButton	m_btnLocalServer;
	CButton	m_btnRemoteServer;
	CStatic	m_idc_StaticServerName;
	CEdit	m_idc_ServerName;
	int		m_nRadio;
	CString	m_strRemoteMachineName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConnectionDlg)
	afx_msg void OnConnect();
	afx_msg void OnRadioRemote();
	afx_msg void OnRadioLocal();
	afx_msg void OnChangeEditServername();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONNECTIONDLG_H__ED0892D9_99C7_4F37_A6C3_D201D448C9E9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emlistctrl.cpp ===
// EmListCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "EmListCtrl.h"
#include "emshellView.h"
#include "emobjdef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEmListCtrl

CEmListCtrl::CEmListCtrl(CEmshellView *pShellView)
{
//	CEmListCtrl::CEmListCtrl();
	
	//Initialize the last selected object to void
	_tcscpy( m_LastSelectedEmObject.szBucket1, _T("VOID") );
	
	m_pEmShell = pShellView;
	m_nSortedColumn = -1;
}

CEmListCtrl::CEmListCtrl()
{
	//Initialize the last selected object to void
	_tcscpy( m_LastSelectedEmObject.szBucket1, _T("VOID") );
	
	m_pEmShell = NULL;
	m_nSortedColumn = -1;
}

CEmListCtrl::~CEmListCtrl()
{
}


BEGIN_MESSAGE_MAP(CEmListCtrl, CGenListCtrl)
	//{{AFX_MSG_MAP(CEmListCtrl)
	ON_WM_CONTEXTMENU()
	ON_WM_LBUTTONDBLCLK()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclickRef)
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmListCtrl message handlers

void CEmListCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	int					nIndex		=	HitTest(point);
	HRESULT				hr			=	E_FAIL;
	CMenu				*pSubMenu	=	NULL;
	CMenu				menu;
	EMShellViewState	currentViewState = m_pEmShell->GetViewState();

	//Load the popupmenu and display it right next to the cursor position
	ScreenToClient(&point);
	nIndex = HitTest(point);

	do {
		if(nIndex < 0) {
			hr = S_OK;
			break;
		}
		
		SelectItem(nIndex);
		
		ClientToScreen(&point);
		//Determine if we are in a log view or a process view and display
		//the correct menu.
		if ( currentViewState == SHELLVIEW_LOGFILES ||
             currentViewState == SHELLVIEW_DUMPFILES ||
             currentViewState == SHELLVIEW_MSINFOFILES ) {

            menu.LoadMenu(IDR_LOGPOPUP);	
			pSubMenu = menu.GetSubMenu(0);
			ASSERT(pSubMenu);

			pSubMenu->TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, ::AfxGetMainWnd());
		}
		else if ( currentViewState == SHELLVIEW_ALL ||
			      currentViewState == SHELLVIEW_APPLICATIONS || 
				  currentViewState == SHELLVIEW_SERVICES ||
				  currentViewState == SHELLVIEW_COMPLETEDSESSIONS ) {
			menu.LoadMenu(IDR_PROCESSPOPUP);	
			pSubMenu = menu.GetSubMenu(0);
			ASSERT(pSubMenu);

			pSubMenu->TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, ::AfxGetMainWnd());
		}
		else if ( currentViewState == SHELLVIEW_DUMPFILES ) {
		}
		hr = S_OK;
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	//Release this menu resource
	menu.DestroyMenu();
}

void CEmListCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
    //Get the selected emobject
	ShowProperties();
	
	CGenListCtrl::OnLButtonDblClk(nFlags, point);
}

void CEmListCtrl::ShowProperties()
{
    PEmObject pEmObject = NULL;

    pEmObject = m_pEmShell->GetSelectedEmObject();
    
    if ( pEmObject ) {
        //Get the current view state from the shell
        switch ( m_pEmShell->GetViewState() ) {
        case SHELLVIEW_LOGFILES:
        case SHELLVIEW_DUMPFILES:
        case SHELLVIEW_MSINFOFILES:
            m_pEmShell->ShowProperties( pEmObject );
            break;
        default:
            m_pEmShell->DoModalPropertySheet( pEmObject );
        }
    }
}

void CEmListCtrl::SortList(int nColumn)
{
	CGenListCtrl::BubbleSortItems(nColumn, IsAscending(), GetListCtrlHeader()[nColumn].nType);
}

void CEmListCtrl::OnColumnclickRef(IN	NMHDR	*pNMHDR,IN	LRESULT	*pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    CWaitCursor wait;

	m_nSortedColumn = pNMListView->iSubItem;

	CGenListCtrl::OnColumnclickRef(pNMHDR, pResult);
}

void CEmListCtrl::OnItemChange(IN	NMHDR	*pNMHDR,IN	LRESULT	*pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	POSITION pos = NULL;
	PEmObject pEmObject = NULL; 
	 
	do {
		pos = GetFirstSelectedItemPosition();

		if (pos == NULL) break;

		int nIndex = GetNextSelectedItem(pos);
		//Get the item at nIndex
		if (nIndex == -1) break;

		pEmObject = (PEmObject) GetItemData(nIndex);
		
		if ( pEmObject == NULL ) break;

		//Store off the szname, guid, nID and weather it's in the session table or not
		memcpy((void*)&m_LastSelectedEmObject.guidstream, (void*)pEmObject->guidstream, sizeof GUID);
		_tcscpy( m_LastSelectedEmObject.szName, pEmObject->szName );
		m_LastSelectedEmObject.nId = pEmObject->nId;

		//Find out if this selected object is in the session table
		PActiveSession pActiveSession = NULL;
		pActiveSession = m_pEmShell->FindActiveSession(pEmObject);
		if (pActiveSession != NULL) {
			_tcscpy( m_LastSelectedEmObject.szBucket1, _T("GUID") );
		}
		else {
			_tcscpy( m_LastSelectedEmObject.szBucket1, _T("SZNAME") );
		}
	} while (FALSE);
}

void CEmListCtrl::RefreshList()
{
	if ( m_nSortedColumn != -1 ) {
		SortList(m_nSortedColumn);
	}
	
	//Select the last item that had the focus
	if ( wcscmp(m_LastSelectedEmObject.szBucket1, _T("GUID")) == 0) {
		//We know it's in the session table, so search for the item by GUID
		SelectItemByGUID(m_LastSelectedEmObject.guidstream);
	}
	else if ( wcscmp(m_LastSelectedEmObject.szBucket1, _T("SZNAME")) == 0) {
		//We know it's not in the session table, so search for the item by name
		SelectItemBySZNAME(m_LastSelectedEmObject.szName, m_LastSelectedEmObject.nId);
	}
}

void CEmListCtrl::SelectItemByGUID(unsigned char* pszGUID)
{
	//Search through the list selecting the item whose itemdata.guid matches pszGUID
	//Given a GUID, find the element in the ListCtl
	PEmObject pListEmObject = NULL;

	//Step through every item in the list control searching for pEmObject  
	int nCount = GetItemCount();
	for (int i = 0;i < nCount; i++) {
		pListEmObject = (PEmObject) GetItemData(i);

		if (pListEmObject == NULL) break;

		if (memcmp((void *)pListEmObject->guidstream, (void *)pszGUID, sizeof GUID) == 0) {
			CEmListCtrl::SelectItem(i);

			//We have found the element, stop the search
			break;
		}
	}
}

void CEmListCtrl::SelectItemBySZNAME(TCHAR*	pszName, int nId)
{
	//Search through the list selecting the item whose itemdata.szname matches pszName
	//Given a pszName, find the element in the ListCtl
	PEmObject	pListEmObject	= NULL;
	BOOL		bFound			= FALSE;
	int			nFirstMatch		= -1;

	//Step through every item in the list control searching for pEmObject  
	int nCount = GetItemCount();
	for (int i = 0;i < nCount; i++) {
		pListEmObject = (PEmObject) GetItemData(i);

		if (pListEmObject == NULL) break;

		if (wcscmp(pListEmObject->szName, pszName) == 0 ) {
			if (nFirstMatch == -1 ) 
				nFirstMatch = i;

			if (pListEmObject->nId == nId) {
				SelectItem(i);
				bFound = TRUE;
				//We have found the element, stop the search
				break;
			}
		}
	}

	//If the we didn't find a perfect match, select the first near match
	//And if we didn't find any, select the first item in the list
	if ( !bFound ) {
		if (nFirstMatch == -1) {
			SelectItem(0);
		}
		else {
			SelectItem(nFirstMatch);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emshell.cpp ===
// emshell.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "emshell.h"

#include "MainFrm.h"
#include "emshellDoc.h"
#include "emshellView.h"
#include "genparse.h"
#include <atlbase.h>
#include <comdef.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern BSTR CopyBSTR( LPBYTE  pb, ULONG   cb );
extern const TCHAR*    gtcFileOpenFlags;

const TCHAR*    gtcPollSessionsFreq         = _T("PollSessionsFreq");
const TCHAR*    gtcWindowHeight             = _T("WindowHeight");
const TCHAR*    gtcWindowWidth              = _T("WindowWidth");
const TCHAR*    gtcRecursive                = _T("Recursive");
const TCHAR*    gtcCommandSet               = _T("CommandSet");
const TCHAR*    gtcMiniDump                 = _T("MiniDump");
const TCHAR*    gtcUserDump                 = _T("UserDump");
const TCHAR*    gtcNotifyAdmin              = _T("NotifyAdmin");
const TCHAR*    gtcMsinfoDump               = _T("MsinfoDump");
const TCHAR*    gtcAdminName                = _T("AdminName");
const TCHAR*    gtcAltSymbolPath            = _T("AltSymbolPath");
const TCHAR*    gtcSelectedCommandSet       = _T("SelectedCommandSet");
const TCHAR*    gtcPassword                 = _T("Password");
const TCHAR*    gtcPort                     = _T("Port");
const TCHAR*    gtcUsername                 = _T("Username");
const TCHAR*    gtcShowMSInfoDlg            = _T("ShowMSInfoDlg");
const TCHAR*    gtcEmDir                    = _T("emdir");
const TCHAR*    gtcNoDebugProcesses         = _T("NoDebugProcesses");
const TCHAR*    gtcWildCardNoDebugServices  = _T("WildCardNoDebugServices");
const TCHAR*    gtcNoDebugServices          = _T("NoDebugServices");
const TCHAR*    gtcNoDbgDefSvcList          = _T("EMSVC;RPCSS;IISADMIN");
const TCHAR*    gtcNoDbgDefProcList         = _T("EM.EXE;WINLOGON.EXE;EXPLORER.EXE;CSRSS.EXE;SMSS.EXE");
const TCHAR*    gtcWldCrdDefList            = _T("LSASS;SERVICES ;SVCHOST;SERVICES.EXE");
const TCHAR*    gtcDefPassword              = _T("microsoftvi");
const TCHAR*    gtcDefPort                  = _T("70");
const TCHAR*    gtcDefUsername              = _T("em");
const TCHAR*    gtcDefAltSymbolPath         = _T("");
const TCHAR*    gtcDefSelectedCommandSet    = _T("");
const TCHAR*    gtcDefAdminName             = _T("");
const DWORD     gnDefWindowWidth            = 240;
const DWORD     gnDefWindowHeight           = 320;
const DWORD     gnDefSessionRefreshRate     = 30;
const DWORD     gnDefUserDumpFlag           = 0;
const DWORD     gnDefShowMSInfoDlgFlag      = 1;
const DWORD     gnDefRecursiveFlag          = 0;
const DWORD     gnDefNotifyAdminFlag        = 0;
const DWORD     gnDefMSInfoDumpFlag         = 0;
const DWORD     gnDefMiniDumpFlag           = 1;
const DWORD     gnDefCommandSetFlag         = 0;

/////////////////////////////////////////////////////////////////////////////
// CEmshellApp

BEGIN_MESSAGE_MAP(CEmshellApp, CWinApp)
	//{{AFX_MSG_MAP(CEmshellApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmshellApp construction

CEmshellApp::CEmshellApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance

    m_dwSessionRefreshRate                      = gnDefSessionRefreshRate;
	m_dwWindowWidth                             = gnDefWindowWidth;
	m_dwWindowHeight                            = gnDefWindowHeight;
	m_dwRecursive                               = gnDefRecursiveFlag;
    m_dwMiniDump                                = gnDefMiniDumpFlag;
    m_dwUserDump                                = gnDefUserDumpFlag;
    m_dwMsinfoDump                              = gnDefMSInfoDumpFlag;
    m_dwShowMSInfoDlg                           = gnDefShowMSInfoDlgFlag; 
    m_SessionSettings.dwCommandSet              = gnDefCommandSetFlag;
	m_SessionSettings.dwNotifyAdmin				= gnDefNotifyAdminFlag;
	m_SessionSettings.dwProduceMiniDump			= gnDefMiniDumpFlag;
	m_SessionSettings.dwProduceUserDump			= gnDefUserDumpFlag;
	m_SessionSettings.dwRecursiveMode			= gnDefRecursiveFlag;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEmshellApp object

CEmshellApp theApp;


/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

void
TestCommandLine 
( 
    LPCTSTR     pszCmdLine
) 
{
    CGenCommandLine parser;
    CString         sText;
    
    TCHAR *szCmdLines[] =  {
                L"-ntx",
                L"-ntx -pid 45 -mfc, -ntx -vc6 -lib",
                L"-server /tcp /port=325",
                NULL
    };

    for (int i=0 ; szCmdLines[i] ; i++) {
        parser.Initialize( szCmdLines[i] );

        OutputDebugString ( szCmdLines[i] );
        OutputDebugString ( L"\n" );

        while ( parser.GetNext() != NULL ) {
            LPCTSTR pszToken = parser.GetToken();
            LPCTSTR pszValue = parser.GetValue();

            sText.Format( TEXT("Token:%s, Value:%s\n"), (pszToken), (pszValue) );
            OutputDebugString ( sText );
        }
        OutputDebugString ( L"\n" );
    }

}

#endif // #ifdef _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CEmshellApp initialization

BOOL CEmshellApp::InitInstance()
{

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

#ifdef _DEBUG
    TestCommandLine(GetCommandLine());
#endif

	//CoInitializeEx(NULL, COINIT_MULTITHREADED);
	CoInitialize(NULL);
	//CoInitializeEx( NULL, COINIT_MULTITHREADED );
//	::AfxOleInit();

    if ( !InitEmshell() ) {
        return false;
    }

    if(ReadDataFromRegistry() != ERROR_SUCCESS && CreateEmShellRegEntries() != ERROR_SUCCESS ) {

            MessageBox( NULL, _T("Registry entry not found.\nPlease re-install the application"), _T("Registry corrupted"), MB_OK);
            return FALSE;
    }

    //Get the path to CDB from the registry
    GetCDBPathFromRegistry();

    //Synchronize the session dlg data with the registry
    UpdateSessionData();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

bool CEmshellApp::InitEmshell 
(
    int nCmdShow    /* = SW_SHOW */
)
{
	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CEmshellDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CEmshellView));

	AddDocTemplate(pDocTemplate);

    return ( AfxGetApp()->OnCmdMsg(ID_FILE_NEW, 0, NULL, NULL) > 0);
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CEmshellApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CEmshellApp message handlers


void CAboutDlg::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

int CEmshellApp::ExitInstance() 
{
	//Uninitialize the COM services
	//Taken out since were now using AfxOleInit
	CoUninitialize();
    SetEmShellRegOptions( TRUE );

    return CWinApp::ExitInstance();
}

int CEmshellApp::DisplayErrMsgFromHR(HRESULT hr, UINT nType)
{
	void* pMsgBuf;
	DWORD dwSize = 0;
	int nRetVal = 0;
	CString strCaption;
    CString strTemp;
	CString strMessage;

	do {
		dwSize = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
			NULL,
			hr,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(LPTSTR) &pMsgBuf,
			0,
			NULL) ;

		if (dwSize == 0) break;

        strMessage = (LPTSTR) pMsgBuf;
        strMessage += "\n";

		strCaption.LoadString(IDS_ERRORMSG);

        //If we know the message, let's give them a description of what's going on
        switch( LOWORD( hr ) ) {
        case RPC_S_SERVER_UNAVAILABLE:
            strMessage += "\n\n";
            //Notify the user that the connection has failed.
            strTemp.LoadString( IDS_ERROR_CONNECTION_TERMINATED );
            strMessage += strTemp;
            break;
        }

		nRetVal = MessageBox(::AfxGetMainWnd()->m_hWnd, strMessage, strCaption, nType);
		
		//Release the buffer given to us from FormatMessage()
		LocalFree(pMsgBuf);
	} while (FALSE);

	return nRetVal;
}

int CEmshellApp::DisplayErrMsgFromString(CString strMessage, UINT nType)
{
	int nRetVal = 0;

	CString strCaption;
	strCaption.LoadString(IDS_ERRORMSG);

	nRetVal = MessageBox(::AfxGetMainWnd()->m_hWnd, strMessage, strCaption, nType);

	return nRetVal; 
}

void CEmshellApp::GetEmObjectTypeString(LONG lType, CString &csStatusStr)
{
    int nId =   -1;

    csStatusStr =   _T("");

    switch(lType)
    {
	case EMOBJ_SERVICE:
		nId = IDS_EMOBJECT_TYPE_SERVICE;
		break;
	case EMOBJ_PROCESS:
		nId = IDS_EMOBJECT_TYPE_PROCESS;
		break;
	case EMOBJ_LOGFILE:
		nId = IDS_EMOBJECT_TYPE_LOGFILE;
		break;
	case EMOBJ_MINIDUMP:
		nId = IDS_EMOBJECT_TYPE_MINIDUMP;
		break;
	case EMOBJ_USERDUMP:
		nId = IDS_EMOBJECT_TYPE_USERDUMP;
		break;
	case EMOBJ_UNKNOWNOBJECT:
		nId = IDS_EMOBJECT_TYPE_UNKNOWNOBJECT;
		break;
	default:
		break;
	}

    csStatusStr.LoadString(nId);
}

PEmObject CEmshellApp::AllocEmObject()
{
	PEmObject pEmObject = NULL;

	pEmObject = new EmObject;

	if (pEmObject == NULL) DisplayErrMsgFromHR(E_OUTOFMEMORY);

	return pEmObject;
}

void CEmshellApp::DeAllocEmObject(PEmObject pEmObj)
{
	_ASSERTE(pEmObj != NULL);
	delete pEmObj;
}

void CEmshellApp::GetStatusString(LONG lStatus, CString &csStatusStr)
{
    int nId =   -1;

    csStatusStr =   _T("");

    switch(lStatus)
    {
    case STAT_SESS_NOT_STARTED_RUNNING:
        nId = IDS_STAT_SESS_NOT_STARTED_RUNNING;
        break;
    case STAT_SESS_NOT_STARTED_FILECREATED_SUCCESSFULLY:
        nId = IDS_STAT_SESS_NOT_STARTED_FILECREATED_SUCCESSFULLY;
        break;
    case STAT_SESS_NOT_STARTED_FILECREATION_FAILED:
        nId = IDS_STAT_SESS_NOT_STARTED_FILECREATION_FAILED;
        break;
    case STAT_SESS_NOT_STARTED_NOTRUNNING:
        nId = IDS_STAT_SESS_NOT_STARTED_NOTRUNNING;
        break;
    case STAT_SESS_DEBUG_IN_PROGRESS_NONE:
        nId = IDS_STAT_SESS_DEBUG_IN_PROGRESS_NONE;
        break;
    case STAT_SESS_DEBUG_IN_PROGRESS_FILECREATED_SUCESSFULLY:
        nId = IDS_STAT_SESS_DEBUG_IN_PROGRESS_FILECREATED_SUCESSFULLY;
        break;
    case STAT_SESS_DEBUG_IN_PROGRESS_FILECREATION_FAILED:
        nId = IDS_STAT_SESS_DEBUG_IN_PROGRESS_FILECREATION_FAILED;
        break;
	case STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_NONE:
        nId = IDS_STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_NONE;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATED_SUCESSFULLY:
        nId = IDS_STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATED_SUCESSFULLY;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATION_FAILED:
        nId = IDS_STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATION_FAILED;
		break;
    case STAT_SESS_STOPPED_SUCCESS:
        nId = IDS_STAT_SESS_STOPPED_SUCCESS;
        break;
    case STAT_SESS_STOPPED_FAILED:
        nId = IDS_STAT_SESS_STOPPED_FAILED;
        break;
	case STAT_SESS_STOPPED_ORPHAN_SUCCESS:
        nId = IDS_STAT_SESS_STOPPED_ORPHAN_SUCCESS;
		break;
	case STAT_SESS_STOPPED_ORPHAN_FAILED:
        nId = IDS_STAT_SESS_STOPPED_ORPHAN_FAILED;
		break;
	case STAT_SESS_STOPPED_DEBUGGEE_KILLED:
        nId = IDS_STAT_SESS_STOPPED_DEBUGGEE_KILLED;
		break;
	case STAT_SESS_STOPPED_DEBUGGEE_EXITED:
        nId = IDS_STAT_SESS_STOPPED_DEBUGGEE_EXITED;
		break;
	case STAT_SESS_STOPPED_EXCEPTION_OCCURED:
        nId = IDS_STAT_SESS_STOPPED_EXCEPTION_OCCURED;
		break;
	case STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_KILLED:
        nId = IDS_STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_KILLED;
		break;
	case STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_EXITED:
        nId = IDS_STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_EXITED;
		break;
	case STAT_SESS_STOPPED_ORPHAN_EXCEPTION_OCCURED:
        nId = IDS_STAT_SESS_STOPPED_ORPHAN_EXCEPTION_OCCURED;
		break;
	case STAT_SESS_STOPPED_ACCESSVIOLATION_OCCURED:
        nId = IDS_STAT_SESS_STOPPED_ACCESSVIOLATION_OCCURED;
		break;
	case STAT_SESS_STOPPED_ORPHAN_ACCESSVIOLATION_OCCURED:
        nId = IDS_STAT_SESS_STOPPED_ORPHAN_ACCESSVIOLATION_OCCURED;
		break;
    default:
        return;
    }

    csStatusStr.LoadString(nId);
}

void CEmshellApp::GetCDBPathFromRegistry()
{
    CRegKey emshell;
    LONG    lRes    = NULL;
    DWORD   dwSize  = 0;
    LPTSTR  pString = NULL;

    do {

        //Open the key
        lRes = emshell.Open( HKEY_LOCAL_MACHINE, EMSVC_SESSION_KEY );
        if( lRes != ERROR_SUCCESS ) break;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcEmDir, &dwSize);
        
        if ( lRes != ERROR_FILE_NOT_FOUND ) {
            pString = m_strApplicationPath.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcEmDir, &dwSize );
            m_strApplicationPath.ReleaseBuffer();

            if( lRes != ERROR_SUCCESS ) break;
        }


    } while( FALSE );
    
    if ( lRes != ERROR_SUCCESS ) {
        MessageBox(NULL, _T("Unable to get application install path from registry.\n  Using help might not function properly."), _T("Registry operation failed"), MB_OK);
    }
}

DWORD CEmshellApp::ReadDataFromRegistry ( HKEY hKey, LPCTSTR lpKey )
{
    CRegKey emshell;
    DWORD dwSize = 0;
    LPTSTR pString = NULL;
    LONG lRes = NULL;

    do {
        //Open the key
        lRes = emshell.Open( hKey, lpKey );
        if( lRes != ERROR_SUCCESS ) break;


        lRes = emshell.QueryValue( m_dwWindowHeight, gtcWindowHeight );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwWindowHeight = gnDefWindowHeight;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcWindowHeight, m_dwWindowHeight ) != ERROR_SUCCESS ) {
                break;
            }
        }
    
        lRes = emshell.QueryValue( m_dwWindowWidth, gtcWindowWidth );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwWindowWidth = gnDefWindowWidth;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcWindowWidth, m_dwWindowWidth ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwShowMSInfoDlg, gtcShowMSInfoDlg );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwShowMSInfoDlg = gnDefShowMSInfoDlgFlag;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcShowMSInfoDlg, m_dwShowMSInfoDlg ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwSessionRefreshRate, gtcPollSessionsFreq );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwSessionRefreshRate = gnDefSessionRefreshRate;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcPollSessionsFreq, m_dwSessionRefreshRate ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwRecursive, gtcRecursive );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwRecursive = gnDefRecursiveFlag;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcRecursive, m_dwRecursive ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwNotifyAdmin, gtcNotifyAdmin );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwNotifyAdmin = gnDefNotifyAdminFlag;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcNotifyAdmin, m_dwNotifyAdmin ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwCommandSet, gtcCommandSet );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwCommandSet = gnDefCommandSetFlag;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcCommandSet, m_dwCommandSet ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwMiniDump, gtcMiniDump );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwMiniDump = gnDefMiniDumpFlag;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcMiniDump, m_dwMiniDump ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwUserDump, gtcUserDump );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwUserDump = gnDefUserDumpFlag;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcUserDump, m_dwUserDump ) != ERROR_SUCCESS ) {
                break;
            }
        }

        lRes = emshell.QueryValue( m_dwMsinfoDump, gtcMsinfoDump );
        if( lRes == ERROR_FILE_NOT_FOUND ) {
            
            m_dwMsinfoDump = gnDefMSInfoDumpFlag;

            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcMsinfoDump, m_dwMsinfoDump ) != ERROR_SUCCESS ) {
                break;
            }
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcAdminName, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcAdminName, gtcDefAdminName ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strAdminName.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcAdminName, &dwSize );
            m_strAdminName.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcAltSymbolPath, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcAltSymbolPath, gtcDefAltSymbolPath ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strAltSymbolPath.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcAltSymbolPath, &dwSize );
            m_strAltSymbolPath.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcSelectedCommandSet, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcSelectedCommandSet, gtcDefSelectedCommandSet ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strCommandSet.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcSelectedCommandSet, &dwSize );
            m_strCommandSet.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcPassword, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcPassword, gtcDefPassword ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strPassword.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcPassword, &dwSize );
            m_strPassword.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcPort, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcPort, gtcDefPort ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strPort.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcPort, &dwSize );
            m_strPort.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcUsername, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcUsername, gtcDefUsername ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strUsername.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcUsername, &dwSize );
            m_strUsername.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }
        
        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcNoDebugProcesses, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcNoDebugProcesses, gtcNoDbgDefProcList ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strIgnoreProcesses.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcNoDebugProcesses, &dwSize );
            m_strIgnoreProcesses.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcWildCardNoDebugServices, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcWildCardNoDebugServices, gtcWldCrdDefList ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strWildCardIgnoreServices.GetBuffer( dwSize + sizeof( TCHAR ));

            lRes = emshell.QueryValue( pString, gtcWildCardNoDebugServices, &dwSize );
            m_strWildCardIgnoreServices.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }

        dwSize = 0;

        //Get the size of the string in the registry
        lRes = emshell.QueryValue( pString, gtcNoDebugServices, &dwSize);
        if ( lRes == ERROR_FILE_NOT_FOUND ) {
            //Create the entry
            if( lRes = CreateKeyAndSetData( hKey, lpKey, gtcNoDebugServices, gtcNoDbgDefSvcList ) != ERROR_SUCCESS ) {
                break;
            }
        } else {
            pString = m_strIgnoreServices.GetBuffer( dwSize + sizeof( TCHAR ) );

            lRes = emshell.QueryValue( pString, gtcNoDebugServices, &dwSize );
            m_strIgnoreServices.ReleaseBuffer();
            if( lRes != ERROR_SUCCESS ) break;
        }
    } while ( FALSE );

    if ( lRes != ERROR_SUCCESS ) {
        MessageBox(NULL, _T("Unable to set registry values."), _T("Registry operation failed"), MB_OK);
    }
    return lRes;
}

DWORD
CEmshellApp::CreateEmShellRegEntries
(
    HKEY    hKey /* = HKEY_CURRENT_USER */,
    LPCTSTR lpszKey /* = _T("Software\\Microsoft\\EM\\shell") */
)
{
    LONG lRes = 0L;

    if( (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcPollSessionsFreq, m_dwSessionRefreshRate ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcWindowHeight, m_dwWindowHeight ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcWindowWidth, m_dwWindowWidth ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcRecursive, m_dwRecursive ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcCommandSet, m_dwCommandSet ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcMiniDump, m_dwMiniDump ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcUserDump, m_dwUserDump ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcNotifyAdmin, m_dwNotifyAdmin ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcMsinfoDump, m_dwMsinfoDump ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcAdminName, m_strAdminName ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcAltSymbolPath, m_strAltSymbolPath ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcSelectedCommandSet, m_strCommandSet ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcPassword, m_strPassword ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcPort, m_strPort ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcUsername, m_strUsername ) != ERROR_SUCCESS) ||
        (lRes = CreateKeyAndSetData( hKey, lpszKey, gtcShowMSInfoDlg, m_dwShowMSInfoDlg ) != ERROR_SUCCESS)
        ) {

        MessageBox(NULL, _T("Unable to set registry values."), _T("Registry operation failed"), MB_OK);
    }

    return lRes;
}

DWORD
CEmshellApp::CreateKeyAndSetData
(
    HKEY    hKeyParent,
    LPCTSTR lpszKeyName,
    LPCTSTR lpszNamedValue,
    LPCTSTR lpValue,
    LPTSTR  lpszClass /* = REG_NONE */
)
{
    CRegKey registry;

    do {

        if( registry.Create(hKeyParent, lpszKeyName, lpszClass) != ERROR_SUCCESS ) {
        
            return GetLastError();
        }

        if( registry.SetValue( lpValue, lpszNamedValue ) != ERROR_SUCCESS ) {

            return GetLastError();
        }
    }
    while( false );

    if( HKEY(registry) != NULL ) {

        registry.Close();
    }

    return 0L; // Successful
}

DWORD
CEmshellApp::CreateKeyAndSetData
(
    HKEY    hKeyParent,
    LPCTSTR lpszKeyName, 
    LPCTSTR lpszNamedValue,
    DWORD   dwValue,
    LPTSTR  lpszClass /* = REG_NONE */
)
{
    CRegKey registry;

    do {

        if( registry.Create(hKeyParent, lpszKeyName) != ERROR_SUCCESS ) {
        
            return GetLastError();
        }

        if( registry.SetValue( dwValue, lpszNamedValue ) != ERROR_SUCCESS ) {

            return GetLastError();
        }
    }
    while( false );

    if( HKEY(registry) != NULL ) {

        registry.Close();
    }

    return 0L; // Successful
}

void
CEmshellApp::GetEmShellRegOptions
(
    BOOL  bReadFromRegistry /* = FALSE */,
    DWORD *pdwPollingSessionsFreq /* = NULL */,
    DWORD *pdwWindowHeight /* = NULL */,
    DWORD *pdwWindowWidth /* = NULL */,
	DWORD *pdwRecursive /* = NULL */,
	DWORD *pdwCommandSet /* = NULL */,
    DWORD *pdwMiniDump /* = NULL */,
    DWORD *pdwUserDump /* = NULL */,
    DWORD *pdwNotifyAdmin /* = NULL */,
    DWORD *pdwMsinfoDump /* = NULL */,
    CString *pstrAdminName /* = NULL */,
    CString *pstrAltSymbolPath /* = NULL */,
    CString *pstrCommandSet /* = NULL */,
    CString *pstrPassword /* = NULL */,
    CString *pstrPort /* = NULL */,
    CString *pstrUsername /* = NULL */,
    DWORD *pdwShowMSInfoDlg /* = NULL */
)
{
    if( bReadFromRegistry ) { ReadDataFromRegistry(); }

    if( pdwPollingSessionsFreq ) *pdwPollingSessionsFreq = m_dwSessionRefreshRate; // MilliSeconds
    if( pdwWindowHeight )   *pdwWindowHeight    = m_dwWindowHeight;
    if( pdwWindowWidth )    *pdwWindowWidth     = m_dwWindowWidth;
	if( pdwRecursive )      *pdwRecursive       = m_dwRecursive;
	if( pdwCommandSet )     *pdwCommandSet      = m_dwCommandSet;
    if( pdwMiniDump )       *pdwMiniDump        = m_dwMiniDump;
    if( pdwUserDump )       *pdwUserDump        = m_dwUserDump;
    if( pdwNotifyAdmin )    *pdwNotifyAdmin     = m_dwNotifyAdmin;
    if( pdwMsinfoDump )     *pdwMsinfoDump      = m_dwMsinfoDump;
    if( pstrAdminName )     *pstrAdminName      = m_strAdminName;
    if( pstrAltSymbolPath ) *pstrAltSymbolPath  = m_strAltSymbolPath;
    if( pstrCommandSet )    *pstrCommandSet     = m_strCommandSet;
    if( pstrPassword )      *pstrPassword       = m_strPassword;
    if( pstrPort )          *pstrPort           = m_strPort;
    if( pstrUsername )      *pstrUsername       = m_strUsername;
    if( pdwShowMSInfoDlg )  *pdwShowMSInfoDlg   = m_dwShowMSInfoDlg;
}

void
CEmshellApp::SetEmShellRegOptions
(
    const BOOL  bUpdateRegistry /* = FALSE */,
    const DWORD *pdwPollingSessionsFreq /* = NULL */,
    const DWORD *pdwWindowHeight /* = NULL */,
    const DWORD *pdwWindowWidth /* = NULL */,
	const DWORD *pdwRecursive /* = NULL */,
	const DWORD *pdwCommandSet /* = NULL */,
    const DWORD *pdwMiniDump /* = NULL */,
    const DWORD *pdwUserDump /* = NULL */,
    const DWORD *pdwNotifyAdmin /* = NULL */,
    const DWORD *pdwMsinfoDump /* = NULL */,
    CString *pstrAdminName /* = NULL */,
    CString *pstrAltSymbolPath /* = NULL */,
    CString *pstrCommandSet /* = NULL */,
    CString *pstrPassword /* = NULL */,
    CString *pstrPort /* = NULL */,
    CString *pstrUsername /* = NULL */,
    const DWORD *pdwShowMSInfoDlg /* = NULL */
)
{
    if( pdwPollingSessionsFreq ) m_dwSessionRefreshRate = *pdwPollingSessionsFreq; // will be stored as secs.
    if( pdwWindowHeight )   m_dwWindowHeight    = *pdwWindowHeight;
    if( pdwWindowWidth )    m_dwWindowWidth     = *pdwWindowWidth;
	if( pdwRecursive )      m_dwRecursive       = *pdwRecursive;
	if( pdwCommandSet )     m_dwCommandSet      = *pdwCommandSet;
    if( pdwMiniDump )       m_dwMiniDump        = *pdwMiniDump;
    if( pdwUserDump )       m_dwUserDump        = *pdwUserDump;
    if( pdwNotifyAdmin )    m_dwNotifyAdmin     = *pdwNotifyAdmin;
    if( pdwMsinfoDump )     m_dwMsinfoDump      = *pdwMsinfoDump;
    if( pstrAdminName )     m_strAdminName      = *pstrAdminName;
    if( pstrAltSymbolPath ) m_strAltSymbolPath  = *pstrAltSymbolPath;
    if( pstrCommandSet )    m_strCommandSet     = *pstrCommandSet;
    if( pstrPassword )      m_strPassword       = *pstrPassword;
    if( pstrPort )          m_strPort           = *pstrPort;
    if( pstrUsername )      m_strUsername       = *pstrUsername;
    if( pdwShowMSInfoDlg )  m_dwShowMSInfoDlg   = *pdwShowMSInfoDlg;

    if( bUpdateRegistry ) { CreateEmShellRegEntries(); }
}

void __stdcall _com_issue_error( HRESULT hr )
{
    throw _com_error ( hr );
}

BOOL CEmshellApp::AskForPath( CString &strDirPath ) 
{
    LPITEMIDLIST    lpItemIDlist                = NULL;
    UINT            nFlags                      = BIF_NEWDIALOGSTYLE;
    BOOL            bRetVal                     = FALSE;
    TCHAR           szDisplayName[_MAX_PATH];
    TCHAR           szBuffer[_MAX_PATH];
    CString         strTitle;
    BROWSEINFO      browseInfo;
    LPMALLOC        lpMalloc;                   // pointer to IMalloc

    strTitle.LoadString( IDS_EXPORT_FILES_CAPTION );

    //Initialize the browseinfo object
    browseInfo.hwndOwner        = ::AfxGetMainWnd()->m_hWnd; // set root at Desktop
    browseInfo.pidlRoot         = NULL; 
    browseInfo.pszDisplayName   = szDisplayName;
    browseInfo.lpszTitle        = strTitle;     // passed in
    browseInfo.ulFlags          = nFlags;       // also passed in
    browseInfo.lpfn             = NULL;         // not used
    browseInfo.lParam           = 0;            // not used   

    do {
        if (::SHGetMalloc(&lpMalloc) != NOERROR) break; // failed to get allocator
        
        if ((lpItemIDlist = ::SHBrowseForFolder(&browseInfo)) != NULL)
        {
            // Get the path of the selected folder from the item ID list.
            if (::SHGetPathFromIDList(lpItemIDlist, szBuffer)) {

                // At this point, szBuffer contains the path the user chose.
                if (szBuffer[0] == '\0') {

                    strTitle.LoadString( IDS_EXPORT_FAILED_GET_DIRECTORY );
        			((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString( strTitle );

                   break;

                }

                // We have a path in szBuffer!
                // Return it.
                strDirPath = szBuffer;
                bRetVal = TRUE;

             }
        }
        else {

            break;

        }

        if ( strDirPath[strDirPath.GetLength() - 1 ] != CString( _T("\\") ) )
            strDirPath += _T("\\");

    } while ( FALSE );


    if ( lpItemIDlist ) {

        lpMalloc->Free( lpItemIDlist );
        lpItemIDlist = NULL;

    }

    if ( lpMalloc ) {

        lpMalloc->Release();
        lpMalloc = NULL;

    }

    return bRetVal;
}

HRESULT CEmshellApp::ExportLog( PEmObject pEmObject, CString strDirPath, IEmManager* pEmManager )
{
    char            lpszLogData[ISTREAM_BUFFER_SIZE];
    BSTR            bstrEmObject    = NULL;
    HRESULT         hr              = E_FAIL;
    IStream*        pIEmStream      = NULL;
    ULONG           lRead           = 0L;
    size_t          tWritten        = 0;
	FILE*           pLogFile        = NULL;
    CString         strMessage;

    do {
        //Initialize the bstrEmObject for the call to the server
		bstrEmObject = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );

        if( bstrEmObject == NULL ){
			hr = E_OUTOFMEMORY;
			break;
        }

        //Get an IStream* file pointer for the currently selected item.
        hr = pEmManager->GetEmFileInterface( bstrEmObject, (IStream **)&pIEmStream );
        if( FAILED( hr ) ) break;

        //Append the filename to the directory name
        strDirPath += pEmObject->szName;

        CFileFind finder;
        BOOL bFound = finder.FindFile( strDirPath );

        if ( bFound ) {
            strMessage.LoadString( IDS_FILEOVERWRITE_CONFIRMATION );
            //Ask the user if they want to overwrite, if not break.
			if (((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString(strMessage, MB_YESNO) == IDNO) break;
        }

		//Set the cursor to a wait cursor
		CWaitCursor wait;

        //Create the file in the selected directory
        pLogFile = _tfopen( strDirPath, gtcFileOpenFlags );
        
        if ( pLogFile == NULL ) {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        //Read the stream into the file
        do {
        
            hr = pIEmStream->Read( (void *)lpszLogData, ISTREAM_BUFFER_SIZE, &lRead );
            if ( lRead == 0 || FAILED( hr ) ) break;
        
            tWritten = fwrite( lpszLogData, sizeof( char ), lRead, pLogFile );
            if ( tWritten == 0 ) {
                hr = E_FAIL;
                break;
            }

        } while (TRUE);

        if ( FAILED( hr ) ) break;

    } while ( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}

    if ( pIEmStream ) {
        SAFE_RELEASEIX( pIEmStream );
    }

    if ( pLogFile ) {
        fclose( pLogFile );
        pLogFile = NULL;
    }

    return( hr );
}


BOOL CEmshellApp::CanDisplayProcess(TCHAR *pszName)
{
    BOOL bRetVal    = TRUE;
    TCHAR* pszIgnoreProcesses = new TCHAR[m_strIgnoreProcesses.GetLength() + sizeof(TCHAR)];
    TCHAR* token     = NULL;

    wcscpy( pszIgnoreProcesses, m_strIgnoreProcesses );

    //Tokenize and iterate through each element in the string comparing the 
    //element with the service name
    token = wcstok( pszIgnoreProcesses, _T(";") );

    while( token != NULL )
    {
        if ( !_wcsicmp( token, pszName ) ) {
            bRetVal = FALSE;
            break;
        }

        /* Get next token: */
        token = wcstok( NULL, _T(";") );
    }

    delete[] pszIgnoreProcesses;
    return bRetVal;
}

BOOL CEmshellApp::CanDisplayService(TCHAR *pszName, TCHAR *pszSecName)
{
    BOOL bRetVal    = TRUE;
    TCHAR* pszIgnoreServices = new TCHAR[m_strIgnoreServices.GetLength() + sizeof(TCHAR)];
	ASSERT( pszIgnoreServices != NULL );

	if( pszIgnoreServices == NULL ) return bRetVal;

    TCHAR* pszWildCardIgnoreServices = new TCHAR[m_strWildCardIgnoreServices.GetLength() + sizeof(TCHAR)];
	ASSERT( pszWildCardIgnoreServices != NULL );

	if( pszWildCardIgnoreServices == NULL ) {

		delete pszWildCardIgnoreServices;
		return bRetVal;
	}

    TCHAR* token     = NULL;

    do {
        wcscpy( pszWildCardIgnoreServices, m_strWildCardIgnoreServices );

        //Tokenize and iterate through each element in the string looking for each 
        //element within the service name
        token = wcstok( pszWildCardIgnoreServices, _T(";") );

        while( token != NULL )
        {
            if ( wcsstr( _wcslwr( pszName ), _wcslwr( token ) ) ) {
                bRetVal = FALSE;
                break;
            }

            /* Get next token: */
            token = wcstok( NULL, _T(";") );
        }

        //Break out if we know we can't show it.
        if ( !bRetVal ) break;

        wcscpy( pszIgnoreServices, m_strIgnoreServices );

        //Tokenize and iterate through each element in the string comparing the 
        //element with the service name
        token = wcstok( pszIgnoreServices, _T(";") );

        while( token != NULL )
        {
            if ( !_wcsicmp( token, pszSecName ) ) {
                bRetVal = FALSE;
                break;
            }

            /* Get next token: */
            token = wcstok( NULL, _T(";") );
        }
    } while ( FALSE );

    delete[] pszIgnoreServices;
    delete[] pszWildCardIgnoreServices;
    return bRetVal;
}

void CEmshellApp::UpdateSessionData( BOOL bUpdate )
{
    if( bUpdate ) {
        //Write out the session info to the app registry entries
        m_dwCommandSet        = m_SessionSettings.dwCommandSet;
        m_dwMiniDump          = m_SessionSettings.dwProduceMiniDump;
        m_dwRecursive         = m_SessionSettings.dwRecursiveMode;
        m_dwUserDump          = m_SessionSettings.dwProduceUserDump;
        m_dwNotifyAdmin       = m_SessionSettings.dwNotifyAdmin;
        m_strAdminName        = m_SessionSettings.strAdminName;
        m_strAltSymbolPath    = m_SessionSettings.strAltSymbolPath;
        m_strCommandSet       = m_SessionSettings.strCommandSet;
        m_strPassword         = m_SessionSettings.strPassword;
        m_strUsername         = m_SessionSettings.strUsername;
        m_strPort             = m_SessionSettings.strPort;

        //Flush the changes to the registry
        CreateEmShellRegEntries();
    }
    else {
        //Retrieve the session info from the app registry entries
        m_SessionSettings.dwCommandSet      = m_dwCommandSet;
        m_SessionSettings.dwProduceMiniDump = m_dwMiniDump;
        m_SessionSettings.dwRecursiveMode   = m_dwRecursive;
        m_SessionSettings.dwProduceUserDump = m_dwUserDump;
        m_SessionSettings.dwNotifyAdmin     = m_dwNotifyAdmin;
        m_SessionSettings.strAdminName      = m_strAdminName;
        m_SessionSettings.strAltSymbolPath  = m_strAltSymbolPath;
        m_SessionSettings.strCommandSet     = m_strCommandSet;
        m_SessionSettings.strPassword       = m_strPassword;
        m_SessionSettings.strUsername       = m_strUsername;
        m_SessionSettings.strPort           = m_strPort;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emoptions.cpp ===
// EmOptions.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "EmOptions.h"
#include <atlbase.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEmOptions dialog


CEmOptions::CEmOptions(CWnd* pParent /*=NULL*/)
	: CDialog(CEmOptions::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEmOptions)
	m_csRefreshRate = _T("");
	//}}AFX_DATA_INIT
}


void CEmOptions::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEmOptions)
	DDX_Control(pDX, IDC_OPTION_REFRESHRATE, m_ctrlRefreshRate);
	DDX_Text(pDX, IDC_OPTION_REFRESHRATE, m_csRefreshRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEmOptions, CDialog)
	//{{AFX_MSG_MAP(CEmOptions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmOptions message handlers

BOOL CEmOptions::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

    DWORD   dwPollSessionsFreq  =   0L;

    ((CEmshellApp*)AfxGetApp())->GetEmShellRegOptions( TRUE, &dwPollSessionsFreq );

    m_csRefreshRate.Format(_T("%d"), dwPollSessionsFreq);
    UpdateData(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEmOptions::OnOK() 
{
    UpdateData();

    DWORD   dwPollSessionsFreq  =   0L;
    CString strMessage;
    strMessage.LoadString( IDS_OUTOFBOUNDS_REFRESHRATE );

    dwPollSessionsFreq = _ttol( (LPCTSTR) m_csRefreshRate );

    //Varify the data in the polling edit box
    if ( dwPollSessionsFreq < 1 || dwPollSessionsFreq > 300 ) {
        //Error to the user that they need to select a timing that is greater than 0 or less than 300
        ((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString( strMessage );

        //Set the focus into the edit control
        m_ctrlRefreshRate.SetFocus();
        m_ctrlRefreshRate.SetSel(0, -1);

        return;
    }

    ((CEmshellApp*)AfxGetApp())->SetEmShellRegOptions( TRUE, &dwPollSessionsFreq );

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emshell.h ===
// emshell.h : main header file for the EMSHELL application
//

#if !defined(AFX_EMSHELL_H__A4B361A0_838C_4898_A9C1_D460D1546E6B__INCLUDED_)
#define AFX_EMSHELL_H__A4B361A0_838C_4898_A9C1_D460D1546E6B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "emsvc.h"
#include "emobjdef.h"

/////////////////////////////////////////////////////////////////////////////
// CEmshellApp:
// See emshell.cpp for the implementation of this class
//

#define EM_NAMEDKEY_LEN 60
#define EM_REGKEY _T("Software\\Microsoft\\EM\\shell")
#define EMSVC_SESSION_KEY _T("SYSTEM\\CurrentControlSet\\Services\\emsvc\\Parameters\\Session")

class CEmshellApp : public CWinApp
{
public:
	DWORD m_dwWindowWidth,
	      m_dwWindowHeight,
	      m_dwSessionRefreshRate,
          m_dwRecursive,
          m_dwCommandSet,
          m_dwMiniDump,
          m_dwUserDump,
          m_dwMsinfoDump,
          m_dwNotifyAdmin,
          m_dwShowMSInfoDlg;
    CString m_strApplicationPath;
    CString m_strAdminName;
    CString m_strAltSymbolPath;
    CString m_strCommandSet;
    CString m_strPassword;
    CString m_strPort;
    CString m_strUsername;
	SessionSettings m_SessionSettings;

public:
    void GetCDBPathFromRegistry();
    void UpdateSessionData( BOOL bUpdate = FALSE );
	BOOL CanDisplayService(TCHAR *pszName, TCHAR *pszSecName);
	BOOL CanDisplayProcess(TCHAR *pszName);
	void SetEmShellRegOptions
    (
        const BOOL bUpdateRegistry          = FALSE,
        const DWORD *pdwPollingSessionsFreq = NULL,
        const DWORD *pdwWindowHeight        = NULL,
        const DWORD *pdwWindowWidth         = NULL,
	    const DWORD *pdwRecursive           = NULL,
	    const DWORD *pdwCommandSet          = NULL,
        const DWORD *pdwMiniDump            = NULL,
        const DWORD *pdwUserDump            = NULL,
        const DWORD *pdwNotifyAdmin         = NULL,
        const DWORD *pdwMsinfoDump          = NULL,
        CString *pstrAdminName              = NULL,
        CString *pstrAltSymbolPath          = NULL,
        CString *pstrCommandSet             = NULL,
        CString *pstrPassword               = NULL,
        CString *pstrPort                   = NULL,
        CString *pstrUsername               = NULL,
        const DWORD *pdwShowMSInfoDlg       = NULL
    );

	void GetEmShellRegOptions
    (
        BOOL  bReadFromRegistry         = FALSE,
        DWORD *pdwPollingSessionsFreq   = NULL,
        DWORD *pdwWindowHeight          = NULL,
        DWORD *pdwWindowWidth           = NULL,
	    DWORD *pdwRecursive             = NULL,
	    DWORD *pdwCommandSet            = NULL,
        DWORD *pdwMiniDump              = NULL,
        DWORD *pdwUserDump              = NULL,
        DWORD *pdwNotifyAdmin           = NULL,
        DWORD *pdwMsinfoDump            = NULL,
        CString *pstrAdminName          = NULL,
        CString *pstrAltSymbolPath      = NULL,
        CString *pstrCommandSet         = NULL,
        CString *pstrPassword           = NULL,
        CString *pstrPort               = NULL,
        CString *pstrUsername           = NULL,
        DWORD *pdwShowMSInfoDlg         = NULL
    );

    DWORD CreateKeyAndSetData
    (
        HKEY    hKeyParent,
        LPCTSTR lpszKeyName, 
        LPCTSTR lpszNamedValue,
        LPCTSTR lpValue,
        LPTSTR  lpszClass = REG_NONE
    );

    DWORD CreateKeyAndSetData
    (
        HKEY    hKeyParent,
        LPCTSTR lpszKeyName, 
        LPCTSTR lpszNamedValue,
        DWORD   dwValue,
        LPTSTR  lpszClass = REG_NONE
    );

    DWORD CreateEmShellRegEntries
    (
        HKEY    hKey = HKEY_CURRENT_USER,
        LPCTSTR lpszKey = EM_REGKEY
    );

	DWORD
    ReadDataFromRegistry
    (
        HKEY    hKey = HKEY_CURRENT_USER,
        LPCTSTR lpszKey = EM_REGKEY
    );

	CEmshellApp();
    HRESULT ExportLog( PEmObject pEmObject, CString strDirPath, IEmManager* pEmManager );
    BOOL AskForPath( CString &strDirPath );
	int DisplayErrMsgFromHR( HRESULT hr, UINT nType = MB_OK );
	int DisplayErrMsgFromString( CString strMessage, UINT nType = MB_OK );
	void GetStatusString( LONG lStatus, CString &csStatus );
	void GetEmObjectTypeString( LONG lType, CString &csStatusStr );
	EmObject* AllocEmObject();
	void DeAllocEmObject( EmObject* pEmObj );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEmshellApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CEmshellApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    protected:
	    CString m_strIgnoreProcesses;
	    CString m_strIgnoreServices;
        CString m_strWildCardIgnoreServices;

    bool InitEmshell (
            int nCmdShow = SW_SHOW
        );

};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EMSHELL_H__A4B361A0_838C_4898_A9C1_D460D1546E6B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emoptions.h ===
#if !defined(AFX_EMOPTIONS_H__AB51FD59_6D21_45BE_B1C8_A70A85A575A2__INCLUDED_)
#define AFX_EMOPTIONS_H__AB51FD59_6D21_45BE_B1C8_A70A85A575A2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EmOptions.h : header file
//

#include "emobjdef.h"

/////////////////////////////////////////////////////////////////////////////
// CEmOptions dialog

class CEmOptions : public CDialog
{
    EmOptions m_EmOpts;

// Construction
public:
	CEmOptions(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEmOptions)
	enum { IDD = IDD_OPTIONS };
	CEdit	m_ctrlRefreshRate;
	CString	m_csRefreshRate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEmOptions)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEmOptions)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EMOPTIONS_H__AB51FD59_6D21_45BE_B1C8_A70A85A575A2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emshelldoc.h ===
// emshellDoc.h : interface of the CEmshellDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_EMSHELLDOC_H__DE402522_2120_4FEC_92AA_41CD749E2ADF__INCLUDED_)
#define AFX_EMSHELLDOC_H__DE402522_2120_4FEC_92AA_41CD749E2ADF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ConnectionDlg.h"	// Added by ClassView
#include "emsvc.h"

class CEmshellDoc : public CDocument
{
protected: // create from serialization only
	CEmshellDoc();
	DECLARE_DYNCREATE(CEmshellDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEmshellDoc)
	public:
	virtual void Serialize(CArchive& ar);
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	void AppendVersionOfShell(CString &strVersion);
	LPCTSTR GetServerName();
	BOOL GetConnectedToServerState();
	IEmManager* GetEmManager();
	BOOL DisconnectFromServer();
	HRESULT ConnectToServer(CString &strServer);
	virtual ~CEmshellDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	CConnectionDlg m_connectionDlg;
	IEmManager* m_pIEmManager;
	BOOL m_bConnectedToServer;
    CString m_strServerName;
	//{{AFX_MSG(CEmshellDoc)
	afx_msg void OnFileConnect();
	afx_msg void OnFileDisconnect();
	afx_msg void OnUpdateFileDisconnect(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EMSHELLDOC_H__DE402522_2120_4FEC_92AA_41CD749E2ADF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emshelldoc.cpp ===
// emshellDoc.cpp : implementation of the CEmshellDoc class
//

#include "stdafx.h"
#include "emshell.h"
#include "emshellview.h"
#include "emshellDoc.h"
#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEmshellDoc

IMPLEMENT_DYNCREATE(CEmshellDoc, CDocument)

BEGIN_MESSAGE_MAP(CEmshellDoc, CDocument)
	//{{AFX_MSG_MAP(CEmshellDoc)
	ON_COMMAND(ID_FILE_CONNECT, OnFileConnect)
	ON_COMMAND(ID_FILE_DISCONNECT, OnFileDisconnect)
	ON_UPDATE_COMMAND_UI(ID_FILE_DISCONNECT, OnUpdateFileDisconnect)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmshellDoc construction/destruction

CEmshellDoc::CEmshellDoc()
{
	// TODO: add one-time construction code here
	m_pIEmManager							= NULL;
	m_bConnectedToServer					= FALSE;
}

CEmshellDoc::~CEmshellDoc()
{
	//m_pEImManager should have been released in OnDestroy()
	_ASSERTE(m_pIEmManager == NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CEmshellDoc serialization

void CEmshellDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CEmshellDoc diagnostics

#ifdef _DEBUG
void CEmshellDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CEmshellDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CEmshellDoc commands

HRESULT CEmshellDoc::ConnectToServer(CString &strServer)
{
	COSERVERINFO	si;
	MULTI_QI		qi;
	HRESULT			hr		= E_FAIL;
	POSITION		pos		= NULL;
	CEmshellView*	pView	= NULL;

//NOTE: We need to determine if this remains
	//Synchronize the dialog controls to their member vairables
//	UpdateData(TRUE);
//***********************************

	si.dwReserved1	= 0;
	//Since we know the server name won't be changed by the COM call, we'll cast it
	//to an LPTSTR so we can assign it to the COSERVERINFO.pwszName data member
	si.pwszName		= (LPTSTR) (LPCTSTR) strServer;
	si.pAuthInfo	= NULL;
	si.dwReserved2	= 0;

	//Later, we might want to get a whole slew of interfaces, for now
	//just get the EmManager
	qi.pIID = &IID_IEmManager;
	qi.pItf = NULL;
	qi.hr	= 0;
	
	do {
		hr = CoCreateInstanceEx(CLSID_EmManager, NULL, CLSCTX_ALL, &si, 1, &qi);
		
		if ( FAILED(hr) ) break;

		//Store off the pointer to the EmManager interface
		m_pIEmManager = (IEmManager*) qi.pItf;
		
		//Set the connected to server flag
		m_bConnectedToServer = TRUE;
		
		//Append the build number to the server name
//		AppendVersionOfShell(strServer)

		//Set the title to the server we're connected too
		SetTitle(strServer);
        
        //Store off the server name
        m_strServerName = strServer;

		CString strStatus;
		strStatus.LoadString(IDS_CONNECTED);
		((CMainFrame*)AfxGetMainWnd())->GetStatusBar()->SetPaneText(1, strStatus);

		pos = GetFirstViewPosition();
		if ( pos == NULL ) break;

		pView = (CEmshellView*) GetNextView(pos);
		if ( pView == NULL ) break;

		//Maybe we should move this into the view... Say PostConnectServer()
        EMShellViewState state = pView->GetViewState();
	    pView->SetShellState(state);
	    pView->ListCtrlPopulate(state);

		pView->m_mainListControl.ResizeColumnsFitScreen();

        DWORD dwPollSessionsFreq = 30L; // default is 30 secs
        ((CEmshellApp*)AfxGetApp())->GetEmShellRegOptions( TRUE, &dwPollSessionsFreq );

		pView->SetTimer(1, dwPollSessionsFreq*1000, 0);
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	return hr;
}

BOOL CEmshellDoc::DisconnectFromServer()
{
	BOOL	bDisconnected		= FALSE;
	CEmshellView*	pView		= NULL;
	POSITION		pos			= NULL;
	CString			strText;

	strText.LoadString(IDS_DISCONNECTWARNING);

	do {
		pos = GetFirstViewPosition();
		if ( pos == NULL ) break;

		pView = (CEmshellView*) GetNextView(pos);
		if ( pView == NULL ) break;

 		//Set the cursor to a wait cursor
 		CWaitCursor wait;
		
		bDisconnected = TRUE;

		//Reuse strText
		strText.LoadString(IDS_DISCONNECTED);

		//Set the title to the server we're connected to
		SetTitle(strText);
		((CMainFrame*)AfxGetMainWnd())->GetStatusBar()->SetPaneText(1, strText);


		//We need to make sure the timer doesn't get through when the list is empty
		//Destroy the timer first
		pView->KillTimer(1);

		//Clear all the sessions from the session table
		pView->ClearSessionTable();
		
		//Clear all the items from the list control
		pView->ListCtrlClear();

		//Release the m_pIEmManager
		SAFE_RELEASEIX(m_pIEmManager);

		//Set the connected state to false
		m_bConnectedToServer = FALSE;
	} while (FALSE);
	
	return bDisconnected;
}

void CEmshellDoc::OnFileConnect() 
{
	//Create the connection dialog
	int				result		= 0;
	HRESULT			hr			= E_FAIL;
	BOOL			bDisconnected = FALSE;
    CString         strText, strCaption;

	do {
        if (m_bConnectedToServer) {

            strText.LoadString(IDS_DISCONNECTWARNING);
	        strCaption.LoadString(IDS_DISCONNECTCAPTION);

		    //Notify the user that they are going to disconnect their current
		    //session if they want to continue
		    if (AfxGetMainWnd()->MessageBox(strText, strCaption, MB_OKCANCEL|MB_ICONWARNING) == IDCANCEL) break;		
		
            DisconnectFromServer();

        }

 		//Open the connection dialog
 		result = (int)m_connectionDlg.DoModal();

 		//If the user selected OK, call ConnectToServer
 		if (result == IDOK) {

 			//Set the cursor to a wait cursor
 			CWaitCursor wait;

			//Store off the server name and 
 			if (m_connectionDlg.m_bLocalServer)
 				hr = ConnectToServer(m_connectionDlg.m_strLocalMachineName);
 			else
 				hr = ConnectToServer(m_connectionDlg.m_strRemoteMachineName);
 			
 			if (SUCCEEDED(hr)) break;

 		}

	} while (result == IDOK);
}

void CEmshellDoc::OnFileDisconnect() 
{
    CString strText, strCaption;

	strText.LoadString(IDS_DISCONNECTWARNING);
	strCaption.LoadString(IDS_DISCONNECTCAPTION);

	if ( AfxGetMainWnd()->MessageBox( strText, strCaption, MB_OKCANCEL|MB_ICONWARNING ) == IDOK )
        DisconnectFromServer();
}

IEmManager* CEmshellDoc::GetEmManager()
{
	return m_pIEmManager;
}

BOOL CEmshellDoc::GetConnectedToServerState()
{
	return m_bConnectedToServer;
}

BOOL CEmshellDoc::CanCloseFrame(CFrameWnd* pFrame) 
{
	BOOL bDisconnect = TRUE;

	// TODO: Add your specialized code here and/or call the base class
	//Ask the user if they would like to close the connection to the server
	if ( m_bConnectedToServer ) {
		bDisconnect = DisconnectFromServer();
	}
	
	if ( bDisconnect ) {
		bDisconnect = CDocument::CanCloseFrame(pFrame);
	}

	return bDisconnect;
}

BOOL CEmshellDoc::OnNewDocument() 
{
	// TODO: Add your specialized code here and/or call the base class
	CString strVal;
	strVal.LoadString(IDS_DISCONNECTED);
	SetTitle(strVal);

    CWnd * pWnd = AfxGetMainWnd();

    if ( pWnd && pWnd->IsKindOf ( RUNTIME_CLASS (CMainFrame) ) )  {
            CMainFrame *pFrame = ( CMainFrame* ) pWnd;
            pFrame->GetStatusBar()->SetPaneText ( 1, strVal );
    }

	return CDocument::OnNewDocument();
}

void CEmshellDoc::OnUpdateFileDisconnect(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	pCmdUI->Enable ( GetConnectedToServerState() );	
}

LPCTSTR CEmshellDoc::GetServerName()
{
    return m_strServerName;
}

void CEmshellDoc::AppendVersionOfShell(CString &strVersion)
{
//	GetFileVersionInfoSize();
//	GetFileVersionInfo();
//	VerQueryValue();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emshellview.cpp ===
// emshellView.cpp : implementation of the CEmshellView class
//

#include "stdafx.h"
#include "emshell.h"
#include "ConnectionDlg.h"
#include "comdef.h"
#include "AutomaticSessDlg.h"
#include "RemoteSessDlg.h"
#include "PropPageGeneral.h"
#include "PropPageDumpFiles.h"
#include "PropPageLogFiles.h"
#include "PropPageGenLogDump.h"
#include "ReadLogsDlg.h"
#include "EmOptions.h"
#include "MSInfoDlg.h"

#include "emshellDoc.h"
#include "emshellView.h"
#include "afxdlgs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ISTREAM_BUFFER_SIZE 0X10000

extern const TCHAR* gtcNone;
const TCHAR* gtcEmChm = _T("\\em.chm");

/////////////////////////////////////////////////////////////////////////////
// CEmshellView

IMPLEMENT_DYNCREATE(CEmshellView, CFormView)

BEGIN_MESSAGE_MAP(CEmshellView, CFormView)
	//{{AFX_MSG_MAP(CEmshellView)
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_WM_TIMER()
	ON_UPDATE_COMMAND_UI(ID_VIEW_REFRESH, OnUpdateViewRefresh)
	ON_COMMAND(ID_REFRESH, OnViewRefresh)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_STOPSESSION, OnUpdateProcesspopupStopDebugSession)
	ON_COMMAND(ID_PROCESSPOPUP_STOPSESSION, OnProcesspopupStopDebugSession)
	ON_COMMAND(ID_PROCESSPOPUP_GENERATEMINIDUMP, OnProcesspopupGenerateminidump)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_GENERATEMINIDUMP, OnUpdateProcesspopupGenerateminidump)
	ON_COMMAND(ID_PROCESSPOPUP_GENERATEUSERDUMP, OnProcesspopupGenerateuserdump)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_GENERATEUSERDUMP, OnUpdateProcesspopupGenerateuserdump)
	ON_COMMAND(ID_PROCESSPOPUP_AUTOMATICSESSION, OnProcesspopupAutomaticsession)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_AUTOMATICSESSION, OnUpdateProcesspopupAutomaticsession)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_PROPERTIES, OnUpdateProcesspopupProperties)
	ON_COMMAND(ID_PROCESSPOPUP_PROPERTIES, OnProcesspopupProperties)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_MANUALSESSION, OnUpdateProcesspopupManualsession)
	ON_COMMAND(ID_PROCESSPOPUP_MANUALSESSION, OnProcesspopupManualsession)
	ON_COMMAND(ID_PROCESSPOPUP_REFRESH, OnProcesspopupRefresh)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_REFRESH, OnUpdateProcesspopupRefresh)
	ON_COMMAND(ID_VIEW_SERVICESANDAPPLICATIONS, OnViewServicesandapplications)
	ON_UPDATE_COMMAND_UI(ID_VIEW_SERVICESANDAPPLICATIONS, OnUpdateViewServicesandapplications)
	ON_COMMAND(ID_VIEW_LOGFILES, OnViewLogfiles)
	ON_UPDATE_COMMAND_UI(ID_VIEW_LOGFILES, OnUpdateViewLogfiles)
	ON_COMMAND(ID_VIEW_DUMPFILES, OnViewDumpfiles)
	ON_UPDATE_COMMAND_UI(ID_VIEW_DUMPFILES, OnUpdateViewDumpfiles)
	ON_UPDATE_COMMAND_UI(ID_LOGPOPUP_OPEN, OnUpdateLogpopupOpen)
	ON_COMMAND(ID_LOGPOPUP_OPEN, OnLogpopupOpen)
	ON_UPDATE_COMMAND_UI(ID_LOGPOPUP_PROPERTIES, OnUpdateLogpopupProperties)
	ON_COMMAND(ID_LOGPOPUP_PROPERTIES, OnLogpopupProperties)
	ON_COMMAND(ID_VIEW_APPLICATIONS, OnViewApplications)
	ON_UPDATE_COMMAND_UI(ID_VIEW_APPLICATIONS, OnUpdateViewApplications)
	ON_COMMAND(ID_VIEW_COMPLETEDSESSIONS, OnViewCompletedsessions)
	ON_UPDATE_COMMAND_UI(ID_VIEW_COMPLETEDSESSIONS, OnUpdateViewCompletedsessions)
	ON_COMMAND(ID_VIEW_SERVICES, OnViewServices)
	ON_UPDATE_COMMAND_UI(ID_VIEW_SERVICES, OnUpdateViewServices)
	ON_COMMAND(ID_PROCESSPOPUP_DELETESESSION, OnProcesspopupDeleteSession)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_DELETESESSION, OnUpdateProcesspopupDeleteSession)
	ON_COMMAND(IDM_TOOLS_OPTOINS, OnToolsOptions)
	ON_UPDATE_COMMAND_UI(IDM_TOOLS_OPTOINS, OnUpdateToolsOptoins)
	ON_COMMAND(ID_PROCESSPOPUP_CANCELSESSION, OnProcesspopupCancelDebugSession)
	ON_UPDATE_COMMAND_UI(ID_PROCESSPOPUP_CANCELSESSION, OnUpdateProcesspopupCancelDebugSession)
	ON_COMMAND(ID_LOGPOPUP_DELETE, OnLogpopupDelete)
	ON_UPDATE_COMMAND_UI(ID_LOGPOPUP_DELETE, OnUpdateLogpopupDelete)
	ON_COMMAND(ID_ACTION_GENERATENFOFILE, OnActionGenerateMSInfoFile)
	ON_UPDATE_COMMAND_UI(ID_ACTION_GENERATENFOFILE, OnUpdateActionGenerateMSInfoFile)
	ON_COMMAND(ID_VIEW_MSINFOFILES, OnViewMSInfoFiles)
	ON_UPDATE_COMMAND_UI(ID_VIEW_MSINFOFILES, OnUpdateViewMSInfoFiles)
	ON_COMMAND(ID_LOGPOPUP_EXPORT, OnLogpopupExport)
	ON_UPDATE_COMMAND_UI(ID_LOGPOPUP_EXPORT, OnUpdateLogpopupExport)
	ON_COMMAND(ID_VIEW_REFRESH, OnViewRefresh)
	ON_COMMAND(ID_HELP_CONTENTS, OnHelpContents)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CFormView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CFormView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CFormView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmshellView construction/destruction

CEmshellView::CEmshellView()
	: CFormView(CEmshellView::IDD),
	m_mainListControl(this)
{
	//{{AFX_DATA_INIT(CEmshellView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    memset ( &m_lastSelectedEmObj, 0, sizeof ( EmObject ) );
}

CEmshellView::~CEmshellView()
{
}

void CEmshellView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEmshellView)
	DDX_Control(pDX, IDC_LST_MAINLISTCTRL, m_mainListControl);
	//}}AFX_DATA_MAP
}

BOOL CEmshellView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CFormView::PreCreateWindow(cs);
}

void CEmshellView::OnInitialUpdate()
{
	CFormView::OnInitialUpdate();
	SetShellState(SHELLVIEW_ALL);
	GetParentFrame()->RecalcLayout();
	ResizeParentToFit();
}

/////////////////////////////////////////////////////////////////////////////
// CEmshellView diagnostics

#ifdef _DEBUG
void CEmshellView::AssertValid() const
{
	CFormView::AssertValid();
}

void CEmshellView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}

CEmshellDoc* CEmshellView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CEmshellDoc)));
	return (CEmshellDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CEmshellView message handlers

BSTR
CopyBSTR
(
    LPBYTE  pb,
    ULONG   cb
)
{
    return ::SysAllocStringByteLen ((LPCSTR)pb, cb);
}

void CEmshellView::OnSize(UINT nType, int cx, int cy) 
{
	CFormView::OnSize(nType, cx, cy);
	
    if (m_mainListControl.GetSafeHwnd()) {
		UINT delta = 0;

//		m_mainListControl.ResizeColumnsWithRatio();
		m_mainListControl.MoveWindow(delta, delta, cx - (delta*2), cy- (delta*2));
	}

    SetScrollSizes(MM_TEXT, CSize(cx, cy));
	
}

PEmObject GetEmObj(BSTR bstrEmObj)
{
	//Do a simple cast from a BSTR to an EmObject
    return ((PEmObject)bstrEmObj);
}

HRESULT CEmshellView::DisplayLogData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	CString	strFileSize;
	CString	strStartDate;
	LONG	lRow			=	0L;
	int		nImage			=	0;
	int nImageOffset		=	0;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		strFileSize.Format(_T("%d"), pEmObject->dwBucket1);
		
		lRow = m_mainListControl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		//Set the itemData
		m_mainListControl.SetItemData(lRow, (ULONG_PTR) pEmObject);
		
		//Get the correct offset into the bitmap for the current status
		nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

		//Call SetItem() with the index and image to show based on the state of pEmObject
		m_mainListControl.SetItem(lRow, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

		lRow = m_mainListControl.SetItemText(lRow, 1, strFileSize);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

        //
        // a-mando
        //
        if( pEmObject->dateStart ) {

            COleDateTime oleDtTm( pEmObject->dateStart );
            strStartDate = oleDtTm.Format(_T("%c"));
		    lRow = m_mainListControl.SetItemText(lRow, 2, strStartDate);
		    if(lRow == -1L){
			    hr = E_FAIL;
			    break;
		    }
        }
        // a-mando

		hr = S_OK;
	}
	while( false );

	return hr;
}

HRESULT CEmshellView::DisplayMSInfoData(PEmObject pEmObject)
{
    return DisplayDumpData(pEmObject);
}

HRESULT CEmshellView::DisplayDumpData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	CString	strFileSize;
	CString	strStartDate;
	LONG	lRow			=	0L;
	int		nImage			=	0;
	int nImageOffset		=	0;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		strFileSize.Format(_T("%d"), pEmObject->dwBucket1);
		
		lRow = m_mainListControl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		//Set the itemData
		m_mainListControl.SetItemData(lRow, (ULONG_PTR) pEmObject);
		
		//Get the correct offset into the bitmap for the current status
		nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

		//Call SetItem() with the index and image to show based on the state of pEmObject
		m_mainListControl.SetItem(lRow, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

		lRow = m_mainListControl.SetItemText(lRow, 1, strFileSize);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

        //
        // a-mando
        //
        if( pEmObject->dateStart ) {

            COleDateTime oleDtTm( pEmObject->dateStart );
            strStartDate = oleDtTm.Format(_T("%c"));
		    lRow = m_mainListControl.SetItemText(lRow, 2, strStartDate);
		    if(lRow == -1L){
			    hr = E_FAIL;
			    break;
		    }
        }
        // a-mando

		hr = S_OK;
	}
	while( false );

	return hr;
}

HRESULT CEmshellView::DisplayServiceData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	TCHAR	szPid[20]		=	{0};
	LONG	lRow			=	0L;
	int		nImage			=	0;
	CString csPROCStatus;
	int nImageOffset		=	0;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		_ltot(pEmObject->nId, szPid, 10);
		
		lRow = m_mainListControl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		//Set the itemData
		m_mainListControl.SetItemData(lRow, (ULONG_PTR) pEmObject);
		
		//Get the correct offset into the bitmap for the current status
		nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

		//Call SetItem() with the index and image to show based on the state of pEmObject
		m_mainListControl.SetItem(lRow, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

		lRow = m_mainListControl.SetItemText(lRow, 1, pEmObject->szSecName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		lRow = m_mainListControl.SetItemText(lRow, 2, pEmObject->szBucket1);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		lRow = m_mainListControl.SetItemText(lRow, 3, szPid);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

        //
        // a-mando
        //
        if( pEmObject->dateStart != 0L ) {

            COleDateTime oleDtTm(pEmObject->dateStart);
            CString strStartDate = oleDtTm.Format(_T("%c"));

            lRow = m_mainListControl.SetItemText(lRow, 4, strStartDate );
		    if(lRow == -1L){
			    hr = E_FAIL;
			    break;
		    }
        }

        if( pEmObject->dateEnd != 0L ) {

            COleDateTime oleDtTm(pEmObject->dateEnd);
            CString strEndDate = oleDtTm.Format(_T("%c"));

            lRow = m_mainListControl.SetItemText(lRow, 5, strEndDate );
		    if(lRow == -1L){
			    hr = E_FAIL;
			    break;
		    }
        }
        // a-mando

        ((CEmshellApp*)AfxGetApp())->GetStatusString(pEmObject->nStatus, csPROCStatus);

		lRow = m_mainListControl.SetItemText(lRow, 6, csPROCStatus);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		hr = S_OK;
	}
	while( false );

	return hr;
}

HRESULT CEmshellView::DisplayProcessData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	TCHAR	szPid[20]		=	{0};
	LONG	lRow			=	0L;
	int		nImage			=	0;
	CString csPROCStatus;
	int nImageOffset		=	0;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		_ltot(pEmObject->nId, szPid, 10);
		
		lRow = m_mainListControl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		//Set the itemData
		m_mainListControl.SetItemData(lRow, (ULONG_PTR) pEmObject);
		
		//Get the correct offset into the bitmap for the current status
		nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

		//Call SetItem() with the index and image to show based on the state of pEmObject
		m_mainListControl.SetItem(lRow, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

		lRow = m_mainListControl.SetItemText(lRow, 1, szPid);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

        //
        // a-mando
        //
        if( pEmObject->dateStart != 0L ) {

            COleDateTime oleDtTm(pEmObject->dateStart);
            CString strStartDate = oleDtTm.Format(_T("%c"));

            lRow = m_mainListControl.SetItemText(lRow, 2, strStartDate );
		    if(lRow == -1L){
			    hr = E_FAIL;
			    break;
		    }
        }

        if( pEmObject->dateEnd != 0L ) {

            COleDateTime oleDtTm(pEmObject->dateEnd);
            CString strEndDate = oleDtTm.Format(_T("%c"));

            lRow = m_mainListControl.SetItemText(lRow, 3, strEndDate );
		    if(lRow == -1L){
			    hr = E_FAIL;
			    break;
		    }
        }
        // a-mando

        ((CEmshellApp*)AfxGetApp())->GetStatusString(pEmObject->nStatus, csPROCStatus);

		lRow = m_mainListControl.SetItemText(lRow, 4, csPROCStatus);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		hr = S_OK;
	}
	while( false );

	return hr;
}

HRESULT CEmshellView::DisplayStoppedSessionData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

    return DisplayServiceData(pEmObject);
}

void CEmshellView::OnDestroy() 
{
	CFormView::OnDestroy();
	
	//If we have sessions still open, there is a big problem
	ASSERT(m_SessionTable.GetSize() == 0);

//	m_ShellImageList.DeleteImageList();
}

CPtrArray* CEmshellView::GetSessionTable()
{
	return &m_SessionTable;
}

void CEmshellView::ClearSessionTable()
{
	//Iterate through the collection removing all the elements and calling release on all the
	//session pointers.  Also, call StopDebugSession CloseActiveSession and RemoveActiveSession 
	//on all the active sessions
	IEmDebugSession*	dsValue			= NULL;
	INT_PTR				nUpperBound		= 0;
	PActiveSession		pActiveSession	= NULL;
	HRESULT				hr				= S_OK;

	do {
		//Get the size of the array, start at the end, and remove each element
		nUpperBound = m_SessionTable.GetUpperBound();
		if( nUpperBound == -1 ) break;

		for ( ; nUpperBound >= 0; nUpperBound-- ) {
			pActiveSession = ( PActiveSession ) m_SessionTable.GetAt( nUpperBound );

			if ( pActiveSession == NULL ) {
				hr = E_FAIL;
				break;
			}

/*			memcpy((void*)&emObject.guidstream, (void*)&pActiveSession->guid, sizeof( GUID ));

			//Call StopDebug on this active session if we're the master.
			if (pActiveSession->bMaster) {
				hr = pActiveSession->pIDebugSession->StopDebug();
				//So what are we supposed to do if it fails?  We should still remove it from the active
				//session table.
			}

			//Create bstr's for the journey ahead, and break if we can't
			bstrEmObj = CopyBSTR ( (LPBYTE)&emObject, sizeof( EmObject ) );

			if( bstrEmObj == NULL ){
				hr = E_OUTOFMEMORY;
				break;
			}
			
			//Call CloseSession on the pEmObject
			hr = GetDocument()->GetEmManager()->CloseSession(bstrEmObj);

			if (FAILED(hr)) {
				CString strErrorMsg;
				strErrorMsg.LoadString(IDS_ERROR_FAILEDCLOSESESSION);
				((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString(strErrorMsg);
				//We've handled the error, so set hr back to S_OK for the next time round
				hr = S_OK;
			}
*/
			//Delete the pActiveSession.  This will release the interface too
			DeAllocActiveSession( pActiveSession );

			//Remove the item from the array
			m_SessionTable.RemoveAt( nUpperBound );
		}
	} while ( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}
}

HRESULT CEmshellView::StartManualDebugSession(EmObject* pEmObject)
{
	IEmDebugSession*	pIEmDebugSession	= NULL;
	HRESULT				hr					= E_FAIL;
	BOOL				bRetVal				= FALSE;
	CString				strMessage;
	INT_PTR		nResult			= 0;
	BSTR		bstrPath        = NULL;
	BSTR		bstrEmObj       = NULL;
	BSTR		bstrECXEmObject = NULL;
	_variant_t	varUsername;
	_variant_t	varPort;
	_variant_t	varPassword;
	_variant_t	varAltSymPath;
	EmObject	EmObjectFilter;
	PEmObject	pEmObjectTmp	= NULL;

	_variant_t		var;	//This will create and initialize the var variant
	LONG lParam = 0;

	do {
		//Create bstr's for the journey ahead, and break if we can't
		bstrEmObj = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );
		if( bstrEmObj == NULL ){
			hr = E_OUTOFMEMORY;
			break;
		}
		
		memcpy(&EmObjectFilter, pEmObject, sizeof( EmObject ) );
		EmObjectFilter.type = EMOBJ_CMDSET;
		bstrECXEmObject = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		
		//Start a debug session with OpenSession()
		hr = GetDocument()->GetEmManager()->OpenSession(bstrEmObj, &pIEmDebugSession);
		

		if ( hr == S_OK ) {
			//Get the EnumObjects for the ECX list control so we can pass it to the dlg
			hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrECXEmObject, &var);

			if ( FAILED(hr) ) break;

            PSessionSettings pSessionSettings = &((CEmshellApp*)AfxGetApp())->m_SessionSettings;
			
            //Create the Automatic Session Dialog
			CRemoteSessDlg dlg(pSessionSettings, &var);

			nResult = dlg.DoModal();
			
			if ( nResult == IDOK ) {
				//Check if the user wanted to save the settings, if so, call UpdateSessionDlgData(FALSE)
				if ( dlg.m_bRememberSettings ) {
                    ((CEmshellApp*)AfxGetApp())->UpdateSessionData( TRUE );
				}

                if ( !dlg.m_strSelectedCommandSet.IsEmpty() && dlg.m_strSelectedCommandSet != gtcNone) {
				    bstrPath = dlg.m_strSelectedCommandSet.AllocSysString();
				    if( bstrPath == NULL ){
					    hr = E_OUTOFMEMORY;
					    break;
				    }
                } else {
                    bstrPath = ::SysAllocString( _T("") );
                }
				
				varUsername		= pSessionSettings->strUsername.AllocSysString();
				varPassword		= pSessionSettings->strPassword.AllocSysString();
				
				varPort.ChangeType(VT_I4);
				varPort.lVal	= _ttoi(pSessionSettings->strPort);
				varAltSymPath	= pSessionSettings->strAltSymbolPath.AllocSysString();

				//Init the var to nothing
				var.Clear();

				//Time to call DebugEx(), get ready for the ride!
				hr = pIEmDebugSession->DebugEx(bstrEmObj, 
											   SessType_Manual,
											   bstrPath, 
											   lParam,	
											   varUsername, 
											   varPassword, 
											   varPort, 
											   var, 
											   varAltSymPath);
		        
				//We don't need the bstr's, release them.
				SysFreeString ( bstrPath );

                if ( FAILED(hr) ) break;
				
				//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
				pEmObjectTmp = GetEmObj(bstrEmObj);
				if( pEmObject == NULL ){
					hr = E_FAIL;
					break;
				}
				
				memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );

				AddActiveSession(pEmObject, pIEmDebugSession, TRUE);

/*				TCHAR  szClientConnectString[_MAX_PATH] = {0};
				//Start the local cdb session
				GetClientConnectString(szClientConnectString, _MAX_PATH, pEmObject, varPort.lVal);
				hr = StartCDBClient(szClientConnectString);
				if ( FAILED(hr) ) break;
*/				

			}
			else {
				//release the debugsession pointer,  the user decided to cancel
				if ( pIEmDebugSession != NULL )
					//If we got here, we shouldn't have created an active session, so just release the
					//debug interface
					SAFE_RELEASEIX(pIEmDebugSession);
			}

		}
		else if ( hr == S_FALSE ) {
			//We were not able to open a master session, ask the user if they 
			//would like to be the owner if this is an orphan

			if ( pEmObject->nStatus & STAT_ORPHAN ) {
			    if ( CommenceOrphanCustodyBattle( pIEmDebugSession ) ) {
		            //Get the status of the EmObject
                    hr = pIEmDebugSession->GetStatus( bstrEmObj );
		            if ( FAILED( hr ) ) break;

				    //Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
				    pEmObjectTmp = GetEmObj(bstrEmObj);
				    if (pEmObjectTmp == NULL) break;

				    memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );

				    AddActiveSession(pEmObject, pIEmDebugSession, TRUE);
                    break;
			    }
			}

			
			//We were not able to open a master session, ask the user if they 
			//would like to spectate
			strMessage.LoadString( IDS_DEBUG_ERROR );

            if ( ( (CEmshellApp*) AfxGetApp() )->DisplayErrMsgFromString( strMessage, MB_YESNO ) == IDYES ) {
				
				//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
				pEmObjectTmp = GetEmObj(bstrEmObj);
				if (pEmObjectTmp == NULL) break;

				memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );

				AddActiveSession(pEmObject, pIEmDebugSession, FALSE);
                break;
            }
			else {
				//Release the debug interface, we never created an activesession.
				SAFE_RELEASEIX(pIEmDebugSession);
			}
		}
	} while (FALSE);

	if (FAILED(hr)) {
		if ( pIEmDebugSession != NULL )
			//If we got here, we shouldn't have created an active session, so just release the
			//debug interface
			SAFE_RELEASEIX(pIEmDebugSession);
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	SysFreeString ( bstrPath );
    SysFreeString ( bstrEmObj );
	SysFreeString ( bstrECXEmObject );

	//Update the status of the EmObjects ListElement to reflect it's new status
	UpdateListElement(pEmObject);
	
	return hr;
}

HRESULT CEmshellView::StartAutomaticDebugSession(PEmObject pEmObject)
{
	IEmDebugSession*	pIEmDebugSession	= NULL;
	HRESULT				hr					= E_FAIL;
	BOOL				bRetVal				= FALSE;
	CString				strMessage;
	INT_PTR				nResult				= 0;
	BSTR				bstrPath            = NULL;
	BSTR				bstrEmObj           = NULL;
	BSTR				bstrECXEmObject     = NULL;
	_variant_t			varAdminName;
	_variant_t			varAltSymPath;
	PEmObject			pEmObjectTmp		= NULL;
	EmObject			EmObjectFilter;

	_variant_t		var;	//This will create and initialize the var variant
	LONG lParam = 0;

	do {
		//Create bstr's for the journey ahead, and break if we can't
		bstrEmObj = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );
		memcpy(&EmObjectFilter, pEmObject, sizeof( EmObject ) );
		EmObjectFilter.type = EMOBJ_CMDSET;
		bstrECXEmObject = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );

		if( bstrEmObj == NULL ){
			hr = E_OUTOFMEMORY;
			break;
		}
		
		//Start a debug session with OpenSession()
		hr = GetDocument()->GetEmManager()->OpenSession(bstrEmObj, &pIEmDebugSession);
		
		if ( hr == S_OK ) {
			//Get the EnumObjects for the ECX list control so we can pass it to the dlg
			hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrECXEmObject, &var);

			if ( FAILED(hr) ) break;
            
            PSessionSettings pSessionSettings = &((CEmshellApp*)AfxGetApp())->m_SessionSettings;
			
			//Create the Automatic Session Dialog
			CAutomaticSessDlg dlg(pSessionSettings, &var, (EmObjectType)pEmObject->type);

			nResult = dlg.DoModal();
			
			if ( nResult == IDOK ) {
				//Check if the user wanted to save the settings, if so, call UpdateRegistry()
				if ( dlg.m_bRememberSettings ) {
                    ((CEmshellApp*)AfxGetApp())->UpdateSessionData( TRUE );
                }

				bstrPath = dlg.m_strSelectedCommandSet.AllocSysString();
				if( bstrPath == NULL ){
					hr = E_OUTOFMEMORY;
					break;
				}
				
				varAdminName = pSessionSettings->strAdminName.AllocSysString();
				varAltSymPath = pSessionSettings->strAltSymbolPath.AllocSysString();

				//Init the var to nothing
				var.Clear();

				if ( dlg.m_bRecursiveMode )		lParam = lParam | RECURSIVE_MODE;
				if ( dlg.m_bMiniDump )			lParam = lParam | PRODUCE_MINI_DUMP;
				if ( dlg.m_bUserDump )			lParam = lParam | PRODUCE_USER_DUMP;
				
		        //Set the cursor to a wait cursor
		        CWaitCursor wait;

				//Time to call DebugEx(), get ready for the ride!
				hr = pIEmDebugSession->DebugEx(bstrEmObj, 
											   SessType_Automatic,
											   bstrPath, 
											   lParam,	
											   var, 
											   var, 
											   var, 
											   varAdminName, 
											   varAltSymPath);
		        
				//We don't need the bstr's, release them.
				SysFreeString ( bstrPath );
    
				if ( FAILED(hr) ) break;
				
				//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
				pEmObjectTmp = GetEmObj(bstrEmObj);
				if( pEmObject == NULL ){
					hr = E_FAIL;
					break;
				}
				
				memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );

				AddActiveSession(pEmObject, pIEmDebugSession, TRUE);

            }
			else {
				//release the debugsession pointer,  the user decided to cancel
				if ( pIEmDebugSession != NULL )
					//If we got here, we shouldn't have created an active session, so just release the
					//debug interface
					SAFE_RELEASEIX(pIEmDebugSession);
			}

		}
		else if ( hr == S_FALSE ) {
			//We were not able to open a master session, ask the user if they 
			//would like to be the owner if this is an orphan

			if ( pEmObject->nStatus & STAT_ORPHAN ) {
			    if ( CommenceOrphanCustodyBattle( pIEmDebugSession ) ) {
		            //Get the status of the EmObject
                    hr = pIEmDebugSession->GetStatus( bstrEmObj );
		            if ( FAILED( hr ) ) break;

				    //Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
				    pEmObjectTmp = GetEmObj(bstrEmObj);
				    if (pEmObjectTmp == NULL) break;

				    memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );

				    AddActiveSession(pEmObject, pIEmDebugSession, TRUE);
                    break;
			    }
			}

			
			//We were not able to open a master session, ask the user if they 
			//would like to spectate
			strMessage.LoadString( IDS_DEBUG_ERROR );

			if (((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString(strMessage, MB_YESNO) == IDYES) {

				//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
				pEmObjectTmp = GetEmObj(bstrEmObj);
				if (pEmObjectTmp == NULL) break;

				memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );

				AddActiveSession(pEmObject, pIEmDebugSession, FALSE);
                break;
            }
			else {
				//Release the debug interface, we never created an activesession.
				SAFE_RELEASEIX(pIEmDebugSession);
			}
		}
	} while (FALSE);

	if (FAILED(hr)) {
		if ( pIEmDebugSession != NULL )
			//If we got here, we shouldn't have created an active session, so just release the
			//debug interface
			SAFE_RELEASEIX(pIEmDebugSession);
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	SysFreeString ( bstrPath );
    SysFreeString ( bstrEmObj );
	SysFreeString ( bstrECXEmObject );

	//Update the status of the EmObjects ListElement to reflect it's new status
	UpdateListElement(pEmObject);
	
	return hr;
}

void CEmshellView::DeAllocActiveSession(PActiveSession pActiveSession)
{
	//Release the DebugSession
	SAFE_RELEASEIX(pActiveSession->pIDebugSession);
	if (pActiveSession != NULL)
		delete pActiveSession;
	else ((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(E_FAIL);
}

PActiveSession CEmshellView::AllocActiveSession(PEmObject pEmObject, IEmDebugSession* pIDebugSession)
{
	HRESULT			hr				= E_FAIL;
	PActiveSession	pActiveSession	= NULL;

	do {
		//Allocate an ActiveSession object, initialize it, and return it
		pActiveSession = new ActiveSession;
		if (pActiveSession == NULL) {
			hr = E_OUTOFMEMORY;
			break;
		}
		
		//Initialize the members
		pActiveSession->pEmObject = pEmObject;
		pActiveSession->pIDebugSession = pIDebugSession;
		pActiveSession->bMaster = FALSE;
		memcpy((void*)&pActiveSession->guid, (void*)pEmObject->guidstream, sizeof( GUID ));
		hr = S_OK;
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	return pActiveSession;
}

void CEmshellView::OnTimer(UINT nIDEvent) 
{
	INT_PTR			nUpperBound		= 0;
	PActiveSession	pActiveSession	= NULL;
	HRESULT			hr				= S_OK;
	PEmObject		pEmObject		= NULL;
	BSTR			bstrEmObj       = NULL;
	PEmObject		pEmObjectTmp	= NULL;

	if ( m_SessionTable.GetSize() > 0 ) {
		//Step through all the elements in the session table updating the status if it has a valid pEmObject
		for ( nUpperBound = m_SessionTable.GetUpperBound(); nUpperBound >= 0; nUpperBound-- ) {
			pActiveSession = ( PActiveSession ) m_SessionTable.GetAt( nUpperBound );

			if ( pActiveSession == NULL ) {
				hr = E_FAIL;
				break;
			}

			pEmObject = pActiveSession->pEmObject;

			//If we don't have an EmObject to refresh, we don't need to handle this one.
			if( pEmObject == NULL ) {
				continue;
			}
			
			//Create bstr's for the journey ahead, and break if we can't
			bstrEmObj = CopyBSTR ( ( LPBYTE )pEmObject, sizeof( EmObject ) );

			if( bstrEmObj == NULL ){
				hr = E_OUTOFMEMORY;
				break;
			}
			
			hr = pActiveSession->pIDebugSession->GetStatus( bstrEmObj );

			//If we failed to get the status on this session, don't stop, just continue to the next session
			if (FAILED( hr )) {
				hr = S_OK;
				continue;
			}

			//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
			pEmObjectTmp = GetEmObj( bstrEmObj );
			if ( pEmObjectTmp == NULL ) {
				hr = E_FAIL;
				break;
			}

            SysFreeString( bstrEmObj );

			memcpy( pEmObject, pEmObjectTmp, sizeof( EmObject ) );

			//Update the ListCtl with the new info
			UpdateListElement( pEmObject );
			
		}
	}

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}
	
	SysFreeString ( bstrEmObj );

	CFormView::OnTimer( nIDEvent );
}

HRESULT CEmshellView::RemoveActiveSession( PEmObject pEmObject )
{
	INT_PTR			nUpperBound		= 0;
	PActiveSession	pActiveSession	= NULL;

	//Search the session table looking for pEmObject->guidstream, if found close it
	//We don't call FindActiveSession() because we don't get the position of the element, 
	//so do our own search...again :/
	for ( nUpperBound = m_SessionTable.GetUpperBound(); nUpperBound >= 0; nUpperBound-- ) {
		pActiveSession = ( PActiveSession ) m_SessionTable.GetAt( nUpperBound );
		
		if ( pActiveSession == NULL ) {
			break;
		}

		if( memcmp( ( void * ) &pActiveSession->guid, ( void * ) pEmObject->guidstream, sizeof( GUID ) ) == 0 ) {
			//Delete the pActiveSession.  This will release the interface
			DeAllocActiveSession( pActiveSession );

			//Remove the item from the array
			m_SessionTable.RemoveAt( nUpperBound );

			//We have found the element, stop the search
			break;
		}
	}

	return S_OK;
}

HRESULT CEmshellView::DeleteDebugSession( PEmObject pEmObject )
{
	HRESULT			hr			= E_FAIL;
	BSTR			bstrEmObj	= NULL;

	do {
		//Set the cursor to a wait cursor
		CWaitCursor wait;

		//Create bstr's for the journey ahead, and break if we can't
		bstrEmObj = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );
		if( bstrEmObj == NULL ){
			hr = E_OUTOFMEMORY;
			break;
		}
		
		//Close the active session
		hr = GetDocument()->GetEmManager()->DeleteSession( bstrEmObj );
		if ( FAILED( hr ) ) {
			break;
		}
	} while ( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}

	SysFreeString ( bstrEmObj );

	return hr;
}

void CEmshellView::CancelDebugSession( PEmObject pEmObject )
{
	PActiveSession		pActiveSession		= NULL;
	HRESULT				hr					= S_OK;
	BSTR				bstrEmObj           = NULL;
	PEmObject			pEmObjectTmp		= NULL;
	IEmDebugSession*	pTempDebugSession	= NULL;

	do {	
		pActiveSession = FindActiveSession( pEmObject );
		if ( pActiveSession == NULL ) {
			//Create bstr's for the journey ahead, and break if we can't
			bstrEmObj = CopyBSTR ( ( LPBYTE ) pEmObject, sizeof( EmObject ) );
			if( bstrEmObj == NULL ) {
				hr = E_OUTOFMEMORY;
				break;
			}
				
			//We don't have a session open, so open a temporary session
			hr = GetDocument()->GetEmManager()->OpenSession( bstrEmObj, &pTempDebugSession );
			//If we can't get an S_OK, then it's not an orphan, just release the interface.
			if ( FAILED( hr ) ) {
				if ( pTempDebugSession ) {
					//Release the pTempDebugSession pointer
					SAFE_RELEASEIX( pTempDebugSession );
				}
				break;
			}

			//If it's an orphan, ask the user if they want to take control, and if so, add it to our session table
			if ( CommenceOrphanCustodyBattle( pTempDebugSession ) ) {
				pActiveSession = AddActiveSession( pEmObject, pTempDebugSession, TRUE );
                
                if ( !pActiveSession ) {
				    if ( pTempDebugSession ) {
					    //Release the pTempDebugSession pointer
					    SAFE_RELEASEIX( pTempDebugSession );
				    }
                    break;
                }
            }
            else {
				if ( pTempDebugSession ) {
					//Release the pTempDebugSession pointer
					SAFE_RELEASEIX( pTempDebugSession );
				}
                break;
            }
		}
		else if ( !pActiveSession->bMaster ) {
			//We're not the master, so try to become one
			hr = pActiveSession->pIDebugSession->AdoptOrphan();
			if ( SUCCEEDED( hr ) ) {
				//We're now the master, so update the bMaster flag and continue
				pActiveSession->bMaster = TRUE;
			}
			else {
				//We couldn't get ownership of the session, abort with a message.

				break;
			}
		}

		//Set the cursor to a wait cursor
		CWaitCursor wait;

		//Stop the debug session
		hr = pActiveSession->pIDebugSession->CancelDebug( TRUE );
		if ( FAILED( hr ) ) {
			break;
		}

		//Create bstr's for the journey ahead, and break if we can't
		bstrEmObj = CopyBSTR ( ( LPBYTE ) pEmObject, sizeof( EmObject ) );
		if( bstrEmObj == NULL ) {
			hr = E_OUTOFMEMORY;
			break;
		}
			
		//Get the status of the EmObject
        hr = pActiveSession->pIDebugSession->GetStatus( bstrEmObj );
		if ( FAILED( hr ) ) break;

		//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
		pEmObjectTmp = GetEmObj(bstrEmObj);
		if (pEmObjectTmp == NULL) {
			hr = E_FAIL;
			break;
		}

        SysFreeString( bstrEmObj );

		//Remove the session from the active session table
		RemoveActiveSession( pEmObject );
		
		//Update the ListCtl with the new info.  The status should read Debug Completed or some such
		memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );
		UpdateListElement( pEmObject );
	} while( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}

	SysFreeString ( bstrEmObj );
}

BOOL CEmshellView::CommenceOrphanCustodyBattle( IEmDebugSession* pIEmDebugSession )
{
    HRESULT     hr;
	CString     strMessage;
    BOOL        bRetVal     = FALSE;

    strMessage.LoadString( IDS_ORPHANCUSTODYCONFIRM );
	
    //Ask the user if they want custody of the orphan
   	if (((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString( strMessage, MB_YESNO ) == IDYES) {
        
        //Take control and exit
        hr = pIEmDebugSession->AdoptOrphan();
        
        if ( SUCCEEDED( hr ) ) {
            bRetVal = TRUE;
        }
        else {
            ((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
        }
    }
	
    return bRetVal;
}

void CEmshellView::StopDebugSession( PEmObject pEmObject )
{
	PActiveSession		pActiveSession		= NULL;
	HRESULT				hr					= S_OK;
	BSTR				bstrEmObj           = NULL;
	PEmObject			pEmObjectTmp		= NULL;
	IEmDebugSession*	pTempDebugSession	= NULL;

	do {	
		pActiveSession = FindActiveSession( pEmObject );
		if ( pActiveSession == NULL ) {
			//Create bstr's for the journey ahead, and break if we can't
			bstrEmObj = CopyBSTR ( ( LPBYTE ) pEmObject, sizeof( EmObject ) );
			if( bstrEmObj == NULL ) {
				hr = E_OUTOFMEMORY;
				break;
			}
				
			//We don't have a session open, so open a temporary session
			hr = GetDocument()->GetEmManager()->OpenSession( bstrEmObj, &pTempDebugSession );
			
		    //Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
		    pEmObjectTmp = GetEmObj(bstrEmObj);
		    if (pEmObjectTmp == NULL) {
			    hr = E_FAIL;
			    break;
		    }

            SysFreeString( bstrEmObj );

            //If we can't get an S_OK, then it's not an orphan, just release the interface.
			if ( FAILED( hr ) ) {
				if ( pTempDebugSession ) {
					//Release the pTempDebugSession pointer
					SAFE_RELEASEIX( pTempDebugSession );
				}
				break;
			}

			//If it's an orphan, ask the user if they want to take control, and if successfull,
            //add it to our session table
			if ( pEmObject->nStatus & STAT_ORPHAN && CommenceOrphanCustodyBattle( pTempDebugSession ) ) {
				pActiveSession = AddActiveSession( pEmObject, pTempDebugSession, TRUE );
                
                if ( !pActiveSession ) {
				    if ( pTempDebugSession ) {
					    //Release the pTempDebugSession pointer
					    SAFE_RELEASEIX( pTempDebugSession );
                        break;
                    }
				}
			}
            else {
				if ( pTempDebugSession ) {
					//Release the pTempDebugSession pointer
					SAFE_RELEASEIX( pTempDebugSession );
				}
                break;
            }
		}
		else if ( !pActiveSession->bMaster ) {
			//We're not the master, so try to become one
			hr = pActiveSession->pIDebugSession->AdoptOrphan();
			if ( SUCCEEDED( hr ) ) {
				//We're now the master, so update the bMaster flag and continue
				pActiveSession->bMaster = TRUE;
			}
			else {
				//We couldn't get ownership of the session, just remove the session from the active session table.
                //Remove the session from the active session table
		        RemoveActiveSession( pEmObject );
                hr = S_OK;
				break;
			}
		}

		//Set the cursor to a wait cursor
		CWaitCursor wait;

		//Stop the debug session
		hr = pActiveSession->pIDebugSession->StopDebug( TRUE );
		if ( FAILED( hr ) ) {
			break;
		}

        //Create bstr's for the journey ahead, and break if we can't
		bstrEmObj = CopyBSTR ( ( LPBYTE ) pEmObject, sizeof( EmObject ) );
		if( bstrEmObj == NULL ) {
			hr = E_OUTOFMEMORY;
			break;
		}
			
		//Get the status of the EmObject
        hr = pActiveSession->pIDebugSession->GetStatus( bstrEmObj );
		if ( FAILED( hr ) ) break;

		//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
		pEmObjectTmp = GetEmObj(bstrEmObj);
		if (pEmObjectTmp == NULL) {
			hr = E_FAIL;
			break;
		}

        SysFreeString( bstrEmObj );

		//Remove the session from the active session table
//		RemoveActiveSession( pEmObject );
		
		//Update the ListCtl with the new info.  The status should read Debug Completed or some such
		memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );
		UpdateListElement( pEmObject );
	} while( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}

	SysFreeString ( bstrEmObj );
}

PActiveSession CEmshellView::AddActiveSession(PEmObject pEmObject, IEmDebugSession* pIEmDebugSession, BOOL bMaster)
{
	PActiveSession		pActiveSession		= NULL;

    do {
        pActiveSession = AllocActiveSession(pEmObject, pIEmDebugSession);
        if (pActiveSession == NULL) break;

	    //Initialize the bMaster flag of the active session object
	    pActiveSession->bMaster = bMaster;

        //Set the session type
        pActiveSession->nSessionType = (SessionType) pEmObject->type2;

	    //Set the object type
	    pActiveSession->emObjType = (EmObjectType) pEmObject->type;

	    //Add the pDebugSession to the session table if we succeeded in opening a debug session
	    m_SessionTable.Add((void*&)pActiveSession);
    } while ( FALSE );
    return pActiveSession;
}

void CEmshellView::UpdateListElement(PEmObject pEmObject)
{
	switch (m_enumShellViewState) {
	case SHELLVIEW_ALL:
		RefreshAllViewElement(pEmObject);
		break;
	case SHELLVIEW_APPLICATIONS:
		RefreshProcessViewElement(pEmObject);
		break;
	case SHELLVIEW_SERVICES:
		RefreshServiceViewElement(pEmObject);
		break;
	case SHELLVIEW_COMPLETEDSESSIONS:
		RefreshCompletedSessionViewElement(pEmObject);
		break;
	case SHELLVIEW_LOGFILES:
		RefreshLogViewElement(pEmObject);
		break;
	case SHELLVIEW_DUMPFILES:
		RefreshDumpViewElement(pEmObject);
		break;
	case SHELLVIEW_NONE:
	default:
		break;
	}
}

void CEmshellView::RefreshProcessViewElement(PEmObject pEmObject)
{
    CString strTempString	= _T("");
	int nImageOffset		= 0;

	//Given an PEmObject, find the element in the ListCtl, update it's image
	//and call UpdateData on the ListControl
	PEmObject pListEmObject = NULL;

	//Step through every item in the list control searching for pEmObject  
	int nCount = m_mainListControl.GetItemCount();
	
	for (int i = 0;i < nCount; i++) {
		pListEmObject = (PEmObject)m_mainListControl.GetItemData(i);

		if (pListEmObject == NULL) break;

		if (memcmp((void *)pListEmObject->guidstream, (void *)pEmObject->guidstream, sizeof( GUID ) ) == 0) {
			//Get the correct offset into the bitmap for the current status
			nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

			//We have found the item, update its image based on its state
			m_mainListControl.SetItem(i, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

			//Image Name
			strTempString.Format(_T("%s"), pListEmObject->szName);
			m_mainListControl.SetItemText(i, 0, strTempString);

			//PID
			strTempString.Format(_T("%d"), pListEmObject->nId);
			m_mainListControl.SetItemText(i, 1, strTempString);

            //
            // a-mando
            //

            // Start Date
            if( pEmObject->dateStart != 0L ) {

                COleDateTime oleDtTm(pListEmObject->dateStart);
                CString strStartDate = oleDtTm.Format(_T("%c"));
                m_mainListControl.SetItemText(i, 2, strStartDate );
            }

            // End Date
            if( pEmObject->dateEnd != 0L ) {

                COleDateTime oleDtTm(pListEmObject->dateEnd);
                CString strEndDate = oleDtTm.Format(_T("%c"));
                m_mainListControl.SetItemText(i, 3, strEndDate );
            }
            // a-mando

			//Status
            ((CEmshellApp*)AfxGetApp())->GetStatusString(pListEmObject->nStatus, strTempString);
            m_mainListControl.SetItemText(i, 4, strTempString);
			
			m_mainListControl.Update(i);
			
			//We have found the element, stop the search
			break;
		}
	}
}

void CEmshellView::RefreshServiceViewElement(PEmObject pEmObject)
{
    CString strTempString	= _T("");
	int nImageOffset		= 0;

	//Given an PEmObject, find the element in the ListCtl, update it's image
	//and call UpdateData on the ListControl
	PEmObject pListEmObject = NULL;

	//Step through every item in the list control searching for pEmObject  
	int nCount = m_mainListControl.GetItemCount();
	
	for (int i = 0;i < nCount; i++) {
		pListEmObject = (PEmObject)m_mainListControl.GetItemData(i);

		if (pListEmObject == NULL) break;

		if (memcmp((void *)pListEmObject->guidstream, (void *)pEmObject->guidstream, sizeof( GUID ) ) == 0) {
			//Get the correct offset into the bitmap for the current status
			nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

			//We have found the item, update its image based on its state
			m_mainListControl.SetItem(i, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

			//Image Name
			strTempString.Format(_T("%s"), pListEmObject->szName);
			m_mainListControl.SetItemText(i, 0, strTempString);
			
			//Short Name
			strTempString.Format(_T("%s"), pListEmObject->szSecName);
			m_mainListControl.SetItemText(i, 1, strTempString);
			
			//Description Name
			strTempString.Format(_T("%s"), pListEmObject->szBucket1);
			m_mainListControl.SetItemText(i, 2, strTempString);
			
			//PID
			strTempString.Format(_T("%d"), pListEmObject->nId);
			m_mainListControl.SetItemText(i, 3, strTempString);
            
            //
            // a-mando
            //
            if( pEmObject->dateStart != 0L ) {

                COleDateTime oleDtTm(pListEmObject->dateStart);
                CString strStartDate = oleDtTm.Format(_T("%c"));
                m_mainListControl.SetItemText(i, 4, strStartDate );
            }

            if( pEmObject->dateEnd != 0L ) {

                COleDateTime oleDtTm(pListEmObject->dateEnd);
                CString strEndDate = oleDtTm.Format(_T("%c"));
                m_mainListControl.SetItemText(i, 5, strEndDate );
            }
            // a-mando

			//Status
			((CEmshellApp*)AfxGetApp())->GetStatusString(pListEmObject->nStatus, strTempString);
            m_mainListControl.SetItemText(i, 6, strTempString);
			
			m_mainListControl.Update(i);
			
			//We have found the element, stop the search
			break;
		}
	}
}

void CEmshellView::RefreshCompletedSessionViewElement(PEmObject pEmObject)
{
	RefreshServiceViewElement(pEmObject);
}

void CEmshellView::RefreshAllViewElement(PEmObject pEmObject)
{
	RefreshServiceViewElement(pEmObject);
}

void CEmshellView::RefreshLogViewElement(PEmObject pEmObject)
{
    CString strTempString	= _T("");
	int     nImageOffset	= 0;
	int		nImage			= 0;


	//Given an PEmObject, find the element in the ListCtl, update it's image
	//and call UpdateData on the ListControl
	PEmObject pListEmObject = NULL;

	//Step through every item in the list control searching for pEmObject  
	int nCount = m_mainListControl.GetItemCount();
	
	for (int i = 0;i < nCount; i++) {
		pListEmObject = (PEmObject)m_mainListControl.GetItemData(i);

		if (pListEmObject == NULL) break;

		if (memcmp((void *)pListEmObject->guidstream, (void *)pEmObject->guidstream, sizeof( GUID ) ) == 0) {
			//Get the correct offset into the bitmap for the current status
			nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

			//We have found the item, update its image based on its state
			m_mainListControl.SetItem(i, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

			//Image Name
			strTempString.Format(_T("%d bytes"), pListEmObject->szName);
			m_mainListControl.SetItemText(i, 0, strTempString);
			
			//File Size
			strTempString.Format(_T("%d"), pListEmObject->dwBucket1);
			m_mainListControl.SetItemText(i, 1, strTempString);
			
			m_mainListControl.Update(i);
			
			//We have found the element, stop the search
			break;
		}
	}
}

void CEmshellView::RefreshDumpViewElement(PEmObject pEmObject)
{
	RefreshLogViewElement(pEmObject);
}

void CEmshellView::ReSynchApplications()
{
	//iterate through all the sessions and find the corrisponding GUID in the ListCtrl
	//Clear the list control
	PEmObject		pEmObject		= NULL;
	INT_PTR			nUpperBound		= 0;
	PActiveSession	pActiveSession	= NULL;
	HRESULT			hr				= S_OK;
	BOOL			bFound			= FALSE;

	do {
		nUpperBound = m_SessionTable.GetUpperBound();
		
		if (nUpperBound == -1) break;

		//Get the GUID and look it up in the session table
		//If found, map the pEmObject to the session, else remove it. 
		for (; nUpperBound >= 0; nUpperBound--) {
			pActiveSession = (PActiveSession) m_SessionTable.GetAt(nUpperBound);
			
			if (pActiveSession == NULL) {
				hr = E_FAIL;
				break;
			}

			//If the pActiveSession is not process, continue
			if ( pActiveSession->emObjType != EMOBJ_PROCESS ) continue;

			//Step through every item in the list control 
			int nCount = m_mainListControl.GetItemCount();
			for (int i = 0;i < nCount; i++) {
				pEmObject = (PEmObject)m_mainListControl.GetItemData(i);
				
				if (pEmObject == NULL) {
					hr = E_FAIL;
					break;
				}

				if(memcmp((void *)&pActiveSession->guid, (void *)pEmObject->guidstream, sizeof( GUID ) ) == 0) {
					//Assign the pEmObject to the pActiveSession
					pActiveSession->pEmObject = pEmObject;
					
					//We have found the element, stop the search
					bFound = TRUE;

					break;
				}
			}

			if (!bFound) {
				//We have a session table element that does not map to a list element
				//Notify the error of the anomoly and remove it from the session table
				CString strMessage;
				strMessage.LoadString(IDS_SESSIONLISTANOMOLY);
				((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString(strMessage);
				
				//Delete the pActiveSession.  This will release the interface too
				DeAllocActiveSession(pActiveSession);

				//Remove the item from the session table
				m_SessionTable.RemoveAt(nUpperBound);
				break;
			}
		}
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::ReSynchServices()
{
	//iterate through all the sessions and find the corrisponding GUID in the ListCtrl
	//Clear the list control
	PEmObject		pEmObject		= NULL;
	INT_PTR			nUpperBound		= 0;
	PActiveSession	pActiveSession	= NULL;
	HRESULT			hr				= S_OK;
	BOOL			bFound			= FALSE;

	do {
		nUpperBound = m_SessionTable.GetUpperBound();
		
		if (nUpperBound == -1) break;

		//Get the GUID and look it up in the session table
		//If found, map the pEmObject to the session, else remove it. 
		for (; nUpperBound >= 0; nUpperBound--) {
			pActiveSession = (PActiveSession) m_SessionTable.GetAt(nUpperBound);
			
			if (pActiveSession == NULL) {
				hr = E_FAIL;
				break;
			}

			//If the pActiveSession is not service, continue
			if ( pActiveSession->emObjType != EMOBJ_SERVICE ) continue;

			//Step through every item in the list control 
			int nCount = m_mainListControl.GetItemCount();
			for (int i = 0;i < nCount; i++) {
				pEmObject = (PEmObject)m_mainListControl.GetItemData(i);
				
				if (pEmObject == NULL) {
					hr = E_FAIL;
					break;
				}

				if(memcmp((void *)&pActiveSession->guid, (void *)pEmObject->guidstream, sizeof( GUID ) ) == 0) {
					//Assign the pEmObject to the pActiveSession
					pActiveSession->pEmObject = pEmObject;
					
					//We have found the element, stop the search
					bFound = TRUE;

					break;
				}
			}

			if (!bFound) {
				//We have a session table element that does not map to a list element
				//Notify the error of the anomoly and remove it from the session table
				CString strMessage;
				strMessage.LoadString(IDS_SESSIONLISTANOMOLY);
				((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromString(strMessage);
				
				//Delete the pActiveSession.  This will release the interface too
				DeAllocActiveSession(pActiveSession);

				//Remove the item from the session table
				m_SessionTable.RemoveAt(nUpperBound);
				break;
			}
		}
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::ReSynchStoppedSessions()
{
	//iterate through all the sessions and find the corrisponding GUID in the ListCtrl
	//Clear the list control
	PEmObject		pEmObject		= NULL;
	INT_PTR			nUpperBound		= 0;
	PActiveSession	pActiveSession	= NULL;
	HRESULT			hr				= S_OK;
	BOOL			bFound			= FALSE;

	do {
		nUpperBound = m_SessionTable.GetUpperBound();
		
		if (nUpperBound == -1) break;

		//Get the GUID and look it up in the session table
		//If found, map the pEmObject to the session, else remove it. 
		for (; nUpperBound >= 0; nUpperBound--) {
			pActiveSession = (PActiveSession) m_SessionTable.GetAt(nUpperBound);
			
			if (pActiveSession == NULL) {
				hr = E_FAIL;
				break;
			}

			//Step through every item in the list control 
			int nCount = m_mainListControl.GetItemCount();
			for (int i = 0;i < nCount; i++) {
				pEmObject = (PEmObject)m_mainListControl.GetItemData(i);
				
				if (pEmObject == NULL) {
					hr = E_FAIL;
					break;
				}

				if(memcmp((void *)&pActiveSession->guid, (void *)pEmObject->guidstream, sizeof( GUID ) ) == 0) {
					//Assign the pEmObject to the pActiveSession
					pActiveSession->pEmObject = pEmObject;
					
					//We have found the element, stop the search
					bFound = TRUE;

					break;
				}
			}
		}
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::GenerateDump(PEmObject pEmObject, BOOL bMiniDump)
{
	INT_PTR				nUpperBound			= 0;
	PActiveSession		pActiveSession		= NULL;
	HRESULT				hr					= E_FAIL;
	BSTR				bstrEmObj		    = NULL;
	IEmDebugSession*	pTempDebugSession	= NULL;
	BOOL				bTempSession		= FALSE;
	PEmObject			pEmObjectTmp		= NULL;

	//Set the cursor to a wait cursor
	CWaitCursor wait;

	do {
		//Find the element in the session table
		pActiveSession = FindActiveSession( pEmObject );

		//Create bstr's for the journey ahead, and break if we can't
		bstrEmObj = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );
		if( bstrEmObj == NULL ){
			hr = E_OUTOFMEMORY;
			break;
		}

		if (pActiveSession == NULL) {
			//Get a temporary IDebugSession*
			hr = GetDocument()->GetEmManager()->OpenSession(bstrEmObj, &pTempDebugSession);
			if (FAILED(hr)) break;
			
			bTempSession = TRUE;
		}
		else {
			//Generate the dumpfile
			pTempDebugSession = pActiveSession->pIDebugSession;
            if ( pTempDebugSession == NULL ) break;
		}

		//Generate the dumpfile
		hr = pTempDebugSession->GenerateDumpFile(bMiniDump);
		if (FAILED(hr)) break;

        hr = pTempDebugSession->GetStatus(bstrEmObj);
		if (FAILED(hr)) break;
        
		//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
		pEmObjectTmp = GetEmObj(bstrEmObj);
		if (pEmObjectTmp == NULL) break;

        SysFreeString( bstrEmObj );

		memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );
		
		//Update the ListCtl with the new info
		UpdateListElement(pEmObject);
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

    SysFreeString( bstrEmObj );

	if ( bTempSession && pTempDebugSession ) {
		//Release the pTempDebugSession pointer
		SAFE_RELEASEIX( pTempDebugSession );
	}
}

void CEmshellView::OnViewRefresh() 
{
	RefreshListCtl();		
}

void CEmshellView::RefreshListCtl()
{
	//refresh the list control based on it's contents
	if ( GetDocument()->GetConnectedToServerState() ) {
		//Refresh everything.  Rebuild the list.
		ListCtrlClear();
		//Pass in the current view
		ListCtrlPopulate(m_enumShellViewState);
		m_mainListControl.RefreshList();
	}
	
}

//******** Right click popup menu item updateUI handlers ***********//
//*********************************************************//
void CEmshellView::OnUpdateProcesspopupStopDebugSession( CCmdUI* pCmdUI ) 
{
	PEmObject		pEmObject		= NULL;
	BOOL			bEnable			= FALSE;
    PActiveSession  pActiveSession  = NULL;

	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

        if ( m_enumShellViewState != SHELLVIEW_ALL &&
	        m_enumShellViewState != SHELLVIEW_APPLICATIONS &&
            m_enumShellViewState != SHELLVIEW_SERVICES &&
            m_enumShellViewState != SHELLVIEW_COMPLETEDSESSIONS ) break;

		// Update the state of this button based on the state of the currently selected item
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

        pActiveSession = FindActiveSession( pEmObject );

		//Determine if the status of pActiveSession and enable this appropriately
		if ( pEmObject->nStatus & STAT_SESS_DEBUG_IN_PROGRESS && 
            ( pEmObject->nStatus & STAT_ORPHAN || pActiveSession ) )
			bEnable = TRUE;
	}while ( FALSE );

	pCmdUI->Enable( bEnable);
}

void CEmshellView::OnUpdateProcesspopupCancelDebugSession( CCmdUI* pCmdUI ) 
{
	PEmObject		pEmObject		= NULL;
	BOOL			bEnable			= FALSE;
    PActiveSession  pActiveSession  = NULL;

	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

        if ( m_enumShellViewState != SHELLVIEW_ALL &&
	        m_enumShellViewState != SHELLVIEW_APPLICATIONS &&
            m_enumShellViewState != SHELLVIEW_SERVICES &&
            m_enumShellViewState != SHELLVIEW_COMPLETEDSESSIONS ) break;

		// Update the state of this button based on the state of the currently selected item
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();
		if ( pEmObject == NULL ) break;

        pActiveSession = FindActiveSession( pEmObject );

		//Determine if the status of pActiveSession and enable this apprpriately
		if ( pEmObject->nStatus & STAT_SESS_DEBUG_IN_PROGRESS && 
            ( pEmObject->nStatus & STAT_ORPHAN || ( pActiveSession && pActiveSession->bMaster ) ) )
			bEnable = TRUE;
	}while (FALSE);

	pCmdUI->Enable( bEnable);
}

void CEmshellView::OnUpdateViewRefresh(CCmdUI* pCmdUI) 
{
	//We get this call everytime the menu is about to be shown
	pCmdUI->Enable ( GetDocument()->GetConnectedToServerState() );	
}

void CEmshellView::OnUpdateProcesspopupGenerateminidump(CCmdUI* pCmdUI) 
{
	PEmObject		pEmObject		= NULL;
	BOOL			bEnable			= FALSE;

	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

        if ( m_enumShellViewState != SHELLVIEW_ALL &&
	        m_enumShellViewState != SHELLVIEW_APPLICATIONS &&
            m_enumShellViewState != SHELLVIEW_SERVICES &&
            m_enumShellViewState != SHELLVIEW_COMPLETEDSESSIONS ) break;

		// Update the state of this button based on the state of the currently selected item
		// If we are the master, then we can stop this session
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

		if ( !( pEmObject->nStatus & STAT_NOTRUNNING ) && 
             !( pEmObject->nStatus & STAT_SESS_STOPPED ) && 
              ( pEmObject->type & EMOBJ_PROCESS || 
                pEmObject->type & EMOBJ_SERVICE ) ) {

            bEnable = TRUE;
        }

	}while (FALSE);

	pCmdUI->Enable( bEnable);
}

void CEmshellView::OnUpdateProcesspopupGenerateuserdump(CCmdUI* pCmdUI) 
{
	PEmObject		pEmObject		= NULL;
	BOOL			bEnable			= FALSE;

	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

        if ( m_enumShellViewState != SHELLVIEW_ALL &&
	        m_enumShellViewState != SHELLVIEW_APPLICATIONS &&
            m_enumShellViewState != SHELLVIEW_SERVICES &&
            m_enumShellViewState != SHELLVIEW_COMPLETEDSESSIONS ) break;

		// Update the state of this button based on the state of the currently selected item
		// If we are the master, then we can stop this session
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

		if ( !( pEmObject->nStatus & STAT_NOTRUNNING ) && 
             !( pEmObject->nStatus & STAT_SESS_STOPPED ) && 
              ( pEmObject->type & EMOBJ_PROCESS || 
                pEmObject->type & EMOBJ_SERVICE ) ) {

            bEnable = TRUE;
        }
		    
	}while (FALSE);

	pCmdUI->Enable( bEnable);
}

void CEmshellView::OnUpdateProcesspopupAutomaticsession(CCmdUI* pCmdUI) 
{
	PEmObject		pEmObject	= NULL;
	BOOL			bEnable		= FALSE;
	PActiveSession	pActiveSession	= NULL;

	// Allow if this isn't being debugged
	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

        if ( m_enumShellViewState != SHELLVIEW_ALL &&
	        m_enumShellViewState != SHELLVIEW_APPLICATIONS &&
            m_enumShellViewState != SHELLVIEW_SERVICES &&
            m_enumShellViewState != SHELLVIEW_COMPLETEDSESSIONS ) break;

		// Update the state of this button based on the state of the currently selected item
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

		//Find the element in the session table
		pActiveSession = FindActiveSession( pEmObject );

		//Determine the status of pActiveSession and enable this apprpriately
		if ( !pActiveSession && (pEmObject->nStatus & STAT_SESS_NOT_STARTED) || 
            ( pEmObject->type2 == SessType_Automatic && pEmObject->nStatus & STAT_ORPHAN ) ) {
			bEnable = TRUE;
        }
	}while (FALSE);

	pCmdUI->Enable( bEnable);
}

void CEmshellView::OnUpdateProcesspopupManualsession(CCmdUI* pCmdUI) 
{
	PEmObject		pEmObject	= NULL;
	BOOL			bEnable		= FALSE;
	PActiveSession	pActiveSession	= NULL;

	// Allow if this isn't being debugged
	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

        if ( m_enumShellViewState != SHELLVIEW_ALL &&
	        m_enumShellViewState != SHELLVIEW_APPLICATIONS &&
            m_enumShellViewState != SHELLVIEW_SERVICES &&
            m_enumShellViewState != SHELLVIEW_COMPLETEDSESSIONS ) break;

		// Update the state of this button based on the state of the currently selected item
		// If we are the master, then we can stop this session
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;
		
		//Find the element in the session table
		pActiveSession = FindActiveSession( pEmObject );

		//Determine if the status of pActiveSession and enable this apprpriately
//		if ( pEmObject->nStatus & STAT_SESS_NOT_STARTED ) {
		if ( !pActiveSession && (pEmObject->nStatus & STAT_SESS_NOT_STARTED) || 
            ( pEmObject->type2 == SessType_Manual && pEmObject->nStatus & STAT_ORPHAN ) ) {
			bEnable = TRUE;
        }
	}while (FALSE);
	pCmdUI->Enable( bEnable);
}


void CEmshellView::OnUpdateProcesspopupProperties(CCmdUI* pCmdUI) 
{
	BOOL	bEnable = FALSE;

	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

		if ( GetSelectedEmObject() == NULL ) break;
		bEnable = TRUE;
	} while ( FALSE );

	// Always allow properties
	pCmdUI->Enable( bEnable );
}

void CEmshellView::OnUpdateProcesspopupRefresh(CCmdUI* pCmdUI) 
{
	// Only allow refresh if the current item is in our session table
	PEmObject		pEmObject		= NULL;
	BOOL			bEnable			= FALSE;

	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;
        
        if ( m_enumShellViewState != SHELLVIEW_ALL &&
	        m_enumShellViewState != SHELLVIEW_APPLICATIONS &&
            m_enumShellViewState != SHELLVIEW_SERVICES &&
            m_enumShellViewState != SHELLVIEW_COMPLETEDSESSIONS ) break;

		// Update the state of this button based on the state of the currently selected item
		// If we are the master, then we can stop this session
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

		bEnable = TRUE;
	}while (FALSE);

	pCmdUI->Enable( bEnable);
}




//******** Right click popup menu item handlers ***********//
//*********************************************************//
void CEmshellView::OnProcesspopupStopDebugSession() 
{
	//Stop the session for the current item selected
	PEmObject	pEmObject	= NULL;
	HRESULT		hr			= E_FAIL;

	do {
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

		//Stop and remove the session
		StopDebugSession( pEmObject );

		hr = S_OK;
	} while ( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}
}

void CEmshellView::OnProcesspopupGenerateminidump() 
{
	PEmObject	pEmObject	= NULL;
	HRESULT		hr			= E_FAIL;

	do {
		pEmObject = GetSelectedEmObject();

		if (pEmObject == NULL) break;

		//Generate the MiniDump file
		GenerateDump(pEmObject, TRUE);

		hr = S_OK;
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::OnProcesspopupGenerateuserdump() 
{
	PEmObject	pEmObject	= NULL;
	HRESULT		hr			= E_FAIL;

	do {
		pEmObject = GetSelectedEmObject();

		if (pEmObject == NULL) break;

		//Generate the UserDump file
		GenerateDump(pEmObject, FALSE);

		hr = S_OK;
	} while(FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
	
}

void CEmshellView::OnProcesspopupAutomaticsession() 
{
	PEmObject	pEmObject		= NULL;
	HRESULT		hr				= E_FAIL;

	do {
		pEmObject = GetSelectedEmObject();
		
		if ( pEmObject == NULL ) break;

		//Start the automatic session
		hr = StartAutomaticDebugSession(pEmObject);
	} while (FALSE);

}


void CEmshellView::OnProcesspopupManualsession() 
{
	// Start a manual session with the server
	PEmObject	pEmObject	= NULL;
	HRESULT		hr			= E_FAIL;

	do {
		pEmObject = GetSelectedEmObject();
		
		if (pEmObject == NULL) break;

		//Start the manual session
		hr = StartManualDebugSession(pEmObject);
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::OnProcesspopupProperties() 
{
    PEmObject			pEmObject		= NULL;
	IEmDebugSession*	pIDebugSession	= NULL;

    do {
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

        if ( pEmObject ) {
            //Get the current view state from the shell
            switch ( GetViewState() ) {
            case SHELLVIEW_LOGFILES:
            case SHELLVIEW_DUMPFILES:
            case SHELLVIEW_MSINFOFILES:
                ShowProperties( pEmObject );
                break;
            default:
                DoModalPropertySheet( pEmObject );
            }
        }
	} while (FALSE);
}

void CEmshellView::OnProcesspopupRefresh() 
{
	// Refresh the currently selected item
	// Get the currently selected EmObject
	PEmObject			pEmObject			= NULL;
	HRESULT				hr					= E_FAIL;
	PActiveSession		pActiveSession		= NULL;
	BSTR				bstrEmObj		    = NULL;
	PEmObject			pEmObjectTmp		= NULL;
	IEmDebugSession*	pTempDebugSession	= NULL;
	BOOL				bTempSession		= FALSE;

	do {
		pEmObject = GetSelectedEmObject();
		
		if (pEmObject == NULL) break;

		//Find the element in the session table
		pActiveSession = FindActiveSession( pEmObject );

		//Create bstr's for the journey ahead, and break if we can't
		bstrEmObj = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );
		if( bstrEmObj == NULL ){
			hr = E_OUTOFMEMORY;
			break;
		}

		if ( pActiveSession == NULL ) {
			hr = GetDocument()->GetEmManager()->OpenSession(bstrEmObj, &pTempDebugSession);
			if (FAILED(hr)) break;
		
			bTempSession = TRUE;
			
			hr = pTempDebugSession->GetStatus(bstrEmObj);
			if (FAILED(hr)) break;
		}
		else {
			hr = pActiveSession->pIDebugSession->GetStatus(bstrEmObj);
			if (FAILED(hr)) break;
		}
		//Convert the bstrEmObj to an PEmObject and memcopy it into the itemdata's PEmObject
		pEmObjectTmp = GetEmObj(bstrEmObj);
		if (pEmObjectTmp == NULL) break;

        SysFreeString( bstrEmObj );

		memcpy(pEmObject, pEmObjectTmp, sizeof( EmObject ) );
		
		//Update the element
		UpdateListElement(pEmObject);

		hr = S_OK;
	} while (FALSE);

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	SysFreeString ( bstrEmObj );
	
	if ( pTempDebugSession ) {
		//Release the pTempDebugSession pointer
		SAFE_RELEASEIX( pTempDebugSession );
	}
}

PEmObject CEmshellView::GetSelectedEmObject()
{
	PEmObject	pEmObject	= NULL;
	int			nIndex		= -1;
	do {
		nIndex = GetSelectedItemIndex();
		
		if (nIndex == -1) break;

		pEmObject = (PEmObject) m_mainListControl.GetItemData(nIndex);
	} while (FALSE);

	return pEmObject;
}

int CEmshellView::GetSelectedItemIndex()
{
	POSITION	pos			= 0;
	int			nIndex		= -1;

	do {
		pos = m_mainListControl.GetFirstSelectedItemPosition();
		
		if(pos == NULL) break;

		//Get the nIndex for the currently selected item
		nIndex = m_mainListControl.GetNextSelectedItem(pos);
	} while (FALSE);

	return nIndex;
}

PActiveSession CEmshellView::FindActiveSession(PEmObject pEmObject)
{
	//iterate through all the sessions and find the corrisponding pEmObject
	INT_PTR			nUpperBound		= 0;
	PActiveSession	pActiveSession	= NULL;
	BOOL			bFound			= FALSE;
	PActiveSession	pRetVal			= NULL;

	do {
		nUpperBound = m_SessionTable.GetUpperBound();
		
		if ( nUpperBound == -1 ) break;
		if ( pEmObject == NULL ) break;

		//look up the pEmObject in the session table
		//If found, map the pEmObject to the session, else remove it. 
		for (; nUpperBound >= 0; nUpperBound--) {
			pActiveSession = (PActiveSession) m_SessionTable.GetAt(nUpperBound);
			
			if ( pActiveSession == NULL ) break;

			if( memcmp( ( void * ) &pActiveSession->guid, ( void * ) pEmObject->guidstream, sizeof( GUID ) ) == 0 ) {
				pRetVal = pActiveSession;
			}
		}
	} while ( FALSE );

	return pRetVal;
}


int CEmshellView::GetImageOffsetFromStatus(EmSessionStatus em)
{
	int retVal = 0;

	//Use a switch/case statement to determine the correct offset into the bitmap
	switch (em) {
	case STAT_SESS_NONE_STAT_NONE:
		retVal = 0;
		break;
	case STAT_SESS_NOT_STARTED_NOTRUNNING:
		retVal = 1;
		break;
	case STAT_SESS_NOT_STARTED_RUNNING:
		retVal = 2;
		break;
	case STAT_SESS_NOT_STARTED_FILECREATED_SUCCESSFULLY:
		retVal = 3;
		break;
	case STAT_SESS_NOT_STARTED_FILECREATION_FAILED:
		retVal = 4;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_NONE:
		retVal = 5;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_FILECREATED_SUCESSFULLY:
		retVal = 6;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_FILECREATION_FAILED:
		retVal = 7;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_NONE:
		retVal = 8;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATED_SUCESSFULLY:
		retVal = 9;
		break;
	case STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATION_FAILED:
		retVal = 10;
		break;
	case STAT_SESS_STOPPED_SUCCESS:
		retVal = 11;
		break;
	case STAT_SESS_STOPPED_FAILED:
		retVal = 12;
		break;
	case STAT_SESS_STOPPED_ORPHAN_SUCCESS:
		retVal = 13;
		break;
	case STAT_SESS_STOPPED_ORPHAN_FAILED:
		retVal = 14;
		break;
	case STAT_SESS_STOPPED_DEBUGGEE_KILLED:
		retVal = 15;
		break;
	case STAT_SESS_STOPPED_DEBUGGEE_EXITED:
		retVal = 16;
		break;
	case STAT_SESS_STOPPED_EXCEPTION_OCCURED:
		retVal = 17;
		break;
	case STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_KILLED:
		retVal = 18;
		break;
	case STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_EXITED:
		retVal = 19;
		break;
	case STAT_SESS_STOPPED_ORPHAN_EXCEPTION_OCCURED:
		retVal = 20;
		break;
	case STAT_SESS_STOPPED_ACCESSVIOLATION_OCCURED:
		retVal = 21;
		break;
	case STAT_SESS_STOPPED_ORPHAN_ACCESSVIOLATION_OCCURED:
		retVal = 22;
		break;
	}
	return retVal;
}

void CEmshellView::InitializeAllView()
{
	InitializeServiceView();
}

void CEmshellView::InitializeCompletedSessionsView() 
{
	InitializeServiceView();
}

void CEmshellView::InitializeProcessView()
{
	//This gets called only when the user is first starting the app or when 
	//the user is changing views.
	//Reset the list control
	m_mainListControl.ResetListCtrl();

	//Load the string resources for the CListCtrl columns
	CString strImageName, strPID, strStatus, strStartDate, strEndDate;
	strImageName.LoadString(IDS_LC_IMAGENAME);
	strPID.LoadString(IDS_LC_PID);
	strStatus.LoadString(IDS_LC_STATUS);
    strStartDate.LoadString(IDS_LC_STARTDATE);
    strEndDate.LoadString(IDS_LC_ENDDATE);

	//Unload the last image resources, if there are any
	m_ShellImageList.DeleteImageList();

	//Load the image resources for the CListCtrl items
	m_ShellImageList.Create(IDB_STATUS_BITMAP, 16, 1, CLR_NONE);
	m_mainListControl.SetImageList(&m_ShellImageList, LVSIL_SMALL);

	//Add the columns to the list control
	m_mainListControl.BeginSetColumn(5);
	m_mainListControl.AddColumn(strImageName);
	m_mainListControl.AddColumn(strPID, VT_I4);
	m_mainListControl.AddColumn(strStartDate);
	m_mainListControl.AddColumn(strEndDate);
	m_mainListControl.AddColumn(strStatus);
	m_mainListControl.EndSetColumn();

    m_mainListControl.ResizeColumnsFitScreen();
	m_mainListControl.SetExtendedStyle(LVS_EX_FULLROWSELECT);
}

void CEmshellView::InitializeServiceView()
{
	//This gets called only when the user is first starting the app or when 
	//the user is changing views.
	//Reset the list control
	m_mainListControl.ResetListCtrl();

	//Load the string resources for the CListCtrl columns
	CString strImageName, strPID, strStatus, strShortName, strDescription,
            strStartDate, strEndDate;
	strImageName.LoadString(IDS_LC_IMAGENAME);
	strPID.LoadString(IDS_LC_PID);
	strStatus.LoadString(IDS_LC_STATUS);
	strShortName.LoadString(IDS_LC_SHORTNAME);
	strDescription.LoadString(IDS_LC_DESCRIPTION);
    strStartDate.LoadString(IDS_LC_STARTDATE);
    strEndDate.LoadString(IDS_LC_ENDDATE);

	//Unload the last image resources, if there are any
	m_ShellImageList.DeleteImageList();

	//Load the image resources for the CListCtrl items
	m_ShellImageList.Create(IDB_STATUS_BITMAP, 16, 1, CLR_NONE);
	m_mainListControl.SetImageList(&m_ShellImageList, LVSIL_SMALL);

	//Add the columns to the list control
	m_mainListControl.BeginSetColumn(7);
	m_mainListControl.AddColumn(strImageName);
	m_mainListControl.AddColumn(strShortName);
	m_mainListControl.AddColumn(strDescription);
	m_mainListControl.AddColumn(strPID, VT_I4);
	m_mainListControl.AddColumn(strStartDate);
	m_mainListControl.AddColumn(strEndDate);
	m_mainListControl.AddColumn(strStatus);
	m_mainListControl.EndSetColumn();

    m_mainListControl.ResizeColumnsFitScreen();
	m_mainListControl.SetExtendedStyle(LVS_EX_FULLROWSELECT);
}

void CEmshellView::InitializeLogView()
{
	//Reset the list control
	m_mainListControl.ResetListCtrl();
	//Load the string resources for the CListCtrl columns
	CString strFileName, strSize, strTime; //, strProc;
	strFileName.LoadString(IDS_LC_FILENAME);
	strSize.LoadString(IDS_LC_FILESIZE);
	strTime.LoadString(IDS_LC_FILETIME);
//	strProc.LoadString(IDS_LC_FILEPROCESS);

	//Unload the last image resources, if there are any
	m_ShellImageList.DeleteImageList();

	//Load the image resources for the CListCtrl items
	m_ShellImageList.Create(IDB_STATUS_BITMAP, 16, 1, CLR_NONE);
	m_mainListControl.SetImageList(&m_ShellImageList, LVSIL_SMALL);

	//Add the columns to the list control
	m_mainListControl.BeginSetColumn(3);
	m_mainListControl.AddColumn(strFileName);
	m_mainListControl.AddColumn(strSize, VT_I4);
	m_mainListControl.AddColumn(strTime);
//	m_mainListControl.AddColumn(strProc);
	m_mainListControl.EndSetColumn();
	
	m_mainListControl.ResizeColumnsFitScreen();
	m_mainListControl.SetExtendedStyle(LVS_EX_FULLROWSELECT);
}

void CEmshellView::InitializeDumpView()
{
	InitializeLogView();
}

void CEmshellView::PopulateProcessType()
{
	_variant_t 		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter       = NULL;
	PEmObject		pCurrentObj		= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ));

	do {
		EmObjectFilter.type = EMOBJ_PROCESS;
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		//hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrEmObjectFilter, &var);
		hr = GetDocument()->GetEmManager()->EnumObjects(EMOBJ_PROCESS, &var );

		if(FAILED(hr)) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if ( pCurrentObj != NULL ) {
                *pCurrentObj = *GetEmObj( bstrEmObj );
			}

            SysFreeString( bstrEmObj );

            //Unallocate the EmObject if it has an hr of E_FAIL
			if (FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
				continue;
			}

            if ( !( (CEmshellApp*)AfxGetApp() )->CanDisplayProcess( pCurrentObj->szName ) ){
                ((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
                continue;
            }

			//Depending on the current view, use the correct DisplayData routine
			if ( m_enumShellViewState == SHELLVIEW_APPLICATIONS ) {

				//Convert the BSTR object to an EmObject and pass it to DisplayData
				DisplayProcessData( pCurrentObj );

			} else {

    			DisplayServiceData( pCurrentObj );
			}
		}
	} while (FALSE);
    
    SafeArrayDestroyData(var.parray);
	SysFreeString ( bstrEmObjectFilter );
    SysFreeString ( bstrEmObj );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::PopulateServiceType()
{
	_variant_t		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter       = NULL;
	PEmObject		pCurrentObj		= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ));

	do {
		EmObjectFilter.type = EMOBJ_SERVICE;
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		//hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrEmObjectFilter, &var);
		hr = GetDocument()->GetEmManager()->EnumObjects(EMOBJ_SERVICE, &var );

		if(FAILED(hr)) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if (pCurrentObj == NULL) {
                hr = E_FAIL;
                break;
			}

    		*pCurrentObj = *GetEmObj( bstrEmObj );

            SysFreeString( bstrEmObj );

            //Unallocate the EmObject if it has an hr of E_FAIL
			if ( (_tcscmp(pCurrentObj->szName, _T("")) == 0) && FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
				continue;
			}

            if ( !( (CEmshellApp*)AfxGetApp() )->CanDisplayService( pCurrentObj->szName, pCurrentObj->szSecName ) ){
                ((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
                continue;
            }

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayServiceData( pCurrentObj );
		}
	} while (FALSE);

    SafeArrayDestroyData(var.parray);
	SysFreeString ( bstrEmObjectFilter );
    SysFreeString ( bstrEmObj );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::PopulateDumpType()
{
	_variant_t		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter       = NULL;
	EmObject		*pCurrentObj	= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ) );

	do {
		EmObjectFilter.type = EMOBJ_MINIDUMP;
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrEmObjectFilter, &var);

		if(FAILED(hr)) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if (pCurrentObj != NULL) {
				*pCurrentObj = *GetEmObj( bstrEmObj );
			}

            SysFreeString( bstrEmObj );

			//Unallocate the EmObject if it has an hr of E_FAIL
			if (FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
				continue;
			}

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayDumpData( pCurrentObj );
		}
	} while (FALSE);

    SafeArrayDestroyData(var.parray);
	SysFreeString ( bstrEmObjectFilter );
    SysFreeString ( bstrEmObj );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::PopulateCompletedSessionsType()
{
	_variant_t		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter       = NULL;
	EmObject		*pCurrentObj	= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ) );

	do {
		EmObjectFilter.type = EMOBJ_PROCESS;
        EmObjectFilter.nStatus = STAT_SESS_STOPPED; // only the HIWORD is the filter.
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrEmObjectFilter, &var);

		if(hr != S_OK) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if (pCurrentObj != NULL) {
				*pCurrentObj = *GetEmObj( bstrEmObj );
			}

            SysFreeString( bstrEmObj );

			//Unallocate the EmObject if it has an hr of E_FAIL
			if (FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
				continue;
			}

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayStoppedSessionData( pCurrentObj );
		}
	} while (FALSE);

    SafeArrayDestroyData(var.parray);
	SysFreeString ( bstrEmObjectFilter );
    SysFreeString ( bstrEmObj );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::PopulateLogType()
{
	_variant_t		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter       = NULL;
	EmObject		*pCurrentObj	= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ) );

	do {
		EmObjectFilter.type = EMOBJ_LOGFILE;
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrEmObjectFilter, &var);

		if(FAILED(hr)) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if (pCurrentObj != NULL) {
				*pCurrentObj = *GetEmObj( bstrEmObj );
			}

            SysFreeString( bstrEmObj );

			//Unallocate the EmObject if it has an hr of E_FAIL
			if (FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
				continue;
			}

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayLogData( pCurrentObj );
		}
	} while (FALSE);

    SafeArrayDestroyData(var.parray);
	SysFreeString ( bstrEmObjectFilter );
    SysFreeString ( bstrEmObj );
    
	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::StoreOffSelectedEmObject()
{
    PEmObject pEmObject = NULL;

	//Get the currently selected emObject
	pEmObject = GetSelectedEmObject();
    if ( pEmObject != NULL ) {
        //store off it's name
        m_lastSelectedEmObj = *pEmObject;
    }
    else {
        memset ( &m_lastSelectedEmObj, 0, sizeof ( EmObject ) );
    }
}

void CEmshellView::SetShellState(EMShellViewState eState)
{
    StoreOffSelectedEmObject();

	//Clear the current view
	ListCtrlClear();
	
	//Set the view style to the appropriate enum view state
	m_enumShellViewState = eState;
	
	//Initialize the new view state
	ListCtrlInitialize(m_enumShellViewState);
}

void CEmshellView::ListCtrlInitialize(EMShellViewState eShellViewState) 
{
	switch (eShellViewState) {
	case SHELLVIEW_ALL:
		InitializeAllView();
		break;
	case SHELLVIEW_APPLICATIONS:
		InitializeProcessView();
		break;
	case SHELLVIEW_COMPLETEDSESSIONS:
		InitializeCompletedSessionsView();
		break;
	case SHELLVIEW_SERVICES:
		InitializeServiceView();
		break;
	case SHELLVIEW_LOGFILES:
		InitializeLogView();
		break;
	case SHELLVIEW_DUMPFILES:
		InitializeDumpView();
		break;
    case SHELLVIEW_MSINFOFILES:
        InitializeMSInfoView();
        break;
	case SHELLVIEW_NONE:
		break;
	}
}

void CEmshellView::SelectItemBySZNAME(TCHAR*	pszName, int nId)
{
	//Search through the list selecting the item whose itemdata.szname matches pszName
	//Given a pszName, find the element in the ListCtl
	PEmObject	pListEmObject	= NULL;
	BOOL		bFound			= FALSE;
	int			nFirstMatch		= -1;

	//Step through every item in the list control searching for pEmObject  
	int nCount = m_mainListControl.GetItemCount();
	for (int i = 0;i < nCount; i++) {
		pListEmObject = (PEmObject) m_mainListControl.GetItemData(i);

		if (pListEmObject == NULL) break;

		if (wcscmp(pListEmObject->szName, pszName) == 0 ) {
			if (nFirstMatch == -1 ) 
				nFirstMatch = i;

			if (pListEmObject->nId == nId) {
				m_mainListControl.SelectItem(i);
				bFound = TRUE;
				//We have found the element, stop the search
				break;
			}
		}
	}

	//If the we didn't find a perfect match, select the first near match
	//And if we didn't find any, select the first item in the list
	if ( !bFound ) {
		if (nFirstMatch == -1) {
			m_mainListControl.SelectItem(0);
		}
		else {
			m_mainListControl.SelectItem(nFirstMatch);
		}
	}
}

void CEmshellView::ListCtrlPopulate(EMShellViewState eShellViewState)
{
    DWORD dwPollSessionsFreq = 30L; // default is 30 secs

    ((CEmshellApp*)AfxGetApp())->GetEmShellRegOptions( TRUE, &dwPollSessionsFreq );

    switch (eShellViewState) {
	case SHELLVIEW_ALL:
		PopulateProcessType();
		PopulateServiceType();
		ReSynchServices();
		ReSynchApplications();
        SetTimer( 1, dwPollSessionsFreq*1000, 0);
		break;
	case SHELLVIEW_APPLICATIONS:
		PopulateProcessType();
		ReSynchApplications();
        SetTimer( 1, dwPollSessionsFreq*1000, 0);
		break;
	case SHELLVIEW_SERVICES:
		PopulateServiceType();
		ReSynchServices();
        SetTimer( 1, dwPollSessionsFreq*1000, 0);
		break;
	case SHELLVIEW_COMPLETEDSESSIONS:
		PopulateCompletedSessionsType();
		ReSynchStoppedSessions();
		break;
	case SHELLVIEW_LOGFILES:
		PopulateLogType();
		break;
	case SHELLVIEW_DUMPFILES:
		PopulateDumpType();
		break;
    case SHELLVIEW_MSINFOFILES:
        PopulateMSInfoType();
        break;
	case SHELLVIEW_NONE:
		break;
	}

    //Select the last selected item
    //Try to select the last emobject name selected.  If not, select the first item in the view.
    SelectItemBySZNAME( m_lastSelectedEmObj.szName, m_lastSelectedEmObj.nId );
}

/*void CEmshellView::CloseAllSessions()
{
}
*/

void CEmshellView::ListCtrlClear()
{
	INT_PTR			nUpperBound		= 0;
	PActiveSession	pActiveSession	= NULL;
	HRESULT			hr				= E_FAIL;
	PEmObject		pEmObject		= NULL;
	INT_PTR			nCount			= m_mainListControl.GetItemCount();

	//We need to make sure the timer doesn't get through when the list is empty
	//Destroy the timer first
	KillTimer(1);

	//Step through every item in the list control and delete the pEmObjects
	//and the item.  
	for (int i = 0;i < nCount; i++) {
		pEmObject = (PEmObject)m_mainListControl.GetItemData(i);
		
		//Cast dwData to a EmObject and call delete on it
		((CEmshellApp*)AfxGetApp())->DeAllocEmObject(pEmObject);
	}

	//Remove all the items from the list control
	i = m_mainListControl.DeleteAllItems();
    ASSERT(m_mainListControl.GetItemCount() == 0);

	//Set all the pEmObjects to NULL
	for (nUpperBound = m_SessionTable.GetUpperBound(); nUpperBound >= 0; nUpperBound--) {
		pActiveSession = (PActiveSession) m_SessionTable.GetAt(nUpperBound);
		
		ASSERT(pActiveSession != NULL);
		pActiveSession->pEmObject = NULL;
	}
}

void CEmshellView::OnViewServicesandapplications() 
{
    if ( m_enumShellViewState == SHELLVIEW_ALL ) return;

	SetShellState(SHELLVIEW_ALL);
	ListCtrlPopulate(SHELLVIEW_ALL);
}

void CEmshellView::OnUpdateViewServicesandapplications(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;
	BOOL bChecked = FALSE;

	if ( GetDocument()->GetConnectedToServerState() == TRUE ) {
		bEnable = TRUE;
		if ( m_enumShellViewState == SHELLVIEW_ALL ) {
			bChecked = TRUE;
		}
	}
	pCmdUI->Enable ( bEnable );	
	pCmdUI->SetCheck( bChecked );
}

void CEmshellView::OnViewLogfiles() 
{
    if ( m_enumShellViewState == SHELLVIEW_LOGFILES ) return;

	SetShellState(SHELLVIEW_LOGFILES);
	ListCtrlPopulate(SHELLVIEW_LOGFILES);
}

void CEmshellView::OnUpdateViewLogfiles(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;
	BOOL bChecked = FALSE;

	if ( GetDocument()->GetConnectedToServerState() == TRUE ) {
		bEnable = TRUE;
		if ( m_enumShellViewState == SHELLVIEW_LOGFILES )  
			bChecked = TRUE;
	}	
	pCmdUI->Enable ( bEnable );	
	pCmdUI->SetCheck( bChecked );
}

void CEmshellView::OnViewDumpfiles() 
{
    if ( m_enumShellViewState == SHELLVIEW_DUMPFILES ) return;

	SetShellState(SHELLVIEW_DUMPFILES);
	ListCtrlPopulate(SHELLVIEW_DUMPFILES);
}

void CEmshellView::OnUpdateViewDumpfiles(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;
	BOOL bChecked = FALSE;

	if ( GetDocument()->GetConnectedToServerState() == TRUE ) {
		bEnable = TRUE;
		if ( m_enumShellViewState == SHELLVIEW_DUMPFILES )  
			bChecked = TRUE;
	}	
	pCmdUI->Enable ( bEnable );	
	pCmdUI->SetCheck( bChecked );
}

void CEmshellView::OnUpdateLogpopupOpen(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;

	//TODO: Enable the button when display a log file is supported
	pCmdUI->Enable ( m_enumShellViewState == SHELLVIEW_LOGFILES );	
}

void CEmshellView::OnLogpopupOpen() 
{
	// TODO: Add your command handler code here

    PEmObject   pEmObject   =   NULL;

    pEmObject = GetSelectedEmObject();

    if ( pEmObject == NULL ) return;

	CReadLogsDlg ReadLogDlg(pEmObject, GetDocument()->GetEmManager());
    ReadLogDlg.DoModal();
}

void CEmshellView::OnUpdateLogpopupProperties(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;

	//TODO: Enable the button when properties of a log file is supported
	pCmdUI->Enable ( TRUE );	
}

void CEmshellView::OnLogpopupProperties() 
{
	// TODO: Add your command handler code here
    
    PEmObject   pEmObject = GetSelectedEmObject();
    
    if ( pEmObject ) {
        ShowProperties( pEmObject );
    }
}

void CEmshellView::ShowProperties( PEmObject pEmObject )
{
    CPropertySheet      propsheet;
    CPropPageGenLogDump genLogDumpPropPage;

    genLogDumpPropPage.m_pEmObj = pEmObject;
    genLogDumpPropPage.m_pParentPropSheet = &propsheet;

    propsheet.AddPage(&genLogDumpPropPage);
    propsheet.SetTitle( pEmObject->szName, PSH_PROPTITLE );
	propsheet.DoModal();

    if( genLogDumpPropPage.m_bDeleteFile ) {

        OnLogpopupDelete();
    }

}

EMShellViewState CEmshellView::GetViewState()
{
	return m_enumShellViewState;
}

HRESULT CEmshellView::StartCDBClient(IN LPTSTR lpszConnectString)
{
	STARTUPINFO sp;
	PROCESS_INFORMATION pi;

	ZeroMemory(&sp, sizeof( sp ) );
	ZeroMemory(&pi, sizeof( pi ) );

	BOOL bCdbCreated = CreateProcess(// This has to be obtained from the registry...
			                            _T("C:\\Debuggers\\cdb.exe"),
			                            lpszConnectString,
			                            NULL,
			                            NULL,
			                            FALSE,
			                            CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE,
			                            NULL,
			                            NULL,
			                            &sp,
			                            &pi
			                            );

	//
	// Wait till CDB does some initializations..
	// Don't know how long to wait.. have to figure out a way..
	//
	Sleep(2000);

    if(bCdbCreated == FALSE){
    	return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

HRESULT CEmshellView::GetClientConnectString(IN OUT LPTSTR pszConnectString, IN DWORD dwBuffSize, PEmObject pEmSessObj, int nPort)
{
	_ASSERTE(pszConnectString != NULL);
	_ASSERTE(dwBuffSize > 0L);

	HRESULT	hr			= E_FAIL;
	DWORD	dwBuff		= MAX_COMPUTERNAME_LENGTH;

	do
	{
		if( pszConnectString == NULL	||
			dwBuffSize <= 0L ) break;

		if( nPort != 0 ){
			_stprintf(pszConnectString, _T(" -remote tcp:server=%s,port=%d"), GetDocument()->GetServerName(), nPort);
		}
		else {
			_stprintf(pszConnectString, _T(" -remote npipe:server=%s,pipe=EM_%d"), GetDocument()->GetServerName(), pEmSessObj->nId);
		}

		hr = S_OK;
	}
	while( false );

	return hr;
}


void CEmshellView::DoModalPropertySheet(PEmObject pEmObject)
{
	CPropertySheet		propsheet;
	CPropPageGeneral	generalPropPage;
	CPropPageLogFiles	logFilesPropPage;
	CPropPageDumpFiles	dumpFilesPropPage;
	BOOL				bInActiveSessionTable = FALSE;

	generalPropPage.m_pEmObject			= pEmObject;
	logFilesPropPage.m_pEmObject		= pEmObject;
	logFilesPropPage.m_pIEmManager		= GetDocument()->GetEmManager();
	dumpFilesPropPage.m_pEmObject		= pEmObject;
	dumpFilesPropPage.m_pIEmManager		= GetDocument()->GetEmManager();

	propsheet.AddPage(&generalPropPage);
	propsheet.AddPage(&logFilesPropPage);
	propsheet.AddPage(&dumpFilesPropPage);

    //
    // a-mando
    //
    propsheet.SetTitle( pEmObject->szName, PSH_PROPTITLE );

	propsheet.DoModal();
}

void CEmshellView::OnViewApplications() 
{
    if ( m_enumShellViewState == SHELLVIEW_APPLICATIONS ) return;

	SetShellState(SHELLVIEW_APPLICATIONS);
	ListCtrlPopulate(SHELLVIEW_APPLICATIONS);
}

void CEmshellView::OnUpdateViewApplications(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;
	BOOL bChecked = FALSE;

	if ( GetDocument()->GetConnectedToServerState() == TRUE ) {
		bEnable = TRUE;
		if ( m_enumShellViewState == SHELLVIEW_APPLICATIONS )  
			bChecked = TRUE;
	}	
	pCmdUI->Enable ( bEnable );	
	pCmdUI->SetCheck( bChecked );
}

void CEmshellView::OnViewCompletedsessions() 
{
    if ( m_enumShellViewState == SHELLVIEW_COMPLETEDSESSIONS ) return;

	SetShellState(SHELLVIEW_COMPLETEDSESSIONS);
	ListCtrlPopulate(SHELLVIEW_COMPLETEDSESSIONS);
}

void CEmshellView::OnUpdateViewCompletedsessions(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;
	BOOL bChecked = FALSE;

	if ( GetDocument()->GetConnectedToServerState() == TRUE ) {
		bEnable = TRUE;
		if ( m_enumShellViewState == SHELLVIEW_COMPLETEDSESSIONS )  
			bChecked = TRUE;
	}	
	pCmdUI->Enable ( bEnable );	
	pCmdUI->SetCheck( bChecked );
}

void CEmshellView::OnViewServices() 
{
    if ( m_enumShellViewState == SHELLVIEW_SERVICES ) return;

	SetShellState(SHELLVIEW_SERVICES);
	ListCtrlPopulate(SHELLVIEW_SERVICES);
}

void CEmshellView::OnUpdateViewServices(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;
	BOOL bChecked = FALSE;

	if ( GetDocument()->GetConnectedToServerState() == TRUE ) {
		bEnable = TRUE;
		if ( m_enumShellViewState == SHELLVIEW_SERVICES )  
			bChecked = TRUE;
	}	
	pCmdUI->Enable ( bEnable );	
	pCmdUI->SetCheck( bChecked );
}

void CEmshellView::OnProcesspopupDeleteSession() 
{
	//Delete the session for the current item selected
	PEmObject			pEmObject			= NULL;
	HRESULT				hr					= E_FAIL;
	int					nIndex				= -1;
	PActiveSession		pActiveSession		= NULL;
	IEmDebugSession*	pTempDebugSession	= NULL;
	BSTR				bstrEmObj		    = NULL;

	do {
		nIndex = GetSelectedItemIndex();
		
		if ( nIndex == -1 ) break;

		pEmObject = ( PEmObject ) m_mainListControl.GetItemData( nIndex );

		if ( pEmObject == NULL ) break;

		//Find the element in the session table
		pActiveSession = FindActiveSession( pEmObject );
		if ( pActiveSession == NULL ) {
			//Create bstr's for the journey ahead, and break if we can't
			bstrEmObj = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );
			if( bstrEmObj == NULL ){
				hr = E_OUTOFMEMORY;
				break;
			}
			
			//We don't have a session open, so open a temporary session
			hr = GetDocument()->GetEmManager()->OpenSession( bstrEmObj, &pTempDebugSession );
			if (FAILED(hr)) break;

            SysFreeString( bstrEmObj );

			if ( hr == S_OK ) {
				//We are the master now... Delete the debug session
				hr = DeleteDebugSession( pEmObject );
		    	if ( FAILED( hr ) ) break;
			}
            else if ( hr == S_FALSE ) {
                //Adopt the orphan if the user wants
			    if ( CommenceOrphanCustodyBattle( pTempDebugSession ) ) {
                    hr = DeleteDebugSession( pEmObject );
	        		if ( FAILED( hr ) ) break;
                } else break;
            }
			else if ( hr == E_FAIL ) {
				//Notify the user that the process currently belongs to someone else
				break;
			}
		}
		else {
			//Close and remove the currently selected session
			hr = DeleteDebugSession( pEmObject );
			if ( FAILED( hr ) ) break;

			hr = RemoveActiveSession( pEmObject );
			if ( FAILED( hr ) ) break;
		}

		//Cast dwData to a EmObject and call delete on it
		((CEmshellApp*)AfxGetApp())->DeAllocEmObject(pEmObject);

        //Remove the item from the list control
		m_mainListControl.DeleteItem( nIndex );
	} while ( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}

	if ( pTempDebugSession ) {
		//Release the pTempDebugSession pointer
		SAFE_RELEASEIX( pTempDebugSession );
	}
	
	SysFreeString ( bstrEmObj );
}

void CEmshellView::OnUpdateProcesspopupDeleteSession( CCmdUI* pCmdUI ) 
{
	PEmObject		pEmObject		= NULL;
	PActiveSession	pActiveSession	= NULL;
	BOOL			bEnable			= FALSE;

	do {
		if ( !GetDocument()->GetConnectedToServerState() ) break;

		// Update the state of this button based on the state of the currently selected item
		//Get the currently selected emObject
		pEmObject = GetSelectedEmObject();
		if ( pEmObject == NULL ) break;

        pActiveSession = FindActiveSession( pEmObject );

		//Determine if the status of pActiveSession and enable this apprpriately
		//If it's status is stopped && (it's an orphan || it's in our session table)
		if ( pEmObject->nStatus & STAT_SESS_STOPPED && 
            ( pEmObject->nStatus & STAT_ORPHAN || pActiveSession ) ) {
			bEnable = TRUE;
		}
	}while ( FALSE );

	pCmdUI->Enable( bEnable );
}

void CEmshellView::OnToolsOptions() 
{
	// TODO: Add your command handler code here
	CEmOptions  EmOpts;
    DWORD       dwPollSessionsFreq = 30L; // default

    if( EmOpts.DoModal() == IDOK ) {

        ((CEmshellApp*)AfxGetApp())->GetEmShellRegOptions( FALSE, &dwPollSessionsFreq );
        KillTimer( 1 );
        SetTimer( 1, dwPollSessionsFreq*1000, 0);
    }
}

void CEmshellView::OnUpdateToolsOptoins(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	
}

void CEmshellView::OnProcesspopupCancelDebugSession() 
{
	//Stop the session for the current item selected
	PEmObject	pEmObject	= NULL;
	HRESULT		hr			= E_FAIL;

	do {
		pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

		//Stop and remove the session
		CancelDebugSession( pEmObject );

		hr = S_OK;
	} while ( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}
}

//
// a-mando
//
void CEmshellView::OnLogpopupDelete()
{
	//Stop the session for the current item selected
	PEmObject	pEmObject	    = NULL;
	HRESULT		hr			    = E_FAIL;
	BSTR		bstrEmObj       = NULL;
    UINT        nIndex          = -1;

	do {

        nIndex = GetSelectedItemIndex();
        if ( nIndex == -1 ) break;

        pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

		bstrEmObj = CopyBSTR ( (LPBYTE)pEmObject, sizeof( EmObject ) );

        if( bstrEmObj == NULL ){
			hr = E_OUTOFMEMORY;
			break;
        }

        hr = GetDocument()->GetEmManager()->DeleteFile( bstrEmObj );
        if( FAILED(hr) ) break;

        //Remove the item from the list control
		m_mainListControl.DeleteItem( nIndex );
        if( !m_mainListControl.SelectItem( nIndex ) ) {

            m_mainListControl.SelectItem( nIndex-1 );
        }

    } while ( FALSE );

	if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}
}

void CEmshellView::OnUpdateLogpopupDelete(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	
}
// a-mando

void CEmshellView::OnActionGenerateMSInfoFile() 
{
	// TODO: Add your command handler code here

    CMSInfoDlg  DlgMsInfo;
    BSTR        bstrCategories  =   NULL;
    HRESULT     hr              =   S_OK;

    CWaitCursor wait;

    // we won't show this dialog if the user doesn't want it.
    if( !((CEmshellApp*)AfxGetApp())->m_dwShowMSInfoDlg || DlgMsInfo.DoModal() == IDOK ) {

        ((CEmshellApp*)AfxGetApp())->m_dwShowMSInfoDlg = !DlgMsInfo.m_bDlgNoShow;

        bstrCategories = DlgMsInfo.m_csCategories.AllocSysString();

        hr = GetDocument()->GetEmManager()->MakeNFO( NULL, NULL, bstrCategories );
    }

    SysFreeString( bstrCategories );

    if ( FAILED( hr ) ) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR( hr );
	}
}

void CEmshellView::OnUpdateActionGenerateMSInfoFile(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here

    pCmdUI->Enable( GetDocument()->GetConnectedToServerState() );
}

void CEmshellView::OnViewMSInfoFiles() 
{
    if ( m_enumShellViewState == SHELLVIEW_MSINFOFILES ) return;

	SetShellState(SHELLVIEW_MSINFOFILES);
	ListCtrlPopulate(SHELLVIEW_MSINFOFILES);
}

void CEmshellView::OnUpdateViewMSInfoFiles(CCmdUI* pCmdUI) 
{
	BOOL bEnable = FALSE;
	BOOL bChecked = FALSE;

	if ( GetDocument()->GetConnectedToServerState() == TRUE ) {
		bEnable = TRUE;
		if ( m_enumShellViewState == SHELLVIEW_MSINFOFILES )  
			bChecked = TRUE;
	}	
	pCmdUI->Enable ( bEnable );	
	pCmdUI->SetCheck( bChecked );
}

void CEmshellView::PopulateMSInfoType()
{
	_variant_t		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter       = NULL;
	EmObject		*pCurrentObj	= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ) );

	do {
		EmObjectFilter.type = EMOBJ_MSINFO;
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		hr = GetDocument()->GetEmManager()->EnumObjectsEx(bstrEmObjectFilter, &var);

		if(FAILED(hr)) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if (pCurrentObj != NULL) {
				*pCurrentObj = *GetEmObj( bstrEmObj );
			}

            SysFreeString( bstrEmObj );

			//Unallocate the EmObject if it has an hr of E_FAIL
			if (FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject( pCurrentObj );
				continue;
			}

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayMSInfoData( pCurrentObj );
		}
	} while (FALSE);

    SafeArrayDestroyData(var.parray);
	SysFreeString ( bstrEmObjectFilter );
    SysFreeString( bstrEmObj );
    
	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CEmshellView::InitializeMSInfoView()
{
    InitializeLogView();
}

void CEmshellView::OnLogpopupExport() 
{
	PEmObject	pEmObject	    = NULL;
    CString     strDirPath;

    do {

        pEmObject = GetSelectedEmObject();

		if ( pEmObject == NULL ) break;

        //Get the path
        if ( ( (CEmshellApp*) AfxGetApp() )->AskForPath( strDirPath ) ) {
            //Export the file
            ((CEmshellApp*)AfxGetApp())->ExportLog( pEmObject, strDirPath, GetDocument()->GetEmManager() );
        }
    } while ( FALSE );

}

void CEmshellView::OnUpdateLogpopupExport(CCmdUI* pCmdUI) 
{
	// TODO: Add your command update UI handler code here
	
}

void CEmshellView::OnHelpContents() 
{
	// TODO: Add your command handler code here
    HWND hwnd = HtmlHelp( ::GetDesktopWindow(), ((CEmshellApp*)AfxGetApp())->m_strApplicationPath + gtcEmChm, HH_DISPLAY_TOPIC, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\genlistctrl.cpp ===
// GenListCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "GenListCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenListCtrl

CGenListCtrl::CGenListCtrl()
{
	m_lNumOfColumns		=	0;
	m_lCurrentColumn	=	-1L;
	m_pColumnHdrArr		=	NULL;
}

CGenListCtrl::~CGenListCtrl()
{
	if(m_pColumnHdrArr) delete [] m_pColumnHdrArr;
}


BEGIN_MESSAGE_MAP(CGenListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CGenListCtrl)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclickRef)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGenListCtrl message handlers
void
CGenListCtrl::ResizeColumnsFitScreen()
{
	CRect			rcListCtrl;
	int				cCtrlWidth	=	0;
	int				nColWidth	=	0;
	int				nNumCols	=	0;
	int				nIdx		=	0;
	CHeaderCtrl		*pHdrCtl	=	NULL;

	do
	{
		if(::IsWindow(m_hWnd) == FALSE) break;

		GetClientRect(&rcListCtrl);
		cCtrlWidth = rcListCtrl.right - rcListCtrl.left;

		//
		// Remember to take care of the Vertical scroll
		// bar when calculating the width of the control.
		//
		if(GetScrollBarCtrl(SB_VERT) != NULL){
			cCtrlWidth -= GetSystemMetrics(SM_CXVSCROLL);
		}

		pHdrCtl = GetHeaderCtrl();
		if(pHdrCtl == NULL) break;

		nNumCols = pHdrCtl->GetItemCount();
		if(nNumCols == 0) break; // No columns are as yet
								 // inserted..

		//
		// This gives the width (new) of each column.
		//
		nColWidth = cCtrlWidth / nNumCols;

		SetRedraw(FALSE);

		while(nIdx < nNumCols){
			SetColumnWidth(nIdx++, nColWidth);
		}

		SetRedraw(TRUE);
		InvalidateRect(NULL);
	}
	while(FALSE);
}

void
CGenListCtrl::ResizeColumnsWithRatio()
{
	int				nNumColumns			=	0;
	int				*pWidths			=	NULL;
	int				nTotalColumnWidth	=	0;
	int				nIdx				=	0;
	CHeaderCtrl		*pHdrCtl			=	NULL;
	RECT			rectList;

	do
	{
		if(::IsWindow(m_hWnd) == FALSE) break;

		pHdrCtl = GetHeaderCtrl();
		if(pHdrCtl == NULL) break;

		nNumColumns = pHdrCtl->GetItemCount();

		//
		// To store the widths of each column.
		//
		pWidths	=	new int[nNumColumns];
		if(pWidths == NULL) break;

		nIdx = 0;
		while(nIdx < nNumColumns){
			pWidths[nIdx] = GetColumnWidth(nIdx);

			//
			// We need to calculate the sum of
			// all the column widths for finding
			// the %widths of each column.
			//
			nTotalColumnWidth += pWidths[nIdx++];
		}

		//
		// 1. No columns are inserted as yet
		// 2. Or, all the columns have been
		// reduced to 0 width.
		//
		if(nTotalColumnWidth == 0) break;

		//
		// This is the new width, to which the
		// columns have to be distributed..
		//
		GetClientRect(&rectList);
		nIdx = 0;

		SetRedraw(FALSE);

		while(nIdx < nNumColumns){
			SetColumnWidth(nIdx, (pWidths[nIdx++] * (rectList.right - rectList.left)) / nTotalColumnWidth);
		}

		SetRedraw(TRUE);
		InvalidateRect(NULL);
	}
	while(FALSE);

	if(pWidths)delete[] pWidths;
}

BOOL
CGenListCtrl::SelectItem
(
IN	LONG nIndex
)
{
    BOOL bRet = FALSE;

	//
	// This ensures the items are scrolled as
	// needed to make the item at nIndex visible..
	//
	bRet = EnsureVisible(nIndex, FALSE);

	//
	// This selects the item.
	//
    if( bRet )
	    bRet = SetItemState(nIndex, 
                            LVIS_SELECTED | LVIS_FOCUSED,
                            LVIS_SELECTED | LVIS_FOCUSED
                            );

    return bRet;
}

void
CGenListCtrl::BeginSetColumn
(
IN	LONG nCols
)
{
	if(nCols == 0) return;

	m_lNumOfColumns = nCols;

	//
	// Allocate enough memory to store header data..
	//
	m_pColumnHdrArr = new GenListCtrlHeader[nCols];
	if(m_pColumnHdrArr == NULL) /* ? */ return;

	//
	// Starting from the first column..
	//
	m_lCurrentColumn = 0L;
}

void
CGenListCtrl::AddColumn
(
IN	LPCTSTR pszColumn,
IN	short	nType
)
{
	do
	{
		if(m_lCurrentColumn >= m_lNumOfColumns) break;

		//
		// BeginSetColumn, not called yet?
		//
		if(m_pColumnHdrArr == NULL) break;

		if(pszColumn == NULL) break;

		m_pColumnHdrArr[m_lCurrentColumn].csText = pszColumn;
		m_pColumnHdrArr[m_lCurrentColumn].nType = nType;

		//
		// Will be pointing to the next column, next
		// time AddColumn is called.. This will also
		// be an indicator to the number of columns
		// actually added..
		//
		++m_lCurrentColumn;
	}
	while(FALSE);
}

void
CGenListCtrl::EndSetColumn()
{
	int	nIdx	=	0;

	do
	{
		SetRedraw(FALSE);

		//
		// Insert all the columns when EndSetColumn is
		// called. This helps in avoiding the flicker
		// that is experienced if we insert one column
		// at a time..
		//
		while(nIdx < m_lCurrentColumn){
			InsertColumn(nIdx, m_pColumnHdrArr[nIdx++].csText);
		}

		SetRedraw(TRUE);
		InvalidateRect(NULL);
	}
	while(FALSE);
}

LONG
CGenListCtrl::SetItemText
(
IN	LONG	nRow,
IN	LONG	nCol,
IN	LPCTSTR pszText
)
{
	LONG	lRet		=	-1L;
	LONG	lNumItems	=	0L;

	lNumItems = GetItemCount();

	//
	// New Item is being inserted..
	//
	if( nRow == lNumItems	||
		nRow == -1L){
		lRet = InsertItem(lNumItems, pszText);
	}
	//
	// SubItem text is being set..
	//
	else if(nRow < lNumItems	&&
			(nCol >= 1 && nCol < m_lCurrentColumn)){
		lRet = CListCtrl::SetItemText(nRow, nCol, pszText);
		lRet == 0 ? lRet = -1 : lRet = nRow;
	}

	return lRet;
}

int CALLBACK
CGenListCtrl::CompareItems
(
IN	LPARAM lParam1,
IN	LPARAM lParam2,
IN	LPARAM lParamSort
)
{
	return 1;
}

void
CGenListCtrl::OnColumnclickRef
(
IN	NMHDR	*pNMHDR,
IN	LRESULT	*pResult
)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

	static int	nEarlierColumn = pNMListView->iSubItem;

	if(nEarlierColumn == pNMListView->iSubItem){
		m_bAscending = !m_bAscending;
	}
	else{
		m_bAscending = TRUE;
	}

	nEarlierColumn = pNMListView->iSubItem;
	BubbleSortItems(nEarlierColumn, m_bAscending, m_pColumnHdrArr[nEarlierColumn].nType);
	
	*pResult = 0;
}

int
CGenListCtrl::GenCompareFunc
(
IN	LPARAM lParam1,
IN	LPARAM lParam2
)
{
	return 0;
}

BOOL
CGenListCtrl::BubbleSortItems
(
IN	int		nCol,
IN	BOOL	bAscending,
IN	short	nType,
IN	int		nLo,
IN	int		nHi
)
{
	BOOL		bRet		=	FALSE;
	CHeaderCtrl *pHdrCtl	=	GetHeaderCtrl();
	LONG		nNumCols	=	0L;
	CString		csTextLo	=	_T("");
	CString		csTextHi	=	_T("");

	do
	{
		if(!(pHdrCtl == NULL)								&&
			((nNumCols = pHdrCtl->GetItemCount()) == 0L)	&&
			(nCol >= nNumCols)
			) break;

		if(nHi == -1) nHi = GetItemCount();

		for(int i = nLo; i < nHi; i++){
			for(int j = i + 1; j < nHi; j++){
				csTextLo = GetItemText(i, nCol);
				csTextHi = GetItemText(j, nCol);

				switch(nType)
				{
				case VT_BSTR:
					if(bAscending == TRUE){
						if(csTextLo.CompareNoCase(csTextHi) > 0){
							SwapRows(i, j);
						}
					}
					else{
						if(csTextLo.CompareNoCase(csTextHi) < 0){
							SwapRows(i, j);
						}
					}
					break;
				case VT_I4:
					if(bAscending == TRUE){
						if(_ttol(csTextLo) > _ttol(csTextHi)){
							SwapRows(i, j);
						}
					}
					else{
						if(_ttol(csTextLo) < _ttol(csTextHi)){
							SwapRows(i, j);
						}
					}
					break;
				}
			}
		}
	}
	while(FALSE);

	return bRet;
}

void
CGenListCtrl::SwapRows
(
IN	LONG lRowLo,
IN	LONG lRowHi
)
{
	LVITEM			lviLo, lviHi;
	CStringArray	arrAllColumnsText;
	LONG			nNumCols = GetHeaderCtrl()->GetItemCount();

	arrAllColumnsText.SetSize(nNumCols);

	lviLo.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_STATE | LVIF_INDENT;
	lviLo.iItem = lRowLo;

	lviLo.iSubItem = 0;
	lviLo.stateMask = -1; // All state masks...

	lviHi = lviLo;
	lviHi.iItem = lRowHi;

	GetItem( &lviLo );
	GetItem( &lviHi );

	CString csTest = GetItemText(lRowLo, 0);
	csTest = GetItemText(lRowLo, 1);
	csTest = GetItemText(lRowLo, 2);

	for(int i = 0; i < nNumCols; i++)
		arrAllColumnsText[i] = GetItemText(lRowLo, i);

	for(i = 0; i < nNumCols; i++)
		CListCtrl::SetItemText(lRowLo, i, GetItemText(lRowHi, i));

	lviHi.iItem = lRowLo;
	SetItem( &lviHi );

	for(i = 0; i < nNumCols; i++)
		CListCtrl::SetItemText(lRowHi, i, arrAllColumnsText[i]);

	lviLo.iItem = lRowHi;
	SetItem( &lviLo );
}


BOOL CGenListCtrl::IsAscending()
{
	return m_bAscending;
}

PGenListCtrlHeader CGenListCtrl::GetListCtrlHeader()
{
	return m_pColumnHdrArr;
}

HRESULT CGenListCtrl::ResetListCtrl()
{
	HRESULT hr	= E_FAIL;

	do {
		//Count the number of rows and delete them all
		CGenListCtrl::DeleteAllItems();

		//Count the number of columns and delete them all
		int nColumnCount = GetHeaderCtrl()->GetItemCount();

		// Delete all of the columns.
		for (int i=0;i < nColumnCount;i++)
		{
		   DeleteColumn(0);
		}
		//Reset the member variables to their initial values
		m_bAscending = FALSE;
		m_lColumnClicked = 0;
		m_lCurrentColumn = -1L;
		m_lNumOfColumns = 0;

		//We need to delete the hdrarray
		if(m_pColumnHdrArr) delete [] m_pColumnHdrArr;
		m_pColumnHdrArr = NULL;
	} while (FALSE);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "emshell.h"
#include "ConnectionDlg.h"
#include "emshellview.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_SEPARATOR,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}
/*	if (!m_wndDlgBar.Create(this, IDR_MAINFRAME, 
		CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
	{
		TRACE0("Failed to create dialogbar\n");
		return -1;		// fail to create
	}
*/

	if (!m_wndReBar.Create(this) ||
		!m_wndReBar.AddBar(&m_wndToolBar) 
        /* || !m_wndReBar.AddBar(&m_wndDlgBar) */
        )
	{
		TRACE0("Failed to create rebar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

    m_wndStatusBar.SetPaneInfo( 1, ID_SEPARATOR, SBPS_NORMAL, 96 );
	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	//Modify the cs structure to remove the FWS_ADDTOTITLE style.
	//cs.style &= ~FWS_ADDTOTITLE;

	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers



CStatusBar* CMainFrame::GetStatusBar()
{
	return &m_wndStatusBar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\genlistctrl.h ===
#if !defined(AFX_GENLISTCTRL_H__CF59F8D3_F8A7_4D9E_82B5_FD9D10E5EC24__INCLUDED_)
#define AFX_GENLISTCTRL_H__CF59F8D3_F8A7_4D9E_82B5_FD9D10E5EC24__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GenListCtrl.h : header file
//

class CGenListCtrl;

//
// Column Headings for the list control
//
typedef struct _GenListCtrlHeader{
    CString     csText; // ??? <- Can be removed.
    short		nType;
} GenListCtrlHeader, *PGenListCtrlHeader;

/////////////////////////////////////////////////////////////////////////////
// CGenListCtrl window

class CGenListCtrl : public CListCtrl
{
	PGenListCtrlHeader	m_pColumnHdrArr;
// Construction
public:
	CGenListCtrl();

// Attributes
public:
private:
	BOOL m_bAscending;
	LONG m_lCurrentColumn;
	LONG m_lNumOfColumns;

// Operations
public:
    void ResizeColumnsFitScreen ( void );
    void ResizeColumnsWithRatio ( void );

    BOOL SelectItem ( LONG nIndex );

    void BeginSetColumn ( LONG nCols );
    void AddColumn ( LPCTSTR pszColumn, short type = VT_BSTR );
    void EndSetColumn ( void );

    LONG SetItemText ( LONG nRow, LONG nCol, LPCTSTR pszText );
	static int CALLBACK CompareItems(LPARAM lParam1, LPARAM lParam2, LPARAM lParam3);
//    LRESULT GenCompareFunc ( NMHDR* pNMH, DWORD dwParam1, DWORD dwParam2 );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGenListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	HRESULT ResetListCtrl();
	PGenListCtrlHeader GetListCtrlHeader();
	BOOL IsAscending();
	void SwapRows(LONG lRowLo, LONG lRowHi);
	BOOL BubbleSortItems( int nCol, BOOL bAscending, short nType = VT_BSTR, int nLo = 0, int nHi = -1);
	virtual int GenCompareFunc(LPARAM lParam1, LPARAM lParam2);
	LONG m_lColumnClicked;
	virtual ~CGenListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CGenListCtrl)
	afx_msg void OnColumnclickRef(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GENLISTCTRL_H__CF59F8D3_F8A7_4D9E_82B5_FD9D10E5EC24__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__044545C0_0809_42F8_BAB5_8D920DCDD809__INCLUDED_)
#define AFX_MAINFRM_H__044545C0_0809_42F8_BAB5_8D920DCDD809__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	CStatusBar* GetStatusBar();
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	CReBar      m_wndReBar;
//	CDialogBar      m_wndDlgBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__044545C0_0809_42F8_BAB5_8D920DCDD809__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\emshellview.h ===
// emshellView.h : interface of the CEmshellView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_EMSHELLVIEW_H__4D47F015_9482_4563_8A25_58AA5FD22CB4__INCLUDED_)
#define AFX_EMSHELLVIEW_H__4D47F015_9482_4563_8A25_58AA5FD22CB4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "EmListCtrl.h"
#include "emsvc.h"
#include "emobjdef.h"

class CEmshellDoc;

class CEmshellView : public CFormView
{
protected: // create from serialization only
	CEmshellView();
	DECLARE_DYNCREATE(CEmshellView)

public:
	//{{AFX_DATA(CEmshellView)
	enum { IDD = IDD_EMSHELL_FORM };
	CEmListCtrl	m_mainListControl;
	//}}AFX_DATA

// Attributes
public:
	CEmshellDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEmshellView)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
    void SelectItemBySZNAME(TCHAR*	pszName, int nId);
    void ShowProperties( PEmObject pEmObject );
	void InitializeMSInfoView();
	void PopulateMSInfoType();
	BOOL CommenceOrphanCustodyBattle( IEmDebugSession* pIEmDebugSession );
	void ReSynchStoppedSessions();
	void DoModalPropertySheet(PEmObject pEmObject);
	HRESULT GetClientConnectString(IN OUT LPTSTR pszConnectString, IN DWORD dwBuffSize, PEmObject pEmSessObj, int nPort);
	HRESULT StartCDBClient(IN LPTSTR lpszConnectString);
	EMShellViewState GetViewState();
	void SetShellState(EMShellViewState eState);
	void PopulateProcessType();
	void PopulateServiceType();
	void PopulateDumpType();
	void PopulateLogType();
	void PopulateCompletedSessionsType();
	void ListCtrlInitialize(EMShellViewState eShellViewState);
	void InitializeDumpView();
	void InitializeLogView();
	void InitializeProcessView();
	void InitializeAllView();
	void InitializeServiceView();
	void InitializeCompletedSessionsView();
	int GetImageOffsetFromStatus(EmSessionStatus em);
	PActiveSession FindActiveSession(PEmObject pEmObject);
	PEmObject GetSelectedEmObject();
	int GetSelectedItemIndex();
	void RefreshListCtl();
	void RefreshProcessViewElement(PEmObject pEmObject);
	void RefreshServiceViewElement(PEmObject pEmObject);
	void RefreshCompletedSessionViewElement(PEmObject pEmObject);
	void RefreshAllViewElement(PEmObject pEmObject);
	void RefreshLogViewElement(PEmObject pEmObject);
	void RefreshDumpViewElement(PEmObject pEmObject);
	void GenerateDump(PEmObject pEmObj, BOOL bMiniDump);
	void ReSynchServices();
	void ReSynchApplications();
	void UpdateListElement(PEmObject pEmObject);
	HRESULT DeleteDebugSession(PEmObject pEmObject);
	HRESULT RemoveActiveSession(PEmObject pEmObject);
	void StopDebugSession(PEmObject pEmObject);
	void CancelDebugSession(PEmObject pEmObject);
	void DeAllocActiveSession(PActiveSession pActiveSession);
	void ListCtrlClear();
	void ListCtrlPopulate(EMShellViewState eShellViewState);
	HRESULT StartAutomaticDebugSession(EmObject* pEmObject);
	HRESULT StartManualDebugSession(EmObject* pEmObject);
	void ClearSessionTable();
	PActiveSession AllocActiveSession(PEmObject pEmObject, IEmDebugSession* pIDebugSession);
    PActiveSession AddActiveSession(PEmObject pEmObject, IEmDebugSession* pIEmDebugSession, BOOL bMaster);
	CPtrArray* GetSessionTable();
	virtual ~CEmshellView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	EMShellViewState m_enumShellViewState;
    void StoreOffSelectedEmObject();
    EmObject    m_lastSelectedEmObj;
	CImageList	m_ShellImageList;
	CPtrArray	m_SessionTable;
	BOOL m_bLocalServer;
	HRESULT DisplayProcessData(PEmObject pEmObject);
	HRESULT DisplayServiceData(PEmObject pEmObject);
	HRESULT DisplayLogData(PEmObject pEmObject);
	HRESULT DisplayDumpData(PEmObject pEmObject);
    HRESULT DisplayStoppedSessionData(PEmObject pEmObject);
    HRESULT DisplayMSInfoData(PEmObject pEmObject);
	//{{AFX_MSG(CEmshellView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnUpdateViewRefresh(CCmdUI* pCmdUI);
	afx_msg void OnViewRefresh();
	afx_msg void OnUpdateProcesspopupStopDebugSession(CCmdUI* pCmdUI);
	afx_msg void OnProcesspopupStopDebugSession();
	afx_msg void OnProcesspopupGenerateminidump();
	afx_msg void OnUpdateProcesspopupGenerateminidump(CCmdUI* pCmdUI);
	afx_msg void OnProcesspopupGenerateuserdump();
	afx_msg void OnUpdateProcesspopupGenerateuserdump(CCmdUI* pCmdUI);
	afx_msg void OnProcesspopupAutomaticsession();
	afx_msg void OnUpdateProcesspopupAutomaticsession(CCmdUI* pCmdUI);
	afx_msg void OnUpdateProcesspopupProperties(CCmdUI* pCmdUI);
	afx_msg void OnProcesspopupProperties();
	afx_msg void OnUpdateProcesspopupManualsession(CCmdUI* pCmdUI);
	afx_msg void OnProcesspopupManualsession();
	afx_msg void OnProcesspopupRefresh();
	afx_msg void OnUpdateProcesspopupRefresh(CCmdUI* pCmdUI);
	afx_msg void OnViewServicesandapplications();
	afx_msg void OnUpdateViewServicesandapplications(CCmdUI* pCmdUI);
	afx_msg void OnViewLogfiles();
	afx_msg void OnUpdateViewLogfiles(CCmdUI* pCmdUI);
	afx_msg void OnViewDumpfiles();
	afx_msg void OnUpdateViewDumpfiles(CCmdUI* pCmdUI);
	afx_msg void OnUpdateLogpopupOpen(CCmdUI* pCmdUI);
	afx_msg void OnLogpopupOpen();
	afx_msg void OnUpdateLogpopupProperties(CCmdUI* pCmdUI);
	afx_msg void OnLogpopupProperties();
	afx_msg void OnViewApplications();
	afx_msg void OnUpdateViewApplications(CCmdUI* pCmdUI);
	afx_msg void OnViewCompletedsessions();
	afx_msg void OnUpdateViewCompletedsessions(CCmdUI* pCmdUI);
	afx_msg void OnViewServices();
	afx_msg void OnUpdateViewServices(CCmdUI* pCmdUI);
	afx_msg void OnProcesspopupDeleteSession();
	afx_msg void OnUpdateProcesspopupDeleteSession(CCmdUI* pCmdUI);
	afx_msg void OnToolsOptions();
	afx_msg void OnUpdateToolsOptoins(CCmdUI* pCmdUI);
	afx_msg void OnProcesspopupCancelDebugSession();
	afx_msg void OnUpdateProcesspopupCancelDebugSession(CCmdUI* pCmdUI);
	afx_msg void OnLogpopupDelete();
	afx_msg void OnUpdateLogpopupDelete(CCmdUI* pCmdUI);
	afx_msg void OnActionGenerateMSInfoFile();
	afx_msg void OnUpdateActionGenerateMSInfoFile(CCmdUI* pCmdUI);
	afx_msg void OnViewMSInfoFiles();
	afx_msg void OnUpdateViewMSInfoFiles(CCmdUI* pCmdUI);
	afx_msg void OnLogpopupExport();
	afx_msg void OnUpdateLogpopupExport(CCmdUI* pCmdUI);
	afx_msg void OnHelpContents();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
};

#ifndef _DEBUG  // debug version in emshellView.cpp
inline CEmshellDoc* CEmshellView::GetDocument()
   { return (CEmshellDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EMSHELLVIEW_H__4D47F015_9482_4563_8A25_58AA5FD22CB4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\msinfodlg.cpp ===
// MSInfoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "MSInfoDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMSInfoDlg dialog


CMSInfoDlg::CMSInfoDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMSInfoDlg::IDD, pParent)
{
#ifdef _DEBUG
	m_csCategories = _T("/CATEGORIES: +componentsNetadapter+componentsports+componentsstorage+componentsprinting");
#else
	m_csCategories = _T("/CATEGORIES: +all");
#endif

    m_bShow = false;

	//{{AFX_DATA_INIT(CMSInfoDlg)
	m_bDlgNoShow = FALSE;
	//}}AFX_DATA_INIT
}


void CMSInfoDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMSInfoDlg)
	DDX_Control(pDX, IDC_CHECK_NFODIALOG_NOSHOW, m_ctrlDlgNoShow);
	DDX_Control(pDX, IDC_STATIC_DEMARK, m_ctlStaticDemark);
	DDX_Text(pDX, IDC_EDIT_CATEGORIES, m_csCategories);
	DDX_Check(pDX, IDC_CHECK_NFODIALOG_NOSHOW, m_bDlgNoShow);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMSInfoDlg, CDialog)
	//{{AFX_MSG_MAP(CMSInfoDlg)
	ON_BN_CLICKED(IDC_OPTIONS, OnOptions)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMSInfoDlg message handlers

BOOL CMSInfoDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

    ShowOptions( m_bShow ); // false
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMSInfoDlg::OnOptions() 
{
	// TODO: Add your control notification handler code here

    ShowOptions( (m_bShow = !m_bShow) );
}

void CMSInfoDlg::ShowOptions(bool bShow)
{
    RECT    rtShowDlgCheckBox,
            rtDemark,
            rtDlg;

    (*this).GetWindowRect( &rtDlg );
    m_ctrlDlgNoShow.GetWindowRect( &rtShowDlgCheckBox );
    m_ctlStaticDemark.GetWindowRect( &rtDemark );

    if( bShow ) {

        rtDlg.bottom = rtShowDlgCheckBox.bottom + 12;
    }
    else {

        rtDlg.bottom = rtDemark.top;
    }

    (*this).MoveWindow( &rtDlg );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\msinfodlg.h ===
#if !defined(AFX_MSINFODLG_H__F21299A0_9CC6_48DF_8254_2827F19E4C6B__INCLUDED_)
#define AFX_MSINFODLG_H__F21299A0_9CC6_48DF_8254_2827F19E4C6B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MSInfoDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMSInfoDlg dialog

class CMSInfoDlg : public CDialog
{
// Construction
public:
	void ShowOptions( bool bShow );
	bool m_bShow;
	BSTR m_bstrCategories;
	CMSInfoDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMSInfoDlg)
	enum { IDD = IDD_DIALOG_NFO };
	CButton	m_ctrlDlgNoShow;
	CStatic	m_ctlStaticDemark;
	CString	m_csCategories;
	BOOL	m_bDlgNoShow;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMSInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMSInfoDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnOptions();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MSINFODLG_H__F21299A0_9CC6_48DF_8254_2827F19E4C6B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\propertiesdlg.cpp ===
// PropertiesDlg.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "PropertiesDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropertiesDlg dialog


CPropertiesDlg::CPropertiesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPropertiesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropertiesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPropertiesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropertiesDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropertiesDlg, CDialog)
	//{{AFX_MSG_MAP(CPropertiesDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropertiesDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\propertiesdlg.h ===
#if !defined(AFX_PROPERTIESDLG_H__2F58D8E6_413B_4EFF_B675_E228B8EF72FB__INCLUDED_)
#define AFX_PROPERTIESDLG_H__2F58D8E6_413B_4EFF_B675_E228B8EF72FB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropertiesDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropertiesDlg dialog

class CPropertiesDlg : public CDialog
{
// Construction
public:
	CPropertiesDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPropertiesDlg)
	enum { IDD = IDD_PROPERTIES_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertiesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPropertiesDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPERTIESDLG_H__2F58D8E6_413B_4EFF_B675_E228B8EF72FB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagedumpfiles.h ===
#if !defined(AFX_PROPPAGEDUMPFILES_H__DD1839DF_3482_4ED7_9D59_F529A1B190C4__INCLUDED_)
#define AFX_PROPPAGEDUMPFILES_H__DD1839DF_3482_4ED7_9D59_F529A1B190C4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropPageDumpFiles.h : header file
//

#include "genlistctrl.h"
#include "emsvc.h"	// Added by ClassView
#include "emshellview.h"

/////////////////////////////////////////////////////////////////////////////
// CPropPageDumpFiles dialog

class CPropPageDumpFiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPageDumpFiles)

// Construction
public:
	HRESULT DisplayDumpData(PEmObject pEmObject);
	void PopulateDumpType();
	IEmManager* m_pIEmManager;
	PEmObject m_pEmObject;
	CPropPageDumpFiles();
	~CPropPageDumpFiles();

// Dialog Data
	//{{AFX_DATA(CPropPageDumpFiles)
	enum { IDD = IDD_PROPPAGE_DUMPFILES };
	CGenListCtrl	m_ListCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageDumpFiles)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageDumpFiles)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonExport();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEDUMPFILES_H__DD1839DF_3482_4ED7_9D59_F529A1B190C4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagedumpfiles.cpp ===
// PropPageDumpFiles.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "PropPageDumpFiles.h"
#include <comdef.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPageDumpFiles property page

IMPLEMENT_DYNCREATE(CPropPageDumpFiles, CPropertyPage)

extern BSTR CopyBSTR( LPBYTE  pb, ULONG   cb );
extern PEmObject GetEmObj(BSTR bstrEmObj);

CPropPageDumpFiles::CPropPageDumpFiles() : CPropertyPage(CPropPageDumpFiles::IDD)
{
	//{{AFX_DATA_INIT(CPropPageDumpFiles)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPropPageDumpFiles::~CPropPageDumpFiles()
{
}

void CPropPageDumpFiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageDumpFiles)
	DDX_Control(pDX, IDC_LIST_DUMPFILES, m_ListCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageDumpFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageDumpFiles)
	ON_BN_CLICKED(IDC_BUTTON_EXPORT, OnButtonExport)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageDumpFiles message handlers

BOOL CPropPageDumpFiles::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	//Load the string resources for the CListCtrl columns
	CString strFileName, strSize, strTime;
	strFileName.LoadString(IDS_LC_FILENAME);
	strSize.LoadString(IDS_LC_FILESIZE);
	strTime.LoadString(IDS_LC_FILETIME);

	//Add the columns to the list control
	m_ListCtrl.BeginSetColumn(3);
	m_ListCtrl.AddColumn(strFileName);
	m_ListCtrl.AddColumn(strSize, VT_I4);
	m_ListCtrl.AddColumn(strTime);
	m_ListCtrl.EndSetColumn();
	
	//Populate the dump list control
	PopulateDumpType();

	m_ListCtrl.ResizeColumnsFitScreen();
	m_ListCtrl.SetExtendedStyle(LVS_EX_FULLROWSELECT);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPropPageDumpFiles::PopulateDumpType()
{
	_variant_t		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter       = NULL;
	EmObject		*pCurrentObj	= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ) );

	do {
		memcpy( &EmObjectFilter, m_pEmObject, sizeof( EmObject ) );
		EmObjectFilter.type = EMOBJ_MINIDUMP;
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		hr = m_pIEmManager->EnumObjectsEx(bstrEmObjectFilter, &var);

		if(FAILED(hr)) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if (pCurrentObj != NULL) {
				*pCurrentObj = *GetEmObj(bstrEmObj);
			}

            SysFreeString( bstrEmObj );

			//Unallocate the EmObject if it has an hr of E_FAIL
			if (FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject(pCurrentObj);
				continue;
			}

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayDumpData(pCurrentObj);
		}
	} while (FALSE);

    SafeArrayDestroyData(var.parray);
    SysFreeString( bstrEmObj );
	SysFreeString ( bstrEmObjectFilter );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

HRESULT CPropPageDumpFiles::DisplayDumpData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	CString	strFileSize;
	CString	strStartDate;
	LONG	lRow			=	0L;
	int		nImage			=	0;
	int nImageOffset		=	0;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		strFileSize.Format(_T("%d"), pEmObject->dwBucket1);
		strStartDate.Format(_T("%d"), pEmObject->dateStart);

        lRow = m_ListCtrl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		//Set the itemData
		m_ListCtrl.SetItemData(lRow, (ULONG_PTR) pEmObject);
		
		//Get the correct offset into the bitmap for the current status
//		nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

		//Call SetItem() with the index and image to show based on the state of pEmObject
		m_ListCtrl.SetItem(lRow, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

		lRow = m_ListCtrl.SetItemText(lRow, 1, strFileSize);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

        //
        // a-mando
        //
        if( pEmObject->dateStart != 0L ) {

            COleDateTime oleDtTm(pEmObject->dateStart);
    		strStartDate = oleDtTm.Format(_T("%c"));

            lRow = m_ListCtrl.SetItemText(lRow, 2, strStartDate);
	        if(lRow == -1L){
		        hr = E_FAIL;
		        break;
	        }
        }
        // a-mando

		hr = S_OK;
	}
	while( false );

	return hr;
}



void CPropPageDumpFiles::OnButtonExport() 
{
	PEmObject		pEmObject		= NULL;
	HRESULT			hr				= S_OK;
    CString         strDirPath;

    //Iterate through each element in the m_ListCtrl, getting it's pEmObject and calling ExportLog() on it.
	//Step through every item in the list control 
	int nCount = m_ListCtrl.GetItemCount();
    //Get the path
    if ( ( (CEmshellApp*) AfxGetApp() )->AskForPath( strDirPath ) ) {
	    for (int i = 0;i < nCount; i++) {
		    pEmObject = (PEmObject)m_ListCtrl.GetItemData(i);
		    
		    if (pEmObject == NULL) {
			    hr = E_FAIL;
			    break;
		    }

            //Export the file
            hr = ((CEmshellApp*)AfxGetApp())->ExportLog( pEmObject, strDirPath, m_pIEmManager );
        }
    }

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagegeneral.cpp ===
// PropPageGeneral.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "PropPageGeneral.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPageGeneral property page

IMPLEMENT_DYNCREATE(CPropPageGeneral, CPropertyPage)

CPropPageGeneral::CPropPageGeneral() : CPropertyPage(CPropPageGeneral::IDD)
{
	//{{AFX_DATA_INIT(CPropPageGeneral)
	m_strdwBucket1 = _T("");
	m_strName = _T("");
	m_strszBucket1 = _T("");
	m_strGUID = _T("");
	m_strHR = _T("");
	m_strPID = _T("");
	m_strType = _T("");
	m_strEndDate = _T("");
	m_strStartDate = _T("");
	m_strStatus = _T("");
	//}}AFX_DATA_INIT
}

CPropPageGeneral::~CPropPageGeneral()
{
}

void CPropPageGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageGeneral)
	DDX_Control(pDX, IDC_STATIC_HRLABEL, m_ctrlHRLabel);
	DDX_Control(pDX, IDC_STATIC_SZBUCKET1LABEL, m_ctrlszBucket1Label);
	DDX_Control(pDX, IDC_STATIC_DWBUCKET1LABEL, m_ctrldwBucket1Label);
	DDX_Control(pDX, IDC_STATIC_GUIDLABEL, m_ctrlGUIDLabel);
	DDX_Text(pDX, IDC_STATIC_DWBUCKET1VAL, m_strdwBucket1);
	DDX_Text(pDX, IDC_STATIC_NAMEVAL, m_strName);
	DDX_Text(pDX, IDC_STATIC_SZBUCKET1VAL, m_strszBucket1);
	DDX_Text(pDX, IDC_STATIC_GUIDVAL, m_strGUID);
	DDX_Text(pDX, IDC_STATIC_HRVAL, m_strHR);
	DDX_Text(pDX, IDC_STATIC_PIDVAL, m_strPID);
	DDX_Text(pDX, IDC_STATIC_TYPEVAL, m_strType);
	DDX_Text(pDX, IDC_STATIC_ENDDATEVAL, m_strEndDate);
	DDX_Text(pDX, IDC_STATIC_STARTDATEVAL, m_strStartDate);
	DDX_Text(pDX, IDC_STATIC_STATUSVAL, m_strStatus);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageGeneral, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageGeneral)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageGeneral message handlers

BOOL CPropPageGeneral::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	COleDateTime startDate((DATE)m_pEmObject->dateStart);
	COleDateTime endDate((DATE)m_pEmObject->dateEnd);

	// TODO: Add extra initialization here
	m_strEndDate = endDate.Format(L"%c");
	m_strStartDate = startDate.Format(L"%c");
	m_strPID.Format(L"%d", m_pEmObject->nId);

	//Display status string
	((CEmshellApp*)AfxGetApp())->GetStatusString(m_pEmObject->nStatus, m_strStatus);
	m_strName = m_pEmObject->szName;

	//Map the process type to a string and populate
	((CEmshellApp*)AfxGetApp())->GetEmObjectTypeString(m_pEmObject->type, m_strType);

#ifdef _DEBUG
    const       cchMax = 128;
    TCHAR       szGuid[cchMax + 1];
    GUID        guid = *((GUID*) m_pEmObject->guidstream);
    StringFromGUID2 ( guid, szGuid, cchMax );
	m_strGUID.Format(L"%s", szGuid);
	m_strszBucket1.Format(L"%s", m_pEmObject->szBucket1);
	m_strdwBucket1.Format(L"%d", m_pEmObject->dwBucket1);
	m_strHR.Format(L"0x%x", m_pEmObject->hr);
#endif

#ifndef _DEBUG
	//Set unwanted string text to null
	m_ctrlszBucket1Label.SetWindowText(_T(""));
	m_ctrlGUIDLabel.SetWindowText(_T(""));
	m_ctrldwBucket1Label.SetWindowText(_T(""));
	m_ctrlHRLabel.SetWindowText(_T(""));
#endif

	UpdateData(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagegeneral.h ===
#if !defined(AFX_PROPPAGEGENERAL_H__617991BA_50EF_4DA1_8BAE_0A593EA0BE73__INCLUDED_)
#define AFX_PROPPAGEGENERAL_H__617991BA_50EF_4DA1_8BAE_0A593EA0BE73__INCLUDED_

#include "emsvc.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropPageGeneral.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropPageGeneral dialog

class CPropPageGeneral : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPageGeneral)

// Construction
public:
	PEmObject m_pEmObject;
	CPropPageGeneral();
	~CPropPageGeneral();

// Dialog Data
	//{{AFX_DATA(CPropPageGeneral)
	enum { IDD = IDD_PROPPAGE_GENERAL };
	CStatic	m_ctrlHRLabel;
	CStatic	m_ctrlszBucket1Label;
	CStatic	m_ctrldwBucket1Label;
	CStatic	m_ctrlGUIDLabel;
	CString	m_strdwBucket1;
	CString	m_strName;
	CString	m_strszBucket1;
	CString	m_strGUID;
	CString	m_strHR;
	CString	m_strPID;
	CString	m_strType;
	CString	m_strEndDate;
	CString	m_strStartDate;
	CString	m_strStatus;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageGeneral)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEGENERAL_H__617991BA_50EF_4DA1_8BAE_0A593EA0BE73__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagegenlogdump.cpp ===
// PropPageGenLogDump.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "PropPageGenLogDump.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPageGenLogDump property page

IMPLEMENT_DYNCREATE(CPropPageGenLogDump, CPropertyPage)

CPropPageGenLogDump::CPropPageGenLogDump() : CPropertyPage(CPropPageGenLogDump::IDD)
{
	//{{AFX_DATA_INIT(CPropPageGenLogDump)
	m_csDateTime = _T("");
	m_csDirectory = _T("");
	m_csFileSize = _T("");
	m_csFileName = _T("");
	//}}AFX_DATA_INIT

    m_pEmObj = NULL;
    m_bDeleteFile = FALSE;
    m_pParentPropSheet = NULL;
}

CPropPageGenLogDump::~CPropPageGenLogDump()
{
}

void CPropPageGenLogDump::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageGenLogDump)
	DDX_Text(pDX, IDC_EDIT_DATETIME, m_csDateTime);
	DDX_Text(pDX, IDC_EDIT_DIRECTORY, m_csDirectory);
	DDX_Text(pDX, IDC_EDIT_FILE_SIZE, m_csFileSize);
	DDX_Text(pDX, IDC_EDIT_FILENAME, m_csFileName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageGenLogDump, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageGenLogDump)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageGenLogDump message handlers

BOOL CPropPageGenLogDump::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	// TODO: Add extra initialization here

    //
    // a-mando
    //
    if( m_pEmObj ) {

        m_csFileName = m_pEmObj->szName;
        m_csDirectory = m_pEmObj->szSecName;

        if( m_pEmObj->dateStart ) {

            COleDateTime oleDtTm(m_pEmObj->dateStart);
            m_csDateTime = oleDtTm.Format(_T("%c"));
        }

        m_csFileSize.Format(_T("%d"), m_pEmObj->dwBucket1);

        UpdateData(FALSE);
    }
    // a-mando

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPropPageGenLogDump::OnDelete() 
{
	// TODO: Add your control notification handler code here
    m_bDeleteFile = TRUE;

    if( m_pParentPropSheet ) {

        m_pParentPropSheet->EndDialog(IDOK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagegenlogdump.h ===
#if !defined(AFX_PROPPAGEGENLOGDUMP_H__ED4C551D_178C_4DCB_92C1_21F0F18B8B37__INCLUDED_)
#define AFX_PROPPAGEGENLOGDUMP_H__ED4C551D_178C_4DCB_92C1_21F0F18B8B37__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropPageGenLogDump.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropPageGenLogDump dialog

class CPropPageGenLogDump : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPageGenLogDump)

// Construction
public:
	CPropPageGenLogDump();
	~CPropPageGenLogDump();

// Dialog Data
	//{{AFX_DATA(CPropPageGenLogDump)
	enum { IDD = IDD_PROPPAGE_GENLOGDUMP };
	CString	m_csDateTime;
	CString	m_csDirectory;
	CString	m_csFileSize;
	CString	m_csFileName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageGenLogDump)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageGenLogDump)
	virtual BOOL OnInitDialog();
	afx_msg void OnDelete();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CPropertySheet * m_pParentPropSheet;
    PEmObject   m_pEmObj;
    BOOL        m_bDeleteFile;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGEGENLOGDUMP_H__ED4C551D_178C_4DCB_92C1_21F0F18B8B37__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagelogfiles.h ===
#if !defined(AFX_PROPPAGELOGFILES_H__18F14285_FBAB_4BE1_8249_4B7EF63794F0__INCLUDED_)
#define AFX_PROPPAGELOGFILES_H__18F14285_FBAB_4BE1_8249_4B7EF63794F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropPageLogFiles.h : header file
//

#include "genlistctrl.h"
#include "emsvc.h"	// Added by ClassView
/////////////////////////////////////////////////////////////////////////////
// CPropPageLogFiles dialog

class CPropPageLogFiles : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropPageLogFiles)

// Construction
public:
	PEmObject GetSelectedEmObject();
	void DoModalReadLogsDlg(PEmObject pEmObject);
	HRESULT DisplayLogData(PEmObject pEmObject);
	void PopulateLogType();
	IEmManager* m_pIEmManager;
	PEmObject m_pEmObject;
	CPropPageLogFiles();
	~CPropPageLogFiles();

// Dialog Data
	//{{AFX_DATA(CPropPageLogFiles)
	enum { IDD = IDD_PROPPAGE_LOGFILES };
	CGenListCtrl	m_ListCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPropPageLogFiles)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPropPageLogFiles)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkListLogfiles(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnButtonExport();
	afx_msg void OnButtonViewlogfile();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGELOGFILES_H__18F14285_FBAB_4BE1_8249_4B7EF63794F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\readlogsdlg.h ===
#if !defined(AFX_READLOGSDLG_H__FB51DB88_CAC0_491B_B24F_25E5FCAACEC4__INCLUDED_)
#define AFX_READLOGSDLG_H__FB51DB88_CAC0_491B_B24F_25E5FCAACEC4__INCLUDED_

#include "emsvc.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ReadLogsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CReadLogsDlg dialog

typedef enum ReadLogType {
    ReadLogsType_None,
    ReadLogsType_Exception,
    ReadLogsType_Hang
};

class CReadLogsDlg : public CDialog
{
// Construction
public:
    void ShowAppropriateControls();
    void GetFirstParameter( char* szBuffer, CString &str );
    void GetSecondParameter( char* szBuffer, CString &str );
    void GetThirdParameter( char* szBuffer, CString &str );
    char* GetThreadNumber( char* szBuffer );
    char* GetThreadID( char* szBuffer );
	void ProcessKvThreadBlocks();
	CMapStringToString m_mapCriticalSection;
	CMapStringToString m_mapThreadID;
	void BuildThreadIDMap();
	void BuildCriticalSectionsMap();
	CString m_pTempLogFileName;
	void ParseAndInitExceptionView();
	void ParseAndInitHangView();
	void ParseAndInitNoneView();
	~CReadLogsDlg();
    BOOL    m_bAdvancedWindow;
	void SetDialogSize(BOOL);
	PEmObject m_pEmObject;
	IEmManager* m_pIEmManager;
    IStream*    m_pIEmStream;
    ReadLogType m_eReadLogType;
	CReadLogsDlg(PEmObject pEmObj, IEmManager *pEmMgr, CWnd* pParent = NULL);   // standard constructor
    void ResizeAndReposControl();

// Dialog Data
	//{{AFX_DATA(CReadLogsDlg)
	enum { IDD = IDD_READLOGS };
	CStatic	m_ctlStaticExcepInfo;
	CStatic	m_staticHangInfo;
	CStatic	m_ctlStaticFailingInstruction;
	CStatic	m_ctlStaticExceptionLocation;
	CStatic	m_ctlStaticExceptionType;
	CStatic	m_ctlStaticCallStack;
	CEdit	m_ctlEditFailingInstruction;
	CEdit	m_ctlEditExceptionType;
	CEdit	m_ctlEditExceptionLocation;
	CListBox	m_ctlListControl;
	CButton	m_ctrlAdvancedBtn;
	CEdit	m_ctrlCompleteReadLog;
	CString	m_csCompleteLog;
	CString	m_strExceptionType;
	CString	m_strExceptionLocation;
	CString	m_strFailingInstruction;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReadLogsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	FILE* m_pLogFile;

	// Generated message map functions
	//{{AFX_MSG(CReadLogsDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnAdvanced();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_READLOGSDLG_H__FB51DB88_CAC0_491B_B24F_25E5FCAACEC4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\readlogsdlg.cpp ===
// ReadLogsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "ReadLogsDlg.h"
#include "EmShell.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern BSTR CopyBSTR( LPBYTE  pb, ULONG   cb );

const char*     gslCarriageReturn           = "\r";
const TCHAR*    gtcFileOpenFlags            = _T("w+b");
const TCHAR*    gtcTempFilenameSeed         = _T("ems");
const char*     gslFirstChance              = "first chance";
const char*     gslCode                     = " - code";
const char*     gslKV                       = "> kv";
const char*     gslChildEBP                 = "ChildEBP";
const char*     gslPrompt                   = ">";
const char*     gslUEIP                     = "> u eip";
const char*     gslSemiColon                = ":";
const char*     gslReadLogsAV               = "READLOGS_AV";
const char*     gslReadLogsDB               = "READLOGS_DB";
const char*     gslTildaStarKV              = "~*kv";
const char*     gslBangLocks                = "!locks";
const char*     gslIDColon                  = "id: ";
const char*     gslCritSecText              = "CritSec ";
const char      gslSpace                    = ' ';
const char*     gslOwningThread             = "OwningThread";
const char*     gslPeriod                   = ".";
const char*     gslWaitForSingleObject      = "WaitForSingleObject";
const char*     gslWaitForMultipleObjects   = "WaitForMultipleObjects";
const char*     gslWaitForCriticalSection   = "WaitForCriticalSection";

/////////////////////////////////////////////////////////////////////////////
// CReadLogsDlg dialog


CReadLogsDlg::CReadLogsDlg(PEmObject pEmObj, IEmManager *pEmMgr, CWnd* pParent /*=NULL*/)
	: CDialog(CReadLogsDlg::IDD, pParent)
{
    _ASSERTE( pEmObj != NULL );
    _ASSERTE( pEmMgr != NULL );

    m_pEmObject         = pEmObj;
    m_pIEmManager       = pEmMgr;
    m_bAdvancedWindow   = FALSE;
    m_pLogFile          = NULL;

	//{{AFX_DATA_INIT(CReadLogsDlg)
	m_csCompleteLog = _T("");
	m_strExceptionType = _T("");
	m_strExceptionLocation = _T("");
	m_strFailingInstruction = _T("");
	//}}AFX_DATA_INIT
}


void CReadLogsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReadLogsDlg)
	DDX_Control(pDX, IDC_STATIC_EXCEPINFO, m_ctlStaticExcepInfo);
	DDX_Control(pDX, IDC_STATIC_HANGINFO, m_staticHangInfo);
	DDX_Control(pDX, IDC_STATIC_FAILING_INSTRUCTION, m_ctlStaticFailingInstruction);
	DDX_Control(pDX, IDC_STATIC_EXCEPTION_LOCATION, m_ctlStaticExceptionLocation);
	DDX_Control(pDX, IDC_STATIC_EXCEPTION_TYPE, m_ctlStaticExceptionType);
	DDX_Control(pDX, IDC_STATIC_CALL_STACK, m_ctlStaticCallStack);
	DDX_Control(pDX, IDC_EDIT_FAILING_INSTRUCTION, m_ctlEditFailingInstruction);
	DDX_Control(pDX, IDC_EDIT_EXCEPTION_TYPE, m_ctlEditExceptionType);
	DDX_Control(pDX, IDC_EDIT_EXCEPTION_LOCATION, m_ctlEditExceptionLocation);
	DDX_Control(pDX, IDC_LIST_CALL_STACK, m_ctlListControl);
	DDX_Control(pDX, IDC_ADVANCED, m_ctrlAdvancedBtn);
	DDX_Control(pDX, IDC_EDIT_READLOGS, m_ctrlCompleteReadLog);
	DDX_Text(pDX, IDC_EDIT_READLOGS, m_csCompleteLog);
	DDX_Text(pDX, IDC_EDIT_EXCEPTION_TYPE, m_strExceptionType);
	DDX_Text(pDX, IDC_EDIT_EXCEPTION_LOCATION, m_strExceptionLocation);
	DDX_Text(pDX, IDC_EDIT_FAILING_INSTRUCTION, m_strFailingInstruction);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReadLogsDlg, CDialog)
	//{{AFX_MSG_MAP(CReadLogsDlg)
	ON_BN_CLICKED(IDC_ADVANCED, OnAdvanced)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReadLogsDlg message handlers

BOOL CReadLogsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

    HRESULT hr                                  = E_FAIL;
    ULONG   lRead                               = 0L;
    size_t  tWritten                            = 0;
    BSTR    bstrEmObj                           = NULL;
    TCHAR   szTempDirPath[MAX_PATH]             = {0};
    TCHAR   szTempFileName[MAX_PATH]            = {0};
    char    lpszLogData[ISTREAM_BUFFER_SIZE];

    do {
        CWaitCursor wait;
        
        if( !m_pEmObject || !m_pIEmManager ) break;

        bstrEmObj = CopyBSTR( (LPBYTE) m_pEmObject, sizeof EmObject );

        //Load the read logs stream from the manager
        hr = m_pIEmManager->GetEmFileInterface( bstrEmObj, (IStream **)&m_pIEmStream );
        if( FAILED(hr) ) break;

        SysFreeString( bstrEmObj ); 

        //Get the temporary system path
        if ( 0 == GetTempPath( MAX_PATH, szTempDirPath ) ) break;

        //Create a temp filename
        GetTempFileName( szTempDirPath, gtcTempFilenameSeed, 0, szTempFileName);

        m_pTempLogFileName = szTempFileName;

        //Create a temp file in the system temp directory
        m_pLogFile = _tfopen( m_pTempLogFileName, gtcFileOpenFlags );
        if ( m_pLogFile == NULL ) break;

        //Check the second line, if it's not either READLOGS_AV OR READLOGS_DB, cancel
        for (int i = 1; i < 2; i++) {

            hr = m_pIEmStream->Read( (void *)lpszLogData, ISTREAM_BUFFER_SIZE, &lRead );
            if ( lRead == 0 || FAILED( hr ) ) break;
        
            m_csCompleteLog += lpszLogData;

            tWritten = fwrite( lpszLogData, sizeof( char ), lRead, m_pLogFile );
            if ( tWritten == 0 ) {
                hr = E_FAIL;
                break;
            }
            
            if ( i == 1) {

                //Check to see which version of the dlg we should be showing
                if ( strstr( lpszLogData, gslReadLogsAV ) )
                    m_eReadLogType = ReadLogsType_Exception;
                else if ( strstr( lpszLogData, gslReadLogsDB ) )
                    m_eReadLogType = ReadLogsType_Hang;
                else
                    m_eReadLogType = ReadLogsType_None;

            }
        } while ( FALSE );

        if ( FAILED( hr) ) break;

        //Continue to read the log into the temp file
        do {
        
            hr = m_pIEmStream->Read( (void *)lpszLogData, ISTREAM_BUFFER_SIZE, &lRead );
            if ( lRead == 0 || FAILED( hr ) ) break;
        
            m_csCompleteLog += lpszLogData;

            tWritten = fwrite( lpszLogData, sizeof( char ), lRead, m_pLogFile );
            if ( tWritten == 0 ) {
                hr = E_FAIL;
                break;
            }

        } while (TRUE);

        if ( FAILED( hr ) ) break;

        //Flush the data to the file.
        fflush( m_pLogFile );

        switch ( m_eReadLogType ) {
        case ReadLogsType_Exception:
            ParseAndInitExceptionView();
            break;
        case ReadLogsType_Hang:
            ParseAndInitHangView();
            break;
        case ReadLogsType_None:
            ParseAndInitNoneView();
            break;
        default:
            break;
        }
        
        UpdateData(FALSE);
    } while ( FALSE );

    SysFreeString( bstrEmObj ); 

	if (m_pIEmStream) m_pIEmStream->Release();

    //
    // a-mando
    //
    ShowAppropriateControls();
    ResizeAndReposControl();
    // a-mando

    SetDialogSize(FALSE);

    if( FAILED(hr) ) { 
		//Show msg box
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
		return FALSE; 
	}

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CReadLogsDlg::SetDialogSize(BOOL bAdvanced)
{
    CRect   rtCompleteLog,
            rtDlg;

    GetWindowRect( &rtDlg );
    m_ctrlCompleteReadLog.GetWindowRect( &rtCompleteLog );

    rtDlg.bottom = rtCompleteLog.top;

    if( bAdvanced ) {

        rtDlg.bottom = rtCompleteLog.bottom + DLG_PIXEL_EXTEND_SIZE;
        m_ctrlCompleteReadLog.ShowWindow(SW_SHOW);
    }

    MoveWindow(rtDlg);
}

void CReadLogsDlg::OnAdvanced() 
{
    CString csTemp;

	// TODO: Add your control notification handler code here

    if( !m_bAdvancedWindow )
    {
        SetDialogSize( TRUE );
        m_bAdvancedWindow = TRUE;

        csTemp.LoadString( IDS_READLOGS_ADVOPEN );
        m_ctrlAdvancedBtn.SetWindowText( csTemp );
    }
    else
    {
        SetDialogSize(FALSE);
        m_bAdvancedWindow = FALSE;

        csTemp.LoadString( IDS_READLOGS_ADVCLOSE );
        m_ctrlAdvancedBtn.SetWindowText( csTemp );
    }
}

CReadLogsDlg::~CReadLogsDlg()
{
    POSITION pos = NULL; 
    CString key;
    CString* pVal = NULL;

    ASSERT( m_pLogFile == NULL );

}

void CReadLogsDlg::ParseAndInitHangView()
{
    //Show the controls for this view
    //Hide the controls for this view

    //Build map of critical sections
    BuildCriticalSectionsMap();

    //Build map of thread ID's
    BuildThreadIDMap();

    //Set the file cursor to the beginning of the logfile
    ProcessKvThreadBlocks();
}

//
// a-mando
//
void CReadLogsDlg::ShowAppropriateControls()
{
    //Enable the controls based on what view is selected
    switch ( m_eReadLogType ) {
    case ReadLogsType_None:
    case ReadLogsType_Exception:
        m_ctlStaticExcepInfo.ShowWindow(SW_SHOW);
        m_staticHangInfo.ShowWindow(SW_HIDE);
	    m_ctlStaticFailingInstruction.ShowWindow(SW_SHOW);
	    m_ctlStaticExceptionLocation.ShowWindow(SW_SHOW);
	    m_ctlStaticExceptionType.ShowWindow(SW_SHOW);
	    m_ctlStaticCallStack.ShowWindow(SW_SHOW);
	    m_ctlEditFailingInstruction.ShowWindow(SW_SHOW);
	    m_ctlEditExceptionType.ShowWindow(SW_SHOW);
	    m_ctlEditExceptionLocation.ShowWindow(SW_SHOW);
	    m_ctlListControl.ShowWindow(SW_SHOW);
        break;
    case ReadLogsType_Hang:
        m_staticHangInfo.ShowWindow(SW_SHOW);
        //Disable all the controls except for the m_ctlHangListControl
        break;
    }
}
// a-mando

void CReadLogsDlg::ParseAndInitNoneView()
{
    //Show the controls for this view
    //Hide the controls for this view

}

void CReadLogsDlg::ParseAndInitExceptionView()
{
    char    szBuffer[MAX_TEMP_BUFFER_SIZE]      = {0};
    TCHAR   szTmpBuffer[MAX_TEMP_BUFFER_SIZE]   = {0};
    char*   pszOffset                           = NULL;
    long    lLastLineOffset                     = 0L;
    char    szException[MAX_TEMP_BUFFER_SIZE]   = {0};
    BOOL    bFound                              = FALSE;

    //Show the controls for this view
    //Hide the controls for this view

    do {
        //Set the file cursor to the beginning of the logfile
        fseek( m_pLogFile, 0, SEEK_SET );

        do {

            //Search through each line looking for the "(first chance)" text
            pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
            if ( pszOffset == NULL ) break;

            pszOffset = strstr( szBuffer, gslFirstChance );
            if ( pszOffset == 0 ) continue;

            //Get the current byte offset.  Note this is the next line, not the first chance line
            lLastLineOffset = ftell( m_pLogFile );
            if ( lLastLineOffset == -1L ) break;

            //Store off the line just matched
            strcpy( szException, szBuffer );
        
            bFound = TRUE;

        } while ( TRUE );

        if ( !bFound ) break;

        //Parse the szException for the readable exception text
        //Get the position of the word "code", and then only get the string up to that point
        pszOffset = strstr( szException, gslCode );

	if ( pszOffset != NULL ) //a-kjaw, bug ID: 296028
            *pszOffset = '\0'; 

        //Store off szException to the dialog control
        m_strExceptionType = szException;

        bFound = FALSE;     //Reset

        //Handle ~KV
        //Set the file pointer back to the last exception position or break if there is a problem
        do {
            if ( fseek( m_pLogFile, lLastLineOffset, SEEK_SET ) ) break;

            do {

                //Search through each line looking for the "> kv" text
                pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszOffset == NULL ) break;

                pszOffset = strstr( szBuffer, gslKV );
                if ( pszOffset == 0 ) continue;

                bFound = TRUE;

                break;

            } while ( TRUE );
        
            if ( !bFound ) break;

            bFound = FALSE;     //Reset

            do {

                //Search through each line looking for the "ChildEBP" text
                pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszOffset == NULL ) break;

                pszOffset = strstr( szBuffer, gslChildEBP );
                if ( pszOffset == 0 ) continue;

                bFound = TRUE;

                break;

            } while ( TRUE );

            if ( !bFound ) break;
        
            bFound = FALSE;     //Reset

            do {

                //Search through each line getting the call stack strings and 
                //populating the list control with them
                pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszOffset == NULL ) break;

                pszOffset = strstr( szBuffer, gslPrompt );
                if ( pszOffset != 0 ) break;

                pszOffset = strstr( szBuffer, gslCarriageReturn );
                *pszOffset = 0;

                //Get the string from offset 45 on and insert into list control
                mbstowcs( szTmpBuffer, szBuffer + sizeof( char[45] ), MAX_TEMP_BUFFER_SIZE );
                
                m_ctlListControl.AddString( szTmpBuffer );

            } while ( TRUE );

        } while ( FALSE );
        
        //Handle u eip
        do {

            if ( fseek( m_pLogFile, lLastLineOffset, SEEK_SET ) ) break;

            do {

                //Search through each line looking for the "> u eip" text
                pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszOffset == NULL ) break;

                pszOffset = strstr( szBuffer, gslUEIP );
                if ( pszOffset == 0 ) continue;

                bFound = TRUE;

                break;

            } while ( TRUE );
        
            if ( !bFound ) break;

            bFound = FALSE;     //Reset

            //Get the first item in the list control
            m_ctlListControl.GetText( 0, m_strExceptionLocation );

            do {

                //Get the immediate next line and stuff it into the failing instruction 
                pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszOffset == NULL ) break;

                //If the line has a semicolon, skip it. 
                pszOffset = strstr( szBuffer, gslSemiColon );
                if ( pszOffset != NULL ) {
                    pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                }

                pszOffset = strstr( szBuffer, gslCarriageReturn );
                *pszOffset = 0;

                m_strFailingInstruction = szBuffer + sizeof( char[26] );
                
                bFound = TRUE;

                break;

            } while ( TRUE );

        } while ( FALSE );

    } while ( FALSE );

    if ( !bFound ) {

        //We didn't find an exception, error to the user
    }
}

void CReadLogsDlg::OnDestroy() 
{
	CDialog::OnDestroy();
	
	// TODO: Add your message handler code here
	//Release the handle to the file
    if ( m_pLogFile ) {

        fclose( m_pLogFile );
        m_pLogFile = NULL;
        DeleteFile( m_pTempLogFileName );
    }
}


void CReadLogsDlg::BuildCriticalSectionsMap()
{
    BOOL    bFound                              = FALSE;
    char    *pszOffset                          = NULL;
    char    *pszTempOffset                      = NULL;
    char    szBuffer[MAX_TEMP_BUFFER_SIZE]      = {0};
    CString csAddress;
    CString *pcsOwningThread    = NULL;
    
    do {
        //Set the file cursor to the beginning of the logfile
        fseek( m_pLogFile, 0, SEEK_SET );

        do {

            //Search through each line looking for the "!Locks" command
            pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
            if ( pszOffset == NULL ) break;

            pszOffset = strstr( szBuffer, gslBangLocks );
            if ( pszOffset == NULL ) continue;

            bFound = TRUE;
            break;
        } while ( TRUE );

        if ( !bFound ) break;
        bFound = FALSE;

        //We're now at the !Locks area of the log file
        do {

            //We are now poised to extract the critical section address and the internal thread ID
            do {

                //Search through the block looking for the "CritSec" text or the "> " prompt
                pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszOffset == NULL ) break;

                pszOffset = strstr( szBuffer, gslCritSecText );

                //If "CritSec" is not in the string, look for the prompt
                if ( pszOffset == NULL ) {
                
                    pszOffset = strstr( szBuffer, gslPrompt );
                
                    //If the prompt is not in the string, continue
                    if ( pszOffset == NULL ) {
                        continue;
                    }
                    else break;
                }

                pszOffset = strstr( szBuffer, gslCarriageReturn );
		if( pszOffset != NULL ) // a-mando, bug ID: 296029
                    *pszOffset = '\0';

                //We have a "CritSec", get the address from the right most edge
                pszOffset = strrchr( szBuffer, gslSpace );
                if ( pszOffset == NULL ) break;

                csAddress = pszOffset + 1;

                csAddress.MakeLower();

                bFound = TRUE;
                break;
            } while ( TRUE );

            if ( !bFound ) break;
            bFound = FALSE;
        
            do {

                //Search through the block looking for the "OwningThread" text or the "> " prompt
                pszOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszOffset == NULL ) break;

                pszOffset = strstr( szBuffer, gslOwningThread );

                //If "OwningThread" is not in the string, look for the prompt
                if ( pszOffset == NULL ) {
                
                    pszOffset = strstr( szBuffer, gslPrompt );
                
                    //If the prompt is not in the string, continue
                    if ( pszOffset == NULL ) {
                        continue;
                    }
                    else break;
                }

                //We have an "OwningThread", get the internal thread ID from the right most edge
                pszOffset = strrchr( szBuffer, gslSpace );
                if ( pszOffset == NULL ) break;

                pszTempOffset = strstr( pszOffset, gslCarriageReturn );
                if ( pszTempOffset != NULL ) *pszTempOffset = '\0';

                CString pcsOwningThread = pszOffset + 1 ;

                //Add the address and owning thread to the critical section map
                m_mapCriticalSection.SetAt( csAddress, (CString&) pcsOwningThread );

                bFound = TRUE;
                break;
            } while ( TRUE );

            if ( !bFound ) break;
            bFound = FALSE;
        
        } while ( TRUE );

        if ( !bFound ) break;
        bFound = FALSE;

    } while ( FALSE );
}

void CReadLogsDlg::BuildThreadIDMap()
{
    BOOL    bFound                              = FALSE;
    char    *pszStartOffset                     = NULL;
    char    *pszEndOffset                       = NULL;
    char    szBuffer[MAX_TEMP_BUFFER_SIZE]      = {0};
    CString* pcsThreadVal                       = NULL;
    CString csThreadKey;

    do {
        //Set the file cursor to the beginning of the logfile
        fseek( m_pLogFile, 0, SEEK_SET );

        do {

            //Search through each line looking for the "~*kv" command
            pszStartOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
            if ( pszStartOffset == NULL ) break;

            pszStartOffset = strstr( szBuffer, gslTildaStarKV );
            if ( pszStartOffset == NULL ) continue;

            bFound = TRUE;
            break;
        } while ( TRUE );

        if ( !bFound ) break;
        bFound = FALSE;

        //We're now at the ~*kv area of the log file
        do {

            //We are now poised to extract the critical section address and the internal thread ID
            do {

                //Search through the block looking for the "id: " text or the "> " prompt
                pszStartOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszStartOffset == NULL ) break;

                pszStartOffset = strstr( szBuffer, gslIDColon );

                //If "id: " is not in the string, look for the prompt
                if ( pszStartOffset == NULL ) {
                
                    pszStartOffset = strstr( szBuffer, gslPrompt );
                
                    //If the prompt is not in the string, continue
                    if ( pszStartOffset == NULL ) {
                        continue;
                    }
                    else break;
                }

                //We have an "id: ", get the internal thread ID and ordered thread ID
                CString pcsThreadVal = GetThreadID( szBuffer );

                csThreadKey = GetThreadNumber( szBuffer );
                
                csThreadKey.MakeLower();

                m_mapThreadID.SetAt( csThreadKey, (CString&) pcsThreadVal );

                bFound = TRUE;
                break;
            } while ( TRUE );

            if ( !bFound ) break;
            bFound = FALSE;
        
        } while ( TRUE );

        if ( !bFound ) break;
        bFound = FALSE;

    }while ( FALSE );

}

char* CReadLogsDlg::GetThreadID( char* szBuffer )
{
    char    *pszStartOffset                     = NULL;
    char    *pszEndOffset                       = NULL;

    do {
        pszStartOffset = strstr( szBuffer, gslPeriod );
        if ( pszStartOffset == NULL ) break;

        if ( pszStartOffset == szBuffer ) {
            szBuffer++;
            continue;
        }

        pszStartOffset++;

        //increment 1 past the period we're sitting on.  Unless it's the first one we're encountering
        pszEndOffset = strchr( pszStartOffset, gslSpace );
        if ( pszEndOffset == NULL ) break;
        *pszEndOffset = '\0';

        break;
    } while ( TRUE );

    return pszStartOffset;
}

char* CReadLogsDlg::GetThreadNumber( char* szBuffer )
{
    char    *pszStartOffset                     = NULL;
    char    *pszEndOffset                       = NULL;

    //Look for the first occurance of a numeric number
    pszStartOffset = szBuffer;
    for ( ; (!isdigit( *pszStartOffset ) || *pszStartOffset == '.') && *pszStartOffset != '\0';  ) {
        pszStartOffset++;
    }
    pszEndOffset = strchr( pszStartOffset, gslSpace );
    *pszEndOffset = '\0';

    return pszStartOffset;
}

void CReadLogsDlg::GetFirstParameter( char* szBuffer, CString &str ) 
{
    char* token = NULL;

    //Tokenize the buffer and get the 3rd token and set to str
    token =  strtok( szBuffer, &gslSpace );

   for ( int i = 1; i < 3 && token != NULL; i++)
   {
      /* Get next token: */
      token = strtok( NULL, &gslSpace );
   }

   str = token;
}

void CReadLogsDlg::GetSecondParameter( char* szBuffer, CString &str ) 
{
    char* token = NULL;

    //Tokenize the buffer and get the 3rd token and set to str
    token =  strtok( szBuffer, &gslSpace );

   for ( int i = 1; i < 4 && token != NULL; i++)
   {
      /* Get next token: */
      token = strtok( NULL, &gslSpace );
   }

   str = token;
}

void CReadLogsDlg::GetThirdParameter( char* szBuffer, CString &str ) 
{
    char* token = NULL;

    //Tokenize the buffer and get the 3rd token and set to str
    token =  strtok( szBuffer, &gslSpace );

   for ( int i = 1; i < 5 && token != NULL; i++)
   {
      /* Get next token: */
      token = strtok( NULL, &gslSpace );
   }

   str = token;
}

void CReadLogsDlg::ProcessKvThreadBlocks()
{
    BOOL    bFound                              = FALSE;
    char    *pszStartOffset                     = NULL;
    char    *pszEndOffset                       = NULL;
    char    szBuffer[MAX_TEMP_BUFFER_SIZE]      = {0};
    char    szOriginalBuffer[MAX_TEMP_BUFFER_SIZE]      = {0};
    CString csThreadID;
    CString csThreadNumber;
    CString csOutput;
    CString csFirstParameter;
    CString csSecondParameter;
    CString csThirdParameter;
    CString csOwningThread;

    do {
        //Set the file cursor to the beginning of the logfile
        fseek( m_pLogFile, 0, SEEK_SET );

        do {

            //Search through each line looking for the "~*kv" command
            pszStartOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
            if ( pszStartOffset == NULL ) break;
            
            pszStartOffset = strstr( szBuffer, gslTildaStarKV );
            if ( pszStartOffset == NULL ) continue;

            bFound = TRUE;
            break;
        } while ( TRUE );

        if ( !bFound ) break;
        bFound = FALSE;

        //We're now at the ~*kv area of the log file
        do {

            //We are now poised to handle determining output string for thread states
            do {
                
                //Search through the block looking for the "id: " text or the "> " prompt
                pszStartOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszStartOffset == NULL ) break;

                //Let's keep a copy of the original around
                strcpy( szOriginalBuffer, szBuffer );

                pszStartOffset = strstr( szBuffer, gslIDColon );

                //If "id: " is not in the string, look for the prompt
                if ( pszStartOffset == NULL ) {
                
                    pszStartOffset = strstr( szBuffer, gslPrompt );
                
                    //If the prompt is not in the string, continue
                    if ( pszStartOffset == NULL ) {
                        continue;
                    }
                    else break;
                }

                csThreadNumber = GetThreadNumber( szBuffer );
                strcpy( szBuffer, szOriginalBuffer );

                csThreadID = GetThreadID( szBuffer );
                strcpy( szBuffer, szOriginalBuffer );

                //Search through the block looking for the "ChildEBP" text or the "> " prompt
                pszStartOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszStartOffset == NULL ) break;

                //Let's keep a copy of the original around
                strcpy( szOriginalBuffer, szBuffer );

                pszStartOffset = strstr( szBuffer, gslChildEBP );

                //If "ChildEBP" is not in the string, look for the prompt
                if ( pszStartOffset == NULL ) {
                
                    pszStartOffset = strstr( szBuffer, gslPrompt );
                
                    //If the prompt is not in the string, continue
                    if ( pszStartOffset == NULL ) {
                        continue;
                    }
                    else break;
                }

                //We have found the "ChildEBP", so skip it! hahahahaa (what a waste)
                pszStartOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                if ( pszStartOffset == NULL ) break;

                //Let's keep a copy of the original around
                strcpy( szOriginalBuffer, szBuffer );

                if ( strstr( szBuffer, gslWaitForSingleObject ) ) {
                    //Get the next line and look for WaitForCriticalSection
                    pszStartOffset = fgets( szBuffer, MAX_TEMP_BUFFER_SIZE, m_pLogFile );
                    if ( pszStartOffset == NULL ) break;

                    //Let's keep a copy of the original around
                    strcpy( szOriginalBuffer, szBuffer );

                    pszStartOffset = strstr( szBuffer, gslWaitForCriticalSection );

                    //If "WaitForCriticalSection" is not in the string, look for the prompt
                    if ( pszStartOffset == NULL ) {
                
                        pszStartOffset = strstr( szBuffer, gslPrompt );
                
                        //If the prompt is not in the string, continue
                        if ( pszStartOffset == NULL ) {
                            GetFirstParameter( szBuffer, csFirstParameter );
                            strcpy( szBuffer, szOriginalBuffer );
                            csOutput.Format( _T("Thread %s is in a WaitForSingleObject() call on object %s"), csThreadNumber, csFirstParameter );
                            bFound = TRUE;
                            break;
                        }
                        else break;
                    }

                    //"WaitForCriticalSection" is in the string, 
                    //Get the 5th token (3rd parameter) and look it up in the critical section map
                    GetThirdParameter( szBuffer, csThirdParameter );
                    strcpy( szBuffer, szOriginalBuffer );
                    csThirdParameter.MakeLower();
                    BOOL bFoundInMap = m_mapCriticalSection.Lookup( csThirdParameter, (CString&) csOwningThread );

                    //If not found in map,
                    if ( !bFoundInMap ) { 
                        csOutput.Format( _T("Thread %s id: %s is in WaitForCriticalSection() call on object %s"), csThreadNumber, csThreadID, csThirdParameter );
                        bFound = TRUE;
                        break;
                    }
                    else {
                        csOutput.Format( _T("Thread %s id: %s is in WaitForCriticalSection() call on object %s.  Thread %s is the owning thread."), csThreadNumber, csThreadID, csThirdParameter, csOwningThread);
                        bFound = TRUE;
                        break;
                    }

                }
                else if ( strstr( szBuffer, gslWaitForMultipleObjects ) ) {
                    GetFirstParameter( szBuffer, csFirstParameter );
                    strcpy( szBuffer, szOriginalBuffer );
                    GetSecondParameter( szBuffer, csSecondParameter );
                    strcpy( szBuffer, szOriginalBuffer );
    
                    csOutput.Format( _T("Thread %s id: %s is in a WaitForMultipleObjects() call on %s objects at address %s"), csThreadNumber, csThreadID, csFirstParameter, csSecondParameter );
                    bFound = TRUE;
                    break;
                }
                else {
                    csOutput.Format( _T("Thread %s is not in a known wait state"), csThreadNumber );
                    bFound = TRUE;
                    break;
                }

                if ( !bFound ) break;
                bFound = FALSE;

            } while ( TRUE );

            if ( !bFound ) break;
            bFound = FALSE;
            
            //Output the text to the list control
            m_ctlListControl.AddString( csOutput );

        } while ( TRUE );

        if ( !bFound ) break;
        bFound = FALSE;

    } while ( TRUE );
}

//
// a-mando
//
void CReadLogsDlg::ResizeAndReposControl()
{
    CRect   rtListCtrl,
            rtHangInfo,
            rtDlg;
    
    GetWindowRect( &rtDlg );
    m_staticHangInfo.GetWindowRect( &rtHangInfo );
    m_ctlListControl.GetWindowRect( &rtListCtrl );
    ScreenToClient( &rtDlg );
    ScreenToClient( &rtHangInfo );
    ScreenToClient( &rtListCtrl );

    switch ( m_eReadLogType ) {

    case ReadLogsType_Exception:
        break;

    case ReadLogsType_Hang:
        m_staticHangInfo.ShowWindow(SW_SHOW);
        rtListCtrl.left = rtDlg.left + DLG_PIXEL_EXTEND_SIZE;
        rtListCtrl.top = rtHangInfo.bottom + DLG_PIXEL_EXTEND_SIZE;
        m_ctlListControl.MoveWindow(&rtListCtrl);
	    m_ctlListControl.ShowWindow(SW_SHOW);
        break;

    case ReadLogsType_None:
        //Disable all the controls
        break;
    }

}
// a-mando
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\remotesessdlg.cpp ===
// RemoteSessDlg.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "RemoteSessDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR* gtcNone = _T("None");

/////////////////////////////////////////////////////////////////////////////
// CRemoteSessDlg dialog

extern PEmObject GetEmObj(BSTR bstrEmObj);

CRemoteSessDlg::CRemoteSessDlg(PSessionSettings pSettings, VARIANT *pVar, CWnd* pParent /*=NULL*/)
	: CDialog(CRemoteSessDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CRemoteSessDlg)
	m_bRememberSettings = FALSE;
	m_strAltSymbolPath = _T("");
	m_strPort = _T("");
	m_strPassword = _T("");
	m_strUsername = _T("");
	m_bCommandSet = FALSE;
	//}}AFX_DATA_INIT

	m_pSettings = pSettings;
	m_pECXVariantList = pVar;
}


void CRemoteSessDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRemoteSessDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LIST_COMMANDSET, m_mainListCtrl);
	DDX_Control(pDX, IDC_CK_COMMANDSET, m_btnCommandSet);
	DDX_Check(pDX, IDC_CK_REMEMBERSETTINGS, m_bRememberSettings);
	DDX_Text(pDX, IDC_EDIT_ALTSYMBOLPATH, m_strAltSymbolPath);
	DDX_Text(pDX, IDC_EDIT_PORT, m_strPort);
	DDX_Text(pDX, IDC_EDIT_PASSWORD, m_strPassword);
	DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUsername);
	DDX_Check(pDX, IDC_CK_COMMANDSET, m_bCommandSet);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemoteSessDlg, CDialog)
	//{{AFX_MSG_MAP(CRemoteSessDlg)
	ON_NOTIFY(NM_CLICK, IDC_LIST_COMMANDSET, OnClickListCommandset)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRemoteSessDlg message handlers

void CRemoteSessDlg::OnOK() 
{
	// TODO: Add extra validation here
	CDialog::OnOK();

	//Store off the current settings
	UpdateSessionDlgData(FALSE);
}

HRESULT CRemoteSessDlg::DisplayData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	TCHAR	szPid[20]		=	{0};
	LONG	lRow			=	0L;
	int		nImage			=	0;
	CString csPROCStatus;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		_ltot(pEmObject->nId, szPid, 10);
		
		lRow = m_mainListCtrl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		if ( pEmObject->dwBucket1 )
			lRow = m_mainListCtrl.SetItemText(lRow, 1, pEmObject->szBucket1);

		hr = S_OK;
	}
	while( false );

	return hr;
}

void CRemoteSessDlg::OnClickListCommandset(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	//Set the m_strSelectedCommandSet to the value of the currently selected item
	//in the list
	//Get the currently selected item
	POSITION pos = NULL;
	int nIndex = 0;

	do {
		pos = m_mainListCtrl.GetFirstSelectedItemPosition();

		if ( pos != NULL ) {
			nIndex = m_mainListCtrl.GetNextSelectedItem(pos);
			m_strSelectedCommandSet = m_mainListCtrl.GetItemText(nIndex, 0);
		}

		//Enable the Okay button
		//m
	} while ( FALSE );

	*pResult = 0;
}

BOOL CRemoteSessDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	// TODO: Add extra initialization here
	//Populate the list control with the ECX files.
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	EmObject		CurrentObj;
	CString			strDescription;
	CString			strName;

	do {
		//Check mark the command set button, but disable it
		m_btnCommandSet.SetCheck(1);
		m_btnCommandSet.EnableWindow(FALSE);

		//Add the columns to the list control
		m_mainListCtrl.BeginSetColumn(2);
		strName.LoadString(IDS_AUTOSESSDLG_NAME);
		strDescription.LoadString(IDS_AUTOSESSDLG_DESCRIPTION);
		m_mainListCtrl.AddColumn(strName);
		m_mainListCtrl.AddColumn(strDescription);
		m_mainListCtrl.EndSetColumn();
		
		m_mainListCtrl.ResizeColumnsFitScreen();
		m_mainListCtrl.SetExtendedStyle(LVS_EX_FULLROWSELECT);

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(m_pECXVariantList->parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(m_pECXVariantList->parray, 1, &lUBound);
		if(FAILED(hr)) break;

        //Add the "None" element to the list
		LONG lRow = m_mainListCtrl.SetItemText(-1, 0, gtcNone);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		//m_mainListCtrl.SetItemText(lRow, 1, gtcNone);

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(m_pECXVariantList->parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject. there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy
			CurrentObj = *GetEmObj(bstrEmObj);

            SysFreeString( bstrEmObj );

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayData(&CurrentObj);
		}
		//Synchronize the dialog with the view data
		UpdateSessionDlgData();
		UpdateData(FALSE);
	} while (FALSE);

    SysFreeString( bstrEmObj );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRemoteSessDlg::UpdateSessionDlgData(bool bUpdate)
{
	LVFINDINFO findInfo;
	int nIndex = 0;

	//if bUpdate is TRUE, we are loading the dialog settings from m_pSettings
	if ( bUpdate ) {
		if ( m_pSettings != NULL ) {
            m_bCommandSet           = m_pSettings->dwCommandSet;
			m_strPort				= m_pSettings->strPort;
			m_strPassword			= m_pSettings->strPassword;
			m_strUsername			= m_pSettings->strUsername;
			m_strAltSymbolPath		= m_pSettings->strAltSymbolPath;
			m_strSelectedCommandSet	= m_pSettings->strCommandSet;
			
			//Create and initialize a findInfo object to retrieve the index for the item were looking for
			findInfo.flags = LVFI_STRING;
			findInfo.psz = m_strSelectedCommandSet;

			if ( m_mainListCtrl.GetItemCount() > 0) {
				//Search for m_strSelectedCommandSet in the list control and select it.
				nIndex = m_mainListCtrl.FindItem(&findInfo);

				if ( nIndex != -1 ) {
					//We have found it, now hilight it
					m_mainListCtrl.SetItemState( nIndex,LVIS_SELECTED | LVIS_FOCUSED , LVIS_SELECTED | LVIS_FOCUSED);
					m_strSelectedCommandSet = m_mainListCtrl.GetItemText(nIndex, 0);
				} else {
					//Select the only item in the list
					m_mainListCtrl.SetItemState( 0,LVIS_SELECTED | LVIS_FOCUSED , LVIS_SELECTED | LVIS_FOCUSED);
					m_strSelectedCommandSet = m_mainListCtrl.GetItemText(0, 0);
				}
			}
			else {
				//We have no items in the list, disable the okay button
				m_btnOK.EnableWindow(FALSE);
			}
		}
	}
	//if bUpdate is FALSE, we are saving the dialog settings to m_pSettings
	else {
			m_pSettings->strPort			= m_strPort;
			m_pSettings->strPassword		= m_strPassword;
			m_pSettings->strUsername		= m_strUsername;
			m_pSettings->strAltSymbolPath	= m_strAltSymbolPath;
			m_pSettings->strCommandSet		= m_strSelectedCommandSet;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\proppagelogfiles.cpp ===
// PropPageLogFiles.cpp : implementation file
//

#include "stdafx.h"
#include "emshell.h"
#include "ReadLogsDlg.h"
#include "PropPageLogFiles.h"
#include <comdef.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropPageLogFiles property page

IMPLEMENT_DYNCREATE(CPropPageLogFiles, CPropertyPage)

CPropPageLogFiles::CPropPageLogFiles() : CPropertyPage(CPropPageLogFiles::IDD)
{
	//{{AFX_DATA_INIT(CPropPageLogFiles)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

extern BSTR CopyBSTR( LPBYTE  pb, ULONG   cb );
extern PEmObject GetEmObj(BSTR bstrEmObj);

CPropPageLogFiles::~CPropPageLogFiles()
{
}

void CPropPageLogFiles::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropPageLogFiles)
	DDX_Control(pDX, IDC_LIST_LOGFILES, m_ListCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropPageLogFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CPropPageLogFiles)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_LOGFILES, OnDblclkListLogfiles)
	ON_BN_CLICKED(IDC_BUTTON_EXPORT, OnButtonExport)
	ON_BN_CLICKED(IDC_BUTTON_VIEWLOGFILE, OnButtonViewlogfile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropPageLogFiles message handlers

BOOL CPropPageLogFiles::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	//Load the string resources for the CListCtrl columns
	CString strFileName, strSize, strTime;
	strFileName.LoadString(IDS_LC_FILENAME);
	strSize.LoadString(IDS_LC_FILESIZE);
	strTime.LoadString(IDS_LC_FILETIME);

	//Add the columns to the list control
	m_ListCtrl.BeginSetColumn(3);
	m_ListCtrl.AddColumn(strFileName);
	m_ListCtrl.AddColumn(strSize, VT_I4);
	m_ListCtrl.AddColumn(strTime);
	m_ListCtrl.EndSetColumn();
	
	// Populate the list control with the log files
	PopulateLogType();

	m_ListCtrl.ResizeColumnsFitScreen();
	m_ListCtrl.SetExtendedStyle(LVS_EX_FULLROWSELECT);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPropPageLogFiles::PopulateLogType()
{
	_variant_t		var;	//This will create and initialize the var variant
	HRESULT			hr				= E_FAIL;
    LONG			lLBound			= 0;
    LONG			lUBound			= 0;
    BSTR			bstrEmObj       = NULL;
	BSTR			bstrEmObjectFilter	= NULL;
	EmObject		*pCurrentObj	= NULL;
	EmObject		EmObjectFilter;
	memset(&EmObjectFilter, 0, sizeof( EmObject ) );

	do {
		memcpy( &EmObjectFilter, m_pEmObject, sizeof( EmObject ) );
		EmObjectFilter.type = EMOBJ_LOGFILE;
		bstrEmObjectFilter = CopyBSTR ( (LPBYTE)&EmObjectFilter, sizeof( EmObject ) );
		//Populate the list control based on the EmObjectType
		//Enumerate all the objects and stick them in the variant
		hr = m_pIEmManager->EnumObjectsEx(bstrEmObjectFilter, &var);

		if(FAILED(hr)) break;

		//Get the lower and upper bounds of the variant array
		hr = SafeArrayGetLBound(var.parray, 1, &lLBound);
		if(FAILED(hr)) break;

		hr = SafeArrayGetUBound(var.parray, 1, &lUBound);
		if(FAILED(hr)) break;

		//There are elements at both the lower bound and upper bound, so include them
		for(; lLBound <= lUBound; lLBound++)
		{
			//Get a BSTR object from the safe array
			hr = SafeArrayGetElement(var.parray, &lLBound, &bstrEmObj);
			
			if (FAILED(hr)) break;

			//Create a local copy of the EmObject (there aren't any pointers in
			//EmObject structure, so don't worry about doing a deep copy

			pCurrentObj = ((CEmshellApp*)AfxGetApp())->AllocEmObject();
			if (pCurrentObj != NULL) {
				*pCurrentObj = *GetEmObj(bstrEmObj);
			}

            SysFreeString( bstrEmObj );

			//Unallocate the EmObject if it has an hr of E_FAIL
			if (FAILED(pCurrentObj->hr)) {
				((CEmshellApp*)AfxGetApp())->DeAllocEmObject(pCurrentObj);
				continue;
			}

			//Convert the BSTR object to an EmObject and pass it to DisplayData
			DisplayLogData(pCurrentObj);
		}
	} while (FALSE);

    SafeArrayDestroyData(var.parray);
    SysFreeString( bstrEmObj );
	SysFreeString ( bstrEmObjectFilter );

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

HRESULT CPropPageLogFiles::DisplayLogData(PEmObject pEmObject)
{
	_ASSERTE(pEmObject != NULL);

	HRESULT hr				=	E_FAIL;
	CString	strFileSize;
	CString	strStartDate;
	LONG	lRow			=	0L;
	int		nImage			=	0;
	int nImageOffset		=	0;

	do
	{
		if( pEmObject == NULL ){
			hr = E_INVALIDARG;
			break;
		}

		strFileSize.Format(_T("%d"), pEmObject->dwBucket1);

		lRow = m_ListCtrl.SetItemText(-1, 0, pEmObject->szName);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

		//Set the itemData
		m_ListCtrl.SetItemData(lRow, (ULONG_PTR) pEmObject);
		
		//Get the correct offset into the bitmap for the current status
//		nImageOffset = GetImageOffsetFromStatus((EmSessionStatus)pEmObject->nStatus);

		//Call SetItem() with the index and image to show based on the state of pEmObject
		m_ListCtrl.SetItem(lRow, 0, LVIF_IMAGE, NULL, nImageOffset, 0, 0, 0);

		lRow = m_ListCtrl.SetItemText(lRow, 1, strFileSize);
		if(lRow == -1L){
			hr = E_FAIL;
			break;
		}

        //
        // a-mando
        //
        if( pEmObject->dateStart != 0L ) {

            COleDateTime oleDtTm(pEmObject->dateStart);
    		strStartDate = oleDtTm.Format(_T("%c"));

            lRow = m_ListCtrl.SetItemText(lRow, 2, strStartDate);
	        if(lRow == -1L){
		        hr = E_FAIL;
		        break;
	        }
        }
        // a-mando

		hr = S_OK;
	}
	while( false );

	return hr;
}


void CPropPageLogFiles::OnDblclkListLogfiles(NMHDR* pNMHDR, LRESULT* pResult) 
{
	PEmObject pEmObject = NULL;

	// TODO: Add your control notification handler code here
	
	do {
		//Get the currently selected object in the list control
		pEmObject = GetSelectedEmObject();
		
		if (pEmObject == NULL) break;

		DoModalReadLogsDlg(pEmObject);
	}while (FALSE);

	*pResult = 0;
}

void CPropPageLogFiles::DoModalReadLogsDlg(PEmObject pEmObject)
{
	CReadLogsDlg		readLogDlg( pEmObject, m_pIEmManager );
	BOOL				bInActiveSessionTable = FALSE;

//	readLogDlg.m_pEmObject			= pEmObject;
//	readLogDlg.m_pIEmManager		= m_pIEmManager;

	readLogDlg.DoModal();
}

PEmObject CPropPageLogFiles::GetSelectedEmObject()
{
	POSITION	pos			= 0;
	int			nIndex		= 0;
	PEmObject	pEmObject	= NULL;
	PEmObject	pRetVal		= NULL;

	do {
		pos = m_ListCtrl.GetFirstSelectedItemPosition();
		
		if(pos == NULL) break;

		//Get the itemdata for the element at nIndex
		nIndex = m_ListCtrl.GetNextSelectedItem(pos);
		
		if (nIndex == -1) break;

		pEmObject = (PEmObject) m_ListCtrl.GetItemData(nIndex);
		
		if ( pEmObject == NULL ) break;

		pRetVal = pEmObject;
	} while (FALSE);

	return pRetVal;
}


void CPropPageLogFiles::OnButtonExport() 
{
	PEmObject		pEmObject		= NULL;
	HRESULT			hr				= S_OK;
    CString         strDirPath;

    //Iterate through each element in the m_ListCtrl, getting it's pEmObject and calling ExportLog() on it.
	//Step through every item in the list control 
	int nCount = m_ListCtrl.GetItemCount();
    //Get the path
    if ( ( (CEmshellApp*) AfxGetApp() )->AskForPath( strDirPath ) ) {
	    for (int i = 0;i < nCount; i++) {
		    pEmObject = (PEmObject)m_ListCtrl.GetItemData(i);
		    
		    if (pEmObject == NULL) {
			    hr = E_FAIL;
			    break;
		    }

            //Export the file
            ((CEmshellApp*)AfxGetApp())->ExportLog( pEmObject, strDirPath, m_pIEmManager );
        }
    }

	if (FAILED(hr)) {
		((CEmshellApp*)AfxGetApp())->DisplayErrMsgFromHR(hr);
	}
}

void CPropPageLogFiles::OnButtonViewlogfile() 
{
	PEmObject pEmObject = NULL;

	// TODO: Add your control notification handler code here
	
	do {
		//Get the currently selected object in the list control
		pEmObject = GetSelectedEmObject();
		
		if (pEmObject == NULL) break;

		DoModalReadLogsDlg(pEmObject);
	}while (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\remotesessdlg.h ===
#if !defined(AFX_REMOTESESSDLG_H__E2778F1E_48A8_444F_97EF_1315B83FD425__INCLUDED_)
#define AFX_REMOTESESSDLG_H__E2778F1E_48A8_444F_97EF_1315B83FD425__INCLUDED_

#include "emobjdef.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RemoteSessDlg.h : header file
//

#include "genlistctrl.h"
/////////////////////////////////////////////////////////////////////////////
// CRemoteSessDlg dialog

class CRemoteSessDlg : public CDialog
{
// Construction
public:
	VARIANT* m_pECXVariantList;
	CString m_strSelectedCommandSet;
	PSessionSettings m_pSettings;
	void UpdateSessionDlgData(bool bUpdate = TRUE);
	CRemoteSessDlg(PSessionSettings pSettings, VARIANT *pVar, CWnd* pParent = NULL);   // standard constructor
	HRESULT DisplayData(PEmObject pEmObject);

// Dialog Data
	//{{AFX_DATA(CRemoteSessDlg)
	enum { IDD = IDD_REMOTE_SESS_DLG };
	CButton	m_btnOK;
	CGenListCtrl	m_mainListCtrl;
	CButton	m_btnCommandSet;
	BOOL	m_bRememberSettings;
	CString	m_strAltSymbolPath;
	CString	m_strPort;
	CString	m_strPassword;
	CString	m_strUsername;
	BOOL	m_bCommandSet;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRemoteSessDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRemoteSessDlg)
	virtual void OnOK();
	afx_msg void OnClickListCommandset(NMHDR* pNMHDR, LRESULT* pResult);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOTESESSDLG_H__E2778F1E_48A8_444F_97EF_1315B83FD425__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	emshell.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by emshell.rc
//
#define IDOK2                           3
#define IDD_ABOUTBOX                    100
#define IDD_EMSHELL_FORM                101
#define IDD_PROPPAGE_LOGFILES           107
#define IDR_MAINFRAME                   128
#define IDR_EMSHELTYPE                  129
#define IDD_CONNECTION                  131
#define IDR_PROCESSPOPUP                133
#define IDB_STATUS_BITMAP               135
#define IDD_REMOTE_SESS_DLG             144
#define IDD_AUTO_SESS_DLG               145
#define IDR_LOGPOPUP                    146
#define IDD_PROPPAGE_DUMPFILES          146
#define IDD_PROPPAGE_GENERAL            147
#define IDD_READLOGS                    151
#define IDD_OPTIONS                     152
#define IDI_EMOPTIONS                   153
#define IDD_PROPPAGE_GENLOGDUMP         153
#define IDD_DIALOG_NFO                  154
#define IDI_ICON_SYSINFO                155
#define IDC_LST_MAINLISTCTRL            1000
#define IDC_EDIT_SERVERNAME             1002
#define IDCONNECT                       1003
#define IDC_RADIO_LOCAL                 1004
#define IDC_RADIO_REMOTE                1005
#define IDC_STATIC_SERVERNAME           1006
#define IDC_CHECK1                      1017
#define IDC_CHECK_NFODIALOG_NOSHOW      1017
#define IDC_EDIT1                       1018
#define IDC_EDIT_PORT                   1018
#define IDC_EDIT_DUMPDIRVAL             1018
#define IDC_EDIT_READLOGS               1018
#define IDC_OPTION_REFRESHRATE          1018
#define IDC_EDIT_DATETIME               1018
#define IDC_EDIT_CATEGORIES             1018
#define IDC_EDIT3                       1019
#define IDC_CK_RECURSIVEMODE            1019
#define IDC_EDIT_USERNAME               1019
#define IDC_EDIT_EXCEPTION_LOCATION     1019
#define IDC_EDIT4                       1020
#define IDC_CK_MINIDUMP                 1020
#define IDC_EDIT_PASSWORD               1020
#define IDC_EDIT_FAILING_INSTRUCTION    1020
#define IDC_CHECK4                      1021
#define IDC_CK_BLOCK_IP                 1021
#define IDC_EDIT2                       1022
#define IDC_EDIT_EXCEPTION_TYPE         1022
#define IDC_EDIT_FILENAME               1022
#define IDC_EDIT_FILE_SIZE              1023
#define IDC_CHECK5                      1024
#define IDC_EDIT_DIRECTORY              1024
#define IDC_LIST2                       1025
#define IDC_CK_COMMANDSET               1026
#define IDC_CK_NOTIFYADMIN              1027
#define IDC_CK_USERDUMP                 1028
#define IDC_STATIC_ALTSYMBOLPATH        1029
#define IDC_EDIT_ALTSYMBOLPATH          1030
#define IDC_LIST_COMMANDSET             1031
#define IDC_CK_REMEMBERSETTINGS         1032
#define IDC_EDIT_NOTIFYADMIN            1033
#define IDC_STATIC_OPTIONSGROUP         1034
#define IDC_STATIC_PORT                 1035
#define IDC_STATIC_USERNAME             1036
#define IDC_STATIC_PASSWORD             1037
#define IDC_LIST1                       1040
#define IDC_LIST_LOGFILES               1040
#define IDC_LIST_CALL_STACK             1040
#define IDC_STATIC_NAMEVAL              1041
#define IDC_STATIC_NAMELABEL            1042
#define IDC_STATIC_TYPELABEL            1043
#define IDC_STATIC_GUIDLABEL            1044
#define IDC_STATIC_PIDLABEL             1045
#define IDC_STATIC_DWBUCKET1LABEL       1046
#define IDC_STATIC_SZBUCKET1LABEL       1047
#define IDC_STATIC_HRLABEL              1048
#define IDC_STATIC_DWBUCKET1VAL         1049
#define IDC_STATIC_SZBUCKET1VAL         1050
#define IDC_STATIC_LOGDIRLABEL          1051
#define IDC_BUTTON_DUMPDIREXPLORE       1052
#define IDC_STATIC_DUMPDIRLABEL         1053
#define IDC_EDIT_LOGDIRVAL              1054
#define IDC_BUTTON_LOGDIREXPLORE        1055
#define IDC_LIST_DUMPFILES              1056
#define IDC_STATIC_TYPEVAL              1057
#define IDC_STATIC_GUIDVAL              1058
#define IDC_STATIC_PIDVAL               1059
#define IDC_STATIC_HRVAL                1060
#define IDC_STATIC_STARTDATELABEL       1061
#define IDC_STATIC_ENDDATELABEL         1062
#define IDC_STATIC_STARTDATEVAL         1063
#define IDC_STATIC_ENDDATEVAL           1064
#define IDC_STATIC_STATUSLABEL          1065
#define IDC_STATIC_STATUSVAL            1066
#define IDC_ADVANCED                    1068
#define IDC_EDIT_HANG_LIST_CONTROL      1071
#define IDC_STATIC_EXCEPTION_TYPE       1072
#define IDC_STATIC_EXCEPTION_LOCATION   1073
#define IDC_STATIC_FAILING_INSTRUCTION  1074
#define IDC_STATIC_CALL_STACK           1075
#define IDC_STATIC_HANGINFO             1076
#define IDC_STATIC_EXCEPINFO            1077
#define IDC_DELETE                      1082
#define IDC_OPTIONS                     1086
#define IDC_STATIC_DEMARK               1087
#define IDC_BUTTON_EXPORT               1088
#define IDC_BUTTON_VIEWLOGFILE          1089
#define IDS_LC_STARTDATE                32000
#define IDS_LC_STARTEND                 32001
#define IDS_LC_ENDDATE                  32001
#define IDS_ERROR_CONNECTION_TERMINATED 32002
#define ID_FILE_CONNECT                 32771
#define ID_PROCESSPOPUP_AUTOMATICSESSION 32773
#define ID_PROCESSPOPUP_RECURSIVESESSION 32775
#define ID_PROCESSPOPUP_MANUALSESSION   32776
#define ID_PROCESSPOPUP_STOPSESSION     32777
#define ID_PROCESSPOPUP_PROPERTIES      32778
#define ID_REFRESH                      32779
#define ID_PROCESSPOPUP_GENERATEMINIDUMP 32780
#define ID_PROCESSPOPUP_GENERATEUSERDUMP 32781
#define ID_VIEW_REFRESH                 32782
#define ID_VIEW_SERVICESANDAPPLICATIONS 32783
#define ID_VIEW_LOGFILES                32784
#define ID_VIEW_DUMPFILES               32785
#define ID_FILE_DISCONNECT              32786
#define ID_PROCESSPOPUP_REFRESH         32787
#define IDS_DISCONNECTED                32788
#define IDS_CONNECTED                   32789
#define IDS_OUTOFBOUNDS_REFRESHRATE     32790
#define ID_LOGPOPUP_OPEN                32802
#define ID_LOGPOPUP_PROPERTIES          32803
#define IDS_EMOBJECT_TYPE_PROCESS       32804
#define IDS_EMOBJECT_TYPE_SERVICE       32805
#define ID_VIEW_APPLICATIONS            32805
#define IDS_EMOBJECT_TYPE_LOGFILE       32806
#define IDS_EMOBJECT_TYPE_MINIDUMP      32807
#define ID_VIEW_SERVICES                32807
#define IDS_EMOBJECT_TYPE_USERDUMP      32808
#define ID_VIEW_COMPLETEDSESSIONS       32808
#define IDS_EMOBJECT_TYPE_UNKNOWNOBJECT 32809
#define ID_VIEW_RUNNINGSESSIONS         32813
#define ID_PROCESSPOPUP_DELETESESSION   32814
#define IDS_FILEOVERWRITE_CONFIRMATION  32815
#define ID_PROCESSPOPUP_CANCELSESSION   32816
#define IDM_TOOLS_OPTOINS               32817
#define ID_BUTTON32830                  32830
#define ID_LOGPOPUP_DELETE              32831
#define ID_ACTION_GENERATENFOFILE       32832
#define ID_VIEW_MSINFOFILES             32833
#define ID_LOGPOPUP_EXPORT              32834
#define ID_HELP_CONTENTS                32837
#define IDS_LC_IMAGENAME                51191
#define IDS_LC_PID                      51192
#define IDS_LC_STATUS                   51193
#define IDS_LC_DESCRIPTION              51194
#define IDS_LC_STARTTIME                51195
#define IDS_LC_ENDTIME                  51196
#define IDS_ERRORMSG                    51197
#define IDS_PROCESSRUNNING              51198
#define IDS_PROCESSSTOPPED              51199
#define IDS_DISCONNECTWARNING           51200
#define IDS_DISCONNECTCAPTION           51201
#define IDS_LC_SHORTNAME                51202
#define IDS_SESSIONLISTANOMOLY          51204
#define IDS_AUTOSESSDLG_DESCRIPTION     51205
#define IDS_LC_FILENAME                 51206
#define IDS_LC_FILESIZE                 51207
#define IDS_LC_FILETIME                 51208
#define IDS_LC_FILEPROCESS              51209
#define IDS_ERROR_FAILEDCLOSESESSION    51210
#define IDS_EXPORT_FILES_CAPTION        51211
#define IDS_EXPORT_FAILED_GET_DIRECTORY 51212
#define IDS_STATUS_NONE                 51446
#define IDS_STATUS_FILECREATED          51447
#define IDS_STATUS_SESS_STARTED         51448
#define IDS_STATUS_SESS_DEBUGGING_IN_PROCESS 51451
#define IDS_STATUS_SESS_DEBUGGEE_KILLED 51452
#define IDS_STATUS_SESS_DEBUGGEE_EXITED 51453
#define IDS_STATUS_SESS_DEBUGGING_COMPLETED 51454
#define IDS_STATUS_SESS_ERROR_ENCOUNTERED 51455
#define IDS_STATUS_ERROR                51456
#define IDS_STATUS_SESS_EXCEPTIONOCCURED 51457
#define IDS_STATUS_SESS_ACCESSVIOLATIONOCCURED 51458
#define IDS_DEBUG_ERROR                 51459
#define IDS_ORPHANCUSTODYCONFIRM        51460
#define IDS_STAT_SESS_NOT_STARTED_RUNNING 51463
#define IDS_STAT_SESS_NOT_STARTED_NOTRUNNING 51464
#define IDS_STAT_SESS_DEBUG_IN_PROGRESS_NONE 51465
#define IDS_STAT_SESS_DEBUG_IN_PROGRESS_FILECREATED_SUCESSFULLY 51466
#define IDS_STAT_SESS_DEBUG_IN_PROGRESS_FILECREATION_FAILED 51467
#define IDS_STAT_SESS_STOPPED_SUCCESS   51468
#define IDS_STAT_SESS_STOPPED_FAILED    51469
#define IDS_STAT_SESS_NOT_STARTED_FILECREATED_SUCCESSFULLY 51470
#define IDS_STAT_SESS_NOT_STARTED_FILECREATION_FAILED 51471
#define IDS_STAT_SESS_STOPPED_DEBUGGEE_KILLED 51472
#define IDS_STAT_SESS_STOPPED_DEBUGGEE_EXITED 51473
#define IDS_STAT_SESS_STOPPED_EXCEPTION_OCCURED 51474
#define IDS_STAT_SESS_STOPPED_ACCESSVIOLATION_OCCURED 51475
#define IDS_STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_NONE 51476
#define IDS_STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATED_SUCESSFULLY 51477
#define IDS_STAT_SESS_DEBUG_IN_PROGRESS_ORPHAN_FILECREATION_FAILED 51478
#define IDS_STAT_SESS_STOPPED_ORPHAN_SUCCESS 51479
#define IDS_STAT_SESS_STOPPED_ORPHAN_FAILED 51480
#define IDS_STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_KILLED 51481
#define IDS_STAT_SESS_STOPPED_ORPHAN_DEBUGGEE_EXITED 51482
#define IDS_STAT_SESS_STOPPED_ORPHAN_EXCEPTION_OCCURED 51483
#define IDS_STAT_SESS_STOPPED_ORPHAN_ACCESSVIOLATION_OCCURED 51484
#define IDS_READLOGS_ADVOPEN            51485
#define IDS_READLOGS_ADVCLOSE           51486
#define IDS_AUTOSESSDLG_NAME            57332
#define IDS_APPTITLE                    57333
#define IDS_DATETIMEFORMAT              61446

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        158
#define _APS_NEXT_COMMAND_VALUE         32838
#define _APS_NEXT_CONTROL_VALUE         1090
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emdebugsession.cpp ===
// EmDebugSession.cpp : Implementation of CEmDebugSession
#include "stdafx.h"
#include "Emsvc.h"
#include "EmDebugSession.h"

/////////////////////////////////////////////////////////////////////////////
// CEmDebugSession


STDMETHODIMP CEmDebugSession::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEmDebugSession
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
        if (::InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP
CEmDebugSession::DebugEx
(
IN      BSTR        bstrEmObj,
IN      SessionType eSessType,
IN      BSTR        bstrEcxFilePath,
IN      LONG        lParam,
IN OPT  VARIANT     vtUserName,
IN OPT  VARIANT     vtPassword,
IN OPT  VARIANT     vtPort,
IN OPT  VARIANT     vtNotifyAdmin,
IN OPT  VARIANT     vtAltSymPath
)
{
    ATLTRACE(_T("CEmDebugSession::DebugEx\n"));

    _ASSERTE(bstrEmObj != NULL);

    HRESULT     hr                      =   E_FAIL;
    PEmObject   pEmObj                  =   NULL;
	PEMSession	pEmSess					=	NULL;

    BSTR        bstrUserName            =   GetBSTR(vtUserName);
    BSTR        bstrPassword            =   GetBSTR(vtPassword);
    BSTR        bstrNotificationString  =   GetBSTR(vtNotifyAdmin);
    BSTR        bstrAltSymPath          =   GetBSTR(vtAltSymPath);
    UINT        nPort                   =   GetInteger(vtPort);
    EmObject    EmObj;

    m_pcs->ReadLock();

    __try {

        do
        {
            if( (bstrEmObj == NULL) ||
                (vtUserName.vt != VT_EMPTY && IsBSTR(vtUserName) == FALSE)          ||
                (vtPassword.vt != VT_EMPTY && IsBSTR(vtPassword) == FALSE)          ||
                (vtPort.vt != VT_EMPTY && IsInteger(vtPort) == FALSE)               ||
                (vtNotifyAdmin.vt != VT_EMPTY && IsBSTR(vtNotifyAdmin) == FALSE)    ||
                (vtAltSymPath.vt != VT_EMPTY && IsBSTR(vtAltSymPath) == FALSE)
                )
            {

                hr = E_INVALIDARG;
                break;
            }

            pEmObj = GetEmObj(bstrEmObj);
            _ASSERTE( pEmObj != NULL );

            //
            // If it is being debugged already this call should not
            // have been made..
            //

//            hr = m_pASTManager->IsAlreadyBeingDebugged(pEmObj);
            LONG lStatus    =   0L;
            hr = m_pASTManager->GetSessionStatus( m_pEmObj->guidstream, &lStatus );
            FAILEDHR_BREAK(hr);

//            if( hr == S_OK ) {
            if( HIWORD(lStatus) > HIWORD(STAT_SESS_NOT_STARTED) ) {

                hr = EMERROR_PROCESSBEINGDEBUGGED;
                break;
            }

            ZeroMemory((void *)&EmObj, sizeof EmObj);

            if( eSessType == SessType_Automatic ) {

                hr = StartAutomaticSession(
                                        (lParam & RECURSIVE_MODE),
                                        bstrEcxFilePath,
                                        bstrNotificationString,
                                        bstrAltSymPath,
                                        (lParam & PRODUCE_MINI_DUMP),
                                        (lParam & PRODUCE_USER_DUMP)
                                        );

                EmObj.type2 = SessType_Automatic;
                EmObj.dateStart = CServiceModule::GetCurrentTime();

                m_pASTManager->UpdateSessObject( m_pEmObj->guidstream,
                                                 EMOBJ_FLD_TYPE2 | EMOBJ_FLD_DATESTART,
                                                 &EmObj
                                                 );
            }

            else {

                hr = StartManualSession(
                                        bstrEcxFilePath,
                                        nPort,
                                        bstrUserName,
                                        bstrPassword,
                                        (lParam && BLOCK_INCOMING_IPCALLS),
                                        bstrAltSymPath
                                        );
                FAILEDHR_BREAK(hr);

                EmObj.type2 = SessType_Manual;
                EmObj.dateStart = CServiceModule::GetCurrentTime();

                m_pASTManager->UpdateSessObject( m_pEmObj->guidstream,
                                                 EMOBJ_FLD_TYPE2 | EMOBJ_FLD_DATESTART,
                                                 &EmObj
                                                 );
            }

        }
        while( false );

	    if(SUCCEEDED(hr)) {

            m_pASTManager->SetSessionStatus(
                                    pEmObj->guidstream,
                                    STAT_SESS_DEBUG_IN_PROGRESS_NONE,
                                    hr,
                                    NULL
                                    );

            SetMyselfAsMaster();

            m_pASTManager->GetSession(pEmObj->guidstream, &pEmSess);
		    ::SysFreeString(bstrEmObj);
		    bstrEmObj = CopyBSTR((LPBYTE)pEmSess->pEmObj, sizeof EmObject);

	    }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

STDMETHODIMP CEmDebugSession::StopDebug(BOOL bForceStop)
{
    ATLTRACE(_T("CEmDebugSession::StopDebug\n"));

	HRESULT hr      =   E_FAIL;
    LONG    lStatus =   0L;

    m_pcs->ReadLock();

    __try {

        hr = m_pASTManager->GetSessionStatus( m_pEmObj->guidstream, &lStatus );
        if( FAILED(hr) ) { return hr; }

        if( !(lStatus & STAT_SESS_DEBUG_IN_PROGRESS ) ) {

            return (hr = EMERROR_PROCESSNOTBEINGDEBUGGED);
        }

        hr = CanTakeOwnership();

        if( bForceStop && hr == EMERROR_SESSIONORPHANED ) {

            hr = m_pASTManager->AdoptThisSession( m_pEmObj->guidstream );
            if( SUCCEEDED(hr) ) {

                SetMyselfAsMaster();
                hr = S_OK;
            }
        }

        if( hr == S_OK ) { hr = m_pEmSessThrd->StopDebugging(); }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

STDMETHODIMP
CEmDebugSession::GenerateDumpFile
(
IN  UINT nDumpType
)
{
    ATLTRACE(_T("CEmDebugSession::GenerateDumpFile\n"));

	HRESULT hr      =   E_FAIL,
            hrStat  =   E_FAIL;
    LONG    lStatus =   0L;

    m_pcs->ReadLock();

    __try {

// we don't need this check any more, coz we allow anybody and everybody
// to generate dump files.. :(
//        if( AmITheMaster() == FALSE ) { return EMERROR_NOTOWNER; }

        hr = m_pEmSessThrd->CreateDumpFile( nDumpType );

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

STDMETHODIMP
CEmDebugSession::GetStatus
(
IN OUT  BSTR bstrEmObj
)
{
    ATLTRACE(_T("CEmDebugSession::GetStatus\n"));

    _ASSERTE(bstrEmObj != NULL);

    HRESULT     hr          =   E_FAIL;
    PEMSession  pEmSess     =   NULL;
    PEmObject   pEmObj      =   NULL;

    m_pcs->ReadLock();

    __try {

        do
        {
            if( bstrEmObj == NULL ){

                hr = E_INVALIDARG;
                break;
            }

/*
// everyone should be able to call Refresh..

            if( AmITheMaster() == FALSE ) {

                hr = EMERROR_NOTOWNER;
                break;
            }
*/

            pEmObj = GetEmObj(bstrEmObj);

            // This should never happen
            hr = EMERROR_INVALIDPROCESS;
            if(m_pASTManager->GetSession(pEmObj->guidstream, &pEmSess) == S_OK){

                ::SysFreeString(bstrEmObj);
                bstrEmObj = CopyBSTR((LPBYTE)pEmSess->pEmObj, sizeof EmObject);
                hr = S_OK;
            }

        }
        while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

bool CEmDebugSession::AmITheMaster()
{
    ATLTRACE(_T("CEmDebugSession::AmITheMaster\n"));

    return (m_bMaster);
}

HRESULT
CEmDebugSession::StartAutomaticSession
(
IN  BOOL    bRecursive,
IN  BSTR    bstrEcxFilePath,
IN  BSTR    bstrNotificationString,
IN  BSTR    bstrAltSymPath,
IN  BOOL    bGenMiniDumpFile,
IN  BOOL    bGenUserDumpFile
)
{
    ATLTRACE(_T("CEmDebugSession::StartAutomaticSession\n"));

    _ASSERTE(bstrEcxFilePath != NULL);

    HRESULT hr  =   E_FAIL;

    m_pcs->ReadLock();

    __try {

        do
        {
            if( bstrEcxFilePath == NULL ) {

                hr = E_INVALIDARG;
                break;
            }

            hr = m_pEmSessThrd->InitAutomaticSession(
                                                bRecursive,
                                                bstrEcxFilePath,
                                                bstrNotificationString,
                                                bstrAltSymPath,
                                                bGenMiniDumpFile,
                                                bGenUserDumpFile
                                                );
            FAILEDHR_BREAK(hr);

            hr = HRESULT_FROM_WIN32(m_pEmSessThrd->Start());
			FAILEDHR_BREAK(hr);

    		WaitForSingleObject( m_pEmSessThrd->m_hCDBStarted, INFINITE );

        }
        while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

HRESULT
CEmDebugSession::StartManualSession
(
IN  BSTR    bstrEcxFilePath,
IN  UINT    nPort,
IN  BSTR    bstrUserName,
IN  BSTR    bstrPassword,
IN  BOOL    bBlockIncomingIPConnections,
IN  BSTR    bstrAltSymPath
)
{
    ATLTRACE(_T("CEmDebugSession::StartManualSession\n"));

	_ASSERTE( nPort != NULL );
	_ASSERTE( bstrUserName != NULL );
	_ASSERTE( bstrPassword != NULL );

    HRESULT hr  =   E_FAIL;

    m_pcs->ReadLock();

    __try {

        do
        {

			if( ( nPort == NULL )		||
				( bstrUserName == NULL )||
				( bstrPassword == NULL ) ) {

				hr = E_INVALIDARG;
				break;
			}
			
			if( m_pASTManager->IsPortInUse(nPort) == TRUE ) {

				hr = EMERROR_PORTINUSE;
				break;
			}

            hr = m_pEmSessThrd->InitManualSession(
                                                bstrEcxFilePath,
                                                nPort,
                                                bstrUserName,
												bstrPassword,
												bBlockIncomingIPConnections,
												bstrAltSymPath
                                                );
            FAILEDHR_BREAK(hr);

            hr = HRESULT_FROM_WIN32(m_pEmSessThrd->Start());
			FAILEDHR_BREAK(hr);

    		WaitForSingleObject( m_pEmSessThrd->m_hCDBStarted, INFINITE );

        }
        while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

STDMETHODIMP
CEmDebugSession::Debug
(
IN OUT  BSTR        bstrEmObj,
IN      SessionType eSessType
)
{
    return E_NOTIMPL;
}

STDMETHODIMP CEmDebugSession::CancelDebug(BOOL bForceCancel)
{
    ATLTRACE(_T("CEmDebugSession::CancelDebug\n"));

	HRESULT hr      =   E_FAIL;
    LONG    lStatus =   0L;

    m_pcs->ReadLock();

    __try {

        hr = m_pASTManager->GetSessionStatus( m_pEmObj->guidstream, &lStatus );
        if( FAILED(hr) ) { return hr; }

        if( !(lStatus & STAT_SESS_DEBUG_IN_PROGRESS ) ) {

            return (hr = EMERROR_PROCESSNOTBEINGDEBUGGED);
        }

        hr = CanTakeOwnership();

        if( bForceCancel && hr == EMERROR_SESSIONORPHANED ) {

            hr = m_pASTManager->AdoptThisSession( m_pEmObj->guidstream );
            if( SUCCEEDED(hr) ) { SetMyselfAsMaster(); hr = S_OK; }
        }

        if( hr == S_OK ) { hr = m_pEmSessThrd->CancelDebugging(); }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

void CEmDebugSession::SetMyselfAsMaster(bool bMaster /* = true */)
{
    m_bMaster = bMaster;
}

HRESULT CEmDebugSession::CanTakeOwnership()
{
    HRESULT hr      =   E_FAIL,
            hrStat  =   E_FAIL;
    LONG    lStatus =   0L;

    m_pcs->ReadLock();

    __try
    {

        do
        {
            m_pASTManager->GetSessionStatus( m_pEmObj->guidstream, &lStatus, &hrStat );

            if( HIWORD(lStatus) < HIWORD(STAT_SESS_DEBUG_IN_PROGRESS) ) {

                hr = EMERROR_PROCESSNOTBEINGDEBUGGED;
                break;
            }

            // if I am the master, I can do anything to the session..
            if( AmITheMaster() == true ) { hr = S_OK; break; }

            hr = m_pASTManager->IsSessionOrphaned( m_pEmObj->guidstream );
            if( FAILED(hr) ) { break; }

            // am not the master and the session is orphaned..
            if( hr == S_OK ) { hr = EMERROR_SESSIONORPHANED; break; }

            // am not the master and the session is not orphaned..
            hr = E_ACCESSDENIED;

        }
        while( false );
    }

	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}

STDMETHODIMP CEmDebugSession::AdoptOrphan()
{
    HRESULT hr      =   E_FAIL;

    m_pcs->ReadLock();

    __try
    {
        hr = CanTakeOwnership();

        if( hr == EMERROR_SESSIONORPHANED ) {

            hr = m_pASTManager->AdoptThisSession( m_pEmObj->guidstream );
            if( SUCCEEDED(hr) ) { SetMyselfAsMaster(); hr = S_OK; }
        }
    }

	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\email.cpp ===
#include "stdafx.h"

// This flag indicates that the CDO's IDispatch must be used natively.
//#define _USECDODISP

#ifndef _USECDODISP   

//
// Use CDO by importing the typelib into the project
//
#include <cdonts.tlh>

// BUGBUG need to know the right place to pick up cdonts.dll
//#import <cdonts.dll> no_namespace rename("GetMessage", "GetMessageCDOEm" )

HRESULT
SendMail
(
IN  LPCTSTR lpszFrom,
IN  LPCTSTR lpszTo,
IN  LPCTSTR lpszSubject,
IN  LPCTSTR lpszMessage,
IN  short   nImportance = CdoNormal
)
{

    _ASSERTE(lpszFrom != NULL);
    _ASSERTE(lpszTo != NULL);

    HRESULT hr          =   E_FAIL;

    _bstr_t btFrom      =   _T(""),
            btTo        =   _T(""),
            btSubject   =   _T(""),
            btMessage   =   _T("");

//    __try
    {

        btFrom = lpszFrom;
        btTo = lpszTo;
        btSubject = lpszSubject;
        btMessage = lpszMessage;

        CoInitialize(NULL);

        INewMail  *pNewMail   =   NULL;

        hr = CoCreateInstance( 
                            __uuidof(NewMail),
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            __uuidof(INewMail),
                            (void**) &pNewMail
                            );

        if( SUCCEEDED(hr) ) {

            hr = pNewMail->Send( btFrom, btTo, btSubject, btMessage, nImportance );
            pNewMail->Release();
        }

        CoUninitialize();
    }
//	__except ( EXCEPTION_EXECUTE_HANDLER, 1 )
//    {
//        hr = E_UNEXPECTED;
//        _ASSERTE(false);
//    }

    return hr;
}

void __stdcall _com_issue_errorex ( 
    long hr, 
    struct IUnknown * pUnk,
    struct _GUID const & refGuid
    )
{
    throw _com_error ( hr );
}


#else  // _USECDODISP   


#include <afxdisp.h>

class INewMail : public COleDispatchDriver
{
public:
	INewMail() {}		// Calls COleDispatchDriver default constructor

// Operations
public:
	void Send(const VARIANT& From, const VARIANT& To, const VARIANT& Subject, const VARIANT& Body, const VARIANT& Importance);
    void AttachFile(const VARIANT& Source, const VARIANT& FileName, const VARIANT& EncodingMethod);
    void AttachURL(const VARIANT& Source, const VARIANT& ContentLocation, const VARIANT& ContentBase, const VARIANT& EncodingMethod);
};


void INewMail::Send(const VARIANT& From, const VARIANT& To, const VARIANT& Subject, const VARIANT& Body, const VARIANT& Importance)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0xa, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &From, &To, &Subject, &Body, &Importance);
}

void INewMail::AttachFile(const VARIANT& Source, const VARIANT& FileName, const VARIANT& EncodingMethod)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0xb, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Source, &FileName, &EncodingMethod);
}

void INewMail::AttachURL(const VARIANT& Source, const VARIANT& ContentLocation, const VARIANT& ContentBase, const VARIANT& EncodingMethod)
{
	static BYTE parms[] =
		VTS_VARIANT VTS_VARIANT VTS_VARIANT VTS_VARIANT;
	InvokeHelper(0xc, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &Source, &ContentLocation, &ContentBase, &EncodingMethod);
}


HRESULT
SendMail
(
IN  LPCTSTR lpszFrom,
IN  LPCTSTR lpszTo,
IN  LPCTSTR lpszSubject,
IN  LPCTSTR lpszMessage,
IN  short   nImportance 
)
{
    _ASSERTE(lpszFrom != NULL);
    _ASSERTE(lpszTo != NULL);

    HRESULT hr          =   E_FAIL;

    _bstr_t btFrom      =   _T(""),
            btTo        =   _T(""),
            btSubject   =   _T(""),
            btMessage   =   _T("");


    btFrom = lpszFrom;
    btTo = lpszTo;
    btSubject = lpszSubject;
    btMessage = lpszMessage;

    hr = CoInitialize ( NULL );

    INewMail   Mail;
    BOOL fOk = Mail.CreateDispatch ( _T("cdonts.newmail") );

    if ( fOk ) {

        variant_t   vFrom       = lpszFrom;
        variant_t   vTo         = lpszTo;
        variant_t   vSubject    = lpszSubject;
        variant_t   vImp        = nImportance;

        Mail.Send ( vFrom, vTo, vSubject, vSubject, vImp );
    }

    CoUninitialize();
    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emerr.h ===
#ifndef _EMERR_H
#define _EMERR_H

#define EMERR_DEBUGSESSION_BASE             0x200
#define EMERROR_BUSY                        MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+1)
#define EMERROR_PROCESSBEINGDEBUGGED        MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+5)
#define EMERROR_INVALIDPROCESS              MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+6)
#define EMERROR_PROCESSNOTBEINGDEBUGGED	    MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+7)
#define EMERROR_NOTOWNER                    MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+8)
#define EMERROR_SESSIONNOTOPENED            MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+9)
#define EMERROR_SESSIONNOTINITIALIZED       MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+10)

#define EMERROR_CDBSERVERSTARTFAILED        MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+11)
#define EMERROR_CONNECTIONTOSERVERFAILED    MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+12)
#define EMERROR_UNABLETOCREATELOGFILE       MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+13)
#define EMERROR_ECXFILEEXECUTIONFAILED      MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+14)
#define EMERROR_CALLBACKSCANNOTBEREGISTERED MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+15)
#define EMERROR_DISPATCHCALLBACKFAILED      MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+16)
#define EMERROR_COMMANDEXECUTIONFAILED      MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+17)
#define EMERROR_PORTINUSE					MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+18)
#define EMERROR_OBJECTNOTINITIALIZED        MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+19)
#define EMERROR_SESSIONORPHANED             MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+20)
#define EMERROR_ECXFILEOPENFAILED           MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+21)
#define EMERROR_ALTSYMPATHFAILED            MAKE_HRESULT (SEVERITY_ERROR, FACILITY_ITF, EMERR_DEBUGSESSION_BASE+22)

#define INVALID_PID -2

#endif // _EMERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emfile.cpp ===
// EmFile.cpp : Implementation of CEmFile
#include "stdafx.h"
#include "Emsvc.h"
#include "EmFile.h"

/////////////////////////////////////////////////////////////////////////////
// CEmFile

STDMETHODIMP CEmFile::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEmFile
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
        if (::InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CEmFile::CEmFile()
{
    m_hEmFile       =   INVALID_HANDLE_VALUE;
    m_bstrFileName  =   NULL;
}

CEmFile::~CEmFile()
{
    if( m_hEmFile != INVALID_HANDLE_VALUE ) {

        CloseHandle( m_hEmFile );
        m_hEmFile = INVALID_HANDLE_VALUE;
    }

    if( m_bstrFileName ) { SysFreeString( m_bstrFileName ); m_bstrFileName = NULL; }
}

STDMETHODIMP CEmFile::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    _ASSERTE( pv != NULL );
    _ASSERTE( cb != 0L );
    _ASSERTE( m_hEmFile != INVALID_HANDLE_VALUE );

    HRESULT hr  =   E_FAIL;

    __try
    {
        if( pv == NULL  || cb == 0L ) { hr = E_INVALIDARG; goto qRead; }
        if( m_hEmFile == INVALID_HANDLE_VALUE ) { hr = EMERROR_OBJECTNOTINITIALIZED; goto qRead; }

        if( ReadFile(
                      m_hEmFile,
                      pv,
                      cb,
                      pcbRead,
                      NULL
                      ) == false ) {

            hr = HRESULT_FROM_WIN32(GetLastError()); goto qRead;
        }

        hr = S_OK;
qRead:

        if( FAILED(hr) ) {

        }
        
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;

        _ASSERTE( false );
	}

	return hr;
}

STDMETHODIMP CEmFile::Write(void const *pv, ULONG cb, ULONG *pcbWritten)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::Seek(LARGE_INTEGER dlibMove, ULONG dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::SetSize(ULARGE_INTEGER libNewSize)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::Commit(DWORD grfCommitFlags)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::Revert()
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::Clone(IStream **ppstm)
{
	// TODO: Add your implementation code here

	return E_NOTIMPL;
}

STDMETHODIMP CEmFile::InitFile(BSTR bstrFileName)
{
    _ASSERTE( bstrFileName != NULL );

    HRESULT hr  =   E_FAIL;

    __try
    {

        if( bstrFileName == NULL ){ hr = E_INVALIDARG; goto qInitFile; }

        m_bstrFileName = SysAllocString( bstrFileName );
        _ASSERTE( m_bstrFileName != NULL );

        if( m_bstrFileName == NULL ) { hr = E_OUTOFMEMORY; goto qInitFile; }

        hr = CreateEmFile();
        if( FAILED(hr) ) { goto qInitFile; }

        hr = S_OK;

qInitFile:

        if( FAILED(hr) ) {

            if( m_bstrFileName ) { SysFreeString( m_bstrFileName ); m_bstrFileName = NULL; }
        }

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;

        if( m_bstrFileName ) { SysFreeString( m_bstrFileName ); m_bstrFileName = NULL; }

        _ASSERTE( false );
	}

	return hr;
}

HRESULT
CEmFile::CreateEmFile
(
IN  DWORD                   dwDesiredAccess         /*=   GENERIC_READ*/,
IN  DWORD                   dwShareMode             /*=   FILE_SHARE_READ*/,
IN  LPSECURITY_ATTRIBUTES   lpSecurityAttributes    /*=   NULL*/,
IN  DWORD                   dwCreationDisposition   /*=   OPEN_EXISTING*/,
IN  DWORD                   dwFlagsAndAttributes    /*=   FILE_ATTRIBUTE_NORMAL*/,
IN  HANDLE                  hTemplateFile           /*=   NULL*/
)
{
    HRESULT hr          =   E_FAIL;
    DWORD   dwLastRet   =   0L;

    __try
    {

        m_hEmFile = ::CreateFile ( 
                                m_bstrFileName,
                                dwDesiredAccess,
                                dwShareMode,
                                lpSecurityAttributes,
                                dwCreationDisposition,
                                dwFlagsAndAttributes,
                                hTemplateFile
                                );

        if( m_hEmFile == INVALID_HANDLE_VALUE ) {

            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto qCreateEmFile;
        }

        hr = S_OK;

qCreateEmFile:

        if( FAILED(hr) ) {

            if( m_hEmFile != INVALID_HANDLE_VALUE ) {

                CloseHandle( m_hEmFile );
                m_hEmFile = INVALID_HANDLE_VALUE;
            }
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;

        if( m_hEmFile != INVALID_HANDLE_VALUE ) {

            CloseHandle( m_hEmFile );
            m_hEmFile = INVALID_HANDLE_VALUE;
        }

        _ASSERTE( false );
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emshell\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B3CF15BC_3C19_4922_89FE_9C5E49B5EDD3__INCLUDED_)
#define AFX_STDAFX_H__B3CF15BC_3C19_4922_89FE_9C5E49B5EDD3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#include "emerr.h"
#include <htmlhelp.h>

#include "..\emsvc\emsvc_i.c"
#include "..\emsvc\emsvc.h"
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#define ISTREAM_BUFFER_SIZE     0X10000
#define MAX_TEMP_BUFFER_SIZE    256
#define DLG_PIXEL_EXTEND_SIZE   12


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B3CF15BC_3C19_4922_89FE_9C5E49B5EDD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emdebugsession.h ===
// EmDebugSession.h : Declaration of the CEmDebugSession

#ifndef __EMDEBUGSESSION_H_
#define __EMDEBUGSESSION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEmDebugSession
class ATL_NO_VTABLE CEmDebugSession : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEmDebugSession, &CLSID_EmDebugSession>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CEmDebugSession>,
	public IDispatchImpl<IEmDebugSession, &IID_IEmDebugSession, &LIBID_EMSVCLib>
{
public:
    CEMSessionThread    *m_pEmSessThrd;
    PEmObject           m_pEmObj;
    CExcepMonSessionManager *m_pASTManager;
    bool                m_bMaster;
    PGenCriticalSection m_pcs;

public:
	CEmDebugSession()
	{
        ATLTRACE(_T("CEmDebugSession::CEmDebugSession\n"));

        m_pEmSessThrd = NULL;
        m_pEmObj = NULL;
        m_pASTManager = &(_Module.m_SessionManager);
        m_bMaster = false;

        m_pcs = new CGenCriticalSection;
	}

	~CEmDebugSession()
	{
        ATLTRACE(_T("CEmDebugSession::~CEmDebugSession\n"));

        if( AmITheMaster() == true ) {

            m_pASTManager->OrphanThisSession(m_pEmObj->guidstream);
        }

        if( m_pcs ) delete m_pcs;
	}

    void Init();

    bool AmITheMaster();

    HRESULT
    StartAutomaticSession
    (
    IN  BOOL    bRecursive,
    IN  BSTR    bstrEcxFilePath,
    IN  BSTR    bstrNotificationString,
    IN  BSTR    bstrAltSymPath,
    IN  BOOL    bGenMiniDumpFile,
    IN  BOOL    bGenUserDumpFile
    );

    HRESULT
    StartManualSession
    (
    IN  BSTR    bstrEcxFilePath,
    IN  UINT    nPort,
    IN  BSTR    bstrUserName,
    IN  BSTR    bstrPassword,
    IN  BOOL    bBlockIncomingIPConnections,
    IN  BSTR    bstrAltSymPath
    );

DECLARE_REGISTRY_RESOURCEID(IDR_EMDEBUGSESSION)
DECLARE_NOT_AGGREGATABLE(CEmDebugSession)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEmDebugSession)
	COM_INTERFACE_ENTRY(IEmDebugSession)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CEmDebugSession)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEmDebugSession
public:
	STDMETHOD(AdoptOrphan)();
	HRESULT CanTakeOwnership();
	void SetMyselfAsMaster(bool bMaster = true);
	STDMETHOD(CancelDebug)(BOOL bForceCancel);
	STDMETHOD(DebugEx)(/*[in, out]*/ BSTR bstrEmObj, /*[in]*/ SessionType eSessType, /*[in]*/ BSTR bstrEcxFilePath, /*[in]*/ LONG lParam, /*[in, optional]*/ VARIANT vtUserName, /*[in, optional]*/ VARIANT vtPassword, /*[in, optional]*/ VARIANT vtPort, /*[in, optional]*/ VARIANT vtNotifyAdmin, /*[in, optional]*/ VARIANT vtAltSymPath);
	STDMETHOD(GetStatus)(/*[out]*/ BSTR bstrEmObj);
	STDMETHOD(GenerateDumpFile)(/*[in]*/ UINT neDumpType);
	STDMETHOD(StopDebug)(BOOL bForceStop);
	STDMETHOD(Debug)(BSTR bstrEmObj, SessionType eSessType);
};

#endif //__EMDEBUGSESSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emmanager.cpp ===
// EmManager.cpp : Implementation of CEmManager
#include "stdafx.h"
#include "Emsvc.h"
#include "EmManager.h"
#include "Processes.h"
#include "sahlp.h"
#include "EmDebugSession.h"
#include "EmFile.h"

/////////////////////////////////////////////////////////////////////////////
// CEmManager

STDMETHODIMP CEmManager::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEmManager
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (::InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

BOOL CALLBACK
CallbackFunc
(
IN	long	lPID,
IN	LPCTSTR lpszImagePath,
IN	LPCTSTR lpszShortName,
IN	LPCTSTR lpszDescription,
IN	LPARAM	lParam,
IN  LONG    lItem
)
{

	HRESULT		hr				=	E_FAIL;
    CEmManager  *pEMMgr			=   (CEmManager *)lParam;
	VARIANT		*pVariant		=	(VARIANT *)(pEMMgr->m_lpVariant);
	EmObject	item;
    BSTR        bstrVal			=   NULL,
				bstrTemp		=	NULL;
    PEmObject   pEmObj			=   NULL;
	BOOL		bSessPresent	=	FALSE;
	PEMSession	pEmSess			=	NULL;

	do
	{

        ZeroMemory((PVOID)&item, sizeof EmObject);

        item.hr = E_FAIL;

        if(lPID != INVALID_PID) {

            item.nId = lPID;
		    item.nStatus = pEMMgr->m_nStatus;
		    item.type = (short)pEMMgr->m_nType;

            if(lpszImagePath) {
                
                _tcsncpy(item.szName, lpszImagePath, sizeof item.szName / sizeof TCHAR);
            }

            if(lpszShortName) {
                
                _tcsncpy(item.szSecName, lpszShortName, sizeof item.szSecName / sizeof TCHAR);
            }

            if(lpszDescription) {
                
                _tcsncpy(item.szBucket1, lpszDescription, sizeof item.szBucket1 / sizeof TCHAR);
            }

            bstrTemp = CopyBSTR((LPBYTE)item.szName, _tcslen(item.szName) * sizeof TCHAR);
		    _ASSERTE(bstrTemp != NULL);

            if( bstrTemp == NULL ) { hr = E_OUTOFMEMORY; break; }

            item.hr = S_OK;

            hr = pEMMgr->m_pASTManager->GetSession(item.nId, bstrTemp, &pEmSess);
		    FAILEDHR_BREAK(hr);

            if( bstrTemp ){ ::SysFreeString ( bstrTemp ); bstrTemp = NULL; }

    		bSessPresent = (hr == S_OK);
        }

        if( bSessPresent && // We will point to this only if it present in the
                            // AST and the state is "BEING DEBUGGED"
            pEmSess->pEmObj->nStatus & STAT_SESS_DEBUG_IN_PROGRESS )
        {
            pEmObj = pEmSess->pEmObj;
        }
        else
        {
            pEmObj = &item;
        }

        bstrVal = CopyBSTR ( (LPBYTE)pEmObj, sizeof EmObject );

        if( bstrVal == NULL ) { hr = E_OUTOFMEMORY; break; }

        hr = ::SafeArrayPutElement ( pVariant->parray, &lItem, bstrVal );
        FAILEDHR_BREAK(hr);

        if( bstrVal ) { ::SysFreeString ( bstrVal ); bstrVal = NULL; }
    }
    while ( false );

    if( bstrVal ) { ::SysFreeString ( bstrVal ); bstrVal = NULL; }
    if( bstrTemp ) { ::SysFreeString( bstrTemp ); bstrTemp = NULL; }
    if( FAILED(hr) ){ return FALSE; }

    return TRUE;
}

STDMETHODIMP
CEmManager::EnumObjects
(
IN	EmObjectType	eObjectType,
OUT	VARIANT			*lpVariant
)
{
    ATLTRACE(_T("CEmManager::EnumObjects\n"));

	_ASSERTE( lpVariant != NULL );

    HRESULT	hr	=	E_FAIL;

	m_pcs->WriteLock();

	__try {

		do
		{
			if( lpVariant == NULL ){
				hr = E_INVALIDARG;
				break;
			}

			switch( eObjectType )
			{
			case EMOBJ_SERVICE:
				m_lpVariant = lpVariant;
				hr = EnumSrvcs();
				break;

			case EMOBJ_PROCESS:
				m_lpVariant = lpVariant;
				hr = EnumProcs();
                hr = S_OK;
				break;

			case EMOBJ_LOGFILE:
				hr = EnumLogFiles ( lpVariant );
				break;

			case EMOBJ_MINIDUMP:
			case EMOBJ_USERDUMP:
                hr = EnumDumpFiles ( lpVariant );
				break;

			case EMOBJ_CMDSET:
				hr = EnumCmdSets ( lpVariant );
				break;

            case EMOBJ_MSINFO:
                hr = EnumMsInfoFiles( lpVariant );
                break;

			default:
				hr = E_INVALIDARG;
			}
		}
		while( false );

	}
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	m_pcs->WriteUnlock();

	return hr;
}

HRESULT
CEmManager::EnumProcs()
{
    ATLTRACE(_T("CEmManager::EnumProcs\n"));

    _ASSERTE( m_lpVariant != NULL );

    USES_CONVERSION;

	HRESULT	        hr			    =	E_FAIL;
	DWORD	        dwLastRet	    =	0L;
	DWORD	        dwNumbProcs	    =	0L,
                    dwNumbStpSess   =   0L;
    POSITION        pos             =   NULL;
    BSTR            bstrVal         =   NULL;
    LONG            lItem           =   0L;
    PEMSession      pEmSess         =   NULL;
	BOOL			bSACreated		=	FALSE;
    EmObject        TempEmObj;

	m_pcs->WriteLock();

    __try {

		do
		{
			if( m_lpVariant == NULL ){
				hr = E_UNEXPECTED;
				break;
			}

			dwLastRet = GetNumberOfRunningApps( &dwNumbProcs );
			FAILEDDW_BREAK(dwLastRet);

			hr = m_pASTManager->GetNumberOfStoppedSessions(&dwNumbStpSess);
			FAILEDHR_BREAK(hr);

			hr = Variant_CreateOneDim ( m_lpVariant, (dwNumbProcs + dwNumbStpSess), VT_BSTR );
			FAILEDHR_BREAK(hr);
			bSACreated = TRUE;

            m_nStatus = STAT_SESS_NOT_STARTED_RUNNING;
			m_nType = EMOBJ_PROCESS;

   			dwLastRet = EnumRunningProcesses( CallbackFunc, (LPARAM)this );

			if(dwLastRet != 0){

				hr = HRESULT_FROM_WIN32( dwLastRet );
			}

            hr = m_pASTManager->GetFirstStoppedSession(&pos, NULL, &pEmSess);
			lItem = dwNumbProcs;

            ZeroMemory( (void *)&TempEmObj, sizeof EmObject );
            TempEmObj.hr = E_FAIL;

			while( dwNumbStpSess ){

                if( pEmSess->pEmObj->type & EMOBJ_PROCESS ){

    				bstrVal = CopyBSTR ( (LPBYTE)pEmSess->pEmObj, sizeof EmObject );
                }
                else {

    				bstrVal = CopyBSTR ( (LPBYTE)&TempEmObj, sizeof EmObject );
                }

				if( bstrVal == NULL ){
					hr = E_OUTOFMEMORY;
					break;
				}

				hr = ::SafeArrayPutElement ( m_lpVariant->parray, &lItem, bstrVal );
				FAILEDHR_BREAK(hr);

				if( bstrVal ){
					::SysFreeString ( bstrVal );
                    bstrVal = NULL;
				}

                ++lItem;
				--dwNumbStpSess;
				m_pASTManager->GetNextStoppedSession(&pos, NULL, &pEmSess);
			}
		}
		while ( false );

		if( FAILED(hr) ) {

			Variant_DestroyOneDim(m_lpVariant);
			bSACreated = FALSE;
		}

		if( bstrVal ){
			::SysFreeString ( bstrVal );
		}

	}
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;

		if(bSACreated) {

			Variant_DestroyOneDim(m_lpVariant);
			bSACreated = FALSE;
		}

		if( bstrVal ){
			::SysFreeString ( bstrVal );
            bstrVal = NULL;
		}

		_ASSERTE( false );
	}

	m_pcs->WriteUnlock();

	return hr;
}

HRESULT
CEmManager::EnumSrvcs()
{
    ATLTRACE(_T("CEmManager::EnumSrvcs\n"));

	_ASSERTE( m_lpVariant != NULL );

    USES_CONVERSION;

	HRESULT	hr			        =	E_FAIL;
	DWORD	dwLastRet	        =	0L;
	DWORD	dwNumbSrvcs	        =	0L,
            dwNumbStoppedSrvcs  =   0L;
	BOOL	bSACreated	        =	FALSE;


    DWORD	    dwNumbStpSess	=	0L;
    POSITION    pos             =   NULL;
    BSTR        bstrVal         =   NULL;
    LONG        lItem           =   0L;
    PEMSession  pEmSess         =   NULL;
    EmObject    TempEmObj;

	m_pcs->WriteLock();

	__try {

		do
		{
			if( m_lpVariant == NULL ){
				hr = E_INVALIDARG;
				break;
			}

			m_nType = EMOBJ_SERVICE;

            dwLastRet = GetNumberOfServices( &dwNumbStoppedSrvcs, SERVICE_WIN32, SERVICE_INACTIVE );
			FAILEDDW_BREAK(dwLastRet);

            dwLastRet = GetNumberOfServices( &dwNumbSrvcs, SERVICE_WIN32, SERVICE_ACTIVE );
			FAILEDDW_BREAK(dwLastRet);

			hr = m_pASTManager->GetNumberOfStoppedSessions(&dwNumbStpSess);
			FAILEDHR_BREAK(hr);

			hr = Variant_CreateOneDim ( m_lpVariant, dwNumbSrvcs + dwNumbStoppedSrvcs + dwNumbStpSess, VT_BSTR );
			FAILEDHR_BREAK(hr);
			bSACreated = TRUE;

			m_nStatus = STAT_SESS_NOT_STARTED_RUNNING;
   			dwLastRet = EnumServices( CallbackFunc, (LPARAM)this, SERVICE_ACTIVE, 0L );
			m_nStatus = STAT_SESS_NOT_STARTED_NOTRUNNING;
   			dwLastRet = EnumServices( CallbackFunc, (LPARAM)this, SERVICE_INACTIVE, dwNumbSrvcs );

            hr = m_pASTManager->GetFirstStoppedSession(&pos, NULL, &pEmSess);
			lItem = dwNumbSrvcs + dwNumbStoppedSrvcs;

            ZeroMemory( (void *)&TempEmObj, sizeof EmObject );
            TempEmObj.hr = E_FAIL;

			while( dwNumbStpSess ){

                if( pEmSess->pEmObj->type & EMOBJ_SERVICE ){

    				bstrVal = CopyBSTR ( (LPBYTE)pEmSess->pEmObj, sizeof EmObject );
                }
                else {

    				bstrVal = CopyBSTR ( (LPBYTE)&TempEmObj, sizeof EmObject );
                }

				if( bstrVal == NULL ){
					hr = E_OUTOFMEMORY;
					break;
				}

				hr = ::SafeArrayPutElement ( m_lpVariant->parray, &lItem, bstrVal );
				FAILEDHR_BREAK(hr);

				if( bstrVal ){
					::SysFreeString ( bstrVal );
                    bstrVal = NULL;
				}

                ++lItem;
				--dwNumbStpSess;
				m_pASTManager->GetNextStoppedSession(&pos, NULL, &pEmSess);
			}

			if(dwLastRet == FALSE){ // The callback returned false.. otherwise we would
									// get the error value (GetLastError())
				hr = S_FALSE;
			}
			else {

                hr = HRESULT_FROM_WIN32( dwLastRet );
			}

		}
		while ( false );

		if(FAILED(hr)) {

            if( bSACreated ) Variant_DestroyOneDim(m_lpVariant);
			bSACreated = FALSE;
		}
	}

	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;

		if(bSACreated) {

			Variant_DestroyOneDim(m_lpVariant);
			bSACreated = FALSE;
		}

		_ASSERTE( false );
	}


	m_pcs->WriteUnlock();

	return hr;
}

STDMETHODIMP
CEmManager::OpenSession
(
IN OUT  BSTR            bstrEmObj,
OUT     IEmDebugSession **ppEmDebugSession
)
{
    ATLTRACE(_T("CEmManager::OpenSession\n"));

    _ASSERTE(bstrEmObj != NULL);
    _ASSERTE(ppEmDebugSession != NULL);

    HRESULT			hr              =   E_FAIL;
    PEmObject		pEmNewSessObj   =   NULL;
    PEMSession      pNewEmSess      =   NULL;
	BOOL			bBeingDebugged	=	FALSE;
    PEmObject       pEmObj          =   NULL;

    CComObject<CEmDebugSession> *pEmDbgSess =   NULL;

	m_pcs->WriteLock();

	__try {

		do
		{
			if( bstrEmObj == NULL ||
				ppEmDebugSession == NULL ){
            
				hr = E_INVALIDARG;
				break;
			}

            pEmObj = GetEmObj(bstrEmObj);

			//
			// Check the session table if it is already being debugged
			//
//			hr = m_pASTManager->IsAlreadyBeingDebugged(pEmObj);
//            if( FAILED(hr) && hr != EMERROR_INVALIDPROCESS ) break;

            hr = CheckIfCanOpenSession( pEmObj );
            FAILEDHR_BREAK(hr);

			bBeingDebugged = (hr == S_FALSE);

			hr = CComObject<CEmDebugSession>::CreateInstance(&pEmDbgSess);
			FAILEDHR_BREAK(hr);

            pEmDbgSess->AddRef();

			if( bBeingDebugged == FALSE ){ // it is not being debugged already.

				hr = m_pASTManager->AddSession(pEmObj, &pNewEmSess);
				FAILEDHR_BREAK(hr);

				hr = S_OK;
			}
			else{ // it is already being debugged

				//
				// This will get the updated status too..
				//
				hr = m_pASTManager->GetSession(pEmObj->nId, pEmObj->szName, &pNewEmSess);
				FAILEDHR_BREAK(hr);

                hr = S_FALSE;

/**********

                hr = m_pASTManager->IsSessionOrphaned(pNewEmSess->pEmObj->guidstream);
				FAILEDHR_BREAK(hr);

                if( hr == S_OK ) {} // session is orphaned..
                else if( hr == S_FALSE ) {} // session is not orphaned..
***********/
			}

			pEmNewSessObj = pNewEmSess->pEmObj;
            pEmDbgSess->m_pEmObj = pEmNewSessObj;
			pEmDbgSess->m_pEmSessThrd = (CEMSessionThread *)pNewEmSess->pThread;

		}
		while( false );

		if(FAILED(hr)){

			if(pEmDbgSess){

				pEmDbgSess->Release();
				pEmDbgSess = NULL;
			}
		}
		else{

            //
            // This will update all the fields of EmObject..
            //
            ::SysFreeString(bstrEmObj);
            bstrEmObj = CopyBSTR((LPBYTE)pNewEmSess->pEmObj, sizeof EmObject);

			*ppEmDebugSession = pEmDbgSess; // Client will take care of Release.
		}
	} // __try

	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;

		if(pEmDbgSess){

			pEmDbgSess->Release();
			pEmDbgSess = NULL;
		}

		_ASSERTE( false );
	}

	m_pcs->WriteUnlock();

    return hr;
}

STDMETHODIMP CEmManager::DeleteSession(BSTR bstrEmObj)
{
    ATLTRACE(_T("CEmManager::CloseSession\n"));

    _ASSERTE(bstrEmObj != NULL);

	HRESULT	    hr	    =	E_FAIL;
    PEmObject   pEmObj  =   NULL;

	m_pcs->ReadLock();

	__try {

		if(bstrEmObj == NULL){ 
			
			hr = E_INVALIDARG;
		}
		else {

            pEmObj = GetEmObj(bstrEmObj);
			hr = m_pASTManager->RemoveSession(pEmObj->guidstream);
		}
	}

	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	m_pcs->ReadUnlock();

	return hr;
}

STDMETHODIMP CEmManager::EnumObjectsEx(BSTR bstrEmObj, VARIANT *lpVariant)
{
    ATLTRACE(_T("CEmManager::EnumObjectsEx\n"));

	_ASSERTE( lpVariant != NULL );
    _ASSERTE( bstrEmObj != NULL );

    HRESULT	    hr	                            =	E_FAIL;
    PEmObject   pEmObj                          =   NULL;
    TCHAR       szSearchString[_MAX_PATH + 1]   =   _T("");
    TCHAR       szEmDir[_MAX_PATH+1]            =   _T("");
    TCHAR       szEmFileExt[_MAX_EXT+1]     =   _T("");

	m_pcs->WriteLock();

	__try {

		do
		{
			if( bstrEmObj == NULL ||
                lpVariant == NULL ) {

                hr = E_INVALIDARG;
				break;
			}

            pEmObj = GetEmObj(bstrEmObj);
            _ASSERTE(pEmObj != NULL);

			switch( pEmObj->type )
			{
			case EMOBJ_SERVICE:
				break;

			case EMOBJ_PROCESS:
                if( pEmObj->nStatus & STAT_SESS_STOPPED ) {

                    hr = EnumSessions( pEmObj, lpVariant );
                }

				break;

			case EMOBJ_LOGFILE:
                _Module.GetEmDirectory( EMOBJ_LOGFILE, szEmDir, _MAX_PATH, szEmFileExt, _MAX_EXT );

                GetUniqueFileName(
                                    pEmObj,
                                    szSearchString,
                                    NULL,
                                    szEmFileExt,
                                    true
                                    );

                _tcsncat( szEmDir, _T("\\"), _MAX_PATH );
                _tcsncat( szEmDir, szSearchString, _MAX_PATH );

                hr = EnumLogFiles ( lpVariant, szEmDir );
				break;

			case EMOBJ_MINIDUMP:
			case EMOBJ_USERDUMP:

                _Module.GetEmDirectory( EMOBJ_MINIDUMP, szEmDir, _MAX_PATH, szEmFileExt, _MAX_EXT );

                GetUniqueFileName(
                                    pEmObj,
                                    szSearchString,
                                    NULL,
                                    szEmFileExt,
                                    true
                                    );

                _tcsncat( szEmDir, _T("\\"), _MAX_PATH );
                _tcsncat( szEmDir, szSearchString, _MAX_PATH );

                hr = EnumDumpFiles ( lpVariant, szEmDir );
				break;

			case EMOBJ_MSINFO:

                _Module.GetEmDirectory( EMOBJ_MSINFO, szEmDir, _MAX_PATH, szEmFileExt, _MAX_EXT );

                GetUniqueFileName(
                                    pEmObj,
                                    szSearchString,
                                    NULL,
                                    szEmFileExt,
                                    true
                                    );

                _tcsncat( szEmDir, _T("\\"), _MAX_PATH );
                _tcsncat( szEmDir, szSearchString, _MAX_PATH );

                hr = EnumMsInfoFiles( lpVariant, szEmDir );
				break;

			case EMOBJ_CMDSET:
				hr = EnumCmdSets ( lpVariant );
				break;

			default:
				hr = E_INVALIDARG;
			}
		}
		while( false );

	}
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	m_pcs->WriteUnlock();

	return hr;
}

HRESULT
CEmManager::EnumSessions
(
IN	PEmObject	pEmObj,
OUT VARIANT		*lpVariant
)
{
    ATLTRACE(_T("CEmManager::EnumSessions\n"));

	_ASSERTE( pEmObj != NULL );
	_ASSERTE( lpVariant != NULL );

	HRESULT	hr	=	E_FAIL;
	DWORD	dwNumbSess	=	0L;
	long    lItem		=	0L;
	PEMSession	pEmSess	=	NULL;
    POSITION    pos     =   NULL;
    BSTR        bstrVal =   NULL;
    bool        bVariantCreated =   false;
    EmObject    TempEmObj;

	m_pcs->WriteLock();

    __try {

		if( pEmObj == NULL ||
			lpVariant == NULL ) {

			hr = E_INVALIDARG;
            goto qEnumSessions;
		}

		hr = m_pASTManager->GetNumberOfSessions(&dwNumbSess);
		if(hr != S_OK) goto qEnumSessions; // S_FALSE => no sessions.

		hr = Variant_CreateOneDim ( lpVariant, dwNumbSess, VT_BSTR );
        if(FAILED(hr)) goto qEnumSessions;
        bVariantCreated = true;

		hr = m_pASTManager->GetFirstSession(&pos, &pEmSess);
		lItem = 0L;

        ZeroMemory( (void *)&TempEmObj, sizeof EmObject );
        TempEmObj.hr = E_FAIL;

		while( dwNumbSess ){

			if( HIWORD(pEmSess->pEmObj->nStatus) & HIWORD(pEmObj->nStatus) ) {

				bstrVal = CopyBSTR ( (LPBYTE)pEmSess->pEmObj, sizeof EmObject );
			}
            else {
				bstrVal = CopyBSTR ( (LPBYTE)&TempEmObj, sizeof EmObject );
            }

            if( bstrVal == NULL ) { hr = E_OUTOFMEMORY; goto qEnumSessions; }

            hr = ::SafeArrayPutElement ( lpVariant->parray, &lItem, bstrVal );
			if(FAILED(hr)) goto qEnumSessions;

			if( bstrVal ){
				::SysFreeString ( bstrVal );
				bstrVal = NULL;
			}

            ++lItem;
			--dwNumbSess;
			m_pASTManager->GetNextSession(&pos, &pEmSess);
		}

qEnumSessions:
	    if( FAILED(hr) ) {

            if( bVariantCreated == true ) Variant_DestroyOneDim(lpVariant);
	    }

	}
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		if( bVariantCreated == true ) Variant_DestroyOneDim(lpVariant);

        hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	m_pcs->WriteUnlock();

    return hr;
}

STDMETHODIMP CEmManager::GetEmFileInterface(BSTR bstrEmObj, IStream **ppstrm)
{
    _ASSERTE( bstrEmObj != NULL );
    _ASSERTE( ppstrm != NULL );

    HRESULT     hr                      =   E_FAIL;
    PEmObject   pEmObj                  =   NULL;
    TCHAR       szEmDir[_MAX_PATH+1]    =   _T("");

    CComObject<CEmFile> *pEmFile        =   NULL;

	m_pcs->WriteLock();

    __try
    {
        if( bstrEmObj == NULL || ppstrm == NULL ) {

            hr = E_INVALIDARG; goto qGetEmFileInterface;
        }

        pEmObj = GetEmObj(bstrEmObj);
        *ppstrm = NULL;

		hr = CComObject<CEmFile>::CreateInstance(&pEmFile);
        if( FAILED(hr) ) { goto qGetEmFileInterface; }

        pEmFile->AddRef();

        hr = _Module.GetEmDirectory( (EmObjectType)pEmObj->type, szEmDir, _MAX_PATH, NULL, 0L );
        if( FAILED(hr) ) { goto qGetEmFileInterface; }

        _tcsncat( szEmDir, _T("\\"), _MAX_PATH ); 
        _tcsncat( szEmDir, pEmObj->szName, _MAX_PATH ); 

        hr = pEmFile->InitFile( szEmDir );
        if( FAILED(hr) ) { goto qGetEmFileInterface; }

        *ppstrm = pEmFile;
        hr = S_OK;

qGetEmFileInterface:

        if( FAILED(hr) ) {

            if( pEmFile ) { pEmFile->Release(); }
        }
	}
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	m_pcs->WriteUnlock();

    return hr;
}

STDMETHODIMP
CEmManager::GenerateDumpFile
(
IN  BSTR bstrEmObj,
IN  UINT nDumpType
)
{
    _ASSERTE( bstrEmObj != NULL );

    HRESULT         hr              =   E_FAIL;
    IEmDebugSession *pIEmDbgSess    =   NULL;
    bool            bCallDeleteSess =   false;

	m_pcs->ReadLock();

    __try
    {
        if( bstrEmObj == NULL ) { hr = E_INVALIDARG; goto qGenerateDumpFile; }

        hr = OpenSession( bstrEmObj, &pIEmDbgSess );
        bCallDeleteSess = (hr == S_OK);

        if( pIEmDbgSess ) {

            hr = pIEmDbgSess->GenerateDumpFile( nDumpType );
        }

qGenerateDumpFile:
        if( FAILED(hr) ) {

            if( pIEmDbgSess ) { pIEmDbgSess->Release(); pIEmDbgSess = NULL; }
        }

//        if( bCallDeleteSess ) { DeleteSession( bstrEmObj ); }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;

        if( pIEmDbgSess ) { pIEmDbgSess->Release(); pIEmDbgSess = NULL; }
//        if( bCallDeleteSess ) { DeleteSession( bstrEmObj ); }

        _ASSERTE( false );
	}

	m_pcs->ReadUnlock();

	return hr;
}

HRESULT
CEmManager::CheckIfCanOpenSession
(
IN  PEmObject pEmObj
)
{
    HRESULT hr          =   E_FAIL,
            hrTemp      =   E_FAIL;
    DWORD   dwLastRet   =   0L;
    bool    bValidImage =   false;
    PEMSession  pEmSess =   NULL;
    POSITION    pos     =   NULL;

	m_pcs->ReadLock();

    __try
    {

        if( pEmObj->type != EMOBJ_SERVICE && pEmObj->type != EMOBJ_PROCESS ) {

            hr = E_INVALIDARG;
            goto qCheckIfCanOpenSession;
        }

        if( pEmObj->type == EMOBJ_PROCESS ) {

            IsValidProcess( pEmObj->nId, pEmObj->szName, &bValidImage );
    
            hrTemp = m_pASTManager->GetSession(
                                        pEmObj->nId,
                                        pEmObj->szName,
                                        &pEmSess
                                        );

            if( !bValidImage ) { // pid and image name does not match.. :(

                if( hrTemp == S_FALSE ) { // Not present in the AST, as well.

                    hr = EMERROR_INVALIDPROCESS;
                }
                else { // is present in the AST..

                    hr = S_FALSE;
                }

                goto qCheckIfCanOpenSession;
            }

            if( bValidImage ) { // pid and image name match..

                if( hrTemp == S_FALSE ) { // not present in the AST, so it can be added..

                    hr = S_OK;
                }
                else { // present in the AST..

                    if( HIWORD(pEmSess->pEmObj->nStatus) >= HIWORD(STAT_SESS_DEBUG_IN_PROGRESS) )
                        hr = S_FALSE;
                    else
                        hr = S_OK;
                }

                goto qCheckIfCanOpenSession;
            }
        }

        if( pEmObj->type == EMOBJ_SERVICE ) {

            hr = m_pASTManager->GetNumberOfSessions( &dwLastRet );
            if( FAILED(hr) ) { goto qCheckIfCanOpenSession; }

		    hr = m_pASTManager->GetFirstSession(&pos, &pEmSess);
            if( FAILED(hr) ) { goto qCheckIfCanOpenSession; }

            hr = S_OK;
		    while( dwLastRet ) {

                if( _tcsicmp( pEmObj->szName, pEmSess->pEmObj->szName ) == 0 &&
                    _tcsicmp( pEmObj->szSecName, pEmSess->pEmObj->szSecName ) == 0 ) {

                    hr = S_FALSE;
                    goto qCheckIfCanOpenSession;
                }

			    --dwLastRet;
			    m_pASTManager->GetNextSession(&pos, &pEmSess);
		    }
        }

qCheckIfCanOpenSession:
        if(FAILED(hr)){}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;

        _ASSERTE( false );
	}

	m_pcs->ReadUnlock();

	return hr;
}

STDMETHODIMP CEmManager::DeleteFile(BSTR bstrEmObj)
{
    _ASSERTE( bstrEmObj != NULL );

    HRESULT     hr                  =   E_FAIL;
    LPTSTR      lpszFullFileName    =   NULL;
    PEmObject   pEmObj              =   NULL;
    ULONG       lStrLen             =   0L;

    m_pcs->ReadLock();
    
    __try
    {
        if( bstrEmObj == NULL ) {

            hr = E_INVALIDARG;
            goto qDeleteFile;
        }

        pEmObj = GetEmObj(bstrEmObj);

        if( pEmObj->type != EMOBJ_LOGFILE &&
            pEmObj->type != EMOBJ_MINIDUMP &&
            pEmObj->type != EMOBJ_USERDUMP &&
            pEmObj->type != EMOBJ_MSINFO
            ) {

            hr = E_INVALIDARG;
            goto qDeleteFile;
        }
        
        lStrLen = _tcslen(pEmObj->szName);
        lStrLen += _tcslen(pEmObj->szSecName) + 1;

        lpszFullFileName = new TCHAR[lStrLen + 1];
        if( !lpszFullFileName ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto qDeleteFile;
        }

        _stprintf( lpszFullFileName, _T("%s\\%s"), pEmObj->szSecName, pEmObj->szName );
        if(!::DeleteFile( lpszFullFileName )) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto qDeleteFile;
        }

        hr = S_OK;

qDeleteFile:
        if( lpszFullFileName ) { delete [] lpszFullFileName; lpszFullFileName = NULL; }
        if(FAILED(hr)){}

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;
        if( lpszFullFileName ) { delete [] lpszFullFileName; lpszFullFileName = NULL; }

        _ASSERTE( false );
	}

	m_pcs->ReadUnlock();

	return hr;
}

STDMETHODIMP
CEmManager::MakeNFO
(
IN  BSTR bstrPath,
IN  BSTR bstrMachineName,
IN  BSTR bstrCategories
)
{
    _ASSERTE( bstrCategories != NULL );

    HRESULT     hr              =   E_FAIL;
    BSTR        bstrFilePath    =   NULL,
                bstrMacName     =   NULL;
    BOOL        bMsinfoCreated  =   FALSE;
    HINSTANCE   hi              =   NULL;
    
    TCHAR       szMsInfo32Path[_MAX_PATH+1] =   _T("");
    ULONG       cchMsInfo32Path             =   _MAX_PATH;
    LPTSTR      lpszCmdLine                 =   NULL;
    ULONG       lCmdLineLen                 =   0L;
    LPCTSTR     lpszNfoExt                  =   _T("/nfo ");

    m_pcs->ReadLock();

    __try
    {
        if( !bstrCategories ) { hr = E_INVALIDARG; goto qMakeNFO; }

        if( bstrPath ) {

            bstrFilePath = SysAllocString( bstrPath );
            if( !bstrFilePath ) { hr = E_OUTOFMEMORY; goto qMakeNFO; }
        }
        else {

            hr = _Module.GetTempEmFileName( EMOBJ_MSINFO, bstrFilePath );
            if( FAILED(hr) ) { goto qMakeNFO; }
        }

        if( bstrMachineName ) {

            bstrMacName = SysAllocString( bstrMachineName );
            if( !bstrMacName ) { hr = E_OUTOFMEMORY; goto qMakeNFO; }
        }
        else {

            hr = _Module.GetCompName( bstrMacName );
            if( FAILED(hr) ) { goto qMakeNFO; }
        }
/*
	    hr = CoCreateInstance(
                        CLSID_SystemInfo,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_ISystemInfo,
                        (LPVOID *) &pISystemInfo
                        );

        if( FAILED(hr) ) { goto qMakeNFO; }

	    // Call the make_nfo system Interface
	    //hrReturn=pISystemInfo->make_nfo(bstrPath,bstrMachineName);
	    hr = pISystemInfo->MakeNFO(bstrFilePath, bstrMachineName, bstrCategories);
*/

        STARTUPINFO			sp;
	    PROCESS_INFORMATION pi;

        ZeroMemory(&sp, sizeof(sp));
        ZeroMemory(&pi, sizeof(pi));

        hr = _Module.GetMsInfoPath( szMsInfo32Path, &cchMsInfo32Path );
        if( FAILED(hr) ) { goto qMakeNFO; }

        //
        // msinfo32.exe /nfo <filepath> <- silent file save ( no UI ).
        // msinfo32.exe /categories: +xxx /nfo <filepath>
        //

        lCmdLineLen = _tcslen(szMsInfo32Path)
                    + SysStringLen( bstrCategories )
                    + SysStringLen( bstrFilePath )
                    + _tcslen(lpszNfoExt)
                    + 4 // This is for quotes..
                    + 1;

        lpszCmdLine = new TCHAR[ lCmdLineLen ];
        if( !lpszCmdLine ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto qMakeNFO;
        }

        _stprintf(  lpszCmdLine,
                    _T("\"%s\" %s %s \"%s\""),
                    szMsInfo32Path,
                    (LPCTSTR)bstrCategories,
                    lpszNfoExt,
                    (LPCTSTR)bstrFilePath
                    );

	    bMsinfoCreated = CreateProcess(// This has to be obtained from the registry...
			                        NULL,
			                        lpszCmdLine,
			                        NULL,
			                        NULL,
			                        FALSE,
			                        CREATE_NEW_PROCESS_GROUP,
			                        NULL,
			                        NULL,
			                        &sp,
			                        &pi
			                        );

        if( !bMsinfoCreated ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto qMakeNFO;
        }

        hr = S_OK;

qMakeNFO:

        if( lpszCmdLine ) { delete [] lpszCmdLine; lpszCmdLine = NULL; }
        if( bstrFilePath ) { SysFreeString( bstrFilePath ); }
        if( bstrMacName ) { SysFreeString( bstrMacName ); }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;

        if( lpszCmdLine ) { delete [] lpszCmdLine; lpszCmdLine = NULL; }
        if( bstrFilePath ) { SysFreeString( bstrFilePath ); }
        if( bstrMacName ) { SysFreeString( bstrMacName ); }

        _ASSERTE( false );
	}

	m_pcs->ReadUnlock();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emfile.h ===
// EmFile.h : Declaration of the CEmFile

#ifndef __EMFILE_H_
#define __EMFILE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEmFile
class ATL_NO_VTABLE CEmFile : 
    public IStream,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEmFile, &CLSID_EmFile>,
	public ISupportErrorInfo,
	public IDispatchImpl<IEmFile, &IID_IEmFile, &LIBID_EMSVCLib>
{
private:
    HANDLE  m_hEmFile;
    BSTR    m_bstrFileName;

private:

HRESULT
CreateEmFile
(
IN  DWORD                   dwDesiredAccess         =   GENERIC_READ,
IN  DWORD                   dwShareMode             =   FILE_SHARE_READ,
IN  LPSECURITY_ATTRIBUTES   lpSecurityAttributes    =   NULL,
IN  DWORD                   dwCreationDisposition   =   OPEN_EXISTING,
IN  DWORD                   dwFlagsAndAttributes    =   FILE_ATTRIBUTE_NORMAL,
IN  HANDLE                  hTemplateFile           =   NULL
);

public:
	CEmFile();
	~CEmFile();

DECLARE_REGISTRY_RESOURCEID(IDR_EMFILE)
DECLARE_NOT_AGGREGATABLE(CEmFile)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEmFile)
	COM_INTERFACE_ENTRY(IEmFile)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IStream)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEmFile
public:
	STDMETHOD(InitFile)(BSTR bstrFileName);
	STDMETHOD(Clone)(/*[out]*/ IStream **ppstm);
	STDMETHOD(Stat)(/*[out]*/ STATSTG *pstatstg, DWORD grfStatFlag);
	STDMETHOD(UnlockRegion)(/*[in]*/ ULARGE_INTEGER libOffset, /*[in]*/ ULARGE_INTEGER cb, /*[in]*/ DWORD dwLockType);
	STDMETHOD(LockRegion)(/*[in]*/ ULARGE_INTEGER libOffset, /*[in]*/ ULARGE_INTEGER cb, /*[in]*/ DWORD dwLockType);
	STDMETHOD(Revert)(void);
	STDMETHOD(Commit)(/*[in]*/ DWORD grfCommitFlags);
	STDMETHOD(CopyTo)(/*[in]*/ IStream *pstm, /*[in]*/ ULARGE_INTEGER cb, /*[out]*/ ULARGE_INTEGER *pcbRead, /*[out]*/ ULARGE_INTEGER *pcbWritten);
	STDMETHOD(SetSize)(/*[in]*/ ULARGE_INTEGER libNewSize);
	STDMETHOD(Seek)(/*[in]*/ LARGE_INTEGER dlibMove, /*[in]*/ ULONG dwOrigin, /*[out]*/ ULARGE_INTEGER *plibNewPosition);
	STDMETHOD(Write)(/*[in]*/ void const *pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbWritten);
	STDMETHOD(Read)(/*[out]*/ void *pv, /*[in]*/ ULONG cb, /*[out]*/ ULONG *pcbRead);
};

#endif //__EMFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emmanager.h ===
// EmManager.h : Declaration of the CEmManager

#ifndef __EMMANAGER_H_
#define __EMMANAGER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEmManager
class ATL_NO_VTABLE CEmManager : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEmManager, &CLSID_EmManager>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CEmManager>,
	public IDispatchImpl<IEmManager, &IID_IEmManager, &LIBID_EMSVCLib>
{
public:
    VARIANT *m_lpVariant;
    int     m_nStatus;
    int     m_nType;
    CExcepMonSessionManager *m_pASTManager;

public:
	CEmManager()
	{
        ATLTRACE(_T("CEmManager::CEmManager\n"));

        m_pASTManager = &(_Module.m_SessionManager);
        m_pcs = new CGenCriticalSection;
	}

	~CEmManager()
	{
        ATLTRACE(_T("CEmManager::~CEmManager\n"));

        delete m_pcs;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_EMMANAGER)
DECLARE_NOT_AGGREGATABLE(CEmManager)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEmManager)
	COM_INTERFACE_ENTRY(IEmManager)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CEmManager)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEmManager
public:
	STDMETHOD(MakeNFO)(/*[in]*/ BSTR bstrPath, /*[in]*/ BSTR bstrMachineName, /*[in]*/ BSTR bstrCategories);
	STDMETHOD(DeleteFile)(/*[in, out]*/ BSTR bstrEmObj);
	HRESULT CheckIfCanOpenSession( PEmObject pEmObj );
	STDMETHOD(GenerateDumpFile)(BSTR bstrEmObj, UINT nDumpType);
	STDMETHOD(GetEmFileInterface)(BSTR bstrEmObj, IStream **ppstrm);
	STDMETHOD(EnumObjectsEx)(/*[in]*/ BSTR bstrEmObj, /*[out]*/ VARIANT *lpVariant);
	STDMETHOD(DeleteSession)(BSTR bstrEmObj);
	STDMETHOD(OpenSession)(BSTR bstrEmObj, IEmDebugSession **ppEmDebugSession);
	STDMETHOD(EnumObjects)(EmObjectType eObjectType, VARIANT *lpVariant);
private:
	HRESULT EnumProcs();
    HRESULT EnumSrvcs();
    HRESULT EnumMsInfoFiles( VARIANT *lpVariant, LPCTSTR lpSearchString = NULL );
    HRESULT EnumLogFiles ( VARIANT*, LPCTSTR lpszSearchString = NULL );
    HRESULT EnumDumpFiles ( VARIANT*, LPCTSTR lpszSearchString = NULL );
    HRESULT EnumCmdSets ( VARIANT*, LPCTSTR lpszSearchString = NULL );
	HRESULT EnumSessions ( PEmObject, VARIANT* );

    HRESULT CEmManager::FillMsInfoFileInfo
    (
        LPCTSTR             lpszMsInfoFileDir,
        LPWIN32_FIND_DATA   lpFindData, 
        EmObject            *pEmObject
    );

    HRESULT CEmManager::FillDumpFileInfo
    (
        LPCTSTR             lpszDumpFileDir,
        LPWIN32_FIND_DATA   lpFindData, 
        EmObject            *pEmObject
    );

    HRESULT FillLogFileInfo
    (
        LPCTSTR             lpszLogFileDir,
        LPWIN32_FIND_DATA   lpFindData, 
        EmObject            *pEmObject
    );

    HRESULT ScanCmdfile ( 
        LPCTSTR             lpszCmdFileDir,
        LPWIN32_FIND_DATA   lpFindData, 
        EmObject            *pEmObject
    );

    HRESULT EnumFiles (
        LPTSTR              lpszDirectory,
        LPTSTR              lpszExt,
        LPWIN32_FIND_DATA   *lppFindData,
        LONG                *lpFiles
    );

    HRESULT PackageFilesToVariant ( 
        EmObjectType        eObjectType,
        LPWIN32_FIND_DATA   lpFindFileData,
        LONG                cFiles,
        LPVARIANT           lpVariant
    );

protected:

private:
	PGenCriticalSection m_pcs;
};

#endif //__EMMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\evenhand.h ===
#ifndef __EVENHAND_H
#define __EVENHAND_H

//#include "dbgeng.h"

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

class CEMSessionThread;

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
	CEMSessionThread		*m_pEMThread;

public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    // Symbol state has changed.
    STDMETHOD(ChangeSymbolState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
    STDMETHOD(ChangeDebuggeeState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
	STDMETHOD(Exception)(
		THIS_
		IN PEXCEPTION_RECORD64 Exception,
		IN ULONG FirstChance
		);

	STDMETHOD(Breakpoint)(
		THIS_
		IN PDEBUG_BREAKPOINT Bp
		);

    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        );

    STDMETHOD(ExitProcess)(
        THIS_
        IN ULONG ExitCode
        );
};
#endif // __EVENHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\evenhand.cpp ===
#include "stdafx.h"
#include "EvenHand.h"
#include "SvcObjDef.h"

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask =
//        DEBUG_EVENT_CHANGE_DEBUGGEE_STATE |
		DEBUG_EVENT_EXIT_PROCESS |
		DEBUG_EVENT_CHANGE_ENGINE_STATE |
        DEBUG_EVENT_EXCEPTION |
		DEBUG_EVENT_SESSION_STATUS;
    return S_OK;
}

#if 0
#define DBG_CALLBACK
#endif

// Symbol state has changed.
STDMETHODIMP
EventCallbacks::ChangeSymbolState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
)
{
	return S_OK;
}

STDMETHODIMP
EventCallbacks::SessionStatus(
    THIS_
    IN ULONG Status
    )
{
    if (Status & DEBUG_SESSION_HIBERNATE)
    {
//		MessageBox(NULL, _T("Debuggee stopped"), _T("STop"), MB_OK);
    }

	if (Status & DEBUG_SESSION_END)
	{
//		MessageBox(NULL, _T("Debuggee stopped"), _T("STop"), MB_OK);
	}

	return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::ChangeDebuggeeState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ChangeEngineState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    ULONG InvFlags = 0;

    if (Flags & DEBUG_CES_EXECUTION_STATUS)
    {
//		if(Argument == DEBUG_STATUS_NO_DEBUGGEE)
//			MessageBox(NULL, _T("Debuggee stopped"), _T("STop"), MB_OK);
    }
        
    return S_OK;
}

STDMETHODIMP
EventCallbacks::Exception(
	THIS_
	IN PEXCEPTION_RECORD64 pException,
	IN ULONG FirstChance
)
{
	DWORD excpcd = pException->ExceptionCode;

	do
	{
		if( excpcd == STATUS_BREAKPOINT ) break;
/*
		if( excpcd == EXCEPTION_BREAKPOINT || 
			excpcd == EXCEPTION_ACCESS_VIOLATION){
		}
*/
		{

			m_pEMThread->eDBGServie = DBGService_HandleException;
			m_pEMThread->OnException(pException);
		}
	}
	while(FALSE);

	return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP
EventCallbacks::Breakpoint(
	THIS_
	IN PDEBUG_BREAKPOINT Bp
)
{
	return 0L;
}

STDMETHODIMP
EventCallbacks::ExitProcess(
    THIS_
    IN ULONG ExitCode
)
{
//	MessageBox(NULL, _T("Process Exit"), _T("STop"), MB_OK);

	m_pEMThread->OnProcessExit(ExitCode);

	return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\emsvc.cpp ===
// emsvc.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f emsvcps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "emsvc.h"

#include "emsvc_i.c"

#include <stdio.h>
#include "EmManager.h"
#include "EmDebugSession.h"

#ifdef _DEBUG
    #define _CRTDBG_MAP_ALLOC
    #include <stdlib.h>
    #include <crtdbg.h>
#endif
#include "EmFile.h"

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_EmManager, CEmManager)
OBJECT_ENTRY(CLSID_EmDebugSession, CEmDebugSession)
OBJECT_ENTRY(CLSID_EmFile, CEmFile)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    ATLTRACE(_T("CServiceModule::RegisterServer\n"));

    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove any previous service since it may point to
    // the incorrect file
    Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_Emsvc, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{D48CD754-320F-4DCF-8CDA-7318CB03837D}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));
    
    if (bService)
    {
        key.SetValue(_T("emsvc"), _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
    ATLTRACE(_T("CServiceModule::UnregisterServer\n"));

    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_Emsvc, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    ATLTRACE(_T("CServiceModule::Init\n"));

    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
    ATLTRACE(_T("CServiceModule::Unlock\n"));

    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);

    ATLTRACE(_T("CServiceModule::Unlock - Lock count l = %d\n"), l);

    return l;
}

BOOL CServiceModule::IsInstalled()
{
    ATLTRACE(_T("CServiceModule::IsInstalled\n"));

    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
    ATLTRACE(_T("CServiceModule::Install\n"));

    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
    ATLTRACE(_T("CServiceModule::Uninstall\n"));

    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    ATLTRACE(_T("CServiceModule::LogEvent\n"));

    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (m_bService)
    {
        /* Get a handle to use with ReportEvent(). */
        hEventSource = RegisterEventSource(NULL, m_szServiceName);
        if (hEventSource != NULL)
        {
            /* Write to event log. */
            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    ATLTRACE(_T("CServiceModule::Start\n"));

    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    ATLTRACE(_T("CServiceModule::ServiceMain\n"));

    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
    LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    ATLTRACE(_T("CServiceModule::Handler\n"));

    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        LogEvent(_T("Bad service request"));
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    ATLTRACE(_T("CServiceModule::Run - Begin\n"));

    _Module.dwThreadID = GetCurrentThreadId();

    if(FAILED(GetEmFilePath( EMOBJ_LOGFILE, m_bstrLogFilePath ))) {
        LogEvent(_T("%s"), _T("Log file path not present."));
        return;
    }
    m_bstrLogFileExt    = _T ( ".dbl" );

    if(FAILED(GetEmFilePath( EMOBJ_MINIDUMP, m_bstrDumpFilePath ))) {
        LogEvent(_T("%s"), _T("Dump file path not present."));
    }
    m_bstrDumpFileExt   = _T ( ".dmp" );

    if(FAILED(GetEmFilePath( EMOBJ_CMDSET, m_bstrEcxFilePath ))) {
        LogEvent(_T("%s"), _T("Ecx file path not present in the registry. Was unable to create one."));
    }
    m_bstrEcxFileExt = _T( ".ecx" ); //GetEmFileExt( EMOBJ_CMDSET );

    if(FAILED(GetEmFilePath( EMOBJ_MSINFO, m_bstrMsInfoFilePath ))) {
        LogEvent(_T("%s"), _T("MsInfo file path not present in the registry. Was unable to create one."));
    }
    m_bstrMsInfoFileExt = _T( ".nfo" ); //GetEmFileExt( EMOBJ_CMDSET );

    m_SessionManager.InitSessionsFromLog( _T("EmSess.log"), STAT_SESS_STOPPED);

    HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
  //HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    // This provides a NULL DACL which will allow access to everyone.
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    hr = CoInitializeSecurity(sd, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER+CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    LogEvent(_T("Service started"));
    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);
    
    m_SessionManager.PersistSessions(_T("EmSess.log"));

    _Module.RevokeClassObjects();

    m_SessionManager.StopAllThreads();

    ATLTRACE(_T("CServiceModule::Run - before CoUninitialize \n"));

    CoUninitialize();

    ATLTRACE(_T("CServiceModule::Run - After CoUninitialize\n"));
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    ATLTRACE(_T("WinManin::lpCmdLine = %s\n"), lpCmdLine);

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_EMSVCLib);
    _Module.m_bService = TRUE;

#ifdef _DEBUG
    _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF | _CRTDBG_CHECK_CRT_DF );
#endif

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{D48CD754-320F-4DCF-8CDA-7318CB03837D}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    ATLTRACE(_T("WinManin:: Service Stop\n"));

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}


HRESULT
CServiceModule::GetEmDirectory
(
    EmObjectType    eObjectType,
    LPTSTR          pszDirectory,
    LONG            cchDirectory,
    LPTSTR          pszExt,
    LONG            cchExt
)
{
    ATLTRACE(_T("CServiceModule::GetEmDirectory - EmObjectType = %d\n"), eObjectType);

    HRESULT hr                          = S_OK;
    LPCTSTR pszSrcDirectory             = NULL;
    LPCTSTR pszSrcExt                   = NULL;

    switch ( eObjectType ) {
        case EMOBJ_LOGFILE:

            pszSrcDirectory = m_bstrLogFilePath;
            pszSrcExt       = m_bstrLogFileExt;
            break;

        case EMOBJ_MINIDUMP:
        case EMOBJ_USERDUMP:
            pszSrcDirectory = m_bstrDumpFilePath;
            pszSrcExt       = m_bstrDumpFileExt;
            break;

        case EMOBJ_CMDSET:
            pszSrcDirectory = m_bstrEcxFilePath;
            pszSrcExt       = m_bstrEcxFileExt;
            break;

        case EMOBJ_MSINFO:
            pszSrcDirectory = m_bstrMsInfoFilePath;
            pszSrcExt       = m_bstrMsInfoFileExt;
            break;

        default:
            hr = E_FAIL;
    }

    if ( SUCCEEDED(hr) ) {

        if ( pszDirectory && pszSrcDirectory ) // a-kjaw, bug ID: 296022
            _tcsncpy ( pszDirectory, pszSrcDirectory, cchDirectory );

        if ( pszExt && pszSrcExt ) // a-kjaw, bug ID: 296021
            _tcsncpy ( pszExt, pszSrcExt, cchExt );
    }

    return (hr);
}

void __stdcall _com_issue_error( HRESULT hr )
{
    throw _com_error ( hr );
}

HRESULT
CServiceModule::GetPathFromReg
(
IN      HKEY            hKeyParent,
IN      LPCTSTR         lpszKeyName,
IN      LPCTSTR         lpszQueryKey,
OUT     LPTSTR          pszDirectory,
IN OUT  ULONG           *cchDirectory
)
{
    ATLTRACE(_T("CServiceModule::GetPathFromReg\n"));

    HRESULT hr          =   E_FAIL;
    DWORD   dwLastRet   =   0L;
    CRegKey registry;

    do {

        dwLastRet = registry.Open(hKeyParent, lpszKeyName, KEY_READ);

        if(dwLastRet != ERROR_SUCCESS) {

            hr = HRESULT_FROM_WIN32(dwLastRet);
            break;
        }

        dwLastRet = registry.QueryValue(pszDirectory, lpszQueryKey, cchDirectory);
        hr = HRESULT_FROM_WIN32(dwLastRet);
    }
    while( false );

    if(HKEY(registry) != NULL) {

        registry.Close();
    }

    return S_OK;
}

HRESULT
CServiceModule::CreateEmDirectory
(
IN OUT  LPTSTR  lpDirName,
IN      LONG    ccDirName,
IN      LPCTSTR lpParentDirPath
)
{
    ATLTRACE(_T("CServiceModule::CreateEmDirectory\n"));

    HRESULT hr                      =   S_OK;
    DWORD   dwLastRet               =   0L;
    TCHAR   szDirPath[_MAX_PATH]    =   _T("");
    LONG    ccDirPath               =   _MAX_PATH;

    do {

        if( lpDirName == NULL ) {

            hr = E_INVALIDARG;
            break;
        }

        if( GetCurrentDirectory( ccDirPath, szDirPath ) == 0 ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if( !lpParentDirPath ) { lpParentDirPath = szDirPath; }
        _stprintf( szDirPath, _T("%s\\%s"), lpParentDirPath, lpDirName );

        CreateDirectory( szDirPath, NULL );
        dwLastRet = GetLastError();

        if( dwLastRet != 0 && dwLastRet != ERROR_ALREADY_EXISTS ) {

            hr = HRESULT_FROM_WIN32(dwLastRet);
            break;
        }

        _tcsncpy( lpDirName, szDirPath, ccDirName );
        hr = S_OK;
    }
    while ( false );

    return hr;
}

HRESULT
CServiceModule::RegisterDir
(
IN HKEY     hKeyParent,
IN LPCTSTR  lpszKeyName, 
IN LPCTSTR  lpszNamedValue,
IN LPCTSTR  lpValue
)
{
    ATLTRACE(_T("CServiceModule::RegisterDir\n"));

    HRESULT hr = E_FAIL;
    CRegKey registry;

    do {

        if( registry.Create(hKeyParent, lpszKeyName) != ERROR_SUCCESS ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        if( registry.SetValue( lpValue, lpszNamedValue ) != ERROR_SUCCESS ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        hr = S_OK;
    }
    while( false );

    if( HKEY(registry) != NULL ) {

        registry.Close();
    }

    return hr;
}

HRESULT
CServiceModule::CreateEmDirAndRegister
(
IN OUT  LPTSTR  lpDirName,
IN      LONG    ccDirName,
IN      HKEY    hKeyParent,
IN      LPCTSTR lpszKeyName,
IN      LPCTSTR lpszNamedValue
)
{
    ATLTRACE(_T("CServiceModule::CreateEmDirAndRegister\n"));

    HRESULT hr = E_FAIL;

    hr = CreateEmDirectory( lpDirName, ccDirName );
    if( FAILED(hr) ) return hr;

    hr = RegisterDir( hKeyParent, lpszKeyName, lpszNamedValue, lpDirName );
    return hr;
}

HRESULT
CServiceModule::GetEmFilePath
(
IN  short   nFileType,
OUT bstr_t& bstrFilePath
)
{
    ATLTRACE(_T("CServiceModule::GetEmFilePath\n"));

    HRESULT hr                          = E_FAIL;
    TCHAR   szDirectory[_MAX_PATH+1]    = _T("");
    ULONG   lDirectory                  = _MAX_PATH;

    LPCTSTR lpValueName                 = NULL;
    LPCTSTR lpDir                       = NULL;

    bstrFilePath = _T("");

    switch( nFileType )
    {
    case EMOBJ_LOGFILE:
        lpValueName = _T("LogDir");
        lpDir = _T("Logs");
        break;
    case EMOBJ_MINIDUMP:
    case EMOBJ_USERDUMP:
        lpValueName = _T("DumpDir");
        lpDir = _T("Dump");
        break;
    case EMOBJ_CMDSET:
        lpValueName = _T("CmdDir");
        lpDir = _T("Ecx");
        break;
    case EMOBJ_MSINFO:
        lpValueName = _T("MSInfoDir");
        lpDir = _T("MSInfo");
        break;
    }

    hr = GetPathFromReg (
                    HKEY_LOCAL_MACHINE,
                    _T("SYSTEM\\currentcontrolset\\services\\EMSVC\\Parameters\\Session"),
                    lpValueName,
                    szDirectory,
                    &lDirectory
                    );

    if( _tcscmp(szDirectory, _T("")) == 0 ) {

        _tcscpy(szDirectory, lpDir);
        lDirectory = _MAX_PATH;

        hr = CreateEmDirAndRegister(
                            szDirectory,
                            lDirectory,
                            HKEY_LOCAL_MACHINE,
                            _T("SYSTEM\\CurrentControlSet\\Services\\EMSVC\\Parameters\\Session"),
                            lpValueName
                            );
    }
    else {

        //
        // Just try to create the directory once,
        // if it is already present, this api returns
        // an error..
        //

        CreateDirectory( (LPTSTR)szDirectory, NULL );
    }

    if(SUCCEEDED(hr)) bstrFilePath = szDirectory;

    return hr;
}

bool
CServiceModule::DateFromTm
(
IN  WORD wYear,
IN  WORD wMonth,
IN  WORD wDay,
IN  WORD wHour,
IN  WORD wMinute,
IN  WORD wSecond,
OUT DATE& dtDest
)
{
	// Validate year and month (ignore day of week and milliseconds)
	if (wYear > 9999 || wMonth < 1 || wMonth > 12)
		return false;

	//  Check for leap year and set the number of days in the month
	BOOL bLeapYear = ((wYear & 3) == 0) &&
		((wYear % 100) != 0 || (wYear % 400) == 0);

	int nDaysInMonth =
		MonthDays[wMonth] - MonthDays[wMonth-1] +
		((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

	// Finish validating the date
	if (wDay < 1 || wDay > nDaysInMonth ||
		wHour > 23 || wMinute > 59 ||
		wSecond > 59)
	{
		return FALSE;
	}

	// Cache the date in days and time in fractional days
	long nDate;
	double dblTime;

	//It is a valid date; make Jan 1, 1AD be 1
	nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
		MonthDays[wMonth-1] + wDay;

	//  If leap year and it's before March, subtract 1:
	if (wMonth <= 2 && bLeapYear)
		--nDate;

	//  Offset so that 12/30/1899 is 0
	nDate -= 693959L;

	dblTime = (((long)wHour * 3600L) +  // hrs in seconds
		((long)wMinute * 60L) +  // mins in seconds
		((long)wSecond)) / 86400.;

	dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

	return TRUE;
}

DATE
CServiceModule::GetCurrentTime()
{
    time_t  timeSrc =   ::time(NULL);
    DATE    dt;

	// Convert time_t to struct tm
	tm *ptm = localtime(&timeSrc);

	if (ptm != NULL)
	{
		DateFromTm(
            (WORD)(ptm->tm_year + 1900),
			(WORD)(ptm->tm_mon + 1),
            (WORD)ptm->tm_mday,
			(WORD)ptm->tm_hour,
            (WORD)ptm->tm_min,
			(WORD)ptm->tm_sec,
            dt
            );
	}

    return dt;
}

DATE
CServiceModule::GetDateFromFileTm
(
IN  const FILETIME& filetimeSrc
)
{
    DATE    dt  =   0L;

	// Assume UTC FILETIME, so convert to LOCALTIME
	FILETIME filetimeLocal;
    if (!FileTimeToLocalFileTime( &filetimeSrc, &filetimeLocal)){ return (dt = 0L); }

	// Take advantage of SYSTEMTIME -> FILETIME conversion
	SYSTEMTIME systime;

    if(!FileTimeToSystemTime(&filetimeLocal, &systime)) { return (dt = 0L); }

	CServiceModule::DateFromTm(
            (WORD)(systime.wYear),
		    (WORD)(systime.wMonth),
            (WORD)systime.wDay,
		    (WORD)systime.wHour,
            (WORD)systime.wMinute,
		    (WORD)systime.wSecond,
            dt
            );

    return dt;
}

HRESULT
CServiceModule::GetTempEmFileName
(
IN  short   nObjType,
OUT BSTR    &bstrFileName
)
{
    HRESULT     hr                          =   E_FAIL;
    LPCTSTR     lpszFileName                =   NULL;
    TCHAR       szFilePath[_MAX_PATH + 1]   =   _T(""),
                szFileName[_MAX_FNAME + 1]  =   _T(""),
                szFileExt[_MAX_EXT + 1]     =   _T("");
    TCHAR       szId[100]                   =   _T(""); //
    DWORD       dwBuffSize                  =   0L;

    __try
    {

        switch( nObjType )
        {
        case EMOBJ_MSINFO:
            lpszFileName = _T("MSInfo");
            break;
        }

        bstrFileName = NULL;

        hr = _Module.GetEmDirectory( EMOBJ_MSINFO, szFilePath, _MAX_PATH, szFileExt, _MAX_EXT );
        if( FAILED(hr) ) { goto qGetFileName; }

        CreateDirectory( szFilePath, NULL );

        // path\\filename_id.ext
        _stprintf( szFileName, _T("%s\\%s_%d%s"), szFilePath, lpszFileName, GetEmUniqueId(), szFileExt );

        bstrFileName = SysAllocString( szFileName );
        if( !bstrFileName ) { hr = E_OUTOFMEMORY; goto qGetFileName; }

        hr = S_OK;

qGetFileName:
        if( FAILED(hr) ) {}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;

        _ASSERTE( false );
	}

	return hr;
}

HRESULT
CServiceModule::GetCompName
(
OUT BSTR    &bstrCompName
)
{
    HRESULT hr                                      =   E_FAIL;
    TCHAR   szMachineName[MAX_COMPUTERNAME_LENGTH]  =   _T("");
    DWORD   dwBuffSize                              =   MAX_COMPUTERNAME_LENGTH;

    __try
    {
        dwBuffSize = MAX_COMPUTERNAME_LENGTH;

        if( !GetComputerName( szMachineName, &dwBuffSize ) ) {

            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto qGetCompName;
        }

        bstrCompName = SysAllocString( szMachineName );
        if( !bstrCompName ) { hr = E_OUTOFMEMORY; goto qGetCompName; }

        hr = S_OK;

qGetCompName:
        if( FAILED(hr) ) {}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;

        _ASSERTE( false );
	}

	return hr;
}

HRESULT
CServiceModule::GetCDBInstallDir
(
OUT LPTSTR  lpCdbDir,
IN  ULONG   *pccCdbDir
)
{
    return GetEmInstallDir( lpCdbDir, pccCdbDir );
}

HRESULT
CServiceModule::GetEmInstallDir
(
OUT     LPTSTR  lpEmDir,
IN  OUT ULONG   *pccEmDir
)
{
    HRESULT hr          =   E_FAIL;
    LPCTSTR lpValueName =   _T("EmDir");

    __try
    {
        if( !lpEmDir || *pccEmDir <= 0 ) { hr = E_INVALIDARG; goto qGetEmInstallDir; }

        hr = GetPathFromReg (
                        HKEY_LOCAL_MACHINE,
                        _T("SYSTEM\\currentcontrolset\\services\\EMSVC\\Parameters\\Session"),
                        lpValueName,
                        lpEmDir,
                        pccEmDir
                        );

        if( FAILED(hr) ) { goto qGetEmInstallDir; }

        hr = S_OK;
qGetEmInstallDir:
        if( FAILED(hr) ) { }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;

        _ASSERTE( false );
	}

    return hr;
}

HRESULT
CServiceModule::GetMsInfoPath
(
OUT     LPTSTR  lpMsInfoPath,
IN  OUT ULONG   *pccMsInfoPath
)
{
    LPCTSTR lpszMsInfoRegKey    =   _T("Software\\Microsoft\\Shared Tools\\MSInfo");
    LPCTSTR lpszPath            =   _T("Path");

    return GetPathFromReg(
                    HKEY_LOCAL_MACHINE,
                    lpszMsInfoRegKey,
                    lpszPath,
                    lpMsInfoPath,
                    pccMsInfoPath
                    );
}

HRESULT
CServiceModule::GetOsVersion
(
OUT DWORD   *pdwOsVer
)
{
    _ASSERTE( pdwOsVer != NULL );

    HRESULT         hr  =   E_FAIL;
    OSVERSIONINFO   osvi;

    ZeroMemory( (void *)&osvi, sizeof(OSVERSIONINFO) );
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( !GetVersionEx (&osvi) ) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto qGetOsVersion;
    }

    if( osvi.dwPlatformId & VER_PLATFORM_WIN32_NT ) {

        if( osvi.dwMajorVersion == 4 &&
            osvi.dwMinorVersion == 0 ) {
            
            *pdwOsVer = WINOS_NT4;
        }
        else if( osvi.dwMajorVersion == 5 &&
                 osvi.dwMinorVersion == 0 ) {

            *pdwOsVer = WINOS_WIN2K;
        }
    }

    hr = S_OK;

qGetOsVersion:

    if( FAILED(hr) ) { if( pdwOsVer ) *pdwOsVer = 0L; }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\genlog.cpp ===
// GenLog.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "GenLog.h"

CGenLog::CGenLog()
: m_pFileHandle( NULL ), m_pWriteBuffer( NULL ), m_lWriteBufferLen( 0L )
{
}

CGenLog::CGenLog
(
IN  const char *pszFilePath
)
: m_pFileHandle( NULL ), m_pWriteBuffer( NULL ), m_lWriteBufferLen( 0L )
{
//    _ASSERTE( pszFilePath != NULL );

    InitLog( pszFilePath, "w+" );
}

CGenLog::~CGenLog()
{
    ResetGenLog();
}

long
CGenLog::InitLog
(
IN  const char          *pszFilePath, /* = NULL */
IN  const char          *pszMode, /* = NULL */
IN  const unsigned long lWriteBuffer /* = 256 */
)
{
//    _ASSERTE( pszFilePath != NULL );
//    _ASSERTE( pszMode != NULL );
//    _ASSERTE( lWriteBuffer > 0L );

    long   lLastRet     =   GENLOG_ERROR_UNEXPECTED;
    FILE    *pTempFile  =   NULL;
    char    *pWriteBuff =   NULL;

    __try {

        if( pszFilePath == NULL ||
            pszMode == NULL ||
            lWriteBuffer == 0L ) {

            lLastRet = GENLOG_ERROR_INVALIDARG;
            goto qInitLog;
        }

        ResetGenLog();

        pTempFile = fopen( pszFilePath, pszMode );
        if( !pTempFile ) {

            lLastRet = GENLOG_ERROR_FILEOPERATIONFAILED;
            goto qInitLog;
        }

        //
        // we allocate a byte more than what is required, so that we can
        // take care of av issues..
        //
        pWriteBuff = (char *) calloc( lWriteBuffer + 1, sizeof( char ) );
//        _ASSERTE( pWriteBuff != NULL );

        if( !pWriteBuff ) {

            lLastRet = GENLOG_ERROR_MEMORY;
            goto qInitLog;
        }

        lLastRet = GENLOG_SUCCESS;

qInitLog:
        if( lLastRet == GENLOG_SUCCESS ) {

            m_pFileHandle = pTempFile;
            m_pWriteBuffer = pWriteBuff;
            m_lWriteBufferLen = lWriteBuffer;
        }
        else {

            // do the cleanup stuff here..
            if( pTempFile ) { fclose ( pTempFile ); }
            if( pWriteBuff ) { free( pWriteBuff ); }
        }
    }
	__except ( -1/*EXCEPTION_EXECUTE_HANDLER*/, 1 ) {

        lLastRet = GENLOG_ERROR_UNEXPECTED;

        if( pTempFile ) { fclose ( pTempFile ); }
        if( pWriteBuff ) { free( pWriteBuff ); }

//        _ASSERTE( false );
    }

    return lLastRet;
}

void 
CGenLog::Debug
(
IN  const char *pDebugString,
IN  ...
)
{
//    _ASSERTE( pDebugString != NULL );
//    _ASSERTE( m_pFileHandle != NULL );
//    _ASSERTE( m_pWriteBuffer != NULL );

    __try {

        if( !pDebugString || !m_pFileHandle || !m_pWriteBuffer ) { return; }

	    va_list argList;
	    va_start(argList, pDebugString);
	    _vsnprintf(m_pWriteBuffer, m_lWriteBufferLen, pDebugString, argList);
        Write();
	    va_end(argList);
    }
    __except( -1/*EXCEPTION_EXECUTE_HANDLER*/, 1 ) {

//        _ASSERTE( false );
    }
}

void
CGenLog::Error
(
IN  const char *pErrorString,
IN  ...
)
{
//    _ASSERTE( pErrorString != NULL );
//    _ASSERTE( m_pFileHandle != NULL );
//    _ASSERTE( m_pWriteBuffer != NULL );

    __try {

        if( !pErrorString || !m_pFileHandle || !m_pWriteBuffer ) { return; }

	    va_list argList;
	    va_start(argList, pErrorString);
	    _vsnprintf(m_pWriteBuffer, m_lWriteBufferLen, pErrorString, argList);
        Write();
	    va_end(argList);
    }
    __except( -1/*EXCEPTION_EXECUTE_HANDLER*/, 1 ) {

//        _ASSERTE( false );
    }
}

void
CGenLog::Log
(
IN  const char *pLogString,
IN  ...
)
{
//    _ASSERTE( pLogString != NULL );
//    _ASSERTE( m_pFileHandle != NULL );
//    _ASSERTE( m_pWriteBuffer != NULL );

    __try {

        if( !pLogString || !m_pFileHandle || !m_pWriteBuffer ) { return; }

	    va_list argList;
	    va_start(argList, pLogString);
	    _vsnprintf(m_pWriteBuffer, m_lWriteBufferLen, pLogString, argList);
        Write();
	    va_end(argList);
    }
    __except( -1/*EXCEPTION_EXECUTE_HANDLER*/, 1 ) {

//        _ASSERTE( false );
    }
}

long
CGenLog::Write()
{
//    _ASSERTE( m_pFileHandle != NULL );
//    _ASSERTE( m_pWriteBuffer != NULL );

    long            lLastRet        =   GENLOG_ERROR_UNEXPECTED;
    unsigned long   lWrittenDataLen =   0L;

    __try {

        if( !m_pWriteBuffer || !m_pFileHandle ) {

            lLastRet = GENLOG_ERROR_INVALIDARG;
            goto qWrite;
        }

        if( !m_pFileHandle ) {

            lLastRet = GENLOG_ERROR_UNINITIALIZED;
            goto qWrite;
        }

        lWrittenDataLen = fwrite(
                            (void *)m_pWriteBuffer,
                            sizeof( char ),
                            strlen( m_pWriteBuffer),
                            m_pFileHandle
                            );

        if( lWrittenDataLen != strlen( m_pWriteBuffer) ) {

            lLastRet = GENLOG_ERROR_FILEOPERATIONFAILED;
            goto qWrite;
        }

        lLastRet = GENLOG_SUCCESS;

qWrite:
        if( lLastRet == GENLOG_SUCCESS ) {

            // great!!
        }
        else {

            // cleanup..
        }

    }
    __except ( -1 /*EXCEPTION_EXECUTE_HANDLER*/, 1 ) {

        lLastRet = GENLOG_ERROR_UNEXPECTED;
//        _ASSERTE( false );
    }

    return lLastRet;
}

void
CGenLog::ResetGenLog()
{

    if( m_pFileHandle ) { fclose( m_pFileHandle ); m_pFileHandle = NULL; }
    if( m_pWriteBuffer ) { free( (void *) m_pWriteBuffer ); m_pWriteBuffer = NULL; }
    m_lWriteBufferLen = GENLOG_DEFAULT_WRITEBUFSIZE;
}

void
CGenLog::Header
(
IN  const char *pszHeaderString
)
{
    const char  *pszHead = "---------------------------------------------------\n";

    __try {

        if( !pszHeaderString ) {

            strcpy( m_pWriteBuffer, pszHead );
            Write();
            Now();
            strcpy( m_pWriteBuffer, pszHead );
            Write();
        }
        else {

            strncpy( m_pWriteBuffer, pszHeaderString, m_lWriteBufferLen );
            Write();
        }        

    }
    __except ( -1 /*EXCEPTION_EXECUTE_HANDLER*/, 1 ) {

//        _ASSERTE( false );
    }
}

void
CGenLog::Now()
{
    time_t      timeNow     =   ::time(NULL);
	struct tm   *ptmTemp    =   localtime(&timeNow);
    const char  *pFormat    =   "%H : %M : %S - %A, %B %d, %Y\n";

    __try {

        if (ptmTemp == NULL ||
		    !strftime(m_pWriteBuffer, m_lWriteBufferLen, pFormat, ptmTemp))
		    m_pWriteBuffer[0] = '\0';

        Write();

    }
    __except ( -1 /*EXCEPTION_EXECUTE_HANDLER*/, 1 ) {

//        _ASSERTE( false );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\notify.cpp ===
#include "stdafx.h"
#include "Notify.h"

extern
HRESULT
SendMail
(
IN  LPCTSTR lpszFrom,
IN  LPCTSTR lpszTo,
IN  LPCTSTR lpszSubject,
IN  LPCTSTR lpszMessage,
IN  short   nImportance
);

CNotify::CNotify(LPCTSTR lpszNotifyWho, LPCTSTR lpszNotifyWhat)
{
    _ASSERTE(lpszNotifyWho != NULL);

    m_lpszNotifyWho = new TCHAR[_tcslen(lpszNotifyWho) + 1];
    _ASSERTE(m_lpszNotifyWho != NULL);

    if(m_lpszNotifyWho) _tcscpy(m_lpszNotifyWho, lpszNotifyWho);

    m_lpszNotifyWhat = new TCHAR[_tcslen(lpszNotifyWhat) + 1];
    _ASSERTE(m_lpszNotifyWhat != NULL);

    if(m_lpszNotifyWhat) _tcscpy(m_lpszNotifyWhat, lpszNotifyWhat);
}

CNotify::~CNotify()
{
    if(m_lpszNotifyWho) delete [] m_lpszNotifyWho;
    if(m_lpszNotifyWhat) delete [] m_lpszNotifyWhat;

    m_lpszNotifyWho = NULL;
    m_lpszNotifyWhat = NULL;
}

DWORD CNotify::Notify()
{
    _ASSERTE(m_lpszNotifyWho!= NULL);

    DWORD   dwLastRet   =   0L;

    if(!m_lpszNotifyWho) return dwLastRet;

    if(ShouldNetSend() == true){

        dwLastRet = NetSend();
    }
    else {

        dwLastRet = EMail();
    }

    return dwLastRet;
}

DWORD CNotify::NetSend()
{
    DWORD   dwLastRet   =   0L;
    TCHAR   *lpszCmd    =   NULL;

    _ASSERTE(m_lpszNotifyWho != NULL);

    if(!m_lpszNotifyWho) return dwLastRet;

    lpszCmd = new TCHAR[ _tcslen(_T("net send")) + _tcslen(m_lpszNotifyWho) + _tcslen(m_lpszNotifyWhat) + 3]; // room for blank space and null
    dwLastRet = GetLastError();
    _ASSERTE(lpszCmd != NULL);

    if(!lpszCmd) return dwLastRet;

    _stprintf(lpszCmd, _T("%s %s %s"), _T("net send"), m_lpszNotifyWho, m_lpszNotifyWhat);
    _tsystem(lpszCmd);

    if(lpszCmd) delete [] lpszCmd;

    return (dwLastRet = 0L);
}

HRESULT CNotify::EMail()
{
//    return S_OK;
    return SendMail(_T("ExceptionMonitor8.0"), m_lpszNotifyWho, _T("Exception Occured"), m_lpszNotifyWhat, 1);
}

bool CNotify::ShouldNetSend()
{
    bool bRet = true; // Assume NetSend.

    if(_tcschr(m_lpszNotifyWho, _T('@')) != NULL) bRet = false;

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\kwa.cpp ===
// EmManager.cpp : Implementation of CEmManager
#include "stdafx.h"
#include "Emsvc.h"
#include "EmManager.h"
#include "Processes.h"
#include "sahlp.h"
#include <winerror.h>

BSTR
CopyBSTR
(
    LPBYTE  pb,
    ULONG   cb
);


/*

BOOL OleDateFromTm(WORD wYear, WORD wMonth, WORD wDay,
	WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest)
{
	// Validate year and month (ignore day of week and milliseconds)
	if (wYear > 9999 || wMonth < 1 || wMonth > 12)
		return FALSE;

	//  Check for leap year and set the number of days in the month
	BOOL bLeapYear = ((wYear & 3) == 0) &&
		((wYear % 100) != 0 || (wYear % 400) == 0);

	int nDaysInMonth =
		_afxMonthDays[wMonth] - _afxMonthDays[wMonth-1] +
		((bLeapYear && wDay == 29 && wMonth == 2) ? 1 : 0);

	// Finish validating the date
	if (wDay < 1 || wDay > nDaysInMonth ||
		wHour > 23 || wMinute > 59 ||
		wSecond > 59)
	{
		return FALSE;
	}

	// Cache the date in days and time in fractional days
	long nDate;
	double dblTime;

	//It is a valid date; make Jan 1, 1AD be 1
	nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
		_afxMonthDays[wMonth-1] + wDay;

	//  If leap year and it's before March, subtract 1:
	if (wMonth <= 2 && bLeapYear)
		--nDate;

	//  Offset so that 12/30/1899 is 0
	nDate -= 693959L;

	dblTime = (((long)wHour * 3600L) +  // hrs in seconds
		((long)wMinute * 60L) +  // mins in seconds
		((long)wSecond)) / 86400.;

	dtDest = (double) nDate + ((nDate >= 0) ? dblTime : -dblTime);

	return TRUE;
}


const COleDateTime& COleDateTime::operator=(const FILETIME& filetimeSrc)
{
	// Assume UTC FILETIME, so convert to LOCALTIME
	FILETIME filetimeLocal;
	if (!FileTimeToLocalFileTime( &filetimeSrc, &filetimeLocal))
	{
#ifdef _DEBUG
		DWORD dwError = GetLastError();
		TRACE1("\nFileTimeToLocalFileTime failed. Error = %lu.\n\t", dwError);
#endif // _DEBUG
		m_status = invalid;
	}
	else
	{
		// Take advantage of SYSTEMTIME -> FILETIME conversion
		SYSTEMTIME systime;
		m_status = FileTimeToSystemTime(&filetimeLocal, &systime) ?
			valid : invalid;

		// At this point systime should always be valid, but...
		if (GetStatus() == valid)
		{
			m_status = _AfxOleDateFromTm(systime.wYear, systime.wMonth,
				systime.wDay, systime.wHour, systime.wMinute,
				systime.wSecond, m_dt) ? valid : invalid;
		}
	}

	return *this;
}

*/

HRESULT CEmManager::EnumLogFiles 
(
    VARIANT *lpVariant,
    LPCTSTR lpSearchString
)
{
    ATLTRACE(_T("CEmManager::EnumLogFiles\n"));

    HRESULT             hr                      =   E_FAIL;
    TCHAR               szDirectory[_MAX_PATH]  =   _T("");
    TCHAR               szExt[_MAX_EXT]         =   _T("");
    LPWIN32_FIND_DATA   lpFindData              =   NULL;
    LONG                cFiles                  =   0;

    __try {

        if(lpSearchString == NULL) {

            _Module.GetEmDirectory ( 
                            EMOBJ_LOGFILE, 
                            (LPTSTR)szDirectory, 
                            sizeof szDirectory / sizeof (TCHAR),
                            (LPTSTR)szExt,
                            sizeof szExt / sizeof (TCHAR)
                            );
        }
        else {

            _tcscpy(szDirectory, lpSearchString);
            _tcscpy(szExt, _T(""));
        }

        hr = EnumFiles ( 
                szDirectory,
                szExt,
                &lpFindData,
                &cFiles
             );

        if ( SUCCEEDED(hr) ) {

            hr = PackageFilesToVariant ( 
                            EMOBJ_LOGFILE,
                            lpFindData,
                            cFiles,
                            lpVariant 
                            );
        }

        if( lpFindData ) { free( lpFindData ); lpFindData = NULL; }

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return (hr);
}

HRESULT
CEmManager::EnumCmdSets
(
OUT VARIANT *lpVariant,
IN  LPCTSTR lpSearchString
)
{
    ATLTRACE(_T("CEmManager::EnumCmdSets\n"));

    HRESULT             hr          = E_FAIL;
    TCHAR               szDirectory[_MAX_PATH];
    TCHAR               szExt[_MAX_EXT];
    LPWIN32_FIND_DATA   lpFindData  = NULL;
    LONG                cFiles      = 0;

    __try {

        if( lpSearchString == NULL ) {

            _Module.GetEmDirectory ( 
                            EMOBJ_CMDSET,
                            (LPTSTR)szDirectory, 
                            sizeof szDirectory / sizeof ( TCHAR ),
                            (LPTSTR)szExt,
                            sizeof szExt / sizeof ( TCHAR )
                            );
        }
        else {

            _tcscpy( szDirectory, lpSearchString );
            _tcscpy( szExt, _T(""));
        }

        hr = EnumFiles ( 
                szDirectory,
                szExt,
                &lpFindData,
                &cFiles
             );

        if ( SUCCEEDED(hr) ) {

            hr = PackageFilesToVariant ( 
                            EMOBJ_CMDSET,
                            lpFindData,
                            cFiles,
                            lpVariant 
                            );
        }

        if( lpFindData ) { free( lpFindData ); lpFindData = NULL; }

	}
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return (hr);
}

HRESULT
CEmManager::EnumDumpFiles
(
OUT VARIANT *lpVariant,
IN  LPCTSTR lpSearchString
)
{
    ATLTRACE(_T("CEmManager::EnumDumpFiles\n"));

    HRESULT             hr          = E_FAIL;
    TCHAR               szDirectory[_MAX_PATH];
    TCHAR               szExt[_MAX_EXT];
    LPWIN32_FIND_DATA   lpFindData  = NULL;
    LONG                cFiles      = 0;

    __try {

        if(lpSearchString == NULL) {

            _Module.GetEmDirectory ( 
                            EMOBJ_MINIDUMP,
                            (LPTSTR)szDirectory, 
                            sizeof szDirectory / sizeof ( TCHAR ),
                            (LPTSTR)szExt,
                            sizeof szExt / sizeof ( TCHAR )
                            );
        }
        else {

            _tcscpy( szDirectory, lpSearchString );
            _tcscpy( szExt, _T(""));
        }

        hr = EnumFiles ( 
                szDirectory,
                szExt,
                &lpFindData,
                &cFiles
             );

        if ( SUCCEEDED(hr) ) {

            hr = PackageFilesToVariant ( 
                            EMOBJ_MINIDUMP,
                            lpFindData,
                            cFiles,
                            lpVariant 
                            );
        }

        if( lpFindData ) { free( lpFindData ); lpFindData = NULL; }

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return (hr);
}



HRESULT CEmManager::EnumFiles
(
    LPTSTR              lpszDirectory,
    LPTSTR              lpszExt,
    LPWIN32_FIND_DATA   *lppFindData,
    LONG                *lpFiles
)
{
    ATLTRACE(_T("CEmManager::EnumFiles\n"));

    HRESULT     		hr 				= E_FAIL;
	HANDLE				hFind			= INVALID_HANDLE_VALUE;
	LPWIN32_FIND_DATA	lpFindFileData  = NULL;
	LONG				cMaxFiles 	    = 0;  
	LONG				cGrowBy		    = 100;
	LONG				cFileBuf	    = 0;
	BOOL				fContinue	    = TRUE;
    TCHAR               szFileName[_MAX_PATH];
    DWORD               dwErr;

    *lppFindData    =  NULL;
    *lpFiles        =  0;


	cFileBuf    = cGrowBy;
    cMaxFiles   = 0;

    __try {

        _tcscpy ( szFileName, lpszDirectory );
        if ( _tcslen ( lpszExt ) > 0 ) {
            _tcscat ( szFileName, _T ( "\\*" ) );
            _tcscat ( szFileName, lpszExt );
        }

        // start with a initial buffer
	    lpFindFileData = ( LPWIN32_FIND_DATA) malloc ( sizeof ( WIN32_FIND_DATA) * cFileBuf );
        if ( lpFindFileData == NULL )
            goto qEnumFiles;

        // read from the filesystem
        hFind = FindFirstFile ( szFileName, &lpFindFileData[cMaxFiles] );

	    while ( hFind != INVALID_HANDLE_VALUE  && fContinue ) {

            cMaxFiles++;

            // grow buffer if necessary
		    if ( cMaxFiles == cFileBuf ) {
			    cFileBuf += cGrowBy;

			    LPWIN32_FIND_DATA lpNewFileData = (LPWIN32_FIND_DATA) realloc ( 
                                                    lpFindFileData,
                                                    sizeof ( WIN32_FIND_DATA) * cFileBuf 
												    );
			    if ( lpNewFileData == NULL ) {
				    goto qEnumFiles;
			    }

			    delete lpFindFileData;
			    lpFindFileData = lpNewFileData;
		    }

		    fContinue = FindNextFile ( hFind, &lpFindFileData[cMaxFiles] );
	    }

        if ( hFind == INVALID_HANDLE_VALUE || fContinue == FALSE ) {
            dwErr = GetLastError();
        }

        if ( dwErr == ERROR_NO_MORE_FILES || dwErr == ERROR_FILE_NOT_FOUND )
            hr = S_OK;
        else 
            hr = HRESULT_FROM_WIN32 ( dwErr );

qEnumFiles:

        if ( SUCCEEDED ( hr ) ) {
            *lppFindData    =  lpFindFileData;
            *lpFiles        =  cMaxFiles;
        }
        else {
            if ( lpFindFileData ) 
                free ( lpFindFileData );
        }

        if ( hFind != INVALID_HANDLE_VALUE )
            FindClose ( hFind );

	}
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        if ( lpFindFileData ) 
            free ( lpFindFileData );

        if ( hFind != INVALID_HANDLE_VALUE )
            FindClose ( hFind );

        hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return (hr);
}


HRESULT CEmManager::PackageFilesToVariant 
( 
    EmObjectType        eObjectType,
    LPWIN32_FIND_DATA   lpFindFileData,
    LONG                cFiles,
    LPVARIANT           lpVariant
)
{
    ATLTRACE(_T("CEmManager::PackageFilesToVariant\n"));

    HRESULT     hr                  = E_FAIL;
    EmObject    emObject;
    BSTR        bstrObject          = NULL;
    LONG        iFile               = 0;

    __try {

        ::VariantClear ( lpVariant );

        hr = Variant_CreateOneDim ( lpVariant, cFiles, VT_BSTR );
        if ( FAILED(hr) )
            goto qPackage;

        for ( iFile=0 ; iFile<cFiles ; iFile++ ) {

            ZeroMemory ( &emObject, sizeof EmObject );

            // type
            emObject.type   = eObjectType;

            // ID
		    emObject.nId    = 0;

            // name
		    _tcscpy ( emObject.szName, lpFindFileData[iFile].cFileName );

		    emObject.nStatus = 0; //STAT_FILECREATED;

            // Start time 
            emObject.dateStart = CServiceModule::GetDateFromFileTm(lpFindFileData[iFile].ftCreationTime);

            // End time
            emObject.dateEnd = 0;

            emObject.dwBucket1 = lpFindFileData[iFile].nFileSizeLow;

            // Now that EmObject is filled up, preprocess as appropriate

            switch ( eObjectType ) {

                case EMOBJ_MSINFO:
                    FillMsInfoFileInfo( NULL, &lpFindFileData[iFile], &emObject );
                    break;

                case EMOBJ_MINIDUMP:
                case EMOBJ_USERDUMP:
                    FillDumpFileInfo( NULL, &lpFindFileData[iFile], &emObject );
                    break;

                case EMOBJ_LOGFILE:
                    FillLogFileInfo( NULL, &lpFindFileData[iFile], &emObject );
                    break;

                case EMOBJ_CMDSET:
                    ScanCmdfile ( NULL, &lpFindFileData[iFile], &emObject );
                    break;
            }



            bstrObject = CopyBSTR ( (LPBYTE) &emObject, sizeof (EmObject) );
            if ( bstrObject == NULL ) {
                hr = E_OUTOFMEMORY;
                goto qPackage;
            }

            hr = ::SafeArrayPutElement ( lpVariant->parray, &iFile, bstrObject );
            if ( FAILED (hr) )
                goto qPackage;

            SysFreeString ( bstrObject );
        }

qPackage:

        if ( FAILED(hr)) {
            ::VariantClear ( lpVariant );
        }

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        ::VariantClear ( lpVariant );

        hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return (hr);

}

HRESULT CEmManager::ScanCmdfile
(
    LPCTSTR             lpszCmdFileDir,
    LPWIN32_FIND_DATA   lpFindData, 
    EmObject            *pEmObject
)
{
    USES_CONVERSION;

    ATLTRACE(_T("CEmManager::ScanCmdfile\n"));

    HRESULT     hr = S_OK;
    const DWORD cchBuf = 512;
    DWORD       dwBytesRead;
    char        szBuf[cchBuf+1];
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    const DWORD cTemplates = 4;
    LPSTR       szTemplate [cTemplates];
    DWORD       dwErr;
    DWORD       dwIndex;

    TCHAR       szCmdDir[_MAX_PATH]     =   _T("");
    TCHAR       szCurrentDir[_MAX_PATH] =   _T("");
    DWORD       dwBufSize               =   _MAX_PATH;
    BOOL        bMatchFound             =   FALSE;
    char        *pNewLine               =   NULL;

    __try {

        if( !lpszCmdFileDir ) {

            _Module.GetEmDirectory( EMOBJ_CMDSET, szCmdDir, sizeof( szCmdDir ) / sizeof( TCHAR ), NULL, NULL);
            lpszCmdFileDir = szCmdDir;
        }

        // fill template
        szTemplate[0] = ( "!emdbg.tag" );
        szTemplate[1] = ( "! emdbg.tag" );
        szTemplate[2] = ( "*" );
        szTemplate[3] = ( " *" );

        ZeroMemory ( szBuf, sizeof szBuf );

        if(GetCurrentDirectory(dwBufSize, szCurrentDir) == 0) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto qScan;
        }

        if(SetCurrentDirectory(lpszCmdFileDir) == 0) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto qScan;
        }

        hFile = ::CreateFile (
                    lpFindData->cFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if ( hFile == INVALID_HANDLE_VALUE ) {
            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32 ( dwErr );
            goto qScan;
        }

        if ( !::ReadFile ( hFile, szBuf, cchBuf, &dwBytesRead, NULL ) ) {
            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32 ( dwErr );
            goto qScan;
        }

        pNewLine = strchr(szBuf, '\r\n');
        if( pNewLine ) *pNewLine = '\0';

        // see if a valid .ecx file
        for ( dwIndex=0 ; dwIndex<cTemplates ; dwIndex++ ) {
            if ( 0 == 
                strncmp( 
                    szBuf, 
                    szTemplate[dwIndex], 
                    strlen ( szTemplate[dwIndex] ) 
                    )
               ) {

                bMatchFound = TRUE;
                break;
            }
        }

        // check if we got a match
        if ( bMatchFound == FALSE ) {
            pEmObject->hr = E_FAIL;
        }
        else {

            int cCh = 0;

            {
                EmObject obj;
                cCh = sizeof ( obj.szBucket1 ) / sizeof ( TCHAR );
            }

            // eat spaces
            LPSTR pszSrc = szBuf;
            pszSrc += strlen ( szTemplate[dwIndex] );
            while ( pszSrc != NULL && *pszSrc == ' ' )
                pszSrc++;

            LPTSTR  pszSrcW = A2T ( pszSrc );


            ZeroMemory ( pEmObject->szBucket1, cCh );
            _tcsncpy ( 
                pEmObject->szBucket1, 
                pszSrcW,
                cCh - sizeof ( TCHAR )
                );
        }


qScan:

        if ( hFile != INVALID_HANDLE_VALUE )
            ::CloseHandle ( hFile );

        if ( _tcscmp( szCurrentDir, _T("") ) != 0 ) {

            if(SetCurrentDirectory(szCurrentDir) == 0) {

                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        if ( hFile != INVALID_HANDLE_VALUE )
            ::CloseHandle ( hFile );

        if ( _tcscmp( szCurrentDir, _T("") ) != 0 ) {

            SetCurrentDirectory(szCurrentDir);
        }

        hr = E_UNEXPECTED;
		_ASSERTE( false );
	}


    return  hr;
}

HRESULT CEmManager::FillLogFileInfo
(
    LPCTSTR             lpszLogFileDir,
    LPWIN32_FIND_DATA   lpFindData, 
    EmObject            *pEmObject
)
{
    HRESULT     hr          =   E_FAIL;
    LPTSTR      lpszLogDir  =   NULL;

    __try
    {
        if( !lpszLogFileDir ){

            lpszLogDir = new TCHAR[_MAX_PATH+1];
            if( !lpszLogDir ) return E_OUTOFMEMORY;
            _Module.GetEmDirectory( EMOBJ_LOGFILE, lpszLogDir, _MAX_PATH, NULL, NULL );
            lpszLogFileDir = lpszLogDir;
        }

        _tcscpy(pEmObject->szSecName, lpszLogFileDir);

//qFileLogFileInfo:
        if( lpszLogDir ) { delete [] lpszLogDir; lpszLogDir = NULL; }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;
        if( lpszLogDir ) { delete [] lpszLogDir; lpszLogDir = NULL; }

        _ASSERTE( false );
	}

    return  hr;
}

HRESULT CEmManager::FillMsInfoFileInfo
(
    LPCTSTR             lpszMsInfoFileDir,
    LPWIN32_FIND_DATA   lpFindData, 
    EmObject            *pEmObject
)
{
    HRESULT     hr              =   E_FAIL;
    LPTSTR      lpszMsInfoDir   =   NULL;

    __try
    {
        if( !lpszMsInfoFileDir ){

            lpszMsInfoDir = new TCHAR[_MAX_PATH+1];
            if( !lpszMsInfoDir ) return E_OUTOFMEMORY;
            _Module.GetEmDirectory( EMOBJ_MSINFO, lpszMsInfoDir, _MAX_PATH, NULL, NULL );
            lpszMsInfoFileDir = lpszMsInfoDir;
        }

        _tcscpy(pEmObject->szSecName, lpszMsInfoFileDir);

//qFileLogFileInfo:
        if( lpszMsInfoDir ) { delete [] lpszMsInfoDir; lpszMsInfoDir = NULL; }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;
        if( lpszMsInfoDir ) { delete [] lpszMsInfoDir; lpszMsInfoDir = NULL; }

        _ASSERTE( false );
	}

    return  hr;
}

HRESULT CEmManager::FillDumpFileInfo
(
    LPCTSTR             lpszDumpFileDir,
    LPWIN32_FIND_DATA   lpFindData, 
    EmObject            *pEmObject
)
{
    HRESULT     hr          =   E_FAIL;
    LPTSTR      lpszDumpDir =   NULL;

    __try
    {
        if( !lpszDumpFileDir ){

            lpszDumpDir = new TCHAR[_MAX_PATH+1];
            if( !lpszDumpDir ) return E_OUTOFMEMORY;
            _Module.GetEmDirectory( EMOBJ_MINIDUMP, lpszDumpDir, _MAX_PATH, NULL, NULL );
            lpszDumpFileDir = lpszDumpDir;
        }

        _tcscpy(pEmObject->szSecName, lpszDumpFileDir);

//qFileLogFileInfo:
        if( lpszDumpDir ) { delete [] lpszDumpDir; lpszDumpDir = NULL; }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        hr = E_UNEXPECTED;
        if( lpszDumpDir ) { delete [] lpszDumpDir; lpszDumpDir = NULL; }

        _ASSERTE( false );
	}

    return  hr;
}

//
// a-mando
//
HRESULT
CEmManager::EnumMsInfoFiles
(
OUT VARIANT *lpVariant,
IN  LPCTSTR lpSearchString
)
{
    ATLTRACE(_T("CEmManager::EnumMsInfoFiles\n"));

    HRESULT             hr          = E_FAIL;
    TCHAR               szDirectory[_MAX_PATH];
    TCHAR               szExt[_MAX_EXT];
    LPWIN32_FIND_DATA   lpFindData  = NULL;
    LONG                cFiles      = 0;

    __try {

        if(lpSearchString == NULL) {

            _Module.GetEmDirectory ( 
                            EMOBJ_MSINFO,
                            (LPTSTR)szDirectory, 
                            sizeof szDirectory / sizeof ( TCHAR ),
                            (LPTSTR)szExt,
                            sizeof szExt / sizeof ( TCHAR )
                            );
        }
        else {

            _tcscpy( szDirectory, lpSearchString );
            _tcscpy( szExt, _T(""));
        }

        hr = EnumFiles ( 
                szDirectory,
                szExt,
                &lpFindData,
                &cFiles
             );

        if ( SUCCEEDED(hr) ) {

            hr = PackageFilesToVariant ( 
                            EMOBJ_MSINFO,
                            lpFindData,
                            cFiles,
                            lpVariant 
                            );
        }

        if( lpFindData ) { free( lpFindData ); lpFindData = NULL; }

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return (hr);
}

// a-mando
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\notify.h ===
#ifndef _NOTIFY_H
#define _NOTIFY_H

class CNotify
{
// Attributes
public:
private:
    LPTSTR  m_lpszNotifyWho;
    LPTSTR  m_lpszNotifyWhat;
protected:

// Methods
public:
    CNotify(LPCTSTR lpszNotifyWho, LPCTSTR lpszNotifyWhat);
    ~CNotify();

    DWORD Notify();
private:
    bool ShouldNetSend();
protected:
    DWORD NetSend();
    HRESULT EMail();
};

#endif // _NOTIFY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\genlog.h ===
#pragma once

#include <crtdbg.h>
#include <malloc.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>

#define IN
#define OUT

//
// CGenLog - Const
//
#define GENLOG_DEFAULT_WRITEBUFSIZE         256

//
// CGenLog - Error Codes...
//
#define GENLOG_SUCCESS                      0
#define GENLOG_ERROR_INVALIDARG             -1
#define GENLOG_ERROR_UNEXPECTED             -2
#define GENLOG_ERROR_FILEOPERATIONFAILED    -3
#define GENLOG_ERROR_UNINITIALIZED          -4
#define GENLOG_ERROR_MEMORY                 -5

class IGenLog {

    virtual void Debug( const char *pDebugString, ... ) = 0;
    virtual void Error( const char *pErrorString, ... ) = 0;
    virtual void Log( const char *pLogString, ... ) = 0;
};

class CGenLog : public IGenLog {

    FILE            *m_pFileHandle;
    char            *m_pWriteBuffer;
    unsigned long   m_lWriteBufferLen;

public:
    CGenLog();
    CGenLog(const char *pszFilePath);
    ~CGenLog();

    long
    InitLog
    (
    IN  const char          *pszFilePath = NULL,
    IN  const char          *pszMode = NULL,
    IN  const unsigned long lWriteBuffer = GENLOG_DEFAULT_WRITEBUFSIZE
    );

    void
    ResetGenLog();

    void
    Header(const char *pszHeaderString = NULL);

    void
    Now();

public:

    virtual void Debug( const char *pDebugString, ... );
    virtual void Error( const char *pErrorString, ... );
    virtual void Log( const char *pLogString, ... );

protected:
    long Write();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by emsvc.rc
//
#define IDS_SERVICENAME                 100
#define IDR_Emsvc                       100
#define IDR_DEBUGSESSION                101
#define IDS_SERVICE                     101
#define IDR_EMMANAGER                   102
#define IDS_PROCESS                     102
#define IDS_IMAGENAME                   103
#define IDR_EMDEBUGSESSION              104
#define IDS_SHORTNAME                   104
#define IDS_DESCRIPTION                 105
#define IDR_EMFILE                      106
#define IDS_SECONDARYNAME               106
#define IDS_DEBUGGEE_EXCEPTION          107
#define IDS_DEBUGGEE_ACCESSVIOLATION    108

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\processes.cpp ===
g// EmExtn.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#include <Psapi.h>
#include <winsvc.h>
#include <comsvcs.h>

#include "Processes.h"

#define SUCCESS 0

DWORD
InvalidCallback
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumSrvcsProc,
/* [in] */ LPARAM				lParam,
/* [in] */ LONG                 nItemNum
)
{
    return( lpEnumSrvcsProc( INVALID_PID, NULL, NULL, NULL, lParam, nItemNum ) );
}

DWORD
GetNumberOfRunningApps
(
/* [out] */ DWORD   *pdwNumbApps
)
{
	DWORD	dwLastRet	=	0L;
	DWORD	*pdwPIDs	=	NULL;
	DWORD	dwBuffSize	=	256L;
	UINT	nIdx		=	0;
    bool    bIsService  =   false;
	
	do
	{
		//
		// This loop is used to get all the running PIDs
		// in the system. Because we do not know how many
		// processes are running, we dynamically increase
		// the array size. Limit = 256 DWORDs * 5
		//
		do {

			if(pdwPIDs != NULL){

                delete[] pdwPIDs;
				pdwPIDs = NULL;
			}

			dwBuffSize *= (nIdx + 1);
			pdwPIDs = new DWORD[dwBuffSize];

            if(pdwPIDs == NULL){

                dwLastRet = GetLastError();
				break;
			}

			dwLastRet = GetAllPids(
								pdwPIDs,
								dwBuffSize,
								&dwBuffSize
								);
		}
		while(dwLastRet == E_TOOMANY_PROCESSES);

		if( dwLastRet == 0 ){

            *pdwNumbApps = 0L;

            for(UINT i = 0; i < dwBuffSize; ++i)
            {
                IsService( pdwPIDs[i], &bIsService );
                if( bIsService != true ) *pdwNumbApps += 1;
            }
		}
	}
	while ( false );

	if(pdwPIDs != NULL) {

		delete[] pdwPIDs;
		pdwPIDs = NULL;
	}

	return dwLastRet;
}

DWORD
GetAllPids
(
/* [out] */	DWORD	adwProcIDs[],
/* [in] */	DWORD	dwBuffSize,
/* [out] */	DWORD	*pdwNumbProcs
)
{
	DWORD	dwLastRet	=	0L;

	_ASSERT(adwProcIDs != NULL);
	_ASSERT(dwBuffSize != 0L);
	_ASSERT(pdwNumbProcs != NULL);

	do
	{
		if( (adwProcIDs == NULL)	||
			(dwBuffSize == 0L)		||
			(pdwNumbProcs == 0L)) {

            dwLastRet = E_INVALIDARG;
			break;
		}

		//
		// Get the list of process identifiers.
		//
		dwLastRet = (DWORD)EnumProcesses(
									adwProcIDs,
									dwBuffSize,
									pdwNumbProcs);
		
		if(dwLastRet == 0L){
			dwLastRet = GetLastError();
			break;
		}

		//
		// If both of them are same, it means that
		// there may be more PIDs for which there
		// is no space..
		//
		if(dwBuffSize == *pdwNumbProcs){
			dwLastRet = ERROR_NOT_ENOUGH_MEMORY;
			break;
		}

		//
		// This will give us the number of PIDs
		//
		(*pdwNumbProcs) = ((*pdwNumbProcs) / sizeof(DWORD));
        dwLastRet = 0L;
	}
	while(FALSE);

	return dwLastRet;
}

DWORD
GetNumberOfServices
(
/* [out] */ DWORD   *pdwNumbSrvcs,
/* [in] */  DWORD   dwServiceType, /* = SERVICE_WIN32 */
/* [in] */  DWORD   dwServiceState /* = SERVICE_ACTIVE */
)
{
    _ASSERTE( pdwNumbSrvcs != NULL );

    DWORD                   dwLastRet       =   0L;
    SC_HANDLE               scm             =   NULL;
    LPENUM_SERVICE_STATUS   status          =   NULL;
    DWORD                   cbBytesNeeded   =   0L,
                            dwNumbSvcs      =   0L,
                            dwResume        =   0L;
    ENUM_SERVICE_STATUS     aServices[1]; // a-mando, bug ID: 296023

    __try {

        if( pdwNumbSrvcs == NULL ) { dwLastRet = -1L; goto qGetNumberOfServices; }

        scm = OpenSCManager(
                            NULL,
                            NULL,
                            SC_MANAGER_ENUMERATE_SERVICE
                            );

        if( !scm ) { dwLastRet = GetLastError(); goto qGetNumberOfServices; }

        *pdwNumbSrvcs = 0L;

        if( EnumServicesStatus(
                        scm,
                        dwServiceType,
                        dwServiceState,
                        aServices, // a-mando, bug ID: 296023
                        0,
                        &cbBytesNeeded,
                        &dwNumbSvcs,
                        &dwResume
                        ) == false ) {

            dwLastRet = GetLastError();
        }

        if( dwLastRet != ERROR_MORE_DATA ) { goto qGetNumberOfServices;}
        
		//
		// Allocate space
		//
		status = (LPENUM_SERVICE_STATUS)LocalAlloc(
									LPTR,
									cbBytesNeeded
									);

        if( !status ) { dwLastRet = GetLastError(); goto qGetNumberOfServices; }

		//
		// Get the status records.
		//
		dwResume = 0;
		dwLastRet = EnumServicesStatus(
									scm,
									dwServiceType,
									dwServiceState,
									status,
									cbBytesNeeded,
									&cbBytesNeeded,
									&dwNumbSvcs,
									&dwResume
									);

        if (dwLastRet == 0) { dwLastRet = GetLastError(); goto qGetNumberOfServices; }

        *pdwNumbSrvcs = dwNumbSvcs;

        dwLastRet = SUCCESS;

qGetNumberOfServices:
        if( scm ) CloseServiceHandle( scm );
        if( status ) LocalFree( status );

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		dwLastRet = GetLastError();

        if( scm ) CloseServiceHandle( scm );
        if( status ) LocalFree( status );

        _ASSERTE( false );
	}

    return dwLastRet;
}

DWORD
GetNumberOfActiveServices
(
/* [out] */  DWORD   *pdwNumbActiveSrvcs
)
{
    return GetNumberOfServices( pdwNumbActiveSrvcs );
}

DWORD
GetNumberOfInactiveServices
(
/* [out] */  DWORD   *pdwNumbInactiveSrvcs
)
{
    return GetNumberOfServices( pdwNumbInactiveSrvcs, SERVICE_WIN32, SERVICE_INACTIVE );
}

DWORD
IsService
(
/* [in] */  UINT    nPid,
/* [out] */ bool    *pbIsService,
/* [out] */ LPTSTR  lpszImagePath,
/* [out] */ ULONG   cchImagePath,
/* [out] */ LPTSTR  lpszServiceShortName,
/* [in] */  ULONG   cchServiceShortName,
/* [out] */ LPTSTR  lpszServiceDescription,
/* [in] */  ULONG   cchServiceDescription
)
{
    DWORD           dwRet   =   0L;
    OSVERSIONINFO   osvi;

    ZeroMemory( (void *)&osvi, sizeof(OSVERSIONINFO) );
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( !GetVersionEx (&osvi) ) {

        return (dwRet = GetLastError());
    }

    if( osvi.dwPlatformId & VER_PLATFORM_WIN32_NT ) {

        if( osvi.dwMajorVersion == 4 ) {
            // && osvi.dwMinorVersion == 0 ) { // we will not look for the minor version.

            IsService_NT4( nPid, pbIsService );
        }
        else if( osvi.dwMajorVersion == 5 ) { 
            // && osvi.dwMinorVersion == 0 ) {

            IsService_NT5(
                        nPid,
                        pbIsService,
                        lpszImagePath,
                        cchImagePath,
                        lpszServiceShortName,
                        cchServiceShortName,
                        lpszServiceDescription,
                        cchServiceDescription
                        );
        }
    }

    return dwRet;
}

DWORD
IsService_NT5
(
/* [in] */  UINT    nPid,
/* [out] */ bool    *pbIsService,
/* [out] */ LPTSTR  lpszImagePath,
/* [out] */ ULONG   cchImagePath,
/* [out] */ LPTSTR  lpszServiceShortName,
/* [in] */  ULONG   cchServiceShortName,
/* [out] */ LPTSTR  lpszServiceDescription,
/* [in] */  ULONG   cchServiceDescription
)
{
    _ASSERTE ( pbIsService != NULL );

    bool                        bIsService  =   false;
	DWORD					    dwLastRet	=	0L;
	int						    i			=	0;
	SC_HANDLE				    scm			=	NULL;
	ENUM_SERVICE_STATUS_PROCESS *status	    =	NULL;
	DWORD					    numServices =	0L,
							    sizeNeeded	=	0L,
							    resume		=	0L;

	__try
	{

        if( pbIsService == NULL ) { dwLastRet = -1L; goto qIsService; }
		//
		// Open a connection to the SCM
		//
		scm = OpenSCManager(0, 0, SC_MANAGER_ENUMERATE_SERVICE);

        if ( !scm ){ dwLastRet = GetLastError(); goto qIsService; }

		//
		// Get the number of bytes to allocate
		//
		resume = 0;
		if( EnumServicesStatusEx(
									scm,
                                    SC_ENUM_PROCESS_INFO,
									SERVICE_WIN32, // We won't debug drivers
                                    SERVICE_ACTIVE,
									0,
									0,
									&sizeNeeded,
									&numServices,
									&resume,
                                    NULL
                                    ) == 0 ) {

			dwLastRet = GetLastError();

			//
			// If it is any error other than this,
			// we won't continue..
			//
			if(dwLastRet != ERROR_MORE_DATA) goto qIsService;
		}

		//
		// Allocate space
		//
		status = (ENUM_SERVICE_STATUS_PROCESS *)LocalAlloc(
									LPTR,
									sizeNeeded
									);

        if( status == NULL ){ dwLastRet = GetLastError(); goto qIsService; }

		//
		// Get the status records.
		//
		resume = 0;
		if( EnumServicesStatusEx(
									scm,
                                    SC_ENUM_PROCESS_INFO,
									SERVICE_WIN32, // We won't debug drivers
                                    SERVICE_ACTIVE,
									(LPBYTE)status,
									sizeNeeded,
									&sizeNeeded,
									&numServices,
									&resume,
                                    NULL
                                    ) == 0 ) {

			dwLastRet = GetLastError(); goto qIsService;
		}

        *pbIsService = false;
		for (i = 0; i < (int)numServices; i++)
		{
            if( status[i].ServiceStatusProcess.dwProcessId == nPid ) {

                *pbIsService = true;

                if(lpszImagePath)
                    { _tcsncpy( lpszImagePath, _T(""), cchImagePath ); }
                
                if(lpszServiceShortName)
                    { _tcsncpy( lpszServiceShortName, status[i].lpServiceName, cchServiceShortName ); }
                
                if(lpszServiceDescription)
                    { _tcsncpy( lpszServiceDescription, status[i].lpDisplayName, cchServiceDescription ); }

                break;
            }
		}

        dwLastRet = SUCCESS;

qIsService:
        if( scm ) { CloseServiceHandle(scm); scm = NULL; }
        if( status ){ LocalFree(status); status = NULL; }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		dwLastRet = GetLastError();

        if( scm ) { CloseServiceHandle( scm ); scm = NULL; }
        if( status ){ LocalFree(status); status = NULL; }

        _ASSERTE( false );
	}

	return dwLastRet;
}

DWORD
GetServiceInfo
(
/* [in] */  UINT    nPid,
/* [out] */ LPTSTR  lpszImagePath,
/* [out] */ ULONG   cchImagePath,
/* [out] */ LPTSTR  lpszServiceShortName,
/* [in] */  ULONG   cchServiceShortName,
/* [out] */ LPTSTR  lpszServiceDescription,
/* [in] */  ULONG   cchServiceDescription
)
{
    bool    bIsService  =   false;

    return IsService(
                    nPid,
                    &bIsService,
                    lpszImagePath,
                    cchImagePath,
                    lpszServiceShortName,
                    cchServiceShortName,
                    lpszServiceDescription,
                    cchServiceDescription 
                    );
}

DWORD
EnumRunningProcesses
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumRunProc,
/* [in] */ LPARAM				lParam,
/* [in] */ UINT                 nStartIndex
)
{
	// Nothing to do if this is NULL..
	_ASSERT(lpEnumRunProc != NULL);

	DWORD	dwLastRet				=	0L;
	DWORD	dwBuffSize				=	256L;
	DWORD	*pdwPIDs				=	NULL;
	UINT	nIdx					=	0;
    UINT    nItemNum                =   nStartIndex;
    bool    bService                =   FALSE;
    TCHAR   szShortName[_MAX_PATH]  =   _T("");
	TCHAR   szImagePath[_MAX_PATH]	=   _T("");

	__try
	{
        if( !lpEnumRunProc ){ dwLastRet = E_INVALIDARG; goto qEnumRunningProcesses; }

		//
		// This loop is used to get all the running PIDs
		// in the system. Because we do not know how many
		// processes are running, we dynamically increase
		// the array size. Limit = 256 DWORDs * 5
		//
		do{
			if(pdwPIDs != NULL){
				delete[] pdwPIDs;
				pdwPIDs = NULL;
			}

			dwBuffSize *= (nIdx + 1);
			pdwPIDs = new DWORD[dwBuffSize];
			if(pdwPIDs == NULL){
				dwLastRet = GetLastError();
				break;
			}

			dwLastRet = GetAllPids(
								pdwPIDs,
								dwBuffSize,
								&dwBuffSize
								);
		}
		while(dwLastRet == E_TOOMANY_PROCESSES);

		//
		// There are more processes than we
		// can handle..
		//
        if( dwLastRet != E_TOOMANY_PROCESSES && dwLastRet != 0){ goto qEnumRunningProcesses; }

		//
		// If everything goes alright, call the Callback procedure
		// once for each PID (or till the procedure returns FALSE)
		// with the PID and the corresponding Image path..
		//
		nIdx = -1;
		while(++nIdx < dwBuffSize){
            dwLastRet = SUCCESS;

            IsService( pdwPIDs[nIdx], &bService );
            if( bService == true ) continue; // we won't add services into the list..

            // This may fail for some procs like the system process.
            if( GetImageNameFromPID( pdwPIDs[nIdx], szImagePath, _MAX_PATH )) {

                if(lpEnumRunProc(INVALID_PID, NULL, NULL, NULL, lParam, nItemNum++) == FALSE){

                    dwLastRet = FALSE;
				    goto qEnumRunningProcesses; // Stop when the Callback procedure returns FALSE.
			    }

            }
            else {

                BSTR bstrDesc = _T("");

                if( IsPackage( szImagePath ) ) {

                    GetPackageDescription( pdwPIDs[nIdx], bstrDesc );
                }

                if(lpEnumRunProc(pdwPIDs[nIdx], szImagePath, _T(""), bstrDesc, lParam, nItemNum++ ) == FALSE) {

                    dwLastRet = FALSE;
				    goto qEnumRunningProcesses; // Stop when the Callback procedure returns FALSE.
			    }
            }
		}

        dwLastRet = SUCCESS;

qEnumRunningProcesses:
	    //
	    // Clean up memory allocated for PIDs array.
	    //
        if( pdwPIDs ) { delete[] pdwPIDs; pdwPIDs = NULL; }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		dwLastRet = GetLastError();

        if( pdwPIDs ) { delete[] pdwPIDs; pdwPIDs = NULL; }

        _ASSERTE( false );
	}

	return dwLastRet;
}

BOOL
IsPackage
(
IN  LPTSTR  lpszImageName
)
{
    _ASSERTE( lpszImageName != NULL );

    BOOL        bRet        =   false;
    const DWORD cTemplates  =   2;
    LPCTSTR     szTemplate [cTemplates];

    __try
    {
        if( !lpszImageName ) { return (bRet = false); }

        _tcslwr( lpszImageName );
        szTemplate[0] = _T("dllhost.exe");
        szTemplate[1] = _T("mts.exe");

        for( int i = 0; i < cTemplates; i++ ) {

            if( _tcsstr( lpszImageName, szTemplate[i] ) != NULL ) {

                bRet = true;
                break;
            }
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        bRet = false;

        _ASSERTE( false );
	}

	return bRet;
}

DWORD
EnumRunningServices
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumSrvcsProc,
/* [in] */ LPARAM				lParam,
/* [in] */ UINT                 nStartIndex
)
{
    return EnumServices( lpEnumSrvcsProc, lParam, SERVICE_ACTIVE, nStartIndex );
}


DWORD
EnumStoppedServices
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumSrvcsProc,
/* [in] */ LPARAM				lParam,
/* [in] */ UINT                 nStartIndex
)
{
    return EnumServices( lpEnumSrvcsProc, lParam, SERVICE_INACTIVE, nStartIndex );
}

DWORD
EnumServices
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumSrvcsProc,
/* [in] */ LPARAM				lParam,
/* [in] */ DWORD                dwSrvcState,
/* [in] */ UINT                 nStartIndex
)
{
    _ASSERTE ( lpEnumSrvcsProc != NULL );

    bool                        bIsService  =   false;
	DWORD					    dwLastRet	=	0L;
	int						    i			=	0;
	SC_HANDLE				    scm			=	NULL,
                                service     =   NULL;
    LPQUERY_SERVICE_CONFIG      buffer      =   NULL;
	ENUM_SERVICE_STATUS_PROCESS *status	    =	NULL;
	DWORD					    numServices =	0L,
							    sizeNeeded	=	0L,
							    resume		=	0L;
    UINT                        nItemNum    =   nStartIndex;


	__try
	{

        if( lpEnumSrvcsProc == NULL ) { dwLastRet = -1L; goto qEnumServices; }
		//
		// Open a connection to the SCM
		//
		scm = OpenSCManager(0, 0, SC_MANAGER_ENUMERATE_SERVICE);

        if ( !scm ){ dwLastRet = GetLastError(); goto qEnumServices; }

		//
		// Get the number of bytes to allocate
		//
		resume = 0;
		if( EnumServicesStatusEx(
									scm,
                                    SC_ENUM_PROCESS_INFO,
									SERVICE_WIN32, // We won't debug drivers
                                    dwSrvcState,
									0,
									0,
									&sizeNeeded,
									&numServices,
									&resume,
                                    NULL
                                    ) == 0 ) {

			dwLastRet = GetLastError();

			//
			// If it is any error other than this,
			// we won't continue..
			//
			if(dwLastRet != ERROR_MORE_DATA) goto qEnumServices;
		}

		//
		// Allocate space
		//
		status = (ENUM_SERVICE_STATUS_PROCESS *)LocalAlloc(
									LPTR,
									sizeNeeded
									);

        if( status == NULL ){ dwLastRet = GetLastError(); goto qEnumServices; }

		//
		// Get the status records.
		//
		resume = 0;
		if( EnumServicesStatusEx(
									scm,
                                    SC_ENUM_PROCESS_INFO,
									SERVICE_WIN32, // We won't debug drivers
                                    dwSrvcState,
									(LPBYTE)status,
									sizeNeeded,
									&sizeNeeded,
									&numServices,
									&resume,
                                    NULL
                                    ) == 0 ) {

			dwLastRet = GetLastError(); goto qEnumServices;
		}

		for (i = 0; i < (int)numServices; i++)
		{
			if(service){
				CloseServiceHandle(service);
				service = NULL;
			}

			service = OpenService(	scm, 
									status[i].lpServiceName,
									SERVICE_QUERY_CONFIG
									);

            if (!service) {
                
                dwLastRet = GetLastError();
                InvalidCallback( lpEnumSrvcsProc, lParam, nItemNum++ );
                continue;
            } //goto qEnumServices; }

			//
			// Find out how big the buffer needs to be
			//
			dwLastRet =  QueryServiceConfig(
									service,
									0,
									0,
									&sizeNeeded
									);

			if(dwLastRet == 0){
				dwLastRet = GetLastError();

				//
				// If it is any error other than
				// this, we won't continue..
				//
                if(dwLastRet != ERROR_INSUFFICIENT_BUFFER) {

                    InvalidCallback( lpEnumSrvcsProc, lParam, nItemNum++ );
                    continue;
                }
			}

			//
			// Allocate space for the buffer
			//
			buffer = (LPQUERY_SERVICE_CONFIG)
							LocalAlloc(
									LPTR,
									sizeNeeded
									);

			//
			// Get Buffer
			//
			dwLastRet = QueryServiceConfig(
									service,
									buffer,
									sizeNeeded,
									&sizeNeeded
									);
			if (dwLastRet == 0){
				dwLastRet = GetLastError();
                InvalidCallback( lpEnumSrvcsProc, lParam, nItemNum++ );
                continue;
			}

            _tcslwr(buffer->lpBinaryPathName);

            if(lpEnumSrvcsProc(
                            status[i].ServiceStatusProcess.dwProcessId,
                            buffer->lpBinaryPathName,
                            status[i].lpServiceName,
                            status[i].lpDisplayName,
                            lParam,
                            nItemNum++
                            ) == FALSE) {

                dwLastRet = FALSE;
				goto qEnumServices; // Stop when the Callback procedure returns FALSE.
			}

            //
			// CleanUp
			//
			if(buffer != NULL){
				LocalFree(buffer);
				buffer = NULL;
			}

		}

        dwLastRet = SUCCESS;

qEnumServices:
        if( scm ) { CloseServiceHandle(scm); scm = NULL; }
        if( status ){ LocalFree(status); status = NULL; }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		dwLastRet = GetLastError();

        if( scm ) { CloseServiceHandle( scm ); scm = NULL; }
        if( status ){ LocalFree(status); status = NULL; }

        _ASSERTE( false );
	}

	return dwLastRet;
}

DWORD
StartServiceAndGetPid
(
IN	LPCTSTR	lpszServiceShortName,
OUT	UINT	*pnPid
)
{
	_ASSERTE(lpszServiceShortName != NULL);

	DWORD	    dwLastRet	    =	0L;
	DWORD	    dwBytesNeeded	=	0L;
  	SC_HANDLE	scm			    =	NULL,
                service         =   NULL;

    SERVICE_STATUS_PROCESS	stInfo;


	do
	{
		//
		// Open a connection to the SCM
		//
		scm = OpenSCManager(0, 0, GENERIC_EXECUTE | STANDARD_RIGHTS_REQUIRED | SC_MANAGER_ENUMERATE_SERVICE);

		if (!scm){
			dwLastRet = GetLastError();
			break;
		}

		service = OpenService( scm, lpszServiceShortName, GENERIC_EXECUTE | STANDARD_RIGHTS_REQUIRED | SC_MANAGER_ENUMERATE_SERVICE );

		if (!service){
			dwLastRet = GetLastError();
			break;
		}

		if( StartService( service, 0L, NULL ) == 0 ) {

			dwLastRet = GetLastError();
			break;
		}

		if( QueryServiceStatusEx(
				service,
				SC_STATUS_PROCESS_INFO,
				(LPBYTE) &stInfo,
				sizeof stInfo,
				&dwBytesNeeded
				) == 0 ) {

			dwLastRet = GetLastError();
			break;
		}

        //
        // Successful..
        //
		*pnPid = stInfo.dwProcessId;
        dwLastRet = 0L;
	}
	while(FALSE);

	if(scm){
		CloseServiceHandle(scm);
		scm = NULL;
	}

	if(service){
		CloseServiceHandle(service);
		service = NULL;
	}

	return dwLastRet;
}

BOOL
IsImageRunning
(
/* [in] */ ULONG lPID
)
{
	bool bRet = FALSE;

	HANDLE hProcess = ::OpenProcess(
							PROCESS_QUERY_INFORMATION,
							FALSE,
							lPID
							);

	if(hProcess != NULL){
		CloseHandle(hProcess);
		bRet = TRUE;
	}

	return bRet;
}

DWORD
GetImageNameFromPID
(
/* [in] */	ULONG	lPID,
/* [out] */	LPTSTR	lpszImagePath,
/* [in] */	DWORD	dwBuffSize
)
{
	DWORD	dwLastRet			=	S_OK;
	HANDLE	hProcess			=	NULL;
	HMODULE	hMod				=	NULL;
	DWORD	cbNeeded			=	0L;

	//
	// 0 is a valid PID..
	//
//	_ASSERT(lPID != 0L);
	_ASSERT(lpszImagePath != NULL);

	do
	{
		if( /*(lPID == 0L)	||*/
			(lpszImagePath == NULL) ){
			dwLastRet = E_INVALIDARG;
			break;
		}

		//
		// Get a handle to the process.
		//
		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
								PROCESS_VM_READ,
								FALSE,
								lPID
								);

		if (hProcess == NULL){
			dwLastRet = GetLastError();
			break;
		}

		//
		// We do not want to enumerate all the modules in the
		// process, but only one..
		//
		dwLastRet = EnumProcessModules(
								hProcess,
								&hMod,
								sizeof(hMod),
								&cbNeeded
								);

		if(dwLastRet == NULL){
			dwLastRet = GetLastError();
			break;
		}

		//
	    // Get the process name.
		//
		dwLastRet = GetModuleBaseName(
								hProcess,
								hMod,
								lpszImagePath,
								dwBuffSize
								);

		if(dwLastRet == NULL){
			dwLastRet = GetLastError();
			break;
		}

		//
		// We will store all the strings in
		// lower case..
		//
		_tcslwr(lpszImagePath);
		dwLastRet = SUCCESS;

	}while(FALSE);

    if(hProcess) CloseHandle(hProcess);

	return dwLastRet;
}

DWORD
IsValidImage
(
/* [in] */  ULONG   lPID,
/* [in] */  LPCTSTR lpszImageName,
/* [out] */ bool    *pbValidImage
)
{
    _ASSERTE( lpszImageName != NULL );

    DWORD   dwLastRet                   =   0L;
    TCHAR   szImageName[_MAX_PATH+1]    =   _T("");

    __try
    {
        if( lpszImageName == NULL ) {

            return (dwLastRet = -1L);
        }

        *pbValidImage = false;

        dwLastRet = GetImageNameFromPID( lPID, szImageName, _MAX_PATH );
        if( dwLastRet != SUCCESS ) return dwLastRet;

        *pbValidImage = (_tcsicmp( szImageName, lpszImageName) == 0);
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 )
    {
        dwLastRet = GetLastError();
        _ASSERTE(false);
    }

    return dwLastRet;
}

DWORD
IsValidProcess
(
/* [in] */  ULONG   lPID,
/* [in] */  LPCTSTR lpszImageName,
/* [out] */ bool    *pbValidImage
)
{
    return IsValidImage( lPID, lpszImageName, pbValidImage );
}

DWORD
IsValidService
(
/* [in] */  ULONG   lPID,
/* [in] */  LPCTSTR lpszImageName,
/* [out] */ bool    *pbValidImage
)
{
    _ASSERTE( lpszImageName != NULL );

    DWORD   dwLastRet                   =   0L;
    TCHAR   szImageName[_MAX_PATH+1]    =   _T("");
    LPCTSTR lpszImage                   =   NULL;

    __try
    {
        if( lpszImageName == NULL ) {

            return (dwLastRet = -1L);
        }

        lpszImage = _tcsrchr( lpszImageName, _T('\\') );

        if( !lpszImage ) { lpszImage = lpszImageName; }
        else { lpszImage += 1; }

        dwLastRet = IsValidImage( lPID, lpszImage, pbValidImage );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 )
    {
        dwLastRet = GetLastError();
        _ASSERTE(false);
    }

    return dwLastRet;
}

DWORD
GetProcessHandle
(
IN  ULONG   lPid,
OUT HANDLE  *phProcess
)
{
    DWORD   dwLastRet   =   0L;

    __try
    {
		//
		// Get a handle to the process.
		//
        dwLastRet = SUCCESS;
		*phProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
								PROCESS_VM_READ,
								FALSE,
								lPid
								);

		if (*phProcess == NULL){

            dwLastRet = GetLastError();
		}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 )
    {
        dwLastRet = GetLastError();
        _ASSERTE(false);
    }

    return dwLastRet;
}

HRESULT
GetPackageDescription
(
IN  const long  nPid,
OUT BSTR        &bstrDescription
)
{
    _ASSERTE( nPid != 0 );

	HRESULT	    hr              =   E_FAIL;
	IMtsGrp*	pMtsGrp         =   NULL;
	IUnknown*	pUnk            =   NULL;
	IMtsEvents* pEvents         =   NULL;
	long		lPackages       =   0;
	long		lPID            =   0;
	long		lLp             =   0;

    __try
    {
        if( !nPid ) { return (hr = E_INVALIDARG); }

	    //Create the MTS Group object
	    hr = CoInitialize( NULL );
        if( FAILED(hr) ) { goto qGetPackageDescription; }

	    hr = CoCreateInstance (CLSID_MtsGrp, NULL, CLSCTX_ALL, IID_IMtsGrp, (void **)&pMtsGrp);
        if( FAILED(hr) ) { goto qGetPackageDescription; }

	    hr = pMtsGrp->Refresh(); // its important to call this!
        if( FAILED(hr) ) { goto qGetPackageDescription; }

	    hr = pMtsGrp->get_Count( &lPackages );
        if( FAILED(hr) ) { goto qGetPackageDescription; }

        for (lLp = 0; lLp < lPackages; lLp++)
	    {

		    hr = pMtsGrp->Item(lLp, &pUnk);
            if( FAILED(hr) ) { goto qGetPackageDescription; }

		    hr = pUnk->QueryInterface(IID_IMtsEvents, (void **)&pEvents);
            if( FAILED(hr) || !pEvents ) { goto qGetPackageDescription; }
            if( pUnk ) { pUnk->Release(); pUnk = NULL; }

            hr = pEvents->GetProcessID( &lPID );
            if( FAILED(hr) ) { goto qGetPackageDescription; }

            if( lPID == nPid ) { // This is the package we are looking for..

		        hr = pEvents->get_PackageName( &bstrDescription );
                if( FAILED(hr) ) { goto qGetPackageDescription; }
                break; // We got what we were looking for.
            }

            if( pEvents ) { pEvents->Release(); pEvents = NULL; }

        }

        hr = S_OK;

qGetPackageDescription:
        if( pEvents ) { pEvents->Release(); pEvents = NULL; }
        if( pUnk ) { pUnk->Release(); pUnk = NULL; }
        if( pMtsGrp ) { pMtsGrp->Release(); pMtsGrp = NULL; }

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 )
    {
        if( pEvents ) { pEvents->Release(); pEvents = NULL; }
        if( pUnk ) { pUnk->Release(); pUnk = NULL; }
        if( pMtsGrp ) { pMtsGrp->Release(); pMtsGrp = NULL; }

        hr = E_UNEXPECTED;

        _ASSERTE(false);
    }

    return hr;
}

/*

  EnumServicesStatusEx(..) is not supported on NT 4.0.
  <http://www.mvps.org/win32/security/is_svc.html>

*/

HRESULT
IsService_NT4
(
IN  UINT    nPid,
OUT bool    *pbIsService
)
{
    _ASSERTE( nPid > 0 );

    HRESULT                     hr              =   E_FAIL;
    HANDLE                      hProcess        =   NULL;
	HANDLE                      hProcessToken   =   NULL;
	DWORD                       groupLength     =   50;
	PTOKEN_GROUPS               groupInfo       =   NULL;
	SID_IDENTIFIER_AUTHORITY    siaNt           =   SECURITY_NT_AUTHORITY;
	PSID                        pInteractiveSid =   NULL;
	PSID                        pServiceSid     =   NULL;
	DWORD                       dwRet           =   NO_ERROR;
	DWORD                       ndx;
	bool                        isInteractive   =   FALSE,
                                isService       =   FALSE;


    __try
    {

        if( nPid <= 0 ) { hr = E_INVALIDARG; goto qIsService; }

        hr = GetProcessHandle( nPid, &hProcess );
        if( FAILED(hr) ) { goto qIsService; }

	    // open the token
	    if( !::OpenProcessToken( hProcess, TOKEN_QUERY, &hProcessToken) ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
		    goto qIsService;
	    }

	    // allocate a buffer of default size
	    groupInfo = (PTOKEN_GROUPS)::LocalAlloc(0, groupLength);
	    if ( !groupInfo ) {

		    hr = HRESULT_FROM_WIN32( GetLastError() );
		    goto qIsService;
	    }

	    // try to get the info
	    if (!::GetTokenInformation(
                            hProcessToken,
                            TokenGroups,
                            groupInfo,
                            groupLength,
                            &groupLength
                            )
            ) {

		    // if buffer was too small, allocate to proper size, otherwise error
		    if (::GetLastError() != ERROR_INSUFFICIENT_BUFFER) {

			    hr = HRESULT_FROM_WIN32( GetLastError() );
			    goto qIsService;
		    }

		    ::LocalFree(groupInfo);

		    groupInfo = (PTOKEN_GROUPS)::LocalAlloc(0, groupLength);
		    if (groupInfo == NULL) {

			    hr = HRESULT_FROM_WIN32( GetLastError() );
			    goto qIsService;
		    }

		    if (!GetTokenInformation(hProcessToken, TokenGroups,
			    groupInfo, groupLength, &groupLength)) {

			    hr = HRESULT_FROM_WIN32( GetLastError() );
			    goto qIsService;
		    }
	    }

	    //
	    //  We now know the groups associated with this token.  We want
	    //  to look to see if the interactive group is active in the
	    //  token, and if so, we know that this is an interactive process.
	    //
	    //  We also look for the "service" SID, and if it's present,
	    //  we know we're a service.
	    //
	    //  The service SID will be present iff the service is running in a
	    //  user account (and was invoked by the service controller).
	    //

	    // create comparison sids
	    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID,
		    0, 0, 0, 0, 0, 0, 0, &pInteractiveSid)) {

		    hr = HRESULT_FROM_WIN32( GetLastError() );
		    goto qIsService;
	    }

	    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID,
		    0, 0, 0, 0, 0, 0, 0, &pServiceSid)) {

		    hr = HRESULT_FROM_WIN32( GetLastError() );
		    goto qIsService;
	    }


	    // reset flags
	    isInteractive = FALSE;
	    isService = FALSE;

	    // try to match sids
	    for (ndx = 0; ndx < groupInfo->GroupCount ; ndx += 1)
	    {
		    SID_AND_ATTRIBUTES sanda = groupInfo->Groups[ndx];
		    PSID pSid = sanda.Sid;

		    //
		    //	  Check to see if the group we're looking at is one of
		    //	  the two groups we're interested in.
		    //

		    if (::EqualSid(pSid, pInteractiveSid))
		    {
			    //
			    //  This process has the Interactive SID in its
			    //  token.  This means that the process is running as
			    //  a console process
			    //
			    isInteractive = TRUE;
			    isService = FALSE;
			    break;
		    }
		    else if (::EqualSid(pSid, pServiceSid))
		    {
			    //
			    //  This process has the Service SID in its
			    //  token.  This means that the process is running as
			    //  a service running in a user account ( not local system ).
			    //
			    isService = TRUE;
			    isInteractive = FALSE;
			    break;
		    }
	    }

	    if ( !( isService || isInteractive ) )
	    {
		    //
		    //  Neither Interactive or Service was present in the current
		    //  users token, This implies that the process is running as
		    //  a service, most likely running as LocalSystem.
		    //
		    isService = TRUE;

	    }

qIsService:
		if ( pServiceSid )
			::FreeSid( pServiceSid );

		if ( pInteractiveSid )
			::FreeSid( pInteractiveSid );

		if ( groupInfo )
			::LocalFree( groupInfo );

		if ( hProcessToken )
			::CloseHandle( hProcessToken );

        if( hProcess ) { CloseHandle( hProcess ); }

    }

    __except( EXCEPTION_EXECUTE_HANDLER, 1 )
    {
        hr = E_UNEXPECTED;
        _ASSERTE(false);
    }

    //
    // BUGBUG:  If the function fails, we treat
    //          the process as an app
    //
    *pbIsService = isService;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\rwfile.cpp ===
#include "stdafx.h"
#include "rwfile.h"

CRWFile::CRWFile()
{
    IRWFile::m_hFile = INVALID_HANDLE_VALUE;
}

CRWFile::~CRWFile()
{
    if( IRWFile::m_hFile != INVALID_HANDLE_VALUE ) {

        CloseHandle( IRWFile::m_hFile );
    }
}

HRESULT CRWFile::InitFile
(
IN  LPCTSTR                 lpFileName,
IN  DWORD                   dwDesiredAccess,
IN  DWORD                   dwShareMode,
IN  LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
IN  DWORD                   dwCreationDisposition,
IN  DWORD                   dwFlagsAndAttributes,
IN  HANDLE                  hTemplateFile
)
{
    _ASSERTE( lpFileName != NULL );

    HRESULT hr  =   E_FAIL;

    __try
    {

        if( !lpFileName ) { hr = E_INVALIDARG; goto qInitFile; }

        m_hFile = CreateFile(
                        lpFileName,
                        dwDesiredAccess,
                        dwShareMode,
                        lpSecurityAttributes,
                        dwCreationDisposition,
                        dwFlagsAndAttributes,
                        hTemplateFile
                        );

        if( m_hFile == INVALID_HANDLE_VALUE ) {

            hr = HRESULT_FROM_WIN32(GetLastError());
            goto qInitFile;
        }

        hr = S_OK;

qInitFile:
        if( FAILED(hr) ) {}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT CRWFile::Read
(
OUT LPVOID          lpBuffer,
IN  DWORD           nNumberOfBytesToRead,
OUT LPDWORD         lpNumberOfBytesRead,
OUT LPOVERLAPPED    lpOverlapped
)
{
    _ASSERTE( lpBuffer != NULL );
    _ASSERTE( nNumberOfBytesToRead > 0 );

    HRESULT hr      =   E_FAIL;
    BOOL    bRet    =   false;

    __try
    {
        if( !lpBuffer || nNumberOfBytesToRead <= 0 ){

            hr = E_INVALIDARG; goto qRead;
        }

        bRet = ReadFile(
                    m_hFile,
                    lpBuffer,
                    nNumberOfBytesToRead,
                    lpNumberOfBytesRead,
                    lpOverlapped
                    );

        if( bRet && *lpNumberOfBytesRead == 0 ) { // crossed beyond the end of the file.

            hr = S_FALSE; goto qRead;
        }

        if( !bRet ) {

            hr = HRESULT_FROM_WIN32(GetLastError()); goto qRead;
        }

        hr = S_OK;

qRead:
        if( FAILED(hr) ){}

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT CRWFile::Write
(
OUT LPCVOID         lpBuffer,
IN  DWORD           nNumberOfBytesToWrite,
OUT LPDWORD         lpNumberOfBytesWritten,
OUT LPOVERLAPPED    lpOverLapped
)
{
    _ASSERTE( lpBuffer != NULL );

    HRESULT hr      =   E_FAIL;
    BOOL    bRet    =   false;

    __try
    {
        if( !lpBuffer ) { hr = E_INVALIDARG; goto qWrite; }

        bRet = WriteFile(
                    m_hFile,
                    lpBuffer,
                    nNumberOfBytesToWrite,
                    lpNumberOfBytesWritten,
                    lpOverLapped
                    );

        if( !bRet ) {

            hr = HRESULT_FROM_WIN32(GetLastError()); goto qWrite;
        }

        hr = S_OK;

qWrite:
        if( FAILED(hr) ){}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\processes.h ===
#ifndef _EMEXTN_H
#define _EMEXTN_H

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef BOOL (CALLBACK* ENUMPROCSANDSERVICES)(long, LPCTSTR, LPCTSTR, LPCTSTR, LPARAM, LONG);

#define E_TOOMANY_PROCESSES		-1

DWORD
GetNumberOfRunningApps
(
/* [out] */ DWORD   *pdwNumbApps
);

DWORD
GetAllPids
(
/* [out] */	DWORD	adwProcIDs[],
/* [in] */	DWORD	dwBuffSize,
/* [out] */	DWORD	*pdwNumbProcs
);

DWORD
GetNumberOfServices
(
/* [out */  DWORD   *pdwNumbSrvcs,
/* [in] */  DWORD   dwServiceType = SERVICE_WIN32,
/* [in] */  DWORD   dwServiceState = SERVICE_ACTIVE
);

DWORD
GetNumberOfActiveServices
(
/* [out */  DWORD   *pdwNumbRunningSrvcs
);

DWORD
GetNumberOfInactiveServices
(
/* [out */  DWORD   *pdwNumbStoppedSrvcs
);

DWORD
IsService
(
/* [in] */  UINT    nPid,
/* [out] */ bool    *pbIsService,
/* [out] */ LPTSTR  lpszImagePath           =   NULL,
/* [out] */ ULONG   cchImagePath            =   0L,
/* [out] */ LPTSTR  lpszServiceShortName    =   NULL,
/* [in] */  ULONG   cchServiceShortName     =   0L,
/* [out] */ LPTSTR  lpszServiceDescription  =   NULL,
/* [in] */  ULONG   cchServiceDescription   =   0L
);

DWORD
IsService_NT5
(
/* [in] */  UINT    nPid,
/* [out] */ bool    *pbIsService,
/* [out] */ LPTSTR  lpszImagePath           =   NULL,
/* [out] */ ULONG   cchImagePath            =   0L,
/* [out] */ LPTSTR  lpszServiceShortName    =   NULL,
/* [in] */  ULONG   cchServiceShortName     =   0L,
/* [out] */ LPTSTR  lpszServiceDescription  =   NULL,
/* [in] */  ULONG   cchServiceDescription   =   0L
);

HRESULT
IsService_NT4
(
IN  UINT nPid,
OUT bool *pbIsService
);

DWORD
GetServiceInfo
(
/* [in] */  UINT    nPid,
/* [out] */ LPTSTR  lpszImagePath,
/* [out] */ ULONG   cchImagePath,
/* [out] */ LPTSTR  lpszServiceShortName,
/* [in] */  ULONG   cchServiceShortName,
/* [out] */ LPTSTR  lpszServiceDescription,
/* [in] */  ULONG   cchServiceDescription
);

DWORD
EnumRunningProcesses
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumRunProc,
/* [in] */ LPARAM				lParam,
/* [in] */ UINT                 nStartIndex = 0L
);

DWORD
EnumRunningServices
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumSrvcsProc,
/* [in] */ LPARAM				lParam,
/* [in] */ UINT                 nStartIndex = 0L
);

DWORD
EnumStoppedServices
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumSrvcsProc,
/* [in] */ LPARAM				lParam,
/* [in] */ UINT                 nStartIndex = 0L
);

DWORD
EnumServices
(
/* [in] */ ENUMPROCSANDSERVICES lpEnumSrvcsProc,
/* [in] */ LPARAM				lParam,
/* [in] */ DWORD                dwSrvcState,
/* [in] */ UINT                 nStartIndex = 0L
);

/***************************************************/

BOOL
IsImageRunning
(
/* [in] */ ULONG lPID
);

DWORD
GetImageNameFromPID
(
/* [in] */	ULONG	lPID,
/* [out] */	LPTSTR	lpszImagePath,
/* [in] */	DWORD	dwBuffSize
);

DWORD
StartServiceAndGetPid
(
/* [in] */	LPCTSTR	lpszServiceShortName,
/* [out] */ UINT	*pnPid
);

DWORD
IsValidImage
(
/* [in] */  ULONG   lPID,
/* [in] */  LPCTSTR lpszImageName,
/* [out] */ bool    *pbValidImage
);

DWORD
IsValidProcess
(
/* [in] */  ULONG   lPID,
/* [in] */  LPCTSTR lpszImageName,
/* [out] */ bool    *pbValidImage
);

DWORD
IsValidService
(
/* [in] */  ULONG   lPID,
/* [in] */  LPCTSTR lpszImageName,
/* [out] */ bool    *pbValidImage
);

DWORD
GetProcessHandle
(
IN  ULONG   lPid,
OUT HANDLE  *phProcess
);

HRESULT
GetPackageDescription
(
/* [in] */  const long  nPid,
/* [out] */ BSTR        &bstrDescription
);

BOOL
IsPackage
(
/* [in[ */ LPTSTR  lpszImageName
);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _EMEXTN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\rwfile.h ===
#pragma once

class IRWFile
{
protected:
    HANDLE  m_hFile;

public:

    virtual HRESULT InitFile(
                          LPCTSTR lpFileName,
                          DWORD dwDesiredAccess,
                          DWORD dwShareMode,
                          LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                          DWORD dwCreationDisposition,
                          DWORD dwFlagsAndAttributes,
                          HANDLE hTemplateFile
                          ) = 0;

    virtual HRESULT Read(
                        LPVOID lpBuffer,
                        DWORD nNumberOfBytesToRead,
                        LPDWORD lpNumberOfBytesRead,
                        LPOVERLAPPED lpOverlapped
                        ) = 0;

    virtual HRESULT Write(
                        LPCVOID lpBuffer,
                        DWORD nNumberOfBytesToWrite,
                        LPDWORD lpNumberOfBytesWritten,
                        LPOVERLAPPED lpOverlapped
                        ) = 0;
};

class CRWFile : public IRWFile
{
public:
    CRWFile();
    ~CRWFile();

    virtual HRESULT InitFile(
                          LPCTSTR lpFileName,
                          DWORD dwDesiredAccess,
                          DWORD dwShareMode,
                          LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                          DWORD dwCreationDisposition,
                          DWORD dwFlagsAndAttributes,
                          HANDLE hTemplateFile
                          );

    virtual HRESULT Read(
                        LPVOID lpBuffer,
                        DWORD nNumberOfBytesToRead,
                        LPDWORD lpNumberOfBytesRead,
                        LPOVERLAPPED lpOverlapped
                        );

    virtual HRESULT Write(
                        LPCVOID lpBuffer,
                        DWORD nNumberOfBytesToWrite,
                        LPDWORD lpNumberOfBytesWritten,
                        LPOVERLAPPED lpOverlapped
                        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\sessmgr.cpp ===
#include "stdafx.h"
#include "emsvc.h"
#include "rwfile.h"

HRESULT
CopyGuid
(
IN  unsigned char *pGuidStreamIn,
OUT unsigned char *pGuidStreamOut
)
{
    ATLTRACE(_T("CopyGuid\n"));

    _ASSERTE(pGuidStreamIn != NULL && pGuidStreamOut != NULL);

    if(pGuidStreamIn == NULL || pGuidStreamOut == NULL){

        return E_INVALIDARG;
    }

    memcpy((void *)pGuidStreamOut, (void *)pGuidStreamIn, sizeof GUID);

    return S_OK;
}

HRESULT
CreateAndAssignGuid
(
OUT unsigned char *pGuidStream
)
{
    ATLTRACE(_T("CreateAndAssignGuid\n"));

    _ASSERTE(pGuidStream != NULL);

    HRESULT hr  =   E_FAIL;

    if( pGuidStream == NULL ){
        hr = E_INVALIDARG;
        return hr;
    }

    hr = CoCreateGuid((GUID*)pGuidStream);

    return hr;
}

inline PEMSession	AllocSession ( PEmObject pEmObj, PGENTHREAD pEmThrd )
{
    ATLTRACE(_T("AllocSession\n"));

	PEMSession	pSess = new EMSession;

	do { 
		if ( pSess == NULL )
			break;

		ZeroMemory( (void *) pSess, sizeof EMSession );

        pSess->pEmObj = pEmObj;
        pSess->pThread = pEmThrd;
		pSess->hrDebug = S_OK;
	}
    while (false);

	return pSess;
}

inline void DeallocSession ( PEMSession &pSess ) 
{
    ATLTRACE(_T("DeallocSession\n"));

    _ASSERTE(pSess);

	if ( pSess ) {

		delete pSess;
        pSess = NULL;
	}
}

inline PEmObject AllocEmObject ( PEmObject pEmObj )
{
    ATLTRACE(_T("AllocEmObject\n"));

    PEmObject pEmNewObj = new EmObject;

	do { 
		if ( pEmNewObj == NULL )
			break;

		ZeroMemory( (void *) pEmNewObj, sizeof EmObject );

        if( pEmObj ){

            memcpy((void *) pEmNewObj, (void *) pEmObj, sizeof EmObject);
        }
	}
    while (false);

	return pEmNewObj;
}

inline void DeallocEmObject( PEmObject &pEmObj ) 
{
    ATLTRACE(_T("DeallocEmObject\n"));

    _ASSERTE(pEmObj);

	if ( pEmObj ) {

		delete pEmObj;
        pEmObj = NULL;
	}
}

PGENTHREAD EmAllocThread
(
IN  PEmObject   pEmObj
)
{
    ATLTRACE(_T("EmAllocThread\n"));

    return new CEMSessionThread(pEmObj);
}

void EmDeallocThread ( PGENTHREAD pThread ) 
{
    ATLTRACE(_T("EmDeallocThread\n"));

    if ( pThread ) {

        delete pThread;
        pThread = NULL;
    }
}

CExcepMonSessionManager::CExcepMonSessionManager ()
{
    ATLTRACE(_T("CExcepMonSessionManager::CExcepMonSessionManager ()\n"));

	m_pcs = new CGenCriticalSection;
}


CExcepMonSessionManager::~CExcepMonSessionManager()
{
    ATLTRACE(_T("CExcepMonSessionManager::~CExcepMonSessionManager ()\n"));

    CleanUp();
    delete m_pcs;
}

void
CExcepMonSessionManager::CleanUp()
{
    ATLTRACE(_T("CExcepMonSessionManager::CleanUp()\n"));

    POSITION pos = NULL;
    unsigned char *pGuid = NULL;
    PEMSession  pEmSess =   NULL;

    __try {

        pos = m_SessTable.GetStartPosition();

        while( pos )
        {
            m_SessTable.GetNextAssoc(pos, pGuid, pEmSess);
            RemoveSession(pGuid);
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		_ASSERTE( false );
	}
}

HRESULT 
CExcepMonSessionManager::AddSession 
(
IN  PEmObject   pEmObj,
OUT PEMSession  *ppNewEmSess
)
{
    ATLTRACE(_T("CExcepMonSessionManager::AddSession\n"));

    _ASSERTE(pEmObj != NULL);

	HRESULT		hr			= E_FAIL;
	PEMSession	pEMSession	= NULL;
    PEmObject   pNewEmObj   = NULL;
    PGENTHREAD  pEmThrd     = NULL;

    __try {

	    do {

            if(pEmObj == NULL){

                hr = E_INVALIDARG;
                break;
            }

            pNewEmObj = AllocEmObject(pEmObj);
            _ASSERTE(pNewEmObj != NULL);

            if(pNewEmObj == NULL){

                hr = E_OUTOFMEMORY;
                break;
            }

            hr = CreateAndAssignGuid(pNewEmObj->guidstream);
            FAILEDHR_BREAK(hr);

            hr = CopyGuid(pNewEmObj->guidstream, pEmObj->guidstream);
            FAILEDHR_BREAK(hr);

            pEmThrd = EmAllocThread(pNewEmObj);
            _ASSERTE(pEmThrd != NULL);

            if(pEmThrd == NULL){

                hr = E_OUTOFMEMORY;
                break;
            }

            pEMSession = AllocSession(pNewEmObj, pEmThrd);
            _ASSERTE(pEMSession != NULL);

            if(pEMSession == NULL){

                hr = E_OUTOFMEMORY;
                break;
            }
	    }
        while ( false );

        if( FAILED(hr) ){

            if(pNewEmObj) DeallocEmObject( pNewEmObj );
            if(pEmThrd) EmDeallocThread(pEmThrd);
            if(pEMSession) DeallocSession(pEMSession);
        }
        else{

    	    m_pcs->WriteLock();

            pNewEmObj->nStatus &= STAT_SESS_NOT_STARTED;

            //
            // Using pNewEmObj->guidstream itself as the key will
            // save some memory.
            //
            m_SessTable.SetAt(pNewEmObj->guidstream, pEMSession);

            *ppNewEmSess = pEMSession;

            m_pcs->WriteUnlock();
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        if(pNewEmObj) DeallocEmObject( pNewEmObj );
        if(pEmThrd) EmDeallocThread(pEmThrd);
        if(pEMSession) DeallocSession(pEMSession);

		hr = E_UNEXPECTED;
        _ASSERTE( false );
	}


	return hr;
}

HRESULT 
CExcepMonSessionManager::RemoveSession
(
IN unsigned char *pGuidStream
)
{
    ATLTRACE(_T("CExcepMonSessionManager::RemoveSession\n"));

    HRESULT         hr          =   E_FAIL;

    POSITION        pos         =   NULL;

    unsigned char   *pGuid      =   NULL;
    PEMSession      pRecEmSess  =   NULL;

	m_pcs->WriteLock();

    __try {

        do {

            pos = m_SessTable.GetStartPosition();

            while( pos ){

                m_SessTable.GetNextAssoc( pos, pGuid, pRecEmSess );

                _ASSERTE(pGuid != NULL && pRecEmSess != NULL);

                if(memcmp(pGuidStream, pGuid, sizeof GUID) == 0){

        		    m_SessTable.RemoveKey ( pGuid );
                    hr = S_OK;
                    break;
                }
            }

        } while ( false );

	    m_pcs->WriteUnlock();

        if (SUCCEEDED (hr) ) {
            hr = InternalRemoveSession ( pRecEmSess );
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	return ( hr );
}

HRESULT
CExcepMonSessionManager::GetSession
(
IN  unsigned char   *pGuid,
OUT PPEMSession     ppEmSess
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetSession\n"));

	_ASSERTE(pGuid != NULL);
	_ASSERTE(ppEmSess != NULL);

	HRESULT			hr			=	E_FAIL;
    POSITION        pos         =   NULL;
    unsigned char   *pRecGuid   =   NULL;
    PEMSession      pRecEmSess  =   NULL;

    __try {

        do
        {
            if( pGuid == NULL ||
			    ppEmSess == NULL){

			    hr = E_INVALIDARG;
                break;
            }

            m_pcs->ReadLock();

            pos = m_SessTable.GetStartPosition();

		    hr = S_FALSE;

            while(pos){

                m_SessTable.GetNextAssoc( pos, pRecGuid, pRecEmSess);

                if(memcmp((void *)pGuid, (void *)pRecGuid, sizeof pGuid) == 0){

                    if(ppEmSess) *ppEmSess = pRecEmSess;
				    hr = S_OK;
                    break;
                }
            }

            m_pcs->ReadUnlock();
        }
        while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::GetSession
(
IN	UINT nPid,
IN	BSTR bstrImageName,
OUT	PEMSession *ppEmSess
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetSession\n"));

	HRESULT		hr		=	E_FAIL;
	POSITION	pos		=	NULL;

	unsigned char	*pRecGuid	=	NULL;
	PEMSession		pRecEmSess	=	NULL;

    __try {

        do
	    {
		    m_pcs->ReadLock();

		    pos = m_SessTable.GetStartPosition();

		    *ppEmSess = NULL;
		    hr = S_FALSE;

		    while( pos )
		    {
			    m_SessTable.GetNextAssoc(pos, pRecGuid, pRecEmSess);

			    if( ((UINT)pRecEmSess->pEmObj->nId == nPid) &&
				    (_tcsicmp(pRecEmSess->pEmObj->szName, bstrImageName) == 0) ) {

				    *ppEmSess = pRecEmSess;
				    hr = S_OK;

				    //
				    // Here is an open issue.. 1
				    //
				    if(pRecEmSess->pEmObj->nStatus & STAT_SESS_DEBUG_IN_PROGRESS) {
					    break;
				    }
				    else {
					    continue;
				    }

			    }
		    }

		    m_pcs->ReadUnlock();
	    }
	    while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	return hr;
}

HRESULT
CExcepMonSessionManager::GetSessionStatus
(
IN  unsigned char   *pGuid,
OUT LONG            *plSessStaus /* = NULL */,
OUT	HRESULT			*plHr /* = NULL */
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetSessionStatus\n"));

    _ASSERTE( pGuid != NULL );

	HRESULT		    hr			= E_FAIL;
    unsigned char   *pRecGuid   = NULL;
	PEMSession	    pEmSess 	= NULL;

    __try {

	    do
	    {
            if( pGuid == NULL ) { hr = E_INVALIDARG; break; }

		    hr = EMERROR_INVALIDPROCESS;

            if(GetSession( pGuid, &pEmSess ) == S_OK){

                if( plSessStaus ) *plSessStaus = pEmSess->pEmObj->nStatus;
			    if( plHr ) *plHr = pEmSess->pEmObj->hr;
                hr = S_OK;
            }

	    }
	    while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	return hr;
}

HRESULT
CExcepMonSessionManager::SetSessionStatus
(
IN unsigned char    *pGuid,
IN LONG             lSessStaus,
IN HRESULT			lHr,
IN LPCTSTR          lpszErrText,
IN bool             bRetainOrphanState /* = true */,
IN bool             bSetEndTime /* = false */
)
{
    ATLTRACE(_T("CExcepMonSessionManager::SetSessionStatus\n"));

	HRESULT		hr			= E_FAIL;

    PEMSession	pEMSession	= NULL;

    __try {

	    do
	    {
		    if( pGuid == NULL ){

                hr = E_INVALIDARG;
			    break;
		    }

		    hr = EMERROR_INVALIDPROCESS;

		    m_pcs->WriteLock();

            if(GetSession(pGuid, &pEMSession) == S_OK){

                bool bOrphan = ((pEMSession->pEmObj->nStatus & STAT_ORPHAN) == STAT_ORPHAN);

                pEMSession->pEmObj->nStatus = lSessStaus;

                // should be calling OrphanThisSession(..) instead.
                if( bRetainOrphanState && bOrphan ) {

                    pEMSession->pEmObj->nStatus |= STAT_ORPHAN;
                }

                pEMSession->pEmObj->hr = lHr;

                if ( lpszErrText ) {

                    _tcsncpy ( 
                        pEMSession->pEmObj->szBucket1, 
                        lpszErrText, 
                        ( sizeof (pEMSession->pEmObj->szBucket1)/sizeof (TCHAR) ) - 1 );
                }

                if( bSetEndTime ) {

                    pEMSession->pEmObj->dateEnd = _Module.GetCurrentTime();
                }

                hr = S_OK;
            }

		    m_pcs->WriteUnlock();

	    }
	    while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

	return hr;
}

HRESULT
CExcepMonSessionManager::UpdateSessObject
(
IN unsigned char	*pGuid,
IN PEmObject		pEmObj
)
{
    ATLTRACE(_T("CExcepMonSessionManager::UpdateSessObject\n"));

	_ASSERTE( pGuid != NULL );
    _ASSERTE( pEmObj != NULL );

    HRESULT         hr          =   E_FAIL;
	unsigned char	*pRecGuid	=	NULL;
	PEMSession		pRecEmSess	=	NULL;

    __try {

        do
        {
            if( pGuid == NULL ||
			    pEmObj == NULL ){

                hr = E_INVALIDARG;
                break;
            }

		    hr = EMERROR_INVALIDPROCESS;

		    m_pcs->WriteLock();

            if(GetSession(pGuid, &pRecEmSess) == S_OK){

                memcpy((void *) pRecEmSess->pEmObj, (void *) pEmObj, sizeof EmObject);
                hr = S_OK;
            }

            m_pcs->WriteUnlock();
        }
        while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT 
CExcepMonSessionManager::InternalRemoveSession 
( 
    PEMSession  pEMSession
)
{
    ATLTRACE(_T("CExcepMonSessionManager::InternalRemoveSession\n"));

    _ASSERTE( pEMSession != NULL );

    __try {

        if( pEMSession == NULL ){ return E_INVALIDARG; }

        if ( pEMSession->pThread ) {

//            pEMSession->pThread->Stop ();
            EmDeallocThread ( pEMSession->pThread );
        }

        if( pEMSession->pEmObj ) {

            DeallocEmObject( pEMSession->pEmObj );
        }

        DeallocSession ( pEMSession );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		_ASSERTE( false );
	}

    return S_OK;
}


HRESULT
CExcepMonSessionManager::StopAllThreads()
{
    ATLTRACE(_T("CExcepMonSessionManager::StopAllThreads\n"));

    HRESULT     hr = E_FAIL;

    m_pcs->ReadLock ();

    __try {

        hr = InternalStopAllThreads ();

    }

    __except (EXCEPTION_EXECUTE_HANDLER, 1) {
        
        _ASSERTE (false);
    }

    m_pcs->ReadUnlock ();

    return (hr);

};


HRESULT
CExcepMonSessionManager::InternalStopAllThreads()
{
    ATLTRACE(_T("CExcepMonSessionManager::InternalStopAllThreads\n"));

    unsigned char   *pGuid      = NULL;
    PEMSession      pEMSession  = NULL;
    POSITION        pos         = NULL;

    m_pcs->ReadLock();

    __try {

        for (   pos = m_SessTable.GetStartPosition ( ) ; 
                pos  != NULL ; ) {

            m_SessTable.GetNextAssoc ( pos, pGuid, pEMSession );
            if(pEMSession->pThread) {

                pEMSession->pThread->Stop();
            }
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();

    return S_OK;
}

/**********************/

HRESULT
CExcepMonSessionManager::IsAlreadyBeingDebugged
(
IN PEmObject    pEmObj
)
{
    ATLTRACE(_T("CExcepMonSessionManager::IsAlreadyBeingDebugged\n"));

    _ASSERTE(pEmObj != NULL);

    HRESULT         hr          =   E_FAIL;
	POSITION	    pos			=	NULL;
    unsigned char   *pGuid      =   NULL;
	PEMSession      pRecEmSess	=	NULL;

    __try {

	    do
	    {
		    if( pEmObj == NULL ) {
			    
			    hr = E_INVALIDARG;
			    break;
		    }

            m_pcs->ReadLock();

            pos = m_SessTable.GetStartPosition();

		    hr = EMERROR_INVALIDPROCESS;

            while(pos){

                m_SessTable.GetNextAssoc( pos, pGuid, pRecEmSess );

                // This should never happen.
                _ASSERTE(pRecEmSess != NULL && pGuid != NULL);

			    //
			    // This is not a fool proof test. But this is the best
			    // that can be done to test if it is being debugged..
			    //
			    if( (pRecEmSess->pEmObj->nId == pEmObj->nId) &&
                    (_tcscmp(pRecEmSess->pEmObj->szName, pEmObj->szName) == 0) ) {

                    hr = S_FALSE;
                    if( HIWORD(pRecEmSess->pEmObj->nStatus) > HIWORD(STAT_SESS_NOT_STARTED) ) {

                        hr = S_OK;
    			    }

                    break;
                }
            }

            m_pcs->ReadUnlock();
	    }
	    while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::GetNumberOfStoppedSessions
(
OUT DWORD *pdwNumOfStoppedSessions
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetNumberOfStoppedSessions\n"));

    _ASSERTE( pdwNumOfStoppedSessions != NULL);

    HRESULT         hr      =   E_INVALIDARG;
    POSITION        pos     =   NULL;
    unsigned char   *pGuid  =   NULL;
    PEMSession      pEmSess =   NULL;

    __try {

        if( pdwNumOfStoppedSessions == NULL ){ return hr; }

        *pdwNumOfStoppedSessions = 0L;

        m_pcs->ReadLock();

        pos = m_SessTable.GetStartPosition();
        hr = S_FALSE;

        while( pos ){

            m_SessTable.GetNextAssoc( pos, pGuid, pEmSess );

            _ASSERTE(pGuid != NULL && pEmSess != NULL);

            if(pEmSess->pEmObj->nStatus & STAT_SESS_STOPPED){

                *pdwNumOfStoppedSessions += 1;
                hr = S_OK;
            }
        }

        m_pcs->ReadUnlock();
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::GetFirstStoppedSession
(
OUT     POSITION        *ppos,
OUT     unsigned char   **ppGuid,
OUT     PEMSession      *ppEmSess
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetFirstStoppedSession\n"));

    _ASSERTE( ppos != NULL);

    HRESULT         hr      =   E_INVALIDARG;
    POSITION        pos     =   NULL;
    unsigned char   *pGuid  =   NULL;
    PEMSession      pEmSess =   NULL;

    __try {

        if( ppos == NULL ){ return hr; }

        m_pcs->ReadLock();

        pos = m_SessTable.GetStartPosition();
        hr = S_FALSE;

        while( pos ){

            m_SessTable.GetNextAssoc( pos, pGuid, pEmSess );

            _ASSERTE(pGuid != NULL && pEmSess != NULL);

            if(pEmSess->pEmObj->nStatus & STAT_SESS_STOPPED){

                if(ppGuid) *ppGuid = pGuid;
                if(ppEmSess) *ppEmSess = pEmSess;
                *ppos = pos;
                hr = S_OK;
                break;
            }
        }

        m_pcs->ReadUnlock();
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::GetNextStoppedSession
(
IN OUT  POSITION        *ppos,
OUT     unsigned char   **ppGuid,
OUT     PEMSession      *ppEmSess
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetNextStoppedSession\n"));

    _ASSERTE( ppos != NULL);

    HRESULT         hr      =   E_INVALIDARG;
    POSITION        pos     =   NULL;
    unsigned char   *pGuid  =   NULL;
    PEMSession      pEmSess =   NULL;

    __try {

        if( ppos == NULL ){ return hr; }

        m_pcs->ReadLock();

        pos = *ppos;
        hr = S_FALSE;

        while( pos ){

            m_SessTable.GetNextAssoc( pos, pGuid, pEmSess );

            _ASSERTE(pGuid != NULL && pEmSess != NULL);

            if(pEmSess->pEmObj->nStatus & STAT_SESS_STOPPED){

                if(ppGuid) *ppGuid = pGuid;
                if(ppEmSess) *ppEmSess = pEmSess;
                *ppos = pos;
                hr = S_OK;
                break;
            }
        }

        m_pcs->ReadUnlock();
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

BOOL
CExcepMonSessionManager::IsPortInUse
(
IN  UINT    nPort
)
{
    BOOL            bRet    =   FALSE;
    POSITION        pos     =   NULL;
    unsigned char   *pGuid  =   NULL;
    PEMSession      pEmSess =   NULL;

    __try {

        m_pcs->ReadLock();

        pos = m_SessTable.GetStartPosition();

        while( pos ){

            m_SessTable.GetNextAssoc( pos, pGuid, pEmSess );

            _ASSERTE(pGuid != NULL && pEmSess != NULL);

            if( ((CEMSessionThread *)pEmSess->pThread)->m_nPort == nPort ){

                bRet = TRUE;
                break;
            }
        }

        m_pcs->ReadUnlock();
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		_ASSERTE( false );
	}

    return bRet;
}

HRESULT
CExcepMonSessionManager::GetFirstSession
(
OUT		POSITION		*ppos,
OUT		PEMSession		*ppEmSess
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetFirstStoppedSession\n"));

    _ASSERTE( ppos != NULL);

    HRESULT         hr      =   E_INVALIDARG;
    POSITION        pos     =   NULL;
    unsigned char   *pGuid  =   NULL;
    PEMSession      pEmSess =   NULL;

    __try {

        if( ppos == NULL ){ return hr; }

        m_pcs->ReadLock();

        pos = m_SessTable.GetStartPosition();
        hr = S_FALSE;

        if( pos != NULL ) {

            m_SessTable.GetNextAssoc( pos, pGuid, pEmSess );

            _ASSERTE(pGuid != NULL && pEmSess != NULL);

            if(ppEmSess) *ppEmSess = pEmSess;
            *ppos = pos;
            hr = S_OK;
        }

        m_pcs->ReadUnlock();
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::GetNextSession
(
IN OUT	POSITION		*ppos,
OUT		PEMSession		*ppEmSess
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetNextSession\n"));

    _ASSERTE( ppos != NULL );

    HRESULT         hr      =   E_INVALIDARG;
    POSITION        pos     =   NULL;
    unsigned char   *pGuid  =   NULL;
    PEMSession      pEmSess =   NULL;

    __try {

        if( ppos == NULL ){ return hr; }

        m_pcs->ReadLock();

        pos = *ppos;
        hr = S_FALSE;

        while( pos ){

            m_SessTable.GetNextAssoc( pos, pGuid, pEmSess );

            _ASSERTE(pGuid != NULL && pEmSess != NULL);

            if(ppEmSess) *ppEmSess = pEmSess;
            *ppos = pos;
            hr = S_OK;
        }

        m_pcs->ReadUnlock();
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::GetNumberOfSessions
(
OUT DWORD *pdwNumOfSessions
)
{
    ATLTRACE(_T("CExcepMonSessionManager::GetNumberOfSessions\n"));

    _ASSERTE( pdwNumOfSessions != NULL );

    HRESULT         hr      =   E_INVALIDARG;
    POSITION        pos     =   NULL;
    unsigned char   *pGuid  =   NULL;
    PEMSession      pEmSess =   NULL;

    __try {

        if( pdwNumOfSessions == NULL ){ return hr; }

        *pdwNumOfSessions = 0L;

        m_pcs->ReadLock();

        pos = m_SessTable.GetStartPosition();
        hr = S_FALSE;

        while( pos ){

            m_SessTable.GetNextAssoc( pos, pGuid, pEmSess );

            _ASSERTE(pGuid != NULL && pEmSess != NULL);

            *pdwNumOfSessions += 1;
            hr = S_OK;
        }

        m_pcs->ReadUnlock();
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::UpdateSessObject
(
IN unsigned char	*pGuid,
IN DWORD            dwEmObjFlds,
IN PEmObject        pEmObj
)
{
    return CExcepMonSessionManager::UpdateSessObject (
                    pGuid, dwEmObjFlds, pEmObj->type, pEmObj->type2,
                    pEmObj->guidstream, pEmObj->nId, pEmObj->szName,
                    pEmObj->szSecName, pEmObj->nStatus, pEmObj->dateStart,
                    pEmObj->dateEnd, pEmObj->szBucket1, pEmObj->dwBucket1,
                    pEmObj->hr
                    );
}

HRESULT
CExcepMonSessionManager::UpdateSessObject
(
IN unsigned char    *pGuid,
IN DWORD            dwEmObjFlds,
IN short            type,
IN short            type2,
IN unsigned char    *pguidstream,
IN LONG             nId,
IN TCHAR            *pszName,
IN TCHAR            *pszSecName,
IN LONG             nStatus,
IN DATE             dateStart,
IN DATE             dateEnd,
IN TCHAR            *pszBucket1,
IN DWORD            dwBucket1,
IN HRESULT          hrr
)
{
    ATLTRACE(_T("CExcepMonSessionManager::UpdateSessObject\n"));

	_ASSERTE( pGuid != NULL );

    HRESULT         hr          =   E_FAIL;
	unsigned char	*pRecGuid	=	NULL;
	PEMSession		pRecEmSess	=	NULL;

    __try {

        do
        {
            if( pGuid == NULL ){

                hr = E_INVALIDARG;
                break;
            }

		    hr = EMERROR_INVALIDPROCESS;

		    m_pcs->WriteLock();

            if(GetSession(pGuid, &pRecEmSess) == S_OK){

                if( dwEmObjFlds & EMOBJ_FLD_TYPE ) {

                    pRecEmSess->pEmObj->type = type;
                }

                if( dwEmObjFlds & EMOBJ_FLD_TYPE2 ) {

                    pRecEmSess->pEmObj->type2 = type2;
                }

                if( dwEmObjFlds & EMOBJ_FLD_GUIDSTREAM ) {

                    memcpy((void*)pRecEmSess->pEmObj->guidstream, pguidstream, sizeof pRecEmSess->pEmObj->guidstream );
                }

                if( dwEmObjFlds & EMOBJ_FLD_SZNAME ) {

                    _tcsncpy(pRecEmSess->pEmObj->szName, pszName, sizeof pRecEmSess->pEmObj->szName / sizeof TCHAR );
                }

                if( dwEmObjFlds & EMOBJ_FLD_SZSECNAME ) {

                    _tcsncpy(pRecEmSess->pEmObj->szSecName, pszSecName, sizeof pRecEmSess->pEmObj->szSecName / sizeof TCHAR );
                }

                if( dwEmObjFlds & EMOBJ_FLD_NSTATUS ) {

                    pRecEmSess->pEmObj->nStatus = nStatus;
                }

                if( dwEmObjFlds & EMOBJ_FLD_DATESTART ) {

                    pRecEmSess->pEmObj->dateStart = dateStart;
                }

                if( dwEmObjFlds & EMOBJ_FLD_DATEEND ) {

                    pRecEmSess->pEmObj->dateEnd = dateEnd;
                }

                if( dwEmObjFlds & EMOBJ_FLD_SZBUCKET1 ) {

                    _tcsncpy(pRecEmSess->pEmObj->szBucket1, pszBucket1, sizeof pRecEmSess->pEmObj->szBucket1 / sizeof TCHAR );
                }

                if( dwEmObjFlds & EMOBJ_FLD_DWBUCKET1 ) {

                    pRecEmSess->pEmObj->dwBucket1 = dwBucket1;
                }

                if( dwEmObjFlds & EMOBJ_FLD_HR ) {

                    pRecEmSess->pEmObj->hr = hrr;
                }

                hr = S_OK;
            }

            m_pcs->WriteUnlock();
        }
        while( false );
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::IsSessionOrphaned
(
IN unsigned char    *pGuid
)
{
    _ASSERTE( pGuid != NULL );

    PEMSession  pEmSess =   NULL;
    HRESULT     hr      =   E_FAIL;

    __try
    {
        if( pGuid == NULL ) { hr = E_INVALIDARG; goto qIsSessionOrphaned; }

        hr = GetSession(pGuid, &pEmSess);
        if( FAILED(hr) ) { goto qIsSessionOrphaned; }

        hr = S_FALSE;
        if( pEmSess->pEmObj->nStatus & STAT_ORPHAN ) { hr = S_OK; }

qIsSessionOrphaned:
        if(FAILED(hr)){}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::OrphanThisSession
(
IN  unsigned char *pGuid
)
{
    _ASSERTE(pGuid != NULL);

    HRESULT hr          =   E_FAIL,
            hrSess      =   E_FAIL;
    LONG    lSessStatus =   0L;

    __try
    {
        if( !pGuid ) { hr = E_INVALIDARG; goto qOrphanThisSession; }

        hr = GetSessionStatus(pGuid, &lSessStatus, &hrSess);
        if( FAILED(hr) ) goto qOrphanThisSession;

        lSessStatus += STAT_ORPHAN;
        hr = SetSessionStatus( pGuid, lSessStatus, hrSess );

qOrphanThisSession:
        if( FAILED(hr) ) {}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::AdoptThisSession
(
IN  unsigned char *pGuid
)
{
    _ASSERTE(pGuid != NULL);

    HRESULT hr          =   E_FAIL,
            hrSess      =   E_FAIL;
    LONG    lSessStatus =   0L;

    __try
    {
        if( !pGuid ) { hr = E_INVALIDARG; goto qOrphanThisSession; }

        hr = GetSessionStatus(pGuid, &lSessStatus, &hrSess);
        if( FAILED(hr) ) goto qOrphanThisSession;

        if( lSessStatus & STAT_ORPHAN ) { lSessStatus -= STAT_ORPHAN; }
        hr = SetSessionStatus( pGuid, lSessStatus, hrSess, NULL, false );

qOrphanThisSession:
        if( FAILED(hr) ) {}
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}

HRESULT
CExcepMonSessionManager::PersistSessions
(
IN  LPCTSTR lpFilePath
)
{

    HRESULT         hr          =   E_FAIL;
    DWORD           dwWritten   =   0L;
    POSITION        pos         =   NULL;
    unsigned char   *pGuid      =   NULL;
    PEMSession      pEmSess     =   NULL;
    LPVOID          lpvSess     =   NULL;
    DWORD           dwBytes     =   0L;

/*
	HRESULT				hrDebug;

    PGENTHREAD			pThread;
    PEmObject           pEmObj;
*/

    CRWFile fileSessLog;

    m_pcs->WriteLock();

    if( !lpFilePath ) { hr = E_INVALIDARG; goto qPersistSessions; }

    hr = fileSessLog.InitFile(
                        lpFilePath,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if( FAILED(hr) ) { goto qPersistSessions; }

    for ( pos = m_SessTable.GetStartPosition(); pos != NULL; ) {

        m_SessTable.GetNextAssoc ( pos, pGuid, pEmSess );

        if(pEmSess) {

/*            dwBytes = sizeof HRESULT + sizeof PGENTHREAD + sizeof EmObject + 1;
            lpvSess = malloc( dwBytes );
            if( !lpvSess ) { hr = E_OUTOFMEMORY; goto qPersistSessions; }

            memcpy( lpvSess, &(pEmSess->hrDebug), sizeof HRESULT );
            memcpy( (void*)((long)lpvSess + sizeof HRESULT ),
                    (void*)&(pEmSess->pThread),
                    sizeof PGENTHREAD
                    );
            memcpy( (void*)((long)lpvSess + sizeof HRESULT + sizeof PGENTHREAD),
                    (void*)(pEmSess->pEmObj),
                    sizeof EmObject
                    );
*/

            hr = fileSessLog.Write(
                                (LPVOID)pEmSess->pEmObj,
                                sizeof EmObject,
                                &dwWritten,
                                NULL
                                );

//            if( !lpvSess ) { free( lpvSess ); lpvSess = NULL; }
        }
    }

    hr = S_OK;

qPersistSessions:
//    if( !lpvSess ) { free( lpvSess ); lpvSess = NULL; }
    if( FAILED(hr) ){}

    m_pcs->WriteUnlock();

    return hr;
}

HRESULT
CExcepMonSessionManager::InitSessionsFromLog
(
IN  LPCTSTR         lpFilePath,
IN  EmStatusHiWord  lStatusHi,
IN  EmStatusLoWord  lStatusLo
)
{

    HRESULT         hr      =   E_FAIL;
    DWORD           dwRead  =   0L;
    EmObject        EmObj;

    CRWFile fileSessLog;

    m_pcs->WriteLock();

    if( !lpFilePath ) { hr = E_INVALIDARG; goto qInitSessionsFromLog; }

    hr = fileSessLog.InitFile(
                        lpFilePath,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if( FAILED(hr) ) { goto qInitSessionsFromLog; }

    do
    {

        hr = fileSessLog.Read(
                            (LPVOID)&EmObj,
                            sizeof EmObj,
                            &dwRead,
                            NULL
                            );

        if( hr != S_OK ) break;

        if( lStatusHi && (EmObj.nStatus & lStatusHi) ) {

            hr = AddLoggedSession( &EmObj );
        }

    } while ( hr == S_OK );

    hr = S_OK;

qInitSessionsFromLog:
    if( FAILED(hr) ){}

    m_pcs->WriteUnlock();

    return hr;
}

HRESULT
CExcepMonSessionManager::AddLoggedSession
(
IN  PEmObject   pEmObj
)
{
    ATLTRACE(_T("CExcepMonSessionManager::AddLoggedSession\n"));

    _ASSERTE(pEmObj != NULL);

	HRESULT		hr			= E_FAIL;
	PEMSession	pEMSession	= NULL;
    PEmObject   pNewEmObj   = NULL;
    PGENTHREAD  pEmThrd     = NULL;

    __try {

	    do {

            if(pEmObj == NULL){

                hr = E_INVALIDARG;
                break;
            }

            pNewEmObj = AllocEmObject(pEmObj);
            _ASSERTE(pNewEmObj != NULL);

            if(pNewEmObj == NULL){

                hr = E_OUTOFMEMORY;
                break;
            }

            pEmThrd = NULL;
            pEMSession = AllocSession(pNewEmObj, pEmThrd);
            _ASSERTE(pEMSession != NULL);

            if(pEMSession == NULL){

                hr = E_OUTOFMEMORY;
                break;
            }
        
            hr = S_OK;

        }
        while ( false );

        if( FAILED(hr) ){

            if(pNewEmObj) DeallocEmObject( pNewEmObj );
            if(pEmThrd) EmDeallocThread(pEmThrd);
            if(pEMSession) DeallocSession(pEMSession);
        }
        else{

    	    m_pcs->WriteLock();

            //
            // Using pNewEmObj->guidstream itself as the key will
            // save some memory.
            //
            m_SessTable.SetAt(pNewEmObj->guidstream, pEMSession);

            m_pcs->WriteUnlock();
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

        if(pNewEmObj) DeallocEmObject( pNewEmObj );
        if(pEmThrd) EmDeallocThread(pEmThrd);
        if(pEMSession) DeallocSession(pEMSession);

		hr = E_UNEXPECTED;
        _ASSERTE( false );
	}


	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\sessthrd.cpp ===
#include "stdafx.h"
#include "svcobjdef.h"
#include "dbghelp.h"
#include "Processes.h"
#include "Notify.h"
#include "resource.h"

CEMSessionThread::CEMSessionThread
(
IN  PEmObject pEmObj
)
{

    ATLTRACE(_T("CEMSessionThread::CEMSessionThread\n"));

    m_pEmSessObj = pEmObj;
	eDBGSessType = SessType_Automatic;

    m_pDBGClient	= NULL;
	m_pDBGControl	= NULL;
    m_pDBGSymbols   = NULL;

    m_pASTManager = &(_Module.m_SessionManager);

	m_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    m_hCDBStarted = CreateEvent ( NULL, FALSE, FALSE, NULL );


//// - InitAutomaticSession..

    m_bRecursive = FALSE;
    m_bstrEcxFilePath = NULL;
    m_bstrNotificationString = NULL;
    m_bstrAltSymPath = NULL;
    m_bGenerateMiniDump = FALSE;
    m_bGenerateUserDump = FALSE;

//// - InitManualSession..

    m_bstrUserName = NULL;
    m_bstrPassword = NULL;
    m_nPort = 0;
	m_bBlockIncomingIPConnections = FALSE;

    m_bContinueSession = TRUE;
    m_pEcxFile = NULL;

	ZeroMemory(&m_sp, sizeof(m_sp));
	ZeroMemory(&m_pi, sizeof(m_pi));
};

CEMSessionThread::~CEMSessionThread(){

    ATLTRACE(_T("CEMSessionThread::~CEMSessionThread\n"));

    if(m_bstrUserName) SysFreeString(m_bstrUserName);
    if(m_bstrPassword) SysFreeString(m_bstrPassword);

    if(m_pDBGClient) m_pDBGClient->Release();
	if(m_pDBGControl) m_pDBGControl->Release();
    if(m_pDBGSymbols) m_pDBGSymbols->Release();

    if(m_bstrEcxFilePath) ::SysFreeString(m_bstrEcxFilePath);
    if(m_bstrNotificationString) ::SysFreeString(m_bstrNotificationString );
    if(m_bstrAltSymPath) ::SysFreeString(m_bstrAltSymPath);

	CloseHandle( m_hEvent );
	CloseHandle( m_hCDBStarted );
};

DWORD
CEMSessionThread::Run ( void )
{
    ATLTRACE(_T("CEMSessionThread::Run\n"));

	TCHAR	        szConnectString[_MAX_PATH]	=   _T("");
	char	        *szClientConnectString		=   NULL;
	DWORD	        dwLastRet					=   -1L;
	HRESULT	        hr							=   E_FAIL,
                    hrActual                    =   E_FAIL;
    EmSessionStatus nStatus                     =   STAT_SESS_NONE_STAT_NONE;
	UINT			nPid						=	0;
	EmObject		EmObj;
	PEMSession		pEmSess						=	NULL;

	do
	{
		do
		{

			if( m_pEmSessObj->type == EMOBJ_SERVICE ) {

				if( (m_pEmSessObj->nStatus == STAT_SESS_NOT_STARTED_NOTRUNNING) ||
					(m_pEmSessObj->nStatus & STAT_SESS_STOPPED) ) {

                    hr = S_OK;

                    do {

                        dwLastRet = StartServiceAndGetPid( m_pEmSessObj->szSecName, &nPid );

                        if( dwLastRet != ERROR_SERVICE_ALREADY_RUNNING ) {

                            hr = HRESULT_FROM_WIN32(dwLastRet);
                            break;
                        }

                    }
                    while ( false );

					FAILEDHR_BREAK(hr);

					hr = m_pASTManager->GetSession( m_pEmSessObj->guidstream, &pEmSess );
					FAILEDHR_BREAK(hr);

					memcpy((void *)&EmObj, (void *) pEmSess->pEmObj, sizeof EmObject);
					EmObj.nStatus = STAT_SESS_NOT_STARTED_RUNNING;
					EmObj.nId = nPid;
					EmObj.hr = S_OK;

					hr = m_pASTManager->UpdateSessObject( EmObj.guidstream, &EmObj );
					FAILEDHR_BREAK(hr);
				}
			}

			//
			// Get server connection string and start CDB server
			// Ex:	-server tcp:port=XXX -p YYY
			//		-server npipe:pipe=EM_YYY -p YYY
			//
			hr = GetServerConnectString( szConnectString, _MAX_PATH );
			if( FAILED(hr) ) {

				hrActual = hr;
				nStatus = STAT_SESS_STOPPED_FAILED;
				break;
			}

			hr = StartCDBServer( szConnectString );

			// Indicates that the CDB server got started or failed..
			SetEvent(m_hCDBStarted);

			if( FAILED(hr) ) {

				hrActual = hr;
				hr = EMERROR_CDBSERVERSTARTFAILED;
				nStatus = STAT_SESS_STOPPED_FAILED;
				break;
			}

#ifdef _DEBUG
			m_pASTManager->SetSessionStatus(
									m_pEmSessObj->guidstream,
									STAT_SESS_DEBUG_IN_PROGRESS_NONE,
									S_OK,
									L"StartCDBServer Successful"
									);
#else
			m_pASTManager->SetSessionStatus(
									m_pEmSessObj->guidstream,
									STAT_SESS_DEBUG_IN_PROGRESS_NONE,
									S_OK,
									NULL
									);
#endif

			//
			// Get client connection string and start monitoring
			// Ex:	-remote tcp:server=ABCD,port=XXX
			//		-remote npipe:server=ABCD,pipe=EM_YYY
			//
			hr = GetClientConnectString( szConnectString, _MAX_PATH );
			if( FAILED(hr) ) {

				hrActual = hr;
				hr = EMERROR_CDBSERVERSTARTFAILED;
				nStatus = STAT_SESS_STOPPED_FAILED;
				break;
			}

			size_t Len = wcstombs( NULL, szConnectString, 0 );
			szClientConnectString = (char *)calloc(Len+1, sizeof(char));
			_ASSERTE( szClientConnectString != NULL );

			if( szClientConnectString == NULL ) {
				hr = HRESULT_FROM_WIN32( GetLastError() );

				hrActual = hr;
				hr = EMERROR_CDBSERVERSTARTFAILED;
				nStatus = STAT_SESS_STOPPED_FAILED;
				break;
			}

			wcstombs( szClientConnectString, szConnectString, Len );

			if( eDBGSessType == SessType_Automatic ){

				StartAutomaticExcepMonitoring( szClientConnectString );
			}
			else{

//
// Need info..
//
				StartAutomaticExcepMonitoring( szClientConnectString );
//				StartManualExcepMonitoring( szClientConnectString );
			}

            hr = S_OK;
		}
		while ( m_bRecursive && m_bContinueSession ); // Need to put in a way of stopping the session.
	}
	while( false );

    if(FAILED(hr)) {

#ifdef _DEBUG

        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_FAILED,
                                hrActual,
                                L"CEMSessionThread::Run - Failed",
                                true,
                                true
                                );
#else
        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_FAILED,
                                hrActual,
                                NULL,
                                true,
                                true
                                );
#endif

		StopServer();
    }

	if( szClientConnectString != NULL ){
		free(szClientConnectString);
	}

	return hr;
}

HRESULT
CEMSessionThread::StartAutomaticExcepMonitoring( char *pszConnectString )
{
    ATLTRACE(_T("CEMSessionThread::StartAutomaticExcepMonitoring\n"));

	HRESULT	        hr						        =	E_FAIL,
                    hrActual                        =   E_FAIL;

    TCHAR           szUniqueFileName[_MAX_PATH+1]   =   _T("");
	char	        szLogFile[_MAX_PATH+1]	        =	"";
    TCHAR           szLogDir[_MAX_PATH+1]           =   _T("");

    char            szEcxFile[_MAX_PATH+1]          =   "";
    TCHAR           szEcxDir[_MAX_PATH+1]           =   _T("");

	bool	        bStop					        =	FALSE;
	char	        szCmd[_MAX_PATH+1]		        =	"";
    TCHAR           szFileExt[_MAX_EXT+1]           =   _T("");
	DWORD	        dwBufSize				        =	_MAX_PATH;
    char            szAltSymPath[_MAX_PATH+1]       =   "";
    EmSessionStatus nStatus                         =   STAT_SESS_NONE_STAT_NONE;
    bstr_t          bstrStatus;

	do
	{
        _ASSERTE(m_bstrEcxFilePath != NULL);
        _Module.GetEmDirectory( EMOBJ_CMDSET, szEcxDir, dwBufSize, NULL, NULL );
        _stprintf(szEcxDir, _T("%s\\%s"), szEcxDir, m_bstrEcxFilePath);
		wcstombs( szEcxFile, szEcxDir, dwBufSize );

        dwBufSize = _MAX_PATH;
        _Module.GetEmDirectory( EMOBJ_LOGFILE, szLogDir, dwBufSize, szFileExt, _MAX_EXT );
        CreateDirectory( szLogDir, NULL );

        GetUniqueFileName(  m_pEmSessObj,
                            szUniqueFileName,
                            _T(""),
                            szFileExt,
                            false
                            );

        _stprintf(szLogDir, _T("%s\\%s"), szLogDir, szUniqueFileName);
		wcstombs( szLogFile, szLogDir, dwBufSize );

		hr = DebugConnect(
						pszConnectString,
						IID_IDebugClient,
						(void **)&m_pDBGClient
						);
        if( FAILED(hr) ) {

            hrActual = hr;
            hr = EMERROR_CONNECTIONTOSERVERFAILED;
            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus  = L"DebugConnect failed";
            break;
        }

#ifdef _DEBUG
        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_DEBUG_IN_PROGRESS_NONE,
                                hr,
                                L"DebugConnect Succeeded.."
                                );
#else
        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_DEBUG_IN_PROGRESS_NONE,
                                hr,
                                NULL
                                );
#endif


        hr = m_pDBGClient->QueryInterface(
						IID_IDebugControl,
						(void **)&m_pDBGControl
						);
        if( FAILED(hr) ) {

            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"IDbgClient::QIFace ( IDbgControl ) failed";
            break;
        }

        hr = m_pDBGClient->QueryInterface(
						IID_IDebugSymbols,
						(void **)&m_pDBGSymbols
						);
        if( FAILED(hr) ) {

            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"IDbgClient::QIFace ( IDebugSymbols ) failed";
            break;
        }

		wcstombs( szAltSymPath, m_bstrAltSymPath, dwBufSize );
        if( strcmp( szAltSymPath, "" ) != 0 ) {

            hr = m_pDBGSymbols->SetSymbolPath(szAltSymPath);
            if( FAILED(hr) ) {

                hrActual = hr;
                hr = EMERROR_ALTSYMPATHFAILED;
                nStatus = STAT_SESS_STOPPED_FAILED;
                bstrStatus = L"Alternate symbol path could not be set";
                break;
            }
        }

		if( eDBGSessType == SessType_Automatic ) {

		    hr = m_pDBGControl->OpenLogFile(szLogFile, FALSE);
            if( FAILED(hr) ) {

                hrActual = hr;
                hr = EMERROR_UNABLETOCREATELOGFILE;
                nStatus = STAT_SESS_STOPPED_FAILED;
                bstrStatus = L"Open log file failed";
                break;
            }
        }

/*
		hr = m_pDBGControl->ExecuteCommandFile(
									DEBUG_OUTCTL_LOG_ONLY,
									szEcxFile,
									DEBUG_EXECUTE_DEFAULT
									);
        if( FAILED(hr) ) {

            hrActual = hr;
            hr = EMERROR_ECXFILEEXECUTIONFAILED;
            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"ExecCommandFile failed";
            break;
        }
*/
		m_EventCallbacks.m_pEMThread = this;
		hr = m_pDBGClient->SetEventCallbacks(&m_EventCallbacks);
        if( FAILED(hr) ) {

            hrActual = hr;
            hr = EMERROR_CALLBACKSCANNOTBEREGISTERED;
            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"SetEventCallback failed";
            break;
        }

		ULONG ExecStatus = DEBUG_STATUS_BREAK;

        if( _tcscmp( m_bstrEcxFilePath, _T("") ) != 0 ) {

            m_pEcxFile = fopen(szEcxFile, "r");
            if( m_pEcxFile == NULL ) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                hrActual = hr;
                hr = EMERROR_ECXFILEOPENFAILED;
                nStatus = STAT_SESS_STOPPED_FAILED;
                bstrStatus = L"fopen failed";
                break;
            }

            hr = ExecuteCommandsTillGo(NULL);
        }

		do
		{

			hr = KeepDebuggeeRunning();
            if( FAILED(hr) ) {

                nStatus = STAT_SESS_STOPPED_FAILED;
                bstrStatus = L"KeepDebugeeRunning failed";
                break;
            }

			hr = CanContinue();
            if( FAILED(hr) ) {

                nStatus = STAT_SESS_STOPPED_FAILED;
                bstrStatus = L"Can Continue() failed";
                break;
            }

			hr = m_pDBGClient->DispatchCallbacks(INFINITE); // Milli Secs..
            if( FAILED(hr) ) {

                hrActual = hr;
                hr = EMERROR_DISPATCHCALLBACKFAILED;
                nStatus = STAT_SESS_STOPPED_FAILED;
                bstrStatus = L"DispatchCallbacks failed";
                break;
            }

			//
			// Is this call required???
			//
			hr = CanContinue();
			if( hr != S_OK )
            { 
                bstrStatus = L"CanContinue hr != S_OK";
                break; 
            }

			hr = BreakIn();
            if( FAILED(hr) ) {
                bstrStatus = L"BreakIn";

                nStatus = STAT_SESS_STOPPED_FAILED;
                break;
            }

            if( strcmp( szEcxFile, "" ) != 0 ) {
            
                ExecuteCommandsTillGo(NULL);
            }

			if( eDBGServie == DBGService_HandleException ) {
				break;
			}

			dwBufSize = _MAX_PATH;
			hr = GetCmd( eDBGServie, szCmd, dwBufSize );
            if( FAILED(hr) ) {

                nStatus = STAT_SESS_STOPPED_FAILED;
                bstrStatus = L"GetCmd failed";
                break;
            }
/*
			hr = BreakIn();
            if( FAILED(hr) ) {
                bstrStatus = L"BreakIn";

                nStatus = STAT_SESS_STOPPED_FAILED;
                break;
            }

*/			if( strcmp( szCmd, "q" ) == 0 ){

        		if( eDBGSessType == SessType_Automatic ) {

                    hr = m_pDBGControl->CloseLogFile();

                    if( FAILED(hr) ) {
                        bstrStatus = L"CloseLogFile";
                        nStatus = STAT_SESS_STOPPED_FAILED;
                        break;
                    }
                }

			    hr = m_pDBGControl->Execute( DEBUG_OUTCTL_ALL_CLIENTS,
										    szCmd,
										    DEBUG_EXECUTE_DEFAULT
										    );

//              hr = m_pDBGControl->WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE);
//				hr = m_pDBGClient->EndSession(DEBUG_END_ACTIVE_TERMINATE);

				SetEvent( m_hEvent );

				break;
			}

            if( strcmp( szCmd, "qd" ) == 0 ) {

        		if( eDBGSessType == SessType_Automatic ) {

                    hr = m_pDBGControl->CloseLogFile();

                    if( FAILED(hr) ) {

                        bstrStatus = L"CloseLogFile";
                        nStatus = STAT_SESS_STOPPED_FAILED;
                        break;
                    }
                }

			    hr = m_pDBGControl->Execute( DEBUG_OUTCTL_ALL_CLIENTS,
										    szCmd,
										    DEBUG_EXECUTE_DEFAULT
										    );
/*
                hr = m_pDBGClient->DetachProcesses();
*/

				SetEvent( m_hEvent );

				break;
            }

			hr = m_pDBGControl->Execute( DEBUG_OUTCTL_ALL_CLIENTS,
										szCmd,
										DEBUG_EXECUTE_DEFAULT
										);
            if( FAILED(hr) ) {

                bstrStatus = L"DbgControl::Execute failed";
                nStatus = STAT_SESS_STOPPED_FAILED;
                break;
            }

			Sleep(2000);

			hr = m_pDBGControl->GetExecutionStatus(&ExecStatus);
            if( FAILED(hr) ) {

                bstrStatus = L"GetExecutionStatus";
                nStatus = STAT_SESS_STOPPED_FAILED;
                break;
            }
		}
		// Will have to terminate if either no deubuggee or 
		// stop is requested..
		while( CanContinue() == S_OK );

        hr = m_pDBGControl->GetExecutionStatus(&ExecStatus);
        if( FAILED(hr) ) {
            bstrStatus = L"DbgControl::GetExecutionStatus failed";
            nStatus = STAT_SESS_STOPPED_FAILED;
            break;
        }

		if(ExecStatus != DEBUG_STATUS_NO_DEBUGGEE)
        {
    		if( eDBGSessType == SessType_Automatic ) {

                m_pDBGControl->CloseLogFile();
            }

			m_pDBGClient->EndSession(DEBUG_END_PASSIVE);
		}
	}
	while(FALSE);

    if(FAILED(hr)) {

#ifdef _DEBUG
        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_FAILED,
                                hr,
                                bstrStatus,
                                true,
                                true
                                );
#else
        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_FAILED,
                                hr,
                                NULL,
                                true,
                                true
                                );
#endif
    }

    //
    // When we are here, the debug session is guarenteed to be stopped.
    //
    {
        EmObject    EmObj;
        EmObj.dateEnd = CServiceModule::GetCurrentTime();
        m_pASTManager->UpdateSessObject( m_pEmSessObj->guidstream,
                                         EMOBJ_FLD_DATEEND,
                                         &EmObj
                                         );
    }

    if( m_pEcxFile ) { fclose( m_pEcxFile ); m_pEcxFile = NULL; }

    StopServer();

    return hr;
}

HRESULT
CEMSessionThread::StartManualExcepMonitoring( char *pszConnectString )
{
    ATLTRACE(_T("CEMSessionThread::StartManualExcepMonitoring\n"));

	HRESULT	        hr						=	E_FAIL,
                    hrActual                =   E_FAIL;
	char	        szLogFile[_MAX_PATH+1]	=	"";
    TCHAR           szLogDir[_MAX_PATH+1]   =   _T("");

    char            szEcxFile[_MAX_PATH+1]  =   "";
    TCHAR           szEcxDir[_MAX_PATH+1]   =   _T("");

	bool	        bStop					=	FALSE;
	char	        szCmd[_MAX_PATH+1]		=	"";
	DWORD	        dwBufSize				=	_MAX_PATH;
    EmSessionStatus nStatus                 =   STAT_SESS_NONE_STAT_NONE;
    bstr_t          bstrStatus;

	do
	{
        _ASSERTE(m_bstrEcxFilePath != NULL);
        _Module.GetEmDirectory( EMOBJ_CMDSET, szEcxDir, dwBufSize, NULL, NULL );
        _stprintf(szEcxDir, _T("%s\\%s"), szEcxDir, m_bstrEcxFilePath);
		wcstombs( szEcxFile, szEcxDir, dwBufSize );

        dwBufSize = _MAX_PATH;
        _Module.GetEmDirectory( EMOBJ_LOGFILE, szLogDir, dwBufSize, NULL, NULL );
        _stprintf(szLogDir, _T("%s\\%s"), szLogDir, _T("EmLog.Dbl"));
		wcstombs( szLogFile, szLogDir, dwBufSize );

		hr = DebugConnect(
						pszConnectString,
						IID_IDebugClient,
						(void **)&m_pDBGClient
						);
        if( FAILED(hr) ) {

            hrActual = hr;
            hr = EMERROR_CONNECTIONTOSERVERFAILED;
            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus  = L"DebugConnect failed";
            break;
        }

#ifdef _DEBUG
        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_DEBUG_IN_PROGRESS_NONE,
                                hr,
                                L"DebugConnect Succeeded.."
                                );
#else
        m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_DEBUG_IN_PROGRESS_NONE,
                                hr,
                                NULL
                                );
#endif

        hr = m_pDBGClient->QueryInterface(
						IID_IDebugControl,
						(void **)&m_pDBGControl
						);
        if( FAILED(hr) ) {

            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"IDbgClient::QIFace ( IDbgControl ) failed";
            break;
        }

		hr = m_pDBGControl->OpenLogFile(szLogFile, FALSE);
        if( FAILED(hr) ) {

            hrActual = hr;
            hr = EMERROR_UNABLETOCREATELOGFILE;
            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"Open log file failed";
            break;
        }

		hr = m_pDBGControl->ExecuteCommandFile(
									DEBUG_OUTCTL_LOG_ONLY,
									szEcxFile,
									DEBUG_EXECUTE_DEFAULT
									);
        if( FAILED(hr) ) {

            hrActual = hr;
            hr = EMERROR_ECXFILEEXECUTIONFAILED;
            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"ExecCommandFile failed";
            break;
        }

		m_EventCallbacks.m_pEMThread = this;
		hr = m_pDBGClient->SetEventCallbacks(&m_EventCallbacks);
        if( FAILED(hr) ) {

            hrActual = hr;
            hr = EMERROR_CALLBACKSCANNOTBEREGISTERED;
            nStatus = STAT_SESS_STOPPED_FAILED;
            bstrStatus = L"SetEventCallback failed";
            break;
        }

		ULONG ExecStatus = DEBUG_STATUS_BREAK;

//        m_pDBGClient->ConnectSession(DEBUG_CONNECT_SESSION_DEFAULT);

        while( true ) {

    		hr = m_pDBGClient->DispatchCallbacks(INFINITE); // Milli Secs..
            FAILEDHR_BREAK(hr); //DispatchCallbacks return S_FALSE if timeout expires
        }

        hr = S_OK;

    }
	while(FALSE);

#ifdef _DEBUG
    m_pASTManager->SetSessionStatus(
                            m_pEmSessObj->guidstream,
                            STAT_SESS_STOPPED_SUCCESS,
                            hr,
                            bstrStatus
                            );
#else
    m_pASTManager->SetSessionStatus(
                            m_pEmSessObj->guidstream,
                            STAT_SESS_STOPPED_SUCCESS,
                            hr,
                            NULL
                            );
#endif

    return hr;
}

HRESULT
CEMSessionThread::StartCDBServer
(
IN LPTSTR lpszConnectString
)
{

    ATLTRACE(_T("CEMSessionThread::StartCDBServer\n"));

    TCHAR   szCdbDir[_MAX_PATH+1]    =   _T("");
    ULONG   ccCdbDir                =   _MAX_PATH;
    HRESULT hr                      =   E_FAIL;

    ccCdbDir = _MAX_DIR;
    hr = _Module.GetCDBInstallDir( szCdbDir, &ccCdbDir );
    if( FAILED(hr) ) return hr;

    _tcsncat( szCdbDir, _T("\\cdb.exe"), _MAX_DIR );

	BOOL bCdbCreated = CreateProcess(// This has to be obtained from the registry...
			                            szCdbDir,
			                            lpszConnectString,
			                            NULL,
			                            NULL,
			                            FALSE,
			                            CREATE_NEW_PROCESS_GROUP | CREATE_NEW_CONSOLE,
			                            NULL,
			                            NULL,
			                            &m_sp,
			                            &m_pi
			                            );

    if(bCdbCreated == FALSE){
    	return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Wait till CDB does some initializations..
    // Don't know how long to wait.. have to figure out a way..
    //
    Sleep(2000);

    return S_OK;
}

HRESULT
CEMSessionThread::GetClientConnectString
(
IN OUT	LPTSTR	pszConnectString,
IN		DWORD	dwBuffSize
)
{
    ATLTRACE(_T("CEMSessionThread::GetClientConnectString\n"));

	_ASSERTE(pszConnectString != NULL);
	_ASSERTE(dwBuffSize > 0L);

	HRESULT	hr			= E_FAIL;
	DWORD	dwBuff		= MAX_COMPUTERNAME_LENGTH;

	TCHAR	szCompName[MAX_COMPUTERNAME_LENGTH + 1];

	do
	{
		if( pszConnectString == NULL	||
			dwBuffSize <= 0L ) break;

		if(GetComputerName(szCompName, &dwBuff) == FALSE){
			HRESULT_FROM_WIN32(GetLastError());
			break;
		}

		if( m_nPort != 0 ){
			_stprintf(pszConnectString, _T("tcp:server=%s,port=%d"), szCompName, m_nPort);
		}
		else {
			_stprintf(pszConnectString, _T("npipe:server=%s,pipe=EM_%d"), szCompName, m_pEmSessObj->nId);
		}

		hr = S_OK;
	}
	while( false );

	return hr;
}

HRESULT
CEMSessionThread::GetServerConnectString
(
IN OUT	LPTSTR	lpszConnectString,
IN		DWORD	dwBuffSize
)
{
    ATLTRACE(_T("CEMSessionThread::GetServerConnectString\n"));

	_ASSERTE(lpszConnectString != NULL);
	_ASSERTE(dwBuffSize > 0L);

	HRESULT		hr = E_FAIL;

	do
	{
		if( lpszConnectString == NULL	||
			dwBuffSize <= 0L ) break;

		if( m_nPort != 0 ){
			_stprintf(lpszConnectString, _T(" -server tcp:port=%d -p %d"), m_nPort, m_pEmSessObj->nId);
		}
		else {
			_stprintf(lpszConnectString, _T(" -server npipe:pipe=EM_%d -p %d"), m_pEmSessObj->nId, m_pEmSessObj->nId);
		}

		hr = S_OK;
	}
	while( false );

	return hr;
}

typedef BOOL (WINAPI*PFNWR)(
    IN HANDLE hProcess,
    IN DWORD ProcessId,
    IN HANDLE hFile,
    IN MINIDUMP_TYPE DumpType,
    IN CONST PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam, OPTIONAL
    IN CONST PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam, OPTIONAL
    IN CONST PMINIDUMP_CALLBACK_INFORMATION CallbackParam OPTIONAL
    );


HRESULT
CEMSessionThread::CreateDumpFile( BOOL bMiniDump )
{
    ATLTRACE(_T("CEMSessionThread::CreateDumpFile\n"));

	HRESULT			hr				= E_FAIL;
	HANDLE		    hDumpFile       = INVALID_HANDLE_VALUE,
                    hProcess        = NULL;
    HMODULE         hDbgHelp        = NULL;
    LONG            lStatus         = 0L;

    TCHAR           szDumpFile[_MAX_PATH + 1]   =   _T(""); // a-kjaw, bug ID: 296024/25
    DWORD           dwBufSize               =   _MAX_PATH;
    TCHAR           szCmd[_MAX_PATH + 1]    =   _T(""); // a-kjaw, bug ID: 296026
    DWORD           dwLastErr               =   0L;
    TCHAR           szFileExt[_MAX_EXT + 1] =   _T("");
    LPCTSTR         lpszDbgHelpDll          =   _T("\\dbghelp.dll"),
                    lpszUserDumpExe         =   _T("\\userdump.exe");

	do
	{

        hr = m_pASTManager->GetSessionStatus( m_pEmSessObj->guidstream, &lStatus );
        FAILEDHR_BREAK(hr);

        //
        // We cannot generate dump files if the debuggee has stopped..
        //
        if( lStatus & STAT_SESS_STOPPED ) {

            hr = EMERROR_INVALIDPROCESS;
            break;
        }

        if( bMiniDump ){

            _Module.GetEmDirectory( EMOBJ_MINIDUMP, szCmd, dwBufSize, szFileExt, _MAX_EXT );
            CreateDirectory( szCmd, NULL );

            GetUniqueFileName (
                                m_pEmSessObj,
                                szDumpFile,
                                _T("mini"),
                                szFileExt,
                                false
                                );

			_tcscat( szCmd, _T("\\"));
			_tcscat( szCmd, szDumpFile);

            hDumpFile = CreateFile( szCmd,
                                    GENERIC_ALL,
                                    0,
                                    NULL, // sa
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL
                                    );

            if( hDumpFile == INVALID_HANDLE_VALUE ) {

                dwLastErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastErr);
                break;
            }

            dwBufSize = _MAX_DIR;
            hr = _Module.GetEmInstallDir( szCmd, &dwBufSize );
            if( FAILED(hr) ) break;

            _tcsncat( szCmd, lpszDbgHelpDll, _MAX_PATH );
			hDbgHelp = LoadLibrary(szCmd);
            if( hDbgHelp == NULL ) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }

			PFNWR pFunc = (PFNWR) GetProcAddress(hDbgHelp, "MiniDumpWriteDump");

            if(!pFunc) {

                hr = E_FAIL;
                break;
            }

            hr = HRESULT_FROM_WIN32(GetProcessHandle(m_pEmSessObj->nId, &hProcess));
            FAILEDHR_BREAK(hr);

            hr = S_FALSE;

            if( pFunc(hProcess, m_pEmSessObj->nId, (HANDLE)hDumpFile,
    				MiniDumpNormal, NULL, NULL, NULL) ) {

                hr = S_OK;
            }

        }
		else{

            dwBufSize = _MAX_PATH;
            _Module.GetEmDirectory( EMOBJ_USERDUMP, szDumpFile, dwBufSize, szFileExt, _MAX_EXT );
            CreateDirectory( szDumpFile, NULL );

            _stprintf( szCmd, _T(" %d \"%s\""), m_pEmSessObj->nId, szDumpFile );

            GetUniqueFileName (
                                m_pEmSessObj,
                                szDumpFile,
                                _T("user"),
                                szFileExt,
                                false
                                );
            _tcscat(szCmd, _T("\\"));
            _tcscat(szCmd, szDumpFile);

			STARTUPINFO			sp;
			PROCESS_INFORMATION pi;

			ZeroMemory(&sp, sizeof(sp));
			ZeroMemory(&pi, sizeof(pi));

            dwBufSize = _MAX_DIR;
            hr = _Module.GetEmInstallDir( szDumpFile, &dwBufSize );
            if( FAILED(hr) ) break;

            _tcsncat( szDumpFile, lpszUserDumpExe, _MAX_PATH );

			BOOL bRet = CreateProcess(// This has to be obtained from the registry...
									szDumpFile,
									szCmd,
									NULL,
									NULL,
									FALSE,
									CREATE_NO_WINDOW,
									NULL,
									NULL,
									&sp,
									&pi
									);

			WaitForSingleObject( pi.hProcess, INFINITE );
			CloseHandle(pi.hProcess);

            hr = S_OK;
		}
	}
	while(FALSE);

    if(hDumpFile != INVALID_HANDLE_VALUE) {
        
        CloseHandle(hDumpFile);
    }

    if(hDbgHelp) { FreeLibrary( hDbgHelp ); }
    if(hProcess) { CloseHandle( hProcess ); }

    if(hr == S_OK){

        lStatus |= STAT_FILECREATED_SUCCESSFULLY;
    }
    else {

        lStatus |= STAT_FILECREATION_FAILED;
    }

    hr = m_pASTManager->SetSessionStatus(
                        m_pEmSessObj->guidstream,
                        lStatus,
                        hr,
                        NULL
                        );

	return hr;
}

HRESULT
CEMSessionThread::StopDebugging( )
{
    ATLTRACE(_T("CEMSessionThread::StopDebugging\n"));

	HRESULT			hr				= S_OK;
	IDebugClient	*pDBGClntLocal	= NULL;
	IDebugControl	*pDBGCtrlLocal	= NULL;

	do
	{
/*
// We seem to allow manual sessions to be stopped too..

        if( eDBGSessType == SessType_Manual ) {

            hr = S_OK;
            break;
        }
*/
        m_bContinueSession = FALSE;

		eDBGServie = DBGService_Stop;

		hr = m_pDBGClient->CreateClient(&pDBGClntLocal);
		FAILEDHR_BREAK(hr);

		hr = pDBGClntLocal->ExitDispatch(m_pDBGClient);
		FAILEDHR_BREAK(hr);

		WaitForSingleObject( m_hEvent, INFINITE );

#ifdef _DEBUG
        hr = m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_SUCCESS,
                                S_OK,
                                L"CEMSessionThread::StopDebugging - called"
                                );
#else
        hr = m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_SUCCESS,
                                S_OK,
                                NULL
                                );
#endif
		FAILEDHR_BREAK(hr);

	}
	while(FALSE);

	return hr;
}

HRESULT
CEMSessionThread::GetCmd
(
IN		eDBGServiceRequested eDBGSvc,
IN OUT	char * pszCmdBuff,
IN OUT	DWORD &dwBufLen
)
{
    ATLTRACE(_T("CEMSessionThread::GetCmd\n"));

	HRESULT hr = S_OK;
	char	szPostDebug[_MAX_PATH]	=	"C:\\Program Files\\Debuggers\\bin\\em\\config\\PostDebug.ecx";

	_ASSERTE( pszCmdBuff != NULL );
	_ASSERTE( dwBufLen > 0 );

	do
	{
		if( pszCmdBuff == NULL ||
			dwBufLen < 1L ){
			hr = E_INVALIDARG;
			break;
		}

		strcpy( pszCmdBuff, "" );

		switch( eDBGSvc )
		{
		case DBGService_Stop:
		case DBGService_HandleException:
			strncpy( pszCmdBuff, "q", dwBufLen );
			break;
        case DBGService_Cancel:
			strncpy( pszCmdBuff, "qd", dwBufLen ); // QD (Quit and Detach);
			break;
		case DBGService_CreateMiniDump:
			sprintf( pszCmdBuff, ".dump /m d:\\EMMiniDump%d.dmp", m_pEmSessObj->nId );
			break;
		case DBGService_CreateUserDump:
			sprintf( pszCmdBuff, ".dump d:\\EMUserDump%d.dmp", m_pEmSessObj->nId );
			break;
		case DBGService_Go:
			strncpy( pszCmdBuff, "g", dwBufLen );
			break;
		default:
			hr = E_INVALIDARG;
		}
	}
	while( false );

	dwBufLen = strlen( pszCmdBuff );

	return hr;
}

HRESULT
CEMSessionThread::OnException
(
	IN PEXCEPTION_RECORD64 pException
)
{

    ATLTRACE(_T("CEMSessionThread::OnException\n"));

	HRESULT			hr				            =   S_OK;
	IDebugClient	*pDBGClntLocal	            =   NULL;

	DWORD           excpcd                      =   pException->ExceptionCode;
    TCHAR           szTemp[_MAX_PATH+1]         =   _T("");
    TCHAR           szDesc[sizeof EmObject+1]   =   _T("");

	do
	{
		if(excpcd == EXCEPTION_BREAKPOINT){

			break;
		}

        if(m_bGenerateMiniDump) {

			hr = CreateDumpFile( TRUE );
			FAILEDHR_BREAK(hr);
		}

		if(m_bGenerateUserDump) {

			hr = CreateDumpFile( FALSE );
			FAILEDHR_BREAK(hr);
		}

		if(excpcd == EXCEPTION_ACCESS_VIOLATION){

#ifdef _DEBUG
			m_pASTManager->SetSessionStatus(m_pEmSessObj->guidstream, STAT_SESS_STOPPED_ACCESSVIOLATION_OCCURED, S_OK, L"OnException - AV");
#else
            m_pASTManager->SetSessionStatus(m_pEmSessObj->guidstream, STAT_SESS_STOPPED_ACCESSVIOLATION_OCCURED, S_OK, NULL);
#endif
        	::LoadString(_Module.GetResourceInstance(), IDS_DEBUGGEE_ACCESSVIOLATION, szTemp, _MAX_PATH);
            GetDescriptionFromEmObj(m_pEmSessObj, szDesc, sizeof EmObject, szTemp);
            NotifyAdmin(szDesc);
		}
		else{ // Exception..

#ifdef _DEBUG
            m_pASTManager->SetSessionStatus(m_pEmSessObj->guidstream, STAT_SESS_STOPPED_EXCEPTION_OCCURED, S_OK, L"OnException - Exception");
#else
            m_pASTManager->SetSessionStatus(m_pEmSessObj->guidstream, STAT_SESS_STOPPED_EXCEPTION_OCCURED, S_OK, NULL);
#endif
        	::LoadString(_Module.GetResourceInstance(), IDS_DEBUGGEE_EXCEPTION, szTemp, _MAX_PATH);
            GetDescriptionFromEmObj(m_pEmSessObj, szDesc, sizeof EmObject, szTemp);
            NotifyAdmin(szDesc);
		}

		hr = m_pDBGClient->CreateClient(&pDBGClntLocal);
		FAILEDHR_BREAK(hr);

		hr = pDBGClntLocal->ExitDispatch(m_pDBGClient);
		FAILEDHR_BREAK(hr);
	}
	while(FALSE);

	return hr;
}

HRESULT
CEMSessionThread::CanContinue()
{
    ATLTRACE(_T("CEMSessionThread::CanContinue\n"));

	ULONG	ExecStatus	= DEBUG_STATUS_BREAK;
	HRESULT	hr			= S_OK;

	do
	{
		hr = m_pDBGControl->GetExecutionStatus(&ExecStatus);
		FAILEDHR_BREAK(hr);

		//
		// We don't have anything to do if the debuggee
		// has exited.
		//
		if( ExecStatus == DEBUG_STATUS_NO_DEBUGGEE ){
			hr = S_FALSE;
			break;
		}

		if( IsStopRequested() == TRUE ){
			hr = S_FALSE;
			break;
		}
	}
	while( false );

	return hr;
}

HRESULT
CEMSessionThread::KeepDebuggeeRunning()
{
    ATLTRACE(_T("CEMSessionThread::KeepDebuggeeRunning\n"));

	HRESULT	hr			= E_FAIL;
	ULONG	ExecStatus	= DEBUG_STATUS_BREAK;

	do
	{
		hr = m_pDBGControl->GetExecutionStatus(&ExecStatus);
		FAILEDHR_BREAK(hr);

		if( ExecStatus != DEBUG_STATUS_BREAK ){
			break;
		}

		hr = BreakIn();
		FAILEDHR_BREAK(hr);

		hr = m_pDBGControl->Execute( DEBUG_OUTCTL_ALL_CLIENTS,
									"g",
									DEBUG_EXECUTE_DEFAULT
									);
		FAILEDHR_BREAK(hr);

	}
	while( false );

	return hr;
}

HRESULT
CEMSessionThread::BreakIn()
{
    ATLTRACE(_T("CEMSessionThread::BreakIn\n"));

	HRESULT	hr	= E_FAIL;
	ULONG	ExecStatus	= DEBUG_STATUS_BREAK;

	do
	{
		hr = m_pDBGControl->GetExecutionStatus(&ExecStatus);
		FAILEDHR_BREAK(hr);

		if( ExecStatus == DEBUG_STATUS_GO ||
			ExecStatus == DEBUG_STATUS_GO_HANDLED ||
			ExecStatus == DEBUG_STATUS_GO_NOT_HANDLED ){

			hr = m_pDBGControl->SetInterrupt(DEBUG_INTERRUPT_ACTIVE);
			FAILEDHR_BREAK(hr);

			//
			// Though SetInterrupt returns immediately, it takes some time
			// for the interrrupt to occur..
			//
			Sleep(2000);
		}
	}
	while( false );

	return hr;
}

HRESULT
CEMSessionThread::OnProcessExit
(
IN	ULONG nExitCode
)
{
    ATLTRACE(_T("CEMSessionThread::OnProcessExit\n"));

	HRESULT hr = S_OK;
	IDebugClient *pDBGClntLocal = NULL;
	IDebugControl *pDBGCtrlLocal = NULL;

	do
	{
#ifdef _DEBUG
        hr = m_pASTManager->SetSessionStatus(m_pEmSessObj->guidstream, STAT_SESS_STOPPED_DEBUGGEE_EXITED, S_OK, L"OnProcessExit");
#else
        hr = m_pASTManager->SetSessionStatus(m_pEmSessObj->guidstream, STAT_SESS_STOPPED_DEBUGGEE_EXITED, S_OK, NULL);
#endif
		FAILEDHR_BREAK(hr);

		hr = m_pDBGClient->CreateClient(&pDBGClntLocal);
		FAILEDHR_BREAK(hr);

		hr = pDBGClntLocal->ExitDispatch(m_pDBGClient);
		FAILEDHR_BREAK(hr);

    }
    while ( false );

	return hr;
}

HRESULT
CEMSessionThread::Execute()
{
    ATLTRACE(_T("CEMSessionThread::Execute\n"));

	HRESULT hr = E_FAIL;

	do
	{
		hr = m_pDBGControl->Execute( DEBUG_OUTCTL_ALL_CLIENTS,
									"? a;g",
									DEBUG_EXECUTE_DEFAULT
									);
		FAILEDHR_BREAK(hr);

	}
	while ( false );

	return hr;
}

HRESULT
CEMSessionThread::InitAutomaticSession
(
IN  BOOL    bRecursive,
IN  BSTR    bstrEcxFilePath,
IN  BSTR    bstrNotificationString,
IN  BSTR    bstrAltSymPath,
IN  BOOL    bGenerateMiniDump,
IN  BOOL    bGenerateUserDump
)
{
    ATLTRACE(_T("CEMSessionThread::InitAutomaticSession\n"));

    _ASSERTE(bstrEcxFilePath != NULL);

    if(bstrEcxFilePath == NULL) { return E_INVALIDARG; }

	eDBGSessType = SessType_Automatic;
    m_bRecursive = bRecursive;
    m_bstrEcxFilePath = ::SysAllocString(bstrEcxFilePath);
    m_bstrNotificationString = ::SysAllocString(bstrNotificationString);
    m_bstrAltSymPath = ::SysAllocString(bstrAltSymPath);
    m_bGenerateMiniDump = bGenerateMiniDump;
    m_bGenerateUserDump = bGenerateUserDump;

    return S_OK;
}

HRESULT
CEMSessionThread::InitManualSession
(
IN  BSTR	bstrEcxFilePath,
IN  UINT	nPortNumber,
IN  BSTR	bstrUserName,
IN  BSTR	bstrPassword,
IN  BOOL	bBlockIncomingIPConnections,
IN  BSTR    bstrAltSymPath
)
{
    ATLTRACE(_T("CEMSessionThread::InitManualSession\n"));

	_ASSERTE( nPortNumber != 0 );
	_ASSERTE( bstrUserName != NULL );
	_ASSERTE( bstrPassword != NULL );

	HRESULT		hr	=	E_FAIL;

	do {

		if( ( nPortNumber == 0 )	||
			( bstrUserName == NULL )||
			( bstrPassword == NULL ) ) {

				hr = E_INVALIDARG;
				break;
			}

		eDBGSessType = SessType_Manual;

		if(bstrEcxFilePath) m_bstrEcxFilePath = ::SysAllocString(bstrEcxFilePath);

		m_nPort = nPortNumber;
		m_bBlockIncomingIPConnections = bBlockIncomingIPConnections;
		if(bstrUserName) m_bstrUserName = ::SysAllocString(bstrUserName);
		if(bstrPassword) m_bstrPassword = ::SysAllocString(bstrPassword);
		if(bstrAltSymPath) m_bstrAltSymPath = ::SysAllocString(bstrAltSymPath);

		hr = S_OK;

	}
	while ( false );

    return hr;
}

HRESULT
CEMSessionThread::StopServer()
{
    ATLTRACE(_T("CEMSessionThread::StopServer\n"));

    HRESULT hr = E_FAIL;

    do {

        if(m_pi.hProcess){

            TerminateProcess(m_pi.hProcess, 0);
            ZeroMemory((void *)&m_pi, sizeof PROCESS_INFORMATION);
        }
    }
    while( false );

    return hr;
}

HRESULT
CEMSessionThread::NotifyAdmin(LPCTSTR lpszData)
{
    ATLTRACE(_T("CEMSessionThread::NotifyAdmin\n"));

    DWORD   dwLastRet   =   0L;

    CNotify AdminNotify(m_bstrNotificationString, lpszData);

    dwLastRet = AdminNotify.Notify();

    return HRESULT_FROM_WIN32(dwLastRet);
}

HRESULT
CEMSessionThread::GetDescriptionFromEmObj
(
const   PEmObject   pEmObj,
        LPTSTR      lpszDesc,
        ULONG       cchDesc,
        LPCTSTR     lpszHeader /* = NULL */
) const
{
    _ASSERTE( pEmObj != NULL );
    _ASSERTE( lpszDesc != NULL );
    _ASSERTE( cchDesc > 0 );

    HRESULT hr                      =   E_FAIL;
    TCHAR   szTemp[_MAX_PATH+1]     =   _T("");
    int     j                       =   0;

    do
    {
        if( pEmObj == NULL || lpszDesc == NULL || cchDesc <= 0 ) { return E_INVALIDARG; }
/*
    short type;
    unsigned char guidstream[ 16 ];
    LONG nId;
    TCHAR szName[ 256 ];
    TCHAR szSecName[ 256 ];
    LONG nStatus;
    DATE dateStart;
    DATE dateEnd;
    TCHAR szBucket1[ 64 ];
    DWORD dwBucket1;
    HRESULT hr;
*/
        j = _sntprintf(lpszDesc, cchDesc, _T("%s"), _T(""));

        if( lpszHeader ) {

            j += _sntprintf(lpszDesc+j, cchDesc, _T("%s -- "), lpszHeader); 
        }

        if( pEmObj->type == EMOBJ_PROCESS ) {

        	::LoadString(_Module.GetResourceInstance(), IDS_PROCESS, szTemp, _MAX_PATH);
        }
        else if( pEmObj->type == EMOBJ_SERVICE ) { 

            ::LoadString(_Module.GetResourceInstance(), IDS_SERVICE, szTemp, _MAX_PATH);
        }

        if(_tcscmp(szTemp, _T("")) != 0) {

            j += _sntprintf(lpszDesc+j, cchDesc, _T("%s : %d - "), szTemp, pEmObj->nId); 
        }

        if(_tcscmp(pEmObj->szName, _T("")) != 0) {
            
            ::LoadString(_Module.GetResourceInstance(), IDS_IMAGENAME, szTemp, _MAX_PATH);
            j += _sntprintf(lpszDesc+j, cchDesc, _T("%s : %s - "), szTemp, pEmObj->szName);
        }

        if(_tcscmp(pEmObj->szSecName, _T("")) != 0) {
            
            ::LoadString(_Module.GetResourceInstance(), IDS_SHORTNAME, szTemp, _MAX_PATH);
            j += _sntprintf(lpszDesc+j, cchDesc, _T("%s : %s - "), szTemp, pEmObj->szSecName);
        }

#ifdef _DEBUG
        StringFromGUID2(*(GUID*)pEmObj->guidstream, szTemp, _MAX_PATH);
        if( pEmObj->guidstream && strcmp((const char*)pEmObj->guidstream, "") != 0 ) { j += _sntprintf(lpszDesc+j, cchDesc, _T("%s"), szTemp); }
#endif // _DEBUG


    }
    while ( false );

    return hr;
}

HRESULT CEMSessionThread::CancelDebugging()
{
    ATLTRACE(_T("CEMSessionThread::CancelDebugging\n"));

	HRESULT			hr				= S_OK;
	IDebugClient	*pDBGClntLocal	= NULL;
	IDebugControl	*pDBGCtrlLocal	= NULL;

	do
	{
        if( eDBGSessType == SessType_Manual ) {

            hr = S_OK;
            break;
        }

        m_bContinueSession = FALSE;

		eDBGServie = DBGService_Cancel;

		hr = m_pDBGClient->CreateClient(&pDBGClntLocal);
		FAILEDHR_BREAK(hr);

		hr = pDBGClntLocal->ExitDispatch(m_pDBGClient);
		FAILEDHR_BREAK(hr);

		WaitForSingleObject( m_hEvent, INFINITE );

#ifdef _DEBUG
        hr = m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_SUCCESS,
                                S_OK,
                                L"CEMSessionThread::CancelDebugging - called"
                                );
#else
        hr = m_pASTManager->SetSessionStatus(
                                m_pEmSessObj->guidstream,
                                STAT_SESS_STOPPED_SUCCESS,
                                S_OK,
                                NULL
                                );
#endif
		FAILEDHR_BREAK(hr);

	}
	while(FALSE);

	return hr;
}

HRESULT
CEMSessionThread::ExecuteCommandsTillGo
(
OUT DWORD   *pdwRes
)
{
    _ASSERTE( m_pEcxFile != NULL );
    _ASSERTE( m_pDBGControl != NULL );

    HRESULT hr                  =   E_FAIL;
    char    cmd[MAX_COMMAND]    =   "";
	ULONG   ExecStatus          =   DEBUG_STATUS_BREAK;

    __try
    {

        if( m_pEcxFile == NULL ||
            m_pDBGControl == NULL ) {

            hr = E_INVALIDARG;
            goto qExecuteCommandsTillGo;
        }

        if( pdwRes ) *pdwRes = 0L; // success

        Sleep(2000); // 

        do
        {
			hr = m_pDBGControl->GetExecutionStatus(&ExecStatus);
            if( FAILED(hr) ) { goto qExecuteCommandsTillGo; }

            //
            // we can execute commands only when the debuggee is in
            // this state..
            //
            if( ExecStatus != DEBUG_STATUS_BREAK ) { hr = E_FAIL; goto qExecuteCommandsTillGo; }

            if (fgets(cmd, MAX_COMMAND-1, m_pEcxFile))
            {
                cmd[strlen(cmd) - 1] = 0;
                if( strcmp( cmd, "g" ) == 0 || strcmp( cmd, "G" ) == 0 ) { hr = S_OK; goto qExecuteCommandsTillGo; }

                hr = m_pDBGControl->OutputPrompt(DEBUG_OUTPUT_PROMPT, "> ");
                if( FAILED(hr) ) { goto qExecuteCommandsTillGo; }

		        hr = m_pDBGControl->Execute(
                                        DEBUG_OUTCTL_ALL_CLIENTS,
                                        cmd,
                                        DEBUG_EXECUTE_ECHO
                                        );

                if( FAILED(hr) ) { goto qExecuteCommandsTillGo; }

            }
            else // eof reached..??
            {
                if( pdwRes ) { *pdwRes = GetLastError(); }
                GetLastError();
                hr = S_FALSE;
                goto qExecuteCommandsTillGo;
            }
        }
        while ( true );

qExecuteCommandsTillGo:
        if( FAILED(hr) ) {}

    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		hr = E_UNEXPECTED;
		_ASSERTE( false );
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__4AD508C0_3D5F_4F04_AAC2_814BF64663A6__INCLUDED_)
#define AFX_STDAFX_H__4AD508C0_3D5F_4F04_AAC2_814BF64663A6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <afxwin.h>
#include <afxtempl.h>
#include <atlbase.h>

#include <initguid.h>
#include <dbgeng.h>
#include "emsvc.h"
#include "svcobjdef.h"
#include "comdef.h"
#include "Trace.h"
#include "GenCriticalSection.h"
#include "genobjdef.h"
#include "genlog.h"

#define OPT

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

#define WINOS_NONE      0
#define WINOS_NT4       4
#define WINOS_WIN2K     5

/* _afxMonthDays */
AFX_STATIC_DATA int MonthDays[13] =
	{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

class CServiceModule : public CComModule
{
public:

    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
	void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

    /* _AfxOleDateFromTm */
    static bool DateFromTm(WORD wYear, WORD wMonth, WORD wDay, WORD wHour, WORD wMinute, WORD wSecond, DATE& dtDest);
    static DATE GetCurrentTime();
    static DATE GetDateFromFileTm(const FILETIME& filetimeSrc);

    HRESULT GetCompName( BSTR &bstrCompName );

    HRESULT GetTempEmFileName ( short nObjType, BSTR &bstrFileName );

    HRESULT GetEmDirectory (
        EmObjectType    eObjectType,
        LPTSTR          pszDirectory,
        LONG            cchDirectory,
        LPTSTR          pszExt,
        LONG            cchExt
    );

    HRESULT GetEmFilePath ( short nFileType, bstr_t& bstrFilePath );

    HRESULT GetPathFromReg (
        HKEY            hKeyParent,
        LPCTSTR         lpszKeyName,
        LPCTSTR         lpszQueryKey,
        LPTSTR          pszDirectory,
        ULONG           *cchDirectory
        );

    HRESULT CreateEmDirectory (
        LPTSTR          lpDirName,
        LONG            ccDirName,
        LPCTSTR         lpParentDirPath = NULL
        );

    HRESULT RegisterDir (
        HKEY            hKeyParent,
        LPCTSTR         lpszKeyName, 
        LPCTSTR         lpszNamedValue,
        LPCTSTR         lpValue
        );

    HRESULT CreateEmDirAndRegister (
        LPTSTR          lpDirName,
        LONG            ccDirName,
        HKEY            hKeyParent,
        LPCTSTR         lpszKeyName,
        LPCTSTR         lpszNamedValue
        );

    HRESULT GetCDBInstallDir (
        LPTSTR          lpCdbDir,
        ULONG           *pccCdbDir
        );

    HRESULT GetEmInstallDir (
        LPTSTR  lpEmDir,
        ULONG   *pccEmDir
        );

    HRESULT
    GetMsInfoPath (
        LPTSTR  lpMsInfoPath,
        ULONG   *pccMsInfoPath
        );

    HRESULT
    GetOsVersion (
        OUT DWORD   *pdwOsVer
        );

//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;

    CExcepMonSessionManager m_SessionManager;

    bstr_t  m_bstrLogFilePath;
    bstr_t  m_bstrLogFileExt;

    bstr_t  m_bstrDumpFilePath;
    bstr_t  m_bstrDumpFileExt;

    bstr_t  m_bstrEcxFilePath;
    bstr_t  m_bstrEcxFileExt;

    bstr_t  m_bstrMsInfoFilePath;
    bstr_t  m_bstrMsInfoFileExt;

};

extern CServiceModule _Module;
inline LONG GetEmUniqueId()
{
    static LONG nId = 0;
    return ::InterlockedIncrement(&nId);
}

inline BSTR CopyBSTR( LPBYTE pb, ULONG cb)
{
    return ::SysAllocStringByteLen ((LPCSTR)pb, cb);
}

inline PEmObject GetEmObj(BSTR bstrEmObj)
{
	//Do a simple cast from a BSTR to an EmObject
    return ((PEmObject)bstrEmObj);
}

inline HRESULT
GetUniqueFileName
(
IN  PEmObject   pEmObj,
OUT LPTSTR      lpszFileName,
IN  LPCTSTR     lpszPostFix = NULL,
IN  LPCTSTR     lpszFileExt = NULL,
IN  bool        bForSearch  = false
)
{
    ATLTRACE(_T("GetUniqueFileName\n"));

    _ASSERTE( pEmObj != NULL );
    _ASSERTE( lpszFileName != NULL );

    HRESULT hr  =   E_FAIL;

    do
    {
        if( pEmObj == NULL ||
            lpszFileName == NULL ) {

            hr = E_INVALIDARG;
            break;
        }

        _tcscpy(lpszFileName, _T(""));

        if( _tcslen(pEmObj->szSecName) > 0 ) { _tcscpy( lpszFileName, pEmObj->szSecName ); }
        else if( _tcslen(pEmObj->szName) > 0 ) { _tcscpy( lpszFileName, pEmObj->szName ); }

        if( strlen((const char *)pEmObj->guidstream) > 0 ) {

            TCHAR   szGuid[_MAX_FNAME]  =   _T("");

            StringFromGUID2( *(GUID *)(pEmObj->guidstream), szGuid, _MAX_FNAME );

            _tcscat( lpszFileName, _T("_") );
            _tcscat( lpszFileName, szGuid );

        }

        if( lpszPostFix && _tcslen(lpszPostFix) > 0 ) {

            _tcscat( lpszFileName, _T("_") );
            _tcscat( lpszFileName, lpszPostFix );
        }

        if( bForSearch == false ) {

            TCHAR   szUniqueId[100] =   _T("");
            _ltot(GetEmUniqueId(), szUniqueId, 10);
            _tcscat( lpszFileName, _T("_") );
            _tcscat( lpszFileName, szUniqueId );
        }
        else {

            _tcscat( lpszFileName, _T("*") );
        }
        
        if( lpszFileExt && _tcslen(lpszFileExt) > 0 ) {

            if(*lpszFileExt != _T('.')){ _tcscat( lpszFileName, _T(".") ); }
            _tcscat( lpszFileName, lpszFileExt );
        }

        hr = S_OK;
    }
    while( false );

    return hr;
}

#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4AD508C0_3D5F_4F04_AAC2_814BF64663A6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\trace.cpp ===
#include "stdafx.h"
#include "trace.h"


void CTrace::TraceEvent(LPCTSTR pFormat, ...)
{
    ATLTRACE(_T("CTrace::TraceEvent\n"));

    m_pcs->ReadLock();

    __try {

        TCHAR    chMsg[256];
        HANDLE  hEventSource;
        LPTSTR  lpszStrings[1];
        va_list pArg;

        va_start(pArg, pFormat);
        _vstprintf(chMsg, pFormat, pArg);
        va_end(pArg);

        lpszStrings[0] = chMsg;

        /* Get a handle to use with ReportEvent(). */
        hEventSource = RegisterEventSource(NULL, m_szSourceName);
        if (hEventSource != NULL)
        {
            /* Write to event log. */
            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
	__except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

		_ASSERTE( false );
	}

    m_pcs->ReadUnlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\trace.h ===
#ifndef __TRACE_H
#define __TRACE_H

typedef interface ITrace {

// Data members
public:
private:
protected:

// Methods
public:
    virtual void TraceEvent(LPCTSTR lpszFormat, ...) = 0;
private:
protected:

} ITrace, *PITrace, **PPITrace;

class CTrace : public ITrace {

public:
private:
    TCHAR m_szSourceName[256];
    IGenCriticalSection *m_pcs;
protected:

public:
	CTrace()
	{
        ATLTRACE(_T("CTrace::CTrace\n"));

        _tcscpy(m_szSourceName, _T(""));
        m_pcs = new CGenCriticalSection;
	}

	CTrace(LPCTSTR lpszSourceName)
	{
        ATLTRACE(_T("CTrace::CTrace\n"));

        _tcscpy(m_szSourceName, lpszSourceName);
        m_pcs = new CGenCriticalSection;
	}

	~CTrace()
	{
        ATLTRACE(_T("CTrace::~CTrace\n"));

        delete m_pcs;
	}

private:
protected:

    virtual void TraceEvent(LPCTSTR lpszFormat, ...);
};

#endif // __TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\emsvc\svcobjdef.h ===
#ifndef __SVCOBJDEF_H
#define __SVCOBJDEF_H

#include "genthread.h"
#include "evenhand.h"
#include "gencriticalsection.h"
#include "EmErr.h"

typedef struct tagSession {

	HRESULT				hrDebug;

    PGENTHREAD			pThread;
    PEmObject           pEmObj;

} EMSession, *PEMSession, **PPEMSession;

typedef CMap < unsigned char*, unsigned char*, PEMSession, PEMSession > SessionsTable;

// DbgPrompt doesn't allow buffers greater than 512 bytes
// so limit these strings.
#define MAX_COMMAND 512

class CExcepMonSessionManager 
{
public:
	HRESULT AdoptThisSession( unsigned char *pGuid);
	HRESULT
    OrphanThisSession
    (
    IN  unsigned char *pGuid
    );

	HRESULT
    IsSessionOrphaned
    (
    IN  unsigned char *pGuid
    );

    CExcepMonSessionManager ();
    ~CExcepMonSessionManager ();
	void CleanUp();

    HRESULT 
    AddSession 
    (
    IN  PEmObject   pEmObj,
    OUT PEMSession  *ppNewEmSess
    );

    HRESULT 
    RemoveSession
    ( 
    IN unsigned char *pGuidStream
    );

    HRESULT
    GetSession
    (
    IN  unsigned char *pGuid,
    OUT PPEMSession ppEmSess
    );

	HRESULT
	GetSession
	(
	IN	UINT nPid,
	IN	BSTR bstrImageName,
	OUT	PEMSession *ppEmSess
	);

	HRESULT
	GetSessionStatus
	(
	IN  unsigned char   *pGuid,
	OUT LONG            *plSessStaus = NULL,
	OUT	HRESULT			*plHr = NULL
	);

	HRESULT
	SetSessionStatus
	(
	IN unsigned char    *pGuid,
	IN LONG             lSessStaus,
	IN HRESULT			lHr,
    IN LPCTSTR          lpszErrText = NULL,
    IN bool             bRetainOrphanState = true,
    IN bool             bSetEndTime = false
	);

    HRESULT StopAllThreads ( void ) ;

	HRESULT
	UpdateSessObject
	(
	IN unsigned char	*pGuid,
	IN PEmObject		pEmObj
	);

    HRESULT
    UpdateSessObject
    (
	IN unsigned char	*pGuid,
    IN DWORD            dwEmObjFlds,
    IN PEmObject        pEmObj
    );

    HRESULT
    UpdateSessObject
    (
	IN unsigned char	*pGuid,
    IN DWORD            dwEmObjFlds,
    IN short            type = EMOBJ_UNKNOWNOBJECT,
    IN short            type2 = SessType_Automatic,
	IN unsigned char    *pguidstream = NULL,
	IN LONG             nId = 0,
	IN TCHAR            *pszName = NULL,
	IN TCHAR            *pszSecName = NULL,
	IN LONG             nStatus = STAT_SESS_NONE_STAT_NONE,
	IN DATE             dateStart = 0L,
	IN DATE             dateEnd = 0L,
	IN TCHAR            *pszBucket1 = NULL,
	IN DWORD            dwBucket1 = 0L,
	IN HRESULT          hr = E_FAIL
    );

    HRESULT IsAlreadyBeingDebugged(PEmObject pEmObj);

    HRESULT GetNumberOfStoppedSessions(DWORD *pdwNumOfStoppedSessions);
    HRESULT GetNumberOfSessions(DWORD *pdwNumOfSessions);

    HRESULT
    GetFirstStoppedSession
    (
    OUT     POSITION        *ppos,
    OUT     unsigned char   **ppGuid,
    OUT     PEMSession      *ppEmSess
    );

    HRESULT
    GetNextStoppedSession
    (
    IN OUT  POSITION        *ppos,
    OUT     unsigned char   **ppGuid,
    OUT     PEMSession      *ppEmSess
    );

    BOOL
    IsPortInUse
    (
    IN  UINT    nPort
    );

	HRESULT
	GetFirstSession
	(
	OUT		POSITION		*ppos,
	OUT		PEMSession		*ppEmSess
	);

	HRESULT
	GetNextSession
	(
	IN OUT	POSITION		*ppos,
	OUT		PEMSession		*ppEmSess
	);

    HRESULT
    PersistSessions
    (
    IN  LPCTSTR lpFilePath
    );

    HRESULT
    InitSessionsFromLog
    (
    IN  LPCTSTR lpFilePath,
    IN  EmStatusHiWord  lStatusHi = STAT_SESS_NONE,
    IN  EmStatusLoWord  lStatusLo = STAT_NONE
    );

    HRESULT
    AddLoggedSession
    (
    IN  PEmObject   pEmObj
    );

protected:

    HRESULT InternalStopAllThreads ( void );
    HRESULT InternalRemoveSession ( PEMSession  pEMSession );


private:
    SessionsTable		m_SessTable;
    PGenCriticalSection m_pcs;
};

//
// Debug Service
//
typedef enum eDBGServiceRequested {
	DBGService_None,
	DBGService_CreateMiniDump,
	DBGService_CreateUserDump,
	DBGService_Stop,
    DBGService_Cancel,
	DBGService_Go,
	DBGService_HandleException,
	DBGService_Error
} eDBGServiceRequested;

class CEMSessionThread : public CGenThread {

public:

	UINT m_nPort;
	SessionType         eDBGSessType;
	HANDLE				m_hEvent;
    HANDLE              m_hCDBStarted;

    eDBGServiceRequested    eDBGServie;

	// Interface pointers..
	IDebugClient		*m_pDBGClient;
	IDebugControl		*m_pDBGControl;
    IDebugSymbols       *m_pDBGSymbols;

    PEmObject           m_pEmSessObj;

	EventCallbacks		m_EventCallbacks;

	STARTUPINFO			m_sp;
	PROCESS_INFORMATION m_pi;

    FILE                *m_pEcxFile;

    CExcepMonSessionManager *m_pASTManager;

public:
	HRESULT CancelDebugging();
	CEMSessionThread(PEmObject pEmObj);
	~CEMSessionThread();

	DWORD Run ( void );
	HRESULT CreateDumpFile( BOOL bMiniDump );
	HRESULT StopDebugging( );
	HRESULT	OnException( PEXCEPTION_RECORD64 pException );
	HRESULT OnProcessExit( ULONG nExitCode );
	HRESULT	CanContinue();
	HRESULT	KeepDebuggeeRunning();
	HRESULT	BreakIn();
	HRESULT	Execute();
    HRESULT StopServer();

    HRESULT InitAutomaticSession(
                        BOOL    bRecursive,
                        BSTR    bstrEcxFilePath,
                        BSTR    bstrNotificationString,
                        BSTR    bstrAltSymPath,
                        BOOL    bGenerateMiniDump,
                        BOOL    bGenerateUserDump
                        );

    HRESULT InitManualSession(
						BSTR	bstrEcxFilePath,
						UINT	nPortNumber,
						BSTR	bstrUserName,
						BSTR	bstrPassword,
						BOOL	bBlockIncomingIPConnections,
                        BSTR    bstrAltSymPath
                        );

protected:
	HRESULT GetServerConnectString( LPTSTR, DWORD );
	HRESULT GetClientConnectString( LPTSTR, DWORD );
	HRESULT	StartCDBServer( LPTSTR );
	HRESULT StartAutomaticExcepMonitoring( char * );
	HRESULT StartManualExcepMonitoring( char * );
	HRESULT GetCmd( eDBGServiceRequested, char *,DWORD &);
    HRESULT NotifyAdmin(LPCTSTR lpszData);
    HRESULT GetDescriptionFromEmObj(const PEmObject pEmObj, LPTSTR lpszDesc, ULONG cchDesc, LPCTSTR lpszHeader = NULL) const;
    HRESULT ExecuteCommandsTillGo( DWORD *pdwRes );

private:
    BOOL m_bContinueSession;
    BOOL m_bRecursive;
    BSTR m_bstrEcxFilePath;
    BSTR m_bstrNotificationString;
    BSTR m_bstrAltSymPath;
    BOOL m_bGenerateMiniDump;
    BOOL m_bGenerateUserDump;

    BOOL m_bBlockIncomingIPConnections;
    BSTR m_bstrUserName;
    BSTR m_bstrPassword;

};

#endif // __SVCOBJDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\include\gencriticalsection.h ===
#ifndef _GENCRITICALSECTION_H
#define _GENCRITICALSECTION_H

/////////////////////////////////////
// This class doesn't do much now,
// but this may help when we try to
// optimize the Lock and Unlocks'
/////////////////////////////////////

typedef interface IGenCriticalSection
{
// Data members
public:

private:
protected:
    CRITICAL_SECTION m_cs;

// Methods
public:
    IGenCriticalSection() { ::InitializeCriticalSection ( &m_cs ); }
    ~IGenCriticalSection() { ::DeleteCriticalSection ( &m_cs ); }

	virtual void ReadLock ( void ) = 0;
	virtual void ReadUnlock ( void ) = 0;

	virtual void WriteLock ( void ) = 0;
	virtual void WriteUnlock ( void ) = 0;

private:

protected:

}IGenCriticalSection, *PGenCriticalSection, **PPGenCriticalSection;

class CGenCriticalSection : public IGenCriticalSection
{
// Data members
public:
private:
protected:

// Methods
public:

private:
protected:
    virtual void ReadLock ( void ) { ::EnterCriticalSection (&m_cs); };
    virtual void ReadUnlock ( void ) { ::LeaveCriticalSection (&m_cs); };

    virtual void WriteLock ( void ) { ::EnterCriticalSection (&m_cs); };
    virtual void WriteUnlock ( void ) { ::LeaveCriticalSection (&m_cs); };
};

#endif // _GENCRITICALSECTION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\include\genlistctrl.h ===
///////////////////////////////////////////////////////////////////////////
//
// Module       : Common
// Description  : Common operations for a list control
//
// File         : genlistctrl.h
// Author       : kulor
// Date         : 05/08/2000
//
// History      :
//
///////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////

class CGenListCtrl : public CListCtrl {
public:
    CGenListCtrl ( void );
    virtual ~CGenListCtrl ();

    void ResizeColumnsFitScreen ( void );
    void ResizeColumnsWithRatio ( void );

    void SelectItem ( LONG nIndex );

    void BeginSetColumn ( LONG nCols );
    void AddColumn ( LPCTSTR pszColumn, DWORD dwItemData = 0, short type = VT_STRING );
    void EndSetColumn ( void );

    LONG SetItemText ( LONG nRow, LONG nCol, LPCTSTR pszText );
    LRESULT GenCompareFunc ( NMH* pNMH, DWORD dwParam1, DWORD dwParam2 );
};

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\include\genobjdef.h ===
///////////////////////////////////////////////////////////////////////////
//
// Module       : Common
// Description  : Common routines for ST projects
//
// File         : genobjdefs.h
// Author       : kulor
// Date         : 05/08/2000
//
// History      :
//
///////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////

#define IN
#define OUT
#define INOUT

#define SAFE_RELEASEIX(x)   if (x) { (x)->Release() ; (x) = NULL; }

#define SAFE_DELETEARRAY(a) if (a) { delete [] (a) ; (a) = NULL; }

#define ARRAY_SIZE(x)      ( sizeof (x) / sizeof (x[0]) )

#define FAILEDHR_BREAK(hr)	if(FAILED(hr) == TRUE){		\
								break;					\
							}

#define FAILEDDW_BREAK(dw)	if(dw != 0L){						\
								hr = HRESULT_FROM_WIN32(dw);	\
								break;							\
							}

///////////////////////////////////////////////////////////////////////////

template < class K >
class CFakeComObject : public K {
public:
    ULONG AddRef (void) { return 1; }
    ULONG Release (void) { return 1; }

    HRESULT QueryInterface ( REFIID riid, LPVOID* ppVoid )
    { return E_FAIL ; }
};

///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////

//
// VARIANT -- Helper functions..
//
__inline int IsBSTR(const VARIANT &rv)
{
	return (rv.vt == VT_BSTR)				|| 
		   (rv.vt == (VT_BYREF | VT_BSTR))	||
		   ((rv.vt == (VT_BYREF | VT_VARIANT)) && (rv.pvarVal->vt == VT_BSTR));
}

__inline const BSTR &GetBSTR(const VARIANT &rv)
{
	if(rv.vt == VT_BSTR)
	{
		return rv.bstrVal;
	}
	else if(rv.vt == (VT_BYREF | VT_BSTR))
	{
		return *(rv.pbstrVal);
	}
	else if((rv.vt == (VT_BYREF | VT_VARIANT)) && (rv.pvarVal->vt == VT_BSTR))
	{
		return rv.pvarVal->bstrVal;
	}
	else
	{
		return rv.bstrVal;
	}
	
}

__inline int IsInteger(const VARIANT &rv)
{
	return (rv.vt == VT_I4)													|| 
		   (rv.vt == (VT_BYREF | VT_I4))									||
		   ((rv.vt == (VT_BYREF | VT_VARIANT)) && (rv.pvarVal->vt == VT_I4))||
		   (rv.vt == VT_I2)													|| 
		   (rv.vt == (VT_BYREF | VT_I2))									||
		   ((rv.vt == (VT_BYREF | VT_VARIANT)) && (rv.pvarVal->vt == VT_I2));
}

__inline int GetInteger(const VARIANT &rv)
{
	if(rv.vt == VT_I4)
	{
		return rv.lVal;
	}
	else if(rv.vt == (VT_BYREF | VT_I4))
	{
		return *(rv.plVal);
	}
	else if((rv.vt == (VT_BYREF | VT_VARIANT)) && (rv.pvarVal->vt == VT_I4))
	{
		return rv.pvarVal->lVal;
	}
	else if(rv.vt == VT_I2)
	{
		return rv.iVal;
	}
	else if(rv.vt == (VT_BYREF | VT_I2))
	{
		return *(rv.piVal);
	}
	else if((rv.vt == (VT_BYREF | VT_VARIANT)) && (rv.pvarVal->vt == VT_I2))
	{
		return rv.pvarVal->iVal;
	}
	else
	{
		return -1;
	}
}

///////////////////////////////////////////////////////////////////////////

/*
*
* Work in progress
*
template < class K >
class CGenericPool {
public:
    CGenericPool ()
    {
        m_pchData = malloc (INITIAL_POOL_SIZE)
        m_cData = INITIAL_POOL_SIZE;
    }

    LONG GrowBy ( LONG cItems )
    {
        realloc ( m_pchData , sizeof (K) * (m_cData + cItems) );

        for ( long nIndex=0 ; nIndex < cItems ; nIndex++ ) {
            m_stackFreeNodes.Push ( nIndex );
        }
        return m_stackFreeNodes.GetSize();
    }

    K* AllocNode ( void )
    {
        if ( m_stackFreeNodes.IsEmpty () ) {
            if ( GrowBy ( m_cGrowBy ) == 0 )
                return NULL;
        }

        LONG nIndex = m_stackFreeNodes.Pop ();
        return reinterpret_cast < K* > ( m_pchData[nIndex] );
    }

    FreeNode ( K* )
    {
    }

protected:
    K           *m_pchData;
    LONG        m_cData;
    CGenStack   m_stackFreeNodes;
};
*/

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\include\genparse.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Module       : Common
// Description  : Generic Parser and CommandLine Definitions
//                Dependency on MFC for CString  
//
// File         : genparse.h
// Author       : kulor
// Date         : 05/08/2000
//
// History      :
//
///////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////

#ifndef INOUT
#define INOUT
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#define SPACE       TEXT (' ')
#define EQUALSTO    TEXT ('=')

///////////////////////////////////////////////////////////////////////////

inline bool SZIsValid
(
    IN      LPCTSTR psz
) 
{
    return ( psz != NULL ) && ( *psz != NULL ); 
}


///////////////////////////////////////////////////////////////////////////

inline void SkipSpaces
( 
    INOUT   LPCTSTR pszText
)
{
    while (pszText && *pszText == SPACE)
        pszText++;
}

///////////////////////////////////////////////////////////////////////////

inline long Cstrncpy
(
INOUT   CString &sDest,
IN      LPCTSTR pszSrc,
IN      LONG    cText
)
{
    long nCopied = cText;

    while (cText-- > 0) {
        sDest += *pszSrc++;
    }

    sDest += TCHAR( NULL );

    return (nCopied);
}

///////////////////////////////////////////////////////////////////////////

class CGenParser  {
public:
    CGenParser ()
    {
        m_pszDelims = TEXT ("-/");
        Initialize ( NULL, NULL );
    }

    CGenParser ( LPCTSTR pszText , LPCTSTR pszDelims = NULL )
    {
        Initialize (pszText, pszDelims );
    }

    virtual ~CGenParser ()
    {
    }

    void SetDelims ( LPCTSTR pszDelims )
    {
        if ( pszDelims )
            m_pszDelims = pszDelims;
    }

    virtual void Initialize ( LPCTSTR pszText , LPCTSTR pszDelims = NULL )
    {
        m_pszText = pszText;
        SetDelims (pszDelims);
    }

    bool IsOneof ( TCHAR ch, LPCTSTR pszText , LONG cText ) 
    {
        for ( int i=0 ; i<cText ; i++ ) {
            if ( pszText[i] == ch )
                return true;
        }
        return false;
    }

    virtual bool IsDelimiter ( TCHAR ch )
    {
        for ( int i=0 ; m_pszDelims[i] ; i++ ) {
            if ( ch == m_pszDelims[i] )
                return true;
        }
        return false;
    }

    virtual LPCTSTR GetNext ()
    {
        while ( SZIsValid (m_pszText) ) {

            if ( IsDelimiter (*m_pszText) ) {
                LPCTSTR pszBuf = m_pszText;
                m_pszText++;
                return ( pszBuf );
            }

            m_pszText++;
        }
        return ( NULL );
    }

protected:
    LPCTSTR     m_pszText;
    LPCTSTR     m_pszDelims;
};

///////////////////////////////////////////////////////////////////////////

class CGenCommandLine : public CGenParser {

    typedef CGenParser BaseClass;
    
public:
    CGenCommandLine ( void ) : BaseClass ()
    {}

    CGenCommandLine ( LPCTSTR pszCmdLine ) : BaseClass ( pszCmdLine )
    {}

    virtual ~CGenCommandLine ( void )
    {}

    virtual LPCTSTR GetNext ()
    {
        m_sToken.Empty ();
        m_sValue.Empty ();

        LPCTSTR pszRetVal   = NULL;

        // get the next argv
        if ( (pszRetVal = BaseClass::GetNext ()) != NULL ) {

            LPCTSTR pszBuf      = pszRetVal;
            LONG    cText = 0;

            // extract the LHS
            while ( SZIsValid( pszBuf+cText ) && pszBuf[cText] != SPACE && pszBuf[cText] != EQUALSTO )
                cText++;

            // ignore delimiter
            Cstrncpy ( m_sToken, pszBuf+1, cText-1 );

            pszBuf += cText;

            // move to first char after LHS
            cText = 0;
            pszBuf++;

            // eat white space
            SkipSpaces(pszBuf);

            if ( IsDelimiter ( *pszBuf ) == false ) {

                // extract the RHS
                while ( SZIsValid( pszBuf+cText ) && pszBuf[cText] != SPACE )
                    cText++;

               Cstrncpy ( m_sValue, pszBuf, cText );
            }

           // make the data pointer advance
           BaseClass::m_pszText = pszBuf + cText;
        }

        return pszRetVal;
    }

    LPCTSTR GetToken () { return m_sToken; }
    LPCTSTR GetValue () { return m_sValue; }

private:
    CString     m_sToken;
    CString     m_sValue;
};

///////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\include\genthread.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Module       : Common
// Description  : Generic Thread Base class 
//                Uses Win32 SEH
//
// File         : genthread.h
// Author       : kulor
// Date         : 05/18/2000
//
// History      :
//
///////////////////////////////////////////////////////////////////////////

#pragma once

///////////////////////////////////////////////////////////////////////////
//
// class CGenThread
//
// Usage : 1) Derive from this class and implement the Run method.
//         2) Use the IsStopRequested appropriately.
//
//
typedef class CGenThread {

public:
	CGenThread (bool fStart = false) {

        m_hGenThread    = NULL;
        m_dwThreadId    = 0;
        m_hGenStopEvent = ::CreateEvent ( 
                                NULL,
                                true,
                                false,
                                NULL 
                                );
        if ( fStart ) {
            Start ();
        }
    }

	virtual ~CGenThread () {
        CleanupThread ();
    }

    DWORD GetThreadId ( void ) { return m_dwThreadId ; }

    DWORD Start ( DWORD dwCreateFlags = 0 ) {

        DWORD   dwRet = FALSE;

        if ( !fOkToRun () || IsValidThread () )
            return FALSE;

        // de-signal the event 
        ::ResetEvent ( m_hGenStopEvent );

        m_hGenThread = ::CreateThread ( 
                                NULL,
                                0,
                                GenThreadProc,
                                reinterpret_cast <void*>(this),
                                0,
                                &m_dwThreadId
                                );
        dwRet = ( m_hGenThread ? 0 : GetLastError() );

        return dwRet;
    }

    DWORD Stop ( void ) {

        if ( IsValidThread () == FALSE )
            return FALSE;

        // signal the thread
        ::SetEvent ( m_hGenStopEvent );

        // now wait for it to stop
        DWORD dwRet = ::WaitForSingleObject ( m_hGenThread , INFINITE );

        CleanupThread ();

        return dwRet;
    }

    DWORD Pause ( void ) {

        if ( IsValidThread() == FALSE )
            return FALSE;

        ::SuspendThread ( m_hGenThread );
        return GetLastError ();
    }

    DWORD Resume ( void ) {

        if ( IsValidThread() == FALSE )
            return FALSE;

        ::ResumeThread ( m_hGenThread );
        return GetLastError ();
    }

    bool IsStopRequested ( void ) {
        bool	fVal = false;

        fVal = ( ::WaitForSingleObject ( m_hGenStopEvent, 0 ) == WAIT_OBJECT_0 );

        return (fVal);
    }

    virtual DWORD Run ( void ) = 0 ;

    bool IsValidThread ( void ) {
        return  ( m_hGenThread != NULL );
    }

protected:

    void CleanupThread ( void ) {

        m_dwThreadId = 0;

        if ( m_hGenStopEvent ) {
            ::CloseHandle ( m_hGenStopEvent );
            m_hGenStopEvent = NULL;
        }

        if ( m_hGenThread )  {
            ::CloseHandle ( m_hGenThread );
            m_hGenThread  = NULL;
        }
    }

    virtual bool fOkToRun( void ) {
        return ( m_hGenStopEvent != NULL );
    }

    static DWORD WINAPI GenThreadProc(
        LPVOID lpParameter   
        ) 
    {
        
        CGenThread  *pGenThread = reinterpret_cast<CGenThread*> (lpParameter);
        DWORD       dwRet = 0;

        if ( pGenThread ) {
            __try {

                dwRet = pGenThread->Run ();
            }

            __except ( EXCEPTION_EXECUTE_HANDLER, 1 ) {

                // wireup crash info
            }

            {

                pGenThread->CleanupThread ();
            }
        }

        return dwRet;
    }

protected:
	HANDLE      m_hGenStopEvent;
    HANDLE      m_hGenThread;
    DWORD       m_dwThreadId;

} CGenThread, GENTHREAD, *PGENTHREAD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\excepmon\include\sahlp.h ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module  Name :
       sahlp.h

   Abstract:
       Simple helpers for dealing with safearrays

   Author:
       Kulo Rajasekaran  (kulor)    5/25/2000

   Environment:
       Win32 

   Project:
       utils

   Revision History:

--*/

#pragma once

///////////////////////////////////////////////////////////////////////////////
// SA_CreateOneDim
//
// Description
//  Use this to create a 0 based, one dimensional safearray of any of the datatypes 
//  supported by VARIANT
//
//  Ex: SAFEARRAY   *psa = NULL;
//      SA_CreateOneDim ( psa, 5, VT_BSTR );
//      for (ULONG i=0 ; i<5 ; i++ )  {
//          SafeArrayPutElement ( psa, &i, pSomeValidBstrHere );
//
inline HRESULT SA_CreateOneDim 
( 
    SAFEARRAY   **ppsa, 
    DWORD       cElems, 
    short       vt 
)
{
    HRESULT         hr          =   S_OK;
    SAFEARRAY       *psa        =   NULL;
    SAFEARRAYBOUND  bound;
    long            *plAddr     =   NULL;
    long            lIdx        =   0L;
    UINT            nElemSize   =   0;

    bound.lLbound   = 0;
    bound.cElements = cElems;

    psa = ::SafeArrayCreate ( vt, 1, &bound );
    if ( !psa ) {
        hr = E_FAIL;
        goto exit;
    }

    ::SafeArrayPtrOfIndex( psa, &lIdx, (void**)&plAddr );
    nElemSize = ::SafeArrayGetElemsize( psa );

    memset(plAddr, 0L, cElems * nElemSize);

    *ppsa = psa;

exit:
    if ( FAILED(hr) )
        if ( psa ) 
            ::SafeArrayDestroy ( psa );

    return ( hr );
}

///////////////////////////////////////////////////////////////////////////////
// Variant_CreateOneDim
//
// Description
//  Use this to create a safearray ( of type vt ) with in the passed Variant
//
// See SA_CreateOneDim for description
//
inline HRESULT Variant_CreateOneDim ( VARIANT *pv, DWORD cElems, short vt = VT_VARIANT)
{
    HRESULT     hr;
    
    hr = ::VariantClear(pv);

    hr = SA_CreateOneDim ( &pv->parray, cElems, vt );

    if ( SUCCEEDED(hr) )
        pv->vt = vt | VT_ARRAY;

    return ( hr );
}

inline HRESULT Variant_DestroyOneDim( VARIANT *pv )
{
    HRESULT hr  =   E_FAIL;

    SAFEARRAY *psa = pv->parray;
    _ASSERTE (psa != NULL);

    hr = SafeArrayDestroy(psa);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exdi\exdi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0323 */
/* at Mon May 22 18:20:12 2000
 */
/* Compiler settings for exdi.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __exdi_h__
#define __exdi_h__

/* Forward Declarations */ 

#ifndef __IeXdiServer_FWD_DEFINED__
#define __IeXdiServer_FWD_DEFINED__
typedef interface IeXdiServer IeXdiServer;
#endif 	/* __IeXdiServer_FWD_DEFINED__ */


#ifndef __IeXdiCodeBreakpoint_FWD_DEFINED__
#define __IeXdiCodeBreakpoint_FWD_DEFINED__
typedef interface IeXdiCodeBreakpoint IeXdiCodeBreakpoint;
#endif 	/* __IeXdiCodeBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiDataBreakpoint_FWD_DEFINED__
#define __IeXdiDataBreakpoint_FWD_DEFINED__
typedef interface IeXdiDataBreakpoint IeXdiDataBreakpoint;
#endif 	/* __IeXdiDataBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiEnumCodeBreakpoint_FWD_DEFINED__
#define __IeXdiEnumCodeBreakpoint_FWD_DEFINED__
typedef interface IeXdiEnumCodeBreakpoint IeXdiEnumCodeBreakpoint;
#endif 	/* __IeXdiEnumCodeBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiEnumDataBreakpoint_FWD_DEFINED__
#define __IeXdiEnumDataBreakpoint_FWD_DEFINED__
typedef interface IeXdiEnumDataBreakpoint IeXdiEnumDataBreakpoint;
#endif 	/* __IeXdiEnumDataBreakpoint_FWD_DEFINED__ */


#ifndef __IeXdiX86Context_FWD_DEFINED__
#define __IeXdiX86Context_FWD_DEFINED__
typedef interface IeXdiX86Context IeXdiX86Context;
#endif 	/* __IeXdiX86Context_FWD_DEFINED__ */


#ifndef __IeXdiSHXContext_FWD_DEFINED__
#define __IeXdiSHXContext_FWD_DEFINED__
typedef interface IeXdiSHXContext IeXdiSHXContext;
#endif 	/* __IeXdiSHXContext_FWD_DEFINED__ */


#ifndef __IeXdiMIPSContext_FWD_DEFINED__
#define __IeXdiMIPSContext_FWD_DEFINED__
typedef interface IeXdiMIPSContext IeXdiMIPSContext;
#endif 	/* __IeXdiMIPSContext_FWD_DEFINED__ */


#ifndef __IeXdiARMContext_FWD_DEFINED__
#define __IeXdiARMContext_FWD_DEFINED__
typedef interface IeXdiARMContext IeXdiARMContext;
#endif 	/* __IeXdiARMContext_FWD_DEFINED__ */


#ifndef __IeXdiPPCContext_FWD_DEFINED__
#define __IeXdiPPCContext_FWD_DEFINED__
typedef interface IeXdiPPCContext IeXdiPPCContext;
#endif 	/* __IeXdiPPCContext_FWD_DEFINED__ */


#ifndef __IeXdiClientNotifyMemChg_FWD_DEFINED__
#define __IeXdiClientNotifyMemChg_FWD_DEFINED__
typedef interface IeXdiClientNotifyMemChg IeXdiClientNotifyMemChg;
#endif 	/* __IeXdiClientNotifyMemChg_FWD_DEFINED__ */


#ifndef __IeXdiClientNotifyRunChg_FWD_DEFINED__
#define __IeXdiClientNotifyRunChg_FWD_DEFINED__
typedef interface IeXdiClientNotifyRunChg IeXdiClientNotifyRunChg;
#endif 	/* __IeXdiClientNotifyRunChg_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_exdi_0000 */
/* [local] */ 













// Common eXDI HRESULT values:
//
#define FACILITY_EXDI   (130)
#define CUSTOMER_FLAG   (1)
//
#define SEV_SUCCESS         (0)
#define SEV_INFORMATIONAL   (1)
#define SEV_WARNING         (2)
#define SEV_ERROR           (3)
//
#define MAKE_EXDI_ERROR(ErrorCode,Severity) ((DWORD)(ErrorCode) | (FACILITY_EXDI << 16) | (CUSTOMER_FLAG << 29) | (Severity << 30))
//
//      S_OK							(0)											 // Operation successful
#define EXDI_E_NOTIMPL               MAKE_EXDI_ERROR (0x4001, SEV_ERROR)          // Not implemented (in the specific conditions - could be implement for others - like Kernel Debugger inactive)
#define EXDI_E_OUTOFMEMORY           MAKE_EXDI_ERROR (0x000E, SEV_ERROR)          // Failed to allocate necessary memory
#define EXDI_E_INVALIDARG            MAKE_EXDI_ERROR (0x0057, SEV_ERROR)          // One or more arguments are invalid
#define EXDI_E_ABORT                 MAKE_EXDI_ERROR (0x4004, SEV_ERROR)          // Operation aborted
#define EXDI_E_FAIL                  MAKE_EXDI_ERROR (0x4005, SEV_ERROR)          // Unspecified failure
#define EXDI_E_COMMUNICATION         MAKE_EXDI_ERROR (0x0001, SEV_ERROR)          // Communication error between host driver and target
//
#define EXDI_E_NOLASTEXCEPTION       MAKE_EXDI_ERROR (0x0002, SEV_ERROR)          // No exception occured already, cannot return last
#define EXDI_I_TGTALREADYRUNNING     MAKE_EXDI_ERROR (0x0003, SEV_INFORMATIONAL)  // Indicates that the target was already running
#define EXDI_I_TGTALREADYHALTED      MAKE_EXDI_ERROR (0x0004, SEV_INFORMATIONAL)  // Indicates that the target was already halted
#define EXDI_E_TGTWASNOTHALTED       MAKE_EXDI_ERROR (0x0005, SEV_ERROR)          // The target was not halted (before Single Step command issued)
#define EXDI_E_NORESAVAILABLE        MAKE_EXDI_ERROR (0x0006, SEV_ERROR)          // No resource available, cannot instanciate Breakpoint (in the kind requested)
#define EXDI_E_NOREBOOTAVAIL         MAKE_EXDI_ERROR (0x0007, SEV_ERROR)          // The external reset is not available programatically to the probe
#define EXDI_E_ACCESSVIOLATION       MAKE_EXDI_ERROR (0x0008, SEV_ERROR)          // Access violation on at least one element in address range specificified by the operation
#define EXDI_E_CANNOTWHILETGTRUNNING MAKE_EXDI_ERROR (0x0009, SEV_ERROR)          // Cannot proceed while target running. Operation not supported on the fly. Must halt the target first
#define EXDI_E_USEDBYCONCURENTTHREAD MAKE_EXDI_ERROR (0x000A, SEV_ERROR)          // Cannot proceed immediately because resource is already used by concurent thread. Recall later or call SetWaitOnConcurentUse (TRUE) - default
#define EXDI_E_ADVISELIMIT           MAKE_EXDI_ERROR (0x000D, SEV_ERROR)          // The connection point has already reached its limit of connections and cannot accept any more
typedef __int64 ADDRESS_TYPE;

typedef __int64 __RPC_FAR *PADDRESS_TYPE;

typedef unsigned __int64 DWORD64;

typedef unsigned __int64 __RPC_FAR *PDWORD64;

#define	PROCESSOR_FAMILY_X86	( 0 )

#define	PROCESSOR_FAMILY_SH3	( 1 )

#define	PROCESSOR_FAMILY_SH4	( 2 )

#define	PROCESSOR_FAMILY_MIPS	( 3 )

#define	PROCESSOR_FAMILY_ARM	( 4 )

#define	PROCESSOR_FAMILY_PPC	( 5 )

#define	PROCESSOR_FAMILY_UNK	( 0xffffffff )

typedef struct _DEBUG_ACCESS_CAPABILITIES_STRUCT
    {
    BOOL fWriteCBPWhileRunning;
    BOOL fReadCBPWhileRunning;
    BOOL fWriteDBPWhileRunning;
    BOOL fReadDBPWhileRunning;
    BOOL fWriteVMWhileRunning;
    BOOL fReadVMWhileRunning;
    BOOL fWritePMWhileRunning;
    BOOL fReadPMWhileRunning;
    BOOL fWriteRegWhileRunning;
    BOOL fReadRegWhileRunning;
    } 	DEBUG_ACCESS_CAPABILITIES_STRUCT;

typedef struct _DEBUG_ACCESS_CAPABILITIES_STRUCT __RPC_FAR *PDEBUG_ACCESS_CAPABILITIES_STRUCT;

typedef struct _GLOBAL_TARGET_INFO_STRUCT
    {
    DWORD TargetProcessorFamily;
    DEBUG_ACCESS_CAPABILITIES_STRUCT dbc;
    LPOLESTR szTargetName;
    LPOLESTR szProbeName;
    } 	GLOBAL_TARGET_INFO_STRUCT;

typedef struct _GLOBAL_TARGET_INFO_STRUCT __RPC_FAR *PGLOBAL_TARGET_INFO_STRUCT;

typedef 
enum _RUN_STATUS_TYPE
    {	rsRunning	= 0,
	rsHalted	= rsRunning + 1,
	rsError	= rsHalted + 1,
	rsUnknown	= rsError + 1
    } 	RUN_STATUS_TYPE;

typedef enum _RUN_STATUS_TYPE __RPC_FAR *PRUN_STATUS_TYPE;

typedef 
enum _PHALT_REASON_TYPE
    {	hrNone	= 0,
	hrUser	= hrNone + 1,
	hrException	= hrUser + 1,
	hrBp	= hrException + 1,
	hrStep	= hrBp + 1,
	hrUnknown	= hrStep + 1
    } 	HALT_REASON_TYPE;

typedef enum _PHALT_REASON_TYPE __RPC_FAR *PHALT_REASON_TYPE;

typedef struct _EXCEPTION_TYPE
    {
    DWORD dwCode;
    ADDRESS_TYPE Address;
    } 	EXCEPTION_TYPE;

typedef struct _EXCEPTION_TYPE __RPC_FAR *PEXCEPTION_TYPE;

typedef 
enum _CBP_KIND
    {	cbptAlgo	= 0,
	cbptHW	= cbptAlgo + 1,
	cbptSW	= cbptHW + 1
    } 	CBP_KIND;

typedef enum _CBP_KIND __RPC_FAR *PCBP_KIND;

typedef 
enum _DATA_ACCESS_TYPE
    {	daWrite	= 0,
	daRead	= 1,
	daBoth	= 2
    } 	DATA_ACCESS_TYPE;

typedef enum _DATA_ACCESS_TYPE __RPC_FAR *PDATA_ACCESS_TYPE;

typedef struct _BREAKPOINT_SUPPORT_TYPE
    {
    BOOL fCodeBpBypassCountSupported;
    BOOL fDataBpBypassCountSupported;
    BOOL fDataBpSupported;
    BOOL fDataBpMaskableAddress;
    BOOL fDataBpMaskableData;
    BOOL fDataBpDataWidthSpecifiable;
    BOOL fDataBpReadWriteSpecifiable;
    BOOL fDataBpDataMatchSupported;
    } 	BREAKPOINT_SUPPORT_TYPE;

typedef struct _BREAKPOINT_SUPPORT_TYPE __RPC_FAR *PBREAKPOINT_SUPPORT_TYPE;

typedef 
enum _MEM_TYPE
    {	mtVirtual	= 0,
	mtPhysicalOrPeriIO	= mtVirtual + 1,
	mtContext	= mtPhysicalOrPeriIO + 1
    } 	MEM_TYPE;

typedef enum _MEM_TYPE __RPC_FAR *PMEM_TYPE;

typedef 
enum _EXCEPTION_DEFAULT_ACTION_TYPE
    {	edaIgnore	= 0,
	edaNotify	= edaIgnore + 1,
	edaStop	= edaNotify + 1
    } 	EXCEPTION_DEFAULT_ACTION_TYPE;

typedef struct _EXCEPTION_DESCRIPTION_TYPE
    {
    DWORD dwExceptionCode;
    EXCEPTION_DEFAULT_ACTION_TYPE efd;
    wchar_t szDescription[ 60 ];
    } 	EXCEPTION_DESCRIPTION_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0000_v0_0_s_ifspec;

#ifndef __IeXdiServer_INTERFACE_DEFINED__
#define __IeXdiServer_INTERFACE_DEFINED__

/* interface IeXdiServer */
/* [ref][helpstring][uuid][object] */ 

#define DBGMODE_BFMASK_KERNEL (0x0001) // If TRUE indicates that Kernel Debugger is active (can use KDAPI), so HW on-chip debug functions (eXDI)
                                       //  may be optionaly handled (can return EXDI_E_NOTIMPL)
                                       // If FALSE indicates that Kernel Debugger is not active so HW on-chip debug capabilities are the only   
                                       //  one available and should be implemented.

EXTERN_C const IID IID_IeXdiServer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495352435201")
    IeXdiServer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTargetInfo( 
            /* [out] */ PGLOBAL_TARGET_INFO_STRUCT pgti) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugMode( 
            /* [in] */ DWORD dwModeBitField) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExceptionDescriptionList( 
            /* [in] */ DWORD dwNbElementToReturn,
            /* [size_is][out] */ EXCEPTION_DESCRIPTION_TYPE __RPC_FAR *pedTable,
            /* [out] */ DWORD __RPC_FAR *pdwNbTotalExceptionInList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorDescription( 
            /* [in] */ HRESULT ErrorCode,
            /* [out] */ LPOLESTR __RPC_FAR *pszErrorDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWaitOnConcurentUse( 
            /* [in] */ BOOL fNewWaitOnConcurentUseFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunStatus( 
            /* [out] */ PRUN_STATUS_TYPE persCurrent,
            /* [out] */ PHALT_REASON_TYPE pehrCurrent,
            /* [out] */ ADDRESS_TYPE __RPC_FAR *pCurrentExecAddress,
            /* [out] */ DWORD __RPC_FAR *pdwExceptionCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastException( 
            /* [out] */ PEXCEPTION_TYPE pexLast) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Halt( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoSingleStep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoMultipleStep( 
            /* [in] */ DWORD dwNbInstructions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoRangeStep( 
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reboot( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBpSupport( 
            /* [out] */ PBREAKPOINT_SUPPORT_TYPE pbps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNbCodeBpAvail( 
            /* [out] */ DWORD __RPC_FAR *pdwNbHwCodeBpAvail,
            /* [out] */ DWORD __RPC_FAR *pdwNbSwCodeBpAvail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNbDataBpAvail( 
            /* [out] */ DWORD __RPC_FAR *pdwNbDataBpAvail) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddCodeBreakpoint( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ CBP_KIND cbpk,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ DWORD dwExecMode,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelCodeBreakpoint( 
            /* [in] */ IeXdiCodeBreakpoint __RPC_FAR *pieXdiCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDataBreakpoint( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ ADDRESS_TYPE AddressMask,
            /* [in] */ DWORD dwData,
            /* [in] */ DWORD dwDataMask,
            /* [in] */ BYTE bAccessWidth,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DATA_ACCESS_TYPE da,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DelDataBreakpoint( 
            /* [in] */ IeXdiDataBreakpoint __RPC_FAR *pieXdiDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAllCodeBreakpoints( 
            /* [out] */ IeXdiEnumCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAllDataBreakpoints( 
            /* [out] */ IeXdiEnumDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumCodeBreakpointsInAddrRange( 
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDataBreakpointsInAddrRange( 
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartNotifyingRunChg( 
            /* [in] */ IeXdiClientNotifyRunChg __RPC_FAR *pieXdiClientNotifyRunChg,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopNotifyingRunChg( 
            /* [in] */ DWORD dwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVirtualMemory( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE __RPC_FAR *pbReadBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwNbElementEffectRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteVirtualMemory( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbWriteBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwNbElementEffectWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPhysicalMemoryOrPeriphIO( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE __RPC_FAR *pbReadBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePhysicalMemoryOrPeriphIO( 
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbWriteBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartNotifyingMemChg( 
            /* [in] */ IeXdiClientNotifyMemChg __RPC_FAR *pieXdiClientNotifyMemChg,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopNotifyingMemChg( 
            /* [in] */ DWORD dwConnectionCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Ioctl( 
            /* [in] */ DWORD dwBuffInSize,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbBufferIn,
            /* [in] */ DWORD dwBuffOutSize,
            /* [out] */ DWORD __RPC_FAR *pdwEffectBuffOutSize,
            /* [length_is][size_is][out] */ BYTE __RPC_FAR *pbBufferOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTargetInfo )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ PGLOBAL_TARGET_INFO_STRUCT pgti);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDebugMode )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ DWORD dwModeBitField);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExceptionDescriptionList )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ DWORD dwNbElementToReturn,
            /* [size_is][out] */ EXCEPTION_DESCRIPTION_TYPE __RPC_FAR *pedTable,
            /* [out] */ DWORD __RPC_FAR *pdwNbTotalExceptionInList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorDescription )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ HRESULT ErrorCode,
            /* [out] */ LPOLESTR __RPC_FAR *pszErrorDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWaitOnConcurentUse )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ BOOL fNewWaitOnConcurentUseFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRunStatus )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ PRUN_STATUS_TYPE persCurrent,
            /* [out] */ PHALT_REASON_TYPE pehrCurrent,
            /* [out] */ ADDRESS_TYPE __RPC_FAR *pCurrentExecAddress,
            /* [out] */ DWORD __RPC_FAR *pdwExceptionCode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastException )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ PEXCEPTION_TYPE pexLast);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IeXdiServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Halt )( 
            IeXdiServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoSingleStep )( 
            IeXdiServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoMultipleStep )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ DWORD dwNbInstructions);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoRangeStep )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reboot )( 
            IeXdiServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBpSupport )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ PBREAKPOINT_SUPPORT_TYPE pbps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNbCodeBpAvail )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwNbHwCodeBpAvail,
            /* [out] */ DWORD __RPC_FAR *pdwNbSwCodeBpAvail);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNbDataBpAvail )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwNbDataBpAvail);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddCodeBreakpoint )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ CBP_KIND cbpk,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ DWORD dwExecMode,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DelCodeBreakpoint )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ IeXdiCodeBreakpoint __RPC_FAR *pieXdiCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddDataBreakpoint )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ ADDRESS_TYPE AddressMask,
            /* [in] */ DWORD dwData,
            /* [in] */ DWORD dwDataMask,
            /* [in] */ BYTE bAccessWidth,
            /* [in] */ MEM_TYPE mt,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DATA_ACCESS_TYPE da,
            /* [in] */ DWORD dwTotalBypassCount,
            /* [out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DelDataBreakpoint )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ IeXdiDataBreakpoint __RPC_FAR *pieXdiDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumAllCodeBreakpoints )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ IeXdiEnumCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumAllDataBreakpoints )( 
            IeXdiServer __RPC_FAR * This,
            /* [out] */ IeXdiEnumDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCodeBreakpointsInAddrRange )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumDataBreakpointsInAddrRange )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE FirstAddress,
            /* [in] */ ADDRESS_TYPE LastAddress,
            /* [out] */ IeXdiEnumDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartNotifyingRunChg )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ IeXdiClientNotifyRunChg __RPC_FAR *pieXdiClientNotifyRunChg,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopNotifyingRunChg )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadVirtualMemory )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE __RPC_FAR *pbReadBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwNbElementEffectRead);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteVirtualMemory )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbWriteBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwNbElementEffectWritten);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadPhysicalMemoryOrPeriphIO )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToRead,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][out] */ BYTE __RPC_FAR *pbReadBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WritePhysicalMemoryOrPeriphIO )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemToWrite,
            /* [in] */ BYTE bAccessWidth,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbWriteBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartNotifyingMemChg )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ IeXdiClientNotifyMemChg __RPC_FAR *pieXdiClientNotifyMemChg,
            /* [out] */ DWORD __RPC_FAR *pdwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopNotifyingMemChg )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ DWORD dwConnectionCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Ioctl )( 
            IeXdiServer __RPC_FAR * This,
            /* [in] */ DWORD dwBuffInSize,
            /* [size_is][in] */ const BYTE __RPC_FAR *pbBufferIn,
            /* [in] */ DWORD dwBuffOutSize,
            /* [out] */ DWORD __RPC_FAR *pdwEffectBuffOutSize,
            /* [length_is][size_is][out] */ BYTE __RPC_FAR *pbBufferOut);
        
        END_INTERFACE
    } IeXdiServerVtbl;

    interface IeXdiServer
    {
        CONST_VTBL struct IeXdiServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiServer_GetTargetInfo(This,pgti)	\
    (This)->lpVtbl -> GetTargetInfo(This,pgti)

#define IeXdiServer_SetDebugMode(This,dwModeBitField)	\
    (This)->lpVtbl -> SetDebugMode(This,dwModeBitField)

#define IeXdiServer_GetExceptionDescriptionList(This,dwNbElementToReturn,pedTable,pdwNbTotalExceptionInList)	\
    (This)->lpVtbl -> GetExceptionDescriptionList(This,dwNbElementToReturn,pedTable,pdwNbTotalExceptionInList)

#define IeXdiServer_GetErrorDescription(This,ErrorCode,pszErrorDesc)	\
    (This)->lpVtbl -> GetErrorDescription(This,ErrorCode,pszErrorDesc)

#define IeXdiServer_SetWaitOnConcurentUse(This,fNewWaitOnConcurentUseFlag)	\
    (This)->lpVtbl -> SetWaitOnConcurentUse(This,fNewWaitOnConcurentUseFlag)

#define IeXdiServer_GetRunStatus(This,persCurrent,pehrCurrent,pCurrentExecAddress,pdwExceptionCode)	\
    (This)->lpVtbl -> GetRunStatus(This,persCurrent,pehrCurrent,pCurrentExecAddress,pdwExceptionCode)

#define IeXdiServer_GetLastException(This,pexLast)	\
    (This)->lpVtbl -> GetLastException(This,pexLast)

#define IeXdiServer_Run(This)	\
    (This)->lpVtbl -> Run(This)

#define IeXdiServer_Halt(This)	\
    (This)->lpVtbl -> Halt(This)

#define IeXdiServer_DoSingleStep(This)	\
    (This)->lpVtbl -> DoSingleStep(This)

#define IeXdiServer_DoMultipleStep(This,dwNbInstructions)	\
    (This)->lpVtbl -> DoMultipleStep(This,dwNbInstructions)

#define IeXdiServer_DoRangeStep(This,FirstAddress,LastAddress)	\
    (This)->lpVtbl -> DoRangeStep(This,FirstAddress,LastAddress)

#define IeXdiServer_Reboot(This)	\
    (This)->lpVtbl -> Reboot(This)

#define IeXdiServer_GetBpSupport(This,pbps)	\
    (This)->lpVtbl -> GetBpSupport(This,pbps)

#define IeXdiServer_GetNbCodeBpAvail(This,pdwNbHwCodeBpAvail,pdwNbSwCodeBpAvail)	\
    (This)->lpVtbl -> GetNbCodeBpAvail(This,pdwNbHwCodeBpAvail,pdwNbSwCodeBpAvail)

#define IeXdiServer_GetNbDataBpAvail(This,pdwNbDataBpAvail)	\
    (This)->lpVtbl -> GetNbDataBpAvail(This,pdwNbDataBpAvail)

#define IeXdiServer_AddCodeBreakpoint(This,Address,cbpk,mt,dwExecMode,dwTotalBypassCount,ppieXdiCodeBreakpoint)	\
    (This)->lpVtbl -> AddCodeBreakpoint(This,Address,cbpk,mt,dwExecMode,dwTotalBypassCount,ppieXdiCodeBreakpoint)

#define IeXdiServer_DelCodeBreakpoint(This,pieXdiCodeBreakpoint)	\
    (This)->lpVtbl -> DelCodeBreakpoint(This,pieXdiCodeBreakpoint)

#define IeXdiServer_AddDataBreakpoint(This,Address,AddressMask,dwData,dwDataMask,bAccessWidth,mt,bAddressSpace,da,dwTotalBypassCount,ppieXdiDataBreakpoint)	\
    (This)->lpVtbl -> AddDataBreakpoint(This,Address,AddressMask,dwData,dwDataMask,bAccessWidth,mt,bAddressSpace,da,dwTotalBypassCount,ppieXdiDataBreakpoint)

#define IeXdiServer_DelDataBreakpoint(This,pieXdiDataBreakpoint)	\
    (This)->lpVtbl -> DelDataBreakpoint(This,pieXdiDataBreakpoint)

#define IeXdiServer_EnumAllCodeBreakpoints(This,ppieXdiEnumCodeBreakpoint)	\
    (This)->lpVtbl -> EnumAllCodeBreakpoints(This,ppieXdiEnumCodeBreakpoint)

#define IeXdiServer_EnumAllDataBreakpoints(This,ppieXdiEnumDataBreakpoint)	\
    (This)->lpVtbl -> EnumAllDataBreakpoints(This,ppieXdiEnumDataBreakpoint)

#define IeXdiServer_EnumCodeBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumCodeBreakpoint)	\
    (This)->lpVtbl -> EnumCodeBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumCodeBreakpoint)

#define IeXdiServer_EnumDataBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumDataBreakpoint)	\
    (This)->lpVtbl -> EnumDataBreakpointsInAddrRange(This,FirstAddress,LastAddress,ppieXdiEnumDataBreakpoint)

#define IeXdiServer_StartNotifyingRunChg(This,pieXdiClientNotifyRunChg,pdwConnectionCookie)	\
    (This)->lpVtbl -> StartNotifyingRunChg(This,pieXdiClientNotifyRunChg,pdwConnectionCookie)

#define IeXdiServer_StopNotifyingRunChg(This,dwConnectionCookie)	\
    (This)->lpVtbl -> StopNotifyingRunChg(This,dwConnectionCookie)

#define IeXdiServer_ReadVirtualMemory(This,Address,dwNbElemToRead,bAccessWidth,pbReadBuffer,pdwNbElementEffectRead)	\
    (This)->lpVtbl -> ReadVirtualMemory(This,Address,dwNbElemToRead,bAccessWidth,pbReadBuffer,pdwNbElementEffectRead)

#define IeXdiServer_WriteVirtualMemory(This,Address,dwNbElemToWrite,bAccessWidth,pbWriteBuffer,pdwNbElementEffectWritten)	\
    (This)->lpVtbl -> WriteVirtualMemory(This,Address,dwNbElemToWrite,bAccessWidth,pbWriteBuffer,pdwNbElementEffectWritten)

#define IeXdiServer_ReadPhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToRead,bAccessWidth,pbReadBuffer)	\
    (This)->lpVtbl -> ReadPhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToRead,bAccessWidth,pbReadBuffer)

#define IeXdiServer_WritePhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToWrite,bAccessWidth,pbWriteBuffer)	\
    (This)->lpVtbl -> WritePhysicalMemoryOrPeriphIO(This,Address,bAddressSpace,dwNbElemToWrite,bAccessWidth,pbWriteBuffer)

#define IeXdiServer_StartNotifyingMemChg(This,pieXdiClientNotifyMemChg,pdwConnectionCookie)	\
    (This)->lpVtbl -> StartNotifyingMemChg(This,pieXdiClientNotifyMemChg,pdwConnectionCookie)

#define IeXdiServer_StopNotifyingMemChg(This,dwConnectionCookie)	\
    (This)->lpVtbl -> StopNotifyingMemChg(This,dwConnectionCookie)

#define IeXdiServer_Ioctl(This,dwBuffInSize,pbBufferIn,dwBuffOutSize,pdwEffectBuffOutSize,pbBufferOut)	\
    (This)->lpVtbl -> Ioctl(This,dwBuffInSize,pbBufferIn,dwBuffOutSize,pdwEffectBuffOutSize,pbBufferOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiServer_GetTargetInfo_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ PGLOBAL_TARGET_INFO_STRUCT pgti);


void __RPC_STUB IeXdiServer_GetTargetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_SetDebugMode_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ DWORD dwModeBitField);


void __RPC_STUB IeXdiServer_SetDebugMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetExceptionDescriptionList_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ DWORD dwNbElementToReturn,
    /* [size_is][out] */ EXCEPTION_DESCRIPTION_TYPE __RPC_FAR *pedTable,
    /* [out] */ DWORD __RPC_FAR *pdwNbTotalExceptionInList);


void __RPC_STUB IeXdiServer_GetExceptionDescriptionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetErrorDescription_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ HRESULT ErrorCode,
    /* [out] */ LPOLESTR __RPC_FAR *pszErrorDesc);


void __RPC_STUB IeXdiServer_GetErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_SetWaitOnConcurentUse_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ BOOL fNewWaitOnConcurentUseFlag);


void __RPC_STUB IeXdiServer_SetWaitOnConcurentUse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetRunStatus_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ PRUN_STATUS_TYPE persCurrent,
    /* [out] */ PHALT_REASON_TYPE pehrCurrent,
    /* [out] */ ADDRESS_TYPE __RPC_FAR *pCurrentExecAddress,
    /* [out] */ DWORD __RPC_FAR *pdwExceptionCode);


void __RPC_STUB IeXdiServer_GetRunStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetLastException_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ PEXCEPTION_TYPE pexLast);


void __RPC_STUB IeXdiServer_GetLastException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Run_Proxy( 
    IeXdiServer __RPC_FAR * This);


void __RPC_STUB IeXdiServer_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Halt_Proxy( 
    IeXdiServer __RPC_FAR * This);


void __RPC_STUB IeXdiServer_Halt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DoSingleStep_Proxy( 
    IeXdiServer __RPC_FAR * This);


void __RPC_STUB IeXdiServer_DoSingleStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DoMultipleStep_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ DWORD dwNbInstructions);


void __RPC_STUB IeXdiServer_DoMultipleStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DoRangeStep_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE FirstAddress,
    /* [in] */ ADDRESS_TYPE LastAddress);


void __RPC_STUB IeXdiServer_DoRangeStep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Reboot_Proxy( 
    IeXdiServer __RPC_FAR * This);


void __RPC_STUB IeXdiServer_Reboot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetBpSupport_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ PBREAKPOINT_SUPPORT_TYPE pbps);


void __RPC_STUB IeXdiServer_GetBpSupport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetNbCodeBpAvail_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwNbHwCodeBpAvail,
    /* [out] */ DWORD __RPC_FAR *pdwNbSwCodeBpAvail);


void __RPC_STUB IeXdiServer_GetNbCodeBpAvail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_GetNbDataBpAvail_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwNbDataBpAvail);


void __RPC_STUB IeXdiServer_GetNbDataBpAvail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_AddCodeBreakpoint_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ CBP_KIND cbpk,
    /* [in] */ MEM_TYPE mt,
    /* [in] */ DWORD dwExecMode,
    /* [in] */ DWORD dwTotalBypassCount,
    /* [out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiCodeBreakpoint);


void __RPC_STUB IeXdiServer_AddCodeBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DelCodeBreakpoint_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ IeXdiCodeBreakpoint __RPC_FAR *pieXdiCodeBreakpoint);


void __RPC_STUB IeXdiServer_DelCodeBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_AddDataBreakpoint_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ ADDRESS_TYPE AddressMask,
    /* [in] */ DWORD dwData,
    /* [in] */ DWORD dwDataMask,
    /* [in] */ BYTE bAccessWidth,
    /* [in] */ MEM_TYPE mt,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DATA_ACCESS_TYPE da,
    /* [in] */ DWORD dwTotalBypassCount,
    /* [out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiDataBreakpoint);


void __RPC_STUB IeXdiServer_AddDataBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_DelDataBreakpoint_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ IeXdiDataBreakpoint __RPC_FAR *pieXdiDataBreakpoint);


void __RPC_STUB IeXdiServer_DelDataBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumAllCodeBreakpoints_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ IeXdiEnumCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumCodeBreakpoint);


void __RPC_STUB IeXdiServer_EnumAllCodeBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumAllDataBreakpoints_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [out] */ IeXdiEnumDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumDataBreakpoint);


void __RPC_STUB IeXdiServer_EnumAllDataBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumCodeBreakpointsInAddrRange_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE FirstAddress,
    /* [in] */ ADDRESS_TYPE LastAddress,
    /* [out] */ IeXdiEnumCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumCodeBreakpoint);


void __RPC_STUB IeXdiServer_EnumCodeBreakpointsInAddrRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_EnumDataBreakpointsInAddrRange_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE FirstAddress,
    /* [in] */ ADDRESS_TYPE LastAddress,
    /* [out] */ IeXdiEnumDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiEnumDataBreakpoint);


void __RPC_STUB IeXdiServer_EnumDataBreakpointsInAddrRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StartNotifyingRunChg_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ IeXdiClientNotifyRunChg __RPC_FAR *pieXdiClientNotifyRunChg,
    /* [out] */ DWORD __RPC_FAR *pdwConnectionCookie);


void __RPC_STUB IeXdiServer_StartNotifyingRunChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StopNotifyingRunChg_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ DWORD dwConnectionCookie);


void __RPC_STUB IeXdiServer_StopNotifyingRunChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_ReadVirtualMemory_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ DWORD dwNbElemToRead,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][out] */ BYTE __RPC_FAR *pbReadBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwNbElementEffectRead);


void __RPC_STUB IeXdiServer_ReadVirtualMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_WriteVirtualMemory_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ DWORD dwNbElemToWrite,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][in] */ const BYTE __RPC_FAR *pbWriteBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwNbElementEffectWritten);


void __RPC_STUB IeXdiServer_WriteVirtualMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_ReadPhysicalMemoryOrPeriphIO_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DWORD dwNbElemToRead,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][out] */ BYTE __RPC_FAR *pbReadBuffer);


void __RPC_STUB IeXdiServer_ReadPhysicalMemoryOrPeriphIO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_WritePhysicalMemoryOrPeriphIO_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DWORD dwNbElemToWrite,
    /* [in] */ BYTE bAccessWidth,
    /* [size_is][in] */ const BYTE __RPC_FAR *pbWriteBuffer);


void __RPC_STUB IeXdiServer_WritePhysicalMemoryOrPeriphIO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StartNotifyingMemChg_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ IeXdiClientNotifyMemChg __RPC_FAR *pieXdiClientNotifyMemChg,
    /* [out] */ DWORD __RPC_FAR *pdwConnectionCookie);


void __RPC_STUB IeXdiServer_StartNotifyingMemChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_StopNotifyingMemChg_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ DWORD dwConnectionCookie);


void __RPC_STUB IeXdiServer_StopNotifyingMemChg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiServer_Ioctl_Proxy( 
    IeXdiServer __RPC_FAR * This,
    /* [in] */ DWORD dwBuffInSize,
    /* [size_is][in] */ const BYTE __RPC_FAR *pbBufferIn,
    /* [in] */ DWORD dwBuffOutSize,
    /* [out] */ DWORD __RPC_FAR *pdwEffectBuffOutSize,
    /* [length_is][size_is][out] */ BYTE __RPC_FAR *pbBufferOut);


void __RPC_STUB IeXdiServer_Ioctl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiServer_INTERFACE_DEFINED__ */


#ifndef __IeXdiCodeBreakpoint_INTERFACE_DEFINED__
#define __IeXdiCodeBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiCodeBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiCodeBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495342507401")
    IeXdiCodeBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PCBP_KIND pcbpk,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ DWORD __RPC_FAR *pdwExecMode,
            /* [out] */ DWORD __RPC_FAR *pdwTotalBypassCount,
            /* [out] */ DWORD __RPC_FAR *pdwBypassedOccurences,
            /* [out] */ BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiCodeBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiCodeBreakpoint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiCodeBreakpoint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiCodeBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IeXdiCodeBreakpoint __RPC_FAR * This,
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PCBP_KIND pcbpk,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ DWORD __RPC_FAR *pdwExecMode,
            /* [out] */ DWORD __RPC_FAR *pdwTotalBypassCount,
            /* [out] */ DWORD __RPC_FAR *pdwBypassedOccurences,
            /* [out] */ BOOL __RPC_FAR *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState )( 
            IeXdiCodeBreakpoint __RPC_FAR * This,
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences);
        
        END_INTERFACE
    } IeXdiCodeBreakpointVtbl;

    interface IeXdiCodeBreakpoint
    {
        CONST_VTBL struct IeXdiCodeBreakpointVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiCodeBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiCodeBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiCodeBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiCodeBreakpoint_GetAttributes(This,pAddress,pcbpk,pmt,pdwExecMode,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)	\
    (This)->lpVtbl -> GetAttributes(This,pAddress,pcbpk,pmt,pdwExecMode,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)

#define IeXdiCodeBreakpoint_SetState(This,fEnabled,fResetBypassedOccurences)	\
    (This)->lpVtbl -> SetState(This,fEnabled,fResetBypassedOccurences)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiCodeBreakpoint_GetAttributes_Proxy( 
    IeXdiCodeBreakpoint __RPC_FAR * This,
    /* [out] */ PADDRESS_TYPE pAddress,
    /* [out] */ PCBP_KIND pcbpk,
    /* [out] */ PMEM_TYPE pmt,
    /* [out] */ DWORD __RPC_FAR *pdwExecMode,
    /* [out] */ DWORD __RPC_FAR *pdwTotalBypassCount,
    /* [out] */ DWORD __RPC_FAR *pdwBypassedOccurences,
    /* [out] */ BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IeXdiCodeBreakpoint_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiCodeBreakpoint_SetState_Proxy( 
    IeXdiCodeBreakpoint __RPC_FAR * This,
    /* [in] */ BOOL fEnabled,
    /* [in] */ BOOL fResetBypassedOccurences);


void __RPC_STUB IeXdiCodeBreakpoint_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiCodeBreakpoint_INTERFACE_DEFINED__ */


#ifndef __IeXdiDataBreakpoint_INTERFACE_DEFINED__
#define __IeXdiDataBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiDataBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiDataBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495357507400")
    IeXdiDataBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PADDRESS_TYPE pAddressMask,
            /* [out] */ DWORD __RPC_FAR *pdwData,
            /* [out] */ DWORD __RPC_FAR *pdwDataMask,
            /* [out] */ BYTE __RPC_FAR *pbAccessWidth,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ BYTE __RPC_FAR *pbAddressSpace,
            /* [out] */ PDATA_ACCESS_TYPE pda,
            /* [out] */ DWORD __RPC_FAR *pdwTotalBypassCount,
            /* [out] */ DWORD __RPC_FAR *pdwBypassedOccurences,
            /* [out] */ BOOL __RPC_FAR *pfEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiDataBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiDataBreakpoint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiDataBreakpoint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiDataBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes )( 
            IeXdiDataBreakpoint __RPC_FAR * This,
            /* [out] */ PADDRESS_TYPE pAddress,
            /* [out] */ PADDRESS_TYPE pAddressMask,
            /* [out] */ DWORD __RPC_FAR *pdwData,
            /* [out] */ DWORD __RPC_FAR *pdwDataMask,
            /* [out] */ BYTE __RPC_FAR *pbAccessWidth,
            /* [out] */ PMEM_TYPE pmt,
            /* [out] */ BYTE __RPC_FAR *pbAddressSpace,
            /* [out] */ PDATA_ACCESS_TYPE pda,
            /* [out] */ DWORD __RPC_FAR *pdwTotalBypassCount,
            /* [out] */ DWORD __RPC_FAR *pdwBypassedOccurences,
            /* [out] */ BOOL __RPC_FAR *pfEnabled);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState )( 
            IeXdiDataBreakpoint __RPC_FAR * This,
            /* [in] */ BOOL fEnabled,
            /* [in] */ BOOL fResetBypassedOccurences);
        
        END_INTERFACE
    } IeXdiDataBreakpointVtbl;

    interface IeXdiDataBreakpoint
    {
        CONST_VTBL struct IeXdiDataBreakpointVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiDataBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiDataBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiDataBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiDataBreakpoint_GetAttributes(This,pAddress,pAddressMask,pdwData,pdwDataMask,pbAccessWidth,pmt,pbAddressSpace,pda,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)	\
    (This)->lpVtbl -> GetAttributes(This,pAddress,pAddressMask,pdwData,pdwDataMask,pbAccessWidth,pmt,pbAddressSpace,pda,pdwTotalBypassCount,pdwBypassedOccurences,pfEnabled)

#define IeXdiDataBreakpoint_SetState(This,fEnabled,fResetBypassedOccurences)	\
    (This)->lpVtbl -> SetState(This,fEnabled,fResetBypassedOccurences)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiDataBreakpoint_GetAttributes_Proxy( 
    IeXdiDataBreakpoint __RPC_FAR * This,
    /* [out] */ PADDRESS_TYPE pAddress,
    /* [out] */ PADDRESS_TYPE pAddressMask,
    /* [out] */ DWORD __RPC_FAR *pdwData,
    /* [out] */ DWORD __RPC_FAR *pdwDataMask,
    /* [out] */ BYTE __RPC_FAR *pbAccessWidth,
    /* [out] */ PMEM_TYPE pmt,
    /* [out] */ BYTE __RPC_FAR *pbAddressSpace,
    /* [out] */ PDATA_ACCESS_TYPE pda,
    /* [out] */ DWORD __RPC_FAR *pdwTotalBypassCount,
    /* [out] */ DWORD __RPC_FAR *pdwBypassedOccurences,
    /* [out] */ BOOL __RPC_FAR *pfEnabled);


void __RPC_STUB IeXdiDataBreakpoint_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiDataBreakpoint_SetState_Proxy( 
    IeXdiDataBreakpoint __RPC_FAR * This,
    /* [in] */ BOOL fEnabled,
    /* [in] */ BOOL fResetBypassedOccurences);


void __RPC_STUB IeXdiDataBreakpoint_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiDataBreakpoint_INTERFACE_DEFINED__ */


#ifndef __IeXdiEnumCodeBreakpoint_INTERFACE_DEFINED__
#define __IeXdiEnumCodeBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiEnumCodeBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiEnumCodeBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495345425074")
    IeXdiEnumCodeBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR apieXdiCodeBreakpoint[  ],
            /* [out] */ DWORD __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ DWORD celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ DWORD __RPC_FAR *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiCodeBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiEnumCodeBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR apieXdiCodeBreakpoint[  ],
            /* [out] */ DWORD __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This,
            /* [in] */ DWORD celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This,
            /* [out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiCodeBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableAll )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableAll )( 
            IeXdiEnumCodeBreakpoint __RPC_FAR * This);
        
        END_INTERFACE
    } IeXdiEnumCodeBreakpointVtbl;

    interface IeXdiEnumCodeBreakpoint
    {
        CONST_VTBL struct IeXdiEnumCodeBreakpointVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiEnumCodeBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiEnumCodeBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiEnumCodeBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiEnumCodeBreakpoint_Next(This,celt,apieXdiCodeBreakpoint,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,apieXdiCodeBreakpoint,pceltFetched)

#define IeXdiEnumCodeBreakpoint_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IeXdiEnumCodeBreakpoint_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IeXdiEnumCodeBreakpoint_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#define IeXdiEnumCodeBreakpoint_GetNext(This,ppieXdiCodeBreakpoint)	\
    (This)->lpVtbl -> GetNext(This,ppieXdiCodeBreakpoint)

#define IeXdiEnumCodeBreakpoint_DisableAll(This)	\
    (This)->lpVtbl -> DisableAll(This)

#define IeXdiEnumCodeBreakpoint_EnableAll(This)	\
    (This)->lpVtbl -> EnableAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_Next_Proxy( 
    IeXdiEnumCodeBreakpoint __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [length_is][size_is][out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR apieXdiCodeBreakpoint[  ],
    /* [out] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IeXdiEnumCodeBreakpoint_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_Skip_Proxy( 
    IeXdiEnumCodeBreakpoint __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IeXdiEnumCodeBreakpoint_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_Reset_Proxy( 
    IeXdiEnumCodeBreakpoint __RPC_FAR * This);


void __RPC_STUB IeXdiEnumCodeBreakpoint_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_GetCount_Proxy( 
    IeXdiEnumCodeBreakpoint __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcelt);


void __RPC_STUB IeXdiEnumCodeBreakpoint_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_GetNext_Proxy( 
    IeXdiEnumCodeBreakpoint __RPC_FAR * This,
    /* [out] */ IeXdiCodeBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiCodeBreakpoint);


void __RPC_STUB IeXdiEnumCodeBreakpoint_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_DisableAll_Proxy( 
    IeXdiEnumCodeBreakpoint __RPC_FAR * This);


void __RPC_STUB IeXdiEnumCodeBreakpoint_DisableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumCodeBreakpoint_EnableAll_Proxy( 
    IeXdiEnumCodeBreakpoint __RPC_FAR * This);


void __RPC_STUB IeXdiEnumCodeBreakpoint_EnableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiEnumCodeBreakpoint_INTERFACE_DEFINED__ */


#ifndef __IeXdiEnumDataBreakpoint_INTERFACE_DEFINED__
#define __IeXdiEnumDataBreakpoint_INTERFACE_DEFINED__

/* interface IeXdiEnumDataBreakpoint */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiEnumDataBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495345575074")
    IeXdiEnumDataBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR apieXdiDataBreakpoint[  ],
            /* [out] */ DWORD __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ DWORD celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ DWORD __RPC_FAR *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiDataBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableAll( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableAll( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiEnumDataBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [length_is][size_is][out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR apieXdiDataBreakpoint[  ],
            /* [out] */ DWORD __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This,
            /* [in] */ DWORD celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNext )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This,
            /* [out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiDataBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisableAll )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableAll )( 
            IeXdiEnumDataBreakpoint __RPC_FAR * This);
        
        END_INTERFACE
    } IeXdiEnumDataBreakpointVtbl;

    interface IeXdiEnumDataBreakpoint
    {
        CONST_VTBL struct IeXdiEnumDataBreakpointVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiEnumDataBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiEnumDataBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiEnumDataBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiEnumDataBreakpoint_Next(This,celt,apieXdiDataBreakpoint,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,apieXdiDataBreakpoint,pceltFetched)

#define IeXdiEnumDataBreakpoint_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IeXdiEnumDataBreakpoint_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IeXdiEnumDataBreakpoint_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#define IeXdiEnumDataBreakpoint_GetNext(This,ppieXdiDataBreakpoint)	\
    (This)->lpVtbl -> GetNext(This,ppieXdiDataBreakpoint)

#define IeXdiEnumDataBreakpoint_DisableAll(This)	\
    (This)->lpVtbl -> DisableAll(This)

#define IeXdiEnumDataBreakpoint_EnableAll(This)	\
    (This)->lpVtbl -> EnableAll(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_Next_Proxy( 
    IeXdiEnumDataBreakpoint __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [length_is][size_is][out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR apieXdiDataBreakpoint[  ],
    /* [out] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IeXdiEnumDataBreakpoint_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_Skip_Proxy( 
    IeXdiEnumDataBreakpoint __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IeXdiEnumDataBreakpoint_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_Reset_Proxy( 
    IeXdiEnumDataBreakpoint __RPC_FAR * This);


void __RPC_STUB IeXdiEnumDataBreakpoint_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_GetCount_Proxy( 
    IeXdiEnumDataBreakpoint __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pcelt);


void __RPC_STUB IeXdiEnumDataBreakpoint_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_GetNext_Proxy( 
    IeXdiEnumDataBreakpoint __RPC_FAR * This,
    /* [out] */ IeXdiDataBreakpoint __RPC_FAR *__RPC_FAR *ppieXdiDataBreakpoint);


void __RPC_STUB IeXdiEnumDataBreakpoint_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_DisableAll_Proxy( 
    IeXdiEnumDataBreakpoint __RPC_FAR * This);


void __RPC_STUB IeXdiEnumDataBreakpoint_DisableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiEnumDataBreakpoint_EnableAll_Proxy( 
    IeXdiEnumDataBreakpoint __RPC_FAR * This);


void __RPC_STUB IeXdiEnumDataBreakpoint_EnableAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiEnumDataBreakpoint_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0250 */
/* [local] */ 

#define	SIZE_OF_80387_REGISTERS_IN_BYTES	( 80 )

typedef struct _CONTEXT_X86
    {
    struct 
        {
        BOOL fSegmentRegs;
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    DWORD SegCs;
    DWORD SegSs;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD EFlags;
    DWORD Ebp;
    DWORD Eip;
    DWORD Esp;
    DWORD Eax;
    DWORD Ebx;
    DWORD Ecx;
    DWORD Edx;
    DWORD Esi;
    DWORD Edi;
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[ 80 ];
    DWORD Cr0NpxState;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;
    } 	CONTEXT_X86;

typedef struct _CONTEXT_X86 __RPC_FAR *PCONTEXT_X86;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0250_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0250_v0_0_s_ifspec;

#ifndef __IeXdiX86Context_INTERFACE_DEFINED__
#define __IeXdiX86Context_INTERFACE_DEFINED__

/* interface IeXdiX86Context */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiX86Context;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495358383643")
    IeXdiX86Context : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_X86 pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_X86 Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiX86ContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiX86Context __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiX86Context __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiX86Context __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IeXdiX86Context __RPC_FAR * This,
            /* [out][in] */ PCONTEXT_X86 pContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContext )( 
            IeXdiX86Context __RPC_FAR * This,
            /* [in] */ CONTEXT_X86 Context);
        
        END_INTERFACE
    } IeXdiX86ContextVtbl;

    interface IeXdiX86Context
    {
        CONST_VTBL struct IeXdiX86ContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiX86Context_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiX86Context_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiX86Context_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiX86Context_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiX86Context_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiX86Context_GetContext_Proxy( 
    IeXdiX86Context __RPC_FAR * This,
    /* [out][in] */ PCONTEXT_X86 pContext);


void __RPC_STUB IeXdiX86Context_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiX86Context_SetContext_Proxy( 
    IeXdiX86Context __RPC_FAR * This,
    /* [in] */ CONTEXT_X86 Context);


void __RPC_STUB IeXdiX86Context_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiX86Context_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0251 */
/* [local] */ 

typedef struct _CONTEXT_SHX
    {
    struct 
        {
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    DWORD Pr;
    DWORD Mach;
    DWORD Macl;
    DWORD Gbr;
    DWORD Pc;
    DWORD Sr;
    DWORD R0;
    DWORD R1;
    DWORD R2;
    DWORD R3;
    DWORD R4;
    DWORD R5;
    DWORD R6;
    DWORD R7;
    DWORD R8;
    DWORD R9;
    DWORD R10;
    DWORD R11;
    DWORD R12;
    DWORD R13;
    DWORD R14;
    DWORD R15;
    DWORD Fpscr;
    DWORD Fpul;
    DWORD FR_B0[ 16 ];
    DWORD FR_B1[ 16 ];
    DWORD BarA;
    BYTE BasrA;
    BYTE BamrA;
    WORD BbrA;
    DWORD BarB;
    BYTE BasrB;
    BYTE BamrB;
    WORD BbrB;
    DWORD BdrB;
    DWORD BdmrB;
    WORD Brcr;
    WORD Align;
    } 	CONTEXT_SHX;

typedef struct _CONTEXT_SHX __RPC_FAR *PCONTEXT_SHX;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0251_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0251_v0_0_s_ifspec;

#ifndef __IeXdiSHXContext_INTERFACE_DEFINED__
#define __IeXdiSHXContext_INTERFACE_DEFINED__

/* interface IeXdiSHXContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiSHXContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495353475843")
    IeXdiSHXContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_SHX pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_SHX Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiSHXContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiSHXContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiSHXContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiSHXContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IeXdiSHXContext __RPC_FAR * This,
            /* [out][in] */ PCONTEXT_SHX pContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContext )( 
            IeXdiSHXContext __RPC_FAR * This,
            /* [in] */ CONTEXT_SHX Context);
        
        END_INTERFACE
    } IeXdiSHXContextVtbl;

    interface IeXdiSHXContext
    {
        CONST_VTBL struct IeXdiSHXContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiSHXContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiSHXContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiSHXContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiSHXContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiSHXContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiSHXContext_GetContext_Proxy( 
    IeXdiSHXContext __RPC_FAR * This,
    /* [out][in] */ PCONTEXT_SHX pContext);


void __RPC_STUB IeXdiSHXContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiSHXContext_SetContext_Proxy( 
    IeXdiSHXContext __RPC_FAR * This,
    /* [in] */ CONTEXT_SHX Context);


void __RPC_STUB IeXdiSHXContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiSHXContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0252 */
/* [local] */ 

typedef struct _CONTEXT_MIPS
    {
    struct 
        {
        BOOL fMode64bits;
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fExceptRegs;
        BOOL fMemoryMgmRegs;
        } 	RegGroupSelection;
    DWORD IntAt;
    DWORD Hi32_IntAt;
    DWORD IntV0;
    DWORD Hi32_IntV0;
    DWORD IntV1;
    DWORD Hi32_IntV1;
    DWORD IntA0;
    DWORD Hi32_IntA0;
    DWORD IntA1;
    DWORD Hi32_IntA1;
    DWORD IntA2;
    DWORD Hi32_IntA2;
    DWORD IntA3;
    DWORD Hi32_IntA3;
    DWORD IntT0;
    DWORD Hi32_IntT0;
    DWORD IntT1;
    DWORD Hi32_IntT1;
    DWORD IntT2;
    DWORD Hi32_IntT2;
    DWORD IntT3;
    DWORD Hi32_IntT3;
    DWORD IntT4;
    DWORD Hi32_IntT4;
    DWORD IntT5;
    DWORD Hi32_IntT5;
    DWORD IntT6;
    DWORD Hi32_IntT6;
    DWORD IntT7;
    DWORD Hi32_IntT7;
    DWORD IntS0;
    DWORD Hi32_IntS0;
    DWORD IntS1;
    DWORD Hi32_IntS1;
    DWORD IntS2;
    DWORD Hi32_IntS2;
    DWORD IntS3;
    DWORD Hi32_IntS3;
    DWORD IntS4;
    DWORD Hi32_IntS4;
    DWORD IntS5;
    DWORD Hi32_IntS5;
    DWORD IntS6;
    DWORD Hi32_IntS6;
    DWORD IntS7;
    DWORD Hi32_IntS7;
    DWORD IntT8;
    DWORD Hi32_IntT8;
    DWORD IntT9;
    DWORD Hi32_IntT9;
    DWORD IntK0;
    DWORD Hi32_IntK0;
    DWORD IntK1;
    DWORD Hi32_IntK1;
    DWORD IntGp;
    DWORD Hi32_IntGp;
    DWORD IntSp;
    DWORD Hi32_IntSp;
    DWORD IntS8;
    DWORD Hi32_IntS8;
    DWORD IntRa;
    DWORD Hi32_IntRa;
    DWORD IntLo;
    DWORD Hi32_IntLo;
    DWORD IntHi;
    DWORD Hi32_IntHi;
    DWORD FltF0;
    DWORD Hi32_FltF0;
    DWORD FltF1;
    DWORD Hi32_FltF1;
    DWORD FltF2;
    DWORD Hi32_FltF2;
    DWORD FltF3;
    DWORD Hi32_FltF3;
    DWORD FltF4;
    DWORD Hi32_FltF4;
    DWORD FltF5;
    DWORD Hi32_FltF5;
    DWORD FltF6;
    DWORD Hi32_FltF6;
    DWORD FltF7;
    DWORD Hi32_FltF7;
    DWORD FltF8;
    DWORD Hi32_FltF8;
    DWORD FltF9;
    DWORD Hi32_FltF9;
    DWORD FltF10;
    DWORD Hi32_FltF10;
    DWORD FltF11;
    DWORD Hi32_FltF11;
    DWORD FltF12;
    DWORD Hi32_FltF12;
    DWORD FltF13;
    DWORD Hi32_FltF13;
    DWORD FltF14;
    DWORD Hi32_FltF14;
    DWORD FltF15;
    DWORD Hi32_FltF15;
    DWORD FltF16;
    DWORD Hi32_FltF16;
    DWORD FltF17;
    DWORD Hi32_FltF17;
    DWORD FltF18;
    DWORD Hi32_FltF18;
    DWORD FltF19;
    DWORD Hi32_FltF19;
    DWORD FltF20;
    DWORD Hi32_FltF20;
    DWORD FltF21;
    DWORD Hi32_FltF21;
    DWORD FltF22;
    DWORD Hi32_FltF22;
    DWORD FltF23;
    DWORD Hi32_FltF23;
    DWORD FltF24;
    DWORD Hi32_FltF24;
    DWORD FltF25;
    DWORD Hi32_FltF25;
    DWORD FltF26;
    DWORD Hi32_FltF26;
    DWORD FltF27;
    DWORD Hi32_FltF27;
    DWORD FltF28;
    DWORD Hi32_FltF28;
    DWORD FltF29;
    DWORD Hi32_FltF29;
    DWORD FltF30;
    DWORD Hi32_FltF30;
    DWORD FltF31;
    DWORD Hi32_FltF31;
    DWORD FCR0;
    DWORD FCR31;
    DWORD Pc;
    DWORD Hi32_Pc;
    DWORD Context;
    DWORD Hi32_Context;
    DWORD BadVAddr;
    DWORD Hi32_BadVAddr;
    DWORD EPC;
    DWORD Hi32_EPC;
    DWORD XContextReg;
    DWORD Hi32_XContextReg;
    DWORD ErrorEPC;
    DWORD Hi32_ErrorEPC;
    DWORD Count;
    DWORD Compare;
    DWORD Sr;
    DWORD Cause;
    DWORD WatchLo;
    DWORD WatchHi;
    DWORD ECC;
    DWORD CacheErr;
    DWORD Index;
    DWORD Random;
    DWORD EntryLo0;
    DWORD Hi32_EntryLo0;
    DWORD EntryLo1;
    DWORD Hi32_EntryLo1;
    DWORD PageMask;
    DWORD Wired;
    DWORD EntryHi;
    DWORD Hi32_EntryHi;
    DWORD PRId;
    DWORD Config;
    DWORD LLAddr;
    DWORD TagLo;
    DWORD TagHi;
    } 	CONTEXT_MIPS;

typedef struct _CONTEXT_MIPS __RPC_FAR *PCONTEXT_MIPS;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0252_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0252_v0_0_s_ifspec;

#ifndef __IeXdiMIPSContext_INTERFACE_DEFINED__
#define __IeXdiMIPSContext_INTERFACE_DEFINED__

/* interface IeXdiMIPSContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiMIPSContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-49534D495043")
    IeXdiMIPSContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_MIPS pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_MIPS Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiMIPSContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiMIPSContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiMIPSContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiMIPSContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IeXdiMIPSContext __RPC_FAR * This,
            /* [out][in] */ PCONTEXT_MIPS pContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContext )( 
            IeXdiMIPSContext __RPC_FAR * This,
            /* [in] */ CONTEXT_MIPS Context);
        
        END_INTERFACE
    } IeXdiMIPSContextVtbl;

    interface IeXdiMIPSContext
    {
        CONST_VTBL struct IeXdiMIPSContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiMIPSContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiMIPSContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiMIPSContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiMIPSContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiMIPSContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiMIPSContext_GetContext_Proxy( 
    IeXdiMIPSContext __RPC_FAR * This,
    /* [out][in] */ PCONTEXT_MIPS pContext);


void __RPC_STUB IeXdiMIPSContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiMIPSContext_SetContext_Proxy( 
    IeXdiMIPSContext __RPC_FAR * This,
    /* [in] */ CONTEXT_MIPS Context);


void __RPC_STUB IeXdiMIPSContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiMIPSContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0253 */
/* [local] */ 

typedef struct _CONTEXT_ARM
    {
    struct 
        {
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    DWORD Sp;
    DWORD Lr;
    DWORD Pc;
    DWORD Psr;
    DWORD R0;
    DWORD R1;
    DWORD R2;
    DWORD R3;
    DWORD R4;
    DWORD R5;
    DWORD R6;
    DWORD R7;
    DWORD R8;
    DWORD R9;
    DWORD R10;
    DWORD R11;
    DWORD R12;
    } 	CONTEXT_ARM;

typedef struct _CONTEXT_ARM __RPC_FAR *PCONTEXT_ARM;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0253_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0253_v0_0_s_ifspec;

#ifndef __IeXdiARMContext_INTERFACE_DEFINED__
#define __IeXdiARMContext_INTERFACE_DEFINED__

/* interface IeXdiARMContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiARMContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495341524D43")
    IeXdiARMContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_ARM pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_ARM Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiARMContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiARMContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiARMContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiARMContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IeXdiARMContext __RPC_FAR * This,
            /* [out][in] */ PCONTEXT_ARM pContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContext )( 
            IeXdiARMContext __RPC_FAR * This,
            /* [in] */ CONTEXT_ARM Context);
        
        END_INTERFACE
    } IeXdiARMContextVtbl;

    interface IeXdiARMContext
    {
        CONST_VTBL struct IeXdiARMContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiARMContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiARMContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiARMContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiARMContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiARMContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiARMContext_GetContext_Proxy( 
    IeXdiARMContext __RPC_FAR * This,
    /* [out][in] */ PCONTEXT_ARM pContext);


void __RPC_STUB IeXdiARMContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiARMContext_SetContext_Proxy( 
    IeXdiARMContext __RPC_FAR * This,
    /* [in] */ CONTEXT_ARM Context);


void __RPC_STUB IeXdiARMContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiARMContext_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_exdi_0254 */
/* [local] */ 

typedef struct _CONTEXT_PPC
    {
    struct 
        {
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        } 	RegGroupSelection;
    double Fpr0;
    double Fpr1;
    double Fpr2;
    double Fpr3;
    double Fpr4;
    double Fpr5;
    double Fpr6;
    double Fpr7;
    double Fpr8;
    double Fpr9;
    double Fpr10;
    double Fpr11;
    double Fpr12;
    double Fpr13;
    double Fpr14;
    double Fpr15;
    double Fpr16;
    double Fpr17;
    double Fpr18;
    double Fpr19;
    double Fpr20;
    double Fpr21;
    double Fpr22;
    double Fpr23;
    double Fpr24;
    double Fpr25;
    double Fpr26;
    double Fpr27;
    double Fpr28;
    double Fpr29;
    double Fpr30;
    double Fpr31;
    double Fpscr;
    DWORD Gpr0;
    DWORD Gpr1;
    DWORD Gpr2;
    DWORD Gpr3;
    DWORD Gpr4;
    DWORD Gpr5;
    DWORD Gpr6;
    DWORD Gpr7;
    DWORD Gpr8;
    DWORD Gpr9;
    DWORD Gpr10;
    DWORD Gpr11;
    DWORD Gpr12;
    DWORD Gpr13;
    DWORD Gpr14;
    DWORD Gpr15;
    DWORD Gpr16;
    DWORD Gpr17;
    DWORD Gpr18;
    DWORD Gpr19;
    DWORD Gpr20;
    DWORD Gpr21;
    DWORD Gpr22;
    DWORD Gpr23;
    DWORD Gpr24;
    DWORD Gpr25;
    DWORD Gpr26;
    DWORD Gpr27;
    DWORD Gpr28;
    DWORD Gpr29;
    DWORD Gpr30;
    DWORD Gpr31;
    DWORD Msr;
    DWORD Iar;
    DWORD Lr;
    DWORD Ctr;
    DWORD Cr;
    DWORD Xer;
    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr4;
    DWORD Dr5;
    DWORD Dr6;
    DWORD Dr7;
    } 	CONTEXT_PPC;

typedef struct _CONTEXT_PPC __RPC_FAR *PCONTEXT_PPC;



extern RPC_IF_HANDLE __MIDL_itf_exdi_0254_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_exdi_0254_v0_0_s_ifspec;

#ifndef __IeXdiPPCContext_INTERFACE_DEFINED__
#define __IeXdiPPCContext_INTERFACE_DEFINED__

/* interface IeXdiPPCContext */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiPPCContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-495350504343")
    IeXdiPPCContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_PPC pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_PPC Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiPPCContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiPPCContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiPPCContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiPPCContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IeXdiPPCContext __RPC_FAR * This,
            /* [out][in] */ PCONTEXT_PPC pContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContext )( 
            IeXdiPPCContext __RPC_FAR * This,
            /* [in] */ CONTEXT_PPC Context);
        
        END_INTERFACE
    } IeXdiPPCContextVtbl;

    interface IeXdiPPCContext
    {
        CONST_VTBL struct IeXdiPPCContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiPPCContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiPPCContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiPPCContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiPPCContext_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiPPCContext_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiPPCContext_GetContext_Proxy( 
    IeXdiPPCContext __RPC_FAR * This,
    /* [out][in] */ PCONTEXT_PPC pContext);


void __RPC_STUB IeXdiPPCContext_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiPPCContext_SetContext_Proxy( 
    IeXdiPPCContext __RPC_FAR * This,
    /* [in] */ CONTEXT_PPC Context);


void __RPC_STUB IeXdiPPCContext_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiPPCContext_INTERFACE_DEFINED__ */


#ifndef __IeXdiClientNotifyMemChg_INTERFACE_DEFINED__
#define __IeXdiClientNotifyMemChg_INTERFACE_DEFINED__

/* interface IeXdiClientNotifyMemChg */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiClientNotifyMemChg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-49434E4D4300")
    IeXdiClientNotifyMemChg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyMemoryChange( 
            /* [in] */ MEM_TYPE mtChanged,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemChanged,
            /* [in] */ BYTE bAccessWidth) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiClientNotifyMemChgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiClientNotifyMemChg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiClientNotifyMemChg __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiClientNotifyMemChg __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyMemoryChange )( 
            IeXdiClientNotifyMemChg __RPC_FAR * This,
            /* [in] */ MEM_TYPE mtChanged,
            /* [in] */ ADDRESS_TYPE Address,
            /* [in] */ BYTE bAddressSpace,
            /* [in] */ DWORD dwNbElemChanged,
            /* [in] */ BYTE bAccessWidth);
        
        END_INTERFACE
    } IeXdiClientNotifyMemChgVtbl;

    interface IeXdiClientNotifyMemChg
    {
        CONST_VTBL struct IeXdiClientNotifyMemChgVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiClientNotifyMemChg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiClientNotifyMemChg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiClientNotifyMemChg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiClientNotifyMemChg_NotifyMemoryChange(This,mtChanged,Address,bAddressSpace,dwNbElemChanged,bAccessWidth)	\
    (This)->lpVtbl -> NotifyMemoryChange(This,mtChanged,Address,bAddressSpace,dwNbElemChanged,bAccessWidth)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiClientNotifyMemChg_NotifyMemoryChange_Proxy( 
    IeXdiClientNotifyMemChg __RPC_FAR * This,
    /* [in] */ MEM_TYPE mtChanged,
    /* [in] */ ADDRESS_TYPE Address,
    /* [in] */ BYTE bAddressSpace,
    /* [in] */ DWORD dwNbElemChanged,
    /* [in] */ BYTE bAccessWidth);


void __RPC_STUB IeXdiClientNotifyMemChg_NotifyMemoryChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiClientNotifyMemChg_INTERFACE_DEFINED__ */


#ifndef __IeXdiClientNotifyRunChg_INTERFACE_DEFINED__
#define __IeXdiClientNotifyRunChg_INTERFACE_DEFINED__

/* interface IeXdiClientNotifyRunChg */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiClientNotifyRunChg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47486F67-6461-6C65-5844-49434E525343")
    IeXdiClientNotifyRunChg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyRunStateChange( 
            /* [in] */ RUN_STATUS_TYPE ersCurrent,
            /* [in] */ HALT_REASON_TYPE ehrCurrent,
            /* [in] */ ADDRESS_TYPE CurrentExecAddress,
            /* [in] */ DWORD dwExceptionCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiClientNotifyRunChgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiClientNotifyRunChg __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiClientNotifyRunChg __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiClientNotifyRunChg __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyRunStateChange )( 
            IeXdiClientNotifyRunChg __RPC_FAR * This,
            /* [in] */ RUN_STATUS_TYPE ersCurrent,
            /* [in] */ HALT_REASON_TYPE ehrCurrent,
            /* [in] */ ADDRESS_TYPE CurrentExecAddress,
            /* [in] */ DWORD dwExceptionCode);
        
        END_INTERFACE
    } IeXdiClientNotifyRunChgVtbl;

    interface IeXdiClientNotifyRunChg
    {
        CONST_VTBL struct IeXdiClientNotifyRunChgVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiClientNotifyRunChg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiClientNotifyRunChg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiClientNotifyRunChg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiClientNotifyRunChg_NotifyRunStateChange(This,ersCurrent,ehrCurrent,CurrentExecAddress,dwExceptionCode)	\
    (This)->lpVtbl -> NotifyRunStateChange(This,ersCurrent,ehrCurrent,CurrentExecAddress,dwExceptionCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiClientNotifyRunChg_NotifyRunStateChange_Proxy( 
    IeXdiClientNotifyRunChg __RPC_FAR * This,
    /* [in] */ RUN_STATUS_TYPE ersCurrent,
    /* [in] */ HALT_REASON_TYPE ehrCurrent,
    /* [in] */ ADDRESS_TYPE CurrentExecAddress,
    /* [in] */ DWORD dwExceptionCode);


void __RPC_STUB IeXdiClientNotifyRunChg_NotifyRunStateChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiClientNotifyRunChg_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exdi\exdi_x86_64.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0328 */
/* at Wed Jul 05 12:13:54 2000
 */
/* Compiler settings for x86_64.idl:
    Os (OptLev=s), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __x86_64_h__
#define __x86_64_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IeXdiX86_64Context_FWD_DEFINED__
#define __IeXdiX86_64Context_FWD_DEFINED__
typedef interface IeXdiX86_64Context IeXdiX86_64Context;
#endif 	/* __IeXdiX86_64Context_FWD_DEFINED__ */


/* header files for imported files */
#include "exdi.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_x86_64_0000 */
/* [local] */ 


// The following constants are bit definitions for the ModeFlags value in CONTEXT_X86_64.
// They are provided to allow debuggers to correctly disassemble instructions based on
// the current operating mode of the processor.
#define X86_64_MODE_D     (0x0001) // D bit from the current CS selector
#define X86_64_MODE_L     (0x0002) // L bit (long mode) from the current CS selector
#define X86_64_MODE_LME   (0x0004) // LME bit (lomg mode enable) from extended feature MSR
#define X86_64_MODE_REX   (0x0008) // REX bit (register extension) from extended feature MSR
typedef struct _SEG64_DESC_INFO
    {
    DWORD64 SegBase;
    DWORD64 SegLimit;
    DWORD SegFlags;
    } 	SEG64_DESC_INFO;

typedef struct _SSE_REG
    {
    DWORD Reg0;
    DWORD Reg1;
    DWORD Reg2;
    DWORD Reg3;
    } 	SSE_REG;

typedef struct _CONTEXT_X86_64
    {
    struct 
        {
        BOOL fSegmentRegs;
        BOOL fControlRegs;
        BOOL fIntegerRegs;
        BOOL fFloatingPointRegs;
        BOOL fDebugRegs;
        BOOL fSegmentDescriptors;
        BOOL fSSERegisters;
        BOOL fSystemRegisters;
        } 	RegGroupSelection;
    DWORD SegCs;
    DWORD SegSs;
    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;
    DWORD64 ModeFlags;
    DWORD64 EFlags;
    DWORD64 Rbp;
    DWORD64 Rip;
    DWORD64 Rsp;
    DWORD64 Rax;
    DWORD64 Rbx;
    DWORD64 Rcx;
    DWORD64 Rdx;
    DWORD64 Rsi;
    DWORD64 Rdi;
    DWORD64 R8;
    DWORD64 R9;
    DWORD64 R10;
    DWORD64 R11;
    DWORD64 R12;
    DWORD64 R13;
    DWORD64 R14;
    DWORD64 R15;
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[ 80 ];
    DWORD64 Dr0;
    DWORD64 Dr1;
    DWORD64 Dr2;
    DWORD64 Dr3;
    DWORD64 Dr6;
    DWORD64 Dr7;
    SEG64_DESC_INFO DescriptorCs;
    SEG64_DESC_INFO DescriptorSs;
    SEG64_DESC_INFO DescriptorGs;
    SEG64_DESC_INFO DescriptorFs;
    SEG64_DESC_INFO DescriptorEs;
    SEG64_DESC_INFO DescriptorDs;
    DWORD64 IDTBase;
    DWORD64 IDTLimit;
    DWORD64 GDTBase;
    DWORD64 GDTLimit;
    DWORD SelLDT;
    SEG64_DESC_INFO SegLDT;
    DWORD SelTSS;
    SEG64_DESC_INFO SegTSS;
    DWORD64 RegCr0;
    DWORD64 RegCr2;
    DWORD64 RegCr3;
    DWORD64 RegCr4;
    DWORD64 RegCr8;
    DWORD RegMXCSR;
    SSE_REG RegSSE[ 16 ];
    } 	CONTEXT_X86_64;

typedef struct _CONTEXT_X86_64 __RPC_FAR *PCONTEXT_X86_64;



extern RPC_IF_HANDLE __MIDL_itf_x86_64_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_x86_64_0000_v0_0_s_ifspec;

#ifndef __IeXdiX86_64Context_INTERFACE_DEFINED__
#define __IeXdiX86_64Context_INTERFACE_DEFINED__

/* interface IeXdiX86_64Context */
/* [ref][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IeXdiX86_64Context;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4795B125-6CDE-4e76-B8D3-D5ED69ECE739")
    IeXdiX86_64Context : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out][in] */ PCONTEXT_X86_64 pContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ CONTEXT_X86_64 Context) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IeXdiX86_64ContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IeXdiX86_64Context __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IeXdiX86_64Context __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IeXdiX86_64Context __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IeXdiX86_64Context __RPC_FAR * This,
            /* [out][in] */ PCONTEXT_X86_64 pContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContext )( 
            IeXdiX86_64Context __RPC_FAR * This,
            /* [in] */ CONTEXT_X86_64 Context);
        
        END_INTERFACE
    } IeXdiX86_64ContextVtbl;

    interface IeXdiX86_64Context
    {
        CONST_VTBL struct IeXdiX86_64ContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IeXdiX86_64Context_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IeXdiX86_64Context_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IeXdiX86_64Context_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IeXdiX86_64Context_GetContext(This,pContext)	\
    (This)->lpVtbl -> GetContext(This,pContext)

#define IeXdiX86_64Context_SetContext(This,Context)	\
    (This)->lpVtbl -> SetContext(This,Context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IeXdiX86_64Context_GetContext_Proxy( 
    IeXdiX86_64Context __RPC_FAR * This,
    /* [out][in] */ PCONTEXT_X86_64 pContext);


void __RPC_STUB IeXdiX86_64Context_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IeXdiX86_64Context_SetContext_Proxy( 
    IeXdiX86_64Context __RPC_FAR * This,
    /* [in] */ CONTEXT_X86_64 Context);


void __RPC_STUB IeXdiX86_64Context_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IeXdiX86_64Context_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\eng\engexts\engexts.cpp ===
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#define DEBUG_NO_IMPLEMENTATION
#include <engexts.h>

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_DATA_SPACES2   g_ExtData2;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    //
    // Required interfaces.
    //
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                         (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                         (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                         (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                         (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    //
    // Optional interfaces.
    //
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                         (void **)&g_ExtData2)) != S_OK)
    {
        g_ExtData2 = NULL;
    }
    
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtData2);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\eng\engexts\engexts.h ===
//----------------------------------------------------------------------------
//
// Debugger engine extension helper library.
//
// Copyright (C) Microsoft Corporation, 1999-2000.
//
//----------------------------------------------------------------------------

#ifndef __ENGEXTS_H__
#define __ENGEXTS_H__

#include <stdlib.h>
#include <stdio.h>

#include <windows.h>

#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_DATA_SPACES2   g_ExtData2;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Prototype just to force the extern "C".
// The implementation of these functions are not provided.
HRESULT CALLBACK DebugExtensionInitialize(PULONG Version, PULONG Flags);
void CALLBACK DebugExtensionUninitialize(void);

// Queries for all debugger interfaces.
HRESULT ExtQuery(PDEBUG_CLIENT Client);

// Cleans up all debugger interfaces.
void ExtRelease(void);

// Normal output.
void __cdecl ExtOut(PCSTR Format, ...);
// Error output.
void __cdecl ExtErr(PCSTR Format, ...);
// Warning output.
void __cdecl ExtWarn(PCSTR Format, ...);
// Verbose output.
void __cdecl ExtVerb(PCSTR Format, ...);

#ifdef __cplusplus
}
#endif

#endif // #ifndef __ENGEXTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>

#include <lmerr.h>
#include "extsfns.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;
extern PDEBUG_CONTROL2       g_ExtControl2;

extern ULONG   TargetMachine;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extdll\ext.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ext.cpp

Abstract:

    Generic cross-platform and cross-processor extensions.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>
#include <time.h>
#include <lm.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;
// Version 2 Interfaces
PDEBUG_CONTROL2       g_ExtControl2;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl2),
                                 (void **)&g_ExtControl2)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
    EXT_RELEASE(g_ExtControl2);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;


    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

LegacyCommands()
{
    dprintf("\n");
    dprintf("  !cxr !exr, !trap and !tss has been replaced with the new built-in debugger \n");
    dprintf("  command .cxr, .exr, .trap and .tss.  There is also a new \".thread\" command. \n");
    dprintf("\n");
    dprintf("  These new commands no longer require symbols to work correctly.\n");
    dprintf("\n");
    dprintf("  Another change that comes with these new commands is that they actually\n");
    dprintf("  change the internal state of the debugger engine \"permanently\" (until\n");
    dprintf("  reverted).  Any other debugger or extension command issued after the \n");
    dprintf("  \".cxr\", \".trap\" or \".thread\" command will be executed with the new context.\n");
    dprintf("\n");
    dprintf("  For example, commands such as stack walk (\"k\", \"kb\", \"kv\" ), \"r\" and \"dv\"\n");
    dprintf("  (show local variables) will all work based off the new context that was\n");
    dprintf("  supplied by \".cxr\", \".trap\" or \".thread\".\n");
    dprintf("\n");
    dprintf("  \".cxr\", \".trap\" and \".thread\" also apply to WinDBG:\n");
    dprintf("  using \".cxr\" , \".trap\"  and \".thread\" will automatically show you the\n");
    dprintf("  new stack in the WinDBG stack window and allow you to click on a frame and\n");
    dprintf("  see local variables and source code (if source is available).\n");
    dprintf("\n");
    dprintf("  \".cxr\", \".trap\" or \".thread\" with no parameters will give you back the\n");
    dprintf("  default context that was in effect before the command was executed.\n");
    dprintf("\n");
    dprintf("  For example, to exactly duplicate \n");
    dprintf("\n");
    dprintf("        !cxr <foo>        !trap <foo>\n");
    dprintf("        !kb               !kb\n");
    dprintf("\n");
    dprintf("  you would now use\n");
    dprintf("\n");
    dprintf("        .cxr <foo>        .trap <foo>\n");
    dprintf("        kb                kb\n");
    dprintf("        .cxr              .trap\n");
    dprintf("\n");
    return S_OK;
}

DECLARE_API ( cxr )
{
    LegacyCommands();
    return S_OK;
}

DECLARE_API ( exr )
{
    LegacyCommands();
    return S_OK;
}

DECLARE_API ( trap )
{
    LegacyCommands();
    return S_OK;
}

DECLARE_API ( tss )
{
    LegacyCommands();
    return S_OK;
}


DECLARE_API( cpuid )

/*++

Routine Description:

    Print out the version number for all CPUs, if available.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG64 Val;
    BOOL First = TRUE;
    ULONG Processor;
    ULONG NumProcessors;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL IdAll;

    INIT_API();

    if (g_ExtControl->GetNumberProcessors(&NumProcessors) != S_OK)
    {
        NumProcessors = 0;
    }

    if (GetExpressionEx(args, &Val, &args))
    {
        //
        // The user specified a procesor number.
        //

        Processor = (ULONG)Val;
        if (Processor >= NumProcessors)
        {
            dprintf("Invalid processor number specified\n");
        }
        else
        {
            NumProcessors = Processor + 1;
        }
    }
    else
    {
        //
        // Enumerate all the processors
        //

        Processor = 0;
    }

    while (Processor < NumProcessors)
    {
        if (g_ExtData->
            ReadProcessorSystemData(Processor,
                                    DEBUG_DATA_PROCESSOR_IDENTIFICATION,
                                    &IdAll, sizeof(IdAll), NULL) != S_OK)
        {
            dprintf("Unable to get processor %d ID information\n",
                    Processor);
            break;
        }
        
        switch( TargetMachine )
        {
        case IMAGE_FILE_MACHINE_I386:

            if (First)
            {
                dprintf("CP  F/M/S  Manufacturer\n");
            }

            dprintf("%2d %2d,%d,%-2d %-16.16s\n",
                    Processor,
                    IdAll.X86.Family,
                    IdAll.X86.Model,
                    IdAll.X86.Stepping,
                    IdAll.X86.VendorString);

            break;

        case IMAGE_FILE_MACHINE_AMD64:

            if (First)
            {
                dprintf("CP  F/M/S  Manufacturer\n");
            }

            dprintf("%2d %2d,%d,%-2d %-16.16s\n",
                    Processor,
                    IdAll.Amd64.Family,
                    IdAll.Amd64.Model,
                    IdAll.Amd64.Stepping,
                    IdAll.Amd64.VendorString);

            break;

        case IMAGE_FILE_MACHINE_IA64:

            if (First)
            {
                dprintf("CP M/R/F/A Manufacturer\n");
            }

            dprintf("%2d %d,%d,%d,%d %-16.16s\n",
                    Processor,
                    IdAll.Ia64.Model,
                    IdAll.Ia64.Revision,
                    IdAll.Ia64.Family,
                    IdAll.Ia64.ArchRev,
                    IdAll.Ia64.VendorString);

            break;

        default:
            dprintf("Not supported for this target machine: %ld\n",
                    TargetMachine);
            Processor = NumProcessors;
            break;
        }

        Processor++;
        First = FALSE;
    }

    EXIT_API();

    return S_OK;
}


HRESULT
PrintString(
    BOOL Unicode,
    PDEBUG_CLIENT Client,
    LPCSTR args
    )
{
    ULONG64 AddrString;
    ULONG64 Displacement;
    STRING32 String;
    UNICODE_STRING UnicodeString;
    ULONG64 AddrBuffer;
    CHAR Symbol[1024];
    LPSTR StringData;
    HRESULT hResult;
    BOOL b;


    AddrString = GetExpression(args);
    if (!AddrString)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol(AddrString, Symbol, &Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory(AddrString, &String, sizeof(String), NULL);

    if ( !b )
    {
        return E_FAIL;
    }

    INIT_API();

    if (IsPtr64())
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING64, Buffer),
                             &AddrBuffer);
    }
    else
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING32, Buffer),
                             &AddrBuffer);
    }

    EXIT_API();

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    StringData = (LPSTR) LocalAlloc(LMEM_ZEROINIT,
                                    String.Length + sizeof(UNICODE_NULL));

    if (!StringData)
    {
        return E_FAIL;
    }

    dprintf("String(%d,%d)", String.Length, String.MaximumLength);
    if (Symbol[0])
    {
        dprintf(" %s+%p", Symbol, Displacement);
    }

    b = ReadMemory(AddrBuffer, StringData, String.Length, NULL);

    if ( b )
    {
        if (Unicode)
        {
            ANSI_STRING AnsiString;

            UnicodeString.Buffer = (PWSTR)StringData;
            UnicodeString.Length = String.Length;
            UnicodeString.MaximumLength = String.Length+sizeof(UNICODE_NULL);

            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString,TRUE);

            dprintf(" at %p: %s\n", AddrString, AnsiString.Buffer);

            RtlFreeAnsiString(&AnsiString);
        }
        else
        {
            dprintf(" at %p: %s\n", AddrString, StringData);
        }

        LocalFree(StringData);
        return S_OK;
    }
    else
    {
        LocalFree(StringData);
        return E_FAIL;
    }
}

DECLARE_API( str )

/*++

Routine Description:

    This function is called to format and dump counted (ansi) string.

Arguments:

    args - Address

Return Value:

    None.

--*/
{
    return PrintString(FALSE, Client, args);
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called to format and dump counted (unicode) string.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    return PrintString(TRUE, Client, args);
}

DECLARE_API( obja )

/*++

Routine Description:

    This function is called to format and dump an object attributes structure.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    ULONG64 AddrObja;
    ULONG64 Displacement;
    ULONG64 AddrString;
    STRING32 String;
    ULONG64 StrAddr = NULL;
    CHAR Symbol[1024];
    LPSTR StringData;
    BOOL b;
    ULONG Attr;
    HRESULT hResult;
    ULONG ObjectNameOffset;
    ULONG AttrOffset;
    ULONG StringOffset;

    if (IsPtr64())
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, Attributes);
        StringOffset = FIELD_OFFSET(STRING64, Buffer);
    }
    else
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, Attributes);
        StringOffset = FIELD_OFFSET(STRING32, Buffer);
    }


    AddrObja = GetExpression(args);
    if (!AddrObja)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the Obja
    //

    GetSymbol(AddrObja, Symbol, &Displacement);

    dprintf("Obja %s+%p at %p:\n", Symbol, Displacement, AddrObja);


    INIT_API();

    hResult = g_ExtData->ReadPointersVirtual(1,
                         AddrObja + ObjectNameOffset,
                         &AddrString);

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    if (AddrString)
    {
        b = ReadMemory(AddrString, &String, sizeof(String), NULL);

        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + StringOffset,
                             &StrAddr);
    }

    EXIT_API();


    if (StrAddr)
    {
        StringData = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                       String.Length+sizeof(UNICODE_NULL));

        if (StringData)
        {

            b = ReadMemory(StrAddr, StringData, String.Length, NULL);

            if (b)
            {
                dprintf("\tName is %ws\n", StringData);
            }

            LocalFree(StringData);
        }

    }

    b = ReadMemory(AddrObja + AttrOffset, &Attr, sizeof(Attr), NULL);

    if (!b)
    {
        return E_FAIL;
    }

    if (Attr & OBJ_INHERIT )
    {
        dprintf("\tOBJ_INHERIT\n");
    }
    if (Attr & OBJ_PERMANENT )
    {
        dprintf("\tOBJ_PERMANENT\n");
    }
    if (Attr & OBJ_EXCLUSIVE )
    {
        dprintf("\tOBJ_EXCLUSIVE\n");
    }
    if (Attr & OBJ_CASE_INSENSITIVE )
    {
        dprintf("\tOBJ_CASE_INSENSITIVE\n");
    }
    if (Attr & OBJ_OPENIF )
    {
        dprintf("\tOBJ_OPENIF\n");
    }


    return S_OK;
}


VOID
DecodeErrorForMessage(
    PDEBUG_DECODE_ERROR pDecodeError
    )
{
    HANDLE Dll;
    PSTR Source;
    CHAR Message[ 512 ];
    PCHAR s;
    ULONG   Code;
    BOOL    TreatAsStatus;
    
    Code = pDecodeError->Code;
    TreatAsStatus = pDecodeError->TreatAsStatus;

    if ( !pDecodeError->TreatAsStatus )
    {
        //
        // The value "type" is not known.  Try and figure out what it
        // is.
        //

        if ( (Code & 0xC0000000) == 0xC0000000 )
        {
            //
            // Easy:  NTSTATUS failure case
            //

            Dll = GetModuleHandle( "NTDLL.DLL" );
            Source = "NTSTATUS" ;
            TreatAsStatus = TRUE ;
        }
        else if ( ( Code & 0xF0000000 ) == 0xD0000000 )
        {
            //
            // HRESULT from NTSTATUS
            //

            Dll = GetModuleHandle( "NTDLL.DLL" );
            Source = "NTSTATUS" ;
            Code &= 0xCFFFFFFF ;
            TreatAsStatus = TRUE ;
        }
        else if ( ( Code & 0x80000000 ) == 0x80000000 )
        {
            //
            // Note, this can overlap with NTSTATUS warning area.  In that
            // case, force the NTSTATUS.
            //

            Dll = GetModuleHandle( "KERNEL32.DLL" );
            Source = "HRESULT" ;

        }
        else
        {
            //
            // Sign bit is off.  Explore some known ranges:
            //

            if ( (Code >= WSABASEERR) && (Code <= WSABASEERR + 1000 ))
            {
                Dll = LoadLibrary( "wsock32.dll" );
                Source = "Winsock" ;
            }
            else if ( ( Code >= NERR_BASE ) && ( Code <= MAX_NERR ) )
            {
                Dll = LoadLibrary( "netmsg.dll" );
                Source = "NetAPI" ;
            }
            else
            {
                Dll = GetModuleHandle( "KERNEL32.DLL" );
                Source = "Win32" ;
            }
        }
    }
    else
    {
        Dll = GetModuleHandle( "NTDLL.DLL" );

        Source = "NTSTATUS" ;
    }

    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |
                           FORMAT_MESSAGE_FROM_HMODULE,
                       Dll,
                       Code,
                       0,
                       Message,
                       sizeof( Message ),
                       NULL ) )
    {
        strcpy( Message, "No mapped error code" );
    }

    s = Message ;

    while (*s)
    {
        if (*s < ' ')
        {
            *s = ' ';
        }
        s++;
    }
    pDecodeError->TreatAsStatus = TreatAsStatus;
    strcpy(pDecodeError->Source, Source);
    if (strlen(Message) < sizeof(pDecodeError->Message)) {
        strcpy(pDecodeError->Message, Message);
    }
}

VOID
DecodeError(
    PSTR    Banner,
    ULONG   Code,
    BOOL    TreatAsStatus
    )
{
    DEBUG_DECODE_ERROR Err;

    Err.Code = Code;
    Err.TreatAsStatus = TreatAsStatus;
    DecodeErrorForMessage(&Err);
    if (!TreatAsStatus)
    {
        dprintf("%s: (%s) %#x (%u) - %s\n",
                Banner, Err.Source, Code, Code, Err.Message);
    }
    else
    {
        dprintf("%s: (%s) %#x - %s\n",
                Banner, Err.Source, Code, Err.Message);
    }
}

DECLARE_API( error )
{
    ULONG err ;

    err = (ULONG) GetExpression( args );
    DecodeError( "Error code", err, FALSE );

    return S_OK;
}

#if 1

DECLARE_API( gle )
{
    NTSTATUS Status;
    ULONG64 Address;
    TEB Teb;

    GetTebAddress(&Address);

    if (ReadMemory(Address, &Teb, sizeof(Teb), NULL))
    {
        DecodeError( "LastErrorValue", Teb.LastErrorValue, FALSE );
        DecodeError( "LastStatusValue", Teb.LastStatusValue, TRUE );

        return S_OK;
    }
    else
    {
        dprintf("Unable to read current thread's TEB\n" );
        return E_FAIL;
    }
}


void
DispalyTime(
    ULONG64 Time,
    PCHAR TimeString
    )
{
    if (Time) {
        ULONG seconds = (ULONG) Time;
        ULONG minutes = seconds / 60;
        ULONG hours = minutes / 60;
        ULONG days = hours / 24;

        dprintf("%s %d days %d:%02d:%02d \n",
                TimeString,
                days, hours%24, minutes%60, seconds%60);
    }
}

extern PCHAR gTargetMode[], gAllOsTypes[];

DECLARE_API( targetinfo )
{
    TARGET_DEBUG_INFO TargetInfo;
    EXT_TARGET_INFO GetTargetInfo;
    INIT_API();


    if (g_ExtControl->GetExtensionFunction(0, "GetTargetInfo", (FARPROC *)&GetTargetInfo) == S_OK) {
        TargetInfo.SizeOfStruct = sizeof(TargetInfo);
        if ((*GetTargetInfo)(Client, &TargetInfo) != S_OK) {
            dprintf("GetTargetInfo failed\n");
        } else {
            const char * time;

            dprintf("TargetInfo:\n");
            dprintf("%s\n", gTargetMode[ TargetInfo.Mode ]);
            if ((time = ctime((time_t *) &TargetInfo.CrashTime)) != NULL) {
                dprintf("\tCrashtime:      %s",       time);
            }
            if (TargetInfo.SysUpTime) {
                DispalyTime(TargetInfo.SysUpTime, 
                            "\tSystem Uptime: ");
            }
            else
            {
                dprintf("\tSystem Uptime: not available\n");
            }
            if (TargetInfo.Mode == UserModeTarget) {
                DispalyTime(TargetInfo.AppUpTime, "\tProcess Uptime: ");
            }
            if ((time = ctime((time_t *) &TargetInfo.EntryDate)) != NULL) {
                dprintf("\tEntry Date:     %s", time);
            }
            if (TargetInfo.OsInfo.Type) {
                dprintf(gAllOsTypes[TargetInfo.OsInfo.Type]);
                dprintf(" ");
            }
//          dprintf("OS Type %lx, Probcuct %lx, suite %lx\n",
//                  TargetInfo.OsInfo.Type, TargetInfo.OsInfo.ProductType,
//                  TargetInfo.OsInfo.Suite);
            dprintf("%s, %s ",
                    TargetInfo.OsInfo.OsString,
                    TargetInfo.OsInfo.ServicePackString);
            dprintf("Version %ld.%ld\n",
                    TargetInfo.OsInfo.Version.Major, TargetInfo.OsInfo.Version.Minor);
            dprintf("%d procs, %d current processor, type %lx\n",
                    TargetInfo.Cpu.NumCPUs,
                    TargetInfo.Cpu.CurrentProc,
                    TargetInfo.Cpu.Type);
            for (ULONG i =0; i<TargetInfo.Cpu.NumCPUs; i++) {
                if (TargetInfo.Cpu.Type == IMAGE_FILE_MACHINE_I386) {
                    dprintf("CPU %lx Family %lx Model %lx Ste %lx Vendor %-12.12s\n",
                            i,
                            TargetInfo.Cpu.ProcInfo[i].X86.Family,
                            TargetInfo.Cpu.ProcInfo[i].X86.Model,
                            TargetInfo.Cpu.ProcInfo[i].X86.Stepping,
                            TargetInfo.Cpu.ProcInfo[i].X86.VendorString);
                } else if (TargetInfo.Cpu.Type == IMAGE_FILE_MACHINE_IA64) {
                    dprintf("CPU %lx Family %lx Model %lx Rev %lx Vendor %-12.12s\n",
                            i,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.Family,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.Model,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.Revision,
                            TargetInfo.Cpu.ProcInfo[i].Ia64.VendorString);
                }
            }
        }
    }

    EXIT_API();
    return S_OK;
}
#endif


BOOL
GetOwner(
    PSTR OwnerBuffer,
    ULONG OwnerBufferSize,
    PSTR SymbolName
    )
{
    PSTR Bang;
    CHAR Owner2[MAX_PATH];
    ULONG Found = 0;
    PSTR SymName;
    static CHAR szTriageFileName[MAX_PATH+50];
    static BOOL GotTriageFIleName = FALSE;


    if (!GotTriageFIleName) 
    {
        PCHAR ExeDir;

        ExeDir = &szTriageFileName[0];

        *ExeDir = 0;
            // Get the directory the debugger executable is in.
        if (!GetModuleFileName(NULL, ExeDir, MAX_PATH)) 
        {
            // Error.  Use the current directory.
            strcpy(ExeDir, ".");
        } else 
        {
            // Remove the executable name.
            PCHAR pszTmp = strrchr(ExeDir, '\\');
            if (pszTmp)
            {
                *pszTmp = 0;
            }
            GotTriageFIleName = TRUE;
        }
        strcat(ExeDir, "\\triage\\triage.ini");
    }



    //
    // First extract the module name from the symbol name.
    //

    Bang = strstr(SymbolName, "!");

    if (Bang)
    {
        *Bang = 0;
    }

    Found = GetPrivateProfileString("owners", SymbolName, "[default]",
                                    OwnerBuffer, OwnerBufferSize,
                                    szTriageFileName);

    if (!Found ||
        !strcmp(OwnerBuffer, "ignore"))
    {
        return FALSE;
    }

    if (OwnerBuffer[0] != '[')
    {
        return TRUE;
    }

    //
    // The string points to another section to handle substrings in the module
    // For each substring, starting with the longest one, search the
    // section.
    //
    PSTR End = NULL;
    SymName = NULL;
    if (Bang) 
    {
        SymName = Bang+1;
        End = SymName+ strlen(SymName);
    } 

    strcpy(Owner2, OwnerBuffer+1);
    *(Owner2+strlen(Owner2)-1) = 0;

    while (End > SymName)
    {
        Found = GetPrivateProfileString(Owner2, SymName, "ignore",
                                        OwnerBuffer, OwnerBufferSize,
                                        szTriageFileName);

        if (Found && strcmp(OwnerBuffer, "ignore"))
        {
            return TRUE;
        }

        *--End = 0;
    }

    //
    // We did not find the subcomponent - Look for the default entry.
    //

    Found = GetPrivateProfileString(Owner2, "default", "ignore",
                                    OwnerBuffer, OwnerBufferSize,
                                    szTriageFileName);

    if (Found && strcmp(OwnerBuffer, "ignore"))
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
_EFN_GetTriageFollowupFromSymbol(
    IN PSTR SymbolName,
    OUT PDEBUG_TRIAGE_FOLLOWUP_INFO OwnerInfo
    )
{
    if (OwnerInfo->SizeOfStruct != sizeof(DEBUG_TRIAGE_FOLLOWUP_INFO)) 
    {
        return FALSE;
    }
    if (GetOwner(OwnerInfo->OwnerName.Buffer, OwnerInfo->OwnerName.MaximumLength, SymbolName)) {
        OwnerInfo->OwnerName.Length = (USHORT)strlen(OwnerInfo->OwnerName.Buffer);
        return TRUE;
    }
    return FALSE;
}


DECLARE_API( triage )

/*++

Routine Description:

    This function can be called to triage the owner of a stack trace.

Arguments:

    args - none

Return Value:

    None.

--*/

{

    ULONG NumFrames = 20;
    ULONG FramesFound = 0;
    ULONG i;
    BOOL bOwner = FALSE;
    CHAR  NameBuffer[MAX_PATH + 2000 + 20];
    CHAR  CurrentOwner[MAX_PATH];

    // Allocate a separate buffer to hold the frames while
    // calling OutputStackTrace on them.  We can't just pass
    // in the state buffer pointer as resizing of the state
    // buffer may cause the data pointer to change.

    PDEBUG_STACK_FRAME RawFrames =
        (PDEBUG_STACK_FRAME)malloc(NumFrames * sizeof(DEBUG_STACK_FRAME));
    PDEBUG_STACK_FRAME CurrentFrame = RawFrames;

    if (RawFrames == NULL)
    {
        return E_OUTOFMEMORY;
    }

    INIT_API();

    Status = g_ExtControl->GetStackTrace(0, 0, 0, RawFrames, NumFrames,
                                         &FramesFound);
    if (Status == S_OK)
    {
        for(i=0; i < FramesFound; i++)
        {
            //
            // Get the symbol from the address and look it up in the
            // list of owners
            //

            Status = g_ExtSymbols->GetNameByOffset(CurrentFrame->InstructionOffset,
                                                   NameBuffer,
                                                   sizeof(NameBuffer),
                                                   NULL,
                                                   NULL);
            CurrentFrame++;

            if (Status != S_OK)
            {
                continue;
            }

            if (bOwner = GetOwner(CurrentOwner, sizeof(CurrentOwner), NameBuffer))
            {
                break;
            }
        }
    }

    if (!bOwner)
    {
        GetOwner(CurrentOwner, sizeof(CurrentOwner), "default");
    }

    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS,
                                   RawFrames, FramesFound, 0);

    dprintf("\n********************\nFollow-up:  %s\n********************\n\n",
             CurrentOwner);

    EXIT_API();

    free(RawFrames);
    return Status;
}


void
_EFN_DecodeError(
    PDEBUG_DECODE_ERROR pDecodeError
    )
{
    if (pDecodeError->SizeOfStruct != sizeof(DEBUG_DECODE_ERROR)) 
    {
        return;
    }
    return DecodeErrorForMessage(pDecodeError);
}

DECLARE_API( elog_str )
{
    HANDLE EventSource = NULL;
    
    INIT_API();

    if (args)
    {
        while (isspace(*args))
        {
            args++;
        }
    }
    
    if (!args || !args[0])
    {
        Status = E_INVALIDARG;
        ExtErr("Usage: elog_str string\n");
        goto Exit;
    }

    // Get a handle to the NT application log.
    EventSource = OpenEventLog(NULL, "Application");
    if (!EventSource)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to open event log, 0x%08X\n", Status);
        goto Exit;
    }

    if (!ReportEvent(EventSource, EVENTLOG_ERROR_TYPE, 0, 0, NULL,
                     1, 0, &args, NULL))
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Unable to report event, 0x%08X\n", Status);
        goto Exit;
    }

    Status = S_OK;

 Exit:
    if (EventSource)
    {
        CloseEventLog(EventSource);
    }
    EXIT_API();
    return Status;
}

HRESULT
AnsiToUnicode(PCSTR StrA, PWSTR* StrW)
{
    ULONG Len;

    // No input is an error.
    if (NULL == StrA)
    {
        return E_INVALIDARG;
    }

    Len = strlen(StrA) + 1;
    *StrW = (PWSTR)malloc(Len * sizeof(WCHAR));
    if (*StrW == NULL)
    {
        ExtErr("Unable to allocate memory\n");
        return E_OUTOFMEMORY;
    }

    if (0 == MultiByteToWideChar(CP_ACP, 0, StrA, Len, *StrW, Len))
    {
        HRESULT Status = HRESULT_FROM_WIN32(GetLastError());
        free(*StrW);
        ExtErr("Unable to convert string, 0x%08X\n", Status);
        return Status;
    }

    return S_OK;
}

typedef NET_API_STATUS (NET_API_FUNCTION* PFN_NetMessageBufferSend)
(
    IN  LPCWSTR  servername,
    IN  LPCWSTR  msgname,
    IN  LPCWSTR  fromname,
    IN  LPBYTE   buf,
    IN  DWORD    buflen
);

DECLARE_API( net_send )
{
    PWSTR ArgsW = NULL;
    PWSTR Tokens[4];
    ULONG i;
    HMODULE NetLib = NULL;
    PFN_NetMessageBufferSend Send;
    ULONG Result;
    PWSTR ArgsEnd;

    INIT_API();

    NetLib = LoadLibrary("netapi32.dll");
    if (!NetLib)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Platform does not support net send\n");
        goto Exit;
    }
    Send = (PFN_NetMessageBufferSend)
        GetProcAddress(NetLib, "NetMessageBufferSend");
    if (!Send)
    {
        Status = E_NOTIMPL;
        ExtErr("Platform does not support net send\n");
        goto Exit;
    }
    
    Status = AnsiToUnicode(args, &ArgsW);
    if (Status != S_OK)
    {
        goto Exit;
    }
    ArgsEnd = ArgsW + wcslen(ArgsW);

    // The message text is the entire remainder of the argument
    // string after parsing the first separate tokens, so
    // only wcstok up to the next-to-last token.
    for (i = 0; i < sizeof(Tokens) / sizeof(Tokens[0]) - 1; i++)
    {
        Tokens[i] = wcstok(i == 0 ? ArgsW : NULL, L" \t");
        if (Tokens[i] == NULL)
        {
            Status = E_INVALIDARG;
            ExtErr("USAGE: net_send <targetserver> <targetuser> "
                   "<fromuser> <msg>\n");
            goto Exit;
        }
    }

    Tokens[i] = Tokens[i - 1] + wcslen(Tokens[i - 1]) + 1;
    while (Tokens[i] < ArgsEnd &&
           (*Tokens[i] == ' ' || *Tokens[i] == '\t'))
    {
        Tokens[i]++;
    }
    if (Tokens[i] >= ArgsEnd)
    {
        Status = E_INVALIDARG;
        ExtErr("USAGE: net_send <targetserver> <targetuser> "
               "<fromuser> <msg>\n");
        goto Exit;
    }

    Result = Send(Tokens[0], Tokens[1], Tokens[2], (PBYTE)Tokens[3],
                  (wcslen(Tokens[3]) + 1) * sizeof(WCHAR));
    if (Result != NERR_Success)
    {
        Status = HRESULT_FROM_WIN32(Result);;
        ExtErr("Unable to send message, 0x%08X\n", Status);
        goto Exit;
    }

    Status = S_OK;

 Exit:
    if (ArgsW)
    {
        free(ArgsW);
    }
    if (NetLib)
    {
        FreeLibrary(NetLib);
    }
    EXIT_API();
    return Status;
}

// XXX drewb - This function just starts a mail message; the
// UI comes up and the user must finish and send the message.
// Therefore it doesn't have much value over the
// user just deciding to send a message.
#if 0

typedef ULONG (FAR PASCAL *PFN_MapiSendMail)
(
    LHANDLE lhSession,
    ULONG ulUIParam,
    lpMapiMessage lpMessage,
    FLAGS flFlags,
    ULONG ulReserved
);

DECLARE_API( mapi_send )
{
    HMODULE MapiLib = NULL;
    PFN_MapiSendMail Send;
    MapiMessage Mail;
    
    INIT_API();

    MapiLib = LoadLibrary("mapi.dll");
    if (!MapiLib)
    {
        Status = HRESULT_FROM_WIN32(GetLastError());
        ExtErr("Platform does not support MAPI\n");
        goto Exit;
    }
    Send = (PFN_MapiSendMail)
        GetProcAddress(MapiLib, "MAPISendMail");
    if (!Send)
    {
        Status = E_NOTIMPL;
        ExtErr("Platform does not support MAPI\n");
        goto Exit;
    }

    ZeroMemory(&Mail, sizeof(Mail));

    if (!Send(0,           // use implicit session.
              0,           // ulUIParam; 0 is always valid
              &Mail,       // the message being sent
              MAPI_DIALOG, // allow the user to edit the message
              0            // reserved; must be 0
              ))
    {
        Status = E_FAIL;
        ExtErr("Unable to send mail\n");
        goto Exit;
    }

    Status = S_OK;

 Exit:
    if (MapiLib)
    {
        FreeLibrary(MapiLib);
    }
    EXIT_API();
    return Status;
}

#endif

DECLARE_API( imggp )
{
    ULONG64 ImageBase;
    IMAGE_DOS_HEADER DosHdr;
    IMAGE_NT_HEADERS64 NtHdr;
    ULONG Done;

    INIT_API();
    
    ImageBase = GetExpression(args);

    if (g_ExtData->ReadVirtual(ImageBase, &DosHdr, sizeof(DosHdr),
                               &Done) != S_OK ||
        Done != sizeof(DosHdr))
    {
        ExtErr("Unable to read DOS header at %p\n", ImageBase);
        goto Exit;
    }

    if (DosHdr.e_magic != IMAGE_DOS_SIGNATURE)
    {
        ExtErr("Invalid DOS header at %p\n", ImageBase);
        goto Exit;
    }
    
    if (g_ExtData->ReadVirtual(ImageBase + DosHdr.e_lfanew,
                               &NtHdr, sizeof(NtHdr),
                               &Done) != S_OK ||
        Done != sizeof(NtHdr))
    {
        ExtErr("Unable to read NT header at %p\n",
               ImageBase + DosHdr.e_lfanew);
        goto Exit;
    }

    if (NtHdr.Signature != IMAGE_NT_SIGNATURE)
    {
        ExtErr("Invalid NT header at %p\n", ImageBase + DosHdr.e_lfanew);
        goto Exit;
    }
    if (NtHdr.OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
    {
        ExtErr("Image is not 64-bit\n");
        goto Exit;
    }
    if (NtHdr.OptionalHeader.NumberOfRvaAndSizes <=
        IMAGE_DIRECTORY_ENTRY_GLOBALPTR)
    {
        ExtErr("Image does not have a GP directory entry\n");
        goto Exit;
    }

    ExtOut("Image at %p has a GP value of %p\n",
           ImageBase, ImageBase +
           NtHdr.OptionalHeader.DataDirectory
           [IMAGE_DIRECTORY_ENTRY_GLOBALPTR].VirtualAddress);
    
 Exit:
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\eng\test\test.cpp ===
#include <engexts.h>

//----------------------------------------------------------------------------
//
// StaticEventCallbacks.
//
//----------------------------------------------------------------------------

class StaticEventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );
};

STDMETHODIMP_(ULONG)
StaticEventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
StaticEventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

//----------------------------------------------------------------------------
//
// ExcepCallbacks.
//
//----------------------------------------------------------------------------

class ExcepCallbacks : public StaticEventCallbacks
{
public:
    ExcepCallbacks(void)
    {
        m_Client = NULL;
        m_Control = NULL;
    }
    
    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        );

    HRESULT Initialize(PDEBUG_CLIENT Client)
    {
        HRESULT Status;
        
        m_Client = Client;
        m_Client->AddRef();
        
        if ((Status = m_Client->QueryInterface(__uuidof(IDebugControl),
                                               (void**)&m_Control)) == S_OK)
        {
            // Turn off default breakin on breakpoint exceptions.
            Status = m_Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                                        "sxd bpe", DEBUG_EXECUTE_DEFAULT);
        }

        return Status;
    }
    void Uninitialize(void)
    {
        EXT_RELEASE(m_Control);
        EXT_RELEASE(m_Client);
    }
    
private:
    PDEBUG_CLIENT m_Client;
    PDEBUG_CONTROL m_Control;
};

STDMETHODIMP
ExcepCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_EXCEPTION;
    return S_OK;
}
    
STDMETHODIMP
ExcepCallbacks::Exception(
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    )
{
    m_Control->Output(DEBUG_OUTPUT_NORMAL, "Exception %X at %p, chance %d\n",
                      Exception->ExceptionCode, Exception->ExceptionAddress,
                      FirstChance ? 1 : 2);
    return DEBUG_STATUS_GO_HANDLED;
}

ExcepCallbacks g_ExcepCallbacks;

//----------------------------------------------------------------------------
//
// FnProfCallbacks.
//
//----------------------------------------------------------------------------

class FnProfCallbacks : public StaticEventCallbacks
{
public:
    FnProfCallbacks(void)
    {
        m_Client = NULL;
        m_Control = NULL;
    }
    
    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        );

    HRESULT Initialize(PDEBUG_CLIENT Client, PDEBUG_CONTROL Control)
    {
        m_Hits = 0;
        
        m_Client = Client;
        m_Client->AddRef();
        m_Control = Control;
        m_Control->AddRef();
        
        return S_OK;
    }
    void Uninitialize(void)
    {
        EXT_RELEASE(m_Control);
        EXT_RELEASE(m_Client);
    }

    ULONG GetHits(void)
    {
        return m_Hits;
    }
    PDEBUG_CONTROL GetControl(void)
    {
        return m_Control;
    }
    
private:
    PDEBUG_CLIENT m_Client;
    PDEBUG_CONTROL m_Control;
    ULONG m_Hits;
};

STDMETHODIMP
FnProfCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_BREAKPOINT;
    return S_OK;
}
    
STDMETHODIMP
FnProfCallbacks::Breakpoint(
    THIS_
    IN PDEBUG_BREAKPOINT Bp
    )
{
    PDEBUG_CLIENT Client;
    HRESULT Status = DEBUG_STATUS_NO_CHANGE;
    
    // If this is one of our profiling breakpoints
    // record the function hit and continue on.
    if (Bp->GetAdder(&Client) == S_OK)
    {
        if (Client == m_Client)
        {
            m_Hits++;
            Status = DEBUG_STATUS_GO;
        }
        
        Client->Release();
    }

    Bp->Release();
    return Status;
}

FnProfCallbacks g_FnProfCallbacks;

//----------------------------------------------------------------------------
//
// Extension entry points.
//
//----------------------------------------------------------------------------

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}

extern "C" void CALLBACK
DebugExtensionUninitialize(void)
{
    g_ExcepCallbacks.Uninitialize();
    g_FnProfCallbacks.Uninitialize();
}

#if 0
extern "C" HRESULT CALLBACK
teb(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    ULONG64 DataOffset;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }
    
    if (*Args)
    {
        sscanf(Args, "%I64x", &DataOffset);
    }
    else
    {
        g_ExtSystem->GetCurrentThreadDataOffset(&DataOffset);
    }
    
    ExtOut("TEB at %I64x\n", DataOffset);

    TEB Teb;

    Status = g_ExtData->ReadVirtual(DataOffset, &Teb, sizeof(Teb), NULL);
    if (Status != S_OK)
    {
        ExtErr("* Unable to read TEB\n");
    }
    else
    {
        ExtOut("    ExceptionList:    %x\n", Teb.NtTib.ExceptionList);
        ExtOut("    Stack Base:       %x\n", Teb.NtTib.StackBase);
        ExtOut("    Stack Limit:      %x\n", Teb.NtTib.StackLimit);
        ExtOut("    SubSystemTib:     %x\n", Teb.NtTib.SubSystemTib);
        ExtOut("    FiberData:        %x\n", Teb.NtTib.FiberData);
        ExtOut("    ArbitraryUser:    %x\n", Teb.NtTib.ArbitraryUserPointer);
        ExtOut("    Self:             %x\n", Teb.NtTib.Self);
        ExtOut("    EnvironmentPtr:   %x\n", Teb.EnvironmentPointer);
        ExtOut("    ClientId:         %x.%x\n",
               Teb.ClientId.UniqueProcess, Teb.ClientId.UniqueThread);
        if (Teb.ClientId.UniqueProcess != Teb.RealClientId.UniqueProcess ||
            Teb.ClientId.UniqueThread != Teb.RealClientId.UniqueThread)
        {
            ExtOut("    Real ClientId:    %x.%x\n",
                   Teb.RealClientId.UniqueProcess,
                   Teb.RealClientId.UniqueThread);
        }
        ExtOut("    Real ClientId:    %x.%x\n",
               Teb.RealClientId.UniqueProcess,
               Teb.RealClientId.UniqueThread);
        ExtOut("    RpcHandle:        %x\n", Teb.ActiveRpcHandle);
        ExtOut("    Tls Storage:      %x\n", Teb.ThreadLocalStoragePointer);
        ExtOut("    PEB Address:      %x\n", Teb.ProcessEnvironmentBlock);
        ExtOut("    LastErrorValue:   %u\n", Teb.LastErrorValue);
        ExtOut("    LastStatusValue:  %x\n", Teb.LastStatusValue);
        ExtOut("    Count Owned Locks:%u\n", Teb.CountOfOwnedCriticalSections);
        ExtOut("    HardErrorsMode:   %u\n", Teb.HardErrorsAreDisabled);

        Status = S_OK;
    }

    ExtRelease();
    return Status;
}
#endif

extern "C" HRESULT CALLBACK
outreg(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    g_ExtRegisters->OutputRegisters(DEBUG_OUTCTL_ALL_CLIENTS,
                                    DEBUG_REGISTERS_ALL);
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
enumreg(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Num;

    g_ExtRegisters->GetNumberRegisters(&Num);
    ExtOut("%d registers\n", Num);

    ULONG i;
    char Name[64];
    DEBUG_REGISTER_DESCRIPTION Desc;
    ULONG Reax, Rebx, Refl, Rsf, Rst0;
    ULONG RegFound = 0;

    for (i = 0; i < Num; i++)
    {
        g_ExtRegisters->GetDescription(i, Name, sizeof(Name), NULL, &Desc);

        ExtOut("  %2d: \"%s\", type %d, flags %X\n",
               i, Name, Desc.Type, Desc.Flags);
        if (Desc.Flags & DEBUG_REGISTER_SUB_REGISTER)
        {
            ExtOut("      sub to %d, len %d, mask %I64X, shift %d\n",
                   Desc.SubregMaster, Desc.SubregLength,
                   Desc.SubregMask, Desc.SubregShift);
        }
        
        // XXX drewb - Hack for testing purposes.
        if (!_strcmpi(Name, "eax"))
        {
            Reax = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "ebx"))
        {
            Rebx = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "efl"))
        {
            Refl = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "sf"))
        {
            Rsf = i;
            RegFound++;
        }
        else if (!_strcmpi(Name, "st0"))
        {
            Rst0 = i;
            RegFound++;
        }
    }

    ULONG ProcType;

    g_ExtControl->GetExecutingProcessorType(&ProcType);
    ExtOut("Processor type %d\n", ProcType);
    
    if (ProcType == IMAGE_FILE_MACHINE_I386)
    {
        DEBUG_VALUE Val;
        DEBUG_VALUE Coerce;

        if (RegFound != 5)
        {
            ExtErr("** Only found %d registers\n", RegFound);
        }
        
        Val.Type = DEBUG_VALUE_INT32;
        Val.I32 = 0x12345678;
        g_ExtRegisters->SetValue(Reax, &Val);
        Val.I32 = 12345678;
        g_ExtRegisters->SetValue(Rst0, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r eax,st0", DEBUG_EXECUTE_NOT_LOGGED);

        Val.Type = DEBUG_VALUE_FLOAT32;
        Val.F32 = 1.2345f;
        g_ExtRegisters->SetValue(Rst0, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r st0", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rst0, &Val);
        ExtOut("st0 type is %d\n", Val.Type);
        
        g_ExtControl->CoerceValue(&Val, DEBUG_VALUE_FLOAT32, &Coerce);
        Coerce.F32 *= 2.0f;
        ExtOut("coerce type is %d, val*2 %hf\n", Coerce.Type, Coerce.F32);
        
        g_ExtRegisters->SetValue(Reax, &Val);
        g_ExtRegisters->SetValue(Rebx, &Coerce);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r eax,ebx", DEBUG_EXECUTE_NOT_LOGGED);

        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rsf, &Val);
        ExtOut("sf type is %d, val %d\n", Val.Type, Val.I32);
        Val.I32 ^= 1;
        g_ExtRegisters->SetValue(Rsf, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
        g_ExtRegisters->GetValue(Rsf, &Val);
        ExtOut("sf type is %d, val %d\n", Val.Type, Val.I32);
        Val.I32 ^= 1;
        g_ExtRegisters->SetValue(Rsf, &Val);
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                              "r efl", DEBUG_EXECUTE_NOT_LOGGED);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
symnear(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    LONG Delta;

    Delta = 0;
    sscanf(Args, "%d", &Delta);
    
    ULONG64 Instr;
    char Name[128];
    ULONG64 Disp;
    
    g_ExtRegisters->GetInstructionOffset(&Instr);
    if (g_ExtSymbols->GetNearNameByOffset(Instr, Delta,
                                          Name, sizeof(Name), NULL,
                                          &Disp) == S_OK)
    {
        ExtOut("Symbol %d away from %p is:\n  %s + 0x%I64x\n",
               Delta, Instr, Name, Disp);
        
        if (g_ExtSymbols->GetOffsetByName(Name, &Instr) == S_OK)
        {
            ExtOut("Symbol %s has offset %p\n", Name, Instr);
        }
        else
        {
            ExtOut("Symbol %s has no offset\n", Name);
        }
    }
    else
    {
        ExtOut("No symbol %d away from %p\n", Delta, Instr);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
symname(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Offs;
    
    if (g_ExtSymbols->GetOffsetByName(Args, &Offs) == S_OK)
    {
        ExtOut("Symbol %s has offset %I64x\n",
               Args, Offs);
    }
    else
    {
        ExtOut("Symbol %s has no offset\n", Args);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
line(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Instr;
    ULONG Line;
    char File[128];
    ULONG64 Disp;
    
    g_ExtRegisters->GetInstructionOffset(&Instr);
    if (g_ExtSymbols->GetLineByOffset(Instr, &Line,
                                      File, sizeof(File), NULL, &Disp) == S_OK)
    {
        ExtOut("Line at %p is:\n  %s(%d) + 0x%I64x\n",
               Instr, File, Line, Disp);

        if (g_ExtSymbols->GetOffsetByLine(Line, File, &Instr) == S_OK)
        {
            ExtOut("Line %s(%d) has offset %p\n", File, Line, Instr);
        }
        else
        {
            ExtOut("Line %s(%d) has no offset\n", File, Line);
        }
    }
    else
    {
        ExtOut("No line information for %p\n", Instr);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
sympat(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG64 Match;
    char Name[128];
    ULONG64 Offset;
    PCSTR Pattern;

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args)
    {
        Pattern = Args;
    }
    else
    {
        Pattern = "*";
    }

    Status = g_ExtSymbols->StartSymbolMatch(Pattern, &Match);
    if (Status != S_OK)
    {
        ExtErr("Unable to match on '%s'\n", Pattern);
    }
    else
    {
        for (;;)
        {
            Status = g_ExtSymbols->
                GetNextSymbolMatch(Match, Name, sizeof(Name), NULL, &Offset);
            if (Status != S_OK)
            {
                break;
            }

            ExtOut("%p - %s\n", Offset, Name);

            if (g_ExtControl->GetInterrupt() == S_OK)
            {
                ExtOut("** interrupt\n");
                break;
            }
        }

        g_ExtSymbols->EndSymbolMatch(Match);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
stack(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Flags;

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args)
    {
        sscanf(Args, "%d", &Flags);
    }
    else
    {
        Flags = 0;
    }
    
    DEBUG_STACK_FRAME Frames[4];
    ULONG64 FrameOff, StackOff, InstrOff;
    ULONG Filled;

    g_ExtRegisters->GetFrameOffset(&FrameOff);
    g_ExtRegisters->GetStackOffset(&StackOff);
    g_ExtRegisters->GetInstructionOffset(&InstrOff);
    
    if (g_ExtControl->GetStackTrace(FrameOff, StackOff, InstrOff,
                                    Frames, sizeof(Frames) / sizeof(Frames[0]),
                                    &Filled) != S_OK)
    {
        ExtErr("Unable to get stack trace\n");
    }
    else
    {
        ExtOut("Filled %d frames at %p\n", Filled, InstrOff);
        g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS,
                                       Frames, Filled, Flags);
    }

    ExtOut("\nDirect:\n");
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS,
                                   NULL, 20, Flags);
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
tyid(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    ULONG TypeSize;
    ULONG64 Module;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args >= '0' && *Args <= '9')
    {
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Args, DEBUG_VALUE_INT64, &IntVal, NULL);

        Status = g_ExtSymbols->GetOffsetTypeId(IntVal.I64, &TypeId, &Module);
    }
    else
    {
        Status = g_ExtSymbols->GetSymbolTypeId(Args, &TypeId, &Module);
    }

    if (Status == S_OK)
    {
        ExtOut("Type ID of '%s' is %d\n", Args, TypeId);
    }
    else
    {
        ExtErr("Unable to get type ID, %X\n", Status);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
typeof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    ULONG TypeSize;
    ULONG64 Module;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (*Args >= '0' && *Args <= '9')
    {
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Args, DEBUG_VALUE_INT64, &IntVal, NULL);

        Status = g_ExtSymbols->GetOffsetTypeId(IntVal.I64, &TypeId, &Module);
    }
    else
    {
        Status = g_ExtSymbols->GetSymbolTypeId(Args, &TypeId, &Module);
    }
    if (Status == S_OK)
    {
        Status = g_ExtSymbols->GetTypeName(Module, TypeId, Type, sizeof(Type),
                                           &TypeSize);
    }

    if (Status == S_OK)
    {
        ExtOut("Type of '%s' is '%s':%d (%d chars)\n",
               Args, Type, TypeId, TypeSize);
    }
    else
    {
        ExtErr("Unable to get type, %X\n", Status);
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
tsizeof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    PCSTR TypeName;
    ULONG TypeId;
    ULONG TypeSize;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }

    TypeName = strchr(Args, '!');
    if (TypeName == NULL)
    {
        ExtErr("Must specify Module!Type\n");
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG64 Module;
        
        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, TypeName, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeSize(Module, TypeId, &TypeSize);
        }
    
        if (Status == S_OK)
        {
            ExtOut("Type '%s':%d is %d bytes\n",
                   Args, TypeId, TypeSize);
        }
        else
        {
            ExtErr("Unable to get type size, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
foff(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    PCSTR Bang, Dot;
    ULONG Offset;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    Bang = strchr(Args, '!');
    if (Bang != NULL)
    {
        Dot = strchr(Bang + 1, '.');
    }
    if (Bang == NULL || Dot == NULL)
    {
        ExtErr("Syntax is Module!Type.Field\n");
        Status = E_INVALIDARG;
    }
    else
    {
        ULONG64 Module;
        
        memcpy(Type, Bang + 1, Dot - (Bang + 1));
        Type[Dot - (Bang + 1)] = 0;
        Dot++;

        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, Type, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetFieldOffset(Module, TypeId, Dot,
                                                  &Offset);
        }
        
        if (Status == S_OK)
        {
            ExtOut("Offset of %s is %d bytes\n",
                   Args, Offset);
        }
        else
        {
            ExtErr("Unable to get field offset, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
otype(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG TypeId;
    char Type[256];
    PCSTR Bang, Space;
    
    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    Bang = strchr(Args, '!');
    if (Bang != NULL)
    {
        Space = strchr(Bang + 1, ' ');
    }
    if (Bang == NULL || Space == NULL)
    {
        ExtErr("Syntax is Module!Type Address\n");
        Status = E_INVALIDARG;
    }
    else
    {
        memcpy(Type, Bang + 1, Space - (Bang + 1));
        Type[Space - (Bang + 1)] = 0;
        Space++;

        ULONG64 Module;
        ULONG Flags = DEBUG_OUTTYPE_RECURSION_LEVEL(15);
        DEBUG_VALUE IntVal;

        g_ExtControl->Evaluate(Space, DEBUG_VALUE_INT64, &IntVal, NULL);
        
        Status = g_ExtSymbols->GetSymbolModule(Args, &Module);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetTypeId(Module, Type, &TypeId);
        }
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->
                OutputTypedDataVirtual(DEBUG_OUTCTL_ALL_CLIENTS,
                                       IntVal.I64, Module, TypeId, Flags);
            if (Status != S_OK)
            {
                ExtErr("Unable to output data, %X\n", Status);
            }
        }
        else
        {
            ExtErr("Unable to get type ID, %X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vsearch(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Start = 0, Len = 0;
    ULONG Chars;
    
    sscanf(Args, "%x %x%n", &Start, &Len, &Chars);
    if (Start == 0 || Len == 0)
    {
        ExtErr("Syntax is Start Len Byte+\n");
        Status = E_INVALIDARG;
    }
    else
    {
        UCHAR Pattern[32];
        ULONG PatLen;

        Args += Chars;
        PatLen = 0;
        for (;;)
        {
            while (*Args == ' ' || *Args == '\t')
            {
                Args++;
            }

            if (*Args == 0)
            {
                break;
            }

            sscanf(Args, "%x", &Pattern[PatLen]);
            PatLen++;

            while (*Args != 0 && *Args != ' ' && *Args != '\t')
            {
                Args++;
            }
        }

        ULONG64 Match;
        
        Status = g_ExtData->SearchVirtual(Start, Len, Pattern, PatLen, 1,
                                          &Match);
        if (Status == S_OK)
        {
            ExtOut("Match at %p\n", Match);
        }
        else
        {
            ExtErr("Search failed, 0x%X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vread(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    ULONG Start = 0, Len = 0;
    
    sscanf(Args, "%x %x", &Start, &Len);
    if (Start == 0 || Len == 0)
    {
        ExtErr("Syntax is Start Len\n");
        Status = E_INVALIDARG;
    }
    else
    {
        UCHAR Buffer[16384];
        ULONG Read;

        if (Len > sizeof(Buffer))
        {
            ExtWarn("Buffer is only %X bytes, clamping\n", sizeof(Buffer));
            Len = sizeof(Buffer);
        }
        
        Status = g_ExtData->ReadVirtual(Start, Buffer, Len, &Read);
        if (Status == S_OK)
        {
            ExtOut("Read %X bytes\n", Read);
        }
        else
        {
            ExtErr("Read failed, 0x%X\n", Status);
        }
    }
    
    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
watch(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    PDEBUG_CLIENT Watcher = NULL;

    if ((Status = Client->CreateClient(&Watcher)) != S_OK)
    {
        goto Exit;
    }

    if ((Status = Watcher->SetEventCallbacks(&g_ExcepCallbacks)) != S_OK)
    {
        goto Exit;
    }

    g_ExcepCallbacks.Uninitialize();
    Status = g_ExcepCallbacks.Initialize(Watcher);

 Exit:
    EXT_RELEASE(Watcher);
    if (Status != S_OK)
    {
        ExtErr("Unable to watch, 0x%X\n", Status);
        g_ExcepCallbacks.Uninitialize();
    }
    
    return Status;
}

extern "C" HRESULT CALLBACK
fnprof(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;
    PDEBUG_CLIENT Profiler = NULL;
    PDEBUG_CONTROL ProfCtrl = NULL;
    PDEBUG_BREAKPOINT Bp = NULL;
    static ULONG s_BpId = DEBUG_ANY_ID;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    while (*Args == ' ' || *Args == '\t')
    {
        Args++;
    }
    if (!*Args)
    {
        goto Exit;
    }

    if (!_strcmpi(Args, "-end"))
    {
        ULONG64 Offset;
        char OffsetExpr[512];
        
        if (s_BpId == DEBUG_ANY_ID)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }
        
        if ((Status = g_FnProfCallbacks.GetControl()->
             GetBreakpointById(s_BpId, &Bp)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Bp->GetOffset(&Offset)) != S_OK)
        {
            Offset = DEBUG_INVALID_OFFSET;
        }
        if ((Status = Bp->GetOffsetExpression(OffsetExpr,
                                              sizeof(OffsetExpr),
                                              NULL)) != S_OK)
        {
            goto Exit;
        }

        ExtOut("%s ", OffsetExpr);
        if (Offset != DEBUG_INVALID_OFFSET)
        {
            ExtOut("(%p) ", Offset);
        }
        ExtOut("was hit %d times\n", g_FnProfCallbacks.GetHits());

        g_FnProfCallbacks.GetControl()->RemoveBreakpoint(Bp);
        Bp = NULL;
        s_BpId = DEBUG_ANY_ID;
        g_FnProfCallbacks.Uninitialize();
    }
    else
    {
        if (s_BpId != DEBUG_ANY_ID)
        {
            Status = E_UNEXPECTED;
            goto Exit;
        }
        
        if ((Status = Client->CreateClient(&Profiler)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Profiler->SetEventCallbacks(&g_FnProfCallbacks)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Profiler->QueryInterface(__uuidof(IDebugControl),
                                               (void **)&ProfCtrl)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = ProfCtrl->AddBreakpoint(DEBUG_BREAKPOINT_CODE,
                                              DEBUG_ANY_ID, &Bp)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Bp->SetOffsetExpression(Args)) != S_OK)
        {
            goto Exit;
        }
        
        if ((Status = Bp->AddFlags(DEBUG_BREAKPOINT_ADDER_ONLY |
                                   DEBUG_BREAKPOINT_ENABLED)) != S_OK)
        {
            goto Exit;
        }

        if ((Status = Bp->GetId(&s_BpId)) != S_OK)
        {
            goto Exit;
        }
        
        g_FnProfCallbacks.Uninitialize();
        if ((Status = g_FnProfCallbacks.Initialize(Profiler,
                                                   ProfCtrl)) != S_OK)
        {
            goto Exit;
        }

        ExtOut("Added breakpoint %d on %s\n", s_BpId, Args);
        Bp = NULL;
    }

 Exit:
    if (Bp != NULL)
    {
        if (ProfCtrl != NULL)
        {
            ProfCtrl->RemoveBreakpoint(Bp);
        }
        else
        {
            Bp->Release();
        }
    }
    EXT_RELEASE(ProfCtrl);
    EXT_RELEASE(Profiler);
    if (Status != S_OK)
    {
        ExtErr("Unable to profile, 0x%X\n", Status);
        g_FnProfCallbacks.Uninitialize();
    }

    ExtRelease();
    return Status;
}

extern "C" HRESULT CALLBACK
vtrans(PDEBUG_CLIENT Client, PCSTR Args)
{
    HRESULT Status;

    if ((Status = ExtQuery(Client)) != S_OK)
    {
        return Status;
    }

    if (g_ExtData2 != NULL)
    {
        ULONG64 PhysOffs[8];
        ULONG Levels;
        DEBUG_VALUE Virt;
        
        if ((Status = g_ExtControl->
             Evaluate(Args, DEBUG_VALUE_INT64, &Virt, NULL)) == S_OK)
        {
            Status = g_ExtData2->
                GetVirtualTranslationPhysicalOffsets(Virt.I64, PhysOffs,
                                                     sizeof(PhysOffs) /
                                                     sizeof(PhysOffs[0]),
                                                     &Levels);
            if (SUCCEEDED(Status))
            {
                ULONG i;

                ExtOut("%I64X translates in %d levels:\n",
                       Virt.I64, Levels);
                for (i = 0; i < Levels; i++)
                {
                    ExtOut("  %I64X\n", PhysOffs[i]);
                }
            }
            else
            {
                ExtErr("Unable to translate %I64X, 0x%X\n",
                       Virt.I64, Status);
            }
        }
        else
        {
            ExtErr("Unable to evaluate '%s', 0x%X\n", Args, Status);
        }
    }
    else
    {
        ExtErr("Debugger does not support IDebugDataSpaces2\n");
    }

    ExtRelease();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extdll\extapis.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    extapis.cpp

Abstract:
    Procedures exported by the dll which can be called by
    other extension dlls and debugger

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 2/1/2001

--*/

#include "precomp.h"
#include <time.h>


PCHAR gTargetMode[] = {
    "No Target",
    "Kernel Mode",
    "User Mode",
};

PCHAR gAllOsTypes[] = {
    "Windows 95",
    "Windows 98",
    "Windows ME",
    "Windows NT 4",
    "Windows 2000",
    "Windows XP",
};

HRESULT
GetProcessorInfo(
    PCPU_INFO pCpuInfo
    )
{
    HRESULT Hr;
    ULONG Processor;
    ULONG i;
    DEBUG_PROCESSOR_IDENTIFICATION_ALL ProcId;

    pCpuInfo->Type = TargetMachine;
    if (g_ExtControl->GetNumberProcessors(&pCpuInfo->NumCPUs) != S_OK) {
        pCpuInfo->NumCPUs = 0;
    }
    
    PDEBUG_SYSTEM_OBJECTS DebugSystem;
    ULONG64 hCurrentThread;

    if ((Hr = g_ExtClient->QueryInterface(__uuidof(IDebugSystemObjects),
                                          (void **)&DebugSystem)) != S_OK) {
        return Hr;
    }
    DebugSystem->GetCurrentThreadHandle(&hCurrentThread);
    
    DebugSystem->Release();

    pCpuInfo->CurrentProc = (ULONG) hCurrentThread - 1;
    
    for (i=0; i<pCpuInfo->NumCPUs; i++) {
        // Get Info for all procs
        if ((Hr = g_ExtData->ReadProcessorSystemData(i,
                                                     DEBUG_DATA_PROCESSOR_IDENTIFICATION,
                                                     &pCpuInfo->ProcInfo[i], 
                                                     sizeof(pCpuInfo->ProcInfo[i]), NULL)) != S_OK) {
            continue;
        }

    }
    return Hr;
}

void
GetOsType(ULONG PlatForm, PTARGET_DEBUG_INFO pTargetInfo)
{
    if (PlatForm == VER_PLATFORM_WIN32_NT) 
    // If its nt target
    {
        if (pTargetInfo->OsInfo.Version.Minor > 2195) {
            pTargetInfo->OsInfo.Type = WIN_NT5_1;
        } else if (pTargetInfo->OsInfo.Version.Minor > 1381) {
            pTargetInfo->OsInfo.Type = WIN_NT5;
        } else {
            pTargetInfo->OsInfo.Type = WIN_NT4;
        }
    } else {
        if (pTargetInfo->OsInfo.Version.Minor > 2222) {
            pTargetInfo->OsInfo.Type = WIN_ME;
        } else if (pTargetInfo->OsInfo.Version.Minor > 950) {
            pTargetInfo->OsInfo.Type = WIN_98;
        } else if (pTargetInfo->OsInfo.Version.Minor > 950) {
            pTargetInfo->OsInfo.Type = WIN_95;
        }
    }
}


HRESULT
FillTargetDebugInfo(
    PDEBUG_CLIENT Client,
    PTARGET_DEBUG_INFO pTargetInfo
    )
{
    HRESULT Hr;
    ULONG Time;
    ULONG PlatForm, Qualifier;

    if (pTargetInfo->SizeOfStruct != sizeof(TARGET_DEBUG_INFO)) {
        return E_FAIL;
    }
    ZeroMemory(pTargetInfo, sizeof(TARGET_DEBUG_INFO));
    pTargetInfo->SizeOfStruct = sizeof(TARGET_DEBUG_INFO);
    
    INIT_API();

    pTargetInfo->Mode = (TARGET_MODE) g_TargetClass;
    Hr = GetProcessorInfo(&pTargetInfo->Cpu);
    
    Hr = g_ExtControl2->GetCurrentSystemUpTime(&Time);
    if (Hr == S_OK) {
        pTargetInfo->SysUpTime = Time;
    }
    
    PDEBUG_SYSTEM_OBJECTS2 DebugSystem;
    ULONG64 hCurrentThread;

    if ((Hr = g_ExtClient->QueryInterface(__uuidof(IDebugSystemObjects),
                                          (void **)&DebugSystem)) == S_OK) {
        Hr = DebugSystem->GetCurrentProcessUpTime(&Time);


        DebugSystem->Release();
        if (Hr == S_OK) {
            pTargetInfo->AppUpTime = Time;
        }
    }
    Hr = g_ExtControl2->GetCurrentTimeDate(&Time);
    if (Hr == S_OK) {
        pTargetInfo->CrashTime = Time;
    }

    time_t ltime;
    time( &ltime );
   
    pTargetInfo->EntryDate = (ULONG64) ltime;

    Hr = g_ExtControl->GetSystemVersion(&PlatForm, 
                                        &pTargetInfo->OsInfo.Version.Major,
                                        &pTargetInfo->OsInfo.Version.Minor,
                                        &pTargetInfo->OsInfo.ServicePackString[0],
                                        sizeof(pTargetInfo->OsInfo.ServicePackString),
                                        NULL,
                                        &pTargetInfo->OsInfo.SrvPackNumber,
                                        &pTargetInfo->OsInfo.OsString[0],
                                        sizeof(pTargetInfo->OsInfo.OsString),
                                        NULL);
    GetOsType(PlatForm, pTargetInfo);
    pTargetInfo->Source = Debugger;
    
    EXIT_API();
    return Hr;
}

HRESULT WINAPI
_EFN_GetTargetInfo
   (
    PDEBUG_CLIENT  Client,
    PTARGET_DEBUG_INFO pTargetInfo
    )
{
    return FillTargetDebugInfo(Client, pTargetInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\critsect.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    critsect.c

Abstract:

    Critical section debugger extension for both ntsd and kd.

Author:

    Daniel Mihai (DMihai) 8-Feb-2001

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/////////////////////////////////////////////////////////////////////
BOOL
ReadStructFieldVerbose( ULONG64 AddrStructBase,
                        PCHAR StructTypeName,
                        PCHAR StructFieldName,
                        PVOID Buffer,
                        ULONG BufferSize )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset
    //

    ErrorCode = GetFieldOffset (StructTypeName,
                                StructFieldName,
                                &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        Success = ReadMemory (AddrStructBase + FieldOffset,
                              Buffer,
                              BufferSize,
                              NULL );

        if (Success != TRUE) {

            dprintf ("Cannot read structure field value at 0x%p, error %u\n",
                     AddrStructBase + FieldOffset,
                     ErrorCode );
        }
    }
    else {

        dprintf ("Cannot get field offset of %s in %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////////////
BOOL
ReadPtrStructFieldVerbose( ULONG64 AddrStructBase,
                           PCHAR StructTypeName,
                           PCHAR StructFieldName,
                           PULONG64 Buffer )
{
    ULONG FieldOffset;
    ULONG ErrorCode;
    BOOL Success;

    Success = FALSE;

    //
    // Get the field offset inside the structure 
    //

    ErrorCode = GetFieldOffset ( StructTypeName,
                                 StructFieldName,
                                 &FieldOffset );

    if (ErrorCode == S_OK) {

        //
        // Read the data
        //

        ErrorCode = ReadPtr( AddrStructBase + FieldOffset,
                             Buffer );

        if (ErrorCode != S_OK) {

            dprintf( "Cannot read structure field value at 0x%p, error %u\n",
                     AddrStructBase + FieldOffset,
                     ErrorCode );
        }
        else {

            Success = TRUE;
        }
    }
    else {

        dprintf( "Cannot get field offset of %s in structure %s, error %u\n",
                 StructFieldName,
                 StructTypeName,
                 ErrorCode );
    }

    return Success;
}

/////////////////////////////////////////////////////////////////////////////
ULONG64
GetStackTraceAddress( ULONG StackTraceIndex,
                      ULONG PointerSize )
{
    ULONG64 TraceDatabaseAddress;
    ULONG64 TraceDatabase;
    ULONG64 EntryIndexArray;
    ULONG64 StackTraceAddress;
    ULONG64 StackTraceToDump;
    ULONG NumberOfEntriesAdded;
    ULONG ErrorCode;
    BOOL Success;

    StackTraceToDump = 0;

    //
    // Stack trace database address
    //

    TraceDatabaseAddress = GetExpression("&NTDLL!RtlpStackTraceDataBase");
    
    if ( TraceDatabaseAddress == 0 ) {
        dprintf( "!cs: Unable to resolve NTDLL!RtlpStackTraceDataBase\n"
                 "Please check your symbols\n" );

        goto Done;
    }

    ErrorCode = ReadPtr (TraceDatabaseAddress,
                         &TraceDatabase );

    if (ErrorCode != S_OK) {

        dprintf( "!cs: Cannot read pointer at NTDLL!RtlpStackTraceDataBase\n" );
        
        goto Done;
    }
    else if (TraceDatabase == 0) {

        dprintf( "NTDLL!RtlpStackTraceDataBase is NULL. Probably the stack traces are not enabled.\n" );

        goto Done;
    }

    //
    // Read the number of entries in the database
    //

    Success = ReadStructFieldVerbose (TraceDatabase,
                                      "NTDLL!_STACK_TRACE_DATABASE",
                                      "NumberOfEntriesAdded",
                                      &NumberOfEntriesAdded,
                                      sizeof( NumberOfEntriesAdded ) );

    if( Success == FALSE ) {

        dprintf( "Cannot read the number of stack traces database entries\n" );
        goto Done;
    }
    else if( StackTraceIndex == 0 ) {

        dprintf( "No stack trace found.\n" );
        goto Done;
    } 
    else if( NumberOfEntriesAdded < StackTraceIndex ) {

        dprintf( "Stack trace index 0x%X is invalid, current number of stack traces is 0x%X\n",
                 StackTraceIndex,
                 NumberOfEntriesAdded );
        goto Done;
    }

    //
    // Find the array of stack traces
    //

    Success = ReadPtrStructFieldVerbose (TraceDatabase,
                                         "NTDLL!_STACK_TRACE_DATABASE",
                                         "EntryIndexArray",
                                         &EntryIndexArray );

    if( Success == FALSE ) {

        dprintf( "Cannot read the stack database array address\n" );
        goto Done;
    }
   
    //
    // Compute the address of our stack trace pointer
    //

    StackTraceAddress = EntryIndexArray - StackTraceIndex * PointerSize;

    //
    // Read the pointer to our trace entry in the array
    //

    ErrorCode = ReadPtr (StackTraceAddress,
                         &StackTraceToDump );

    if (ErrorCode != S_OK) {

        dprintf( "Cannot read stack trace address at 0x%p\n",
                 StackTraceAddress );

        StackTraceToDump = 0;
    }

Done:

    return StackTraceToDump;
}

//////////////////////////////////////////////////////////////////////
VOID
DumpStackTraceAtAddress (ULONG64 StackTraceAddress,
                         ULONG PointerSize)
{
    ULONG64 CrtTraceAddress;
    ULONG64 CodeAddress;
    ULONG64 Displacement;
    ULONG ErrorCode;
    ULONG BackTraceFieldOffset;
    USHORT Depth;
    USHORT CrtEntryIndex;
    BOOL Success;
    CHAR Symbol[ 1024 ];

    //
    // Read the stack trace depth
    //

    Success = ReadStructFieldVerbose (StackTraceAddress,
                                      "NTDLL!_RTL_STACK_TRACE_ENTRY",
                                      "Depth",
                                      &Depth,
                                      sizeof( Depth ));

    if( Success == FALSE ) {

        dprintf ("!cs: Cannot read depth for stack trace at 0x%p\n",
                 StackTraceAddress);

        goto Done;
    }

    //
    // Limit the depth to 20 to protect ourselves from corrupted data
    //

    Depth = __min( Depth, 20 );

    //
    // Get a pointer to the BackTrace array
    //

    ErrorCode = GetFieldOffset ("NTDLL!_RTL_STACK_TRACE_ENTRY",
                                "BackTrace",
                                &BackTraceFieldOffset);

    if (ErrorCode != S_OK) {

        dprintf ("!cs: Cannot get the BackTrace field offset\n");
        goto Done;
    }

    CrtTraceAddress = StackTraceAddress + BackTraceFieldOffset;

    //
    // Dump this stack trace
    //

    for( CrtEntryIndex = 0; CrtEntryIndex < Depth; CrtEntryIndex += 1 ) {

        ErrorCode = ReadPtr (CrtTraceAddress,
                             &CodeAddress );

        if (ErrorCode != S_OK) {

            dprintf ("!cs: Cannot read address at 0x%p\n",
                     CrtTraceAddress );
        }

        GetSymbol( CodeAddress,
                   Symbol,
                   &Displacement);

        dprintf ("0x%p: %s+0x%I64X\n",
                 CodeAddress,
                 Symbol,
                 Displacement );

        CrtTraceAddress += PointerSize;
    }

Done:
    
    NOTHING;
}

//////////////////////////////////////////////////////////////////////

BOOL
DumpCriticalSection ( ULONG64 AddrCritSec,  
                      ULONG64 AddrEndCritSect,
                      ULONG64 AddrDebugInfo,
                      BOOL DumpStackTrace )
{
    ULONG64 DebugInfo;
    ULONG64 OtherDebugInfo;
    ULONG64 CritSec;
    ULONG64 SpinCount;
    ULONG64 OwningThread;
    ULONG64 LockSemaphore;
    ULONG64 StackTraceAddress;
    ULONG64 Displacement;
    LONG LockCount;
    LONG RecursionCount;
    USHORT CreatorBackTraceIndex;
    ULONG PointerSize;
    ULONG DebugInfoFieldOffset;
    ULONG CriticalSectionFieldOffset;
    ULONG ErrorCode;
    BOOL HaveGoodSymbols;
    BOOL Success;
    CHAR Symbol[1024];

    HaveGoodSymbols = FALSE;

    //
    // The caller must supply at least one of the 
    // critical section or debug information address.
    //

    if (AddrCritSec == 0 && AddrDebugInfo == 0) {

        dprintf ("Internal debugger extension error: Both critical section and debug info are NULL\n");
        goto Done;
    }

    //
    // Get the field offsets for various structures and check if we have
    // good symbols, with type information.
    //

    ErrorCode = GetFieldOffset ("NTDLL!_RTL_CRITICAL_SECTION",
                                "DebugInfo",
                                &DebugInfoFieldOffset );

    if (ErrorCode != S_OK)
    {
        dprintf( "Bad symbols for NTDLL (error %u). Aborting.\n",
                 ErrorCode );
        goto Done;
    }

    ErrorCode = GetFieldOffset ("NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                "CriticalSection",
                                &CriticalSectionFieldOffset );

    if (ErrorCode != S_OK)
    {
        dprintf( "Bad symbols for NTDLL (error %u). Aborting.\n",
                 ErrorCode );
        goto Done;
    }

    //
    // Get the size of a pointer
    //

    PointerSize = GetTypeSize ("ntdll!PVOID");

    if (PointerSize == 0) {

        dprintf ("Cannot get the pointer size.\n");
        goto Done;
    }

    HaveGoodSymbols = TRUE;

    //
    // Read all the rest of the information we need
    //

    CritSec = AddrCritSec;
    DebugInfo = AddrDebugInfo;

    if (AddrCritSec == 0 || (AddrEndCritSect != 0 && AddrDebugInfo != 0)) {

        //
        // Read the critical section address
        //

        ErrorCode = ReadPtr (AddrDebugInfo + CriticalSectionFieldOffset,
                             &CritSec );

        if (ErrorCode != S_OK)
        {
            dprintf ("Cannot read the critical section address at 0x%p.\n"
                     "The memory is probably paged out or the active critical section list is corrupted.\n",
                     AddrDebugInfo + CriticalSectionFieldOffset );

            //
            // We don't have any useful information to dump 
            // since we can't read the address of the critical section structure.
            //
            // Just display the stack trace since the active critical section list
            // might be corrupted.
            //

            DumpStackTrace = TRUE;

            goto DisplayStackTrace;
        }

        if (AddrCritSec != 0 ) {

            //
            // We are dumpig all the critical sections in a range.
            //

            if (CritSec < AddrCritSec || CritSec > AddrEndCritSect) {

                //
                // We don't want to display this critical section
                // because it is out of the range.
                //

                goto Done;
            }
        }
        
        //
        // Read the the critical section address from the DebugInfo
        //

        dprintf( "-----------------------------------------\n" );

        dprintf ("DebugInfo          = 0x%p\n",
                 AddrDebugInfo );

        GetSymbol( CritSec,
                   Symbol,
                   &Displacement);

        dprintf ("Critical section   = 0x%p (%s+0x%I64X)\n",
                 CritSec,
                 Symbol,
                 Displacement );
    }
    else {
        
        //
        // We have the critical section address from our caller
        //

        GetSymbol( CritSec,
                   Symbol,
                   &Displacement);

        dprintf( "-----------------------------------------\n" );

        dprintf ("Critical section   = 0x%p (%s+0x%I64X)\n",
                 AddrCritSec, 
                 Symbol,
                 Displacement );
        
        if ( DebugInfo == 0 ) {

            //
            // Read the DebugInfo address from the critical section structure
            //

            ErrorCode = ReadPtr (AddrCritSec + DebugInfoFieldOffset,
                                 &DebugInfo );

            if (ErrorCode != S_OK) {

                dprintf ("Cannot read DebugInfo adddress at 0x%p. Possible causes:\n"
                         "\t- The critical section is not initialized, deleted or corrupted\n"
                         "\t- The critical section was a global variable in a DLL that was unloaded\n"
                         "\t- The memory is paged out\n",
                         AddrCritSec + DebugInfoFieldOffset );
            }
        }

        if (DebugInfo != 0) {

            dprintf ("DebugInfo          = 0x%p\n",
                     DebugInfo );
        }
    }

    //
    // Read all the rest of the fields of this critical section
    //

    Success = ReadStructFieldVerbose (CritSec,
                                      "NTDLL!_RTL_CRITICAL_SECTION",
                                      "LockCount",
                                      &LockCount,
                                      sizeof( LockCount ) );

    if( Success != TRUE )
    {
        //
        // Couldn't read the LockCount so we cannot say if it's 
        // locked or not. This can happen especially in stress where everything is
        // paged out because of memory pressure.
        //

        dprintf ("Cannot determine if the critical section is locked or not.\n" );

        goto DisplayStackTrace;
    }
    
    //
    // Determine if the critical section is locked or not
    //

    if (LockCount == -1) {

        //
        // The critical section is not locked 
        //

        dprintf ("NOT LOCKED\n");
    }
    else {

        //
        // The critical section is currently locked
        //

        dprintf ("LOCKED\n"
                 "LockCount          = 0x%X\n",
                 LockCount );

        //
        // OwningThread 
        //

        Success = ReadPtrStructFieldVerbose( CritSec,
                                             "NTDLL!_RTL_CRITICAL_SECTION",
                                             "OwningThread",
                                             &OwningThread);

        if (Success != FALSE)
        {
            dprintf ("OwningThread       = 0x%p\n",
                     OwningThread );
        }

        //
        // RecursionCount 
        //

        Success = ReadStructFieldVerbose( CritSec,
                                          "NTDLL!_RTL_CRITICAL_SECTION",
                                          "RecursionCount",
                                          &RecursionCount,
                                          sizeof( RecursionCount ) );

        if (Success != FALSE)
        {
            dprintf ("RecursionCount     = 0x%X\n",
                     RecursionCount);
        }
    }

    //
    // LockSemaphore 
    //

    Success = ReadStructFieldVerbose (CritSec,
                                      "NTDLL!_RTL_CRITICAL_SECTION",
                                      "LockSemaphore",
                                      &LockSemaphore,
                                      sizeof( LockSemaphore ));

    if (Success != FALSE)
    {
        dprintf ("LockSemaphore      = 0x%X\n",
                 LockSemaphore );
    }

    //
    // SpinCount 
    //

    Success = ReadPtrStructFieldVerbose (CritSec,
                                         "NTDLL!_RTL_CRITICAL_SECTION",
                                         "SpinCount",
                                         &SpinCount);

    if (Success != FALSE)
    {
        dprintf ("SpinCount          = 0x%p\n",
                 SpinCount );
    }

    //
    // Simple checks for orphaned critical sections
    //

    if (AddrDebugInfo != 0) {

        //
        // AddrDebugInfo is a DebugInfo address from the active list.
        // Verify that the critical section's DebugInfo is pointing 
        // back to AddrDebugInfo.
        //

        Success = ReadPtrStructFieldVerbose (CritSec,
                                             "NTDLL!_RTL_CRITICAL_SECTION",
                                             "DebugInfo",
                                             &OtherDebugInfo );

        if (Success != FALSE && OtherDebugInfo != AddrDebugInfo)
        {
            dprintf ("\nWARNING: critical section DebugInfo = 0x%p doesn't point back\n"
                     "to the DebugInfo found in the active critical sections list = 0x%p.\n"
                     "The critical section was probably reused without calling DeleteCriticalSection.\n\n",
                     OtherDebugInfo,
                     AddrDebugInfo );

            Success = ReadStructFieldVerbose (OtherDebugInfo,
                                              "NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                              "CreatorBackTraceIndex",
                                              &CreatorBackTraceIndex,
                                              sizeof( CreatorBackTraceIndex ) );

            StackTraceAddress = GetStackTraceAddress (CreatorBackTraceIndex,
                                                      PointerSize );

            if (StackTraceAddress != 0)
            {
                dprintf ("\nStack trace for DebugInfo = 0x%p:\n\n",
                         OtherDebugInfo );

                DumpStackTraceAtAddress (StackTraceAddress,
                                         PointerSize);
            }

            //
            // Dump the second stack trace too
            // 

            DumpStackTrace = TRUE;
        }
    }

DisplayStackTrace:

    if (!DumpStackTrace) {

        goto Done;
    }

    //
    // Dump the initialization stack trace for this critical section
    //

    Success = ReadStructFieldVerbose (DebugInfo,
                                      "NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                      "CreatorBackTraceIndex",
                                      &CreatorBackTraceIndex, 
                                      sizeof (CreatorBackTraceIndex));

    if (Success != FALSE) {

        StackTraceAddress = GetStackTraceAddress (CreatorBackTraceIndex,
                                                  PointerSize );

        if (StackTraceAddress != 0)
        {
            dprintf ("\n\nStack trace for DebugInfo = 0x%p:\n\n",
                     DebugInfo );

            DumpStackTraceAtAddress (StackTraceAddress,
                                     PointerSize);
        }
    }

Done:
    
    return HaveGoodSymbols;
}

/////////////////////////////////////////////////////////////////////////////
VOID
DisplayHelp( VOID )
{
    dprintf( "!cs [-s]                      - dump all the active critical sections in the current process.\n" );
    dprintf( "!cs [-s] address              - dump critical section at this address.\n" );
    dprintf( "!cs [-s] address1 address2    - dump all the active critical sections in this range.\n" );
    dprintf( "!cs [-s] -d address           - dump critical section corresponding to DebugInfo at this address.\n" );
    dprintf( "\n\"-s\" will dump the critical section initialization stack trace if it's available.\n" );
}

/////////////////////////////////////////////////////////////////////////////
DECLARE_API( cs )

/*++

Routine Description:

    Dump critical sections (both Kernel and User Debugger)

Arguments:

    args - [address] [options]

Return Value:

    None

--*/
{
    ULONG64 AddrCritSec;
    ULONG64 AddrEndCritSect;
    ULONG64 AddrDebugInfo;
    ULONG64 AddrListHead;
    ULONG64 ListHead;
    ULONG64 Next;
    LPCSTR Current;
    LPCSTR NextParam;
    BOOL StackTraces = FALSE;
    BOOL HaveGoodSymbols;
    ULONG ErrorCode;
    ULONG ProcessLocksListFieldOffset;

    INIT_API();

    AddrDebugInfo = 0;
    AddrCritSec = 0;
    AddrEndCritSect = 0;

    //
    // Parse the command line arguments for:
    //
    // -s : dump initialization stack traces
    // -d : find the critical section using a DebugInfo pointer
    //

    for (Current = args; *Current != '\0'; Current += 1) {

        if (*Current == '-') {

            Current += 1;
            switch (*Current) {
                case '?':
                case 'h':
                case 'H':
                    
                    //
                    // Need some help.
                    //
                    
                    DisplayHelp();
                    
                    goto Done;


                case 's':
                case 'S':
                    
                    //
                    // Dump stack traces
                    //

                    StackTraces = TRUE;

                    if(*( Current + 1 ) != '\0') {

                        Current += 1;
                    }

                    break;

                case 'd':
                case 'D':

                    //
                    // The next parameter should be the DebugInfo
                    //

                    do {

                        Current += 1;
                    } 
                    while (*Current == ' ');

                    AddrDebugInfo = GetExpression(Current);

                    if (AddrDebugInfo == 0) {

                        dprintf("!cs: expected DebugInfo address after -d\n");

                        //
                        // Decrement Current since the for loop will increment it again.
                        // Otherwise, if this is the end of the string we will overrun
                        // the args buffer.
                        //

                        Current -= 1;

                        goto Done;
                    }
                    else {

                        goto DoneParsingArguments;
                    }

                    break;

                case ' ':
                    Current += 1;
                    break;
        
                default:
                    dprintf ("!cs: invalid option flag '-%c'\n", 
                             *Current);
                    break;
            }
        }
        else if(*Current == ' ') {

            Current ++;
        }
        else {

            break;
        }
    }

DoneParsingArguments:

    if( AddrDebugInfo == 0 )
    {
        //
        // If the user doesn't want us to use a DebugInfo
        // then he might have asked us to dump a critical section
        //

        if (*Current != '\0')
        {
            AddrCritSec = GetExpression(Current);

            if (AddrCritSec != 0) {

                //
                // We might have an additional argument if the user
                // wants to dump all the active critical sections in 
                // an address range.
                //

                NextParam = strchr (Current,
                                    ' ' );

                if (NextParam != NULL) {

                    AddrEndCritSect = GetExpression(NextParam);
                }
            }
        }
    }

    //
    // Start the real work
    //

    if ((AddrCritSec != 0 && AddrEndCritSect == 0) || AddrDebugInfo != 0)
    {
        //
        // The user wants details only about this critical section
        //

        DumpCriticalSection (AddrCritSec,        // critical section address
                             0,                  // end of address range if we are searching for critical sections
                             AddrDebugInfo,      // debug info address
                             StackTraces );      // dump the stack trace
    }
    else
    {
        //
        // Get the offset of the list entry in the DebugInfo structure
        //

        ErrorCode = GetFieldOffset ("NTDLL!_RTL_CRITICAL_SECTION_DEBUG",
                                    "ProcessLocksList",
                                    &ProcessLocksListFieldOffset );

        if (ErrorCode != S_OK) {

            dprintf ("Bad symbols for NTDLL (error %u). Aborting.\n",
                     ErrorCode );
            goto Done;
        }

        //
        // Parse all the critical sections list
        //

        //
        // Locate the address of the list head.
        //

        AddrListHead = GetExpression ("&NTDLL!RtlCriticalSectionList");
        
        if (AddrListHead == 0 ) {

            dprintf( "!cs: Unable to resolve NTDLL!RtlCriticalSectionList\n"
                     "Please check your symbols\n" );

            goto Done;
        }

        //
        // Read the list head
        //

        ErrorCode = ReadPtr(AddrListHead,
                            &ListHead );

        if (ErrorCode != S_OK) {

            dprintf( "!cs: Unable to read memory at NTDLL!RtlCriticalSectionList\n" );
            goto Done;
        }

        Next = ListHead;

        while (Next != AddrListHead) {

            if (CheckControlC()) {

                break;
            }

            HaveGoodSymbols = DumpCriticalSection (
                                 AddrCritSec,                             // critical section address
                                 AddrEndCritSect,                         // end of address range if we are searching for critical sections
                                 Next - ProcessLocksListFieldOffset,      // debug info address
                                 StackTraces );                           // dump the stack trace

            //
            // Read the pointer to Next element from the list
            //

            if( HaveGoodSymbols == FALSE )
            {
                break;
            }

            ErrorCode = ReadPtr (Next,
                                 &Next );

            if (ErrorCode != S_OK) {

                dprintf ("!cs: Unable to read list entry at 0x%p - aborting.\n",
                         Next);
                goto Done;
            }
        }
    }

Done:

    EXIT_API();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\atom.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    atom.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define MAXINTATOM 0xC000

VOID
AtomExtension(
    PCSTR lpArgumentString
    );

VOID DumpAtomTable(
    ULONG64 ppat,
    ULONG a
    );

DECLARE_API( atom )

/*++

Routine Description:

    This function is called as an NTSD extension to dump a user mode atom table

    Called as:

        !atom [address]

    If an address if not given or an address of 0 is given, then the
    process atom table is dumped.

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
//    AtomExtension( args );
//                           Copied its code here :-
    ULONG64 ppat, pat;
    ULONG a;
    INIT_API();
    try {
        while (*args == ' ') {
            args++;
        }

        if (*args && *args != 0xa) {
            a = (ULONG) GetExpression((LPSTR)args);
        } else {
            a = 0;
        }

        ppat = GetExpression("kernel32!BaseLocalAtomTable");
        if ((ppat != 0) &&
            ReadPointer(ppat, &pat)) {
            dprintf("\nLocal atom table ");
            DumpAtomTable(ppat, a);
            dprintf("Use 'dt _RTL_ATOM_TABLE %p'.\n", ppat);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
    EXIT_API();
    return S_OK;
}

CHAR szBaseLocalAtomTable[] = "kernel32!BaseLocalAtomTable";

VOID DumpAtomTable(
    ULONG64 ppat,
    ULONG a
    )
{
    ULONG64 pat;
    ULONG64 pate;
    ULONG iBucket, NumberOfBuckets, PtrSize, Off, NameOff;
    LPWSTR pwsz;
    BOOL fFirst;

    ReadPointer(ppat, &pat);
    if (pat == 0) {
        dprintf("is not initialized.\n");
        return;
    }
    
    if (InitTypeRead(pat, _RTL_ATOM_TABLE)) {
        return;
    }
    if (a) {
        dprintf("\n");
    } else {
        dprintf("at %x\n", pat);
    }
    NumberOfBuckets = (ULONG) ReadField(NumberOfBuckets);

    GetFieldOffset("_RTL_ATOM_TABLE", "Buckets", &Off);
    GetFieldOffset("_RTL_ATOM_TABLE", "Name", &NameOff);
    PtrSize = IsPtr64() ? 8 : 4;

    for (iBucket = 0; iBucket < NumberOfBuckets; iBucket++) {
        ReadPointer(pat + iBucket * PtrSize + Off, &pate);
        
        if (pate != 0 && !a) {
            dprintf("Bucket %2d:", iBucket);
        }
        fFirst = TRUE;
        while (pate != 0) {
            ULONG NameLength;

            if (!fFirst && !a) {
                dprintf("          ");
            }
            fFirst = FALSE;
            if (InitTypeRead(pate, _RTL_ATOM_TABLE_ENTRY)) {
                return;
            }
            NameLength = (ULONG) ReadField(NameLength);
            pwsz = (LPWSTR)LocalAlloc(LPTR, ((NameLength) + 1) * sizeof(WCHAR));
            ReadMemory(pate + NameOff, pwsz, NameLength * sizeof(WCHAR), NULL);
            pwsz[NameLength ] = L'\0';
            if (a == 0 || a == ((ULONG)ReadField(HandleIndex) | MAXINTATOM)) {
                dprintf("%hx(%2d) = %ls (%d)%s\n",
                        (ATOM)((ULONG)ReadField(HandleIndex) | MAXINTATOM),
                        (ULONG)ReadField(ReferenceCount),
                        pwsz, (NameLength),
                        (ULONG)ReadField(Flags) & RTL_ATOM_PINNED ? " pinned" : "");

                if (a) {
                    LocalFree(pwsz);
                    return;
                }
            }
            LocalFree(pwsz);
            if (pate == ReadField(HashLink)) {
                dprintf("Bogus hash link at %p\n", pate);
                break;
            }
            pate = ReadField(HashLink);
        }
    }
    if (a)
        dprintf("\n");
}


VOID
AtomExtension(
    PCSTR lpArgumentString
    )
{
    ULONG64 ppat;
    ULONG a;

    try {
        while (*lpArgumentString == ' ') {
            lpArgumentString++;
        }

        if (*lpArgumentString && *lpArgumentString != 0xa) {
            a = (ATOM)GetExpression((LPSTR)lpArgumentString);
        } else {
            a = 0;
        }

        ppat = GetExpression(szBaseLocalAtomTable);
        if (ppat != 0) {
            dprintf("\nLocal atom table ");
            DumpAtomTable(ppat, a);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\dlls.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    dlls.c

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
DllsExtension(
    PCSTR lpArgumentString,
    ULONG64 ProcessPeb
    );


DECLARE_API( dlls )

/*++

Routine Description:

    Dump user mode dlls (Kernel debugging)

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
    ULONG64 Process, Peb;
    
    INIT_API();
    GetPebAddress( 0, &Peb );
    DllsExtension( args, Peb );
    EXIT_API();
    return S_OK;

}

void 
ShowImageVersionInfo(
    ULONG64 DllBase
    )
{
    VS_FIXEDFILEINFO FixedVer;
    ULONG            SizeRead;
    CHAR             VersionBuffer[100];
    CHAR             FileStr[MAX_PATH]= {0};
    BOOL             ResFileVerStrOk = FALSE;
    BOOL             ResProdVerStrOk = FALSE;
    struct LANGANDCODEPAGE {
	WORD wLanguage;
	WORD wCodePage;
    } Translate;
    
    if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						  DllBase, "\\VarFileInfo\\Translation",
						  (PVOID) &Translate,
						  sizeof(Translate),
						  &SizeRead) == S_OK) {
	sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\CompanyName",
		Translate.wLanguage, Translate.wCodePage);

	if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						      DllBase, VersionBuffer,
						      (PVOID) &FileStr,
						      sizeof(FileStr),
						      &SizeRead) == S_OK) {
	    FileStr[SizeRead] = 0;
	    dprintf("      Company Name       %s\n", FileStr);
	}
	sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\ProductName",
		Translate.wLanguage, Translate.wCodePage);

	if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						      DllBase, VersionBuffer,
						      (PVOID) &FileStr,
						      sizeof(FileStr),
						      &SizeRead) == S_OK) {
	    FileStr[SizeRead] = 0;
	    dprintf("      Product Name       %s\n", FileStr);
	}
	sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\ProductVersion",
		Translate.wLanguage, Translate.wCodePage);

	if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						      DllBase, VersionBuffer,
						      (PVOID) &FileStr,
						      sizeof(FileStr),
						      &SizeRead) == S_OK) {
	    ResProdVerStrOk = TRUE;
	    FileStr[SizeRead] = 0;
	    dprintf("      Product Version    %s\n", FileStr);
	}
	sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\OriginalFilename",
		Translate.wLanguage, Translate.wCodePage);

	if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						      DllBase, VersionBuffer,
						      (PVOID) &FileStr,
						      sizeof(FileStr),
						      &SizeRead) == S_OK) {
	    FileStr[SizeRead] = 0;
	    dprintf("      Original Filename  %s\n", FileStr);
	}
	sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\FileDescription",
		Translate.wLanguage, Translate.wCodePage);

	if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						      DllBase, VersionBuffer,
						      (PVOID) &FileStr,
						      sizeof(FileStr),
						      &SizeRead) == S_OK) {
	    FileStr[SizeRead] = 0;
	    dprintf("      File Description   %s\n", FileStr);
	}
	sprintf(VersionBuffer, "\\StringFileInfo\\%04X%04X\\FileVersion",
		Translate.wLanguage, Translate.wCodePage);
	if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						      DllBase, VersionBuffer,
						      (PVOID) &FileStr,
						      sizeof(FileStr),
						      &SizeRead) == S_OK) {
	    FileStr[SizeRead] = 0;
	    dprintf("      File Version       %s\n", FileStr);
	    ResFileVerStrOk = TRUE;
	}                    
    }

    if (g_ExtSymbols->GetModuleVersionInformation(DEBUG_ANY_ID,
						  DllBase, "\\",
						  (PVOID) &FixedVer,
						  sizeof(FixedVer),
						  &SizeRead) == S_OK) {
	if (!ResFileVerStrOk) {
	    dprintf("      File version       %d.%d.%d.%d\n",
		    FixedVer.dwFileVersionMS >> 16,
		    FixedVer.dwFileVersionMS & 0xFFFF,
		    FixedVer.dwFileVersionLS >> 16,
		    FixedVer.dwFileVersionLS & 0xFFFF);

	}
	if (!ResProdVerStrOk) {
	    dprintf("      Product Version    %d.%d.%d.%d\n",
		    FixedVer.dwProductVersionMS >> 16,
		    FixedVer.dwProductVersionMS & 0xFFFF,
		    FixedVer.dwProductVersionLS >> 16,
		    FixedVer.dwProductVersionLS & 0xFFFF);
	}
    }
}

typedef enum {
    Memory = 1,
    Load = 2,
    Init = 3
} ELOAD_ORDER;

VOID
DllsExtension(
    PCSTR lpArgumentString,
    ULONG64 ProcessPeb
    )
{
    BOOL b;
    ULONG64 pLdrEntry;
    ULONG64 PebLdrAddress;
    ULONG   Offset;
    ULONG64 Next;
    WCHAR StringData[MAX_PATH+1];
    BOOL SingleEntry;
    BOOL DoHeaders;
    BOOL DoSections;
    BOOL DoAll;
    BOOL ShowVersionInfo;
    PSTR lpArgs = (PSTR)lpArgumentString;
    PSTR p;
    ULONG64 addrContaining = 0;
    ELOAD_ORDER OrderList = Load;
    ULONG64 OrderModuleListStart;
    ULONG64 DllBase;

    SingleEntry = FALSE;
    DoAll = FALSE;
    DoHeaders = FALSE;
    DoSections = FALSE;
    ShowVersionInfo = FALSE;

#if 0
    while ( lpArgumentString != NULL && *lpArgumentString ) {
        if (*lpArgumentString != ' ') {
            sscanf(lpArgumentString,"%lx",&pLdrEntry);
            SingleEntry = TRUE;
            goto dumpsingleentry;
            }

        lpArgumentString++;
        }
#endif

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
            }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = TRUE;
                    break;

                case 'c':   // dump only the dll containing the specified address
                case 'C':
                    lpArgs += 2;    // step over the c and the space.
                    addrContaining = GetExpression(lpArgs);

                    while (*lpArgs && (!isspace(*lpArgs))) {
                        lpArgs++;
                    }

                    if (addrContaining != 0) {
                        dprintf("Dump dll containing 0x%p:\n", addrContaining);
                    } else {
                        dprintf("-c flag requires and address arguement\n");
                        return;
                    }
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dlls [options] [address]\n");
                    dprintf("\n");
                    dprintf("Displays loader table entries.  Optionally\n");
                    dprintf("dumps image and section headers.\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -c nnn  Dump dll containing address nnn\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -i      Dump dll's in Init order\n");
                    dprintf("   -l      Dump dll's in Load order (the default)\n");
                    dprintf("   -m      Dump dll's in Memory order\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("   -v      Dump version info from resource section\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoHeaders = TRUE;
                    break;

                case 'm':   // dump in memory order
                case 'M':
                    ++lpArgs;
                    OrderList = Memory;
                    break;

                case 'i':   // dump in init order
                case 'I':
                    ++lpArgs;
                    OrderList = Init;
                    break;

                case 'l':   // dump in load order
                case 'L':
                    ++lpArgs;
                    OrderList = Load;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoSections = TRUE;
                    break;
                case 'v':
                case 'V':
		    ++lpArgs;
		    ShowVersionInfo = TRUE;
		    break;
                }

            }
        else if (*lpArgs) {
            CHAR c;

            if (SingleEntry) {
                dprintf("Invalid extra argument\n");
                return;
                }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
                }
            c = *p;
            *p = 0;

            pLdrEntry = GetExpression(lpArgs);
            SingleEntry = TRUE;

            *p = c;
            lpArgs=p;

            }

        }

    if (SingleEntry) {
        goto dumpsingleentry;
        }

    //
    // Capture PebLdrData
    //

    GetFieldValue(ProcessPeb, "PEB", "Ldr", PebLdrAddress);
    if (InitTypeRead(PebLdrAddress, PEB_LDR_DATA)) {
        dprintf( "    Unable to read PEB_LDR_DATA type at %p\n", PebLdrAddress );
        return;
    }

    //
    // Walk through the loaded module table and display all ldr data
    //

    switch (OrderList) {
    case Memory:
        GetFieldOffset("PEB_LDR_DATA","InMemoryOrderModuleList", &Offset);
        OrderModuleListStart = PebLdrAddress + Offset;
        Next = ReadField(InMemoryOrderModuleList.Flink);
        break;

    case Init:
        GetFieldOffset("PEB_LDR_DATA","InInitializationOrderModuleList", &Offset);
        OrderModuleListStart = PebLdrAddress + Offset;
        Next = ReadField(InInitializationOrderModuleList.Flink);
        break;

    default:
    case Load:
        GetFieldOffset("PEB_LDR_DATA","InLoadOrderModuleList", &Offset);
        OrderModuleListStart = PebLdrAddress + Offset;
        Next = ReadField(InLoadOrderModuleList.Flink);
        break;
    }

    while (Next != OrderModuleListStart) {
        if (CheckControlC()) {
            return;
            }

        
        switch (OrderList) {
        case Memory:
            GetFieldOffset("LDR_DATA_TABLE_ENTRY","InMemoryOrderLinks", &Offset);
            pLdrEntry = Next - Offset;
            break;

        case Init:
            GetFieldOffset("LDR_DATA_TABLE_ENTRY","InInitializationOrderLinks", &Offset);
            pLdrEntry = Next - Offset;
            break;

         default:
         case Load:
             GetFieldOffset("LDR_DATA_TABLE_ENTRY","InLoadOrderLinks", &Offset);
             pLdrEntry = Next - Offset;
             break;
        }

        //
        // Capture LdrEntry
        //
dumpsingleentry:


        if (InitTypeRead(pLdrEntry, LDR_DATA_TABLE_ENTRY)) {
            dprintf( "    Unable to read Ldr Entry at %p\n", pLdrEntry );
            return;
        }

        ZeroMemory( StringData, sizeof( StringData ) );
        b = ReadMemory( ReadField(FullDllName.Buffer),
                        StringData,
                        (ULONG) ReadField(FullDllName.Length),
                        NULL
                      );
        if (!b) {
            dprintf( "    Unable to read Module Name\n" );
            ZeroMemory( StringData, sizeof( StringData ) );
        }

        //
        // Dump the ldr entry data
        // (dump all the entries if no containing address specified)
        //
        if ((addrContaining == 0) ||
            ((ReadField(DllBase) <= addrContaining) &&
             (addrContaining <= (ReadField(DllBase) + ReadField(SizeOfImage)))
            )
           ) {
            ULONG Flags;

            dprintf( "\n" );
            dprintf( "0x%08p: %ws\n", pLdrEntry, StringData[0] ? StringData : L"Unknown Module" );
            dprintf( "      Base   0x%08p  EntryPoint  0x%08p  Size        0x%08p\n",
                     DllBase = ReadField(DllBase),
                     ReadField(EntryPoint),
                     ReadField(SizeOfImage)
                   );
            dprintf( "      Flags  0x%08x  LoadCount   0x%08x  TlsIndex    0x%08x\n",
                     Flags = (ULONG) ReadField(Flags),
                     (ULONG) ReadField(LoadCount),
                     (ULONG) ReadField(TlsIndex)
                   );

            if (Flags & LDRP_STATIC_LINK) {
                dprintf( "             LDRP_STATIC_LINK\n" );
                }
            if (Flags & LDRP_IMAGE_DLL) {
                dprintf( "             LDRP_IMAGE_DLL\n" );
                }
            if (Flags & LDRP_LOAD_IN_PROGRESS) {
                dprintf( "             LDRP_LOAD_IN_PROGRESS\n" );
                }
            if (Flags & LDRP_UNLOAD_IN_PROGRESS) {
                dprintf( "             LDRP_UNLOAD_IN_PROGRESS\n" );
                }
            if (Flags & LDRP_ENTRY_PROCESSED) {
                dprintf( "             LDRP_ENTRY_PROCESSED\n" );
                }
            if (Flags & LDRP_ENTRY_INSERTED) {
                dprintf( "             LDRP_ENTRY_INSERTED\n" );
                }
            if (Flags & LDRP_CURRENT_LOAD) {
                dprintf( "             LDRP_CURRENT_LOAD\n" );
                }
            if (Flags & LDRP_FAILED_BUILTIN_LOAD) {
                dprintf( "             LDRP_FAILED_BUILTIN_LOAD\n" );
                }
            if (Flags & LDRP_DONT_CALL_FOR_THREADS) {
                dprintf( "             LDRP_DONT_CALL_FOR_THREADS\n" );
                }
            if (Flags & LDRP_PROCESS_ATTACH_CALLED) {
                dprintf( "             LDRP_PROCESS_ATTACH_CALLED\n" );
                }
            if (Flags & LDRP_DEBUG_SYMBOLS_LOADED) {
                dprintf( "             LDRP_DEBUG_SYMBOLS_LOADED\n" );
                }
            if (Flags & LDRP_IMAGE_NOT_AT_BASE) {
                dprintf( "             LDRP_IMAGE_NOT_AT_BASE\n" );
                }
            if (Flags & LDRP_COR_IMAGE) {
                dprintf( "             LDRP_COR_IMAGE\n" );
                }
            if (Flags & LDRP_COR_OWNS_UNMAP) {
                dprintf( "             LDR_COR_OWNS_UNMAP\n" );
                }
        
            if (ShowVersionInfo) {
		ShowImageVersionInfo(DllBase);
	    }
        }


        switch (OrderList) {
            case Memory:
                Next = ReadField(InMemoryOrderLinks.Flink);
                break;

            case Init:
                Next = ReadField(InInitializationOrderLinks.Flink);
                break;

            default:
            case Load:
                Next = ReadField(InLoadOrderLinks.Flink);
                break;
        }
        
        if (DoAll || DoHeaders || DoSections) {
            DumpImage( ReadField(DllBase),
                       DoAll || DoHeaders,
                       DoAll || DoSections );
        }

        if (SingleEntry) {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\gflagext.c ===
#include "precomp.h"
#pragma hdrstop
#include <ntexapi.dbg>

DECLARE_API( gflag )

/*++

Routine Description:

    This function is called as an NTSD extension to dump or modify
    the contents of the NtGlobalFlag variable in NTDLL

    Called as:

        !gflag [value]

    If a value is not given then displays the current bits set in
    NTDLL!NtGlobalFlag variable.  Otherwise value can be one of the
    following:

        -? - displays a list of valid flag abbreviations
        number - 32-bit number that becomes the new value stored into
                 NtGlobalFlag
        +number - specifies one or more bits to set in NtGlobalFlag
        +abbrev - specifies a single bit to set in NtGlobalFlag
        -number - specifies one or more bits to clear in NtGlobalFlag
        -abbrev - specifies a single bit to clear in NtGlobalFlag

Return Value:

    None.

--*/

{
    ULONG gflagOffset;
    ULONG64 pebAddress;
    ULONG64 pNtGlobalFlag = 0;
    ULONG ValidBits = FLG_USERMODE_VALID_BITS;
    ULONG i;
    ULONG OldGlobalFlags;
    ULONG NewGlobalFlagsClear;
    ULONG NewGlobalFlagsSet;
    ULONG NewGlobalFlags;
    LPSTR s, Arg;

    pNtGlobalFlag = GetExpression("nt!NtGlobalFlag");
    ValidBits = FLG_VALID_BITS;

    //
    // If we could not get the global variable from the kernel, try from the
    // PEB for user mode
    //

    if (!pNtGlobalFlag)
    {
        GetPebAddress(0, &pebAddress);

        if (pebAddress)
        {
            if (GetFieldOffset("nt!_PEB", "NtGlobalFlag", &gflagOffset))
            {
                dprintf("Could not find NtGlobalFlag in nt!_PEB\n");
                return E_FAIL;
            }
            pNtGlobalFlag = gflagOffset + pebAddress;
            ValidBits = FLG_USERMODE_VALID_BITS;
        }
    }

    if (!pNtGlobalFlag)
    {
        dprintf( "Unable to get address of NtGlobalFlag variable" );
        return E_FAIL;
    }

    if (!ReadMemory(pNtGlobalFlag,
                    &OldGlobalFlags,
                    sizeof(OldGlobalFlags),
                    NULL))
    {
        dprintf( "Unable to read contents of NtGlobalFlag variable at %p\n", pNtGlobalFlag );
        return E_FAIL;
    }

    OldGlobalFlags &= ValidBits;

    s = (LPSTR)args;
    if (!s)
    {
        s = "";
    }

    NewGlobalFlagsClear = 0;
    NewGlobalFlagsSet = 0;
    while (*s)
    {
        while (*s && *s <= ' ')
        {
            s += 1;
        }

        Arg = s;
        if (!*s)
        {
            break;
        }

        while (*s && *s > ' ')
        {
            s += 1;
        }

        if (*s)
        {
            *s++ = '\0';
        }

        if (!strcmp( Arg, "-?" ))
        {
            dprintf( "usage: !gflag [-? | flags]\n" );
            dprintf( "Flags may either be a single hex number that specifies all\n" );
            dprintf( "32-bits of the GlobalFlags value, or it can be one or more\n" );
            dprintf( "arguments, each beginning with a + or -, where the + means\n" );
            dprintf( "to set the corresponding bit(s) in the GlobalFlags and a -\n" );
            dprintf( "means to clear the corresponding bit(s).  After the + or -\n" );
            dprintf( "may be either a hex number or a three letter abbreviation\n" );
            dprintf( "for a GlobalFlag.  Valid abbreviations are:\n" );
            for (i=0; i<32; i++) {
                if ((GlobalFlagInfo[i].Flag & ValidBits) &&
                    GlobalFlagInfo[i].Abbreviation != NULL)
                {
                    dprintf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation,
                                                      GlobalFlagInfo[i].Description
                           );
                }
            }

            return E_FAIL;
        }

        if (*Arg == '+' || *Arg == '-')
        {
            if (strlen(Arg+1) == 3)
            {
                for (i=0; i<32; i++)
                {
                    if ((GlobalFlagInfo[i].Flag & ValidBits) &&
                        !_stricmp( GlobalFlagInfo[i].Abbreviation, Arg+1 ))
                    {
                        if (*Arg == '-')
                        {
                            NewGlobalFlagsClear |= GlobalFlagInfo[i].Flag;
                        }
                        else
                        {
                            NewGlobalFlagsSet |= GlobalFlagInfo[i].Flag;
                        }

                        Arg += 4;
                        break;
                    }
                }

                if (*Arg != '\0')
                {
                    dprintf( "Invalid flag abbreviation - '%s'\n", Arg );
                    return E_FAIL;
                }
            }

            if (*Arg != '\0')
            {
                if (*Arg++ == '-')
                {
                    NewGlobalFlagsClear |= strtoul( Arg, &Arg, 16 );
                }
                else
                {
                    NewGlobalFlagsSet |= strtoul( Arg, &Arg, 16 );
                }
            }
        }
        else
        {
            NewGlobalFlagsSet = strtoul( Arg, &Arg, 16 );
            break;
        }
    }

    NewGlobalFlags = (OldGlobalFlags & ~NewGlobalFlagsClear) | NewGlobalFlagsSet;
    NewGlobalFlags &= ValidBits;
    if (NewGlobalFlags != OldGlobalFlags)
    {
        if (!WriteMemory( pNtGlobalFlag,
                          &NewGlobalFlags,
                          sizeof( NewGlobalFlags ),
                          NULL))
        {
            dprintf( "Unable to store new global flag settings.\n" );
            return E_FAIL;
        }

        dprintf( "New NtGlobalFlag contents: 0x%08x\n", NewGlobalFlags );
        OldGlobalFlags = NewGlobalFlags;
    }
    else
    {
        dprintf( "Current NtGlobalFlag contents: 0x%08x\n", OldGlobalFlags );
    }

    for (i=0; i<32; i++)
    {
        if (OldGlobalFlags & GlobalFlagInfo[i].Flag)
        {
            dprintf( "    %s - %s\n", GlobalFlagInfo[i].Abbreviation, GlobalFlagInfo[i].Description );
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\heap.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "heap.h"
#pragma hdrstop
ULONG PageSize;

VOID
DebugPageHeapExtension(
    IN PCSTR lpArgumentString
    );

BOOL
GetPageSize()
{
    KDDEBUGGER_DATA64 kdd;

    if (GetDebuggerData('GBDK', &kdd, sizeof(kdd))) {
        //
        // Kernel target
        //
        PageSize =  (ULONG) kdd.MmPageSize;
        return TRUE;
    } else {
        //
        // User maode
        //
        SYSTEM_BASIC_INFORMATION sysInfo;
        if (!NtQuerySystemInformation( SystemBasicInformation,
                                       &sysInfo,
                                       sizeof(sysInfo),
                                       NULL)) {
            PageSize = sysInfo.PageSize;
            return TRUE;
        }
    }
    return FALSE;

}

/*
#if defined(TARGET_i386)
#define STACK_TRACE_DATABASE_SUPPORT 1
#elif defined(TARGET_ALPHA)
#define STACK_TRACE_DATABASE_SUPPORT 0
#elif i386
#define STACK_TRACE_DATABASE_SUPPORT 1
#else
#define STACK_TRACE_DATABASE_SUPPORT 0
#endif*/
#define STACK_TRACE_DATABASE_SUPPORT 0

#if 0 
// BUGBUG This was X86 specific := HOST_i386
ULONG
xRtlCompareMemoryUlong(
    PVOID Source,
    ULONG Length,
    ULONG Pattern
    )
{
    ULONG CountLongs;
    PULONG p = (PULONG)Source;
    PCHAR p1, p2;

    if (((ULONG)p & (sizeof( ULONG )-1)) ||
        (Length & (sizeof( ULONG )-1))
       ) {
        return( 0 );
        }

    CountLongs = Length / sizeof( ULONG );
    while (CountLongs--) {
        if (*p++ != Pattern) {
            p1 = (PCHAR)(p - 1);
            p2 = (PCHAR)&Pattern;
            Length = p1 - (PCHAR)Source;
            while (*p1++ == *p2++) {
                if (p1 > (PCHAR)p) {
                    break;
                    }

                Length++;
                }
            }
        }

    return( Length );
}

#define RtlCompareMemoryUlong  xRtlCompareMemoryUlong
#define RtlCompareMemory       memcmp

#endif

#define STOP_ON_ALLOC 1
#define STOP_ON_REALLOC 2
#define STOP_ON_FREE 3


typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;


typedef struct _HEAP_STATE {
    BOOLEAN ShowHelp;
    BOOLEAN ExitDumpLoop;
    BOOLEAN ComputeSummary;
    BOOLEAN ValidateHeap;
    BOOLEAN DumpHeapEntries;
    BOOLEAN DumpHeapTags;
    BOOLEAN DumpHeapPseudoTags;
    BOOLEAN DumpGlobalTags;
    BOOLEAN DumpHeapSegments;
    BOOLEAN DumpHeapFreeLists;
    BOOLEAN DumpStackBackTrace;
    BOOLEAN SetStopOnBreakPoint;
    BOOLEAN RemoveStopOnBreakPoint;
    BOOLEAN EnableHeapChecking;
    BOOLEAN EnableHeapValidateOnCall;
    BOOLEAN DisableHeapChecking;
    BOOLEAN DisableHeapValidateOnCall;
    BOOLEAN ToggleAPICallTracing;
    ULONG64 HeapToDump;
    ULONG64 HeapEntryToDump;
    ULONG64 ReservedSize;
    ULONG64 CommittedSize;
    ULONG64 AllocatedSize;
    ULONG64 FreeSize;
    ULONG64 OverheadSize;
    ULONG  NumberOfHeaps;
    ULONG  HeapIndex;
    PULONG64 HeapsList;
    ULONG  StopOnOperation;
    ULONG64 StopOnAddress;
    HEAP_STOP_ON_TAG StopOnTag;
    WCHAR  StopOnTagName[ 24 ];

    ULONG  FreeListCounts[ HEAP_MAXIMUM_FREELISTS ];
    ULONG64 TotalFreeSize;
    ULONG64 HeapAddress;
    ULONG64 Heap; // HEAP 
    ULONG  SegmentNumber;
    ULONG64 SegmentAddress;
    ULONG64 Segments[ HEAP_MAXIMUM_SEGMENTS ]; // Ptr to HEAP_SEGMENT
} HEAP_STATE, *PHEAP_STATE;


BOOL
ConvertTagNameToIndex(
    IN PHEAP_STATE State
    );

BOOL
GetHeapTagEntry(
    IN ULONG64 Heap,
    IN USHORT TagIndex,
    OUT PULONG64 TagEntry
    );

VOID
WalkHEAP(
    IN PHEAP_STATE State
    );

VOID
WalkHEAP_SEGMENT(
    IN PHEAP_STATE State
    );

BOOL
ValidateHeapHeader(
    IN ULONG64 HeapAddress
//    IN PHEAP Heap
    );

BOOL
ValidateHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 PrevEntryAddress,
    IN ULONG64 PrevEntry,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    );

VOID
DumpHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    );


#if STACK_TRACE_DATABASE_SUPPORT
VOID
DumpStackBackTraceIndex(
    IN PHEAP_STATE State,
    IN USHORT BackTraceIndex
    );
#endif // STACK_TRACE_DATABASE_SUPPORT

BOOLEAN HeapExtInitialized;

ULONG64 pNtGlobalFlag;

ULONG64 pRtlpHeapInvalidBreakPoint;
ULONG64 pRtlpHeapInvalidBadAddress;

ULONG64 pRtlpGlobalTagHeap;
//HEAP MyLocalRtlpGlobalTagHeap;

#if STACK_TRACE_DATABASE_SUPPORT
ULONG64 pRtlpStackTraceDataBase;// PSTACK_TRACE_DATABASE *
ULONG64 RtlpStackTraceDataBase; // PSTACK_TRACE_DATABASE 
STACK_TRACE_DATABASE StackTraceDataBase;
BOOLEAN HaveCopyOfStackTraceDataBase;
#endif // STACK_TRACE_DATABASE_SUPPORT

ULONG64 pRtlpHeapStopOn; // PHEAP_STOP_ON_VALUES

BOOLEAN RtlpHeapInvalidBreakPoint;
PVOID RtlpHeapInvalidBadAddress;
ULONG HeapEntryTypeSize = 8;

DECLARE_API( heap )

/*++

Routine Description:

    Dump user mode heap (Kernel debugging)

    If an address if not given or an address of 0 is given, then the
    process heap is dumped.  If the address is -1, then all the heaps of
    the process are dumped.  If detail is specified, it defines how much
    detail is shown.  A detail of 0, just shows the summary information
    for each heap.  A detail of 1, shows the summary information, plus
    the location and size of all the committed and uncommitted regions.
    A detail of 3 shows the allocated and free blocks contained in each
    committed region.  A detail of 4 includes all of the above plus
    a dump of the free lists.

Arguments:

    args - [address [detail]]

Return Value:

    None

--*/

{
    BOOL b, GotHeapsList, ArgumentsSpecified;
    ULONG64 pHeapsList;
    ULONG PtrSize;
    ULONG NtGlobalFlag;
    LPSTR p;
    ULONG i;
    ULONG DashBArgumentState;
    ULONG64 AddressToDump;
    HEAP_STATE State;
    UCHAR ArgumentBuffer[ 16 ];
    ULONG TagIndex;
    ULONG64 pTagEntry; // PHEAP_TAG_ENTRY
    ULONG64 TagEntry; // HEAP_TAG_ENTRY
    ULONG64 pPseudoTagEntry; // PHEAP_PSEUDO_TAG_ENTRY
//    HEAP_PSEUDO_TAG_ENTRY PseudoTagEntry;
    BOOLEAN HeapHeaderModified;
    BOOLEAN RtlpHeapInvalidBreakPoint;
    ULONG64 RtlpHeapInvalidBadAddress;
    ULONG LocalHeapSignature;
    ULONG AlOffset, FlagOffset, TagEntrySize, pseudoTagEntrySize;
    ULONG64 AlignRound;
    ULONG64 SystemRangeStart = GetExpression("NT!MmSystemRangeStart");
    ULONG64 ProcessPeb;
    PCSTR Current;

    //
    //  Parse the command line arguments for heap options
    //  that don't require to building the process heap list
    //  (i.e pageheap, leak detection, search a block)
    //

    for (Current = args; *Current != '\0'; Current++) {

        if (*Current == '-') {

            Current++;
            switch (*Current) {
                case 'p':
                    DebugPageHeapExtension( ++Current );

                    return S_OK;

                case 'l':
                case 'L':
                    HeapDetectLeaks();
                    return S_OK;

                case 'x':
                case 'X':
                    HeapFindBlock( args );
                    return S_OK;
                case 's':
                case 'S':
                    HeapStat(++Current);
                    return S_OK;
            }
        }
    }


    // BUGBUG - not initializing the signature, as we have no local copy
    // MyLocalRtlpGlobalTagHeap.Signature = 0;
    LocalHeapSignature = 0;
#if STACK_TRACE_DATABASE_SUPPORT
    HaveCopyOfStackTraceDataBase = FALSE;
#endif // STACK_TRACE_DATABASE_SUPPORT

    memset( &State, 0, FIELD_OFFSET( HEAP_STATE, FreeListCounts ) );
    AddressToDump = (ULONG)-1;
    ArgumentsSpecified = FALSE;
    p = (LPSTR)args;
    if (p != NULL)
    while (*p) {
        if (*p == '-') {
            ArgumentsSpecified = TRUE;
            p += 1;
            while (*p && *p != ' ') {
                switch (*p) {
                case 'v':
                case 'V':
                    State.ValidateHeap = TRUE;
                    break;

                case 'a':
                case 'A':
                    State.DumpHeapEntries = TRUE;
                    State.DumpHeapFreeLists = TRUE;
                    State.DumpHeapSegments = TRUE;
                    break;

                case 'h':
                case 'H':
                    State.DumpHeapEntries = TRUE;
                    break;

                case 'f':
                case 'F':
                    State.DumpHeapFreeLists = TRUE;
                    break;

                case 'm':
                case 'M':
                    State.DumpHeapSegments = TRUE;
                    break;

                case 't':
                    State.DumpHeapTags = TRUE;
                    break;

                case 'T':
                    State.DumpHeapPseudoTags = TRUE;
                    break;

                case 'g':
                case 'G':
                    State.DumpGlobalTags = TRUE;
                    break;

                case 'k':
                case 'K':
                    State.DumpStackBackTrace = TRUE;
                    break;

                case 's':
                case 'S':
                    State.ComputeSummary = TRUE;
                    break;

                case 'd':
                    State.DisableHeapChecking = TRUE;
                    break;

                case 'D':
                    State.DisableHeapValidateOnCall = TRUE;
                    break;

                case 'e':
                    State.EnableHeapChecking = TRUE;
                    break;

                case 'E':
                    State.EnableHeapValidateOnCall = TRUE;
                    break;

                case 'B':
                    State.RemoveStopOnBreakPoint = TRUE;
                    DashBArgumentState = 0;
                    State.StopOnOperation = 0;
                    State.StopOnAddress = 0;
                    State.StopOnTag.HeapIndex = 0;
                    State.StopOnTag.TagIndex = 0;
                    State.StopOnTagName[ 0 ] = UNICODE_NULL;
                    break;

                case 'b':
                    State.SetStopOnBreakPoint = TRUE;
                    DashBArgumentState = 0;
                    State.StopOnOperation = 0;
                    State.StopOnAddress = 0;
                    State.StopOnTag.HeapIndex = 0;
                    State.StopOnTag.TagIndex = 0;
                    State.StopOnTagName[ 0 ] = UNICODE_NULL;
                    break;

                default:
                    dprintf( "HEAPEXT: !heap invalid option flag '-%c'\n", *p );
                case '?':
                    State.ShowHelp = TRUE;
                    break;
                }

                p += 1;
                }
            }
        else
        if (*p != ' ') {
            if (State.SetStopOnBreakPoint) {
                switch (DashBArgumentState) {
                    case 0:
                        DashBArgumentState += 1;
                        if (sscanf( p, "%s", ArgumentBuffer ) == 1) {
                            if (!_stricmp( ArgumentBuffer, "alloc" )) {
                                State.StopOnOperation = STOP_ON_ALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "realloc" )) {
                                State.StopOnOperation = STOP_ON_REALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "free" )) {
                                State.StopOnOperation = STOP_ON_FREE;
                                }
                            }

                        if (State.StopOnOperation == 0) {
                            dprintf( "HEAPEXT: Invalid first argument to -b switch.\n" );
                            State.ShowHelp = TRUE;
                            }
                        break;

                    case 1:
                        if (sscanf( p, "%ws", &State.StopOnTagName ) != 1) {
                            State.StopOnTagName[ 0 ] = UNICODE_NULL;
                            dprintf( "HEAPEXT: Invalid second argument to -b switch.\n" );
                            State.ShowHelp = TRUE;
                            }
                        break;

                    default:
                        dprintf( "HEAPEXT: Too many parameters specified to -b switch\n" );
                        State.ShowHelp = TRUE;
                        break;
                    }
                }
            else
            if (State.RemoveStopOnBreakPoint) {
                switch (DashBArgumentState) {
                    case 0:
                        DashBArgumentState += 1;
                        if (sscanf( p, "%s", ArgumentBuffer ) == 1) {
                            if (!_stricmp( ArgumentBuffer, "alloc" )) {
                                State.StopOnOperation = STOP_ON_ALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "realloc" )) {
                                State.StopOnOperation = STOP_ON_REALLOC;
                                }
                            else
                            if (!_stricmp( ArgumentBuffer, "free" )) {
                                State.StopOnOperation = STOP_ON_FREE;
                                }
                            }
                        break;

                    default:
                        dprintf( "HEAPEXT: Too many parameters specified to -B switch\n" );
                        State.ShowHelp = TRUE;
                        break;
                    }
                }
            else {
                ArgumentsSpecified = TRUE;
                sscanf( p, "%I64lx", &AddressToDump );
                }

            if ((p = strpbrk( p, " " )) == NULL) {
                p = "";
                }
            }
        else {
            p++;
            }
    }

    if (State.ShowHelp) {
        dprintf( "usage: !heap [address] [-? ] [-v] [[-a] | [-h] [-f] [-m]] [-t] [-s]\n" );
        dprintf( "                       [-d | -D | -e | -E]\n" );
        dprintf( "                       [-b [alloc | realloc | free] [tag]]\n" );
        dprintf( "                       [-B [alloc | realloc | free]]\n" );
        dprintf( "  address - specifies either a heap number (1-n), or a heap address.\n" );
        dprintf( "            Zero specifies all heaps in the process.\n" );
        dprintf( "            -1 is the default and specifies the process heap.\n" );
        dprintf( "  -?        displays this help message.\n" );
        dprintf( "  -v        validates the specified heap(s).\n" );
        dprintf( "  -a        displays all the information for the specified heap(s).\n" );
        dprintf( "            This can take a long time.\n" );
        dprintf( "  -h        displays all the entries for the specified heap(s).\n" );
        dprintf( "  -f        displays all the free list entries for the specified heap(s).\n" );
        dprintf( "  -l        detects leaked heap blocks.\n" );
        dprintf( "  -x        search the heap block containing the address.\n" );
        dprintf( "  -x -v     search the whole process virtual space for given address .\n" );
        dprintf( "  -k        displays any associated stack back trace for each entry (x86 only).\n" );
        dprintf( "  -m        displays all the segment entries for the specified heap(s).\n" );
        dprintf( "  -t        displays the tag information for the specified heap(s).\n" );
        dprintf( "  -T        displays the pseudo tag information for the specified heap(s).\n" );
        dprintf( "  -g        displays the global tag information generated by tag by DLL\n" );
        dprintf( "  -s        displays summary information for the specified heap(s).\n" );
        dprintf( "  -e        enables heap checking for the specified heap(s).\n" );
        dprintf( "  -d        disables heap checking for the specified heap(s).\n" );
        dprintf( "  -E        enables validate on call for the specified heap(s).\n" );
        dprintf( "  -D        disables validate on call for the specified heap(s).\n" );
        dprintf( "  -b        creates a conditional breakpoint in the heap manager.\n" );
        dprintf( "            alloc | realloc | free specifies which action to stop.\n" );
        dprintf( "            address either specifies the address of a block to stop on.\n" );
        dprintf( "            or a heap, in which case the tag argument is required,\n" );
        dprintf( "            and is the tag name within the heap specified by address.\n" );
        dprintf( "  -B        removes a conditional breakpoint in the heap manager.\n" );
        dprintf( "            if the type is not specified then all breakpoints are removed.\n" );
        dprintf ("  -p -?       extensive page heap related help.           \n");
        dprintf ("  -p          Dump all page heaps.                        \n");
        dprintf ("  -p -h ADDR  Detailed dump of page heap at ADDR.         \n");
        dprintf ("  -p -a ADDR  Figure out what heap block is at ADDR.      \n");
        dprintf ("  -p -t [N]   Dump N collected traces with heavy heap users.\n");
        dprintf ("  -p -tc [N]  Dump N traces sorted by count usage (eqv. with -t).\n");
        dprintf ("  -p -ts [N]  Dump N traces sorted by size.\n");
        dprintf ("  -p -fi [N]  Dump last N fault injection traces.\n");
        
        return S_OK;
    }

    i = (ULONG)State.EnableHeapChecking + (ULONG)State.EnableHeapValidateOnCall +
        (ULONG)State.DisableHeapChecking + (ULONG)State.DisableHeapValidateOnCall +
        (ULONG)State.ToggleAPICallTracing;

    if (i > 1) {
        dprintf( "HEAPEXT: -d, -D, -e and -E flags are mutually exclusive\n" );
        return E_INVALIDARG;
    }

    if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
        if (pRtlpHeapStopOn == 0) {
            dprintf( "HEAPEXT: Unable to %s heap breakpoint due to missing or invalid NTDLL symbols.\n",
                     State.SetStopOnBreakPoint ? "set" : "remove"
                   );
            return E_INVALIDARG;
        }

        if (State.HeapToDump == 0) {
            dprintf( "HEAPEXT: Must specify either heap index or heap address to -b command.\n" );
            return E_INVALIDARG;
        }
    }

    //
    // Ok, so this is a !heap command for NT heap manager.
    //
    
    if (!HeapExtInitialized) {
        pNtGlobalFlag = GetExpression( "NTDLL!NtGlobalFlag" );
        if (pNtGlobalFlag == 0 ||
            !ReadMemory( pNtGlobalFlag,
                         &NtGlobalFlag,
                         sizeof( NtGlobalFlag ),
                         NULL ) )
        {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!NtGlobalFlag.\n" );
            return E_INVALIDARG;
        }

        pRtlpHeapInvalidBreakPoint = GetExpression( "NTDLL!RtlpHeapInvalidBreakPoint" );
        if (pRtlpHeapInvalidBreakPoint == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapInvalidBreakPoint.\n" );
            }

        pRtlpHeapInvalidBadAddress = GetExpression( "NTDLL!RtlpHeapInvalidBadAddress" );
        if (pRtlpHeapInvalidBadAddress == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapInvalidBadAddress.\n" );
            }

        pRtlpGlobalTagHeap = GetExpression( "NTDLL!RtlpGlobalTagHeap" );
        if (pRtlpGlobalTagHeap == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpGlobalTagHeap.\n" );
            }
        if (!ReadPointer( pRtlpGlobalTagHeap,&pRtlpGlobalTagHeap)) {
            dprintf( "HEAPEXT: Unable to get address of *NTDLL!RtlpGlobalTagHeap.\n" );
        }

        pRtlpHeapStopOn = GetExpression( "NTDLL!RtlpHeapStopOn" );
        if (pRtlpHeapStopOn == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpHeapStopOn\n" );
            }

#if STACK_TRACE_DATABASE_SUPPORT
        pRtlpStackTraceDataBase = GetExpression( "NTDLL!RtlpStackTraceDataBase" );
        if (pRtlpStackTraceDataBase == 0) {
            dprintf( "HEAPEXT: Unable to get address of NTDLL!RtlpStackTraceDataBase\n" );
            }
#endif // STACK_TRACE_DATABASE_SUPPORT

        HeapExtInitialized = TRUE;
        }

    if (!GetPageSize()) {
        dprintf("Unable to get PageSize.\n");
        return E_INVALIDARG;

    }

    if (!ArgumentsSpecified) {
        if ((NtGlobalFlag & (FLG_HEAP_ENABLE_TAIL_CHECK |
                             FLG_HEAP_ENABLE_FREE_CHECK |
                             FLG_HEAP_VALIDATE_PARAMETERS |
                             FLG_HEAP_VALIDATE_ALL |
                             FLG_HEAP_ENABLE_TAGGING |
                             FLG_USER_STACK_TRACE_DB |
                             FLG_HEAP_DISABLE_COALESCING
                            )
            ) != 0
           ) {
            dprintf( "NtGlobalFlag enables following debugging aids for new heaps:" );
            if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {
                dprintf( "    tail checking\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {
                dprintf( "    free checking\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {
                dprintf( "    validate parameters\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {
                dprintf( "    validate on call\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_ENABLE_TAGGING) {
                dprintf( "    heap tagging\n" );
                }

            if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {
                dprintf( "    stack back traces\n" );
                }

            if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {
                dprintf( "    disable coalescing of free blocks\n" );
            }
        }
    }



    {
    INIT_API();
    }

    GetPebAddress( 0, &ProcessPeb);

    if (AddressToDump == (ULONG64)-1) {
        GetFieldValue(ProcessPeb, "PEB", "ProcessHeaps", AddressToDump);
    }

    PtrSize = IsPtr64() ? 8 : 4;
    HeapEntryTypeSize = GetTypeSize("_HEAP_ENTRY");
    GetFieldOffset("_HEAP", "AlignRound", &AlOffset);
    GetFieldOffset("_HEAP", "Flags", &FlagOffset);
    TagEntrySize = GetTypeSize( "_HEAP_TAG_ENTRY");
    pseudoTagEntrySize = GetTypeSize( "_HEAP_PSEUDO_TAG_ENTRY");



    GotHeapsList = FALSE;
    GetFieldValue(ProcessPeb, "PEB", "NumberOfHeaps", State.NumberOfHeaps);
    GetFieldValue(ProcessPeb, "PEB", "ProcessHeaps", pHeapsList);
    if (State.NumberOfHeaps == 0) {
        dprintf( "No heaps to display.\n" );
    }
    else if (!pHeapsList) {
        dprintf( "Unable to get address of ProcessHeaps array\n" );
    }
    else {
        State.HeapsList = malloc( State.NumberOfHeaps * sizeof(ULONG64) ); // To Keep  PHEAP
        if (State.HeapsList == NULL) {
            dprintf( "Unable to allocate memory to hold ProcessHeaps array\n" );
        }
        else {
            ULONG i;
            //
            // Read the array of heap pointers
            //
            GotHeapsList = TRUE;
            for (i=0;i<State.NumberOfHeaps; i++) { 
                if (!ReadPointer( pHeapsList + i*PtrSize,
                             &State.HeapsList[i] )
                    ) {
                    dprintf( "%08p: Unable to read ProcessHeaps array\n", pHeapsList );
                    GotHeapsList = FALSE ;
                    break;
                }
            }
        }
    }

    if (GotHeapsList) {
retryArgs:
        if (!ArgumentsSpecified) {
            if (pRtlpHeapInvalidBreakPoint != 0) {
                b = ReadMemory( pRtlpHeapInvalidBreakPoint,
                                &RtlpHeapInvalidBreakPoint,
                                sizeof( RtlpHeapInvalidBreakPoint ),
                                NULL
                              );
                if (b && RtlpHeapInvalidBreakPoint) {
                    RtlpHeapInvalidBadAddress = 0;
                    if (pRtlpHeapInvalidBadAddress != 0) {
                        b = ReadPointer(pRtlpHeapInvalidBadAddress,
                                    &RtlpHeapInvalidBadAddress);
                        if (b) {
                            AddressToDump = RtlpHeapInvalidBadAddress;
                            }
                        }

                    dprintf( "Stop inside heap manager...validating heap address 0x%p\n", AddressToDump );
                    State.ValidateHeap = TRUE;
                    State.DumpStackBackTrace = TRUE;
                    ArgumentsSpecified = TRUE;
                    goto retryArgs;
                    }
                }
            }
        else
        if (AddressToDump != 0) {
            for (State.HeapIndex=0;
                 State.HeapIndex<State.NumberOfHeaps;
                 State.HeapIndex++
                ) {
                if (AddressToDump-1 == State.HeapIndex ||
                    AddressToDump == State.HeapsList[ State.HeapIndex ]
                   ) {
                    State.HeapToDump = State.HeapsList[ State.HeapIndex ];
                    break;
                    }
                }

            if (State.HeapToDump == 0) {
                if (AddressToDump >= SystemRangeStart) {
                    State.HeapToDump = AddressToDump;
                    }
                else {
                    State.HeapToDump = (ULONG64)-1;
                    }
                }
            }

        State.HeapIndex = 0;
    }
    else {
        if (!ArgumentsSpecified || AddressToDump < 0x10000) {
            dprintf( "You must specify the actual heap address since\n" );
            dprintf( "array of process heaps is inaccessable\n" );
            State.ExitDumpLoop = TRUE;
            }
        else {
            State.HeapToDump = AddressToDump;
            }
    }


    if (State.DumpGlobalTags) {
        dprintf( "Global Tags defined for each DLL that makes an untagged allocation.\n" );
        if (LocalHeapSignature != HEAP_SIGNATURE) {
            b = GetFieldValue( pRtlpGlobalTagHeap,
                               "_HEAP",
                               "Signature",
                               LocalHeapSignature);
            if (b) {
                dprintf( "HEAPEXT: Unable to read RtlpGlobalTagHeap\n" );
                if (State.HeapsList != NULL) {
                    free( State.HeapsList );
                    }
                EXIT_API();
                return E_INVALIDARG;
                }
            }

        GetFieldValue(pRtlpGlobalTagHeap, "_HEAP", "TagEntries", pTagEntry);
        if (pTagEntry == 0) {
            dprintf( "    no global tags currently defined.\n" );
            }
        else {
            ULONG NextAvailableTagIndex;
            
            GetFieldValue(pRtlpGlobalTagHeap, "_HEAP", "NextAvailableTagIndex", NextAvailableTagIndex);

            dprintf( " Tag  Name                   Allocs    Frees   Diff  Allocated\n" );
            for (TagIndex=1; TagIndex<NextAvailableTagIndex; TagIndex++) {
                pTagEntry += TagEntrySize;
                b = (BOOL) InitTypeRead( pTagEntry, _HEAP_TAG_ENTRY);
                if (b) {
                    dprintf( "%04x: unable to read _HEAP_TAG_ENTRY at %p\n", TagIndex, pTagEntry );
                    break;
                    }
                else
                if ((ULONG)ReadField(Allocs) != 0 ||
                    (ULONG)ReadField(Frees) != 0 ||
                    (ULONG)ReadField(Size) != 0
                   ) {
                    dprintf( "%04x: %-20.20ws %8d %8d %6d %8d\n",
                             (ULONG)ReadField(TagIndex),
                             (ULONG)ReadField(TagName),
                             (ULONG)ReadField(Allocs),
                             (ULONG)ReadField(Frees),
                             (ULONG)ReadField(Allocs) - (ULONG)ReadField(Frees),
                             (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT
                           );
                }
            }
        }
    }

    //
    // Walk the list of heaps
    //
    while (!State.ExitDumpLoop &&
           !CheckControlC() &&
           (!GotHeapsList || (State.HeapIndex < State.NumberOfHeaps ))
          ) {
        ULONG Flags;
        WCHAR TagName[ 24 ];

        memset( &State.FreeListCounts, 0, sizeof( State.FreeListCounts ) );
        State.TotalFreeSize = 0;
        if (!GotHeapsList) {
            State.HeapAddress = State.HeapToDump;
            State.ExitDumpLoop = TRUE;
        }
        else {
            State.HeapAddress = State.HeapsList[ State.HeapIndex ];
        }


        State.Heap = State.HeapAddress;

        b = (BOOL) InitTypeRead( (State.HeapAddress), _HEAP);
        if (State.HeapIndex == 0) {
            dprintf( "Index   Address  Name      Debugging options enabled\n" );
        }

        dprintf( "%3u:   %08p ", State.HeapIndex + 1, State.HeapAddress );
        Flags = (ULONG) ReadField(Flags);
        if (b) {
            dprintf( " - heap headers inaccessable, skipping\n" );
        }
        else
        if (!ArgumentsSpecified) {
            if (!GetHeapTagEntry( State.HeapAddress, 0, &TagEntry )) {
                TagName[ 0 ] = UNICODE_NULL;
            } else {
                GetFieldValue(TagEntry, "_HEAP_TAG_ENTRY", "TagName", TagName);
            }
            dprintf( " %-14.14ws", TagName );

            if (Flags & HEAP_TAIL_CHECKING_ENABLED) {
                dprintf( " tail checking" );
            }

            if (Flags & HEAP_FREE_CHECKING_ENABLED) {
                dprintf( " free checking" );
            }

            if (Flags & HEAP_VALIDATE_PARAMETERS_ENABLED) {
                dprintf( " validate parameters" );
                }

            if (Flags & HEAP_VALIDATE_ALL_ENABLED) {
                dprintf( " validate on call" );
                }

            dprintf( "\n" );
            }
        else
        if (State.HeapAddress == State.HeapToDump ||
            State.HeapToDump == 0 ||
            State.HeapToDump == (ULONG64)-1
           ) {
            ULONG Off;
            ULONG64 LastValidEntry;

            GetFieldOffset("_HEAP", "Segments", &Off);
            dprintf( "\n" );
            for (i=0; i<HEAP_MAXIMUM_SEGMENTS; i++) {
                ReadPointer(State.HeapAddress + Off + i*PtrSize,
                        &State.Segments[i]);
                if (State.Segments[ i ] != 0) {
                    b = (BOOL) InitTypeRead(State.Segments[ i ], _HEAP_SEGMENT);
                    if (b) {
                        dprintf( "    Unable to read _HEAP_SEGMENT structure at %p\n", State.Segments[ i ] );
                        }
                    else {
                        LastValidEntry = ReadField(LastValidEntry);
                        dprintf( "    Segment at %p to %p (%08x bytes committed)\n",
                                 i == 0 ? State.HeapAddress : State.Segments[ i ],
                                 LastValidEntry,
                                 (LastValidEntry -
                                    (i == 0 ? State.HeapAddress : State.Segments[ i ])-
                                    (ReadField(NumberOfUnCommittedPages) * PageSize)
                               ));

                        if (State.HeapToDump == (ULONG)-1) {
                            if (AddressToDump >= State.Segments[ i ] &&
                                AddressToDump < LastValidEntry
                               ) {
                                State.HeapToDump = State.HeapAddress;
                                if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
                                    State.StopOnAddress = AddressToDump;
                                    }
                                else {
                                    State.HeapEntryToDump = AddressToDump;
                                    }
                                }
                            }
                        }
                    }
                }

            if (State.HeapToDump == (ULONG64)-1) {
                State.HeapIndex += 1;
                continue;
                }

            if (State.SetStopOnBreakPoint || State.RemoveStopOnBreakPoint) {
                ULONG64 pul;
                ULONG Off;

                switch( State.StopOnOperation) {
                    case STOP_ON_ALLOC:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            GetFieldOffset("_HEAP_STOP_ON_VALUES","AllocAddress", &Off);
                            pul = pRtlpHeapStopOn + Off;;
                            }
                        else {
                            GetFieldOffset("_HEAP_STOP_ON_VALUES","AllocTag.HeapAndTagIndex", &Off);
                            pul = pRtlpHeapStopOn + Off;;
                            }
                        break;

                    case STOP_ON_REALLOC:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            GetFieldOffset("_HEAP_STOP_ON_VALUES","ReAllocAddress", &Off);
                            pul = pRtlpHeapStopOn + Off;;
                            }
                        else {
                            GetFieldOffset("_HEAP_STOP_ON_VALUES","ReAllocTag.HeapAndTagIndex", &Off);
                            pul = pRtlpHeapStopOn + Off;;
                            }
                        break;

                    case STOP_ON_FREE:
                        if (State.StopOnTagName[0] == UNICODE_NULL) {
                            GetFieldOffset("_HEAP_STOP_ON_VALUES","FreeAddress", &Off);
                            pul = pRtlpHeapStopOn + Off;;
                            }
                        else {
                            GetFieldOffset("_HEAP_STOP_ON_VALUES","FreeTag.HeapAndTagIndex", &Off);
                            pul = pRtlpHeapStopOn + Off;;
                            }
                        break;
                    default:
                        pul = 0;
                        break;
                    }

                if (pul != 0) {
                    if (State.StopOnTagName[0] == UNICODE_NULL) {
                        if (State.RemoveStopOnBreakPoint) {
                            State.StopOnAddress = 0;
                            }
                        b = WriteMemory( pul,
                                         &State.StopOnAddress,
                                         PtrSize,
                                         NULL
                                       );
                        }
                    else {
                        if (!ConvertTagNameToIndex( &State )) {
                            dprintf( "HEAPEXT: Unable to convert tag name %ws to an index\n", State.StopOnTagName );
                            b = TRUE;
                            }
                        else {
                            b = WriteMemory( pul,
                                             &State.StopOnTag.HeapAndTagIndex,
                                             sizeof( State.StopOnTag.HeapAndTagIndex ),
                                             NULL
                                           );
                            }
                        }

                    if (!b) {
                        dprintf( "HEAPEXT: Unable to set heap breakpoint - write memory to %x failed\n", pul );
                        }
                    else {
                        if (State.SetStopOnBreakPoint) {
                            if (State.StopOnTagName[0] == UNICODE_NULL) {
                                dprintf( "HEAPEXT: Enabled heap breakpoint for %s of block %x\n",
                                         State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                         State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                         "Free",
                                         State.StopOnAddress
                                       );
                                }
                            else {
                                dprintf( "HEAPEXT: Enabled heap breakpoint for %s of block with tag %ws\n",
                                         State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                         State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                         "Free",
                                         State.StopOnTagName
                                       );
                                }
                            }
                        else {
                            dprintf( "HEAPEXT: Disabled heap breakpoint for %s\n",
                                     State.StopOnOperation == STOP_ON_ALLOC ? "Alloc" :
                                     State.StopOnOperation == STOP_ON_REALLOC ? "ReAlloc" :
                                     "Free"
                                   );
                            }
                        }
                    }
                }

            if (State.ValidateHeap) {
                ValidateHeapHeader( State.HeapAddress );
                }

            HeapHeaderModified = FALSE;
            GetFieldValue(State.HeapAddress, "_HEAP", "AlignRound", AlignRound);
            if (State.EnableHeapChecking || State.EnableHeapValidateOnCall) {
                
                if (!(Flags & HEAP_TAIL_CHECKING_ENABLED)) {
                    AlignRound += CHECK_HEAP_TAIL_SIZE;
                    b = WriteMemory( (State.HeapAddress + AlOffset),
                                     &AlignRound,
                                     sizeof( AlignRound ),
                                     NULL
                                   );
                }
                else {
                    b = TRUE;
                }


                if (b) {
                    HeapHeaderModified = TRUE;
                    Flags |= HEAP_VALIDATE_PARAMETERS_ENABLED |
                                        HEAP_TAIL_CHECKING_ENABLED |
                                        HEAP_FREE_CHECKING_ENABLED;
                    if (State.EnableHeapValidateOnCall) {
                        Flags |= HEAP_VALIDATE_ALL_ENABLED;
                        }

                    b = WriteMemory( (State.HeapAddress + FlagOffset),
                                     (LPCVOID)&Flags,
                                     sizeof( Flags ),
                                     NULL
                                   );
                    }

                if (!b) {
                    dprintf( "HEAPEXT: Unable to enable heap checking for heap %p\n", State.HeapAddress );
                    InitTypeRead( (State.HeapAddress), _HEAP);
                }
                else {
                    if (State.EnableHeapValidateOnCall) {
                        dprintf( "HEAPEXT: Enabled validate on call heap checking for heap %p\n", State.HeapAddress );
                    }
                    else {
                        dprintf( "HEAPEXT: Enabled heap checking for heap %p\n", State.HeapAddress );
                    }
                }
            }
            else
            if (State.DisableHeapChecking || State.DisableHeapValidateOnCall) {
                if (State.DisableHeapValidateOnCall) {
                    if (Flags & HEAP_VALIDATE_ALL_ENABLED) {
                        Flags &= ~HEAP_VALIDATE_ALL_ENABLED;
                        b = WriteMemory( State.HeapAddress + FlagOffset,
                                         (LPCVOID)&Flags,
                                         sizeof( Flags ),
                                         NULL
                                       );
                        }
                    else {
                        b = TRUE;
                        }
                    }
                else {
                    if (Flags & HEAP_TAIL_CHECKING_ENABLED) {
                        HeapHeaderModified = TRUE;
                        AlignRound -= CHECK_HEAP_TAIL_SIZE;
                        b = WriteMemory( State.HeapAddress + AlOffset,
                                         (LPCVOID)&AlignRound,
                                         sizeof( AlignRound ),
                                         NULL
                                       );
                        }
                    else {
                        b = TRUE;
                        }

                    if (b) {
                        Flags &= ~(HEAP_VALIDATE_PARAMETERS_ENABLED |
                                   HEAP_VALIDATE_ALL_ENABLED |
                                   HEAP_TAIL_CHECKING_ENABLED |
                                   HEAP_FREE_CHECKING_ENABLED
                                   );
                        b = WriteMemory( State.HeapAddress + FlagOffset,
                                         (LPCVOID)&Flags,
                                         sizeof( Flags ),
                                         NULL
                                       );
                        }
                    }

                if (!b) {
                    dprintf( "HEAPEXT: Unable to disable heap checking for heap %p\n", State.HeapAddress );
                    InitTypeRead( (State.HeapAddress), _HEAP);
                    }
                else {
                    if (State.DisableHeapValidateOnCall) {
                        dprintf( "HEAPEXT: Disabled validate on call heap checking for heap %p\n", State.HeapAddress );
                        }
                    else {
                        dprintf( "HEAPEXT: Disabled heap checking for heap %p\n", State.HeapAddress );
                        }
                    }
                }
            else
            if (State.ToggleAPICallTracing) {
                Flags ^= HEAP_CREATE_ENABLE_TRACING;
                b = WriteMemory( State.HeapAddress + FlagOffset,
                                 (LPCVOID)&Flags,
                                 sizeof( Flags ),
                                 NULL
                               );
                if (!b) {
                    dprintf( "HEAPEXT: Unable to toggle API call tracing for heap %p\n", State.HeapAddress );
                    InitTypeRead( (State.HeapAddress), _HEAP);
                    }
                else {
                    HeapHeaderModified = TRUE;
                    if (Flags & HEAP_CREATE_ENABLE_TRACING) {
                        dprintf( "HEAPEXT: Enabled API call tracing for heap %p\n", State.HeapAddress );
                        }
                    else {
                        dprintf( "HEAPEXT: Disabled API call tracing for heap %p\n", State.HeapAddress );
                        }
                    }
                }
            else
            if (State.DumpHeapTags) {
                GetFieldValue(State.HeapAddress, "_HEAP", "TagEntries", pTagEntry);
                if (pTagEntry == 0) {
                    dprintf( "    no tags currently defined for this heap.\n" );
                    }
                else {
                    ULONG NextAvailableTagIndex;

                    GetFieldValue(State.HeapAddress, "_HEAP", "NextAvailableTagIndex", NextAvailableTagIndex);

                    dprintf( " Tag  Name                   Allocs    Frees   Diff  Allocated\n" );
                    for (TagIndex=1; TagIndex<NextAvailableTagIndex; TagIndex++) {
                        pTagEntry += TagEntrySize;
                        b = (BOOL) InitTypeRead( pTagEntry, _HEAP_TAG_ENTRY);

                        if (b) {
                            dprintf( "%04x: unable to read _HEAP_TAG_ENTRY at %p\n", TagIndex, pTagEntry );
                            }
                        else
                        if ((ULONG)ReadField(Allocs) != 0 ||
                            (ULONG)ReadField(Frees) != 0 ||
                            (ULONG)ReadField(Size) != 0
                           ) {
                            dprintf( "%04x: %-20.20ws %8d %8d %6d %8d\n",
                                     (ULONG)ReadField(TagIndex),
                                     (ULONG)ReadField(TagName),
                                     (ULONG)ReadField(Allocs),
                                     (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Allocs) - (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT
                                   );
                            }
                        }
                    }
                }
            else
            if (State.DumpHeapPseudoTags) {
                GetFieldValue(State.HeapAddress, "_HEAP", "PseudoTagEntries", pPseudoTagEntry);
                if (pPseudoTagEntry == 0) {
                    dprintf( "    no pseudo tags currently defined for this heap.\n" );
                    }
                else {
                    dprintf( " Tag Name            Allocs    Frees   Diff  Allocated\n" );
                    for (TagIndex=1; TagIndex<HEAP_NUMBER_OF_PSEUDO_TAG; TagIndex++) {
                        pPseudoTagEntry += pseudoTagEntrySize;
                        b = (BOOL) InitTypeRead( pPseudoTagEntry, _HEAP_PSEUDO_TAG_ENTRY);
                        if (b) {
                            dprintf( "%04x: unable to read HEAP_PSEUDO_TAG_ENTRY at %p\n", TagIndex, pPseudoTagEntry );
                            }
                        else
                        if ((ULONG)ReadField(Allocs) != 0 ||
                            (ULONG)ReadField(Frees) != 0 ||
                            (ULONG)ReadField(Size) != 0
                           ) {
                            if (TagIndex == 0) {
                                dprintf( "%04x: Objects>%4u",
                                         TagIndex | HEAP_PSEUDO_TAG_FLAG,
                                         HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                                       );
                                }
                            else
                            if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
                                dprintf( "%04x: Objects=%4u",
                                         TagIndex | HEAP_PSEUDO_TAG_FLAG,
                                         TagIndex << HEAP_GRANULARITY_SHIFT
                                       );
                                }
                            else {
                                dprintf( "%04x: VirtualAlloc", TagIndex | HEAP_PSEUDO_TAG_FLAG );
                            }
                            dprintf( " %8d %8d %6d %8d\n",
                                     (ULONG)ReadField(Allocs),
                                     (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Allocs) - (ULONG)ReadField(Frees),
                                     (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT
                                   );
                        }
                    }
                }
            }

            // BUGBUG - Cannot write whole struct - change to write specific fields only
            //
            /*
            if (HeapHeaderModified && (State.Heap.HeaderValidateCopy != NULL)) {
                b = WriteMemory( (ULONG_PTR)State.Heap.HeaderValidateCopy,
                                 &State.Heap,
                                 sizeof( State.Heap ),
                                 NULL
                               );
                if (!b) {
                    dprintf( "HEAPEXT: Unable to update header validation copy at %p\n", State.Heap.HeaderValidateCopy );
                }
            }*/

            if (State.HeapEntryToDump != 0 ||
                State.DumpHeapEntries ||
                State.DumpHeapSegments ||
                State.DumpHeapFreeLists
               ) {
                WalkHEAP( &State );
            }
        }
        else {
            dprintf( "\n" );
        }

        State.HeapIndex += 1;
    }

    if (State.HeapsList != NULL) {
        free( State.HeapsList );
    }

    EXIT_API();

    return S_OK;
}

BOOL
ConvertTagNameToIndex(
    IN PHEAP_STATE State
    )
{
    ULONG TagIndex;
    ULONG64 pTagEntry; // PHEAP_TAG_ENTRY
    ULONG64 pPseudoTagEntry;
    BOOL b;
    PWSTR s;
    WCHAR TagName[ 24 ];

    ULONG NextAvailableTagIndex, TagEntrySize;

    if (State->RemoveStopOnBreakPoint) {
        State->StopOnTag.HeapAndTagIndex = 0;
        return TRUE;
        }

    if (!_wcsnicmp( State->StopOnTagName, L"Objects", 7 )) {
        GetFieldValue(State->Heap, "_HEAP", "PseudoTagEntries", pPseudoTagEntry);
        if (pPseudoTagEntry == 0) {
            return FALSE;
            }

        s = &State->StopOnTagName[ 7 ];
        if (*s == L'>') {
            GetFieldValue(State->Heap, "_HEAP", "ProcessHeapsListIndex", State->StopOnTag.HeapIndex);
            State->StopOnTag.TagIndex = HEAP_PSEUDO_TAG_FLAG;
            return TRUE;
            }
        else
        if (*s == L'=') {
            while (*++s == L' ') ;
            State->StopOnTag.TagIndex = (USHORT)_wtoi( s );
            if (State->StopOnTag.TagIndex > 0 &&
                State->StopOnTag.TagIndex < (HEAP_MAXIMUM_FREELISTS >> HEAP_GRANULARITY_SHIFT)
               ) {
                GetFieldValue(State->Heap, "_HEAP", "ProcessHeapsListIndex", State->StopOnTag.HeapIndex);
                State->StopOnTag.TagIndex = (State->StopOnTag.TagIndex >> HEAP_GRANULARITY_SHIFT) |
                                             HEAP_PSEUDO_TAG_FLAG;
                return TRUE;
                }
            }
        }

    GetFieldValue(State->Heap, "_HEAP", "TagEntries", pTagEntry);
    if (pTagEntry == 0) {
        return FALSE;
        }

    
    GetFieldValue(State->HeapAddress, "_HEAP", "NextAvailableTagIndex", NextAvailableTagIndex);
    TagEntrySize = GetTypeSize("_HEAP_TAG_ENTRY");

    for (TagIndex=1; TagIndex<NextAvailableTagIndex; TagIndex++) {

        pTagEntry += TagEntrySize;
        b = GetFieldValue( pTagEntry,"_HEAP_TAG_ENTRY","TagName",TagName);
        if (!b && !_wcsicmp( State->StopOnTagName, TagName )) {
            GetFieldValue( pTagEntry,"_HEAP_TAG_ENTRY","TagIndex",State->StopOnTag.TagIndex);
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
GetHeapTagEntry(
    IN ULONG64 Heap,
    IN USHORT TagIndex,
    OUT PULONG64 TagEntry
    )
{
    BOOL b;
    ULONG64 pTagEntries;// PHEAP_TAG_ENTRY
    ULONG NextAvailableTagIndex;
    ULONG64 pPseudoTagEntries; // PHEAP_PSEUDO_TAG_ENTRY

    b = FALSE;
    if (TagIndex & HEAP_PSEUDO_TAG_FLAG) {
        TagIndex &= ~HEAP_PSEUDO_TAG_FLAG;
        GetFieldValue(Heap, "_HEAP", "PseudoTagEntries", pPseudoTagEntries);
        if (pPseudoTagEntries == 0) {
            return FALSE;
        }
        // BUGBUG - Cannot copy name 
        /*
        if (TagIndex == 0) {
            swprintf( TagEntry->TagName, L"Objects>%4u",
                      HEAP_MAXIMUM_FREELISTS << HEAP_GRANULARITY_SHIFT
                      );
        }
        else
        if (TagIndex < HEAP_MAXIMUM_FREELISTS) {
            swprintf( TagEntry->TagName, L"Objects=%4u", TagIndex << HEAP_GRANULARITY_SHIFT );
        }
        else {
            swprintf( TagEntry->TagName, L"VirtualAlloc" );
        }
        TagEntry->TagIndex = TagIndex;
        TagEntry->CreatorBackTraceIndex = 0;*/

        *TagEntry = pPseudoTagEntries + TagIndex * GetTypeSize("_HEAP_PSEUDO_TAG_ENTRY");

        b = !InitTypeRead(*TagEntry, _HEAP_TAG_ENTRY);
    }
    else
    if (TagIndex & HEAP_GLOBAL_TAG) {

        if (GetFieldValue(pRtlpGlobalTagHeap, "_HEAP", "NextAvailableTagIndex",NextAvailableTagIndex)) {
                return FALSE;
        }
        TagIndex &= ~HEAP_GLOBAL_TAG;
        if (TagIndex < NextAvailableTagIndex) {
            GetFieldValue(pRtlpGlobalTagHeap, "_HEAP", "TagEntries", pTagEntries);
            if (pTagEntries == 0) {
                return FALSE;
            }
            *TagEntry = pTagEntries;
            b = ! (BOOL) InitTypeRead(pTagEntries, _HEAP_TAG_ENTRY);
        }
    }
    else {
        if (GetFieldValue(Heap, "_HEAP", "NextAvailableTagIndex",NextAvailableTagIndex)) {
                return FALSE;
        }        
        if (TagIndex < NextAvailableTagIndex) {
            GetFieldValue(Heap, "_HEAP", "TagEntries", pTagEntries);
            if (pTagEntries == 0) {
                return FALSE;
            }

            *TagEntry = pTagEntries;
            b = ! (BOOL) InitTypeRead(pTagEntries, _HEAP_TAG_ENTRY);
        }
    }

    return b;
}


VOID
WalkHEAP(
    IN PHEAP_STATE State
    )
{
    BOOL b;
    ULONG64 FreeListHead;
    ULONG i;
    ULONG64 Head, Next;
//    HEAP_VIRTUAL_ALLOC_ENTRY VirtualAllocEntry;
    ULONG64 TagEntry; // HEAP_TAG_ENTRY
    ULONG64 FreeEntryAddress;
    ULONG64 FreeEntry; // HEAP_FREE_ENTRY
    ULONG64 UCRSegment, UnusedUnCommittedRanges;
    ULONG64 CapturedUCRSegment; // HEAP_UCR_SEGMENT 
    ULONG AlignRound, Offset, ListSize, FreeListOffset;

    GetFieldOffset("_HEAP", "VirtualAllocdBlocks", &Offset);
    if (InitTypeRead(State->HeapAddress, _HEAP)) {
        return;
    }

    AlignRound = (ULONG)ReadField(AlignRound) - GetTypeSize( "_HEAP_ENTRY" );
    if ((ULONG)ReadField(Flags) & HEAP_TAIL_CHECKING_ENABLED) {
        AlignRound -= CHECK_HEAP_TAIL_SIZE;
        }

    dprintf( "    Flags:               %08x\n", (ULONG)ReadField(Flags) );
    dprintf( "    ForceFlags:          %08x\n", (ULONG)ReadField(ForceFlags) );
    dprintf( "    Granularity:         %u bytes\n", AlignRound + 1 );
    dprintf( "    Segment Reserve:     %08x\n", (ULONG)ReadField(SegmentReserve) );
    dprintf( "    Segment Commit:      %08x\n", (ULONG)ReadField(SegmentCommit) );
    dprintf( "    DeCommit Block Thres:%08x\n", (ULONG)ReadField(DeCommitFreeBlockThreshold) );
    dprintf( "    DeCommit Total Thres:%08x\n", (ULONG)ReadField(DeCommitTotalFreeThreshold) );
    dprintf( "    Total Free Size:     %08x\n", (ULONG)ReadField(TotalFreeSize) );
    dprintf( "    Max. Allocation Size:%08x\n", (ULONG)ReadField(MaximumAllocationSize) );
    dprintf( "    Lock Variable at:    %08x\n", (ULONG)ReadField(LockVariable) );
    dprintf( "    Next TagIndex:       %04x\n", (ULONG)ReadField(NextAvailableTagIndex) );
    dprintf( "    Maximum TagIndex:    %04x\n", (ULONG)ReadField(MaximumTagIndex) );
    dprintf( "    Tag Entries:         %08x\n", (ULONG)ReadField(TagEntries) );
    dprintf( "    PsuedoTag Entries:   %08x\n", (ULONG)ReadField(PseudoTagEntries) );
    dprintf( "    Virtual Alloc List:  %08p\n", State->HeapAddress + Offset);

    UCRSegment = ReadField(UCRSegments);
    UnusedUnCommittedRanges = ReadField(UnusedUnCommittedRanges);
    Head = State->HeapAddress + Offset;
    Next = ReadField(VirtualAllocdBlocks.Flink);
    while (Next != Head) {
        ULONG Flags, TagIndex;

        if (InitTypeRead( Next, _HEAP_VIRTUAL_ALLOC_ENTRY)) {
            dprintf( "    Unable to read _HEAP_VIRTUAL_ALLOC_ENTRY structure at %p\n", Next );
            break;
        }

        if (State->DumpHeapEntries) {
            dprintf( "        %08p: %08x [%02x] - busy (%x)",
                     Next,
                     (ULONG)ReadField(CommitSize),
                     (ULONG)ReadField(CommitSize) - (ULONG)ReadField(BusyBlock.Size),
                     Flags = (ULONG)ReadField(BusyBlock.Flags)
                   );

            if ((ULONG)ReadField(BusyBlock.Flags) & HEAP_ENTRY_FILL_PATTERN) {
                dprintf( ", tail fill" );
            }
            if ((ULONG)ReadField(ExtraStuff.Settable)) {
                dprintf( " (Handle %08x)", (ULONG)ReadField(ExtraStuff.Settable) );
            }

            if (TagIndex = (ULONG)ReadField(ExtraStuff.TagIndex)) {
                WCHAR TagName[32];
                if (GetHeapTagEntry( State->Heap, (USHORT) (TagIndex), &TagEntry )) {
                    GetFieldValue(TagEntry, "_HEAP_TAG_ENTRY", "TagName", TagName);
                    dprintf( " (%ws)", TagName );
                }
                else {
                    dprintf( " (Tag %x)", (TagIndex) );
                }
            }

            if ((Flags) & HEAP_ENTRY_SETTABLE_FLAGS) {
                dprintf( ", user flags (%x)", ((Flags) & HEAP_ENTRY_SETTABLE_FLAGS) >> 5 );
            }

            dprintf( "\n" );
#if STACK_TRACE_DATABASE_SUPPORT
            DumpStackBackTraceIndex( State, (ULONG)ReadField(ExtraStuff.AllocatorBackTraceIndex) );
#endif // STACK_TRACE_DATABASE_SUPPORT
        }

        if (ReadField(Entry.Flink) == Next) {
            dprintf( "        **** List is hosed\n");
            break;
        }

        Next = ReadField(Entry.Flink);
    }

    dprintf( "    UCR FreeList:        %p\n", UnusedUnCommittedRanges );
    while (UCRSegment != 0) {
        b = (BOOL) InitTypeRead( UCRSegment, _HEAP_UCR_SEGMENT);
        if (b) {
            dprintf( "    Unable to read _HEAP_UCR_SEGMENT structure at %08p\n", UCRSegment );
            break;
        }
        else {
            dprintf( "    UCRSegment - %08p: %08I64x . %08I64x\n",
                     UCRSegment,
                     ReadField(CommittedSize),
                     ReadField(ReservedSize)
                     );
        }

        if (State->ComputeSummary) {
            State->OverheadSize += ReadField(CommittedSize);
        }

        UCRSegment = ReadField(Next);
    }

    InitTypeRead(State->HeapAddress, _HEAP);

    dprintf( "    FreeList Usage:      %08x %08x %08x %08x\n",
             (ULONG)ReadField(u.FreeListsInUseUlong[0]),
             (ULONG)ReadField(u.FreeListsInUseUlong[1]),
             (ULONG)ReadField(u.FreeListsInUseUlong[2]),
             (ULONG)ReadField(u.FreeListsInUseUlong[3])
           );

    if (State->ComputeSummary) {
        State->OverheadSize += GetTypeSize( "_HEAP" );
        dprintf( "Committed   Allocated     Free      OverHead\n" );
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        
    }


    GetFieldOffset ("_HEAP", "FreeLists", &Offset);
    ListSize = GetTypeSize("LIST_ENTRY");
    GetFieldOffset ("_HEAP_FREE_ENTRY", "FreeList", &FreeListOffset);

    for (i=0; i<HEAP_MAXIMUM_FREELISTS; i++) {
        ULONG64 Flink, Blink;

        FreeListHead = State->HeapAddress + Offset + ListSize * i;
        
        GetFieldValue(FreeListHead, "LIST_ENTRY", "Flink", Flink);
        GetFieldValue(FreeListHead, "LIST_ENTRY", "Blink", Blink);

        if (Flink != Blink ||
            Flink != FreeListHead
            ) {

            ULONG Count = 0;

            dprintf( "    FreeList[ %02x ] at %08p: %08p . %08p  ",
                     i,
                     FreeListHead,
                     Blink,
                     Flink
                     );
            
            if (State->DumpHeapFreeLists) {
                dprintf("\n");
            }

            Next = Flink;
            while (Next != FreeListHead) {
                Count++;
                FreeEntryAddress = Next - FreeListOffset;
                b = (BOOL) InitTypeRead ( FreeEntryAddress, _HEAP_FREE_ENTRY);
                if (b) {
                    dprintf( "    Unable to read HEAP_ENTRY structure at %08p\n", FreeEntryAddress );
                    break;
                    }

                if (State->DumpHeapFreeLists) {
                    dprintf( "        %08x: %05x . %05x [%02x] - free\n",
                             FreeEntryAddress,
                             (ULONG)ReadField(PreviousSize) << HEAP_GRANULARITY_SHIFT,
                             (ULONG)ReadField(Size) << HEAP_GRANULARITY_SHIFT,
                             (ULONG)ReadField(Flags)
                           );
                    }

                Next = ReadField(FreeList.Flink);

                if (CheckControlC()) {
                    return;
                    }
                }

                if (!State->DumpHeapFreeLists) {
                    
                    dprintf( " (%ld block%c)\n", 
                             Count, 
                             (Count == 1 ? ' ' : 's')
                           );
                }
            }
        }

    for (i=0; i<HEAP_MAXIMUM_SEGMENTS; i++) {
        if (State->Segments[ i ] != 0) {
            State->SegmentNumber = i;
            State->SegmentAddress = State->Segments[ i ];
            WalkHEAP_SEGMENT( State );
        }

        if (State->ExitDumpLoop || CheckControlC()) {
            break;
        }
    }

    if (State->HeapAddress == State->HeapToDump) {
        State->ExitDumpLoop = TRUE;
    }

    return;
}

VOID
WalkHEAP_SEGMENT(
    IN PHEAP_STATE State
    )
{
    ULONG64 Segment; // PHEAP_SEGMENT
    BOOL b;
    BOOLEAN DumpEntry;
    ULONG64 EntryAddress, PrevEntryAddress, NextEntryAddress; // PHEAP_ENTRY
    ULONG64 Entry, PrevEntry;
    ULONG64 UnCommittedRanges; // PHEAP_UNCOMMMTTED_RANGE
    ULONG64 UnCommittedRangeStart, UnCommittedRange, UnCommittedRangeEnd;
    ULONG64 BaseAddress, LastValidEntry;
    ULONG NumberOfUnCommittedPages, NumberOfPages;
    ULONG EntryOffset;

    Segment = State->Segments[ State->SegmentNumber ];
    if (State->ComputeSummary) {
        State->OverheadSize += GetTypeSize( "_HEAP_SEGMENT" );
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    InitTypeRead(Segment, _HEAP_SEGMENT);

    if (State->DumpHeapSegments) {
        dprintf( "    Segment%02u at %08x:\n", State->SegmentNumber, State->SegmentAddress );
        dprintf( "        Flags:           %08x\n", (ULONG)ReadField(Flags) );
        dprintf( "        Base:            %08p\n", 
                 BaseAddress = ReadField(BaseAddress) );
        dprintf( "        First Entry:     %08x\n", (ULONG)ReadField(FirstEntry) );
        dprintf( "        Last Entry:      %08p\n", 
                 LastValidEntry = ReadField(LastValidEntry) );
        dprintf( "        Total Pages:     %08x\n", 
                 NumberOfPages = (ULONG)ReadField(NumberOfPages) );
        dprintf( "        Total UnCommit:  %08x\n", 
                 NumberOfUnCommittedPages = (ULONG)ReadField(NumberOfUnCommittedPages) );
        dprintf( "        Largest UnCommit:%08x\n", (ULONG)ReadField(LargestUnCommittedRange) );
        dprintf( "        UnCommitted Ranges: (%u)\n", (ULONG)ReadField(NumberOfUnCommittedRanges) );
        }

    UnCommittedRangeStart = UnCommittedRanges = ReadField(UnCommittedRanges);
    while (UnCommittedRanges != 0) {
        b = (BOOL) InitTypeRead( UnCommittedRanges, _HEAP_UNCOMMMTTED_RANGE);
        if (b) {
            dprintf( "            unable to read uncommited range structure at %p\n",
                     UnCommittedRanges
                   );
            return;
            }

        if (State->DumpHeapSegments) {
            dprintf( "            %08I64x: %08x\n", ReadField(Address), (ULONG) ReadField(Size) );
        }

        UnCommittedRanges = ReadField(Next);

        if (CheckControlC()) {
            break;
            }
        }

    if (State->DumpHeapSegments) {
        dprintf( "\n" );
        }

    if (!GetPageSize()) {
        dprintf("Unable to get PageSize.\n");
        return;

    }

    State->CommittedSize += ( NumberOfPages -
                                    NumberOfUnCommittedPages
                                  ) * PageSize;
    if (State->ComputeSummary) {
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
        }

    if (State->DumpHeapEntries) {
        dprintf( "    Heap entries for Segment%02u in Heap %p\n", State->SegmentNumber, State->HeapAddress );
        }

    UnCommittedRangeEnd = UnCommittedRanges;
    UnCommittedRanges = UnCommittedRangeStart;
    if (BaseAddress == State->HeapAddress) {
        GetFieldOffset("_HEAP", "Entry", &EntryOffset);
        EntryAddress = State->HeapAddress + EntryOffset;
    }
    else {
        GetFieldOffset("_HEAP_SEGMENT", "Entry", &EntryOffset);
        EntryAddress = State->Segments[ State->SegmentNumber ] + EntryOffset;
    }

    PrevEntryAddress = 0;
    while (EntryAddress < LastValidEntry) {
        ULONG Flags, Size, UnusedBytes;
        
        b = (BOOL) InitTypeRead(EntryAddress, _HEAP_ENTRY);
        if (b) {
            dprintf( "            unable to read heap entry at %08p\n", EntryAddress );
            break;
        }

        NextEntryAddress = EntryAddress + (Size = (ULONG) ReadField(Size) * HeapEntryTypeSize);
        Flags = (ULONG) ReadField(Flags);
        UnusedBytes = (ULONG) ReadField(UnusedBytes);

        if (State->DumpHeapEntries) {
            DumpEntry = TRUE;
        }
        else
        if (PrevEntryAddress != 0 &&
            (State->HeapEntryToDump == PrevEntryAddress ||
             (State->HeapEntryToDump > PrevEntryAddress &&
              State->HeapEntryToDump <= NextEntryAddress
              )
             )
            ) {
           DumpEntry = TRUE;
        }
        else {
            DumpEntry = FALSE;
        }

        if (DumpEntry) {
            DumpHeapEntry( State, EntryAddress, EntryAddress );
        }

        if (!(Flags & HEAP_ENTRY_BUSY)) {
            State->TotalFreeSize += Size;
        }

        if (State->ComputeSummary) {
            if (Flags & HEAP_ENTRY_BUSY) {
                State->AllocatedSize += Size << HEAP_GRANULARITY_SHIFT;
                State->AllocatedSize -= UnusedBytes;
                State->OverheadSize += UnusedBytes;
            }
            else {
                State->FreeSize += Size << HEAP_GRANULARITY_SHIFT;
            }
        }

        if (State->ValidateHeap) {
            if (!ValidateHeapEntry( State,
                                    PrevEntryAddress,
                                    PrevEntryAddress,
                                    EntryAddress,
                                    EntryAddress
                                    )
                ) {
                if (State->DumpHeapEntries) {
                    break;
                }
            }
        }

        if (Size == 0 || CheckControlC()) {
            break;
        }

        PrevEntryAddress = EntryAddress;
        // PrevEntry = Entry;
        EntryAddress = NextEntryAddress;
        if (Flags & HEAP_ENTRY_LAST_ENTRY) {

            if (State->ComputeSummary) {
                dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                         State->CommittedSize,
                         State->AllocatedSize,
                         State->FreeSize,
                         State->OverheadSize
                         );
            }

            InitTypeRead(UnCommittedRanges, _HEAP_UNCOMMMTTED_RANGE);

            if (EntryAddress == ReadField(Address)) {

                Size = (ULONG) ReadField(Size);

                if (DumpEntry) {
                    dprintf( "        %p:      %08x      - uncommitted bytes.\n",
                             EntryAddress,
                             Size
                             );
                }

                PrevEntryAddress = 0;
                EntryAddress += Size;

                UnCommittedRanges = ReadField(Next);;
            }
            else {
                break;
            }
        }
    }

    if (State->ComputeSummary) {
        dprintf( "% 8x    % 8x      % 8x  % 8x\r",
                 State->CommittedSize,
                 State->AllocatedSize,
                 State->FreeSize,
                 State->OverheadSize
               );
    }

    return;
}

struct {
    BOOL  HaveOffset;
    ULONG Offset;
    LPSTR Description;
} FieldOffsets[] = {
    0, 0,    "Entry",
    0, 0,    "Signature",
    0, 0,    "Flags",
    0, 0,    "ForceFlags",
    0, 0,    "VirtualMemoryThreshold",
    0, 0,    "SegmentReserve",
    0, 0,    "SegmentCommit",
    0, 0,    "DeCommitFreeBlockThreshold",
    0, 0,    "DeCommitTotalFreeThreshold",
    0, 0,    "TotalFreeSize",
    0, 0,    "MaximumAllocationSize",
    0, 0,    "ProcessHeapsListIndex",
    0, 0,    "HeaderValidateLength",
    0, 0,    "HeaderValidateCopy",
    0, 0,    "NextAvailableTagIndex",
    0, 0,    "MaximumTagIndex",
    0, 0,    "TagEntries",
    0, 0,    "UCRSegments",
    0, 0,    "UnusedUnCommittedRanges",
    0, 0,    "AlignRound",
    0, 0,    "AlignMask",
    0, 0,    "VirtualAllocdBlocks",
    0, 0,    "Segments",
    0, 0,    "FreeListsInUse",
    0, 0,    "FreeListsInUseTerminate",
    0, 0,    "AllocatorBackTraceIndex",
    0, 0,    "Reserved1",
    0, 0,    "PseudoTagEntries",
    0, 0,    "FreeLists",
    0, 0,    "LockVariable",
//     1, GetTypeSize("HEAP"),                                     "Uncommitted Ranges",
    0, 0xFFFF, NULL
};

BOOL
ValidateHeapHeader(
    IN ULONG64 HeapAddress
    )
{
    PVOID CurrentHeaderValidate;
    PVOID PreviousHeaderValidate;
    ULONG i, n, nEqual;
    ULONG64 HeaderValidateCopy;
    BOOL b;

    if (InitTypeRead(HeapAddress, _HEAP)) {
        return FALSE;
    }

    if (ReadField(Signature) != HEAP_SIGNATURE) {
        dprintf( "Heap at %p contains invalid signature.\n" );
        return FALSE;
        }

    n = (ULONG) ReadField(HeaderValidateLength);
    if (n == 0 || (HeaderValidateCopy = ReadField(HeaderValidateCopy)) == 0) {
        return TRUE;
    }

    b = FALSE;
    CurrentHeaderValidate = malloc( n );
    if (CurrentHeaderValidate != NULL) {
        PreviousHeaderValidate = malloc( n );
        if (PreviousHeaderValidate != NULL) {
            b = ReadMemory( HeapAddress,
                            CurrentHeaderValidate,
                            n,
                            NULL
                          );
            if (b) {
                b = ReadMemory( (HeaderValidateCopy),
                                PreviousHeaderValidate,
                                n,
                                NULL
                              );
                if (b) {
                    nEqual = (ULONG)RtlCompareMemory( CurrentHeaderValidate,
                                               PreviousHeaderValidate,
                                               n
                                             );
                    if (nEqual != n) {
                        dprintf( "HEAPEXT: Heap %p - headers modified (%p is %x instead of %x)\n",
                                 HeapAddress,
                                 HeapAddress + nEqual,
                                 *(PULONG)((PCHAR)CurrentHeaderValidate  + nEqual),
                                 *(PULONG)((PCHAR)PreviousHeaderValidate + nEqual)
                               );
                        for (i=0; FieldOffsets[ i ].Description != NULL; i++) {

                            if (!FieldOffsets[i].HaveOffset) {
                                GetFieldOffset("_HEAP", FieldOffsets[i].Description, &FieldOffsets[i].Offset);
                                FieldOffsets[i].HaveOffset = TRUE;
                            }
                            if (nEqual >= FieldOffsets[ i ].Offset &&
                                nEqual < FieldOffsets[ i+1 ].Offset
                               ) {
                                dprintf( "    This is located in the %s field of the heap header.\n",
                                         FieldOffsets[ i ].Description
                                       );
                                }
                            }

                        b = FALSE;
                    }
                }
                else {
                    dprintf( "HEAPEXT: Unable to read copy of heap headers.\n" );
                }
            }
            else {
                dprintf( "HEAPEXT: Unable to read heap headers.\n" );
            }
        }
        else {
            dprintf( "HEAPEXT: Unable to allocate memory for heap header copy.\n" );
        }
    }
    else {
        dprintf( "HEAPEXT: Unable to allocate memory for heap header.\n" );
    }

    return b;
}

UCHAR CheckHeapFillPattern[ 20 ] = {
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL,
    CHECK_HEAP_TAIL_FILL
};

BOOL
ValidateHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 PrevEntryAddress,
    IN ULONG64 PrevEntry,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    )
{
    UCHAR EntryTail[ 20  ]; // CHECK_HEAP_TAIL_SIZE
    ULONG FreeFill[ 256 ];
    ULONG64 FreeAddress;
    ULONG tSize, cb, cbEqual;
    BOOL b;
    ULONG PreviousSize, Flags, Size, UnusedBytes, SmallTagIndex;
    ULONG SizeOfEntry;

    SizeOfEntry = GetTypeSize("_HEAP_ENTRY");
    InitTypeRead(EntryAddress, _HEAP_ENTRY);
    (PreviousSize = (ULONG) ReadField(PreviousSize));
    (Size = (ULONG) ReadField(Size));
    (Flags = (ULONG) ReadField(Flags));
    UnusedBytes = (ULONG) ReadField(UnusedBytes);
    SmallTagIndex = (ULONG) ReadField(SmallTagIndex);

    InitTypeRead(PrevEntryAddress, _HEAP_ENTRY);
    if (PrevEntryAddress == 0 && PreviousSize != 0) {
        dprintf( "    PreviousSize field is non-zero when it should be zero to mark first entry\n" );
        return FALSE;
    }

    if (PrevEntryAddress != 0 && PreviousSize != (ULONG) ReadField(Size)) {
        dprintf( "    PreviousSize field does not match size in previous entry\n" );
        return FALSE;
    }

    if (Flags & HEAP_ENTRY_BUSY) {
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            tSize = (Size << HEAP_GRANULARITY_SHIFT) - UnusedBytes;
            b = ReadMemory( (EntryAddress+ HeapEntryTypeSize + tSize),
                            EntryTail,
                            sizeof( EntryTail ),
                            NULL
                          );
            if (b) {
                cbEqual = (ULONG)RtlCompareMemory( EntryTail,
                                            CheckHeapFillPattern,
                                            CHECK_HEAP_TAIL_SIZE
                                          );
                if (cbEqual != CHECK_HEAP_TAIL_SIZE) {
                    dprintf( "    Heap block at %p modified at %p past requested size of %x (%x * 8 - %x)\n",
                             EntryAddress,
                             EntryAddress + HeapEntryTypeSize + tSize + cbEqual,
                             tSize, Size, UnusedBytes
                           );
                    return FALSE;
                    }
                }
            else {
                dprintf( "    Unable to read tail of heap block at %p\n", EntryAddress );
                return FALSE;
                }
            }
        }
    else {
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            tSize = (Size - 2) << HEAP_GRANULARITY_SHIFT;
            if (Flags & HEAP_ENTRY_EXTRA_PRESENT &&
                tSize > GetTypeSize( "_HEAP_FREE_ENTRY_EXTRA" )
               ) {
                tSize -= GetTypeSize( "_HEAP_FREE_ENTRY_EXTRA" );
                }
            FreeAddress = EntryAddress + GetTypeSize("_HEAP_FREE_ENTRY");
            while (tSize != 0) {
                if (tSize > sizeof( FreeFill )) {
                    cb = sizeof( FreeFill );
                }
                else {
                    cb = tSize;
                }
                b = ReadMemory( FreeAddress,
                                FreeFill,
                                cb,
                                NULL
                                );
                if (b) {
                    cbEqual = (ULONG)RtlCompareMemoryUlong( FreeFill, cb, FREE_HEAP_FILL );
                    if (cbEqual != cb) {                                                            \
                        dprintf( "    Free Heap block %p modified at %p after it was freed\n",
                                 EntryAddress,
                                 FreeAddress + cbEqual
                                 );

                    return FALSE;
                    }
                }
                else {
                    dprintf( "    Unable to portion of free heap block at %p\n", EntryAddress );
                    return FALSE;
                }

                tSize -= cb;
            }
        }
    }

    return TRUE;
}


VOID
DumpHeapEntry(
    IN PHEAP_STATE State,
    IN ULONG64 EntryAddress,
    IN ULONG64 Entry
    )
{
    BOOL b;
    WCHAR TagName[32];
//    HEAP_ENTRY_EXTRA EntryExtra;
    ULONG64 TagEntry; // HEAP_TAG_ENTRY
//    HEAP_FREE_ENTRY_EXTRA FreeExtra;
    ULONG64 p;
    USHORT BackTraceIndex;
    ULONG PreviousSize, Size, Flags, UnusedBytes, SmallTagIndex;
    ULONG SizeOfEntry;

    SizeOfEntry = GetTypeSize("_HEAP_ENTRY");
    InitTypeRead(EntryAddress, _HEAP_ENTRY);
    dprintf( "        %p: %05x . %05x [%02x]",
             EntryAddress,
             (PreviousSize = (ULONG) ReadField(PreviousSize)) << HEAP_GRANULARITY_SHIFT,
             (Size = (ULONG) ReadField(Size)) << HEAP_GRANULARITY_SHIFT,
             (Flags = (ULONG) ReadField(Flags))
           );
    BackTraceIndex = 0;
    UnusedBytes = (ULONG) ReadField(UnusedBytes);
    SmallTagIndex = (ULONG) ReadField(SmallTagIndex);
    if (Flags & HEAP_ENTRY_BUSY) {
        dprintf( " - busy (%x)",
                 (Size << HEAP_GRANULARITY_SHIFT) - UnusedBytes
               );
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            dprintf( ", tail fill" );
            }
        if (Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            p = EntryAddress + SizeOfEntry * (Size - 1);
            b = (BOOL) InitTypeRead( p, _HEAP_ENTRY_EXTRA);
            if (b) {
                dprintf( " - unable to read heap entry extra at %p", p );
            }
            else {
                BackTraceIndex = (USHORT)ReadField(AllocatorBackTraceIndex);
                if ((ULONG)ReadField(Settable)) {
                    dprintf( " (Handle %08x)", (ULONG)ReadField(Settable) );
                }
                if ((ULONG)ReadField(TagIndex)) {
                    if (GetHeapTagEntry( State->Heap, (USHORT)ReadField(TagIndex), &TagEntry )) {
                        GetFieldValue(TagEntry, "_HEAP_TAG_ENTRY", "TagName", TagName);
                        dprintf( " (%ws)", TagName );
                    }
                    else {
                        dprintf( " (Tag %x)", (ULONG)ReadField(TagIndex) );
                    }
                }
            }
        }
        else
        if (SmallTagIndex) {
            if (GetHeapTagEntry( State->Heap, (USHORT) SmallTagIndex, &TagEntry )) {
                GetFieldValue(TagEntry, "_HEAP_TAG_ENTRY", "TagName", TagName);
                dprintf( " (%ws)", TagName );
                }
            else {
                dprintf( " (Tag %x)", SmallTagIndex );
                }
            }

        if (Flags & HEAP_ENTRY_SETTABLE_FLAGS) {
            dprintf( ", user flags (%x)", (Flags & HEAP_ENTRY_SETTABLE_FLAGS) >> 5 );
            }

        dprintf( "\n" );
        }
    else {
        if (Flags & HEAP_ENTRY_FILL_PATTERN) {
            dprintf( " free fill" );
            }

        if (Flags & HEAP_ENTRY_EXTRA_PRESENT) {
            p = (EntryAddress + SizeOfEntry * (Size - 1));
            b = (BOOL) InitTypeRead( p, _HEAP_ENTRY_EXTRA);
            if (b) {
                dprintf( " - unable to read heap free extra at %p", p );
                }
            else {
                BackTraceIndex = (USHORT)ReadField(FreeBackTraceIndex);
                if (GetHeapTagEntry( State->Heap, (USHORT)ReadField(TagIndex), &TagEntry )) {
                    GetFieldValue(TagEntry, "_HEAP_TAG_ENTRY", "TagName", TagName);
                    dprintf( " (%ws)", TagName );
                    }
                else {
                    dprintf( " (Tag %x at %p)", (ULONG)ReadField(TagIndex), p );
                    }
                }
            }

        dprintf( "\n" );
        }

#if STACK_TRACE_DATABASE_SUPPORT
    DumpStackBackTraceIndex( State, BackTraceIndex );
#endif // STACK_TRACE_DATABASE_SUPPORT
    return;
}


#if STACK_TRACE_DATABASE_SUPPORT && 0
VOID
DumpStackBackTraceIndex(
    IN PHEAP_STATE State,
    IN USHORT BackTraceIndex
    )
{
    BOOL b;
    PRTL_STACK_TRACE_ENTRY pBackTraceEntry;
    RTL_STACK_TRACE_ENTRY BackTraceEntry;
    ULONG i;
    CHAR Symbol[ 1024 ];
    ULONG_PTR Displacement;

    ULONG NumberOfEntriesAdded;
    PRTL_STACK_TRACE_ENTRY *EntryIndexArray;    // Indexed by [-1 .. -NumberOfEntriesAdded]

    if (State->DumpStackBackTrace &&
        BackTraceIndex != 0 &&
        pRtlpStackTraceDataBase != NULL
       ) {
        if (!HaveCopyOfStackTraceDataBase) {
            b = ReadMemory( (ULONG_PTR)pRtlpStackTraceDataBase,
                            &RtlpStackTraceDataBase,
                            sizeof( RtlpStackTraceDataBase ),
                            NULL
                          );
            if (!b || RtlpStackTraceDataBase == NULL) {
                State->DumpStackBackTrace = FALSE;
                return;
                }

            b = ReadMemory( (ULONG_PTR)RtlpStackTraceDataBase,
                            &StackTraceDataBase,
                            sizeof( StackTraceDataBase ),
                            NULL
                          );
            if (!b) {
                State->DumpStackBackTrace = FALSE;
                return;
                }

            HaveCopyOfStackTraceDataBase = TRUE;
            }

        if (BackTraceIndex < StackTraceDataBase.NumberOfEntriesAdded) {
            b = ReadMemory( (ULONG_PTR)(StackTraceDataBase.EntryIndexArray - BackTraceIndex),
                            &pBackTraceEntry,
                            sizeof( pBackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace index (%x) entry at %p\n",
                         BackTraceIndex,
                         (StackTraceDataBase.EntryIndexArray - BackTraceIndex)
                       );
                return;
                }

            b = ReadMemory( (ULONG_PTR)pBackTraceEntry,
                            &BackTraceEntry,
                            sizeof( BackTraceEntry ),
                            NULL
                          );
            if (!b) {
                dprintf( "    unable to read stack back trace entry at %p\n",
                         BackTraceIndex,
                         pBackTraceEntry
                       );
                return;
                }

            dprintf( "            Stack trace (%u) at %x:\n", BackTraceIndex, pBackTraceEntry );
            for (i=0; i<BackTraceEntry.Depth; i++) {
                GetSymbol( (LPVOID)BackTraceEntry.BackTrace[ i ],
                           Symbol,
                           &Displacement
                         );
                dprintf( "                %08x: %s", BackTraceEntry.BackTrace[ i ], Symbol );
                if (Displacement != 0) {
                    dprintf( "+0x%p", Displacement );
                    }
                dprintf( "\n" );
                }
            }
        }
}
#endif // STACK_TRACE_DATABASE_SUPPORT

#if 0
int
__cdecl
_wtoi(
    const wchar_t *nptr
    )
{
    NTSTATUS Status;
    ULONG Value;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, nptr );
    Status = RtlUnicodeStringToInteger( &UnicodeString, 10, &Value );
    if (NT_SUCCESS( Status )) {
        return (int)Value;
        }
    else {
        return 0;
        }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    WinDbg Extension Api

Author:

    Kshitiz K Sharma

Environment:

    User/Kernel Mode.

Revision History:

--*/

#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PageSize) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0


#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001


#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE GetTypeSize("HEAP_ENTRY")
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#define HEAP_NO_SERIALIZE               0x00000001      // winnt
#define HEAP_GROWABLE                   0x00000002      // winnt
#define HEAP_GENERATE_EXCEPTIONS        0x00000004      // winnt
#define HEAP_ZERO_MEMORY                0x00000008      // winnt
#define HEAP_REALLOC_IN_PLACE_ONLY      0x00000010      // winnt
#define HEAP_TAIL_CHECKING_ENABLED      0x00000020      // winnt
#define HEAP_FREE_CHECKING_ENABLED      0x00000040      // winnt
#define HEAP_DISABLE_COALESCE_ON_FREE   0x00000080      // winnt

#define HEAP_CREATE_ALIGN_16            0x00010000      // winnt Create heap with 16 byte alignment (obsolete)
#define HEAP_CREATE_ENABLE_TRACING      0x00020000      // winnt Create heap call tracing enabled (obsolete)

#define HEAP_SETTABLE_USER_VALUE        0x00000100
#define HEAP_SETTABLE_USER_FLAG1        0x00000200
#define HEAP_SETTABLE_USER_FLAG2        0x00000400
#define HEAP_SETTABLE_USER_FLAG3        0x00000800
#define HEAP_SETTABLE_USER_FLAGS        0x00000E00

#define HEAP_CLASS_0                    0x00000000      // process heap
#define HEAP_CLASS_1                    0x00001000      // private heap
#define HEAP_CLASS_2                    0x00002000      // Kernel Heap
#define HEAP_CLASS_3                    0x00003000      // GDI heap
#define HEAP_CLASS_4                    0x00004000      // User heap
#define HEAP_CLASS_5                    0x00005000      // Console heap
#define HEAP_CLASS_6                    0x00006000      // User Desktop heap
#define HEAP_CLASS_7                    0x00007000      // Csrss Shared heap
#define HEAP_CLASS_8                    0x00008000      // Csr Port heap
#define HEAP_CLASS_MASK                 0x0000F000

#define HEAP_MAXIMUM_TAG                0x0FFF              // winnt
#define HEAP_GLOBAL_TAG                 0x0800
#define HEAP_PSEUDO_TAG_FLAG            0x8000              // winnt
#define HEAP_TAG_SHIFT                  18                  // winnt
#define HEAP_MAKE_TAG_FLAGS( b, o ) ((ULONG)((b) + ((o) << 18)))  // winnt
#define HEAP_TAG_MASK                  (HEAP_MAXIMUM_TAG << HEAP_TAG_SHIFT)

#define HEAP_CREATE_VALID_MASK         (HEAP_NO_SERIALIZE |             \
                                        HEAP_GROWABLE |                 \
                                        HEAP_GENERATE_EXCEPTIONS |      \
                                        HEAP_ZERO_MEMORY |              \
                                        HEAP_REALLOC_IN_PLACE_ONLY |    \
                                        HEAP_TAIL_CHECKING_ENABLED |    \
                                        HEAP_FREE_CHECKING_ENABLED |    \
                                        HEAP_DISABLE_COALESCE_ON_FREE | \
                                        HEAP_CLASS_MASK |               \
                                        HEAP_CREATE_ALIGN_16 |          \
                                        HEAP_CREATE_ENABLE_TRACING)
                                        

#define PAGE_HEAP_ENABLE_PAGE_HEAP          0x0001
#define PAGE_HEAP_COLLECT_STACK_TRACES      0x0002
#define PAGE_HEAP_RESERVED_04               0x0004
#define PAGE_HEAP_RESERVED_08               0x0008
#define PAGE_HEAP_CATCH_BACKWARD_OVERRUNS   0x0010
#define PAGE_HEAP_UNALIGNED_ALLOCATIONS     0x0020
#define PAGE_HEAP_SMART_MEMORY_USAGE        0x0040
#define PAGE_HEAP_USE_SIZE_RANGE            0x0080
#define PAGE_HEAP_USE_DLL_RANGE             0x0100
#define PAGE_HEAP_USE_RANDOM_DECISION       0x0200
#define PAGE_HEAP_USE_DLL_NAMES             0x0400
#define PAGE_HEAP_USE_FAULT_INJECTION       0x0800

//
//  heap walking contexts.
//

#define CONTEXT_START_GLOBALS   11

#define CONTEXT_START_HEAP      1
#define CONTEXT_END_HEAP        2

#define CONTEXT_START_SEGMENT   3
#define CONTEXT_END_SEGMENT     4

#define CONTEXT_FREE_BLOCK      5
#define CONTEXT_BUSY_BLOCK      6
#define CONTEXT_LOOKASIDE_BLOCK 7
#define CONTEXT_VIRTUAL_BLOCK   8
#define CONTEXT_END_BLOCKS      9

#define CONTEXT_ERROR           10

#define CONTEXT_LFH_HEAP         11
#define CONTEXT_START_SUBSEGMENT 12
#define CONTEXT_END_SUBSEGMENT   13

#define SCANPROCESS 1
#define SCANHEAP    2
#define SCANSEGMENT 3

extern ULONG ScanLevel;


typedef BOOLEAN (*HEAP_ITERATOR_CALLBACK)(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    );

                               
void 
ScanProcessHeaps (
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb,
    HEAP_ITERATOR_CALLBACK HeapCallback
    );
                                        
void InspectLeaks (
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb
    );

void
DumpEntryHeader();

void
DumpEntryInfo(
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    ULONG64 EntryAddress
    );

void 
DumpEntryFlagDescription (
    ULONG Flags
    );

BOOLEAN
SearchVMReference (
    HANDLE hProcess,
    ULONG64 Base,
    ULONG64 EndAddress
    );


extern ULONG PageSize;
extern ULONG HeapEntrySize;
extern ULONG PointerSize;

BOOLEAN
InitializeHeapExtension();

VOID
HeapDetectLeaks();

VOID
HeapFindBlock (
    LPCTSTR szArguments
    );

VOID
HeapStat(
    LPCTSTR szArguments
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\heapfind.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    heapleak.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian Marinescu (adrmarin) 04/17/2000

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "heap.h"
#pragma hdrstop


ULONG64 AddressToFind;

ULONG64 HeapAddressFind;
ULONG64 SegmentAddressFind;
ULONG64 HeapEntryFind;
ULONG64 HeapEntryFindSize;
BOOLEAN Lookaside;

BOOLEAN VerifyBlocks;

ULONG64 DumpOptions = 0xffffff;

#define HEAP_DUMP_FREE_LISTS 1
#define HEAP_DUMP_GFLAGS     2
#define HEAP_DUMP_GTAGS      4
#define HEAP_DUMP_FREE_LISTS_DETAILS 8

BOOLEAN ScanVM;

ULONG
GetFieldSize (
    IN  LPCSTR  Type,
    IN  LPCSTR  Field
   )
{
   FIELD_INFO flds = {(PUCHAR)Field, NULL, 0, DBG_DUMP_FIELD_FULL_NAME, 0, NULL};
   
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), (PUCHAR)Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   
   ULONG RetVal;

   RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

   return flds.size;
}


ULONG
ReadLongValue(LPTSTR Symbol)
{
    ULONG64 Address;
    ULONG Value = 0;

    Address = GetExpression( Symbol );

    if ( (Address == 0) ||
         !ReadMemory( Address, &Value, sizeof( Value ), NULL )) {

        dprintf( "HEAPEXT: Unable to read %s\n", Symbol );
    }

    return Value;
}



#define CheckAndPrintFlag(x)\
    if (Flags & (x)) dprintf(#x" ");

void
DumpFlagDescription(ULONG Flags)
{
    CheckAndPrintFlag(HEAP_NO_SERIALIZE);
    CheckAndPrintFlag(HEAP_GROWABLE);
    CheckAndPrintFlag(HEAP_GENERATE_EXCEPTIONS);
    CheckAndPrintFlag(HEAP_ZERO_MEMORY);
    CheckAndPrintFlag(HEAP_REALLOC_IN_PLACE_ONLY);
    CheckAndPrintFlag(HEAP_TAIL_CHECKING_ENABLED);
    CheckAndPrintFlag(HEAP_FREE_CHECKING_ENABLED);
    CheckAndPrintFlag(HEAP_DISABLE_COALESCE_ON_FREE);
    CheckAndPrintFlag(HEAP_CREATE_ALIGN_16);
    CheckAndPrintFlag(HEAP_CREATE_ENABLE_TRACING);
}

void
DumpEntryFlagDescription(ULONG Flags)
{
    if (Flags & HEAP_ENTRY_BUSY) dprintf("busy "); else dprintf("free ");
    if (Flags & HEAP_ENTRY_EXTRA_PRESENT) dprintf("extra ");
    if (Flags & HEAP_ENTRY_FILL_PATTERN) dprintf("fill ");
    if (Flags & HEAP_ENTRY_VIRTUAL_ALLOC) dprintf("virtual ");
    if (Flags & HEAP_ENTRY_LAST_ENTRY) dprintf("last ");
    if (Flags & HEAP_ENTRY_SETTABLE_FLAGS) dprintf("user_flag ");
}

void
DumpEntryHeader()
{
    dprintf("Entry     User      Heap      Segment       Size  PrevSize  Flags\n");
    dprintf("----------------------------------------------------------------------\n");
}

void
DumpEntryInfo(
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    ULONG64 EntryAddress
    )
{
    ULONG SizeOfEntry;
    ULONG PreviousSize;
    ULONG Flags;
    ULONG Size;
    UCHAR SegmentIndex;
    UCHAR SmallTagIndex;

    SizeOfEntry = GetTypeSize("_HEAP_ENTRY"); // same as granularity
    InitTypeRead(EntryAddress, _HEAP_ENTRY);

    PreviousSize = (ULONG)ReadField(PreviousSize) * SizeOfEntry;
    Size = (ULONG) ReadField(Size) * SizeOfEntry;
    Flags = (ULONG) ReadField(Flags);
    SegmentIndex = (UCHAR) ReadField(SegmentIndex);
    SmallTagIndex = (UCHAR) ReadField(SmallTagIndex);

    if (SegmentIndex != 0xff) {

        dprintf("%p  %p  %p  %p  %8lx  %8lx  ",
                EntryAddress,
                EntryAddress + SizeOfEntry,
                HeapAddress,
                SegmentAddress,
                Size,
                PreviousSize
                );

        DumpEntryFlagDescription(Flags);

        if (Lookaside) {
            dprintf(" - lookaside ");
        }

    } else {

        ULONG64 SubSegment = ReadField(SubSegment);
        ULONG64 BlockSize;

        GetFieldValue(SubSegment, "ntdll!_HEAP_SUBSEGMENT", "BlockSize", BlockSize);

        Size = (ULONG)BlockSize * SizeOfEntry;

        dprintf("%p  %p  %p  %p  %8lx      -     ",
                EntryAddress,
                EntryAddress + SizeOfEntry,
                HeapAddress,
                SegmentAddress,
                Size
                );
        
        if (SmallTagIndex) {

            dprintf("LFH_BUSY; ");
        } else {
            dprintf("LFH_FREE; ");
        }
        DumpEntryFlagDescription(Flags);
    }

    dprintf("\n");
}

void
DumpHeapStructure (ULONG64 HeapAddress)
{
    ULONG AlignRound, Offset;

    if (InitTypeRead(HeapAddress, _HEAP)) {

        return;
    }

    GetFieldOffset("_HEAP", "VirtualAllocdBlocks", &Offset);
    AlignRound = (ULONG)ReadField(AlignRound) - GetTypeSize( "_HEAP_ENTRY" );

    if ((ULONG)ReadField(Flags) & HEAP_TAIL_CHECKING_ENABLED) {

        AlignRound -= CHECK_HEAP_TAIL_SIZE;
    }

    AlignRound += 1;

    dprintf( "    Flags:               %08x ", (ULONG)ReadField(Flags) );
    DumpFlagDescription((ULONG)ReadField(Flags)); dprintf("\n");

    dprintf( "    ForceFlags:          %08x ", (ULONG)ReadField(ForceFlags) );
    DumpFlagDescription((ULONG)ReadField(ForceFlags)); dprintf("\n");

    dprintf( "    Granularity:         %u bytes\n", AlignRound );
    dprintf( "    Segment Reserve:     %08x\n", (ULONG)ReadField(SegmentReserve));
    dprintf( "    Segment Commit:      %08x\n", (ULONG)ReadField(SegmentCommit) );
    dprintf( "    DeCommit Block Thres:%08x\n", (ULONG)ReadField(DeCommitFreeBlockThreshold) );
    dprintf( "    DeCommit Total Thres:%08x\n", (ULONG)ReadField(DeCommitTotalFreeThreshold) );
    dprintf( "    Total Free Size:     %08x\n", (ULONG)ReadField(TotalFreeSize) );
    dprintf( "    Max. Allocation Size:%08x\n", (ULONG)ReadField(MaximumAllocationSize) );
    dprintf( "    Lock Variable at:    %p\n", ReadField(LockVariable) );
    dprintf( "    Next TagIndex:       %04x\n", (ULONG)ReadField(NextAvailableTagIndex) );
    dprintf( "    Maximum TagIndex:    %04x\n", (ULONG)ReadField(MaximumTagIndex) );
    dprintf( "    Tag Entries:         %08x\n", (ULONG)ReadField(TagEntries) );
    dprintf( "    PsuedoTag Entries:   %08x\n", (ULONG)ReadField(PseudoTagEntries) );
    dprintf( "    Virtual Alloc List:  %p\n", HeapAddress + Offset);

    if (DumpOptions & (HEAP_DUMP_FREE_LISTS | HEAP_DUMP_FREE_LISTS_DETAILS)) {

        ULONG i, ListSize, FreeListOffset;

        dprintf( "    FreeList Usage:      %08x %08x %08x %08x\n",
                 (ULONG)ReadField(u.FreeListsInUseUlong[0]),
                 (ULONG)ReadField(u.FreeListsInUseUlong[1]),
                 (ULONG)ReadField(u.FreeListsInUseUlong[2]),
                 (ULONG)ReadField(u.FreeListsInUseUlong[3])
               );

        GetFieldOffset ("_HEAP", "FreeLists", &Offset);
        ListSize = GetTypeSize("LIST_ENTRY");
        GetFieldOffset ("_HEAP_FREE_ENTRY", "FreeList", &FreeListOffset);

        for (i=0; i<HEAP_MAXIMUM_FREELISTS; i++) {

            ULONG64 Flink, Blink, Next;
            ULONG64 FreeListHead;
            ULONG Count = 0;
            ULONG MinSize = 0, MaxSize = 0;

            FreeListHead = HeapAddress + Offset + ListSize * i;

            GetFieldValue(FreeListHead, "LIST_ENTRY", "Flink", Flink);
            GetFieldValue(FreeListHead, "LIST_ENTRY", "Blink", Blink);

            if (Flink != FreeListHead) {

                dprintf( "    FreeList[ %02x ] at %08p",
                         i,
                         FreeListHead
                         );

                if (DumpOptions & HEAP_DUMP_FREE_LISTS_DETAILS) {

                    dprintf("\n");
                }

                Next = Flink;
                while (Next != FreeListHead) {

                    ULONG Size, PrevSize, Flags;
                    ULONG64 FreeEntryAddress;

                    FreeEntryAddress = Next - FreeListOffset;

                    if (InitTypeRead ( FreeEntryAddress, _HEAP_FREE_ENTRY)) {

                        if (Count) {
                            dprintf( "     Total: %ld blocks (%08lx, %08lx)  * Error reading %p\n",
                                     Count,
                                     MinSize,
                                     MaxSize,
                                     FreeEntryAddress
                                   );
                        } else {
                            dprintf( "     No blocks in list. Error reading %p\n",
                                     FreeEntryAddress
                                   );
                        }

                        break;
                    }

                    Size = (ULONG)ReadField(Size) * AlignRound;
                    PrevSize = (ULONG)ReadField(PreviousSize) * AlignRound;
                    Flags = (ULONG)ReadField(Flags);

                    if (!Count) {

                        MinSize = MaxSize = Size;

                    } else {

                        if (Size < MinSize) MinSize = Size;
                        if (Size > MaxSize) MaxSize = Size;
                    }

                    if (DumpOptions & HEAP_DUMP_FREE_LISTS_DETAILS) {

                        dprintf( "        %08p: %05x . %05x [%02x] - ",
                                 FreeEntryAddress,
                                 PrevSize,
                                 Size,
                                 Flags
                               );

                        DumpEntryFlagDescription(Flags);

                        dprintf("\n");
                    }

                    Count += 1;

                    ReadPointer(Next, &Next);

                    if (CheckControlC()) {
                        return;
                    }
                }

                if (Count) {

                    if (DumpOptions & HEAP_DUMP_FREE_LISTS_DETAILS) {

                        dprintf("       ");
                    }

                    dprintf( " * Total %ld block(s) (%08lx, %08lx)\n",
                             Count,
                             MinSize,
                             MaxSize
                           );
                }
            }
        }
    }
}

void
DumpGlobals()
{
    ULONG64 pNtGlobalFlag, NtGlobalFlag = 0;
    ULONG64 pNtTempGlobal, NtTempGlobal = 0;

    NtGlobalFlag = ReadLongValue("NTDLL!NtGlobalFlag");

    if ((NtGlobalFlag & (FLG_HEAP_ENABLE_TAIL_CHECK |
                         FLG_HEAP_ENABLE_FREE_CHECK |
                         FLG_HEAP_VALIDATE_PARAMETERS |
                         FLG_HEAP_VALIDATE_ALL |
                         FLG_HEAP_ENABLE_TAGGING |
                         FLG_USER_STACK_TRACE_DB |
                         FLG_HEAP_DISABLE_COALESCING )) != 0 ) {

        dprintf( "NtGlobalFlag enables following debugging aids for new heaps:" );

        if (NtGlobalFlag & FLG_HEAP_ENABLE_TAIL_CHECK) {
            dprintf( "    tail checking\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_ENABLE_FREE_CHECK) {
            dprintf( "    free checking\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_VALIDATE_PARAMETERS) {
            dprintf( "    validate parameters\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_VALIDATE_ALL) {
            dprintf( "    validate on call\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_ENABLE_TAGGING) {
            dprintf( "    heap tagging\n" );
        }

        if (NtGlobalFlag & FLG_USER_STACK_TRACE_DB) {
            dprintf( "    stack back traces\n" );
        }

        if (NtGlobalFlag & FLG_HEAP_DISABLE_COALESCING) {
            dprintf( "    disable coalescing of free blocks\n" );
        }
    }
    
    NtTempGlobal = ReadLongValue( "NTDLL!RtlpDisableHeapLookaside" );
    
    if (NtTempGlobal) {

        dprintf( "The process has the following heap extended settings %08lx:\n", (ULONG)NtTempGlobal );

        if (NtTempGlobal & 1) {

            dprintf("   - Lookasides disabled\n");
        }

        if (NtTempGlobal & 2) {

            dprintf("   - Large blocks cache disabled\n");
        }

        if (NtTempGlobal & 8) {

            dprintf("   - Low Fragmentation Heap activated for all heaps\n");
        }

        dprintf("\n");
    }
    
    pNtTempGlobal = GetExpression( "NTDLL!RtlpAffinityState" );

    if ( pNtTempGlobal ) {

        ULONG64 TempValue;
        ULONG64 AffinitySwaps;
        ULONG64 AffinityResets;
        ULONG64 AffinityAllocs;
        
        GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "Limit", TempValue);

        if (TempValue) {

            dprintf("Affinity manager status:\n");
            dprintf("   - Virtual affinity limit %I64ld\n", TempValue);

            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "CrtLimit", TempValue);
            dprintf("   - Current entries in use %ld\n", (LONG)TempValue);

            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "AffinitySwaps", AffinitySwaps);
            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "AffinityResets", AffinityResets);
            GetFieldValue(pNtTempGlobal, "ntdll!_AFFINITY_STATE", "AffinityAllocs", AffinityAllocs);

            dprintf("   - Statistics:  Swaps=%I64ld, Resets=%I64ld, Allocs=%I64ld\n\n", 
                    AffinitySwaps,
                    AffinityResets,
                    AffinityAllocs
                    );
        }
    }
}

BOOLEAN HeapFindRoutine(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    )
{
    switch (Context) {

    case CONTEXT_START_HEAP:

        //
        //  we found a block, we won't need then to search in other heaps
        //

        if (HeapEntryFind) {
            ScanLevel = 0;
        }

        break;

    case CONTEXT_FREE_BLOCK:
    case CONTEXT_BUSY_BLOCK:
    case CONTEXT_LOOKASIDE_BLOCK:
    case CONTEXT_VIRTUAL_BLOCK:

        if ((AddressToFind >= EntryAddress) &&
            (AddressToFind < (EntryAddress + Data))) {

            if (HeapEntryFind == 0) {

                HeapAddressFind = HeapAddress;
                SegmentAddressFind = SegmentAddress;
            }

            if (Context == CONTEXT_LOOKASIDE_BLOCK) {

                Lookaside = TRUE;

                ScanLevel = 0;
            }

            HeapEntryFind = EntryAddress;
            HeapEntryFindSize = Data;
        }

        break;

    case CONTEXT_ERROR:

        dprintf("HEAP %p (Seg %p) At %p Error: %s\n",
               HeapAddress,
               SegmentAddress,
               EntryAddress,
               Data
               );

        break;
    }
    return TRUE;
}

BOOLEAN
SearchVMReference (
    HANDLE hProcess,
    ULONG64 Base,
    ULONG64 EndAddress
    )
{
    NTSTATUS Status;
    SIZE_T BufferLen;
    ULONG_PTR lpAddress = 0;
    MEMORY_BASIC_INFORMATION Buffer;
    PVOID MemoryBuffer;

    if ( hProcess ) {

        MemoryBuffer = malloc(PageSize);

        if (!MemoryBuffer) {

           dprintf("Not enough memory. Abording.\n");

           return FALSE;
        }

        dprintf("Search VM for address range %p - %p : ",Base, EndAddress);

        BufferLen = sizeof(Buffer);

        while (BufferLen) {

            BufferLen = VirtualQueryEx( hProcess,
                                        (LPVOID)lpAddress,
                                        &Buffer,
                                        sizeof(Buffer)
                                      );

            if (BufferLen) {

                if ((Buffer.AllocationProtect & (PAGE_READWRITE | PAGE_EXECUTE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY)) /*&&
                    (Buffer.Type == MEM_PRIVATE)*/) {

                    ULONG64 NumPages;
                    ULONG i, j;

                    NumPages = Buffer.RegionSize / PageSize;

                    for (i = 0; i < NumPages; i++) {

                        if (ReadMemory( (ULONG64)(lpAddress + i * PageSize),
                                         MemoryBuffer,
                                         PageSize,
                                         NULL
                                         )) {

                            ULONG_PTR * Pointers = (ULONG_PTR *)MemoryBuffer;

                            for (j = 0; j < PageSize/sizeof(ULONG_PTR); j++) {

                                ULONG_PTR Address = lpAddress + i * PageSize + j * sizeof(ULONG_PTR);

                                if ((*Pointers >= Base) &&
                                    (*Pointers <= EndAddress)) {

                                    dprintf("%08lx (%08lx), ",
                                           Address,
                                           *Pointers
                                           );
                                }

                                Pointers += 1;
                            }
                        }
                    }
                }

                lpAddress += Buffer.RegionSize;
            }
        }

        dprintf("\n");
        free(MemoryBuffer);
    }

    return TRUE;
}

VOID
HeapStat(LPCTSTR szArguments);

VOID
HeapFindBlock(LPCTSTR szArguments)
{
    ULONG64 Process;
    ULONG64 ThePeb;
    HANDLE hProcess;


    if (!InitializeHeapExtension()) {

        return;
    }
    
    HeapEntryFind = 0;
    HeapEntryFindSize = 0;
    HeapAddressFind = 0;
    SegmentAddressFind = 0;
    Lookaside = FALSE;
    AddressToFind = 0;

    GetPebAddress( 0, &ThePeb);
    GetCurrentProcessHandle( &hProcess );

    ScanVM = FALSE;

    {
        LPSTR p = (LPSTR)szArguments;

        while (p && *p) {

            if (*p == '-') {

                p++;

                if (toupper(*p) == 'V') {

                    ScanVM = TRUE;
                }

            } else if (isxdigit(*p)) {

                sscanf( p, "%I64lx", &AddressToFind );

                while ((*p) && isxdigit(*p)) {

                    p++;
                }

                continue;
            }

            p++;
        }
    }

    if (AddressToFind == 0) {

        dprintf("Syntax:\n!heap -x [-v] address\n");
        return;
    }

    ScanProcessHeaps( 0,
                      ThePeb,
                      HeapFindRoutine
                      );

    if (HeapEntryFind) {

        DumpEntryHeader();

        DumpEntryInfo(HeapAddressFind, SegmentAddressFind, HeapEntryFind);

        dprintf("\n");

        if (ScanVM) {

            SearchVMReference(hProcess, HeapEntryFind, HeapEntryFind + HeapEntryFindSize - 1);
        }
    } else {

        if (ScanVM) {
            SearchVMReference(hProcess, AddressToFind, AddressToFind);
        }
    }
}

//
//  Heap stat implementation
//

typedef struct _SIZE_INFO {
    ULONG Busy;
    ULONG Free;
    ULONG FrontHeapAllocs;
    ULONG FrontHeapFrees;
}SIZE_INFO, *PSIZE_INFO;

typedef struct _HEAP_STATS {

    ULONG   HeapIndex;
    ULONG64 HeapAddress;
    ULONG64 ReservedMemory;
    ULONG64 CommitedMemory;
    ULONG64 VirtualBytes;
    ULONG64 FreeSpace;
    ULONG   Flags;
    ULONG   FreeListLength;
    ULONG   VirtualBlocks;
    ULONG   UncommitedRanges;
    ULONG64 LockContention;
    ULONG   FrontEndHeapType;
    ULONG64 FrontEndHeap;

    BOOLEAN ScanningSubSegment;

}HEAP_STATS, *PHEAP_STATS;

HEAP_STATS CrtHeapStat;
PSIZE_INFO SizeInfo = NULL;
ULONG BucketSize;
ULONG LargestBucketIndex = 0;
ULONG64 StatHeapAddress;
ULONG DumpBlocksSize = 0;

ULONG
FASTCALL
HeapStatSizeToSizeIndex(ULONG64 Size)
{
    ULONG Index = (ULONG)(Size / BucketSize);

    if (Index >= LargestBucketIndex) {

        Index = LargestBucketIndex - 1;
    }

    return Index;
}


VOID
HeapStatDumpBlocks()
{
    ULONG Index;
    ULONG64 Busy = 0, Free = 0, FEBusy = 0, FEFree = 0;


    dprintf("\n                    Default heap   Front heap  \n");
    dprintf("   Range (bytes)     Busy  Free    Busy   Free \n");
    dprintf("----------------------------------------------- \n");
    if (SizeInfo == NULL) {

        return;
    }

    for ( Index = 0; Index < LargestBucketIndex; Index++ ) {

        if (SizeInfo[Index].Busy
            ||
            SizeInfo[Index].Free
            ||
            SizeInfo[Index].FrontHeapAllocs
            ||
            SizeInfo[Index].FrontHeapFrees) {
            
            dprintf("%6ld - %6ld   %6ld %6ld %6ld %6ld\n",
                    Index * BucketSize,
                    (Index + 1) * BucketSize,
                    SizeInfo[Index].Busy,
                    SizeInfo[Index].Free,
                    SizeInfo[Index].FrontHeapAllocs,
                    SizeInfo[Index].FrontHeapFrees
                    );

            FEBusy += SizeInfo[Index].FrontHeapAllocs;
            FEFree += SizeInfo[Index].FrontHeapFrees;
            Busy += SizeInfo[Index].Busy;
            Free += SizeInfo[Index].Free;
        }
    }
    
    dprintf("----------------------------------------------- \n");
    dprintf("  Total           %6I64d %6I64d %6I64d %6I64d \n",
            Busy, 
            Free, 
            FEBusy, 
            FEFree
            );
}

VOID 
DumpBlock (
    IN ULONG64 BlockAddress,
    IN UCHAR   Flag
    )
{
    UCHAR Buffer[33];
    PULONG pLongArray = (PULONG)Buffer;
    ULONG i;

    memchr(Buffer, '?', sizeof( Buffer ));

    if (!ReadMemory( BlockAddress, &Buffer, sizeof( Buffer ), NULL )) {

        dprintf("%p  ?\n", BlockAddress);

        return;
    }

    dprintf("%p %c %08lx %08lx %08lx %08lx ", 
            BlockAddress,
            Flag,
            pLongArray[0],
            pLongArray[1],
            pLongArray[2],
            pLongArray[3]
            );

    for (i = 0; i < 32; i++) {

        if (!isprint(Buffer[i])) {

            Buffer[i] = '.';
        }
    }

    Buffer[32] = 0;

    dprintf("%s\n", Buffer);
}

VOID
CollectHeapInfo(
    ULONG64 HeapAddress
    )
{
    ULONG64 TempValue;
    ULONG64 FrontEndHeapType;

    memset(&CrtHeapStat, 0, sizeof(CrtHeapStat));

    CrtHeapStat.HeapAddress = HeapAddress;

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "TotalFreeSize", CrtHeapStat.FreeSpace);
    CrtHeapStat.FreeSpace *= HeapEntrySize;

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "NonDedicatedListLength", CrtHeapStat.FreeListLength);
    
    GetFieldValue(HeapAddress, "ntdll!_HEAP", "Flags", TempValue);
    CrtHeapStat.Flags = (ULONG)TempValue;
    
    GetFieldValue(HeapAddress, "ntdll!_HEAP", "Signature", TempValue);
    
    if (TempValue != 0xeeffeeff) {
        dprintf("Error: Heap %p has an invalid signature %08lx\n", HeapAddress, 0xeeffeeff);
    }

    if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "LockVariable", TempValue) == 0) {

        if (TempValue != 0) {

            GetFieldValue(TempValue, "ntdll!_RTL_CRITICAL_SECTION", "DebugInfo", TempValue);
            GetFieldValue(TempValue, "ntdll!_RTL_CRITICAL_SECTION_DEBUG", "ContentionCount", CrtHeapStat.LockContention);

        } else {

            CrtHeapStat.LockContention = 0xbad;
        }
    }

    CrtHeapStat.FrontEndHeapType = 0;

    if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "Lookaside", TempValue)) {


        if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeapType", FrontEndHeapType)) {

            dprintf("Front-end heap type info is not available\n");

        } else {

            CrtHeapStat.FrontEndHeapType = (ULONG)FrontEndHeapType;
            
            GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeap", CrtHeapStat.FrontEndHeap);
        }

    } else {

        if (TempValue) {

            CrtHeapStat.FrontEndHeapType = 1;
        }

        CrtHeapStat.FrontEndHeap = TempValue;
    }
}

typedef struct _BUCKET_INFO {

    ULONG  TotalBlocks;
    ULONG  SubSegmentCounts;
    ULONG BlockUnits;
    ULONG UseAffinity;
    LONG Conversions;

} BUCKET_INFO, *PBUCKET_INFO;

VOID
DumpLowfHeap(
    ULONG64 HeapAddress
    )
{
    ULONG64 TempValue, CrtAddress;
    ULONG64 Head;
    ULONG TempOffset, i;
    ULONG64 Next;
    ULONG Counter, TempSize;
    ULONG Values[20];
    PBUCKET_INFO BucketInfo;
    ULONG CacheSize = GetFieldSize("ntdll!_USER_MEMORY_CACHE", "AvailableBlocks") / sizeof(ULONG);

    if (CacheSize > 20) {

        CacheSize = 20;
    }

    InitTypeRead(HeapAddress, _LFH_HEAP);

    if (GetFieldValue(HeapAddress, "ntdll!_LFH_HEAP", "Lock.DebugInfo", TempValue) == 0) {

        if (TempValue != 0) {

            ULONG64 Contention;

            GetFieldValue(TempValue, "ntdll!_RTL_CRITICAL_SECTION_DEBUG", "ContentionCount", Contention);

            dprintf("       Lock contention  %7ld\n", (ULONG) Contention);
        }
    }

    GetFieldValue(HeapAddress, "ntdll!_LFH_HEAP", "SubSegmentZones.Flink", Head);

    Counter = 0;

    ReadPtr(Head, &Next);

    while (Next != Head) {

        Counter += 1;

        if (ReadPtr(Next, &Next)) {

            dprintf("ERROR Cannot read SubSegmentZones list at %p\n", Next);

            break;
        }
    }
    
    dprintf("       Metadata usage   %7ld\n", Counter * 1024);
    
    dprintf("       Statistics:\n");
    dprintf("           Segments created    %7ld\n", ReadField(SegmentCreate));
    dprintf("           Segments deleted    %7ld\n", ReadField(SegmentDelete));
    dprintf("           Segments reused     %7ld\n", ReadField(SegmentInsertInFree));
    dprintf("           Conversions         %7ld\n", ReadField(Conversions));
    dprintf("           ConvertedSpace      %7ld\n\n", ReadField(ConvertedSpace));

    GetFieldOffset("ntdll!_LFH_HEAP", "UserBlockCache", &TempOffset);

    CrtAddress = TempValue = HeapAddress + TempOffset;

    InitTypeRead(TempValue, _USER_MEMORY_CACHE);
    dprintf("       Block cache:\n");
    dprintf("            Free blocks        %7ld\n", ReadField(FreeBlocks));
    dprintf("            Sequence           %7ld\n", ReadField(Sequence));
    dprintf("            Cache blocks");

    for (i = 0; i < CacheSize; i++) {

        ULONG64 Depth;

        GetFieldValue(TempValue, "ntdll!_SLIST_HEADER", "Depth", Depth);

        dprintf(" %6ld", (ULONG)Depth);
        TempValue += GetTypeSize("_SLIST_HEADER");
    }
    
    GetFieldOffset("ntdll!_USER_MEMORY_CACHE", "AvailableBlocks", &TempOffset);
    dprintf("\n            Available   ");
    

    TempValue = CrtAddress + TempOffset;

    if (ReadMemory( TempValue, &Values, CacheSize * sizeof(ULONG), NULL )) {
        
        for (i = 0; i < CacheSize; i++) {

            dprintf(" %6ld", Values[i]);
        }
    }

    dprintf("\n");
    
    GetFieldOffset("ntdll!_LFH_HEAP", "Buckets", &TempOffset);

    CrtAddress = HeapAddress + TempOffset;
    TempSize = GetTypeSize("_HEAP_BUCKET");

    BucketInfo = (PBUCKET_INFO)malloc(128 * sizeof(BUCKET_INFO));

    if (BucketInfo) {
        
        dprintf("       Buckets info:\n");
        dprintf("  Size   Blocks  Seg Aff Conv\n");
        dprintf("-----------------------------\n");

        for (i = 0; i < 128; i++) {

            InitTypeRead(CrtAddress + (i * TempSize), _HEAP_BUCKET);

            BucketInfo[i].TotalBlocks = (ULONG)ReadField(Counters.TotalBlocks);
            BucketInfo[i].BlockUnits = (ULONG)ReadField(BlockUnits);
            BucketInfo[i].Conversions = (ULONG)ReadField(Conversions);
            BucketInfo[i].SubSegmentCounts = (ULONG)ReadField(Counters.SubSegmentCounts);
            BucketInfo[i].UseAffinity = (ULONG)ReadField(UseAffinity);

            if (BucketInfo[i].TotalBlocks) {

                dprintf("%6ld %7ld %5ld  %ld %4ld\n",
                       BucketInfo[i].BlockUnits*HeapEntrySize,
                       BucketInfo[i].TotalBlocks,
                       BucketInfo[i].SubSegmentCounts,
                       BucketInfo[i].UseAffinity,
                       BucketInfo[i].Conversions
                       );
            }
        }
        dprintf("-----------------------------\n");

        free(BucketInfo);
    }
}

VOID
DumpHeapInfo(
    ULONG64 HeapAddress
    )
{
    ULONG64 TempValue;

    dprintf("\n%2ld: Heap %p\n", 
            CrtHeapStat.HeapIndex,
            CrtHeapStat.HeapAddress);

    dprintf("   Flags          %08lx - ", CrtHeapStat.Flags);
    DumpFlagDescription(CrtHeapStat.Flags);
    dprintf("\n");

    dprintf("   Reserved       %I64d (k)\n", CrtHeapStat.ReservedMemory/1024);
    dprintf("   Commited       %I64d (k)\n", CrtHeapStat.CommitedMemory/1024);
    dprintf("   Virtual bytes  %I64d (k)\n", CrtHeapStat.VirtualBytes/1024);
    dprintf("   Free space     %I64d (k)\n", CrtHeapStat.FreeSpace/1024);

    
    if (CrtHeapStat.CommitedMemory) {
        dprintf("   External fragmentation          %ld%% (%ld free blocks)\n", 
                (ULONG)(CrtHeapStat.FreeSpace *100 / CrtHeapStat.CommitedMemory),
                CrtHeapStat.FreeListLength
                );

    }

    if (CrtHeapStat.VirtualBytes) {
        dprintf("   Virtual address fragmentation   %ld%% (%ld uncommited ranges)\n", 
                (ULONG)((CrtHeapStat.VirtualBytes - CrtHeapStat.CommitedMemory) *100 / CrtHeapStat.VirtualBytes),
                CrtHeapStat.UncommitedRanges
                );
    }


    dprintf("   Virtual blocks  %ld\n", CrtHeapStat.VirtualBlocks);
    dprintf("   Lock contention %ld\n", CrtHeapStat.LockContention);

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "LastSegmentIndex", TempValue);
    dprintf("   Segments        %ld\n", (ULONG)TempValue + 1);

    GetFieldValue(HeapAddress, "ntdll!_HEAP", "LargeBlocksIndex", TempValue);

    if (TempValue) {

        ULONG PerfOffset;

        InitTypeRead(TempValue, _HEAP_INDEX);

        dprintf("   %ld hash table for the free list\n", (ULONG) ReadField(ArraySize));
        dprintf("       Commits %ld\n", (ULONG) ReadField(Committs));
        dprintf("       Decommitts %ld\n", (ULONG) ReadField(Decommitts));
    }

    switch (CrtHeapStat.FrontEndHeapType) {
    case 1:

        dprintf("\n   Lookaside heap   %p\n", CrtHeapStat.FrontEndHeap);
        break;
    case 2:

        dprintf("\n   Low fragmentation heap   %p\n", CrtHeapStat.FrontEndHeap);

        DumpLowfHeap(CrtHeapStat.FrontEndHeap);
        break;
    }
}

BOOLEAN
HeapStatRoutine(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    )
{
    ULONG SizeIndex;

    switch (Context) {

    case CONTEXT_START_HEAP:
        {
            if (DumpBlocksSize == 0) {
                dprintf("Walking the heap %p ", HeapAddress);
            }

            CollectHeapInfo(HeapAddress);

            //
            //  Allow scanning the heap
            //

            return TRUE;
        }
        break;
    
    case CONTEXT_END_HEAP:

        if (DumpBlocksSize == 0) {
            dprintf("\r");
        }
        if (SizeInfo == NULL) {
            
            dprintf("%p %08lx %7I64d %6I64d %6I64d %6I64d %5ld %5ld %4ld %6lx   ",
                    CrtHeapStat.HeapAddress,     
                    CrtHeapStat.Flags,           
                    (CrtHeapStat.ReservedMemory / 1024),  
                    (CrtHeapStat.CommitedMemory / 1024),  
                    (CrtHeapStat.VirtualBytes / 1024),    
                    (CrtHeapStat.FreeSpace / 1024),       
                    CrtHeapStat.FreeListLength,  
                    CrtHeapStat.UncommitedRanges,
                    CrtHeapStat.VirtualBlocks,   
                    CrtHeapStat.LockContention
                    );
            
            switch (CrtHeapStat.FrontEndHeapType) {
            case 1:
                dprintf("L  ");
                break;
            case 2:
                dprintf("LFH");
                break;
            default:
                dprintf("   ");
            }

            dprintf("\n");

            //
            //  Report external fragmentation is the heap uses more than 1M
            //  The threshold to report is 10%
            //
            
            if ((CrtHeapStat.CommitedMemory > 1024*1024)
                    &&
                CrtHeapStat.FreeSpace *100 / CrtHeapStat.CommitedMemory > 10) {

                dprintf("    External fragmentation  %ld %% (%ld free blocks)\n", 
                        (ULONG)(CrtHeapStat.FreeSpace *100 / CrtHeapStat.CommitedMemory),
                        CrtHeapStat.FreeListLength
                        );
            }

            //
            //  Report virtual address fragmentation is the heap has more than 100 UCR
            //  The threshold to report is 10%
            //

            if (CrtHeapStat.UncommitedRanges > 100
                    &&
                (CrtHeapStat.VirtualBytes - CrtHeapStat.CommitedMemory) *100 / CrtHeapStat.VirtualBytes > 10) {

                dprintf("    Virtual address fragmentation  %ld %% (%ld uncommited ranges)\n", 
                        (ULONG)((CrtHeapStat.VirtualBytes - CrtHeapStat.CommitedMemory) *100 / CrtHeapStat.VirtualBytes),
                        CrtHeapStat.UncommitedRanges
                        );
            }

            //
            //  Make noise about lock contention. The value is 1M, and it's arbitrary.
            //  Over a long run this value can be legitimate
            //

            if (CrtHeapStat.LockContention > 1024*1024) {

                dprintf("    Lock contention  %ld \n", 
                        CrtHeapStat.LockContention);
            }
        } else {
            
            DumpHeapInfo(StatHeapAddress);
            HeapStatDumpBlocks();
        }
        break;

    case CONTEXT_START_SEGMENT:

        {
            ULONG64 NumberOfPages, NumberOfUnCommittedPages, LargestUnCommittedRange, NumberOfUnCommittedRanges;
            
            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfPages", NumberOfPages);
            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfUnCommittedPages", NumberOfUnCommittedPages);
            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "LargestUnCommittedRange", LargestUnCommittedRange);
            GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfUnCommittedRanges", NumberOfUnCommittedRanges);

            CrtHeapStat.ReservedMemory += NumberOfPages * PageSize;
            CrtHeapStat.CommitedMemory += (NumberOfPages - NumberOfUnCommittedPages) * PageSize;
            CrtHeapStat.UncommitedRanges += (ULONG)NumberOfUnCommittedRanges;
            CrtHeapStat.VirtualBytes += NumberOfPages * PageSize - LargestUnCommittedRange;

        }

        if ((SizeInfo != NULL)
                &&
            (DumpBlocksSize == 0)
            ) {

            dprintf(".");
        }

        if (VerifyBlocks) {

            dprintf(".");
            return TRUE;
        }

        //
        //  Do not walk the blocks. We need to return FALSE
        //

        return (SizeInfo != NULL);

    case CONTEXT_START_SUBSEGMENT:

        CrtHeapStat.ScanningSubSegment = TRUE;
        break;
    
    case CONTEXT_END_SUBSEGMENT:
        CrtHeapStat.ScanningSubSegment = FALSE;
        break;

    case CONTEXT_FREE_BLOCK:
        if (SizeInfo) {

            if (CrtHeapStat.ScanningSubSegment) {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].FrontHeapFrees += 1;
            
            } else {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].Free += 1;
            }
        }

        if (Data == DumpBlocksSize) {

            DumpBlock(EntryAddress + HeapEntrySize, 'F');
        }
        break;
    case CONTEXT_BUSY_BLOCK:

        if (SizeInfo) {

            if (CrtHeapStat.ScanningSubSegment) {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].FrontHeapAllocs += 1;
            
            } else {

                SizeInfo[HeapStatSizeToSizeIndex(Data)].Busy += 1;
            }
        }
        if (Data == DumpBlocksSize) {
            DumpBlock(EntryAddress + HeapEntrySize, 'B');
        }
        break;

    case CONTEXT_LOOKASIDE_BLOCK:

        if (SizeInfo) {
            
            SizeInfo[HeapStatSizeToSizeIndex(Data)].FrontHeapFrees += 1;
            SizeInfo[HeapStatSizeToSizeIndex(Data)].Busy -= 1;
        }
        if (Data == DumpBlocksSize) {

            DumpBlock(EntryAddress + HeapEntrySize, 'f');
        }
        break;
    case CONTEXT_VIRTUAL_BLOCK:

        if (SizeInfo) {

            SizeInfo[HeapStatSizeToSizeIndex(Data)].Busy += 1;
        }
        CrtHeapStat.VirtualBlocks += 1;
        break;

    case CONTEXT_ERROR:

        dprintf("HEAP %p (Seg %p) At %p Error: %s\n",
               HeapAddress,
               SegmentAddress,
               EntryAddress,
               Data
               );

        break;
    }
    return TRUE;
}


VOID
HeapStat(LPCTSTR szArguments)
{
    ULONG64 Process;
    ULONG64 ThePeb;
    HANDLE hProcess;

    int LastCommand = ' ';


    if (!InitializeHeapExtension()) {

        return;
    }

    HeapEntryFind = 0;
    HeapEntryFindSize = 0;
    HeapAddressFind = 0;
    SegmentAddressFind = 0;
    Lookaside = FALSE;
    StatHeapAddress = 0;
    BucketSize = 1024;
    DumpBlocksSize = 0;
    VerifyBlocks = FALSE;

    GetPebAddress( 0, &ThePeb);
    GetCurrentProcessHandle( &hProcess );

    ScanVM = FALSE;

    {
        LPSTR p = (LPSTR)szArguments;

        while (p && *p) {

            if (*p == '-') {

                p++;

                LastCommand = toupper(*p);

                if (LastCommand == 'V') {

                    VerifyBlocks = TRUE;
                }

            } else if (isxdigit(*p)) {

                ULONG64 HexInput;

                sscanf( p, "%I64lx", &HexInput );

                while ((*p) && isxdigit(*p)) {

                    p++;
                }

                switch (LastCommand) {
                case 'B':

                    BucketSize = (ULONG)HexInput;

                    break;
                case 'D':

                    DumpBlocksSize = (ULONG)HexInput;

                    break;
                default:

                    if (StatHeapAddress != 0) {

                        dprintf("Parameter error: unexpected second heap address %I64d\n", HexInput);

                    } else {
                        StatHeapAddress = HexInput;
                    }
                }

                continue;
            }

            p++;
        }
    }

    if (StatHeapAddress == 0) {

        DumpGlobals();

        if (PointerSize == 8) {
            dprintf("        ");
        }
        dprintf("  Heap     Flags   Reserv  Commit  Virt   Free  List   UCR  Virt  Lock  Fast \n");
        
        if (PointerSize == 8) {
            dprintf("        ");
        }

        dprintf("                    (k)     (k)    (k)     (k) length      blocks cont. heap \n");
        
        if (PointerSize == 8) {
            dprintf("--------");
        }
        dprintf("-----------------------------------------------------------------------------\n");

        ScanProcessHeaps( 0,
                          ThePeb,
                          HeapStatRoutine
                          );

        
        if (PointerSize == 8) {
            dprintf("--------");
        }
        dprintf("-----------------------------------------------------------------------------\n");

    } else {

        //
        //  Do not handle blocks over 512k, which is close to virtual alloc limit
        //

        LargestBucketIndex = (512*1024)/BucketSize;

        SizeInfo = malloc(LargestBucketIndex * sizeof(SIZE_INFO));

        if (SizeInfo == NULL) {

            dprintf("cannot allocate thye statistics buffer\n");
            return;
        }

        memset(SizeInfo, 0, LargestBucketIndex * sizeof(SIZE_INFO));

        ScanProcessHeaps( StatHeapAddress,
                          ThePeb,
                          HeapStatRoutine
                          );

        free(SizeInfo);
        SizeInfo = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\exts.cpp ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    exts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS2       g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

#define SKIP_WSPACE(s)  while (*s && (*s == ' ' || *s == '\t')) {++s;}

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the page size and PAE enable flag
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugDataSpaces),
                                       (void **)&DebugDataSpaces)) == S_OK)
            {
                if ((Hr = DebugDataSpaces->ReadDebuggerData(
                    DEBUG_DATA_MmPageSize, &Page,
                    sizeof(Page), NULL)) == S_OK)
                {
                    PageSize = (ULONG)(ULONG_PTR)Page;
                }

                DebugDataSpaces->Release();
            }
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        PageSize = 0;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
CxrHelp()
{
    dprintf("\n");
    dprintf("    !cxr has been replaced with the new built-in debugger command .cxr\n");
    dprintf("    !exr, !trap and !tss (both Kernelmode only) too are built-in . commands now\n");
    dprintf("    There is also a new \".thread\" command.\n");
    dprintf("\n");
    dprintf("    These new commands no longer require symbols to work correctly.\n");
    dprintf("\n");
    dprintf("    Another change that comes with these new commands is that they actually\n");
    dprintf("  change the internal state of the debugger engine \"permanently\" (until\n");
    dprintf("  reverted).  Any other debugger or extension command issued after the \n");
    dprintf("  \".cxr\", \".trap\" or \".thread\" command will be executed with the new context.\n");
    dprintf("\n");
    dprintf("  For example, commands such as stack walk (\"k\", \"kb\", \"kv\" ), \"r\" and \"dv\"\n");
    dprintf("  (show local variables) will all work based off the new context that was\n");
    dprintf("  supplied by \".cxr\", \".trap\" or \".thread\".\n");
    dprintf("\n");
    dprintf("  \".cxr\", \".trap\" and \".thread\" also apply to WinDBG:\n");
    dprintf("  using \".cxr\" , \".trap\"  and \".thread\" will automatically show you the\n");
    dprintf("  new stack in the WinDBG stack window and allow you to click on a frame and\n");
    dprintf("  see local variables and source code (if source is available).\n");
    dprintf("\n");
    dprintf("  \".cxr\", \".trap\" or \".thread\" with no parameters will give you back the\n");
    dprintf("  default context that was in effect before the command was executed.\n");
    dprintf("\n");
    dprintf("  For example, to exactly duplicate \n");
    dprintf("\n");
    dprintf("        !cxr <foo>        !trap <foo>\n");
    dprintf("        !kb               !kb\n");
    dprintf("\n");
    dprintf("  you would now use\n");
    dprintf("\n");
    dprintf("        .cxr <foo>        .trap <foo>\n");
    dprintf("        kb                kb\n");
    dprintf("        .cxr              .trap\n");
    dprintf("\n");
}

DECLARE_API ( cxr )
{
    CxrHelp();
    return S_OK;
}

DECLARE_API ( exr )
{
    CHAR  Cmd[400];

    dprintf("*** !exr obsolete: Use '.exr %s'\n", args);

    sprintf(Cmd, ".exr %s", args);
    if (Client &&
        (ExtQuery(Client) == S_OK)) {
        g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                              DEBUG_OUTCTL_OVERRIDE_MASK |
                              DEBUG_OUTCTL_NOT_LOGGED,
                              Cmd, DEBUG_EXECUTE_DEFAULT );

        ExtRelease();
        return S_OK;
    }
    return E_FAIL;

}


HRESULT
PrintString(
    BOOL Unicode,
    PDEBUG_CLIENT Client,
    LPCSTR args
    )
{
    ULONG64 AddrString;
    ULONG64 Displacement;
    STRING32 String;
    UNICODE_STRING UnicodeString;
    ULONG64 AddrBuffer;
    CHAR Symbol[1024];
    LPSTR StringData;
    HRESULT hResult;
    BOOL b;


    AddrString = GetExpression(args);
    if (!AddrString)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol(AddrString, Symbol, &Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory(AddrString, &String, sizeof(String), NULL);

    if ( !b )
    {
        return E_FAIL;
    }

    INIT_API();

    if (IsPtr64())
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING64, Buffer),
                             &AddrBuffer);
    }
    else
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING32, Buffer),
                             &AddrBuffer);
    }

    EXIT_API();

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    StringData = (LPSTR) LocalAlloc(LMEM_ZEROINIT,
                                    String.Length + sizeof(UNICODE_NULL));

    if (!StringData)
    {
        return E_FAIL;
    }

    dprintf("String(%d,%d)", String.Length, String.MaximumLength);
    if (Symbol[0])
    {
        dprintf(" %s+%p", Symbol, Displacement);
    }

    b = ReadMemory(AddrBuffer, StringData, String.Length, NULL);

    if ( b )
    {
        if (Unicode)
        {
            ANSI_STRING AnsiString;

            UnicodeString.Buffer = (PWSTR)StringData;
            UnicodeString.Length = String.Length;
            UnicodeString.MaximumLength = String.Length+sizeof(UNICODE_NULL);

            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString,TRUE);

            dprintf(" at %p: %s\n", AddrString, AnsiString.Buffer);

            RtlFreeAnsiString(&AnsiString);
        }
        else
        {
            dprintf(" at %p: %s\n", AddrString, StringData);
        }

        LocalFree(StringData);
        return S_OK;
    }
    else
    {
        LocalFree(StringData);
        return E_FAIL;
    }
}

DECLARE_API( str )

/*++

Routine Description:

    This function is called to format and dump counted (ansi) string.

Arguments:

    args - Address

Return Value:

    None.

--*/
{
    return PrintString(FALSE, Client, args);
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called to format and dump counted (unicode) string.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    return PrintString(TRUE, Client, args);
}

DECLARE_API( obja )

/*++

Routine Description:

    This function is called to format and dump an object attributes structure.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    ULONG64 AddrObja;
    ULONG64 Displacement;
    ULONG64 AddrString;
    STRING32 String;
    ULONG64 StrAddr = NULL;
    CHAR Symbol[1024];
    LPSTR StringData;
    BOOL b;
    ULONG Attr;
    HRESULT hResult;
    ULONG ObjectNameOffset;
    ULONG AttrOffset;
    ULONG StringOffset;

    if (IsPtr64())
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, Attributes);
        StringOffset = FIELD_OFFSET(STRING64, Buffer);
    }
    else
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, Attributes);
        StringOffset = FIELD_OFFSET(STRING32, Buffer);
    }


    AddrObja = GetExpression(args);
    if (!AddrObja)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the Obja
    //

    GetSymbol(AddrObja, Symbol, &Displacement);

    dprintf("Obja %s+%p at %p:\n", Symbol, Displacement, AddrObja);


    INIT_API();

    hResult = g_ExtData->ReadPointersVirtual(1,
                         AddrObja + ObjectNameOffset,
                         &AddrString);

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    if (AddrString)
    {
        b = ReadMemory(AddrString, &String, sizeof(String), NULL);

        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + StringOffset,
                             &StrAddr);
    }

    EXIT_API();


    if (StrAddr)
    {
        StringData = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                       String.Length+sizeof(UNICODE_NULL));

        if (StringData)
        {

            b = ReadMemory(StrAddr, StringData, String.Length, NULL);

            if (b)
            {
                dprintf("\tName is %ws\n", StringData);
            }

            LocalFree(StringData);
        }

    }

    b = ReadMemory(AddrObja + AttrOffset, &Attr, sizeof(Attr), NULL);

    if (!b)
    {
        return E_FAIL;
    }

    if (Attr & OBJ_INHERIT )
    {
        dprintf("\tOBJ_INHERIT\n");
    }
    if (Attr & OBJ_PERMANENT )
    {
        dprintf("\tOBJ_PERMANENT\n");
    }
    if (Attr & OBJ_EXCLUSIVE )
    {
        dprintf("\tOBJ_EXCLUSIVE\n");
    }
    if (Attr & OBJ_CASE_INSENSITIVE )
    {
        dprintf("\tOBJ_CASE_INSENSITIVE\n");
    }
    if (Attr & OBJ_OPENIF )
    {
        dprintf("\tOBJ_OPENIF\n");
    }


    return S_OK;
}

typedef struct _LIST_TYPE_PARAMS {
    PCHAR Command;
    PCHAR CommandArgs;
    ULONG FieldOffset;
    ULONG nElement;
} LIST_TYPE_PARAMS, *PLIST_TYPE_PARAMS;

ULONG
ListCallback(
    PFIELD_INFO Field,
    PVOID Context
    )
{
    CHAR  Execute[MAX_PATH];
    PCHAR Buffer;
    PLIST_TYPE_PARAMS pListParams = (PLIST_TYPE_PARAMS) Context;


    // Execute command
    sprintf(Execute, 
            "%s %I64lx %s", 
            pListParams->Command, 
            Field->address,// - pListParams->FieldOffset, 
            pListParams->CommandArgs);
    g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Execute,DEBUG_EXECUTE_DEFAULT);
    dprintf("\n");

    if (CheckControlC()) {
        return TRUE;
    }

    return FALSE;
}

/*
    !list [-type <Type>]  [-x "<Command>"] <address>
    
    This dumps out a list starting at ginve <address>
    
    <Type>      If types is specified, it'll list that particular type accoring to
                the given field.
    
    <Command>   If specified it'll execute the command for every list element.
           
*/
DECLARE_API ( list )
{
    CHAR  Command[MAX_PATH], CmdArgs[MAX_PATH];
    CHAR  Type[MAX_PATH];
    CHAR  Field[MAX_PATH];
    ULONG64 Start;
    ULONG   i, Offset, Commandlen;
    ULONG64 Next, Current;
    LIST_TYPE_PARAMS ListParams;

    ZeroMemory(Type, sizeof(Type));
    ZeroMemory(Field, sizeof(Field));
    ZeroMemory(Command, sizeof(Command));
    CmdArgs[0] = 0;
    Start = 0;
    while (args && *args) {
        SKIP_WSPACE(args);

        if (*args == '-' || *args == '/') {
            ++args;
            if (*args == 't') {
                PCHAR Dot;

                args++;
                SKIP_WSPACE(args);

                Dot = strchr(args, '.');
                if (Dot) {
                    strncpy(Type, args, (ULONG) (ULONG_PTR) (Dot-args));
                    
                    Dot++;
                    i=0;
                    while (*Dot && (i < MAX_PATH-1) && (*Dot != ' ') && (*Dot != '\t')) 
                           Field[i++] = *Dot++;
                    args = Dot;
                }
            } else if (*args == 'x') {
                ++args;
                
                SKIP_WSPACE(args);
                i=0;
                if (*args == '"') {
                    ++args;
                    while (*args && (i < MAX_PATH-1) && (*args != '"')) 
                        Command[i++] = *args++;
                    ++args;
                } else {
                    dprintf("Invalid command specification. See !list -h\n");
                    return E_INVALIDARG;
                }
            } else if (*args == 'a') {
                ++args;
                
                SKIP_WSPACE(args);
                i=0;
                if (*args == '"') {
                    ++args;
                    while (*args && (i < MAX_PATH-1) && (*args != '"')) 
                        CmdArgs[i++] = *args++;
                    ++args;
                    CmdArgs[i] = 0;
                } else {
                    dprintf("Invalid command argument specification. See !list -h\n");
                    return E_INVALIDARG;
                }
            } else if (*args == 'h' || *args == '?') {
                dprintf("Usage: !list -t [mod!]TYPE.Field <Start-Address>\n"
                        "             -x \"Command-for-each-element\"\n"
                        "             -a \"Command-arguments\"\n"
                        "             -h\n"
                        "Command after -x is executed for each list element. Its first argument is\n"
                        "list-head address and remaining arguments are specified after -a\n"
                        "eg. !list -t MYTYPE.l.Flink -x \"dd\" -a \"l2\" 0x6bc00\n"
                        "     dumps first 2 dwords in list of MYTYPE at 0x6bc00\n\n"
                        );
                return S_OK;
            } else {
                dprintf("Invalid flag -%c in !list\n", *args);
                return E_INVALIDARG;
            }
        } else {
            if (!GetExpressionEx(args, &Start, &args)) {
                dprintf("Invalid expression in %s\n", args);
                return E_FAIL;
            }
        }
    }

    Offset = 0;
    if (!Command[0]) {
        strcat(Command, "dp");
    }

    if (Type[0] && Field[0]) {
        
        if (GetFieldOffset(Type, Field, &Offset)) {
            dprintf("GetFieldOffset failed for %s.%s\n", Type, Field);
            return E_FAIL;
        }
        
        
        ListParams.Command = Command;
        ListParams.CommandArgs = CmdArgs;
        ListParams.FieldOffset = Offset;
        ListParams.nElement = 0;

        INIT_API();
        
        ListType(Type, Start, FALSE, Field, (PVOID) &ListParams, &ListCallback );

        EXIT_API();
        return S_OK;

    }
    Current = Start;
    Next = 0;
    INIT_API();

    while (Next != Start) {
        CHAR  Execute[MAX_PATH];
        PCHAR Buffer;

        // Execute command
        sprintf(Execute, "%s %I64lx %s", Command, Current, CmdArgs);
        g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Execute,DEBUG_EXECUTE_DEFAULT);
        dprintf("\n");
    
        if (!ReadPointer(Current + Offset, &Next)) {
            dprintf("Cannot read next element at %p\n",
                    Current + Offset);
            break;
        }
        if (!Next) {
            break;
        }
        Next -= Offset;
        Current = Next;
        if (CheckControlC()) {
            break;
        }
    }

    EXIT_API();

   
    return S_OK;
}

BOOL
AnalyzeExceptionPointer(
    ULONG64 ExcepPtr
    )
{
    ULONG64 Exr, Cxr;
    ULONG PtrSize= IsPtr64() ? 8 : 4;

    if (!ReadPointer(ExcepPtr, &Exr) ||
        !ReadPointer(ExcepPtr + PtrSize, &Cxr)) {
        dprintf("Unable to read exception poointers at %p\n", ExcepPtr);
        return FALSE;
    }

    CHAR Cmd[100];

    sprintf(Cmd, ".exr %I64lx", Exr);
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK,
                          Cmd, DEBUG_EXECUTE_DEFAULT);
    
    sprintf(Cmd, ".cxr %I64lx", Cxr);
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK,
                          Cmd, DEBUG_EXECUTE_DEFAULT);
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK,
                          "kb", DEBUG_EXECUTE_DEFAULT);
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK,
                          ".cxr", DEBUG_EXECUTE_DEFAULT);
    return TRUE;
}

BOOL
IsFunctionAddr(
    ULONG64 IP,
    PSTR FuncName
    )
// Check if IP is in the function FuncName
{
    CHAR Buffer[MAX_PATH], *scan, *FnIP;
    ULONG64 Disp;

    GetSymbol(IP, Buffer, &Disp);

    if (scan = strchr(Buffer, '!')) {
        FnIP = scan+1;
        while (*FnIP == '_') ++FnIP;
    } else {
        FnIP = &Buffer[0];
    }

    return !strncmp(FnIP, FuncName, strlen(FuncName));
}

BOOL
GetExceptionPointerFromStack(
    PULONG64 pExcePtr
    )
{
#define MAX_STACK_FRAMES 50
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES], *Frame;
    ULONG nFrames;

    if (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &nFrames ) == S_OK) {
        for (unsigned int i=0; i<nFrames; ++i) {
            if (IsFunctionAddr(stk[i].InstructionOffset, "UnhandledExceptionFilter")) {
                *pExcePtr = stk[i].Params[0];
                return TRUE;
            }
        }
    }
    return FALSE;
}

/*****************************************************************************************
*
*   Do analysis for a given exception pointer
*
******************************************************************************************/

DECLARE_API ( analyzeexcep )
{
    ULONG64 ExcepPtr=0;
    INIT_API();

    GetExpressionEx(args, &ExcepPtr, &args);

    if (!ExcepPtr) {
        GetExceptionPointerFromStack(&ExcepPtr);
    }
    if (ExcepPtr) {
        AnalyzeExceptionPointer(ExcepPtr);
    } else {
        dprintf("Cannot get exception pointer\n");
    }
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.c

Abstract:

    WinDbg Extension Api

Author:

    Kshitiz K. Sharma (kksharma) 10-Jan-2001

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


DECLARE_API( help )
{
    dprintf("acl <Address> [flags]        - Displays the ACL\n" );
    dprintf("atom [atom]                  - Dump the atom or table(s) for the process\n");
    dprintf("cxr                          - Obsolete, .cxr is new command\n");
    dprintf("dlls [-h]                    - Dump loaded DLLS\n");
    dprintf("exr                          - Obsolete, .exr is new command\n");
    dprintf("gflag [value]                - Dump the global flag\n");
    dprintf("heap [address]               - Dump heap\n");
    dprintf("help                         - Displays this list\n");
    dprintf("kuser                        - Displays KUSER_SHARED_DATA\n");
    dprintf("list                         - Dumps lists, list -h for more info\n");
    dprintf("obja [address]               - Displays object attributes\n");
    dprintf("peb [peb addr to dump]       - Dump the PEB structure\n");
    dprintf("psr                          - Dumps an IA64 Processor Status Word\n");
    dprintf("sd <Address> [flags]         - Displays the SECURITY_DESCRIPTOR\n" );
    dprintf("sid <Address> [flags]        - Displays the SID\n" );
    dprintf("str AnsiStringAddress        - Dump an ANSI string\n");
    dprintf("teb [teb addr to dump]       - Dump the TEB structure\n"); 
    dprintf("ustr UnicodeStringAddress    - Dump a UNICODE string\n");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\heappagx.c ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    heappagx.c

Abstract:

    This module contains the page heap manager debug extensions.

Author:

    Tom McGuire (TomMcg) 06-Jan-1995
    Silviu Calinoiu (SilviuC) 22-Feb-2000

Revision History:

--*/


#define DEBUG_PAGE_HEAP 1

#include "precomp.h"
#include "heap.h"


__inline
BOOLEAN
CheckInterrupted(
    VOID
    )
{
    if (CheckControlC()) {
        dprintf( "\nInterrupted\n\n" );
        return TRUE;
    }
    return FALSE;
}

__inline
ULONG64
FetchRemotePVOID (
    ULONG64 Address
    )
{
    ULONG64 RemoteValue = 0;
    ReadPointer( Address, &RemoteValue);
    return RemoteValue;
}

__inline
ULONG
FetchRemoteULONG(
    ULONG64 Address
    )
{
    ULONG RemoteValue = 0;
    ReadMemory( Address, &RemoteValue, sizeof( ULONG ), NULL );
    return RemoteValue;
}

ULONG
ReturnFieldOffset(
    PCHAR TypeName,
    PCHAR FieldName)
{
    ULONG off=0;

    GetFieldOffset(TypeName, FieldName, &off);
    return off;
}


#define FETCH_REMOTE_FIELD_PTR( StructBase, StructType, FieldName ) \
            FetchRemotePVOID((StructBase) + ReturnFieldOffset( #StructType, #FieldName ))

#define FETCH_REMOTE_FIELD_INT( StructBase, StructType, FieldName ) \
            FetchRemoteULONG((StructBase) + ReturnFieldOffset( #StructType, #FieldName ))

#define FETCH_REMOTE_FIELD_SIZE_T( StructBase, StructType, FieldName ) \
            FetchRemotePVOID((StructBase) + ReturnFieldOffset( #StructType, #FieldName ))

#define DUMP_REMOTE_FIELD_INT( DumpName, StructBase, StructType, FieldName ) \
            dprintf( "%s%08X\n", (DumpName), FETCH_REMOTE_FIELD_INT( StructBase, StructType, FieldName ))

#define DUMP_REMOTE_FIELD_PTR( DumpName, StructBase, StructType, FieldName ) \
            dprintf( "%s%p\n", (DumpName), FETCH_REMOTE_FIELD_PTR( StructBase, StructType, FieldName ))

VOID
DebugPageHeapLocateFaultAllocation(
    ULONG64 RemoteHeap,
    ULONG64 AddressOfFault
    );

VOID
DebugPageHeapReportAllocation(
    ULONG64 RemoteHeap,
    ULONG64 RemoteHeapNode,
    PCHAR NodeType,
    ULONG64 AddressOfFault
    );

BOOLEAN
DebugPageHeapExtensionShowHeapList(
    VOID
    );

VOID
TraceDatabaseDump (
    PCSTR Args,
    BOOLEAN SortByCountField
    );

VOID
TraceDatabaseBlockDump (
    ULONG64 Address
    );

VOID
FaultInjectionTracesDump (
    PCSTR Args
    );

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

VOID DebugPageHeapHelp (
    )
{

    dprintf ("!heap -p          Dump all page heaps.                        \n");
    dprintf ("!heap -p -h ADDR  Detailed dump of page heap at ADDR.         \n");
    dprintf ("!heap -p -a ADDR  Figure out what heap block is at ADDR.      \n");
    dprintf ("!heap -p -t [N]   Dump N collected traces with heavy heap users.\n");
    dprintf ("!heap -p -tc [N]  Dump N traces sorted by count usage (eqv. with -t).\n");
    dprintf ("!heap -p -ts [N]  Dump N traces sorted by size.\n");
    dprintf ("!heap -p -fi [N]  Dump last N fault injection traces.\n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf (" |     |               |  | Normal heap allocated block       \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf ("     ^         ^        ^                                     \n");
    dprintf ("     |         |        8 suffix bytes filled with 0xA0       \n");
    dprintf ("     |         user allocation (filled with E0 if zeroing not requested) \n");
    dprintf ("     block header (starts with 0xABCDAAAA and ends with 0xDCBAAAAA).\n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf (" |     |               |  | Normal heap freed block           \n");
    dprintf (" +-----+---------------+--+                                   \n");
    dprintf ("     ^         ^        ^                                     \n");
    dprintf ("     |         |        8 suffix bytes filled with 0xA0       \n");
    dprintf ("     |         user allocation (filled with F0 bytes)         \n");
    dprintf ("     block header (starts with 0xABCDAAA9 and ends with 0xDCBAAA9). \n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------+--+------                                   \n");
    dprintf (" |     |         |  | ... N/A page     Page heap              \n");
    dprintf (" +-----+---------+--+------            allocated block        \n");
    dprintf ("     ^         ^   ^                                          \n");
    dprintf ("     |         |   0-7 suffix bytes filled with 0xD0          \n");
    dprintf ("     |         user allocation (filled with C0 if zeroing not requested) \n");
    dprintf ("     block header (starts with 0xABCDBBBB and ends with 0xDCBABBBB).\n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
    dprintf (" +-----+---------+--+------                                   \n");
    dprintf (" |     |         |  | ... N/A page     Page heap              \n");
    dprintf (" +-----+---------+--+------            freed block            \n");
    dprintf ("     ^         ^   ^                                          \n");
    dprintf ("     |         |   0-7 suffix bytes filled with 0xD0          \n");
    dprintf ("     |         user allocation (filled with F0 bytes)         \n");
    dprintf ("     block header (starts with 0xABCDBBA and ends with 0xDCBABBBA).\n");
    dprintf ("     A `dt DPH_BLOCK_INFORMATION' on header address followed by  \n");
    dprintf ("     a `dds' on the StackTrace field gives the stacktrace of allocation.  \n");
    dprintf ("                                                              \n");
}


VOID
DebugPageHeapExtensionFind(
    PCSTR ArgumentString
    )
{
    ULONG64 RemoteHeapList;
    ULONG64 RemoteHeap;
    ULONG64 RemoteVirtualNode;
    ULONG64 RemoteVirtualBase;
    ULONG64 RemoteVirtualSize;
    ULONG64 AddressOfFault;
    BOOL Result;

    Result = GetExpressionEx (ArgumentString, 
                              &AddressOfFault,
                              &ArgumentString);

    if (Result == FALSE) {
        dprintf ("\nFailed to convert `%s' to an address.\n",
                 ArgumentString);
        return;
    }

    RemoteHeapList = (ULONG64) GetExpression( "NTDLL!RtlpDphHeapListHead" );
    RemoteHeap     = FetchRemotePVOID( RemoteHeapList );

    if (RemoteHeap == 0) {
        dprintf( "\nNo page heaps active in process (or bad symbols)\n\n" );
        AddressOfFault = 0;
    }

    if (( AddressOfFault == 0 ) || ( strchr( ArgumentString, '?' ))) {

        DebugPageHeapHelp();
        return;
    }

    //
    //  Find the heap that contains the range of virtual addresses that
    //  contain the AddressOfFault.
    //

    for (;;) {

        //
        //  The heap header contains a linked list of virtual memory
        //  allocations.
        //

        RemoteVirtualNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pVirtualStorageListHead );

        while (RemoteVirtualNode != 0) {

            RemoteVirtualBase = FETCH_REMOTE_FIELD_PTR( RemoteVirtualNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
            RemoteVirtualSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteVirtualNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );

            if (( RemoteVirtualBase == 0 ) || ( RemoteVirtualSize == 0 )) {
                dprintf( "\nPAGEHEAP: Heap 0x%p appears to have an invalid\n"
                    "          virtual allocation list\n\n",
                    RemoteHeap
                    );
            }

            if ((AddressOfFault >= RemoteVirtualBase) &&
                (AddressOfFault <= RemoteVirtualBase + RemoteVirtualSize )) {

                //
                //  The fault appears to have occurred in the range of this
                //  heap, so we'll search the busy and free lists for the
                //  closest match and report it.  Then exit.
                //

                DebugPageHeapLocateFaultAllocation( RemoteHeap, AddressOfFault );
                return;
            }

            if (CheckInterrupted()) {
                return;
            }

            RemoteVirtualNode = FETCH_REMOTE_FIELD_PTR( RemoteVirtualNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );

        }


        //
        //  Not found in this heap.  Continue with next heap or end
        //  of heap list.
        //

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNextHeapRoot );

        if (RemoteHeap == 0) {
            dprintf( "\nPAGEHEAP: Could not find a page heap containing\n"
                "          the virtual address 0x%p\n\n",
                AddressOfFault
                );
            return;
        }
    }
}


VOID
DebugPageHeapLocateFaultAllocation(
    ULONG64 RemoteHeap,
    ULONG64 AddressOfFault
    )
{
    ULONG64 ClosestHeapNode;
    ULONG64 ClosestDifference;
    ULONG64 RemoteHeapNode;
    ULONG64 RemoteAllocBase;
    ULONG64 RemoteAllocSize;
    ULONG RemoteFreeListSize;

    ClosestHeapNode = 0;

    //
    //  First search the busy list for the containing allocation, if any.
    //

    RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pBusyAllocationListHead );

    while (RemoteHeapNode != 0) {

        RemoteAllocBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
        RemoteAllocSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );

        if ((AddressOfFault >= RemoteAllocBase) &&
            (AddressOfFault < RemoteAllocBase + RemoteAllocSize)) {

            //
            //  The fault appears to have occurred in this allocation's
            //  memory (which includes the NO_ACCESS page beyond the user
            //  portion of the allocation).
            //

            DebugPageHeapReportAllocation( RemoteHeap, RemoteHeapNode, "allocated", AddressOfFault );
            return;
        }

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );
    }

    //
    //  Failed to find containing allocation on busy list, so search free.
    //

    RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pFreeAllocationListHead );

    while (RemoteHeapNode != 0) {

        RemoteAllocBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
        RemoteAllocSize = FETCH_REMOTE_FIELD_INT( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );

        if ((AddressOfFault >= RemoteAllocBase) &&
            (AddressOfFault < RemoteAllocBase + RemoteAllocSize)) {

            //
            //  The fault appears to have occurred in this freed alloc's
            //  memory.
            //

            DebugPageHeapReportAllocation( RemoteHeap, RemoteHeapNode, "freed", AddressOfFault );
            return;
        }

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeapNode = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );
    }

    //
    //  Failed to find containing allocation in free list, but we wouldn't
    //  have gotten this far if the debug heap did not contain the virtual
    //  address range of the fault.  So, report it as a wild pointer that
    //  could have been freed memory.
    //

    RemoteFreeListSize = FETCH_REMOTE_FIELD_INT( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nFreeAllocations );

    dprintf( "\nPAGEHEAP: %p references memory contained in the heap %p,\n"
        "          but does not reference an existing allocated or\n"
        "          recently freed heap block.  It is possible that\n"
        "          the memory at %p could previously have been\n"
        "          allocated and freed, but it must have been freed\n"
        "          prior to the most recent %d frees.\n\n",
        AddressOfFault,
        RemoteHeap,
        AddressOfFault,
        RemoteFreeListSize
        );

}


VOID
DebugPageHeapReportAllocation(
    ULONG64 RemoteHeap,
    ULONG64 RemoteHeapNode,
    PCHAR NodeType,
    ULONG64 AddressOfFault
    )
{
    ULONG64 RemoteUserBase;
    ULONG64 RemoteUserSize;
    ULONG64 EndOfBlock;
    ULONG64 PastTheBlock;
    ULONG64 BeforeTheBlock;

    RemoteUserBase = FETCH_REMOTE_FIELD_PTR( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, pUserAllocation );
    RemoteUserSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, nUserRequestedSize );

    EndOfBlock = RemoteUserBase + RemoteUserSize - 1;

    if (AddressOfFault > EndOfBlock) {

        PastTheBlock = AddressOfFault - EndOfBlock;

        dprintf( "\nPAGEHEAP: %p is %p bytes beyond the end of %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            PastTheBlock,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    else if (AddressOfFault >= RemoteUserBase) {

        dprintf( "\nPAGEHEAP: %p references %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    else {

        BeforeTheBlock = (PCHAR) RemoteUserBase - (PCHAR) AddressOfFault;

        dprintf( "\nPAGEHEAP: %p is %p bytes before the %s heap block at\n"
            "          %p of 0x%x bytes",
            AddressOfFault,
            BeforeTheBlock,
            NodeType,
            RemoteUserBase,
            RemoteUserSize
            );

    }

    {
        ULONG64 Trace;

        Trace = FETCH_REMOTE_FIELD_PTR (RemoteHeapNode, NTDLL!_DPH_HEAP_BLOCK, StackTrace);
        dprintf ("\n\n");
        TraceDatabaseBlockDump (Trace);
    }
}


#define FORMAT_TYPE_BUSY_LIST 0
#define FORMAT_TYPE_FREE_LIST 1
#define FORMAT_TYPE_VIRT_LIST 2


BOOLEAN
DebugPageHeapDumpThisList(
    ULONG64 RemoteList,
    PCH   ListName,
    ULONG FormatType
    )
{
    ULONG64 RemoteNode;
    ULONG64 RemoteBase;
    ULONG64 RemoteSize;
    ULONG64 RemoteUser;
    ULONG64 RemoteUsiz;
    ULONG RemoteFlag;
    ULONG64 RemoteValu;

    RemoteNode = RemoteList;
    dprintf( "\n%s:\n", ListName );

    switch (FormatType) {
    
    case FORMAT_TYPE_BUSY_LIST:
        dprintf( "UserAddr  UserSize  VirtAddr  VirtSize  UserFlag  UserValu\n" );
        break;
    case FORMAT_TYPE_FREE_LIST:
        dprintf( "UserAddr  UserSize  VirtAddr  VirtSize\n" );
        break;
    }

    while (RemoteNode) {

        RemoteBase = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, pVirtualBlock );
        RemoteSize = FETCH_REMOTE_FIELD_SIZE_T( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, nVirtualBlockSize );
        RemoteUser = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, pUserAllocation );
        RemoteUsiz = FETCH_REMOTE_FIELD_SIZE_T( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, nUserRequestedSize );
        RemoteFlag = FETCH_REMOTE_FIELD_INT( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, UserFlags );
        RemoteValu = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, UserValue );
        RemoteNode = FETCH_REMOTE_FIELD_PTR( RemoteNode, NTDLL!_DPH_HEAP_BLOCK, pNextAlloc );

        switch (FormatType) {
        
        case FORMAT_TYPE_BUSY_LIST:

            dprintf(( RemoteFlag || RemoteValu ) ?
                "%p  %08X  %p  %08X  %08X  %p\n" :
            "%p  %08X  %p  %08X\n",
                RemoteUser,
                RemoteUsiz,
                RemoteBase,
                RemoteSize,
                RemoteFlag,
                RemoteValu
                );
            break;

        case FORMAT_TYPE_FREE_LIST:

            dprintf( "%p  %08X  %p  %08X\n",
                RemoteUser,
                RemoteUsiz,
                RemoteBase,
                RemoteSize
                );
            break;

        case FORMAT_TYPE_VIRT_LIST:

            dprintf( "%p - %p (%08X)\n",
                RemoteBase,
                (PCH)RemoteBase + RemoteSize,
                RemoteSize
                );
            break;

        }

        if (CheckInterrupted()) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
DebugPageHeapDumpThisHeap(
    ULONG64 RemoteHeap
    )
{
    ULONG64 RemoteNode;

    dprintf( "\nDPH Heap at %p:\n\n", RemoteHeap );

    DUMP_REMOTE_FIELD_INT( "Signature:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Signature );
    DUMP_REMOTE_FIELD_INT( "HeapFlags:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, HeapFlags );
    DUMP_REMOTE_FIELD_INT( "ExtraFlags:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, ExtraFlags );
    DUMP_REMOTE_FIELD_INT( "NormalHeap:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, NormalHeap );
    DUMP_REMOTE_FIELD_INT( "VirtualRanges:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nVirtualStorageRanges );
    DUMP_REMOTE_FIELD_PTR( "VirtualCommit:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nVirtualStorageBytes );
    DUMP_REMOTE_FIELD_INT( "BusyAllocs:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nBusyAllocations );
    DUMP_REMOTE_FIELD_PTR( "BusyVirtual:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nBusyAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_PTR( "BusyReadWrite:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nBusyAllocationBytesAccessible );
    DUMP_REMOTE_FIELD_INT( "FreeAllocs:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nFreeAllocations );
    DUMP_REMOTE_FIELD_PTR( "FreeVirtual:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nFreeAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_INT( "AvailAllocs:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nAvailableAllocations );
    DUMP_REMOTE_FIELD_PTR( "AvailVirtual:    ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nAvailableAllocationBytesCommitted );
    DUMP_REMOTE_FIELD_INT( "NodePools:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nNodePools );
    DUMP_REMOTE_FIELD_PTR( "NodeVirtual:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nNodePoolBytes );
    DUMP_REMOTE_FIELD_INT( "AvailNodes:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, nUnusedNodes );
    DUMP_REMOTE_FIELD_INT( "Seed:            ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Seed );

    dprintf (" --- Counters --- \n");
    DUMP_REMOTE_FIELD_INT( "Size < 1K:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[0] );
    DUMP_REMOTE_FIELD_INT( "Size < 4K:       ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[1] );
    DUMP_REMOTE_FIELD_INT( "Size >= 4K:      ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[2] );
    DUMP_REMOTE_FIELD_INT( "W/o alloc info:  ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[3] );
    DUMP_REMOTE_FIELD_INT( "Total allocs:    ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[4] );
    DUMP_REMOTE_FIELD_INT( "Total reallocs:  ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[5] );
    DUMP_REMOTE_FIELD_INT( "Total frees:     ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[6] );
    DUMP_REMOTE_FIELD_INT( "Normal allocs:   ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[7] );
    DUMP_REMOTE_FIELD_INT( "Normal reallocs: ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[8] );
    DUMP_REMOTE_FIELD_INT( "Normal frees:    ", RemoteHeap, NTDLL!_DPH_HEAP_ROOT, Counter[9] );

    {
        ULONG64 Trace;

        dprintf ("\n");
        Trace = FETCH_REMOTE_FIELD_PTR (RemoteHeap, NTDLL!_DPH_HEAP_ROOT, CreateStackTrace);
        TraceDatabaseBlockDump (Trace);
    }

    if (! DebugPageHeapDumpThisList(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pVirtualStorageListHead ),
        "VirtualList",
        FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisList(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNodePoolListHead ),
        "NodePoolList",
        FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisList(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pAvailableAllocationListHead ),
        "AvailableList",
        FORMAT_TYPE_VIRT_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisList(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pFreeAllocationListHead ),
        "FreeList",
        FORMAT_TYPE_FREE_LIST )) {
        return FALSE;
    }

    if (! DebugPageHeapDumpThisList(
        FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pBusyAllocationListHead ),
        "BusyList",
        FORMAT_TYPE_BUSY_LIST )) {
        return FALSE;
    }

    dprintf( "\n" );
    return TRUE;
}


VOID
DebugPageHeapExtensionDump(
    PCSTR ArgumentString
    )
{
    ULONG64 RemoteHeapList;
    ULONG64 RemoteHeap;
    ULONG64 RemoteHeapToDump;
    BOOLEAN AnyDumps = FALSE;
    BOOL Result;

    Result = GetExpressionEx (ArgumentString, 
                              &RemoteHeapToDump,
                              &ArgumentString);

    if (Result == FALSE) {
        dprintf ("\nFailed to convert `%s' to an address.\n",
                 ArgumentString);
        return;
    }

    RemoteHeapList = (ULONG64) GetExpression( "NTDLL!RtlpDphHeapListHead" );
    RemoteHeap = FetchRemotePVOID( RemoteHeapList );

    if (( RemoteHeap       == 0 ) ||
        ( RemoteHeapToDump == 0 ) ||
        ( strchr( ArgumentString, '?' ))) {

        DebugPageHeapHelp();
        DebugPageHeapExtensionShowHeapList();
        return;
    }

    while (RemoteHeap != 0) {

        if ((((LONG_PTR)RemoteHeapToDump & 0xFFFF0000 ) == ((LONG_PTR)RemoteHeap & 0xFFFF0000 )) ||
            ((LONG_PTR)RemoteHeapToDump == -1 )) {

            AnyDumps = TRUE;

            if (! DebugPageHeapDumpThisHeap( RemoteHeap ))
                return;

        }

        if (CheckInterrupted()) {
            return;
        }

        RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNextHeapRoot );
    }

    if (! AnyDumps) {
        dprintf( "\nPage heap \"0x%p\" not found in process\n\n", RemoteHeapToDump );
        DebugPageHeapExtensionShowHeapList();
    }
}


BOOLEAN
DebugPageHeapExtensionShowHeapList(
    VOID
    )
{
    ULONG64 RemoteHeapList = (ULONG64)GetExpression( "NTDLL!RtlpDphHeapListHead" );
    ULONG64 RemoteHeap     = FetchRemotePVOID( RemoteHeapList );
    ULONG64 NormalHeap;
    ULONG HeapFlags;

    if (RemoteHeap == 0) {

        dprintf( "\nNo page heaps active in process (or bad symbols)\n" );
        return FALSE;
    }
    else {

        dprintf( "\nPage heaps active in process:\n\n" );

        do {

            NormalHeap = FETCH_REMOTE_FIELD_PTR (RemoteHeap, NTDLL!_DPH_HEAP_ROOT, NormalHeap);
            HeapFlags = (ULONG) FETCH_REMOTE_FIELD_INT (RemoteHeap, NTDLL!_DPH_HEAP_ROOT, ExtraFlags);

            dprintf ("    %p (%p, flags %X)\n", RemoteHeap, NormalHeap, HeapFlags);

            RemoteHeap = FETCH_REMOTE_FIELD_PTR( RemoteHeap, NTDLL!_DPH_HEAP_ROOT, pNextHeapRoot );

        } while (RemoteHeap);

        dprintf( "\n" );
        return TRUE;
    }
}


BOOLEAN
DebugPageHeapIsActive(
    VOID
    )
{
    ULONG64 RemoteHeapList = (ULONG64)GetExpression( "NTDLL!RtlpDphHeapListHead" );
    ULONG64 RemoteHeap     = FetchRemotePVOID( RemoteHeapList );

    if (RemoteHeap == 0) {

        return FALSE;
    }
    else {

        return TRUE;
    }
}


VOID
DebugPageHeapExtension(
    PCSTR ArgumentString
    )
{
    PCSTR Current;
    
    //
    // Is help requested?
    //

    if (strstr (ArgumentString, "?") != NULL) {

        DebugPageHeapHelp ();
    }

    //
    // If page heap not active then return immediately.
    //

    if (! DebugPageHeapIsActive()) {
        dprintf ("Page heap is not active for this process. \n");
        return;
    }

    //
    // Parse command line
    //

    if ((Current = strstr (ArgumentString, "-h")) != NULL) {

        DebugPageHeapExtensionDump (Current + strlen("-h"));
    }
    else if ((Current = strstr (ArgumentString, "-a")) != NULL) {

        DebugPageHeapExtensionFind (Current + strlen("-a"));
    }
    else if ((Current = strstr (ArgumentString, "-tc")) != NULL) {

        TraceDatabaseDump (Current + strlen("-tc"), TRUE);
    }
    else if ((Current = strstr (ArgumentString, "-ts")) != NULL) {

        TraceDatabaseDump (Current + strlen("-ts"), FALSE);
    }
    else if ((Current = strstr (ArgumentString, "-t")) != NULL) {

        TraceDatabaseDump (Current + strlen("-t"), TRUE);
    }
    else if ((Current = strstr (ArgumentString, "-fi")) != NULL) {

        FaultInjectionTracesDump (Current + strlen("-fi"));
    }
    else {
        DebugPageHeapExtensionShowHeapList ();
    }

    return;
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////// Trace database
/////////////////////////////////////////////////////////////////////

typedef struct {
    
    ULONG64 Address;
    ULONG64 Count;
    ULONG64 Size;

} TRACE, *PTRACE;

VOID
TraceDatabaseDump (
    PCSTR Args,
    BOOLEAN SortByCountField
    )
{
    ULONG64 Database;
    ULONG I, J, Min, TraceIndex;
    PTRACE Trace;
    ULONG64 TracesToDisplay = 0;
    ULONG64 MaximumSize;
    ULONG64 CurrentSize;
    ULONG64 NoOfTraces;
    ULONG64 NoOfHits;
    ULONG NoOfBuckets;
    ULONG PvoidSize;
     
    if (Args) {
        sscanf (Args, "%I64u", &TracesToDisplay);

        if (TracesToDisplay == 0) {
            TracesToDisplay = 4;
        }
    }

    Database = (ULONG64) GetExpression ("NTDLL!RtlpDphTraceDatabase" );
    Database = FetchRemotePVOID (Database);

    MaximumSize = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, MaximumSize);
    CurrentSize = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, CurrentSize);

    NoOfBuckets = FETCH_REMOTE_FIELD_INT(Database, NTDLL!_RTL_TRACE_DATABASE, NoOfBuckets);
    NoOfTraces = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, NoOfTraces);
    NoOfHits = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, NoOfHits);

    PvoidSize = IsPtr64() ? 8 : 4;

    dprintf ("MaximumSize: %p \n", MaximumSize);
    dprintf ("CurentSize: %p \n", CurrentSize);
    dprintf ("NoOfBuckets: %u \n", NoOfBuckets);
    dprintf ("NoOfTraces: %p \n", NoOfTraces); 
    dprintf ("NoOfHits: %p \n", NoOfHits);

    //
    // Dump hash counters.
    //

    dprintf ("HashCounters:");

    for (I = 0; I < 16; I += 1) {

        CHAR FieldName[16];

        sprintf (FieldName, "HashCounter[%u]", I);

        dprintf (" %u", FetchRemoteULONG (
            Database + ReturnFieldOffset("NTDLL!_RTL_TRACE_DATABASE", FieldName)));
    }
    
    dprintf ("\n");


    if (NoOfTraces < TracesToDisplay) {
        TracesToDisplay = NoOfTraces;
    }

    Trace = (PTRACE) malloc (sizeof(TRACE) * (ULONG)NoOfTraces);

    if (Trace == NULL) {
        dprintf ("Error: cannot allocate trace database debug structure.\n");
        return;
    }

    //
    // Read all the traces from the hash table.
    //

    for (I = 0, TraceIndex = 0; I < NoOfBuckets; I += 1) {

        ULONG64 Current;

        Current = FETCH_REMOTE_FIELD_PTR(Database, NTDLL!_RTL_TRACE_DATABASE, Buckets);
        Current += I * PvoidSize;

        Current = FetchRemotePVOID (Current);

        while (Current != 0) {

            if (TraceIndex >= NoOfTraces) {
                dprintf ("Internal error: TraceIndex >= NoOfTraces \n");
                return;
            }

            Trace[TraceIndex].Address = Current;
            Trace[TraceIndex].Count = FETCH_REMOTE_FIELD_PTR (Current, NTDLL!_RTL_TRACE_BLOCK, UserCount);
            Trace[TraceIndex].Size = FETCH_REMOTE_FIELD_PTR (Current, NTDLL!_RTL_TRACE_BLOCK, UserSize);
            TraceIndex += 1;

            Current = FETCH_REMOTE_FIELD_PTR (Current, NTDLL!_RTL_TRACE_BLOCK, Next);
        }
    }

    //
    // Sort the traces just read based on Count field.
    //

    for (I = 0; I < NoOfTraces; I += 1) {

        for (J = I, Min = I; J < NoOfTraces; J += 1) {

            if (SortByCountField) {

                if (Trace[J].Count > Trace[Min].Count) {
                    Min = J;
                }
            }
            else {

                if (Trace[J].Size > Trace[Min].Size) {
                    Min = J;
                }
            }
        }

        if (Min != I) {

            ULONG64 Address;
            ULONG64 Count;
            ULONG64 Size;

            Address = Trace[I].Address;
            Count = Trace[I].Count;
            Size = Trace[I].Size;

            Trace[I].Address = Trace[Min].Address;
            Trace[I].Count = Trace[Min].Count;
            Trace[I].Size = Trace[Min].Size;

            Trace[Min].Address = Address;
            Trace[Min].Count = Count;
            Trace[Min].Size = Size;
        }
    }

#if 0

    for (I = 1; I < NoOfTraces; I += 1) {

        if (Trace[I].Size > Trace[I-1].Size) {
            dprintf (".");
        }
    }

#endif

    dprintf ("\n");

    //
    // Print first N
    //

    for (I = 0; I < TracesToDisplay; I += 1) {
        dprintf ("\n");
        TraceDatabaseBlockDump (Trace[I].Address);

        if (CheckControlC()) {
            dprintf ("Interrupted \n");
            break;
        }
    }

    dprintf ("\n");
    free (Trace);
}


VOID
TraceDatabaseBlockDump (
    ULONG64 Address
    )
{
    ULONG64 TraceAddress;
    ULONG64 ReturnAddress;
    CHAR  SymbolName[ 1024 ];
    ULONG64 Displacement;
    ULONG I;
    ULONG BlockSize;
    ULONG PvoidSize;
     
    if (Address == 0) {
        dprintf ("    No trace\n");
        return;
    }

    PvoidSize = IsPtr64() ? 8 : 4;
    
    BlockSize = FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Size);

    dprintf ("    Trace @ %p: %p bytes, %u blocks (heap @ %p) \n", 
             Address,
             FETCH_REMOTE_FIELD_PTR(Address, NTDLL!_RTL_TRACE_BLOCK, UserSize),
             FETCH_REMOTE_FIELD_PTR(Address, NTDLL!_RTL_TRACE_BLOCK, UserCount),
             FETCH_REMOTE_FIELD_PTR(Address, NTDLL!_RTL_TRACE_BLOCK, UserContext));

    dprintf ("    [%x, %u, %u] \n",
             FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Magic),
             FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Count),
             FETCH_REMOTE_FIELD_INT(Address, NTDLL!_RTL_TRACE_BLOCK, Size));


    for (I = 0; I < BlockSize; I += 1) {

        TraceAddress = FETCH_REMOTE_FIELD_PTR (Address, NTDLL!_RTL_TRACE_BLOCK, Trace);

        ReturnAddress = FetchRemotePVOID (TraceAddress + I * PvoidSize);

        GetSymbol (ReturnAddress, SymbolName, &Displacement);

        dprintf ("    %p %s+0x%p\n", 
                 ReturnAddress, 
                 SymbolName, 
                 Displacement);
    }
}

/////////////////////////////////////////////////////////////////////
////////////////////////////////////////////// Fault injection traces
/////////////////////////////////////////////////////////////////////

VOID
FaultInjectionTracesDump (
    PCSTR Args
    )
{
    ULONG64 TracesToDisplay = 0;
    ULONG64 TraceAddress;
    ULONG64 IndexAddress;
    ULONG Index;
    ULONG I;
    const ULONG NO_OF_FAULT_INJECTION_TRACES = 128;
    ULONG PvoidSize;
    ULONG64 TraceBlock;
    ULONG TracesFound = 0;
    BOOLEAN Interrupted = FALSE;
    ULONG64 FlagsAddress;
    ULONG Flags;
     
    if (Args) {
        sscanf (Args, "%I64u", &TracesToDisplay);

        if (TracesToDisplay == 0) {
            TracesToDisplay = 4;
        }
    }

    PvoidSize = IsPtr64() ? 8 : 4;
    
    TraceAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphFaultStacks");
    IndexAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphFaultStacksIndex");
    FlagsAddress = (ULONG64) GetExpression ("NTDLL!RtlpDphGlobalFlags");

    Flags = FetchRemoteULONG (FlagsAddress);

    if (! (Flags & PAGE_HEAP_USE_FAULT_INJECTION)) {

        dprintf ("Fault injection is not enabled for this process. \n");
        dprintf ("Use `pageheap /enable PROGRAM /fault RATE' to enable it. \n");
        return;
    }

    Index = FetchRemoteULONG (IndexAddress);

    for (I = 0; I < NO_OF_FAULT_INJECTION_TRACES; I += 1) {

        Index -= 1;
        Index &= (NO_OF_FAULT_INJECTION_TRACES - 1);
        
        TraceBlock = FetchRemotePVOID (TraceAddress + Index * PvoidSize);

        if (TraceBlock != 0) {
            TracesFound += 1;
            
            dprintf ("\n");
            TraceDatabaseBlockDump (TraceBlock);

            if (TracesFound >= TracesToDisplay) {
                break;
            }
        }
        
        if (CheckControlC()) {
            Interrupted = TRUE;
            dprintf ("Interrupted \n");
            break;
        }
    }

    if (Interrupted == FALSE && TracesFound == 0) {

        dprintf ("No fault injection traces found. \n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\heapleak.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    heapleak.c

Abstract:

    WinDbg Extension Api

Author:

    Adrian Marinescu (adrmarin) 04/17/2000

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "heap.h"
#pragma hdrstop

ULONG PageSize;
ULONG HeapEntrySize;
ULONG PointerSize;
ULONG64 HeapLargestAddress;
BOOLEAN Is64BitArchitecture;
ULONG FrontEndHeapType;
ULONG CrtSegmentIndex;

ULONG ScanLevel;

ULONG LoopLimit = 100000;


BOOLEAN
ReadHeapSubSegment(
    ULONG64 HeapAddress,
    ULONG64 SegmentAddress,
    ULONG64 SubSegmentAddress,
    HEAP_ITERATOR_CALLBACK HeapCallback
    )
{
    ULONG64 SubSegmentDescriptor;
    ULONG64 BlockCount = 0, BlockSize;
    ULONG i;
    ULONG64 CrtAddress;
    ULONG64 EntryAddress;

    GetFieldValue(SubSegmentAddress, "ntdll!_HEAP_USERDATA_HEADER", "SubSegment", SubSegmentDescriptor);

    if (!(*HeapCallback)( CONTEXT_START_SUBSEGMENT,
                          HeapAddress,
                          SubSegmentAddress,
                          SubSegmentDescriptor,
                          0
                     )) {

        return FALSE;
    }

    GetFieldValue(SubSegmentDescriptor, "ntdll!_HEAP_SUBSEGMENT", "BlockCount", BlockCount);

    if (GetFieldValue(SubSegmentDescriptor, "ntdll!_HEAP_SUBSEGMENT", "BlockSize", BlockSize)) {

        (*HeapCallback)( CONTEXT_ERROR,
                         HeapAddress,
                         SegmentAddress,
                         SubSegmentAddress,
                         (ULONG64)(&"subsegment cannot access the block size\n")
                         );
        
        return FALSE;
    }

    if (BlockSize <= 1) {

        (*HeapCallback)( CONTEXT_ERROR,
                 HeapAddress,
                 SegmentAddress,
                 SubSegmentAddress,
                 (ULONG64)(&"invalid block size\n")
                 );

        return FALSE;
    }

    CrtAddress = SubSegmentAddress + GetTypeSize("ntdll!_HEAP_USERDATA_HEADER");

    for (i = 0; i < BlockCount; i++) {

        ULONG64 SmallTagIndex, BlockSegIndex;

        EntryAddress = CrtAddress + i * BlockSize * HeapEntrySize;

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "SegmentIndex", BlockSegIndex);

        if (BlockSegIndex != 0xFF) {
            
            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             (ULONG64)(&"SegmentIndex field corrupted\n")
                             );
        }

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "SmallTagIndex", SmallTagIndex);
        
        if (SmallTagIndex) {

            (*HeapCallback)( CONTEXT_BUSY_BLOCK,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             BlockSize * HeapEntrySize
                             );
        } else {

            (*HeapCallback)( CONTEXT_FREE_BLOCK,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             BlockSize * HeapEntrySize
                             );
        }
    }
    
    if (!(*HeapCallback)( CONTEXT_END_SUBSEGMENT,
                          HeapAddress,
                          SubSegmentAddress,
                          SubSegmentDescriptor,
                          0
                     )) {

        return FALSE;
    }

    return TRUE;
}

//
//  Walking heap routines
//

BOOLEAN
ReadHeapSegment(
    ULONG64 HeapAddress,
    ULONG SegmentIndex,
    ULONG64 SegmentAddress,
    HEAP_ITERATOR_CALLBACK HeapCallback
    )
{
    ULONG64 SegmentBaseAddress;
    ULONG64 PrevEntryAddress, EntryAddress, NextEntryAddress;
    ULONG64 EntrySize, EntryFlags, BlockSegIndex;
    ULONG64 SegmentLastValidEntry;
    ULONG64 UnCommittedRange, UnCommittedRangeAddress = 0, UnCommittedRangeSize = 0;
    ULONG LoopCount;
    BOOLEAN IsSubsegment;

    ScanLevel = SCANSEGMENT;

    if (!(*HeapCallback)( CONTEXT_START_SEGMENT,
                          HeapAddress,
                          SegmentAddress,
                          0,
                          0
                     )) {

        return FALSE;
    }

    CrtSegmentIndex = SegmentIndex;

    GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "BaseAddress", SegmentBaseAddress);
    GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "LastValidEntry", SegmentLastValidEntry);
    GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "UnCommittedRanges", UnCommittedRange);

    if (UnCommittedRange) {

        GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Address", UnCommittedRangeAddress);
        GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Size", UnCommittedRangeSize);
    }

//    dprintf("Uncommitted: %p  %p  %p\n", UnCommittedRange, UnCommittedRangeAddress, UnCommittedRangeSize);

    if (SegmentBaseAddress == HeapAddress) {

        EntryAddress = HeapAddress;

    } else {

        EntryAddress = SegmentAddress;
    }

    PrevEntryAddress = 0;
    LoopCount = 0;

    while (EntryAddress < SegmentLastValidEntry) {

        if (++LoopCount >= LoopLimit) {

             dprintf("Walking the segment exceeded the %ld limit\n", LoopLimit);

             break;
        }

        if (ScanLevel < SCANSEGMENT) {

            break;
        }

        if (GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "Size", EntrySize)) {

            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             (ULONG64)(&"unable to read uncommited range structure at\n")
                             );
            break;
        }
        
        if (EntrySize <= 1) {

            (*HeapCallback)( CONTEXT_ERROR,
                     HeapAddress,
                     SegmentAddress,
                     EntryAddress,
                     (ULONG64)(&"invalid block size\n")
                     );

            break;
        }

        EntrySize *= HeapEntrySize;

        NextEntryAddress = EntryAddress + EntrySize;

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "Flags", EntryFlags);

        GetFieldValue(EntryAddress, "ntdll!_HEAP_ENTRY", "SegmentIndex", BlockSegIndex);

        if (BlockSegIndex != CrtSegmentIndex) {
            
            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             SegmentAddress,
                             EntryAddress,
                             (ULONG64)(&"SegmentIndex field corrupted\n")
                             );
        }

        IsSubsegment = FALSE;

        if (FrontEndHeapType == 2) {

            ULONG64 Signature;
            GetFieldValue(EntryAddress + HeapEntrySize, "ntdll!_HEAP_USERDATA_HEADER", "Signature", Signature);

            if ((ULONG)Signature == 0xF0E0D0C0) {

                ReadHeapSubSegment( HeapAddress, 
                                    SegmentAddress,
                                    EntryAddress + HeapEntrySize, 
                                    HeapCallback );

                IsSubsegment = TRUE;
                
                if (CheckControlC()) {

                    ScanLevel = 0;
                    return FALSE;
                }
            }
        }

        if (!IsSubsegment) {
            if (EntryFlags & HEAP_ENTRY_BUSY) {

                (*HeapCallback)( CONTEXT_BUSY_BLOCK,
                                 HeapAddress,
                                 SegmentAddress,
                                 EntryAddress,
                                 EntrySize
                                 );
            } else {

                (*HeapCallback)( CONTEXT_FREE_BLOCK,
                                 HeapAddress,
                                 SegmentAddress,
                                 EntryAddress,
                                 EntrySize
                                 );
            }
        }
        
        PrevEntryAddress = EntryAddress;
        EntryAddress = NextEntryAddress;

        if (EntryFlags & HEAP_ENTRY_LAST_ENTRY) {
            
            if (CheckControlC()) {

                ScanLevel = 0;
                return FALSE;
            }

            if (EntryAddress == UnCommittedRangeAddress) {

                PrevEntryAddress = 0;
                EntryAddress = UnCommittedRangeAddress + UnCommittedRangeSize;

                GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Next", UnCommittedRange);

                if (UnCommittedRange) {

                    GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Address", UnCommittedRangeAddress);
                    GetFieldValue(UnCommittedRange, "ntdll!_HEAP_UNCOMMMTTED_RANGE", "Size", UnCommittedRangeSize);
                }

            } else {

                break;
            }
        }
    }
    
    if (!(*HeapCallback)( CONTEXT_END_SEGMENT,
                          HeapAddress,
                          SegmentAddress,
                          0,
                          0
                     )) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
ReadHeapData(ULONG64 HeapAddress, HEAP_ITERATOR_CALLBACK HeapCallback)
{
    ULONG SegmentCount = 0;
    ULONG64 Head;
    ULONG64 Next;
    ULONG i;
    ULONG PtrSize;
    ULONG SegmentsOffset;
    ULONG VirtualBlockOffset;
    ULONG64 Segment;
    ULONG64 LookasideAddress;
    ULONG64 LFHAddress;
    ULONG LoopCount;

    ScanLevel = SCANHEAP;

    if (!(*HeapCallback)( CONTEXT_START_HEAP,
                          HeapAddress,
                          0,
                          0,
                          0
                     )) {

        return FALSE;
    }

    PtrSize = IsPtr64() ? 8 : 4;

    LookasideAddress = 0;
    LFHAddress = 0;
    FrontEndHeapType = 0;

    if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "Lookaside", LookasideAddress)) {


        if (GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeapType", FrontEndHeapType)) {

            dprintf("Front-end heap type info is not available\n");
        }

        switch (FrontEndHeapType){
        case 1:
            GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeap", LookasideAddress);
        break;
        case 2:
            GetFieldValue(HeapAddress, "ntdll!_HEAP", "FrontEndHeap", LFHAddress);
        break;
        }

    } else {

        if (LookasideAddress) {

            FrontEndHeapType = 1;
        }
    }

    GetFieldOffset("ntdll!_HEAP", "Segments", &SegmentsOffset);

    do {

        if (ScanLevel < SCANHEAP) {

            return FALSE;
        }

        if (!ReadPointer( HeapAddress + SegmentsOffset + SegmentCount*PtrSize,
                     &Segment ) ) {

            break;
        }

        if (Segment) {

            ReadHeapSegment( HeapAddress,
                             SegmentCount,
                             Segment,
                             HeapCallback
                            );

            SegmentCount += 1;

            if (CheckControlC()) {

                ScanLevel = 0;
                return FALSE;
            }
        }

    } while ( Segment );

    GetFieldOffset("_HEAP", "VirtualAllocdBlocks", &VirtualBlockOffset);

    Head = HeapAddress + VirtualBlockOffset;
    GetFieldValue(HeapAddress, "ntdll!_HEAP", "VirtualAllocdBlocks.Flink", Next);

    LoopCount = 0;

    while (Next != Head) {

        ULONG64 VBlockSize;

        if (++LoopCount >= LoopLimit) {

             dprintf("Walking the virtual block list exceeded the %ld limit\n", LoopLimit);

             break;
        }

        if (ScanLevel < SCANHEAP) {

            return FALSE;
        }

        GetFieldValue(Next, "ntdll!_HEAP_VIRTUAL_ALLOC_ENTRY", "CommitSize", VBlockSize);

        (*HeapCallback)( CONTEXT_VIRTUAL_BLOCK,
                         HeapAddress,
                         0,
                         Next,
                         VBlockSize
                         );

        if (!ReadPointer(Next, &Next)) {

            (*HeapCallback)( CONTEXT_ERROR,
                             HeapAddress,
                             0,
                             Next,
                             (ULONG64)(&"Unable to read virtual block\n")
                             );
            break;
        }
    }

    if (!(*HeapCallback)( CONTEXT_END_BLOCKS,
                          HeapAddress,
                          0,
                          0,
                          0
                     )) {

        return FALSE;
    }

//    dprintf("Scanning lookasides\n");


    if (LookasideAddress) {
        ULONG LookasideSize;
        PVOID Lookaside;
        ULONG HeapEntrySize;

        HeapEntrySize = GetTypeSize("ntdll!_HEAP_ENTRY");
        LookasideSize = GetTypeSize("ntdll!_HEAP_LOOKASIDE");

        for (i = 0; i < HEAP_MAXIMUM_FREELISTS; i++) {

            if (ScanLevel < SCANHEAP) {

                return FALSE;
            }

            GetFieldValue(LookasideAddress, "ntdll!_HEAP_LOOKASIDE", "ListHead.Next", Next);

            if (Is64BitArchitecture) {

                Next <<= 3;
            }

            LoopCount = 0;

            while (Next) {

                if (++LoopCount >= LoopLimit) {

                     dprintf("Walking the lookaside block list index %ld exceeded the %ld limit\n", i, LoopLimit);

                     break;
                }

                (*HeapCallback)( CONTEXT_LOOKASIDE_BLOCK,
                                 HeapAddress,
                                 0,
                                 Next - HeapEntrySize,
                                 i*HeapEntrySize
                                 );

                if (!ReadPointer(Next, &Next)) {

                    (*HeapCallback)( CONTEXT_ERROR,
                                     HeapAddress,
                                     0,
                                     Next,
                                     (ULONG64)(&"Unable to read lookaside block\n")
                                     );
                    break;
                }
            }

            LookasideAddress += LookasideSize;
        }
    }

    if (LFHAddress) {
        (*HeapCallback)( CONTEXT_LFH_HEAP,
                         HeapAddress,
                         LFHAddress,
                         0,
                         0
                         );
    }

    (*HeapCallback)( CONTEXT_END_HEAP,
                     HeapAddress,
                     0,
                     0,
                     0
                   );

    return TRUE;
}


void
ScanProcessHeaps(
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb,
    HEAP_ITERATOR_CALLBACK HeapCallback
    )
{
    ULONG NumberOfHeaps;
    ULONG64 pHeapsList;
    ULONG64 * Heaps;
    ULONG PtrSize;
    ULONG HeapNumber;

    if (AddressToDump) {

        ReadHeapData ( AddressToDump, HeapCallback);
        return;
    }

    if (!(*HeapCallback)( CONTEXT_START_GLOBALS,
                          0,
                          0,
                          0,
                          ProcessPeb
                     )) {

        return;
    }

    ScanLevel = SCANPROCESS;

    GetFieldValue(ProcessPeb, "ntdll!_PEB", "NumberOfHeaps", NumberOfHeaps);
    GetFieldValue(ProcessPeb, "ntdll!_PEB", "ProcessHeaps", pHeapsList);

    if (NumberOfHeaps == 0) {

        dprintf( "No heaps to display.\n" );

        return;
    }

    if (!pHeapsList) {

        dprintf( "Unable to get address of ProcessHeaps array\n" );
        return;

    }

    Heaps = malloc( NumberOfHeaps * sizeof(ULONG64) );

    if (!Heaps) {

        dprintf( "Unable to allocate memory to hold ProcessHeaps array\n" );

        return;
    }

    PtrSize = IsPtr64() ? 8 : 4;

    for (HeapNumber=0; HeapNumber<NumberOfHeaps ; HeapNumber++) {

        if (!ReadPointer( pHeapsList + HeapNumber*PtrSize,
                     &Heaps[HeapNumber] ) ) {

            dprintf( "%08p: Unable to read ProcessHeaps array\n", pHeapsList );

            free(Heaps);
            return;
        }
    }

    for ( HeapNumber = 0; HeapNumber < NumberOfHeaps; HeapNumber++ ) {

        if (ScanLevel < SCANPROCESS) {

            free(Heaps);
            return;
        }

        if ((AddressToDump == 0)
                ||
            (AddressToDump == Heaps[HeapNumber])) {

            ReadHeapData ( Heaps[HeapNumber], HeapCallback);
        }
    }

    free(Heaps);
}

//
//  Allocation routines
//

HANDLE TempHeap;

#define AllocateBlock(Size) HeapAlloc(TempHeap, 0, Size)
#define FreeBlock(P) HeapFree(TempHeap, 0, P)

//
//  Leak detector code
//

typedef enum _USAGE_TYPE {

    UsageUnknown,
    UsageModule,
    UsageHeap,
    UsageOther

} USAGE_TYPE;

typedef struct _HEAP_BLOCK {

    LIST_ENTRY   Entry;
    ULONG64 BlockAddress;
    ULONG64 Size;
    LONG    Count;
} HEAP_BLOCK, *PHEAP_BLOCK;

typedef struct _BLOCK_DESCR {
    USAGE_TYPE Type;
    ULONG64 Heap;
    LONG Count;
    HEAP_BLOCK Blocks[1];
}BLOCK_DESCR, *PBLOCK_DESCR;

typedef struct _MEMORY_MAP {

    ULONG64 Granularity;
    ULONG64 Offset;
    ULONG64 MaxAddress;

    CHAR FlagsBitmap[256 / 8];

    union{

        struct _MEMORY_MAP * Details[ 256 ];
        PBLOCK_DESCR Usage[ 256 ];
    };

    struct _MEMORY_MAP * Parent;

} MEMORY_MAP, *PMEMORY_MAP;

MEMORY_MAP ProcessMemory;
ULONG LeaksCount = 0;
ULONG64 PreviousPage = 0;
ULONG64 CrtPage = 0;
LONG NumBlocks = 0;
PHEAP_BLOCK TempBlocks;
ULONG64 LastHeapAddress = 0;
ULONG64 RtlpPreviousStartAddress = 0;

LIST_ENTRY HeapBusyList;
LIST_ENTRY HeapLeakList;


void InitializeMap(PMEMORY_MAP MemMap, PMEMORY_MAP Parent)
{
    memset(MemMap, 0, sizeof(*MemMap));
    MemMap->Parent = Parent;
    if (Parent) {
        MemMap->Granularity = Parent->Granularity / 256;
    }
}


void
SetBlockInfo(PMEMORY_MAP MemMap, ULONG64 Base, ULONG64 Size, PBLOCK_DESCR BlockDescr)
{
    ULONG64 Start, End;
    ULONG64 i;

    if (((Base + Size - 1) < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return;
    }

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }

    End = (Base - MemMap->Offset + Size - 1) / MemMap->Granularity;

    if (End > 255) {

        End = 255;
    }

    for (i = Start; i <= End; i++) {

        if (MemMap->Granularity == PageSize) {

            if (BlockDescr) {
                if (MemMap->Usage[i] != NULL) {
                    if (MemMap->Usage[i] != BlockDescr) {

                        dprintf("Error\n");
                    }
                }

                MemMap->Usage[i] = BlockDescr;
            } else {

                MemMap->FlagsBitmap[i / 8] |= 1 << (i % 8);
            }

        } else {

            if (!MemMap->Details[i]) {

                MemMap->Details[i] = AllocateBlock(sizeof(*MemMap));

                if (!MemMap->Details[i]) {
                    dprintf("Error allocate\n");
                    return;
                }
                
                InitializeMap(MemMap->Details[i], MemMap);
                MemMap->Details[i]->Offset = MemMap->Offset + MemMap->Granularity * i;
                MemMap->Details[i]->MaxAddress = MemMap->Offset + MemMap->Granularity * (i+1) - 1;
            }

            SetBlockInfo(MemMap->Details[i], Base, Size, BlockDescr);
        }
    }
}

PBLOCK_DESCR
GetBlockInfo(PMEMORY_MAP MemMap, ULONG64 Base)
{
    ULONG64 Start;
    PBLOCK_DESCR BlockDescr = NULL;

    if ((Base < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return NULL;
    }

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }

    if (MemMap->Granularity == PageSize) {

        return MemMap->Usage[Start];

    } else {

        if (MemMap->Details[Start]) {

            return GetBlockInfo(MemMap->Details[Start], Base);
        }
    }

    return NULL;
}

BOOLEAN
GetFlag(PMEMORY_MAP MemMap, ULONG64 Base)
{
    ULONG64 Start;
    PBLOCK_DESCR BlockDescr = NULL;
/*
    dprintf("GetFlag %p %p %p\n",
            MemMap->Offset,
            MemMap->MaxAddress,
            MemMap->Granularity
            );
*/
    if ((Base < MemMap->Offset) ||
        (Base > MemMap->MaxAddress)
        ) {

        return FALSE;
    }

    if (Base > MemMap->Offset) {
        Start = (Base - MemMap->Offset) / MemMap->Granularity;
    } else {
        Start = 0;
    }

    if (MemMap->Granularity == PageSize) {

        ULONG Flag = (MemMap->FlagsBitmap[Start / 8] & (1 << (Start % 8))) != 0;

        return (MemMap->FlagsBitmap[Start / 8] & (1 << (Start % 8))) != 0;

    } else {

        if (MemMap->Details[Start]) {

            return GetFlag(MemMap->Details[Start], Base);
        }
    }

    return FALSE;
}

void InitializeSystem()
{
    ULONG64 AddressRange = PageSize;
    ULONG64 PreviousAddressRange = PageSize;

    InitializeMap(&ProcessMemory, NULL);

    InitializeListHead( &HeapBusyList );
    InitializeListHead( &HeapLeakList );


    while (TRUE) {

        AddressRange = AddressRange * 256;

        if ((AddressRange < PreviousAddressRange)
                ||
            (AddressRange > HeapLargestAddress)
            ) {

            ProcessMemory.MaxAddress = HeapLargestAddress;

            ProcessMemory.Granularity = PreviousAddressRange;

            break;
        }

        PreviousAddressRange = AddressRange;
    }

    TempBlocks = AllocateBlock(PageSize);

    if (TempBlocks == NULL) {

        dprintf("Cannot allocate temp buffer\n");
    }
}

BOOLEAN
PushPageDescriptor(ULONG64 Page, ULONG64 NumPages)
{
    PBLOCK_DESCR PBlockDescr;
    PBLOCK_DESCR PreviousDescr;
    LONG i;

    PreviousDescr = GetBlockInfo(&ProcessMemory, Page * PageSize);

    if (PreviousDescr) {

        dprintf("Conflicting descriptors %08lx\n", PreviousDescr);

        return FALSE;
    }

    PBlockDescr = (PBLOCK_DESCR)AllocateBlock(sizeof(BLOCK_DESCR) + (NumBlocks - 1) * sizeof(HEAP_BLOCK));

    if (!PBlockDescr) {

        dprintf("Unable to allocate page descriptor\n");

        return FALSE;
    }
    PBlockDescr->Type = UsageHeap;
    PBlockDescr->Count = NumBlocks;
    PBlockDescr->Heap = LastHeapAddress;

    memcpy(PBlockDescr->Blocks, TempBlocks, NumBlocks * sizeof(HEAP_BLOCK));

    for (i = 0; i < NumBlocks; i++) {

        InitializeListHead( &PBlockDescr->Blocks[i].Entry );

        if (PBlockDescr->Blocks[i].BlockAddress != RtlpPreviousStartAddress) {

            InsertTailList(&HeapLeakList, &PBlockDescr->Blocks[i].Entry);

            PBlockDescr->Blocks[i].Count = 0;

            RtlpPreviousStartAddress = PBlockDescr->Blocks[i].BlockAddress;
        }
    }

    SetBlockInfo(&ProcessMemory, Page * PageSize, NumPages * PageSize, PBlockDescr);

    return TRUE;
}

BOOLEAN RegisterHeapBlocks(
    IN ULONG Context,
    IN ULONG64 HeapAddress,
    IN ULONG64 SegmentAddress,
    IN ULONG64 EntryAddress,
    IN ULONG64 Data
    )
{
    if (Context == CONTEXT_START_HEAP) {

        dprintf("Heap %p\n", HeapAddress);

        LastHeapAddress = HeapAddress;

        return TRUE;
    }

    if (Context == CONTEXT_START_SEGMENT) {

        ULONG64 NumberOfPages;
        ULONG64 SegmentBaseAddress;

        GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "NumberOfPages", NumberOfPages);
        GetFieldValue(SegmentAddress, "ntdll!_HEAP_SEGMENT", "BaseAddress", SegmentBaseAddress);

        SetBlockInfo(&ProcessMemory, SegmentBaseAddress, NumberOfPages * PageSize, NULL);

        return TRUE;
    }

    if (Context == CONTEXT_ERROR) {

        dprintf("HEAP %p (Seg %p) At %p Error: %s\n",
               HeapAddress,
               SegmentAddress,
               EntryAddress,
               Data
               );

        return TRUE;
    }

    if (Context == CONTEXT_END_BLOCKS) {
        if (PreviousPage) {

            PushPageDescriptor(PreviousPage, 1);
        }

        PreviousPage = 0;
        NumBlocks = 0;

    } else if (Context == CONTEXT_BUSY_BLOCK) {

        ULONG EntrySize;
        ULONG64 EndPage;

        EntrySize = (ULONG)Data;

        EndPage = (EntryAddress + (EntrySize - 1)) / PageSize;

        if (!GetFlag(&ProcessMemory, EntryAddress)) {

            dprintf("CONTEXT_BUSY_BLOCK %p address isn't from the heap\n", EntryAddress);
        }

        CrtPage = (EntryAddress) / PageSize;

        if (CrtPage != PreviousPage) {

            if (PreviousPage) {

                PushPageDescriptor(PreviousPage, 1);
            }

            PreviousPage = CrtPage;
            NumBlocks = 0;
        }

        TempBlocks[NumBlocks].BlockAddress = EntryAddress;
        TempBlocks[NumBlocks].Count = 0;
        TempBlocks[NumBlocks].Size = EntrySize;

        NumBlocks++;

        if (EndPage != CrtPage) {

            PushPageDescriptor(CrtPage, 1);

            NumBlocks = 0;

            TempBlocks[NumBlocks].BlockAddress = (ULONG_PTR)EntryAddress;
            TempBlocks[NumBlocks].Count = 0;
            TempBlocks[NumBlocks].Size = EntrySize;

            NumBlocks = 1;

            if (EndPage - CrtPage > 1) {

                PushPageDescriptor(CrtPage + 1, EndPage - CrtPage - 1);
            }

            PreviousPage = EndPage;
        }
    } else if (Context == CONTEXT_VIRTUAL_BLOCK) {

        ULONG64 EndPage;

        EndPage = (EntryAddress + Data - 1) / PageSize;

        CrtPage = (EntryAddress) / PageSize;

        if (CrtPage != PreviousPage) {

            if (PreviousPage) {

                PushPageDescriptor(PreviousPage, 1);
            }

            PreviousPage = CrtPage;
            NumBlocks = 0;
        } else {
            dprintf("Error in large block address\n");
        }

        TempBlocks[NumBlocks].BlockAddress = EntryAddress;
        TempBlocks[NumBlocks].Count = 0;
        TempBlocks[NumBlocks].Size = Data * HeapEntrySize;

        NumBlocks++;

        PushPageDescriptor(CrtPage, EndPage - CrtPage + 1);

        PreviousPage = 0;

    } else if ( Context == CONTEXT_LOOKASIDE_BLOCK ) {

        PBLOCK_DESCR PBlockDescr;
        LONG i;


        if (!GetFlag(&ProcessMemory, EntryAddress)) {

            dprintf("CONTEXT_LOOKASIDE_BLOCK %p address isn't from the heap\n", EntryAddress);
        }

        PBlockDescr = GetBlockInfo(&ProcessMemory, EntryAddress);

        if (!PBlockDescr) {

            dprintf("Error finding block from lookaside %p\n", EntryAddress);

            return FALSE;
        }

        for (i = 0; i < PBlockDescr->Count; i++) {

            if ((PBlockDescr->Blocks[i].BlockAddress <= (ULONG_PTR)EntryAddress) &&
                (PBlockDescr->Blocks[i].BlockAddress + PBlockDescr->Blocks[i].Size > (ULONG_PTR)EntryAddress)) {

                PBlockDescr->Blocks[i].Count = -10000;
                RemoveEntryList(&PBlockDescr->Blocks[i].Entry);

                return TRUE;
            }
        }

        dprintf("Error, block %p from lookaside not found in allocated block list\n", EntryAddress);
    }

    return TRUE;
}

PHEAP_BLOCK
GetHeapBlock(ULONG64 Address)
{
    PBLOCK_DESCR PBlockDescr;
    LONG i;

    PBlockDescr = GetBlockInfo(&ProcessMemory, Address);

    if (PBlockDescr) {
        for (i = 0; i < PBlockDescr->Count; i++) {

            if ((PBlockDescr->Blocks[i].BlockAddress <= Address) &&
                (PBlockDescr->Blocks[i].BlockAddress + PBlockDescr->Blocks[i].Size > Address)) {

                if (PBlockDescr->Blocks[i].BlockAddress != Address) {

                    return GetHeapBlock(PBlockDescr->Blocks[i].BlockAddress);
                }

                return &(PBlockDescr->Blocks[i]);
            }
        }
    }

    return NULL;
}

BOOLEAN
ScanHeapAllocBlocks()
{

    PLIST_ENTRY Next;

    Next = HeapBusyList.Flink;

    while (Next != &HeapBusyList) {

        PHEAP_BLOCK Block = CONTAINING_RECORD(Next, HEAP_BLOCK, Entry);

        PULONG_PTR CrtAddress = (PULONG_PTR)(Block->BlockAddress + HeapEntrySize);

        Next = Next->Flink;

        while ((ULONG_PTR)CrtAddress < Block->BlockAddress + Block->Size) {

            ULONG_PTR Pointer;

            if (ReadMemory( (ULONG64)(CrtAddress),
                             &Pointer,
                             sizeof(Pointer),
                             NULL
                           )) {

                PHEAP_BLOCK pBlock = GetHeapBlock( Pointer );

                if (pBlock) {

                    //
                    //  We found a block. we increment then the reference count
                    //

                    if (pBlock->Count == 0) {

                        RemoveEntryList(&pBlock->Entry);
                        InsertTailList(&HeapBusyList, &pBlock->Entry);
                    }

                    pBlock->Count += 1;
                }
            }

            //
            //  Go to the next possible pointer
            //

            CrtAddress++;
        }
    }

    Next = HeapLeakList.Flink;

    while (Next != &HeapLeakList) {

        PHEAP_BLOCK Block = CONTAINING_RECORD(Next, HEAP_BLOCK, Entry);
        PBLOCK_DESCR PBlockDescr = GetBlockInfo( &ProcessMemory, Block->BlockAddress );
        PULONG_PTR CrtAddress = (PULONG_PTR)(Block->BlockAddress + HeapEntrySize);

        //
        //  First time we need to display the header
        //

        if (LeaksCount == 0) {

            dprintf("\n");
            DumpEntryHeader();
        }

        //
        //  Display the information for this block
        //

        DumpEntryInfo(PBlockDescr->Heap, 0, Block->BlockAddress);

        LeaksCount += 1;

        //
        //  Go to the next item from the leak list
        //

        Next = Next->Flink;
    }

    return TRUE;
}

BOOLEAN
ScanProcessVM (
    HANDLE hProcess
    )
{
    NTSTATUS Status;
    SIZE_T BufferLen;
    ULONG_PTR lpAddress = 0;
    MEMORY_BASIC_INFORMATION Buffer;
    PVOID MemoryBuffer;

    if ( hProcess ) {

        PROCESS_BASIC_INFORMATION BasicInfo;

        dprintf("Scanning VM ...");

        Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessBasicInformation,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    NULL
                    );

//        dprintf("PEB %p\n", BasicInfo.PebBaseAddress);

        MemoryBuffer = AllocateBlock(PageSize);

        if (!MemoryBuffer) {

            return FALSE;
        }

        BufferLen = sizeof(Buffer);

        while (BufferLen) {

            BufferLen = VirtualQueryEx( hProcess,
                                        (LPVOID)lpAddress,
                                        &Buffer,
                                        sizeof(Buffer)
                                      );

            if (BufferLen) {

                if (( Buffer.AllocationProtect &
                      (PAGE_READWRITE | PAGE_EXECUTE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY))
                    ) {

                    ULONG64 NumPages;
                    ULONG i, j;

                    NumPages = Buffer.RegionSize / PageSize;

                    for (i = 0; i < NumPages; i++) {

                        if (ReadMemory( (ULONG64)(lpAddress + i * PageSize),
                                        MemoryBuffer,
                                        PageSize,
                                        NULL )
                                &&
                            !GetFlag(&ProcessMemory, lpAddress)
                            ) {

                            ULONG_PTR * Pointers = (ULONG_PTR *)MemoryBuffer;

                            for (j = 0; j < PageSize/sizeof(ULONG_PTR); j++) {

                                ULONG_PTR Address = lpAddress + i * PageSize + j * sizeof(ULONG_PTR);

                                PHEAP_BLOCK pBlock = GetHeapBlock(*Pointers);

                                if (pBlock) {

                                    if (pBlock->Count == 0) {

                                        RemoveEntryList(&pBlock->Entry);
                                        InsertTailList(&HeapBusyList, &pBlock->Entry);
                                    }

                                    pBlock->Count += 1;
                                }

                                Pointers += 1;
                            }
                        }

                        if (CheckControlC()) {
                            FreeBlock(MemoryBuffer);
                            ScanLevel = 0;

                            return FALSE;
                        }
                    }
                }

                lpAddress += Buffer.RegionSize;
            }
        }

        //
        //  First scan will mark all used blocks
        //

        ScanHeapAllocBlocks();

        FreeBlock(MemoryBuffer);
    }

    return TRUE;
}


void InspectLeaks(
    IN ULONG64 AddressToDump,
    IN ULONG64 ProcessPeb
    )
{
    HANDLE hProcess;

    LeaksCount = 0;

    InitializeSystem();

    if (TempBlocks) {
        ScanProcessHeaps( 0,
                          ProcessPeb,
                          RegisterHeapBlocks
                          );

        GetCurrentProcessHandle( &hProcess );

        if (hProcess){

            ScanProcessVM(hProcess);

            if (LeaksCount) {

                dprintf("%ld leaks detected.\n", LeaksCount);

            } else {

                dprintf( "No leaks detected.\n");
            }

        } else {

            dprintf("Unable to get the process handle\n");
        }
    }
}

VOID
HeapDetectLeaks()
{
    ULONG64 Process;
    ULONG64 ThePeb;
    ULONG64 PageHeapAddress;
    BOOLEAN PageHeapEnabled = FALSE;
    ULONG PageHeapFlags = 0;

    if (!InitializeHeapExtension()) {

        return;
    }

    //
    // Return immediately if full page heap is enabled
    //

    PageHeapAddress = GetExpression ("ntdll!RtlpDebugPageHeap");

    ReadMemory (PageHeapAddress, 
                &PageHeapEnabled, 
                sizeof (BOOLEAN), 
                NULL);

    PageHeapAddress = GetExpression ("ntdll!RtlpDphGlobalFlags");

    ReadMemory (PageHeapAddress, 
                &PageHeapFlags, 
                sizeof (ULONG), 
                NULL);

    if (PageHeapEnabled == TRUE && (PageHeapFlags & 0x01)) {
        dprintf ("!heap -l does not work if full page heap is enabled for the process \n");
        return;
    }


    GetPebAddress( 0, &ThePeb);

    TempHeap = HeapCreate(HEAP_NO_SERIALIZE | HEAP_GROWABLE, 0, 0);
    if (!TempHeap) {

        dprintf("Unable to create temporary heap\n");
        return;
    }

    InspectLeaks( 0, ThePeb);
    HeapDestroy(TempHeap);

    TempHeap = NULL;
}

BOOLEAN
InitializeHeapExtension()
{
    PointerSize = IsPtr64() ? 8 : 4;
    HeapEntrySize = GetTypeSize("ntdll!_HEAP_ENTRY");

    if ((HeapEntrySize == 0)
            ||
        (PointerSize == 0)) {

        dprintf("Invalid type information\n");

        return FALSE;
    }

    //
    //  Issue adrmarin 04/28/00: The page size should be available in the new interface
    //  IDebugControl::GetPageSize
    //

    if (PointerSize == 4) {

        PageSize = 0x1000;
        HeapLargestAddress = (ULONG)-1;
        Is64BitArchitecture = FALSE;

    } else {

        PageSize = 0x2000;
        HeapLargestAddress = (ULONGLONG)-1;
        Is64BitArchitecture = TRUE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\kuser.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kuser.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
KUserExtension(
    PCSTR lpArgumentString,
    ULONG64 SharedData
    );


DECLARE_API( kuser )

/*++

Routine Description:

    This function is called as an NTSD extension to dump the shared user mode
    page (KUSER_SHARED_DATA)

    Called as:

        !kuser

Arguments:

    None

Return Value:

    None

--*/

{
    INIT_API();
    KUserExtension( args, (ULONG64) MM_SHARED_USER_DATA_VA); // SharedUserData );
    EXIT_API();
    return S_OK;

}

char *DriveTypes[] = {
    "DOSDEVICE_DRIVE_UNKNOWN",
    "DOSDEVICE_DRIVE_CALCULATE",
    "DOSDEVICE_DRIVE_REMOVABLE",
    "DOSDEVICE_DRIVE_FIXED",
    "DOSDEVICE_DRIVE_REMOTE",
    "DOSDEVICE_DRIVE_CDROM",
    "DOSDEVICE_DRIVE_RAMDISK"
};


VOID
KUserExtension(
    PCSTR lpArgumentString,
    ULONG64 SharedData
    )
{
    BOOLEAN fFirst;
    ULONG i;

    try {
        InitTypeRead(SharedData, KUSER_SHARED_DATA);
        dprintf( "KUSER_SHARED_DATA at %p\n", SharedData ),
        dprintf( "TickCount:    %x * %08x\n",
                 (ULONG)ReadField(TickCountMultiplier),
                 (ULONG)ReadField(TickCountLow)
               );


#if 0
        dprintf( "Interrupt Time: %x:%08x:%08x\n",
                 (ULONG)ReadField(InterruptTime.High2Time),
                 (ULONG)ReadField(InterruptTime.High1Time),
                 (ULONG)ReadField(InterruptTime.LowPart)
               );
        dprintf( "System Time: %x:%08x:%08x\n",
                 (ULONG)ReadField(SystemTime.High2Time),
                 (ULONG)ReadField(SystemTime.High1Time),
                 (ULONG)ReadField(SystemTime.LowPart)
               );
        dprintf( "TimeZone Bias: %x:%08x:%08x\n",
                 (ULONG)ReadField(TimeZoneBias.High2Time),
                 (ULONG)ReadField(TimeZoneBias.High1Time),
                 (ULONG)ReadField(TimeZoneBias.LowPart)
               );
#endif
        dprintf( "TimeZone Id: %x\n", (ULONG)ReadField(TimeZoneId) );

        dprintf( "ImageNumber Range: [%x .. %x]\n",
                 (ULONG)ReadField(ImageNumberLow),
                 (ULONG)ReadField(ImageNumberHigh)
               );
        dprintf( "Crypto Exponent: %x\n", (ULONG)ReadField(CryptoExponent) );

        dprintf( "SystemRoot: '%ws'\n",
                 (ULONG)ReadField(NtSystemRoot)
               );


#if 0
        dprintf( "DosDeviceMap: %08x", (ULONG)ReadField(DosDeviceMap) );
        fFirst = TRUE;
        for (i=0; i<32; i++) {
            if ((ULONG)ReadField(DosDeviceMap) & (1 << i)) {
                if (fFirst) {
                    dprintf( " (" );
                    fFirst = FALSE;
                    }
                else {
                    dprintf( " " );
                    }
                dprintf( "%c:", 'A'+i );
                }
            }
        if (!fFirst) {
            dprintf( ")" );
            }
        dprintf( "\n" );

        for (i=0; i<32; i++) {
            CHAR Field[40];
            ULONG DosDeviceDriveType;

            sprintf(Field, "DosDeviceDriveType[%d]", i);

            DosDeviceDriveType  = (ULONG) GetShortField(0, Field, 0);
            if (DosDeviceDriveType > DOSDEVICE_DRIVE_UNKNOWN &&
                DosDeviceDriveType <= DOSDEVICE_DRIVE_RAMDISK
               ) {
                dprintf( "DriveType[ %02i ] (%c:) == %s\n",
                         i, 'A'+i,
                         DriveTypes[ DosDeviceDriveType ]
                       );
                }
            }
#endif

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


#define PAGE_ALIGN64(Va) ((ULONG64)((Va) & ~((ULONG64) ((LONG64) (LONG) PageSize - 1))))

extern ULONG PageSize;

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;

//-----------------------------------------------------------------------------------------
//
//  prototypes for internal non-exported support functions
//
//-----------------------------------------------------------------------------------------

/////////////////////////////////////////////
//
//  Util.c
//
/////////////////////////////////////////////

typedef VOID
(*PDUMP_SPLAY_NODE_FN)(
    ULONG64 RemoteAddress,
    ULONG   Level
    );

ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    );

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    );

ULONG
GetBitFieldOffset (
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   );

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    );

VOID
DumpUnicode(
    UNICODE_STRING u
    );

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    );


ULONG64
GetPointerValue (
    PCHAR String
    );

BOOLEAN
IsHexNumber(
   const char *szExpression
   );

BOOLEAN
IsDecNumber(
   const char *szExpression
   );

VOID DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\psr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ia64 psr

Abstract:

    KD Extension Api

Author:

    Thierry Fevrier (v-thief)

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

typedef struct _EM_PSR {
   unsigned __int64 reserved0:1;  //     0 : reserved
   unsigned __int64 be:1;         //     1 : Big-Endian
   unsigned __int64 up:1;         //     2 : User Performance monitor enable
   unsigned __int64 ac:1;         //     3 : Alignment Check
   unsigned __int64 mfl:1;        //     4 : Lower (f2  ..  f31) floating-point registers written
   unsigned __int64 mfh:1;        //     5 : Upper (f32 .. f127) floating-point registers written
   unsigned __int64 reserved1:7;  //  6-12 : reserved
   unsigned __int64 ic:1;         //    13 : Interruption Collection
   unsigned __int64 i:1;          //    14 : Interrupt Bit
   unsigned __int64 pk:1;         //    15 : Protection Key enable
   unsigned __int64 reserved2:1;  //    16 : reserved
   unsigned __int64 dt:1;         //    17 : Data Address Translation
   unsigned __int64 dfl:1;        //    18 : Disabled Floating-point Low  register set
   unsigned __int64 dfh:1;        //    19 : Disabled Floating-point High register set
   unsigned __int64 sp:1;         //    20 : Secure Performance monitors
   unsigned __int64 pp:1;         //    21 : Privileged Performance monitor enable
   unsigned __int64 di:1;         //    22 : Disable Instruction set transition
   unsigned __int64 si:1;         //    23 : Secure Interval timer
   unsigned __int64 db:1;         //    24 : Debug Breakpoint fault
   unsigned __int64 lp:1;         //    25 : Lower Privilege transfer trap
   unsigned __int64 tb:1;         //    26 : Taken Branch trap
   unsigned __int64 rt:1;         //    27 : Register stack translation
   unsigned __int64 reserved3:4;  // 28-31 : reserved
   unsigned __int64 cpl:2;        // 32;33 : Current Privilege Level
   unsigned __int64 is:1;         //    34 : Instruction Set
   unsigned __int64 mc:1;         //    35 : Machine Abort Mask
   unsigned __int64 it:1;         //    36 : Instruction address Translation
   unsigned __int64 id:1;         //    37 : Instruction Debug fault disable
   unsigned __int64 da:1;         //    38 : Disable Data Access and Dirty-bit faults
   unsigned __int64 dd:1;         //    39 : Data Debug fault disable
   unsigned __int64 ss:1;         //    40 : Single Step enable
   unsigned __int64 ri:2;         // 41;42 : Restart Instruction
   unsigned __int64 ed:1;         //    43 : Exception Deferral
   unsigned __int64 bn:1;         //    44 : register Bank
   unsigned __int64 ia:1;         //    45 : Disable Instruction Access-bit faults 
   unsigned __int64 reserved4:18; // 46-63 : reserved
} EM_PSR, *PEM_PSR;

typedef EM_PSR   EM_IPSR;
typedef EM_IPSR *PEM_IPSR;
typedef unsigned __int64  EM_REG;
typedef EM_REG           *PEM_REG;
#define EM_REG_BITS       (sizeof(EM_REG) * 8)

// IA64 only

typedef enum _DISPLAY_MODE {
    DISPLAY_MIN     = 0,
    DISPLAY_DEFAULT = DISPLAY_MIN,
    DISPLAY_MED     = 1,
    DISPLAY_MAX     = 2,
    DISPLAY_FULL    = DISPLAY_MAX
} DISPLAY_MODE;


typedef struct _EM_REG_FIELD  {
   const    char   *SubName;
   const    char   *Name;
   unsigned long    Length;
   unsigned long    Shift;
} EM_REG_FIELD, *PEM_REG_FIELD;

//
// EmPsrFields: EM register fields for the Processor Status Register.
//

EM_REG_FIELD EmPsrFields[] = {
        { "rv",  "reserved0"   , 0x1, 0 },   // 0
        { "be",  "Big-Endian"  , 0x1, 1 },   // 1
        { "up",  "User Performance monitor enable", 0x1, 2 }, // 2
        { "ac",  "Alignment Check", 0x1, 3 }, // 3
        { "mfl", "Lower floating-point registers written", 0x1, 4 }, // 4
        { "mfh", "Upper floating-point registers written", 0x1, 5 }, // 5
        { "rv",  "reserved1",    0x7, 6 }, // 6-12
        { "ic",  "Interruption Collection", 0x1, 13 }, // 13
        { "i",   "Interrupt enable", 0x1, 14 }, // 14
        { "pk",  "Protection Key enable", 0x1, 15 }, // 15
        { "rv",  "reserved2", 0x1, 16 }, // 16
        { "dt",  "Data Address Translation enable", 0x1, 17 }, // 17
        { "dfl", "Disabled Floating-point Low  register set", 0x1, 18 }, // 18
        { "dfh", "Disabled Floating-point High register set", 0x1, 19 }, // 19
        { "sp",  "Secure Performance monitors", 0x1, 20 }, // 20
        { "pp",  "Privileged Performance monitor enable", 0x1, 21 }, // 21
        { "di",  "Disable Instruction set transition", 0x1, 22 }, // 22
        { "si",  "Secure Interval timer", 0x1, 23 }, // 23
        { "db",  "Debug Breakpoint fault enable", 0x1, 24 }, // 24
        { "lp",  "Lower Privilege transfer trap enable", 0x1, 25 }, // 25
        { "tb",  "Taken Branch trap enable", 0x1, 26 }, // 26
        { "rt",  "Register stack translation enable", 0x1, 27 }, // 27
        { "rv",  "reserved3", 0x4, 28 }, // 28-31
        { "cpl", "Current Privilege Level", 0x2, 32 }, // 32-33
        { "is",  "Instruction Set", 0x1, 34 }, // 34
        { "mc",  "Machine Abort Mask delivery disable", 0x1, 35 }, // 35
        { "it",  "Instruction address Translation enable", 0x1, 36 }, // 36
        { "id",  "Instruction Debug fault disable", 0x1, 37 }, // 37
        { "da",  "Disable Data Access and Dirty-bit faults", 0x1, 38 }, // 38
        { "dd",  "Data Debug fault disable", 0x1, 39 }, // 39
        { "ss",  "Single Step enable", 0x1, 40 }, // 40
        { "ri",  "Restart Instruction", 0x2, 41 }, // 41-42
        { "ed",  "Exception Deferral", 0x1, 43 }, // 43
        { "bn",  "register Bank", 0x1, 44 }, // 44
        { "ia",  "Disable Instruction Access-bit faults", 0x1, 45 }, // 45
        { "rv",  "reserved4", 0x12, 46 } // 46-63
};

VOID
DisplayFullEmRegField(
    ULONG64      EmRegValue,
    EM_REG_FIELD EmRegFields[],
    ULONG        Field
    )
{
   dprintf( "\n %3.3s : %I64x : %-s",  
            EmRegFields[Field].SubName,
            (EmRegValue >> EmRegFields[Field].Shift) & ((1 << EmRegFields[Field].Length) - 1),
            EmRegFields[Field].Name
          );
   return;
} // DisplayFullEmRegField()


VOID
DisplayFullEmReg(
    IN ULONG64      Val,
    IN EM_REG_FIELD EmRegFields[],
    IN DISPLAY_MODE DisplayMode
    )
{
    ULONG i, j;

    i = j = 0;
    if ( DisplayMode >= DISPLAY_MAX )   {
       while( j < EM_REG_BITS )   {
          DisplayFullEmRegField( Val, EmRegFields, i );
          j += EmRegFields[i].Length;
          i++;
       }
    }
    else  {
       while( j < EM_REG_BITS )   {
          if ( !strstr(EmRegFields[i].Name, "reserved" ) &&
               !strstr(EmRegFields[i].Name, "ignored"  ) ) {
             DisplayFullEmRegField( Val, EmRegFields, i );
          }
          j += EmRegFields[i].Length;
          i++;
       }
    }
    dprintf("\n");

    return;

} // DisplayFullEmReg()

VOID
DisplayPsrIA64( 
    IN const PCHAR         Header,
    IN       EM_PSR        EmPsr,
    IN       DISPLAY_MODE  DisplayMode
    )
{
    dprintf("%s", Header ? Header : "" );
    if ( DisplayMode >= DISPLAY_MED )   {
       DisplayFullEmReg( *((PULONG64) &EmPsr), EmPsrFields, DisplayMode );
    }
    else   {
       dprintf(
            "ia bn ed ri ss dd da id it mc is cpl rt tb lp db\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x  %1I64x   %1I64x  %1I64x  %1I64x  %1I64x\n\t\t"
            "si di pp sp dfh dfl dt pk i ic | mfh mfl ac up be\n\t\t "
            "%1I64x  %1I64x  %1I64x  %1I64x  %1I64x   %1I64x   %1I64x  %1I64x %1I64x  %1I64x |  %1I64x   %1I64x   %1I64x  %1I64x  %1I64x\n",
            EmPsr.ia,
            EmPsr.bn,
            EmPsr.ed,
            EmPsr.ri,
            EmPsr.ss,
            EmPsr.dd,
            EmPsr.da,
            EmPsr.id,
            EmPsr.it,
            EmPsr.mc,
            EmPsr.is,
            EmPsr.cpl,
            EmPsr.rt,
            EmPsr.tb,
            EmPsr.lp,
            EmPsr.db,
            EmPsr.si,
            EmPsr.di,
            EmPsr.pp,
            EmPsr.sp,
            EmPsr.dfh,
            EmPsr.dfl,
            EmPsr.dt,
            EmPsr.pk,
            EmPsr.i,
            EmPsr.ic,
            EmPsr.mfh,
            EmPsr.mfl,
            EmPsr.ac,
            EmPsr.up,
            EmPsr.be
            );
    }
    return;
} // DisplayPsrIA64()

DECLARE_API( psr )

/*++

Routine Description:

    Dumps an IA64 Processor Status Word

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/

{
    ULONG64     psrValue;
    ULONG       result;
    ULONG       flags = 0;

    char       *header;

    result = sscanf(args,"%X %lx", &psrValue, &flags);
    psrValue = GetExpression(args);

    if ((result != 1) && (result != 2)) {
        //
        // If user specified "@ipsr"...
        //
        char ipsrStr[16];

        result = sscanf(args, "%s %lx", ipsrStr, &flags);
        if ( ((result != 1) && (result != 2)) || strcmp(ipsrStr,"@ipsr") )   {
            dprintf("USAGE: !psr 0xValue [display_mode:0,1,2]\n");
            dprintf("USAGE: !psr @ipsr   [display_mode:0,1,2]\n");
            return E_INVALIDARG;
        }
        psrValue = GetExpression("@ipsr");
    }
    header = (flags > DISPLAY_MIN) ? NULL : "\tpsr:\t";

    if (TargetMachine != IMAGE_FILE_MACHINE_IA64)
    {
        dprintf("!psr not implemented for this architecture.\n");
    }
    else
    {
        DisplayPsrIA64( header, *((EM_PSR *) &psrValue), flags );
    }

    return S_OK;

} // !psr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\sddump.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    sddump.c

Abstract:

    Debugger Extension Api

Author:

    Baskar Kothandaraman (baskark) 26-Jan-1998

Environment:

    Kernel Mode

Revision History:

    Kshitiz K. Sharma (kksharma)

    Using debugger type info : SID and ACL have exactly same type definitions on
    all platforms - No change.

--*/


#include "precomp.h"
#pragma hdrstop

/*
+-------------------------------------------------------------------+

    NAME:       sid_successfully_read

    FUNCTION:   Tries to read in a SID from the specified address.
                It first reads in the minimal structure, then
                allocates a buffer big enough to hold the whole sid
                & reads in the whole SID....

    ARGS:       Address     --  Address from which to read it from
                sid_buffer  --  variable to receive the ptr to the
                                allocated buffer with the SID.

    RETURN:     TRUE on success, FALSE otherwise.

    NOTE***:    The caller has to call free(*sid_buffer) to free
                up the memory upon a successful call to this
                function.

+-------------------------------------------------------------------+
*/

BOOLEAN sid_successfully_read(
    ULONG64            Address,
    PSID               *sid_buffer
    )
{
    ULONG           result;
    SID             minimum; /* minimum we need to read to get the details */


    *sid_buffer = NULL;

    if ( !ReadMemory( Address,
                      &minimum,
                      sizeof(minimum),
                      &result) )
    {
        dprintf("%08p: Unable to get MIN SID header\n", Address);
        return FALSE;
    }

    /* Now of read-in any extra sub-authorities necessary */

    if (minimum.SubAuthorityCount > SID_MAX_SUB_AUTHORITIES)
    {
        dprintf("SID has an invalid sub-authority_count, 0x%x\n", minimum.SubAuthorityCount);
        return FALSE;
    }
    else
    {
        ULONG   size_to_read = RtlLengthRequiredSid(minimum.SubAuthorityCount);

        *sid_buffer = malloc(size_to_read);

        if (! *sid_buffer)
        {
            dprintf("SID: can't allocate memory to read\n");
            return FALSE;
        }

        if ( !ReadMemory( Address,
                          *sid_buffer,
                          size_to_read,
                          &result) )
        {
            dprintf("%08p: Unable to get The Whole SID\n", Address);
            free(*sid_buffer);
            *sid_buffer = NULL;
            return FALSE;
        }

        if (! RtlValidSid(*sid_buffer))
        {
            dprintf("%08p: SID pointed to by this address is invalid\n", Address);
            free(*sid_buffer);
            *sid_buffer = NULL;
            return FALSE;
        }

    }

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       acl_successfully_read

    FUNCTION:   Tries to read in a ACL from the specified address.
                It first reads in the minimal structure, then
                allocates a buffer big enough to hold the whole acl
                & reads in the whole ACL....

    ARGS:       Address     --  Address from which to read it from
                acl_buffer  --  variable to receive the ptr to the
                                allocated buffer with the ACL.

    RETURN:     TRUE on success, FALSE otherwise.

    NOTE***:    The caller has to call free(*acl_buffer) to free
                up the memory upon a successful call to this
                function.

+-------------------------------------------------------------------+
*/

BOOLEAN acl_successfully_read(
    ULONG64            Address,
    PACL               *acl_buffer
    )
{
    ULONG           result;
    ACL             minimum; /* minimum we need to read to get the details */


    *acl_buffer = NULL;

    if ( !ReadMemory( Address,
                      &minimum,
                      sizeof(minimum),
                      &result) )
    {
        dprintf("%08p: Unable to get MIN ACL header\n", Address);
        return FALSE;
    }

    *acl_buffer = malloc(minimum.AclSize);

    if (! *acl_buffer)
    {
        dprintf("ACL: can't allocate memory to read\n");
        return FALSE;
    }

    if ( !ReadMemory( Address,
                      *acl_buffer,
                      minimum.AclSize,
                      &result) )
    {
        dprintf("%08p: Unable to get The Whole ACL\n", Address);
        free(*acl_buffer);
        *acl_buffer = NULL;
        return FALSE;
    }

    if (! RtlValidAcl(*acl_buffer))
    {
        dprintf("%08p: ACL pointed to by this address is invalid\n", Address);
        free(*acl_buffer);
        *acl_buffer = NULL;
        return FALSE;
    }

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       DumpSID

    FUNCTION:   Prints out a SID, with the padding provided.

    ARGS:       pad         --  Padding to print before the SID.
                sid_to_dump --  Pointer to the SID to print.
                Flag        --  To control options.

    RETURN:     N/A

    NOTE***:    It right now, doesn't lookup the sid.
                In future, you might want ot use the Flag
                parameter to make that optional.

+-------------------------------------------------------------------+
*/


VOID    DumpSID(
    CHAR        *pad,
    PSID        sid_to_dump,
    ULONG       Flag
    )
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      us;

    if (sid_to_dump)
    {
        ntstatus = RtlConvertSidToUnicodeString(&us, sid_to_dump, TRUE);

        if (NT_SUCCESS(ntstatus))
        {
            dprintf("%s%wZ\n", pad, &us);
            RtlFreeUnicodeString(&us);
        }
        else
        {
            dprintf("0x%08lx: Can't Convert SID to UnicodeString\n", ntstatus);
        }
    }
    else
    {
        dprintf("%s is NULL\n", pad);
    }
}

/*
+-------------------------------------------------------------------+

    NAME:       DumpACL

    FUNCTION:   Prints out a ACL, with the padding provided.

    ARGS:       pad         --  Padding to print before the ACL.
                acl_to_dump --  Pointer to the ACL to print.
                Flag        --  To control options.
                Start       --  Actual start address of the Acl

    RETURN:     N/A

+-------------------------------------------------------------------+
*/

BOOL
DumpACL (
    IN  char     *pad,
    IN  ACL      *pacl,
    IN  ULONG    Flags,
    IN  ULONG64  Start
    )
{
    USHORT       x;

    if (pacl == NULL)
    {
        dprintf("%s is NULL\n", pad);
        return FALSE;
    }

    dprintf("%s\n", pad);
    dprintf("%s->AclRevision: 0x%x\n", pad, pacl->AclRevision);
    dprintf("%s->Sbz1       : 0x%x\n", pad, pacl->Sbz1);
    dprintf("%s->AclSize    : 0x%x\n", pad, pacl->AclSize);
    dprintf("%s->AceCount   : 0x%x\n", pad, pacl->AceCount);
    dprintf("%s->Sbz2       : 0x%x\n", pad, pacl->Sbz2);

    for (x = 0; x < pacl->AceCount; x ++)
    {
        PACE_HEADER     ace;
        CHAR        temp_pad[MAX_PATH];
        NTSTATUS    result;

        sprintf(temp_pad, "%s->Ace[%u]: ", pad, x);

        result = RtlGetAce(pacl, x, &ace);
        if (! NT_SUCCESS(result))
        {
            dprintf("%sCan't GetAce, 0x%08lx\n", temp_pad, result);
            return FALSE;
        }

        dprintf("%s->AceType: ", temp_pad);

#define BRANCH_AND_PRINT(x) case x: dprintf(#x "\n"); break

        switch (ace->AceType)
        {
            BRANCH_AND_PRINT(ACCESS_ALLOWED_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_COMPOUND_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_OBJECT_ACE_TYPE);

            BRANCH_AND_PRINT(ACCESS_ALLOWED_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_CALLBACK_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE);
            BRANCH_AND_PRINT(SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE);

            default:
                dprintf("0x%08lx <-- *** Unknown AceType\n", ace->AceType);
                continue; // With the next ace
        }

#undef BRANCH_AND_PRINT

        dprintf("%s->AceFlags: 0x%x\n", temp_pad, ace->AceFlags);

#define BRANCH_AND_PRINT(x) if (ace->AceFlags & x){ dprintf("%s            %s\n", temp_pad, #x); }

        BRANCH_AND_PRINT(OBJECT_INHERIT_ACE)
        BRANCH_AND_PRINT(CONTAINER_INHERIT_ACE)
        BRANCH_AND_PRINT(NO_PROPAGATE_INHERIT_ACE)
        BRANCH_AND_PRINT(INHERIT_ONLY_ACE)
        BRANCH_AND_PRINT(INHERITED_ACE)
        BRANCH_AND_PRINT(SUCCESSFUL_ACCESS_ACE_FLAG)
        BRANCH_AND_PRINT(FAILED_ACCESS_ACE_FLAG)

#undef BRANCH_AND_PRINT

        dprintf("%s->AceSize: 0x%x\n", temp_pad, ace->AceSize);

        /*
            From now on it is ace specific stuff.
            Fortunately ACEs can be split into 3 groups,
            with the ACE structure being the same within the group

            Added 8 more ace types for callback support.
        */

        switch (ace->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                {
                    CHAR        more_pad[MAX_PATH];
                    SYSTEM_AUDIT_ACE    *tace = (SYSTEM_AUDIT_ACE *) ace;

                    dprintf("%s->Mask : 0x%08lx\n", temp_pad, tace->Mask);

                    sprintf(more_pad, "%s->SID: ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);
                }
                break;

            case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:
            case ACCESS_DENIED_CALLBACK_ACE_TYPE:
            case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:
            case SYSTEM_ALARM_CALLBACK_ACE_TYPE:

                {
                    CHAR        more_pad[MAX_PATH];
                    SYSTEM_AUDIT_ACE    *tace = (SYSTEM_AUDIT_ACE *) ace;

                    dprintf("%s->Mask : 0x%08lx\n", temp_pad, tace->Mask);

                    sprintf(more_pad, "%s->SID: ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);
                    dprintf("%s->Address : %08p\n", temp_pad, Start + (ULONG) (((PUCHAR) ace) - ((PUCHAR) pacl)));
                }
                break;

            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    COMPOUND_ACCESS_ALLOWED_ACE     *tace = (COMPOUND_ACCESS_ALLOWED_ACE *) ace;
                    PBYTE                           ptr;

                    dprintf("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    dprintf("%s->CompoundAceType : 0x%08lx\n", temp_pad, tace->CompoundAceType);
                    dprintf("%s->Reserved        : 0x%08lx\n", temp_pad, tace->Reserved);

                    sprintf(more_pad, "%s->SID(1)          : ", temp_pad);
                    DumpSID(more_pad, &(tace->SidStart), Flags);

                    ptr = (PBYTE)&(tace->SidStart);
                    ptr += RtlLengthSid((PSID)ptr); /* Skip this & get to next sid */

                    sprintf(more_pad, "%s->SID(2)          : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                {
                    CHAR                            more_pad[MAX_PATH];
                    ACCESS_ALLOWED_OBJECT_ACE       *tace = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                    PBYTE                           ptr;
                    GUID                            *obj_guid = NULL, *inh_obj_guid = NULL;

                    dprintf("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                    dprintf("%s->Flags           : 0x%08lx\n", temp_pad, tace->Flags);

                    ptr = (PBYTE)&(tace->ObjectType);

                    if (tace->Flags & ACE_OBJECT_TYPE_PRESENT)
                    {
                        dprintf("%s                  : ACE_OBJECT_TYPE_PRESENT\n", temp_pad);
                        obj_guid = &(tace->ObjectType);
                        ptr = (PBYTE)&(tace->InheritedObjectType);
                    }

                    if (tace->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                    {
                        dprintf("%s                  : ACE_INHERITED_OBJECT_TYPE_PRESENT\n", temp_pad);
                        inh_obj_guid = &(tace->InheritedObjectType);
                        ptr = (PBYTE)&(tace->SidStart);
                    }

                    if (obj_guid)
                    {
                        dprintf("%s->ObjectType      : (in HEX)", temp_pad);
                        dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            obj_guid->Data1,
                            obj_guid->Data2,
                            obj_guid->Data3,
                            obj_guid->Data4[0],
                            obj_guid->Data4[1],
                            obj_guid->Data4[2],
                            obj_guid->Data4[3],
                            obj_guid->Data4[4],
                            obj_guid->Data4[5],
                            obj_guid->Data4[6],
                            obj_guid->Data4[7]
                            );
                    }

                    if (inh_obj_guid)
                    {
                        dprintf("%s->InhObjTYpe      : (in HEX)", temp_pad);
                        dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                            inh_obj_guid->Data1,
                            inh_obj_guid->Data2,
                            inh_obj_guid->Data3,
                            inh_obj_guid->Data4[0],
                            inh_obj_guid->Data4[1],
                            inh_obj_guid->Data4[2],
                            inh_obj_guid->Data4[3],
                            inh_obj_guid->Data4[4],
                            inh_obj_guid->Data4[5],
                            inh_obj_guid->Data4[6],
                            inh_obj_guid->Data4[7]
                            );
                    }

                    sprintf(more_pad, "%s->SID             : ", temp_pad);
                    DumpSID(more_pad, ptr, Flags);
                }
                break;

            case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE:
            {
                CHAR                            more_pad[MAX_PATH];
                ACCESS_ALLOWED_OBJECT_ACE       *tace = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                PBYTE                           ptr;
                GUID                            *obj_guid = NULL, *inh_obj_guid = NULL;

                dprintf("%s->Mask            : 0x%08lx\n", temp_pad, tace->Mask);
                dprintf("%s->Flags           : 0x%08lx\n", temp_pad, tace->Flags);

                ptr = (PBYTE)&(tace->ObjectType);

                if (tace->Flags & ACE_OBJECT_TYPE_PRESENT)
                {
                    dprintf("%s                  : ACE_OBJECT_TYPE_PRESENT\n", temp_pad);
                    obj_guid = &(tace->ObjectType);
                    ptr = (PBYTE)&(tace->InheritedObjectType);
                }

                if (tace->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    dprintf("%s                  : ACE_INHERITED_OBJECT_TYPE_PRESENT\n", temp_pad);
                    inh_obj_guid = &(tace->InheritedObjectType);
                    ptr = (PBYTE)&(tace->SidStart);
                }

                if (obj_guid)
                {
                    dprintf("%s->ObjectType      : (in HEX)", temp_pad);
                    dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                        obj_guid->Data1,
                        obj_guid->Data2,
                        obj_guid->Data3,
                        obj_guid->Data4[0],
                        obj_guid->Data4[1],
                        obj_guid->Data4[2],
                        obj_guid->Data4[3],
                        obj_guid->Data4[4],
                        obj_guid->Data4[5],
                        obj_guid->Data4[6],
                        obj_guid->Data4[7]
                        );
                }

                if (inh_obj_guid)
                {
                    dprintf("%s->InhObjTYpe      : (in HEX)", temp_pad);
                    dprintf("(%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x)\n",
                        inh_obj_guid->Data1,
                        inh_obj_guid->Data2,
                        inh_obj_guid->Data3,
                        inh_obj_guid->Data4[0],
                        inh_obj_guid->Data4[1],
                        inh_obj_guid->Data4[2],
                        inh_obj_guid->Data4[3],
                        inh_obj_guid->Data4[4],
                        inh_obj_guid->Data4[5],
                        inh_obj_guid->Data4[6],
                        inh_obj_guid->Data4[7]
                        );
                }

                sprintf(more_pad, "%s->SID             : ", temp_pad);
                DumpSID(more_pad, ptr, Flags);
                dprintf("%s->Address : %08p\n", temp_pad, Start + (ULONG) (((PUCHAR) ace) - ((PUCHAR) pacl)));
            }
            break;
        }
        dprintf("\n");
    }

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       DumpSD

    FUNCTION:   Prints out a Security Descriptor,
                with the padding provided.

    ARGS:       pad          --  Padding to print before the ACL.
                sd_to_dump   --  Pointer to the ACL to print.
                owner        --  Ptr to Owner SID
                group        --  Ptr to Group SID
                dacl         --  Ptr to DACL
                sacl         --  Ptr to SACL
                Flag         --  To control options.
                dacl_address --  Actual start address of the dacl
                sacl_address --  Actual start address of the sacl

    RETURN:     N/A

+-------------------------------------------------------------------+
*/

BOOL
DumpSD (
    IN  char     *pad,
    IN  ULONG64                 sd_to_dump,
    IN  PSID                    owner,
    IN  PSID                    group,
    IN  PACL                    dacl,
    IN  PACL                    sacl,
    IN  ULONG                   Flags,
    IN  ULONG64                 dacl_address,
    IN  ULONG64                 sacl_address
    )
{
    ULONG Control;

    InitTypeRead(sd_to_dump, SECURITY_DESCRIPTOR);
    Control = (ULONG) ReadField(Control);

#define CHECK_SD_CONTROL_FOR(x)\
    if (Control & x)\
    {\
        dprintf("%s            %s\n", pad, #x);\
    }\

    dprintf("%s->Revision: 0x%x\n", pad, (ULONG) ReadField(Revision));
    dprintf("%s->Sbz1    : 0x%x\n", pad, (ULONG) ReadField(Sbz1));
    dprintf("%s->Control : 0x%x\n", pad, (ULONG) ReadField(Control));

    CHECK_SD_CONTROL_FOR(SE_OWNER_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_GROUP_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_DACL_PRESENT)
    CHECK_SD_CONTROL_FOR(SE_DACL_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_SACL_PRESENT)
    CHECK_SD_CONTROL_FOR(SE_SACL_DEFAULTED)
    CHECK_SD_CONTROL_FOR(SE_DACL_UNTRUSTED)
    CHECK_SD_CONTROL_FOR(SE_SERVER_SECURITY)
    CHECK_SD_CONTROL_FOR(SE_DACL_AUTO_INHERIT_REQ)
    CHECK_SD_CONTROL_FOR(SE_SACL_AUTO_INHERIT_REQ)
    CHECK_SD_CONTROL_FOR(SE_DACL_AUTO_INHERITED)
    CHECK_SD_CONTROL_FOR(SE_SACL_AUTO_INHERITED)
    CHECK_SD_CONTROL_FOR(SE_DACL_PROTECTED)
    CHECK_SD_CONTROL_FOR(SE_SACL_PROTECTED)
    CHECK_SD_CONTROL_FOR(SE_SELF_RELATIVE)

    {
        CHAR        temp_pad[MAX_PATH];

        sprintf(temp_pad, "%s->Owner   : ", pad);

        DumpSID(temp_pad, owner, Flags);

        sprintf(temp_pad, "%s->Group   : ", pad);

        DumpSID(temp_pad, group, Flags);

        sprintf(temp_pad, "%s->Dacl    : ", pad);

        DumpACL(temp_pad, dacl, Flags, dacl_address);

        sprintf(temp_pad, "%s->Sacl    : ", pad);

        DumpACL(temp_pad, sacl, Flags, sacl_address);
    }

#undef CHECK_SD_CONTROL_FOR

    return TRUE;
}

/*
+-------------------------------------------------------------------+

    NAME:       sd

    FUNCTION:   Reads in & prints the security descriptor, from
                the address specified. !sd command's workhorse.

    ARGS:       Standard Debugger extensions, refer to DECLARE_API
                macro in the header files.

+-------------------------------------------------------------------+
*/



DECLARE_API( sd )
{
    ULONG64 Address;
    ULONG   Flags;
    ULONG   result;
    PACL                dacl = NULL, sacl = NULL;
    ULONG64     dacl_address;
    ULONG64     sacl_address;
//    SECURITY_DESCRIPTOR sd_to_dump;
    PSID                owner_sid = NULL, group_sid = NULL;
    ULONG   Control;

    Address = 0;
    Flags = 6;
    sscanf(args,"%lx %lx",&Address,&Flags);
    Address = GetExpression(args);

    if (Address == 0) {
        dprintf("usage: !sd <SecurityDescriptor-address>\n");
        goto CLEANUP;
    }

    if ( GetFieldValue( Address,
                        "SECURITY_DESCRIPTOR",
                        "Control",
                        Control) ) {
        dprintf("%08p: Unable to get SD contents\n", Address);
        goto CLEANUP;
    }

    if (Control & SE_SELF_RELATIVE)
    {
        ULONG dacl_offset, sacl_offset;

        InitTypeRead(Address, SECURITY_DESCRIPTOR_RELATIVE);

        dacl_offset = (ULONG) ReadField(Dacl);
        sacl_offset = (ULONG) ReadField(Sacl);

        if (!(Control & SE_OWNER_DEFAULTED)) /* read in the owner */
        {
            ULONG   owner_offset = (ULONG) ReadField(Owner);
            ULONG64 owner_address = Address + owner_offset;

            if (! sid_successfully_read(owner_address, & owner_sid))
            {
                dprintf("%08p: Unable to read in Owner in SD\n", owner_address);
                goto CLEANUP;
            }
        }

        if (!(Control & SE_GROUP_DEFAULTED)) /* read in the group */
        {
            ULONG group_offset = (ULONG) ReadField(Group);
            ULONG64 group_address = Address + group_offset;

            if (! sid_successfully_read(group_address, & group_sid))
            {
                dprintf("%08p: Unable to read in Group in SD\n", group_address);
                goto CLEANUP;
            }
        }

        if ((Control & SE_DACL_PRESENT) &&
            (dacl_offset != 0))
        {
            dacl_address = Address + dacl_offset;

            if (! acl_successfully_read(dacl_address, & dacl))
            {
                dprintf("%08p: Unable to read in Dacl in SD\n", dacl_address);
                goto CLEANUP;
            }
        }


        if ((Control & SE_SACL_PRESENT) &&
            (sacl_offset != 0))
        {
            sacl_address = Address + sacl_offset;

            if (! acl_successfully_read(sacl_address, & sacl))
            {
                dprintf("%08p: Unable to read in Sacl in SD\n", sacl_address);
                goto CLEANUP;
            }
        }
    }
    else
    {
        ULONG64 Dacl, Sacl;
        InitTypeRead(Address, SECURITY_DESCRIPTOR);

        Dacl = ReadField(Dacl);
        Sacl = ReadField(Sacl);

        if (!(Control & SE_OWNER_DEFAULTED)) /* read in the owner */
        {
            ULONG64      owner_address = ReadField(Owner);

            if (! sid_successfully_read(owner_address, & owner_sid))
            {
                dprintf("%08p: Unable to read in Owner in SD\n", owner_address);
                goto CLEANUP;
            }
        }

        if (!(Control & SE_GROUP_DEFAULTED)) /* read in the group */
        {
            ULONG64     group_address = ReadField(Group);

            if (! sid_successfully_read(group_address, & group_sid))
            {
                dprintf("%08p: Unable to read in Group in SD\n", group_address);
                goto CLEANUP;
            }
        }

        if ((Control & SE_DACL_PRESENT) &&
            (Dacl != 0))
        {
            dacl_address = Dacl;

            if (! acl_successfully_read(dacl_address, & dacl))
            {
                dprintf("%08p: Unable to read in Dacl in SD\n", dacl_address);
                goto CLEANUP;
            }
        }

        if ((Control & SE_SACL_PRESENT) &&
            (Sacl != 0))
        {
            sacl_address = (Sacl);

            if (! acl_successfully_read(sacl_address, & sacl))
            {
                dprintf("%08p: Unable to read in Sacl in SD\n", sacl_address);
                goto CLEANUP;
            }
        }
    }

    DumpSD("", Address, owner_sid, group_sid, dacl, sacl, Flags, dacl_address, sacl_address);


CLEANUP:

    if (owner_sid)
    {
        free(owner_sid);
    }

    if (group_sid)
    {
        free(group_sid);
    }

    if (dacl)
    {
        free(dacl);
    }

    if (sacl)
    {
        free(sacl);
    }
    return S_OK;
}

/*
+-------------------------------------------------------------------+

    NAME:       sid

    FUNCTION:   Reads in & prints the SID, from
                the address specified. !sid command's workhorse.

    ARGS:       Standard Debugger extensions, refer to DECLARE_API
                macro in the header files.

+-------------------------------------------------------------------+
*/

DECLARE_API( sid )
{
    ULONG64 Address;
    ULONG   Flags;
    ULONG   result;
    PSID    sid_to_dump;
    NTSTATUS        ntstatus;
    UNICODE_STRING  us;


    Address = 0;
    Flags = 6;
    sscanf(args,"%lx %lx",&Address,&Flags);
    Address = GetExpression(args);

    if (Address == 0) {
        dprintf("usage: !sid <SID-address>\n");
        return E_INVALIDARG;
    }

    if (! sid_successfully_read(Address, & sid_to_dump))
    {
        dprintf("%08p: Unable to read in SID\n", Address);
        return E_INVALIDARG;
    }

    DumpSID("SID is: ", sid_to_dump, Flags);

    return S_OK;
}

/*
+-------------------------------------------------------------------+

    NAME:       acl

    FUNCTION:   Reads in & prints the ACL, from
                the address specified. !acl command's workhorse.

    ARGS:       Standard Debugger extensions, refer to DECLARE_API
                macro in the header files.

+-------------------------------------------------------------------+
*/

DECLARE_API( acl )
{
    ULONG64 Address;
    ULONG   Flags;
    ULONG   result;
    PACL    acl_to_dump;
    NTSTATUS        ntstatus;
    UNICODE_STRING  us;


    Address = 0;
    Flags = 6;
    sscanf(args,"%lx %lx",&Address,&Flags);
    Address = GetExpression (args);
    if (Address == 0) {
        dprintf("usage: !acl <ACL-address>\n");
        return E_INVALIDARG;
    }

    if (! acl_successfully_read(Address, & acl_to_dump))
    {
        dprintf("%08p: Unable to read in ACL\n", Address);
        return E_INVALIDARG;
    }

    DumpACL("ACL is: ", acl_to_dump, Flags, Address);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\peb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    peb.c

Abstract:

    WinDbg Extension Api

Author:

    Ramon J San Andres (ramonsa) 5-Nov-1993

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <time.h>

BOOL
GetTeb32FromWowTeb(ULONG64 Teb, PULONG64 pTeb32)
{
    if (pTeb32) {
        return ReadPointer(Teb, pTeb32);
    }
    return FALSE;
}

BOOL
GetPeb32FromWowTeb(ULONG64 Teb, PULONG64 pPeb32)
{
    ULONG Peb32;
    ULONG64 Teb32=0;
    ULONG err;

    if (GetTeb32FromWowTeb(Teb, &Teb32) && Teb32) {
        if (!(err =GetFieldValue(Teb32, "nt!TEB32", "ProcessEnvironmentBlock", Peb32))) {
            *pPeb32 = Peb32;
            return TRUE;
        } else if (err == SYMBOL_TYPE_INFO_NOT_FOUND) {
            if (!(err =GetFieldValue(Teb32, "wow64!TEB32", "ProcessEnvironmentBlock", Peb32))) {
                *pPeb32 = Peb32;
                return TRUE;
            }
        }
    }
    return FALSE;
}

HRESULT
DumpPeb(ULONG64 peb, BOOL IsWow64Peb)
{
    ULONG64 ldr;
    ULONG64 err;
    ULONG64 ldr_Initialized;
    ULONG64 ldr_InInitializationOrderModuleList_Flink;
    ULONG64 ldr_InInitializationOrderModuleList_Blink;
    ULONG64 ldr_InLoadOrderModuleList_Flink;
    ULONG64 ldr_InLoadOrderModuleList_Blink;
    ULONG   ldr_InMemoryOrderModuleList_Offset;
    ULONG64 ldr_InMemoryOrderModuleList_Flink;
    ULONG64 ldr_InMemoryOrderModuleList_Blink;
    ULONG   ldr_DataTableEntry_InMemoryOrderLinks_Offset;
    ULONG64 peb_SubSystemData;
    ULONG64 peb_ProcessHeap;
    ULONG64 peb_ProcessParameters;
    PCHAR   ldrdata = "nt!_PEB_LDR_DATA";
    PCHAR   ldrEntry = "nt!_LDR_DATA_TABLE_ENTRY";
    PCHAR   processparam = "nt!_RTL_USER_PROCESS_PARAMETERS";
    HRESULT hr = S_OK;

    if (IsWow64Peb) {
        // try and load types from nt
        if ( err = InitTypeRead( peb, nt!PEB32 ) )   {
            if (err == SYMBOL_TYPE_INFO_NOT_FOUND) {
                // try load types from wow64
                if ( !( err = InitTypeRead( peb, wow64!PEB32 )) )   {
                    ldrdata = "wow64!_PEB_LDR_DATA32";
                    ldrEntry = "wow64!_LDR_DATA_TABLE_ENTRY32";
                    processparam = "wow64!_RTL_USER_PROCESS_PARAMETERS32";
                } else {
                    dprintf( "error %d InitTypeRead( wow64!PEB32 at %p)...\n", (ULONG) err, peb);
                    return E_INVALIDARG;
                }
            } else {
                dprintf( "error %d InitTypeRead( nt!PEB32 at %p)...\n", (ULONG) err, peb);
                return E_INVALIDARG;
            }
        } else {
            ldrdata = "nt!_PEB_LDR_DATA32";
            ldrEntry = "nt!_LDR_DATA_TABLE_ENTRY32";
            processparam = "nt!_RTL_USER_PROCESS_PARAMETERS32";
        }
    } else {
        if ( err = InitTypeRead( peb, PEB ) )   {
           dprintf( "error %d InitTypeRead( nt!PEB32 at %p)...\n", (ULONG) err, peb);
           return E_INVALIDARG;
        }
    }

    dprintf( 
        "    InheritedAddressSpace:    %s\n"
        "    ReadImageFileExecOptions: %s\n"
        "    BeingDebugged:            %s\n"
        "    ImageBaseAddress:         %p\n"
        "    Ldr                       %p\n",
        ReadField( InheritedAddressSpace )    ? "Yes" : "No",
        ReadField( ReadImageFileExecOptions ) ? "Yes" : "No",
        ReadField( BeingDebugged )            ? "Yes" : "No",
        ReadField( ImageBaseAddress ),
        (ldr = ReadField( Ldr ))
        );

    peb_SubSystemData     = ReadField( SubSystemData );
    peb_ProcessHeap       = ReadField( ProcessHeap );
    peb_ProcessParameters = ReadField( ProcessParameters );

    err = GetFieldOffset( ldrdata,
                          "InMemoryOrderModuleList", 
                          &ldr_InMemoryOrderModuleList_Offset
                        );
    if ( err )   {
        dprintf( "    ***  _PEB_LDR_DATA%s was not found...\n",
                 ( err == FIELDS_DID_NOT_MATCH ) ? ".InMemoryModuleList field" :
                 " type"
               );
    }
    else   {
       err = GetFieldOffset( ldrEntry,
                             "InMemoryOrderLinks", 
                             &ldr_DataTableEntry_InMemoryOrderLinks_Offset
                           );
       if (err )  {
           dprintf( "    ***  _LDR_DATA_TABLE_ENTRY%s was not found...\n",
                    ( err == FIELDS_DID_NOT_MATCH ) ? ".InMemoryOrderLinks field" :
                   " type"
                  );
       }
    }

    if ( err || GetFieldValue( ldr, ldrdata, "Initialized", ldr_Initialized ) )   {
        dprintf( "    *** unable to read Ldr table at %p\n", ldr );
    }
    else  {
        ULONG64 next, head;
        BOOL First = TRUE;

        GetFieldValue( ldr, ldrdata, "InInitializationOrderModuleList.Flink", ldr_InInitializationOrderModuleList_Flink );
        GetFieldValue( ldr, ldrdata, "InInitializationOrderModuleList.Blink", ldr_InInitializationOrderModuleList_Blink );
        GetFieldValue( ldr, ldrdata, "InLoadOrderModuleList.Flink", ldr_InLoadOrderModuleList_Flink );
        GetFieldValue( ldr, ldrdata, "InLoadOrderModuleList.Blink", ldr_InLoadOrderModuleList_Blink );
        GetFieldValue( ldr, ldrdata, "InMemoryOrderModuleList.Flink", ldr_InMemoryOrderModuleList_Flink );
        GetFieldValue( ldr, ldrdata, "InMemoryOrderModuleList.Blink", ldr_InMemoryOrderModuleList_Blink );

        dprintf( 
            "    Ldr.Initialized:          %s\n"
            "    Ldr.InInitializationOrderModuleList: %p . %p\n"
            "    Ldr.InLoadOrderModuleList:           %p . %p\n"
            "    Ldr.InMemoryOrderModuleList:         %p . %p\n",
                  ldr_Initialized ? "Yes" : "No",
                  ldr_InInitializationOrderModuleList_Flink,
                  ldr_InInitializationOrderModuleList_Blink,
                  ldr_InLoadOrderModuleList_Flink,
                  ldr_InLoadOrderModuleList_Blink,
                  ldr_InMemoryOrderModuleList_Flink,
                  ldr_InMemoryOrderModuleList_Blink
               );
        head = ldr + (ULONG64)ldr_InMemoryOrderModuleList_Offset;
        next = ldr_InMemoryOrderModuleList_Flink;
        while( next != head )    {
            ULONG64 entry, dllBase;
            UNICODE_STRING64 u;
            ULONG Timestamp;
            const char *time;

            entry = next - ldr_DataTableEntry_InMemoryOrderLinks_Offset;
            if (GetFieldValue( entry, ldrEntry, "DllBase", dllBase )) {
                dprintf("Cannot read %s at %p\n",ldrEntry, entry);
                break;
            }
            GetFieldValue( entry, ldrEntry, "TimeDateStamp", Timestamp );
            GetFieldValue( entry, ldrEntry, "FullDllName.Buffer", u.Buffer );
            GetFieldValue( entry, ldrEntry, "FullDllName.Length", u.Length );
            GetFieldValue( entry, ldrEntry, "FullDllName.MaximumLength", u.MaximumLength );
            if (First) {
                if (IsPtr64()) {
                    dprintf("                    Base TimeStamp / Module\n");
                } else {
                    dprintf("            Base TimeStamp                     Module\n");
                }
                First = FALSE;
            }
            if (IsPtr64()) {
                dprintf("        ");
            }
            dprintf( "%16p ", dllBase );
            if ((time = ctime((time_t *) &Timestamp)) != NULL) {
                dprintf( "%08x %-20.20s ", Timestamp, time+4);
            }
            if ( u.Buffer )  {
                if (IsPtr64()) {
                    dprintf("\n                         ");
                }
                DumpUnicode64( u );
            }
            dprintf( "\n");
            GetFieldValue( entry, ldrEntry, "InMemoryOrderLinks.Flink", next );

            if (CheckControlC()) {
                break;
            }
        }
    }

    dprintf( 
        "    SubSystemData:     %p\n"
        "    ProcessHeap:       %p\n"
        "    ProcessParameters: %p\n", 
                  peb_SubSystemData,
                  peb_ProcessHeap,
                  peb_ProcessParameters
            );
    if ( peb_ProcessParameters )   { 
        ULONG64 peb_ProcessParameters_Environment;
        ULONG64 peb_ProcessParameters_Flags;
        UNICODE_STRING64 windowTitle;
        UNICODE_STRING64 imagePathName;
        UNICODE_STRING64 commandLine;
        UNICODE_STRING64 dllPath;

        GetFieldValue( peb_ProcessParameters, processparam, "Environment", peb_ProcessParameters_Environment );
        GetFieldValue( peb_ProcessParameters, processparam, "Flags", peb_ProcessParameters_Flags );
        GetFieldValue( peb_ProcessParameters, processparam, "WindowTitle.Buffer", windowTitle.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "WindowTitle.Length", windowTitle.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "WindowTitle.MaximumLength", windowTitle.MaximumLength );
        GetFieldValue( peb_ProcessParameters, processparam, "ImagePathName.Buffer", imagePathName.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "ImagePathName.Length", imagePathName.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "ImagePathName.MaximumLength", imagePathName.MaximumLength );
        GetFieldValue( peb_ProcessParameters, processparam, "CommandLine.Buffer", commandLine.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "CommandLine.Length", commandLine.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "CommandLine.MaximumLength", commandLine.MaximumLength );
        GetFieldValue( peb_ProcessParameters, processparam, "DllPath.Buffer", dllPath.Buffer );
        GetFieldValue( peb_ProcessParameters, processparam, "DllPath.Length", dllPath.Length );
        GetFieldValue( peb_ProcessParameters, processparam, "DllPath.MaximumLength", dllPath.MaximumLength );
        if ( !(peb_ProcessParameters_Flags & RTL_USER_PROC_PARAMS_NORMALIZED) )   {
             windowTitle.Buffer   += peb_ProcessParameters;
             imagePathName.Buffer += peb_ProcessParameters;
             commandLine.Buffer   += peb_ProcessParameters;
             dllPath.Buffer       += peb_ProcessParameters;
        }
        dprintf( 
            "    WindowTitle:  '" );
        DumpUnicode64( windowTitle );
        dprintf("'\n");
        dprintf( 
            "    ImageFile:    '" );
        DumpUnicode64( imagePathName );
        dprintf("'\n");
        dprintf( 
            "    CommandLine:  '" );
        DumpUnicode64( commandLine );
        dprintf("'\n");
        dprintf( 
            "    DllPath:      '" );
        DumpUnicode64( dllPath );
        dprintf("'\n"
                "        Environment:  %p\n", peb_ProcessParameters_Environment );

    }
    else   {
        dprintf( "    *** unable to read process parameters\n" );

    }
    return S_OK;
}

DECLARE_API( peb )

/*++

Routine Description:

    This function is called to dump the PEB

    Called as:

        !peb

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG64 pebAddress;
    ULONG64 peb;
    HRESULT hr = S_OK;
    
    INIT_API();
    if ( *args ) {
       pebAddress = GetExpression( args );
    } else {
        ULONG64 tebAddress;
        GetTebAddress( &tebAddress );
        if (TargetMachine == IMAGE_FILE_MACHINE_IA64 && tebAddress) {
            ULONG64 Peb32=0;
            if (GetPeb32FromWowTeb(tebAddress, &Peb32) && Peb32) {
                dprintf("Wow64 PEB32 at %lx\n", Peb32);
                DumpPeb(Peb32, TRUE);
                dprintf("\n\nWow64 ");
            }
        }
        
        GetPebAddress( 0, &pebAddress );
    }

    if ( pebAddress ) {
       dprintf( "PEB at %p\n", pebAddress );
    }
    else  {
       dprintf( "PEB NULL...\n" );
       return E_INVALIDARG;
    }

    peb = IsPtr64() ? pebAddress : (ULONG64)(LONG64)(LONG)pebAddress;

    hr = DumpPeb(peb, FALSE);
    EXIT_API();
    return hr;


} // PebExtension()


HRESULT
DumpTeb(ULONG64 tebAddress, BOOL IsWow64Teb)
{

    ULONG64 teb;
    ULONG64 tib_ExceptionList;
    ULONG64 tib_StackBase;
    ULONG64 tib_StackLimit;
    ULONG64 tib_StackSusSystemTib;
    ULONG64 tib_FiberData;
    ULONG64 tib_ArbitraryUserPointer;
    ULONG64 tib_Self;
    ULONG64 tib_EnvironmentPointer;
    ULONG64 teb_ClientId_UniqueProcess;
    ULONG64 teb_ClientId_UniqueThread;
    ULONG64 teb_RealClientId_UniqueProcess;
    ULONG64 teb_RealClientId_UniqueThread;
    ULONG64 DeallocationBStore;
    HRESULT hr = S_OK;
    ULONG64 err;

    teb = tebAddress;
    if (!IsWow64Teb) {
        if ( InitTypeRead( teb, TEB ) )   {
           dprintf( "error InitTypeRead( TEB )...\n");
           return E_INVALIDARG;
        }
    } else {
        if ( err = InitTypeRead( teb, nt!TEB32 ) )   {
            if (err == SYMBOL_TYPE_INFO_NOT_FOUND) {
                if ( InitTypeRead( teb, wow64!TEB32 ) )   {
                    dprintf( "error InitTypeRead( wow64!TEB32 )...\n");
                    return E_INVALIDARG;
                }
            } else {
                dprintf( "error InitTypeRead( TEB32 )...\n");
                return E_INVALIDARG;
            }
        }
    }

    dprintf( 
        "    ExceptionList:        %p\n"
        "    StackBase:            %p\n"
        "    StackLimit:           %p\n"
        "    SubSystemTib:         %p\n"
        "    FiberData:            %p\n"
        "    ArbitraryUserPointer: %p\n"
        "    Self:                 %p\n"
        "    EnvironmentPointer:   %p\n",
                    GetShortField(0, "NtTib.ExceptionList", 0),
                    ReadField( NtTib.StackBase ),
                    GetShortField(0, "NtTib.StackLimit", 0),
                    GetShortField(0, "NtTib.SubsystemTib", 0),
                    GetShortField(0, "NtTib.FiberData", 0),
                    GetShortField(0, "NtTib.ArbitraryUsetPointer", 0),
                    GetShortField(0, "NtTib.Self", 0),
                    GetShortField(0, "NtTib.EnvironmentPointer", 0)
            );

     teb_ClientId_UniqueProcess     = GetShortField( 0, "ClientId.UniqueProcess", 0 );
     teb_ClientId_UniqueThread      = GetShortField( 0, "ClientId.UniqueThread",  0 );
     teb_RealClientId_UniqueProcess = GetShortField( 0, "RealClientId.UniqueProcess", 0 );
     teb_RealClientId_UniqueThread  = GetShortField( 0, "RealClientId.UniqueThread",  0 );
     dprintf( 
         "    ClientId:             %p . %p\n", teb_ClientId_UniqueProcess, teb_ClientId_UniqueThread );
     if ( teb_ClientId_UniqueProcess != teb_RealClientId_UniqueProcess ||
          teb_ClientId_UniqueThread  != teb_RealClientId_UniqueThread )
     {
        dprintf( 
            "    Real ClientId:        %p . %p\n", teb_RealClientId_UniqueProcess, teb_RealClientId_UniqueThread );
     }

    dprintf(  
        "    RpcHandle:            %p\n"
        "    Tls Storage:          %p\n"
        "    PEB Address:          %p\n"
        "    LastErrorValue:       %u\n"
        "    LastStatusValue:      %x\n"
        "    Count Owned Locks:    %u\n"
        "    HardErrorsMode:       %u\n", 
            ReadField( ActiveRpcHandle ),
            ReadField( ThreadLocalStoragePointer ),
            ReadField( ProcessEnvironmentBlock ),
            (ULONG)ReadField( LastErrorValue ),
            (ULONG)ReadField( LastStatusValue ),
            (ULONG)ReadField( CountOfOwnedCriticalSections ),
            (ULONG)ReadField( HardErrorsAreDisabled ) 
            );
    if  (TargetMachine == IMAGE_FILE_MACHINE_IA64 && !IsWow64Teb)   {
        dprintf(
            "    DeallocationBStore:   %p\n"
            "    BStoreLimit:          %p\n",
            ReadField(DeallocationBStore),
            ReadField( BStoreLimit )
           );
    }
    return hr;
} // DumpTeb()



DECLARE_API( teb )

/*++

Routine Description:

    This function is called to dump the TEB

    Called as:

        !teb

--*/

{

    ULONG64 tebAddress;
    HRESULT hr = S_OK;
    
    INIT_API();
    if ( *args )   {
       tebAddress = GetExpression( args );
    } else {
        GetTebAddress( &tebAddress );
    }

    if ( tebAddress )   {
        if (TargetMachine == IMAGE_FILE_MACHINE_IA64 && tebAddress) {
            ULONG64 Teb32=0;
            if (GetTeb32FromWowTeb(tebAddress, &Teb32) && Teb32) {
                dprintf("Wow64 TEB32 at %p\n", Teb32);
                DumpTeb(Teb32, TRUE);
                dprintf("\n\nWow64 ");
            }
        }
       dprintf( "TEB at %p\n", tebAddress );
    } else  {
       dprintf( "TEB NULL...\n" );
       hr = E_INVALIDARG;
       goto ExitTeb;
    }
    tebAddress = IsPtr64() ? tebAddress : (ULONG64)(LONG64)(LONG)tebAddress;

    hr = DumpTeb(tebAddress, FALSE);
ExitTeb:
    EXIT_API();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\verifier.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    verifier.c

Abstract:

    Application verifier debugger extension for both ntsd and kd.

Author:

    Silviu Calinoiu (SilviuC) 4-Mar-2001

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

ULONG
VrfGetArguments (
    PCHAR ArgsString,
    PCHAR Args[],
    ULONG NoOfArgs
    );

VOID
VrfHelp (
    );

BOOLEAN
VrfTraceInitialize (
    );

ULONG64
VrfTraceAddress ( 
    ULONG TraceIndex
    );

VOID
VrfTraceDump (
    ULONG TraceIndex
    );

VOID
VrfDumpSettings (
    );

VOID
VrfDumpVspaceLog (
    ULONG NoOfEntries,
    ULONG64 Address
    );

VOID
VrfDumpHeapLog (
    ULONG NoOfEntries,
    ULONG64 Address
    );

DECLARE_API( avrf )

/*++

Routine Description:

    Application verifier debugger extension.

Arguments:

    args - 

Return Value:

    None

--*/
{
    PCHAR Args[16];
    ULONG NoOfArgs, I;

    INIT_API();

    //
    // Parse arguments.
    //

    NoOfArgs = VrfGetArguments ((PCHAR)args,
                                Args,
                                16);
#if 0
    for (I = 0; I < NoOfArgs; I += 1) {
        dprintf ("%02u: %s\n", I, Args[I]);
    }
#endif

    //
    // Check if help needed
    //

    if (NoOfArgs > 0 && strstr (Args[0], "?") != NULL) {
        VrfHelp ();
        goto Exit;
    }

    if (VrfTraceInitialize() == FALSE) {
        goto Exit;
    }

    if (NoOfArgs > 1 && _stricmp (Args[0], "-trace") == 0) {
        VrfTraceDump (atoi(Args[1]));
        goto Exit;
    }
    
    if (NoOfArgs > 1 && _stricmp (Args[0], "-vs") == 0) {

        if (NoOfArgs > 2 && _stricmp (Args[1], "-a") == 0) {

            ULONG64 Address;
            BOOL Result;
            PCSTR Remainder;

            Result = GetExpressionEx (Args[2], &Address, &Remainder);

            if (Result == FALSE) {
                dprintf ("\nFailed to convert `%s' to an address.\n", Args[2]);
                goto Exit;
            }

            // sscanf (Args[2], "%I64X", &Address);
            dprintf ("Searching in vspace log for address %I64X ...\n\n", Address);
            VrfDumpVspaceLog (0, Address);
            goto Exit;
        }
        else {

            VrfDumpVspaceLog (atoi(Args[1]), 0);
            goto Exit;
        }
    }
    
    if (NoOfArgs > 1 && _stricmp (Args[0], "-hp") == 0) {

        if (NoOfArgs > 2 && _stricmp (Args[1], "-a") == 0) {

            ULONG64 Address;
            BOOL Result;
            PCSTR Remainder;

            Result = GetExpressionEx (Args[2], &Address, &Remainder);

            if (Result == FALSE) {
                dprintf ("\nFailed to convert `%s' to an address.\n", Args[2]);
                goto Exit;
            }

            // sscanf (Args[2], "%I64X", &Address);
            dprintf ("Searching in vspace log for address %I64X ...\n\n", Address);
            VrfDumpHeapLog (0, Address);
            goto Exit;
        }
        else {

            VrfDumpHeapLog (atoi(Args[1]), 0);
            goto Exit;
        }
    }
    
    //
    // If no option specified then we just print current settings.
    //

    VrfDumpSettings ();

Exit:

    EXIT_API();
    return S_OK;
}


VOID
VrfHelp (
    )
{
    dprintf ("Application verifier debugger extension                    \n"
             "                                                           \n"
             "!avrf                displays current settings and stop    \n"
             "                     data if a verifier stop happened.     \n"
             "!avrf -vs N          dumps last N entries from vspace log. \n"
             "!avrf -vs -a ADDR    searches ADDR in the vspace log.      \n"
             "!avrf -hp N          dumps last N entries from heap log.   \n"
             "!avrf -hp -a ADDR    searches ADDR in the heap log.        \n"
             "                                                           \n");
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// Argument parsing routines
/////////////////////////////////////////////////////////////////////

PCHAR 
VrfGetArgument (
    PCHAR Args,
    PCHAR * Next
    )
{
    PCHAR Start;

    if (Args == NULL) {
        return NULL;
    }

    while (*Args == ' ' || *Args == '\t') {
        Args += 1;
    }

    if (*Args == '\0') {
        return NULL;
    }

    Start = Args;

    while (*Args != ' ' && *Args != '\t' && *Args != '\0') {
        Args += 1;
    }

    if (*Args == '\0') {
        *Next = NULL;
    }
    else {
        *Args = '\0';
        *Next = Args + 1;
    }

    return Start;
}

ULONG
VrfGetArguments (
    PCHAR ArgsString,
    PCHAR Args[],
    ULONG NoOfArgs
    )
{
    PCHAR Arg = ArgsString;
    PCHAR Next;
    ULONG Index;
    
    for (Index = 0; Index < NoOfArgs; Index += 1) {

        Arg = VrfGetArgument (Arg, &Next);

        if (Arg) {
            Args[Index] = Arg;
        }
        else {
            break;
        }

        Arg = Next;
    }

    return Index;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////// Dump stack traces
/////////////////////////////////////////////////////////////////////

ULONG64 TraceDbArrayEnd;
ULONG PvoidSize;

BOOLEAN
VrfTraceInitialize (
    )
{
    ULONG64 TraceDatabaseAddress;
    ULONG64 TraceDatabase;

    //
    // Stack trace database address
    //

    TraceDatabaseAddress = GetExpression("ntdll!RtlpStackTraceDataBase");
    
    if ( TraceDatabaseAddress == 0 ) {
        dprintf( "Unable to resolve ntdll!RtlpStackTraceDataBase symbolic name.\n");
        return FALSE;
    }

    if (ReadPtr (TraceDatabaseAddress, &TraceDatabase ) != S_OK) {
        dprintf( "Cannot read pointer at ntdll!RtlpStackTraceDataBase\n" );
        return FALSE;
    }

    if (TraceDatabase == 0) {
        dprintf( "Stack traces not enabled (ntdll!RtlpStackTraceDataBase is null).\n" );
        return FALSE;
    }

    //
    // Find the array of stack traces
    //

    if (InitTypeRead(TraceDatabase, ntdll!_STACK_TRACE_DATABASE)) {
        dprintf("Unable to read type ntdll!_STACK_TRACE_DATABASE @ %p\n", TraceDatabase);
        return FALSE;
    }

    TraceDbArrayEnd = ReadField (EntryIndexArray);

    PvoidSize = GetTypeSize ("ntdll!PVOID");

    return TRUE;
}


ULONG64
VrfTraceAddress ( 
    ULONG TraceIndex
    )
{
    ULONG64 TracePointerAddress;
    ULONG64 TracePointer;

    TracePointerAddress = TraceDbArrayEnd - TraceIndex * PvoidSize;

    if (ReadPtr (TracePointerAddress, &TracePointer) != S_OK) {
        dprintf ("Cannot read stack trace address @ %p\n", TracePointerAddress);
        return 0;
    }

    return TracePointer;
}

VOID
VrfTraceDump (
    ULONG TraceIndex
    )
{
    ULONG64 TraceAddress;
    ULONG64 TraceArray;
    ULONG TraceDepth;
    ULONG Offset;
    ULONG Index;
    ULONG64 ReturnAddress;
    CHAR Symbol[ 1024 ];
    ULONG64 Displacement;

    //
    // Get real address of the trace.
    //

    TraceAddress = VrfTraceAddress (TraceIndex);

    if (TraceAddress == 0) {
        return;
    }

    //
    // Read the stack trace depth
    //

    if (InitTypeRead(TraceAddress, ntdll!_RTL_STACK_TRACE_ENTRY)) {
        dprintf("Unable to read type ntdll!_RTL_STACK_TRACE_ENTRY @ %p\n", TraceAddress);
        return;
    }

    TraceDepth = (ULONG)ReadField (Depth);

    //
    // Limit the depth to 20 to protect ourselves from corrupted data
    //

    TraceDepth = __min (TraceDepth, 16);

    //
    // Get a pointer to the BackTrace array
    //

    GetFieldOffset ("ntdll!_RTL_STACK_TRACE_ENTRY", "BackTrace", &Offset);
    TraceArray = TraceAddress + Offset;

    //
    // Dump this stack trace. Skip first two entries.
    //

    TraceArray += 2 * PvoidSize;

    for (Index = 2; Index < TraceDepth; Index += 1) {

        if (ReadPtr (TraceArray, &ReturnAddress) != S_OK) {
            dprintf ("Cannot read address @ %p\n", TraceArray);
            return;
        }

        GetSymbol (ReturnAddress, Symbol, &Displacement);

        dprintf ("\t%p: %s+0x%I64X\n",
                 ReturnAddress,
                 Symbol,
                 Displacement );

        TraceArray += PvoidSize;
    }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Dump settings
/////////////////////////////////////////////////////////////////////

VOID
VrfDumpSettings (
    )
{
    ULONG64 FlagsAddress;
    ULONG Flags;
    ULONG BytesRead;
    ULONG64 StopAddress;
    ULONG64 StopData[5];
    ULONG I;
    ULONG UlongPtrSize;

    UlongPtrSize = GetTypeSize ("ntdll!ULONG_PTR");
    FlagsAddress = GetExpression("ntdll!AVrfpVerifierFlags");
    
    if (FlagsAddress == 0) {
        dprintf( "Unable to resolve ntdll!AVrfpVerifierFlags symbolic name.\n");
        return;
    }

    if (ReadMemory (FlagsAddress, &Flags, sizeof Flags, &BytesRead) == FALSE) {
        dprintf ("Cannot read value @ %p (ntdll!AVrfpVerifierFlags) \n", FlagsAddress);
        return;
    }

    dprintf ("Application verifier settings (%08X): \n\n", Flags);

    if (Flags & RTL_VRF_FLG_FULL_PAGE_HEAP) {
        dprintf ("   - full page heap\n");
    }
    else {
        dprintf ("   - light page heap\n");
    }
           
    if (Flags & RTL_VRF_FLG_LOCK_CHECKS) {
        dprintf ("   - lock checks (critical section verifier)\n");
    }
    
    if (Flags & RTL_VRF_FLG_HANDLE_CHECKS) {
        dprintf ("   - handle checks\n");
    }
    
    if (Flags & RTL_VRF_FLG_STACK_CHECKS) {
        dprintf ("   - stack checks (disable automatic stack extensions)\n");
    }

    dprintf ("\n");

    //
    // Check if a verifier stop has been encountered.
    //

    StopAddress = GetExpression("ntdll!AVrfpStopData");
    
    if (StopAddress == 0) {
        dprintf( "Unable to resolve ntdll!AVrfpStopData symbolic name.\n");
        return;
    }

    for (I = 0; I < 5; I += 1) {

        if (ReadPtr (StopAddress + I * UlongPtrSize, &(StopData[I])) != S_OK) {
            dprintf ("Cannot read value @ %p \n", StopAddress + I * UlongPtrSize);
        }
    }

    if (StopData[0] != 0) {

        dprintf ("Stop %p: %p %p %p %p \n", 
                 StopData[0],
                 StopData[1],
                 StopData[2],
                 StopData[3],
                 StopData[4]);

        // silviuc: dump more text info about the verifier_stop
    }
}

/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////// Dump vspace log
/////////////////////////////////////////////////////////////////////

VOID
VrfDumpVspaceLog (
    ULONG NoOfEntries,
    ULONG64 Address
    )
{
    ULONG64 IndexAddress;
    ULONG Index;
    ULONG64 LogAddress;
    ULONG EntrySize;
    ULONG MaxIndex = 8192; // silviuc: should not be hard coded
    ULONG BytesRead;
    ULONG64 EntryAddress;
    ULONG TraceIndex;
    ULONG I;
    PCHAR OpName;
    BOOLEAN Found = FALSE;

    if (Address) {
        NoOfEntries = MaxIndex;
    }
    else {
        if (NoOfEntries == 0) {
            NoOfEntries = 8;
        }
    }

    EntrySize = GetTypeSize ("verifier!_VS_CALL");
    IndexAddress = GetExpression("verifier!VsCallsIndex");
    LogAddress = GetExpression("verifier!VsCalls");
    
    if (IndexAddress == 0 || LogAddress == 0 || EntrySize == 0) {
        dprintf( "Incorrect symbols for verifier.dll.\n");
        return;
    }

    if (ReadMemory (IndexAddress, &Index, sizeof Index, &BytesRead) == FALSE) {
        dprintf ("Cannot read value @ %p (verifier!VsCallsIndex) \n", IndexAddress);
        return;
    }

    for (I = 0; I < NoOfEntries; I += 1) {

        ULONG64 VsAddress;
        ULONG64 VsSize;
        BOOLEAN PrintTrace;

        EntryAddress = LogAddress + EntrySize * ((Index - I) % MaxIndex);

        if (InitTypeRead (EntryAddress, verifier!_VS_CALL)) {
            dprintf("Unable to read type verifier!_VS_CALL @ %p\n", EntryAddress);
            return;
        }

        switch ((ULONG)ReadField(Type)) {
            case 0: OpName = "VirtualAlloc"; break;
            case 1: OpName = "VirtualFree"; break;
            case 2: OpName = "MapView"; break;
            case 3: OpName = "UnmapView"; break;
            default:OpName = "Unknown?"; break;
        }

        VsAddress = ReadField(Address);
        VsSize = ReadField (Size);

        if (Address) {
            if (VsAddress <= Address && Address < VsAddress + VsSize) {
                PrintTrace = TRUE;
            }
            else {
                PrintTrace = FALSE;
            }
        }
        else {
            PrintTrace = TRUE;
        }

        if (PrintTrace) {

            Found = TRUE; 

            dprintf ("%s (tid: 0x%X): \n"
                     "address: %p \n"
                     "size: %p\n"
                     "operation: %X\n"
                     "protection: %X\n",
                     OpName,
                     (ULONG)ReadField(Thread),
                     VsAddress,
                     VsSize,
                     (ULONG)ReadField(Operation),
                     (ULONG)ReadField(Protection));

            TraceIndex = (ULONG) ReadField (Trace);
            VrfTraceDump (TraceIndex);
            dprintf ("\n");
        }
    }
    
    if (! Found) {
        dprintf ("No entries found. \n");
    }
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////// Dump heap log
/////////////////////////////////////////////////////////////////////

VOID
VrfDumpHeapLog (
    ULONG NoOfEntries,
    ULONG64 Address
    )
{
    ULONG64 IndexAddress;
    ULONG Index;
    ULONG64 LogAddress;
    ULONG EntrySize;
    ULONG MaxIndex = 8192; // silviuc: should not be hard coded
    ULONG BytesRead;
    ULONG64 EntryAddress;
    ULONG TraceIndex;
    ULONG I;
    PCHAR OpName;
    BOOLEAN Found = FALSE;

    if (Address) {
        NoOfEntries = MaxIndex;
    }
    else {
        if (NoOfEntries == 0) {
            NoOfEntries = 8;
        }
    }

    EntrySize = GetTypeSize ("verifier!_HEAP_CALL");
    IndexAddress = GetExpression("verifier!HeapCallsIndex");
    LogAddress = GetExpression("verifier!HeapCalls");
    
    if (IndexAddress == 0 || LogAddress == 0 || EntrySize == 0) {
        dprintf( "Incorrect symbols for verifier.dll.\n");
        return;
    }

    if (ReadMemory (IndexAddress, &Index, sizeof Index, &BytesRead) == FALSE) {
        dprintf ("Cannot read value @ %p (verifier!HeapCallsIndex) \n", IndexAddress);
        return;
    }

    for (I = 0; I < NoOfEntries; I += 1) {

        ULONG64 VsAddress;
        ULONG64 VsSize;
        BOOLEAN PrintTrace;

        EntryAddress = LogAddress + EntrySize * ((Index - I) % MaxIndex);

        if (InitTypeRead (EntryAddress, verifier!_HEAP_CALL)) {
            dprintf("Unable to read type verifier!_HEAP_CALL @ %p\n", EntryAddress);
            return;
        }

        VsAddress = ReadField(Address);
        VsSize = ReadField (Size);

        if (VsSize == 0) {
            OpName = "free";
        }
        else {
            OpName = "alloc";
        }

        if (Address) {
            if (VsAddress <= Address && Address <= VsAddress + VsSize) {
                PrintTrace = TRUE;
            }
            else {
                PrintTrace = FALSE;
            }
        }
        else {
            PrintTrace = TRUE;
        }

        if (PrintTrace) {

            Found = TRUE;

            dprintf ("%s (tid: 0x%X): \n"
                     "address: %p \n"
                     "size: %p\n",
                     OpName,
                     (ULONG)ReadField(Thread),
                     VsAddress,
                     VsSize);

            TraceIndex = (ULONG) ReadField (Trace);
            VrfTraceDump (TraceIndex);
            dprintf ("\n");
        }
    }

    if (! Found) {
        dprintf ("No entries found. \n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\util.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    util.c

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


ULONG
GetBitFieldOffset (
   IN LPSTR     Type, 
   IN LPSTR     Field, 
   OUT PULONG   pOffset,
   OUT PULONG   pSize
   ) 
{ 
   FIELD_INFO flds = {
       Field, "", 0, 
       DBG_DUMP_FIELD_FULL_NAME | DBG_DUMP_FIELD_RETURN_ADDRESS | DBG_DUMP_FIELD_SIZE_IN_BITS, 
       0, NULL};
   SYM_DUMP_PARAM Sym = {
      sizeof (SYM_DUMP_PARAM), Type, DBG_DUMP_NO_PRINT, 0,
      NULL, NULL, NULL, 1, &flds
   };
   ULONG Err, i=0;
   LPSTR dot, last=Field;
   
   Sym.nFields = 1;
   Err = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );
   *pOffset = (ULONG) (flds.address - Sym.addr);
   *pSize   = flds.size;
   return Err;
}

ULONG
GetUlongFromAddress (
    ULONG64 Location
    )
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location,&Value,sizeof(ULONG),&result)) ||
        (result < sizeof(ULONG))) {
        dprintf("unable to read from %08x\n",Location);
        return 0;
    }

    return Value;
}

ULONG64
GetPointerFromAddress (
    ULONG64 Location
    )
{
    ULONG64 Value;
    ULONG result;

    if (!ReadPointer(Location,&Value)) {
        dprintf("unable to read from %08p\n",Location);
        return 0;
    }

    return Value;
}

ULONG
GetUlongValue (
    PCHAR String
    )
{
    ULONG64 Location;
    ULONG Value;
    ULONG result;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    return GetUlongFromAddress( Location );
}


ULONG64
GetPointerValue (
    PCHAR String
    )
{
    ULONG64 Location, Val=0;


    Location = GetExpression( String );
    if (!Location) {
        dprintf("unable to get %s\n",String);
        return 0;
    }

    ReadPointer(Location, &Val);

    return Val;
}
#if 0
VOID
DumpImageName(
    IN ULONG64 Process
    )
{
    ULONG64 ImageFileName;
    STRING String;
    ULONG Result;
    IN WCHAR Buf[512];


    if ( !GetFieldValue(Process, "EPROCESS", "ImageFileName.Buffer", ImageFileName ) ){

        wcscpy(Buf,L"*** image name unavailable ***");
        if ( ReadMemory( ImageFileName,
                         &String,
                         sizeof(STRING),
                         &Result) ) {
            if ( ReadMemory( (DWORD)String.Buffer,
                             &Buf[0],
                             String.Length,
                             &Result) ) {
                Buf[String.Length/sizeof(WCHAR)] = UNICODE_NULL;
            }
        }
    } else {
        wcscpy(Buf,L"System Process");
    }
    dprintf("%ws",Buf);
}
#endif

BOOLEAN
DbgRtlIsRightChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 RightChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "RightChild", RightChild)) {

        return FALSE;
    }

    if (RightChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}

BOOLEAN
DbgRtlIsLeftChild(
    ULONG64 pLinks,
    ULONG64 Parent
    )
{
    ULONG64 LeftChild;
    if (Parent == pLinks) {

        return FALSE;
    }

    if (GetFieldValue(Parent, "RTL_SPLAY_LINKS", "LeftChild", LeftChild)) {

        return FALSE;
    }

    if (LeftChild == pLinks) {

        return TRUE;
    }

    return FALSE;
}


ULONG
DumpSplayTree(
    IN ULONG64 pSplayLinks,
    IN PDUMP_SPLAY_NODE_FN DumpNodeFn
    )
/*++
    Purpose:

        Perform an in-order iteration across a splay tree, calling a
        user supplied function with a pointer to each RTL_SPLAY_LINKS
        structure encountered in the tree, and the level in the tree
        at which it was encountered (zero based).

    Arguments:

        pSplayLinks     - pointer to root of a splay tree

        DumpNodeFn      - user supplied dumping function

   Returns:

        Count of nodes encountered in the tree.

   Notes:

        Errors reading memory do not terminate the iteration if more
        work is possible.

        Consumes the Control-C flag to terminate possible loops in
        corrupt structures.

--*/
{
    ULONG Level = 0;
    ULONG NodeCount = 0;

    if (pSplayLinks) {
        ULONG64 LeftChild, RightChild, Parent, Current;

        //
        //  Retrieve the root links, find the leftmost node in the tree
        //

        if (GetFieldValue(Current = pSplayLinks,
                          "RTL_SPLAY_LINKS",
                          "LeftChild",
                          LeftChild)) {

            return NodeCount;
        }

        while (LeftChild != 0) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            if (GetFieldValue(Current = LeftChild,
                              "RTL_SPLAY_LINKS",
                              "LeftChild",
                              LeftChild)) {

                //
                //  We can try to continue from this
                //

                break;
            }

            Level++;
        }

        while (TRUE) {

            if ( CheckControlC() ) {

                return NodeCount;
            }

            NodeCount++;
            pSplayLinks = Current;
            (*DumpNodeFn)(pSplayLinks, Level);

            /*
                first check to see if there is a right subtree to the input link
                if there is then the real successor is the left most node in
                the right subtree.  That is find and return P in the following diagram

                      Links
                         \
                          .
                         .
                        .
                       /
                      P
                       \
            */

            GetFieldValue(Current, "RTL_SPLAY_LINKS", "RightChild", RightChild);
            if (RightChild != 0) {

                if (GetFieldValue(Current = RightChild,
                                  "RTL_SPLAY_LINKS",
                                  "RightChild",
                                  RightChild)) {

                    //
                    //  We've failed to step through to a successor, so
                    //  there is no more to do
                    //

                    return NodeCount;
                }

                Level++;

                GetFieldValue(Current,"RTL_SPLAY_LINKS","LeftChild",LeftChild);
                while (LeftChild != 0) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    if (GetFieldValue(Current = LeftChild,
                                     "RTL_SPLAY_LINKS",
                                     "LeftChild",
                                     LeftChild)) {

                        //
                        //  We can continue from this
                        //

                        break;
                    }

                    Level++;
                }

            } else {

                /*
                    we do not have a right child so check to see if have a parent and if
                    so find the first ancestor that we are a left decendent of. That
                    is find and return P in the following diagram

                               P
                              /
                             .
                              .
                               .
                              Links
                */

                //
                //  If the IsLeft or IsRight functions fail to read through a parent
                //  pointer, then we will quickly exit through the break below
                //

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                while (DbgRtlIsRightChild(Current, Parent)) {

                    if ( CheckControlC() ) {

                        return NodeCount;
                    }

                    Level--;
                    pSplayLinks = (Current = Parent);
                }

                GetFieldValue(Current, "RTL_SPLAY_LINKS", "Parent", Parent);
                if (!DbgRtlIsLeftChild(Current, Parent)) {

                    //
                    //  we do not have a real successor so we break out
                    //

                    break;

                } else {

                    Level--;
                    pSplayLinks = (Current = Parent);
                }
            }
        }
    }

    return NodeCount;
}

VOID
DumpUnicode64(
    UNICODE_STRING64 u
    )
{
    UNICODE_STRING v;
    DWORD BytesRead;

//    dprintf("L %x, M %x, B %p ", u.Length, u.MaximumLength, u.Buffer);
    if ((u.Length <= u.MaximumLength) &&
        (u.Buffer) &&
        (u.Length > 0)) {

        v.Buffer = LocalAlloc(LPTR, u.MaximumLength);
        if (v.Buffer != NULL) {
            v.MaximumLength = u.MaximumLength;
            v.Length = u.Length;
            if (ReadMemory(u.Buffer,
                           v.Buffer,
                           u.Length,
                           (PULONG) &u.Buffer)) {
                dprintf("%wZ", &v);
            } else {
                dprintf("<???>");
            }
            LocalFree(v.Buffer);

            return;
        }
    }
}

BOOLEAN
IsHexNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   for(;*szExpression; szExpression++) {
      
      if      ((*szExpression)< '0') { return FALSE ; } 
      else if ((*szExpression)> 'f') { return FALSE ; }
      else if ((*szExpression)>='a') { continue ;     }
      else if ((*szExpression)> 'F') { return FALSE ; }
      else if ((*szExpression)<='9') { continue ;     }
      else if ((*szExpression)>='A') { continue ;     }
      else                           { return FALSE ; }
   }
   return TRUE ;
}


BOOLEAN
IsDecNumber(
   const char *szExpression
   )
{
   if (!szExpression[0]) {
      return FALSE ;
   }

   while(*szExpression) {
      
      if      ((*szExpression)<'0') { return FALSE ; } 
      else if ((*szExpression)>'9') { return FALSE ; }
      szExpression ++ ;
   }
   return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\extsdll\image.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    peext.c

Abstract:

    This module contains the PE dump extensions

Author:

    Kent Forschmiedt (kentf) 10-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <time.h>


// STYP_ flags values for MIPS ROM images

#define STYP_REG      0x00000000
#define STYP_TEXT     0x00000020
#define STYP_INIT     0x80000000
#define STYP_RDATA    0x00000100
#define STYP_DATA     0x00000040
#define STYP_LIT8     0x08000000
#define STYP_LIT4     0x10000000
#define STYP_SDATA    0x00000200
#define STYP_SBSS     0x00000080
#define STYP_BSS      0x00000400
#define STYP_LIB      0x40000000
#define STYP_UCODE    0x00000800
#define S_NRELOC_OVFL 0x20000000

#define IMAGE_SCN_MEM_SYSHEAP       0x00010000  // Obsolete
#define IMAGE_SCN_MEM_PROTECTED     0x00004000  // Obsolete


const static char * const MachineName[] = {
    "Unknown",
    "i386",
    "Alpha AXP",
    "Alpha AXP64",
    "Intel IA64",
};

const static char * const SubsystemName[] = {
    "Unknown",
    "Native",
    "Windows GUI",
    "Windows CUI",
    "Posix CUI",
};

const static char * const DirectoryEntryName[] = {
    "Export",
    "Import",
    "Resource",
    "Exception",
    "Security",
    "Base Relocation",
    "Debug",
    "Description",
    "Special",
    "Thread Storage",
    "Load Configuration",
    "Bound Import",
    "Import Address Table",
    "Reserved",
    "Reserved",
    "Reserved",
    0
};

typedef enum DFT
{
   dftUnknown,
   dftObject,
   dftPE,
   dftROM,
   dftDBG,
   dftPEF,
} DFT;

typedef struct NB10I                   // NB10 debug info
{
    DWORD   nb10;                      // NB10
    DWORD   off;                       // offset, always 0
    DWORD   sig;
    DWORD   age;
} NB10I;

IMAGE_NT_HEADERS ImageNtHeaders;
PIMAGE_FILE_HEADER ImageFileHdr;
PIMAGE_OPTIONAL_HEADER ImageOptionalHdr;
PIMAGE_SECTION_HEADER SectionHdrs;
ULONG64 Base;
ULONG64 ImageNtHeadersAddr, ImageFileHdrAddr, ImageOptionalHdrAddr, SectionHdrsAddr;
DFT dft;


VOID
DumpHeaders (
    VOID
    );

VOID
DumpSections(
    VOID
    );

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG64 FilePointer,
    OUT PULONG64 VirtualAddress
    );

VOID
DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    );

VOID
ImageExtension(
    IN PSTR lpArgs
    );

DECLARE_API( dh )
{
    INIT_API();
    ImageExtension( (PSTR)args );
    EXIT_API();
    return S_OK;

}

VOID
ImageExtension(
    IN PSTR lpArgs
    )
{
    BOOL DoAll;
    BOOL DoSections;
    BOOL DoHeaders;
    CHAR c;
    PCHAR p;
    ULONG64 xBase;

    //
    // Evaluate the argument string to get the address of the
    // image to dump.
    //

    DoAll = TRUE;
    DoHeaders = FALSE;
    DoSections = FALSE;

    xBase = 0;

    while (*lpArgs) {

        while (isspace(*lpArgs)) {
            lpArgs++;
        }

        if (*lpArgs == '/' || *lpArgs == '-') {

            // process switch

            switch (*++lpArgs) {

                case 'a':   // dump everything we can
                case 'A':
                    ++lpArgs;
                    DoAll = TRUE;
                    break;

                default: // invalid switch

                case 'h':   // help
                case 'H':
                case '?':

                    dprintf("Usage: dh [options] address\n");
                    dprintf("\n");
                    dprintf("Dumps headers from an image based at address.\n");
                    dprintf("\n");
                    dprintf("Options:\n");
                    dprintf("\n");
                    dprintf("   -a      Dump everything\n");
                    dprintf("   -f      Dump file headers\n");
                    dprintf("   -s      Dump section headers\n");
                    dprintf("\n");

                    return;

                case 'f':
                case 'F':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoHeaders = TRUE;
                    break;

                case 's':
                case 'S':
                    ++lpArgs;
                    DoAll = FALSE;
                    DoSections = TRUE;
                    break;

            }

        } else if (*lpArgs) {

            if (xBase != 0) {
                dprintf("Invalid extra argument\n");
                return;
            }

            p = lpArgs;
            while (*p && !isspace(*p)) {
                p++;
            }
            c = *p;
            *p = 0;

            xBase = GetExpression(lpArgs);

            *p = c;
            lpArgs=p;

        }

    }

    if ( !xBase ) {
        return;
    }

    DumpImage(xBase, DoAll || DoHeaders, DoAll || DoSections);
}

VOID
DumpImage(
    ULONG64 xBase,
    BOOL DoHeaders,
    BOOL DoSections
    )
{
    IMAGE_DOS_HEADER DosHeader;
    ULONG cb;
    ULONG64 Offset;
    BOOL Ok;

    Base = xBase;

    Ok = ReadMemory(Base, &DosHeader, sizeof(DosHeader), &cb);

    if (!Ok) {
        dprintf("Can't read file header: error == %d\n", GetLastError());
        return;
    }

    if (cb != sizeof(DosHeader) || DosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
        dprintf("No file header.\n");
        return;
    }

    Offset = Base + DosHeader.e_lfanew;

    Ok = ReadMemory(Offset, &ImageNtHeaders, sizeof(ImageNtHeaders), &cb);
    ImageNtHeadersAddr = Offset;

    if (!Ok) {
        dprintf("Can't read optional header: error == %d\n", GetLastError());
        return;
    }

    if (InitTypeRead(ImageNtHeadersAddr, IMAGE_NT_HEADERS)) {
        dprintf("Bad file header.\n");
        return;
    }

    ImageFileHdr = &ImageNtHeaders.FileHeader;
    ImageFileHdrAddr = ReadField(FileHeader);
    ImageOptionalHdr = &ImageNtHeaders.OptionalHeader;
    ImageOptionalHdrAddr = ReadField(OptionalHeader);


    if ((ULONG) ReadField(FileHeader.SizeOfOptionalHeader) == GetTypeSize("IMAGE_ROM_OPTIONAL_HEADER")) {
        dft = dftROM;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_DLL) {
        dft = dftPE;
    } else if (ImageFileHdr->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) {
        dft = dftPE;
    } else if (ImageFileHdr->SizeOfOptionalHeader == 0) {
        dft = dftObject;
    } else {
        dft = dftUnknown;
    }

    if (DoHeaders) {
        DumpHeaders();
    }

    if (DoSections) {
        ULONG SectSize, NumSections;

        SectSize = GetTypeSize("IMAGE_SECTION_HEADER");

        InitTypeRead(ImageFileHdrAddr, IMAGE_FILE_HEADER);
        SectionHdrs = (PIMAGE_SECTION_HEADER) malloc((NumSections =(ULONG) ReadField(NumberOfSections) )* 
                                                     SectSize);
        try {

            SectionHdrsAddr = Offset + GetTypeSize("IMAGE_NT_HEADERS") + 
                ReadField(SizeOfOptionalHeader) - GetTypeSize("IMAGE_OPTIONAL_HEADER");
            Ok = ReadMemory(
                            SectionHdrsAddr,
                            SectionHdrs,
                            (NumSections) * SectSize,
                            &cb);

            if (!Ok) {
                dprintf("Can't read section headers.\n");
            } else {

                if (cb != NumSections * SectSize) {
                    dprintf("\n***\n*** Some section headers may be missing ***\n***\n\n");
                    NumSections = (USHORT)(cb / SectSize);
                }

                DumpSections( );

            }

        }
        finally {

            if (SectionHdrs) {
                free(SectionHdrs);
                SectionHdrs = 0;
            }

        }

    }

}

VOID
DumpHeaders (
    VOID
    )

/*++

Routine Description:

    Formats the file header and optional header.

Arguments:

    None.

Return Value:

    None.

--*/

{
    int i, j;
    const char *time;
    const char *name;
    DWORD dw;
    ULONG TimeDateStamp, SizeOfOptionalHeader, DirOff, DirSize;


    InitTypeRead(ImageFileHdrAddr, IMAGE_FILE_HEADER);
    // Print out file type

    switch (dft) {
        case dftObject :
            dprintf("\nFile Type: COFF OBJECT\n");
            break;

        case dftPE :
            if (ReadField(Characteristics) & IMAGE_FILE_DLL) {
                dprintf("\nFile Type: DLL\n");
            } else {
                dprintf("\nFile Type: EXECUTABLE IMAGE\n");
            }
            break;

        case dftROM :
            dprintf("\nFile Type: ROM IMAGE\n");
            break;

        default :
            dprintf("\nFile Type: UNKNOWN\n");
            break;

    }

    switch (ReadField(Machine)) {
        case IMAGE_FILE_MACHINE_I386     : i = 1; break;
        case IMAGE_FILE_MACHINE_ALPHA    : i = 2; break;
        case IMAGE_FILE_MACHINE_ALPHA64  : i = 3; break;
        case IMAGE_FILE_MACHINE_IA64     : i = 4; break;
        default : i = 0;
    }

    dprintf(
           "FILE HEADER VALUES\n"
           "%8hX machine (%s)\n"
           "%8hX number of sections\n"
           "%8lX time date stamp",
           (ULONG) ReadField(Machine),
           MachineName[i],
           (ULONG) ReadField(NumberOfSections),
           TimeDateStamp = (ULONG) ReadField(TimeDateStamp));

    if ((time = ctime((time_t *) &TimeDateStamp)) != NULL) {
        dprintf( " %s", time);
    }
    dprintf("\n");

    dprintf(
           "%8lX file pointer to symbol table\n"
           "%8lX number of symbols\n"
           "%8hX size of optional header\n"
           "%8hX characteristics\n",
           (ULONG) ReadField(PointerToSymbolTable),
           (ULONG) ReadField(NumberOfSymbols),
           SizeOfOptionalHeader = (ULONG) ReadField(SizeOfOptionalHeader),
           (ULONG) ReadField(Characteristics));

    for (dw = (ULONG) ReadField(Characteristics), j = 0; dw; dw >>= 1, j++) {
        if (dw & 1) {
            switch (1 << j) {
                case IMAGE_FILE_RELOCS_STRIPPED     : name = "Relocations stripped"; break;
                case IMAGE_FILE_EXECUTABLE_IMAGE    : name = "Executable"; break;
                case IMAGE_FILE_LINE_NUMS_STRIPPED  : name = "Line numbers stripped"; break;
                case IMAGE_FILE_LOCAL_SYMS_STRIPPED : name = "Symbols stripped"; break;
                case IMAGE_FILE_BYTES_REVERSED_LO   : name = "Bytes reversed"; break;
                case IMAGE_FILE_32BIT_MACHINE       : name = "32 bit word machine"; break;
                case IMAGE_FILE_DEBUG_STRIPPED      : name = "Debug information stripped"; break;
                case IMAGE_FILE_SYSTEM              : name = "System"; break;
                case IMAGE_FILE_DLL                 : name = "DLL"; break;
                case IMAGE_FILE_BYTES_REVERSED_HI   : name = ""; break;
                default : name = "RESERVED - UNKNOWN";
            }

            if (*name) {
                dprintf( "            %s\n", name);
            }
        }
    }

    if (SizeOfOptionalHeader != 0) {
        char szLinkerVersion[30];
        ULONG Ptr64 = IsPtr64();

        InitTypeRead(ImageOptionalHdrAddr, IMAGE_OPTIONAL_HEADER);

        sprintf(szLinkerVersion,
                "%u.%02u",
                (ULONG) ReadField(MajorLinkerVersion),
                (ULONG) ReadField(MinorLinkerVersion));

        dprintf(
                "\n"
                "OPTIONAL HEADER VALUES\n"
                "%8hX magic #\n"
                "%8s linker version\n"
                "%8lX size of code\n"
                "%8lX size of initialized data\n"
                "%8lX size of uninitialized data\n"
                "%8P address of entry point\n"
                "%8P base of code\n"
                
                ,
                (ULONG) ReadField(Magic),
                szLinkerVersion,
                (ULONG) ReadField(SizeOfCode),
                (ULONG) ReadField(SizeOfInitializedData),
                (ULONG) ReadField(SizeOfUninitializedData),
                ReadField(AddressOfEntryPoint),
                ReadField(BaseOfCode)
                );
        if (Ptr64) {
            dprintf("%8P base of data\n",
                    ReadField(BaseOfData));

        }
    }

    if (dft == dftROM) {
        PIMAGE_ROM_OPTIONAL_HEADER romOptionalHdr;

        InitTypeRead(ImageOptionalHdrAddr, IMAGE_ROM_OPTIONAL_HEADER);
//        romOptionalHdr = (PIMAGE_ROM_OPTIONAL_HEADER) &ImageOptionalHdr;
        dprintf(
               "         ----- rom -----\n"
               "%8lX base of bss\n"
               "%8lX gpr mask\n"
               "         cpr mask\n"
               "         %08lX %08lX %08lX %08lX\n"
               "%8hX gp value\n",
               (ULONG) ReadField(BaseOfBss),
               (ULONG) ReadField(GprMask),
               (ULONG) ReadField(CprMask[0]),
               (ULONG) ReadField(CprMask[1]),
               (ULONG) ReadField(CprMask[2]),
               (ULONG) ReadField(CprMask[3]),
               (ULONG) ReadField(GpValue));
    }

    if (SizeOfOptionalHeader == GetTypeSize("IMAGE_OPTIONAL_HEADER")) {
        char szOSVersion[30];
        char szImageVersion[30];
        char szSubsystemVersion[30];

        InitTypeRead(ImageOptionalHdrAddr, IMAGE_OPTIONAL_HEADER);
        
        switch ((ULONG) ReadField(Subsystem)) {
            case IMAGE_SUBSYSTEM_POSIX_CUI   : i = 4; break;
            case IMAGE_SUBSYSTEM_WINDOWS_CUI : i = 3; break;
            case IMAGE_SUBSYSTEM_WINDOWS_GUI : i = 2; break;
            case IMAGE_SUBSYSTEM_NATIVE      : i = 1; break;
            default : i = 0;
        }

        sprintf(szOSVersion,
                "%hu.%02hu",
                (USHORT) ReadField(MajorOperatingSystemVersion),
                (USHORT) ReadField(MinorOperatingSystemVersion));

        sprintf(szImageVersion,
                "%hu.%02hu",
                (USHORT) ReadField(MajorImageVersion),
                (USHORT) ReadField(MinorImageVersion));

        sprintf(szSubsystemVersion,
                "%hu.%02hu",
                (USHORT) ReadField(MajorSubsystemVersion),
                (USHORT) ReadField(MinorSubsystemVersion));

        dprintf(
                "         ----- new -----\n"
                "%p image base\n"
                "%8lX section alignment\n"
                "%8lX file alignment\n"
                "%8hX subsystem (%s)\n"
                "%8s operating system version\n"
                "%8s image version\n"
                "%8s subsystem version\n",
                ReadField(ImageBase),
                (ULONG) ReadField(SectionAlignment),
                (ULONG) ReadField(FileAlignment),
                (USHORT) ReadField(Subsystem),
                SubsystemName[i],
                szOSVersion,
                szImageVersion,
                szSubsystemVersion);
        dprintf(
                "%8lX size of image\n"
                "%8lX size of headers\n"
                "%8lX checksum\n"
                "%p size of stack reserve\n"
                "%p size of stack commit\n"
                "%p size of heap reserve\n"
                "%p size of heap commit\n",
                (ULONG) ReadField(SizeOfImage),
                (ULONG) ReadField(SizeOfHeaders),
                (ULONG) ReadField(CheckSum),
                ReadField(SizeOfStackReserve),
                ReadField(SizeOfStackCommit),
                ReadField(SizeOfHeapReserve),
                ReadField(SizeOfHeapCommit));

        dprintf("%p Opt Hdr\n", ImageOptionalHdrAddr);
        GetFieldOffset("IMAGE_OPTIONAL_HEADER", "DataDirectory", &DirOff);
        DirSize = GetTypeSize("IMAGE_DATA_DIRECTORY");
        
        for (i = 0; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++) {
            if (!DirectoryEntryName[i]) {
                break;
            }

            InitTypeRead(ImageOptionalHdrAddr + DirOff + i*DirSize, IMAGE_DATA_DIRECTORY);
            dprintf( "%8P [%8lX] address [size] of %s Directory\n",
                    ReadField(VirtualAddress),
                    (ULONG) ReadField(Size),
                    DirectoryEntryName[i]
                   );
        }

        dprintf( "\n" );
    }
}


VOID
DumpSectionHeader (
    IN DWORD i,
    IN ULONG64 Sh
    )
{
    const char *name;
    char *szUnDName;
    DWORD li, lj;
    WORD memFlags;
    CHAR Name[40];

    InitTypeRead(Sh, IMAGE_SECTION_HEADER);
    GetFieldValue(Sh, "IMAGE_SECTION_HEADER", "Name", Name);

    dprintf("\nSECTION HEADER #%hX\n%8.8s name", i, Name);

#if 0
    if (Sh->Name[0] == '/') {
        name = SzObjSectionName((char *) Sh->Name, (char *) DumpStringTable);

        dprintf(" (%s)", name);
    }
#endif
    dprintf( "\n");

    dprintf( "%8P %s\n"
             "%8lX virtual address\n"
             "%8lX size of raw data\n"
             "%8lX file pointer to raw data\n"
             "%8lX file pointer to relocation table\n",
           ReadField(Misc.PhysicalAddress),
           (dft == dftObject) ? "physical address" : "virtual size",
           (ULONG) ReadField(VirtualAddress),
           (ULONG) ReadField(SizeOfRawData),
           (ULONG) ReadField(PointerToRawData),
           (ULONG) ReadField(PointerToRelocations));

    dprintf( "%8lX file pointer to line numbers\n"
                        "%8hX number of relocations\n"
                        "%8hX number of line numbers\n"
                        "%8lX flags\n",
           (ULONG) ReadField(PointerToLinenumbers),
           (ULONG) ReadField(NumberOfRelocations),
           (ULONG) ReadField(NumberOfLinenumbers),
           (ULONG) ReadField(Characteristics));

    memFlags = 0;

    li = (ULONG) ReadField(Characteristics);

    if (dft == dftROM) {
       for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case STYP_REG   : name = "Regular"; break;
                    case STYP_TEXT  : name = "Text"; memFlags = 1; break;
                    case STYP_INIT  : name = "Init Code"; memFlags = 1; break;
                    case STYP_RDATA : name = "Data"; memFlags = 2; break;
                    case STYP_DATA  : name = "Data"; memFlags = 6; break;
                    case STYP_LIT8  : name = "Literal 8"; break;
                    case STYP_LIT4  : name = "Literal 4"; break;
                    case STYP_SDATA : name = "GP Init Data"; memFlags = 6; break;
                    case STYP_SBSS  : name = "GP Uninit Data"; memFlags = 6; break;
                    case STYP_BSS   : name = "Uninit Data"; memFlags = 6; break;
                    case STYP_LIB   : name = "Library"; break;
                    case STYP_UCODE : name = "UCode"; break;
                    case S_NRELOC_OVFL : name = "Non-Relocatable overlay"; memFlags = 1; break;
                    default : name = "RESERVED - UNKNOWN";
                }

                dprintf( "         %s\n", name);
            }
        }
    } else {
        // Clear the padding bits

        li &= ~0x00700000;

        for (lj = 0L; li; li = li >> 1, lj++) {
            if (li & 1) {
                switch ((li & 1) << lj) {
                    case IMAGE_SCN_TYPE_NO_PAD  : name = "No Pad"; break;

                    case IMAGE_SCN_CNT_CODE     : name = "Code"; break;
                    case IMAGE_SCN_CNT_INITIALIZED_DATA : name = "Initialized Data"; break;
                    case IMAGE_SCN_CNT_UNINITIALIZED_DATA : name = "Uninitialized Data"; break;

                    case IMAGE_SCN_LNK_OTHER    : name = "Other"; break;
                    case IMAGE_SCN_LNK_INFO     : name = "Info"; break;
                    case IMAGE_SCN_LNK_REMOVE   : name = "Remove"; break;
                    case IMAGE_SCN_LNK_COMDAT   : name = "Communal"; break;

                    case IMAGE_SCN_MEM_DISCARDABLE: name = "Discardable"; break;
                    case IMAGE_SCN_MEM_NOT_CACHED: name = "Not Cached"; break;
                    case IMAGE_SCN_MEM_NOT_PAGED: name = "Not Paged"; break;
                    case IMAGE_SCN_MEM_SHARED   : name = "Shared"; break;
                    case IMAGE_SCN_MEM_EXECUTE  : name = ""; memFlags |= 1; break;
                    case IMAGE_SCN_MEM_READ     : name = ""; memFlags |= 2; break;
                    case IMAGE_SCN_MEM_WRITE    : name = ""; memFlags |= 4; break;

                    case IMAGE_SCN_MEM_FARDATA  : name = "Far Data"; break;
                    case IMAGE_SCN_MEM_SYSHEAP  : name = "Sys Heap"; break;
                    case IMAGE_SCN_MEM_PURGEABLE: name = "Purgeable or 16-Bit"; break;
                    case IMAGE_SCN_MEM_LOCKED   : name = "Locked"; break;
                    case IMAGE_SCN_MEM_PRELOAD  : name = "Preload"; break;
                    case IMAGE_SCN_MEM_PROTECTED: name = "Protected"; break;

                    default : name = "RESERVED - UNKNOWN";
                }

                if (*name) {
                    dprintf( "         %s\n", name);
                }
            }
        }

        // print alignment

        switch ((ULONG) ReadField(Characteristics) & 0x00700000) {
            default:                      name = "(no align specified)"; break;
            case IMAGE_SCN_ALIGN_1BYTES:  name = "1 byte align";  break;
            case IMAGE_SCN_ALIGN_2BYTES:  name = "2 byte align";  break;
            case IMAGE_SCN_ALIGN_4BYTES:  name = "4 byte align";  break;
            case IMAGE_SCN_ALIGN_8BYTES:  name = "8 byte align";  break;
            case IMAGE_SCN_ALIGN_16BYTES: name = "16 byte align"; break;
            case IMAGE_SCN_ALIGN_32BYTES: name = "32 byte align"; break;
            case IMAGE_SCN_ALIGN_64BYTES: name = "64 byte align"; break;
        }

        dprintf( "         %s\n", name);
    }

    if (memFlags) {
        switch(memFlags) {
            case 1 : name = "Execute Only"; break;
            case 2 : name = "Read Only"; break;
            case 3 : name = "Execute Read"; break;
            case 4 : name = "Write Only"; break;
            case 5 : name = "Execute Write"; break;
            case 6 : name = "Read Write"; break;
            case 7 : name = "Execute Read Write"; break;
            default : name = "Unknown Memory Flags"; break;
        }
        dprintf( "         %s\n", name);
    }
}

VOID
DumpDebugDirectory (
    IN ULONG64 DebugDir
    )
{
    BOOL Ok;
    DWORD cb;
    NB10I nb10i;
    PIMAGE_DEBUG_MISC miscData;
    PIMAGE_DEBUG_MISC miscDataCur;
    ULONG64 VirtualAddress;
    DWORD len;

    InitTypeRead(DebugDir, IMAGE_DEBUG_DIRECTORY );
    switch ((ULONG) ReadField(Type)){
        case IMAGE_DEBUG_TYPE_COFF:
            dprintf( "\tcoff   ");
            break;
        case IMAGE_DEBUG_TYPE_CODEVIEW:
            dprintf( "\tcv     ");
            break;
        case IMAGE_DEBUG_TYPE_FPO:
            dprintf( "\tfpo    ");
            break;
        case IMAGE_DEBUG_TYPE_MISC:
            dprintf( "\tmisc   ");
            break;
        case IMAGE_DEBUG_TYPE_FIXUP:
            dprintf( "\tfixup  ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_TO_SRC:
            dprintf( "\t-> src ");
            break;
        case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC:
            dprintf( "\tsrc -> ");
            break;
        case IMAGE_DEBUG_TYPE_EXCEPTION:
            dprintf( "\tpdata  ");
            break;
        default:
            dprintf( "\t(%6lu)", (ULONG) ReadField(Type));
            break;
    }
    dprintf( "%8x    %8x %8x",
                (ULONG) ReadField(SizeOfData),
                (ULONG) ReadField(AddressOfRawData),
                (ULONG) ReadField(PointerToRawData));

    if ((ULONG) ReadField(PointerToRawData) &&
        (ULONG) ReadField(Type) == IMAGE_DEBUG_TYPE_MISC)
    {

        if (!TranslateFilePointerToVirtualAddress(ReadField(PointerToRawData), &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = (ULONG) ReadField(SizeOfData);
            miscData = (PIMAGE_DEBUG_MISC) malloc(len);
            try {
                Ok = ReadMemory(Base + VirtualAddress, miscData, len, &cb);

                if (!Ok || cb != len) {
                    dprintf("Can't read debug data\n");
                } else {

                    miscDataCur = miscData;
                    do {
                        if (miscDataCur->DataType == IMAGE_DEBUG_MISC_EXENAME) {
                            if (ImageOptionalHdr->MajorLinkerVersion == 2 &&
                                ImageOptionalHdr->MinorLinkerVersion < 37) {
                                dprintf( "\tImage Name: %s", miscDataCur->Reserved);
                            } else {
                                dprintf( "\tImage Name: %s", miscDataCur->Data);
                            }
                            break;
                        }
                        len -= miscDataCur->Length;
                        miscDataCur = (PIMAGE_DEBUG_MISC) ((PCHAR) miscDataCur + miscData->Length);
                    } while (len > 0);

                }

            }
            finally {
                if (miscData) {
                    free(miscData);
                }
            }
        }
    }

    if ((ULONG) ReadField(PointerToRawData) &&
        (ULONG) ReadField(Type) == IMAGE_DEBUG_TYPE_CODEVIEW)
    {
        if (!TranslateFilePointerToVirtualAddress((ULONG) ReadField(PointerToRawData), &VirtualAddress)) {
            dprintf(" [Debug data not mapped]\n");
        } else {

            len = (ULONG) ReadField(SizeOfData);

            Ok = ReadMemory(Base + VirtualAddress, &nb10i, sizeof(nb10i), &cb);

            if (!Ok || cb != sizeof(nb10i)) {
                dprintf("Can't read debug data\n");
            } else {
                dprintf( "\tFormat: %4.4s", &nb10i.nb10);

                if (nb10i.nb10 == '01BN') {
                    CHAR PdbName[MAX_PATH];
                    
                    if ((len - sizeof(nb10i) > MAX_PATH))
                        len = MAX_PATH;

                    Ok = ReadMemory(Base + VirtualAddress + sizeof(nb10i), PdbName, len-sizeof(nb10i), &cb);
                    if (!Ok || cb != len-sizeof(nb10i)) {
                        strcpy(PdbName, "<pdb name unavailable>");
                    }
                    dprintf( ", %x, %x, %s", nb10i.sig, nb10i.age, PdbName);
                }
            }
        }

    }

    dprintf( "\n");
}



VOID
DumpDebugDirectories (
    ULONG64 sh
    )

/*++

Routine Description:

    Print out the contents of all debug directories

Arguments:

    sh - Section header for section that contains debug dirs

Return Value:

    None.

--*/
{
    int                numDebugDirs;
    IMAGE_DEBUG_DIRECTORY      debugDir;
    ULONG64            DebugDirAddr;
    ULONG64            pc;
    ULONG64 VA;
    DWORD              cb, Sz, DebugDirSize;
    BOOL               Ok;

    Sz = GetTypeSize("IMAGE_DATA_DIRECTORY");
    DebugDirSize = GetTypeSize("IMAGE_DEBUG_DIRECTORY");
    if (dft == dftROM) {

        GetFieldValue(sh, "IMAGE_SECTION_HEADER", "VirtualAddress", VA);
        DebugDirAddr = Base + VA;
        pc = DebugDirAddr;
        if (InitTypeRead(pc, IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir @%p\n", pc);
            return;
        }

        numDebugDirs = 0;
        while (ReadField(Type) != 0) {
            numDebugDirs++;
            pc += DebugDirSize;
            if (InitTypeRead(pc, IMAGE_DEBUG_DIRECTORY)) {
                break;
            }
        }
    } else {
        ULONG Off, DirSize;

        GetFieldOffset("IMAGE_OPTIONAL_HEADER", "DataDirectory", &Off);

        GetFieldValue(ImageOptionalHdrAddr + Off + Sz*IMAGE_DIRECTORY_ENTRY_DEBUG, 
                      "IMAGE_DATA_DIRECTORY", "VirtualAddress", VA);
        GetFieldValue(ImageOptionalHdrAddr + Off + Sz*IMAGE_DIRECTORY_ENTRY_DEBUG, 
                      "IMAGE_DATA_DIRECTORY", "Size", DirSize);
        
        DebugDirAddr = Base + VA; // ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
        numDebugDirs = DirSize / DebugDirSize; 
//        dprintf(" DD @%p, DD addr %p\n", ImageOptionalHdrAddr + Off + Sz*IMAGE_DIRECTORY_ENTRY_DEBUG,
  //              DebugDirAddr);
        // ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);
    }

    dprintf("\n\nDebug Directories(%d)\n",numDebugDirs);
    dprintf("\tType       Size     Address  Pointer\n\n");
    pc = DebugDirAddr;
    while (numDebugDirs) {
        if (InitTypeRead(pc, IMAGE_DEBUG_DIRECTORY)) {
            dprintf("Can't read debug dir @%p\n", pc);
            break;
        }
        DumpDebugDirectory(pc);
        pc += Sz;
        numDebugDirs--;
    }
}



VOID
DumpSections(
    VOID
    )
{
    ULONG64 sh;
    const char *p;
    DWORD64 li;
    DWORD cb;
    BOOL Ok;
    ULONG i, j;
    CHAR szName[IMAGE_SIZEOF_SHORT_NAME + 1];
    ULONG NumberOfSections, SectSize, Characteristics;


    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "NumberOfSections", NumberOfSections);
    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "Characteristics", Characteristics);
    SectSize = GetTypeSize("IMAGE_SECTION_HEADER");

    for (i = 1; i <= NumberOfSections; i++) {

        sh = SectionHdrsAddr + (i-1)*SectSize;

        //szName = SzObjSectionName((char *) sh.Name, (char *) DumpStringTable);
        GetFieldValue(sh, "IMAGE_SECTION_HEADER", "Name", szName);
        // strncpy(szName, (char *) sh.Name, IMAGE_SIZEOF_SHORT_NAME);
        szName[IMAGE_SIZEOF_SHORT_NAME] = 0;

        DumpSectionHeader(i, sh);

        if (dft == dftROM) {

            if (!(Characteristics & IMAGE_FILE_DEBUG_STRIPPED)) {

                // If we're looking at the .rdata section and the symbols
                // aren't stripped, the debug directory must be here.

                if (!strcmp(szName, ".rdata")) {

                    DumpDebugDirectories(sh);

                    //DumpDebugData(&sh);
                }
            }

        } else if (dft == dftPE) {
            UCHAR tmp[40];
            ULONG64 VA;

            sprintf(tmp, "DataDirectory[%d].VirtualAddress", IMAGE_DIRECTORY_ENTRY_DEBUG);
            GetFieldValue(ImageOptionalHdrAddr, "IMAGE_OPTIONAL_HEADER", tmp, li);
//            dprintf("Opt Hdr %p, %s = %p", ImageOptionalHdrAddr, tmp, li);

            if (li != 0) {
                InitTypeRead(sh, IMAGE_SECTION_HEADER);
                VA = ReadField(VirtualAddress);
                if (li >= VA && li < (VA + ReadField(SizeOfRawData))) {
                    DumpDebugDirectories(sh);

                    //DumpDebugData(&sh);
                }
            }


#if 0
            if (Switch.Dump.PData) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpFunctionTable(pimage, rgsym, (char *) DumpStringTable, &sh);
                }
            }

            if (Switch.Dump.Imports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    DumpImports(&sh);
                }
            }

            if (Switch.Dump.Exports) {
                li = ImageOptionalHdr->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

                if ((li != 0) && (li >= sh.VirtualAddress) && (li < sh.VirtualAddress+sh.SizeOfRawData)) {
                    // UNDONE: Is this check really necessary?

                    if (ImageFileHdr->Machine != IMAGE_FILE_MACHINE_MPPC_601) {
                        DumpExports(&sh);
                    }
                }
            }

#endif

        }

    }
}

BOOL
TranslateFilePointerToVirtualAddress(
    IN ULONG64 FilePointer,
    OUT PULONG64 VirtualAddress
    )
{
    ULONG i;
    ULONG64 sh;
    ULONG NumberOfSections, SectSize, Characteristics;


    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "NumberOfSections", NumberOfSections);
    GetFieldValue(ImageFileHdrAddr, "IMAGE_FILE_HEADER", "Characteristics", Characteristics);
    SectSize = GetTypeSize("IMAGE_SECTION_HEADER");


    for (i = 1; i <= NumberOfSections; i++) {
        sh = SectionHdrsAddr + (i-1)*SectSize;

        InitTypeRead(sh, IMAGE_SECTION_HEADER);
        if (ReadField(PointerToRawData) <= FilePointer &&
            FilePointer < ReadField(PointerToRawData) + ReadField(SizeOfRawData)) {

            *VirtualAddress = FilePointer - ReadField(PointerToRawData) + ReadField(VirtualAddress);
            return TRUE;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\bugcheck.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    bugcheck.cpp

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:
 
    Andre Vachon (andreva)
    
    bugcheck analyzer.

--*/

#include "precomp.h"
#include <kdextsfn.h>

#pragma hdrstop

extern BUGDESC_APIREFS g_BugDescApiRefs[];
extern ULONG           g_NumBugDescApiRefs;

PSTR g_PoolRegion[DbgPoolRegionMax] = {
    "Unknown",                      // DbgPoolRegionUnknown,               
    "Special pool",                 // DbgPoolRegionSpecial,             
    "Paged pool",                   // DbgPoolRegionPaged,               
    "Nonpaged pool",                // DbgPoolRegionNonPaged,            
    "Pool code",                    // DbgPoolRegionCode,                
    "Nonpaged pool expansion",      // DbgPoolRegionNonPagedExpansion,   
};                                  


BOOL
AnalyzeCrashInfo(
    PBUGCHECK_ANALYSIS Bc,
    BOOL Verbose
    );

void
GetCrashInfoFromBugCheck(
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    );

HRESULT
BugCheckCE(
    PDEBUG_CLIENT Client,
    PBUGCHECK_ANALYSIS Bc
    )
{
    HRESULT Status;
    ULONG Index;
    ULONG64 BaseAddress;
    CHAR ImageNameBuffer[512];


    //
    // The address at fault is in parameter 1
    //

    dprintf("Faulting code address : %p\n", Bc->Args[0]);

    Status = E_FAIL;

    if (Bc->Args[0])
    {
        Status = g_ExtSymbols->GetModuleByOffset(Bc->Args[0], 0,
                                                 &Index, &BaseAddress);
        if (Status == S_OK)
        {
            Status = g_ExtSymbols->GetModuleNames(DEBUG_ANY_ID, BaseAddress,
                                                  ImageNameBuffer,
                                                  sizeof(ImageNameBuffer),
                                                  NULL, NULL, 0, NULL,
                                                  NULL, 0, NULL);
        }
    }

    if (Status == S_OK)
    {
        dprintf("Possible faulting driver name  : %s\n", ImageNameBuffer);
        dprintf("                                 BaseAddress = %p\n", BaseAddress);
        dprintf("                                 Offset = %p\n", Bc->Args[0]-BaseAddress);
    }
    else
    {
        dprintf("Faulting driver name  : UNKNOWN\n");
    }

    return Status;
}



/*
   Get the description record for a bugcheck code.
*/

BOOL
GetBugCheckDescription(
    PBUGCHECK_ANALYSIS Bc
    )
{
    ULONG i;
    for (i=0; i<g_NumBugDescApiRefs; i++) {
        if (g_BugDescApiRefs[i].Code == Bc->Code) {
            (g_BugDescApiRefs[i].pExamineRoutine)(Bc);
            return TRUE;
        }
    }
    return FALSE;
}

void
PrintBugDescription(
    PBUGCHECK_ANALYSIS pBugCheck
    )
{
    LPTSTR Name = pBugCheck->szName;
    LPTSTR Description = pBugCheck->szDescription;

    if (!Name)
    {
        Name = "Unknown bugcheck code";
    }

    if (!Description)
    {
        Description = "Unknown bugcheck description\n";
    }

    dprintf("%s (%lx)\n%s", Name, pBugCheck->Code, Description);

    dprintf("Arguments:\n");
    for (ULONG i=0; i<4; i++) {
        dprintf("Arg%lx: %p",i+1,pBugCheck->Args[i]);
        if (pBugCheck->szParamsDesc[i]) {
            dprintf(", %s", pBugCheck->szParamsDesc[i]);
        }
        dprintf("\n");
    }
}

DECLARE_API( analyzebugcheck )

/*++

Routine Description:

    analyze a bugcheck.

Arguments:

    None.

Return Value:

    None.

--*/


{
    BUGCHECK_ANALYSIS Bc = {0};
    BOOL Verbose=FALSE;

    INIT_API();

    while (*args == ' ' || *args == '\t') args++;

    while (*args == '-') {
        ++args;
        switch (*args) {
        case 'v':
            Verbose = TRUE;
            ++args;
            break;
        case 's':
            if (!strncmp(args, "show",4))
            {
                ULONG64 Code;
                args+=4;
                GetExpressionEx(args, &Code, &args);
                Bc.Code = (ULONG)Code;
                GetBugCheckDescription(&Bc);
                PrintBugDescription(&Bc);
                EXIT_API();
                return Status;
            }

        default:
            dprintf("Unknown option %c\n", *args);
            break;
        }
        while (*args == ' ' || *args == '\t') args++;
    }

    Status = g_ExtControl->ReadBugCheckData(&Bc.Code, &Bc.Args[0], &Bc.Args[1],
                                            &Bc.Args[2], &Bc.Args[3]);

    if (Status != S_OK)
    {
        EXIT_API();
        return Status;
    }

#if 0 
    // disable this
    if (Bc.Code == 0) {
        //
        // It might be watchdog bugcheck
        //
        ULONG64 WdBcAddr;
        ULONG res;

        WdBcAddr = GetExpression("watchdog!g_WdBugCheckData");
        if (WdBcAddr &&
            ReadMemory(WdBcAddr, &Bc.Code, sizeof(Bc.Code), &res) &&
            ReadPointer(WdBcAddr+sizeof(Bc.Code), &Bc.Args[0]) &&
            ReadPointer(WdBcAddr+sizeof(Bc.Code), &Bc.Args[1]) &&
            ReadPointer(WdBcAddr+sizeof(Bc.Code), &Bc.Args[2]) &&
            ReadPointer(WdBcAddr+sizeof(Bc.Code), &Bc.Args[3])) {
        
            dprintf("\n*** Watchdog bugcheck.\n");
        }
    }
#endif

    Status = AnalyzeCrashInfo(&Bc, Verbose) ? S_OK : E_FAIL;

    if (!Verbose) {
        EXIT_API();
        return Status;
    }

    switch (Bc.Code)
    {
    case 0xCE:
        Status = BugCheckCE(Client, &Bc);
        break;

    default:
        break;
    }

    //
    // Create a new minidump file of this crash
    //
#if 0
    ULONG FailTime = 0;
    ULONG UpTime = 0;
    CHAR  CurrentTime[20];
    CHAR  CurrentDate[20];
    CHAR  Buffer[MAX_PATH];

    g_ExtControl->GetCurrentTimeDate(&FailTime);
    g_ExtControl->GetCurrentSystemUpTime(&UpTime);
    _strtime(CurrentTime);
    _strdate(CurrentDate);

    if (CurrentTime && UpTime)
    {
        sprintf(Buffer, "Dump%s-%s-%08lx-%08lx-%s.dmp",
                FailTime, Uptime, Currentdate, CurrentTime);
        Status = g_ExtClient->WriteDumpFile(Buffer ,DEBUG_DUMP_SMALL);
    }
#endif

    CHAR  Buffer[MAX_PATH];
    if (GetTempFileName(".", "DMP", 0, Buffer))
    {
        Status = g_ExtClient->WriteDumpFile(Buffer ,DEBUG_DUMP_SMALL);

        if (Status == S_OK)
        {
            //
            // We create a file - now lets send it to the database
            //

            //CopyFile(Buffer, "c:\\xxxx", 0);
            DeleteFile(Buffer);
        }
    }

    dprintf("\n\n");
    EXIT_API();
    return S_OK;
}

EXTENSION_API( GetKerFailureAnalysis )(
    IN PDEBUG_CLIENT Client,
    OUT PDEBUG_FAILURE_ANALYSIS* pAnalysis
    )
{
    BUGCHECK_ANALYSIS Bc = {0};
    BOOL Verbose;

    INIT_API();

    Status = g_ExtControl->ReadBugCheckData(&Bc.Code, &Bc.Args[0], &Bc.Args[1],
                                            &Bc.Args[2], &Bc.Args[3]);

    if (Status != S_OK)
    {
        EXIT_API();
        return Status;
    }

    GetCrashInfoFromBugCheck(&Bc, pAnalysis);

    Status = *pAnalysis ? S_OK : E_FAIL;
    EXIT_API();
    return Status;
}

#define MAX_STACK_FRAMES 50

#define DWORD_ALIGN(n)  (((n+sizeof(DWORD)-1)/n)*n)

#define DECL_GETINFO(bcname)         \
        void                         \
        GetInfoFor##bcname (         \
            PBUGCHECK_ANALYSIS Bc,   \
            PDEBUG_FAILURE_ANALYSIS *pCrashInfo \
            )

           
DECL_GETINFO( DRIVER_CAUGHT_MODIFYING_FREED_POOL );
DECL_GETINFO( DRIVER_VERIFIER_IOMANAGER_VIOLATION );
DECL_GETINFO( IRQL_NOT_LESS_OR_EQUAL );
DECL_GETINFO( KMODE_EXCEPTION_NOT_HANDLED );
DECL_GETINFO( SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION );
DECL_GETINFO( TIMER_OR_DPC_INVALID );
DECL_GETINFO( UNEXPECTED_KERNEL_MODE_TRAP );
DECL_GETINFO( DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL );


BOOL
AddContextInfoFromStack(
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    );

BOOL 
GetTrapFromStackFrameFPO(
    PDEBUG_STACK_FRAME StackFrame,
    PULONG64 TrapFrame
    );


ULONG64 
GetImplicitContextInstrOffset( void )
{
    ULONG64 IP=0;
    switch (TargetMachine) {
    case IMAGE_FILE_MACHINE_I386:
        IP = GetExpression("@eip");
        break;
    case IMAGE_FILE_MACHINE_IA64:
        IP = GetExpression("@iip");
        break;

    case IMAGE_FILE_MACHINE_AMD64:
        IP = GetExpression("@rip");
        break;
    }
    return IP;
}

BOOL
AnalyzeValue(
    PDEBUG_FLR_PARAM_VALUES pCrashParam,
    BOOL Verbose,
    BOOL ShowFollowup
    )
{
    CHAR Buffer[MAX_PATH];
    CHAR Module[MAX_PATH];
    ULONG64 Base;
    ULONG64 Address;
    BOOL ShowFollowForBufferName = FALSE;
    ULONG OutCtl;



    if (!Verbose) {
        // show only info directly related to faulting driver
        if (((pCrashParam->ParamType & 0xf0000000) != DEBUG_FLR_IP) &&
            ((pCrashParam->ParamType & 0xf0000000) != DEBUG_FLR_THREAD)) {
            return FALSE;
        }
        OutCtl = DEBUG_OUTCTL_IGNORE;
    } else {
        OutCtl = DEBUG_OUTCTL_AMBIENT;
    }
    switch (pCrashParam->ParamType) {
    default:
        dprintf("Unknown type %lx, value %p\n", pCrashParam->ParamType, pCrashParam->Value);
        return FALSE;
    case DEBUG_FLR_CONTEXT:
        if (Verbose) {
            dprintf("Context %p\n", pCrashParam->Value);
        }
        sprintf(Buffer, ".cxr %I64lx", pCrashParam->Value);
        g_ExtControl->Execute(OutCtl,Buffer,DEBUG_EXECUTE_DEFAULT);
        if (Verbose) {
            g_ExtControl->Execute(OutCtl,"k",DEBUG_EXECUTE_DEFAULT);
        } else if (ShowFollowup) {
            ULONG64 Disp;
            // Get symbol for IP in the context
            Address = GetImplicitContextInstrOffset();
            Buffer[0] = 0;
            GetSymbol(Address, Buffer, &Disp);
            Module[0] = 0;
            g_ExtSymbols->GetModuleByOffset(Address,0, NULL, &Base);
            g_ExtSymbols->GetModuleNameString(DEBUG_MODNAME_IMAGE,DEBUG_ANY_ID, Base, &Module[0], sizeof(Module), NULL);

            dprintf("Faulting driver %s ( %s+%I64lx )\n", 
                    Module,
                    Buffer,
                    Disp);
            ShowFollowForBufferName = TRUE;
        }

        g_ExtControl->Execute(OutCtl,".cxr",DEBUG_EXECUTE_DEFAULT);
        break;
    case DEBUG_FLR_CURRENT_IRQL:
        dprintf("Current IRQL %lx\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_DEVICE_OBJECT:
        dprintf("Device Object %p\n", pCrashParam->Value);
        sprintf(Buffer, "!devobj %I64lx", pCrashParam->Value);
        g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Buffer,DEBUG_EXECUTE_DEFAULT);
    case DEBUG_FLR_DRIVER_OBJECT:
        dprintf("Driver Object %p\n", pCrashParam->Value);
        if (g_ExtControl) {
            sprintf(Buffer, "!drvobj %I64lx", pCrashParam->Value);
            g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Buffer,DEBUG_EXECUTE_DEFAULT);
        }
    case DEBUG_FLR_EXCEPTION_CODE:
        dprintf("Unhandled exception %lx\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_EXCEPTION_PARAMETER1:
        dprintf("Exception parameter 1 : %p\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_EXCEPTION_PARAMETER2:
        dprintf("Exception parameter 2 : %p\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_EXCEPTION_RECORD:
        dprintf("Exception Record %p\n", pCrashParam->Value);
        if (g_ExtControl) {
            sprintf(Buffer, ".exr %I64lx", pCrashParam->Value);
            g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Buffer,DEBUG_EXECUTE_DEFAULT);
        }
        break;

    case DEBUG_FLR_POSSIBLE_FAULTING_MODULE:
    case DEBUG_FLR_FAULTING_MODULE:
    case DEBUG_FLR_IP: {
        
        if (pCrashParam->ParamType == DEBUG_FLR_POSSIBLE_FAULTING_MODULE) {
            dprintf("Probably caused by ");

        } else {
            dprintf("Fault occurred in ");
        }
        GetSymbol(pCrashParam->Value, Buffer, &Address);
        Module[0] = 0;
        g_ExtSymbols->GetModuleByOffset(pCrashParam->Value,0, NULL, &Base);
        g_ExtSymbols->GetModuleNameString(DEBUG_MODNAME_IMAGE,DEBUG_ANY_ID, Base, &Module[0], sizeof(Module), NULL);

        dprintf("driver %s ( %s+%I64lx )\n", 
                Module,
                Buffer,
                Address);
        ShowFollowForBufferName = TRUE;
        break;

    }
    case DEBUG_FLR_FOLLOWUP_IP: {
        GetSymbol(pCrashParam->Value, Buffer, &Address);
        ShowFollowForBufferName = TRUE;
        break;
    }
    case DEBUG_FLR_IRP_ADDRESS:
        dprintf("Irp %p\n", pCrashParam->Value);
        if (g_ExtControl) {
            sprintf(Buffer, "!irp %I64lx", pCrashParam->Value);
            g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Buffer,DEBUG_EXECUTE_DEFAULT);
        }
    case DEBUG_FLR_IRP_CANCEL_ROUTINE:
        GetSymbol(pCrashParam->Value, Buffer, &Address);
        dprintf("Irp cancel routine %p ( %s+%I64lx )\n", 
                pCrashParam->Value,
                Buffer,
                Address);
        break;
    case DEBUG_FLR_MM_INTERNAL_CODE:
        dprintf("Mm internal code %lx\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_POOL_ADDRESS: {
        dprintf("Relevant Pool %p\n", pCrashParam->Value);
        if (g_ExtControl) {
            sprintf(Buffer, "!pool %I64lx", pCrashParam->Value);
            g_ExtControl->Execute(DEBUG_OUTCTL_AMBIENT,Buffer,DEBUG_EXECUTE_DEFAULT);
        }
        break;
    }
    case DEBUG_FLR_PREVIOUS_IRQL:
        dprintf("Previous IRQL %lx\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_PREVIOUS_MODE:
        dprintf("Crash occured in %s mode\n", pCrashParam->Value ? "User" : "Kernel");
        break;
    case DEBUG_FLR_READ_ADDRESS: {
        PSTR PoolRegion = NULL;
        PGET_POOL_REGION GetPoolRegion = NULL;

        dprintf("Read address %p", pCrashParam->Value);

        if (g_ExtControl->GetExtensionFunction(0, "GetPoolRegion", (FARPROC*)&GetPoolRegion) == S_OK) {
            if (GetPoolRegion) {
                DEBUG_POOL_REGION RegionId;
                (*GetPoolRegion)(g_ExtClient, pCrashParam->Value,&RegionId);
                PoolRegion = g_PoolRegion[RegionId];
            }
        }
        if (PoolRegion) {
            dprintf(", %s\n",PoolRegion);
        } else {
            dprintf("\n");
        }

        break;
    }
    case DEBUG_FLR_TRAP:
        if (Verbose) {
            dprintf("TrapFrame %p\n", pCrashParam->Value);
        }
        sprintf(Buffer, ".trap %I64lx", pCrashParam->Value);
        g_ExtControl->Execute(OutCtl,Buffer,DEBUG_EXECUTE_DEFAULT);
        if (Verbose) {
            g_ExtControl->Execute(OutCtl,"k",DEBUG_EXECUTE_DEFAULT);
        } else {
            ULONG64 Disp;
            // Get symbol for IP in the context
            Address = GetImplicitContextInstrOffset();
            Buffer[0] = 0;
            GetSymbol(Address, Buffer, &Disp);
            Module[0] = 0;
            g_ExtSymbols->GetModuleByOffset(Address,0, NULL, &Base);
            g_ExtSymbols->GetModuleNameString(DEBUG_MODNAME_IMAGE,DEBUG_ANY_ID, Base, &Module[0], sizeof(Module), NULL);

            dprintf("Faulting driver %s ( %s+%I64lx )\n", 
                    Module,
                    Buffer,
                    Disp);
            ShowFollowForBufferName = TRUE;
        }

        g_ExtControl->Execute(OutCtl,".trap",DEBUG_EXECUTE_DEFAULT);
        break;
    case DEBUG_FLR_TRAP_EXCEPTION:
        dprintf("Unhandled exception %lx\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_TSS:
        if (Verbose) {
            dprintf("TSS %p\n", pCrashParam->Value);
        }
        sprintf(Buffer, ".tss %I64lx", pCrashParam->Value);
        g_ExtControl->Execute(OutCtl,Buffer,DEBUG_EXECUTE_DEFAULT);
        g_ExtControl->Execute(OutCtl,"k",DEBUG_EXECUTE_DEFAULT);
        g_ExtControl->Execute(OutCtl,".trap",DEBUG_EXECUTE_DEFAULT);
        break;
    case DEBUG_FLR_WORK_ITEM:
        dprintf("Work Item %p\n", pCrashParam->Value);
        break;
    case DEBUG_FLR_WORKER_ROUTINE:
        GetSymbol(pCrashParam->Value, Buffer, &Address);
        dprintf("Wroket routine %p ( %s+%I64lx )\n", 
                pCrashParam->Value,
                Buffer,
                Address);
        break;
    case DEBUG_FLR_WRITE_ADDRESS: {
        PSTR PoolRegion = NULL;
        PGET_POOL_REGION GetPoolRegion = NULL;

        dprintf("Write address %p", pCrashParam->Value);

        if (g_ExtControl->GetExtensionFunction(0, "GetPoolRegion", (FARPROC*)&GetPoolRegion) == S_OK) {
            if (GetPoolRegion) {
                DEBUG_POOL_REGION RegionId;
                (*GetPoolRegion)(g_ExtClient, pCrashParam->Value,&RegionId);
                PoolRegion = g_PoolRegion[RegionId];
            }
        }
        if (PoolRegion) {
            dprintf(", %s\n",PoolRegion);
        } else {
            dprintf("\n");
        }

        break;
    }
    }

    if (!ShowFollowForBufferName || !ShowFollowup) {
        return 1;
    }
    EXT_TRIAGE_FOLLOWP FollowUp = NULL;
    if (g_ExtControl->GetExtensionFunction(0, "GetTriageFollowupFromSymbol", (FARPROC *)&FollowUp) == S_OK) {
        DEBUG_TRIAGE_FOLLOWUP_INFO fInfo;

        if (FollowUp) {
            fInfo.SizeOfStruct = sizeof(fInfo);
            fInfo.OwnerName.Buffer = &Module[0];
            fInfo.OwnerName.MaximumLength = sizeof(Module);

            if ((*FollowUp)(Buffer, &fInfo)) {
                dprintf("Followup : %s\n", fInfo.OwnerName.Buffer);
                return 3;
            }
        }

    }
    return 1;

}

PDEBUG_FAILURE_ANALYSIS
FAInitMemBlock(
    ULONG Size
    )
/*
  Allocate and initialize memory for FAILUSER_ANALYZER
*/
{
    PDEBUG_FAILURE_ANALYSIS CrashInfo;

    CrashInfo = (PDEBUG_FAILURE_ANALYSIS) malloc(Size);
    if (!CrashInfo) {
        return NULL;
    }
    ZeroMemory(CrashInfo, Size);
    CrashInfo->SizeOfHeader = sizeof(DEBUG_FLR_PARAM_VALUES);
    CrashInfo->Size = Size;
    return CrashInfo;
}

PDEBUG_FAILURE_ANALYSIS
FAReInitMemBlock(
    PDEBUG_FAILURE_ANALYSIS pOldBlock,
    ULONG Size
    )
/*
   Allocate and initialize memory for FAILUSER_ANALYZER from pOldBlock
*/
{
    PDEBUG_FAILURE_ANALYSIS CrashInfo;

    if (pOldBlock && (Size < pOldBlock->Size)) {
        return NULL;
    }

    CrashInfo = (PDEBUG_FAILURE_ANALYSIS) malloc(Size);
    if (!CrashInfo) {
        return NULL;
    }
    ZeroMemory(CrashInfo, Size);
    if (pOldBlock) {
        memcpy(CrashInfo, pOldBlock, pOldBlock->Size);
    }
    CrashInfo->SizeOfHeader = sizeof(DEBUG_FLR_PARAM_VALUES);
    CrashInfo->Size = Size;
    return CrashInfo;
}

void
GetCrashInfoFromBugCheck(
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
{
    *pCrashInfo = NULL;
    switch (Bc->Code) {

#define GETINFOCASE(bcname)                      \
        case bcname :                            \
           GetInfoFor##bcname (Bc, pCrashInfo);  \
           break;
#define DUPINFOCASE(bcname)                      \
        case bcname:
        

        GETINFOCASE( DRIVER_CAUGHT_MODIFYING_FREED_POOL );

        DUPINFOCASE( PAGE_FAULT_IN_FREED_SPECIAL_POOL );
        DUPINFOCASE( PAGE_FAULT_BEYOND_END_OF_ALLOCATION );
        DUPINFOCASE( TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE );
        DUPINFOCASE( PAGE_FAULT_IN_NONPAGED_AREA );
        DUPINFOCASE( DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION );
        GETINFOCASE( DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL );
        DUPINFOCASE( DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS )

        GETINFOCASE( DRIVER_VERIFIER_IOMANAGER_VIOLATION );
        
        DUPINFOCASE( DRIVER_IRQL_NOT_LESS_OR_EQUAL );
        GETINFOCASE( IRQL_NOT_LESS_OR_EQUAL );

        GETINFOCASE( KMODE_EXCEPTION_NOT_HANDLED );
        GETINFOCASE( SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION );
        GETINFOCASE( TIMER_OR_DPC_INVALID );
        GETINFOCASE( UNEXPECTED_KERNEL_MODE_TRAP );

#undef DUPINFOCASE
#undef GETINFOCASE

    default:
        break;
    }
    AddContextInfoFromStack(pCrashInfo);
    if (*pCrashInfo) {
        (*pCrashInfo)->FailureType = DEBUG_FLR_BUGCHECK;
    } else {

    }
    return;
}

BOOL
AnalyzeCrashInfo(
    PBUGCHECK_ANALYSIS Bc,
    BOOL Verbose
    )
{
    PDEBUG_FAILURE_ANALYSIS pCrashInfo;
    ULONG ValCount;
    BOOL StackShown=FALSE;

    if (!Bc) {
        dprintf("No analysis without BugCheckInfo\n");
        return FALSE;
    }
    
    pCrashInfo = NULL;
    GetCrashInfoFromBugCheck(Bc, &pCrashInfo);
    
    dprintf("*******************************************************************************\n");
    dprintf("*                                                                             *\n");
    dprintf("*                        Bugcheck Analysis                                    *\n");
    dprintf("*                                                                             *\n");
    dprintf("*******************************************************************************\n");
    dprintf("\n");


    if (Verbose)
    {
        GetBugCheckDescription(Bc);
        PrintBugDescription(Bc);

        dprintf("\n\nDetails:\n");
    } else {
        dprintf("Use !analyzebugcheck -v to get more information.\n\n");
    }
    
    if (Bc->Code && !Verbose) {
        
        dprintf("BugCheck %lX, {%1p, %1p, %1p, %1p}\n", 
                Bc->Code,
                Bc->Args[0],Bc->Args[1],Bc->Args[2],Bc->Args[3]);
    }
    
    if (!pCrashInfo) {
        return FALSE;
    }


    BOOL FollowUpShown = FALSE;
    BOOL DriverShown = FALSE;
    if (!Verbose) {
        // First show what we thought caused failure
        for (ValCount=0; ValCount<pCrashInfo->ParamCount; ValCount++) {
            ULONG retval;

            if (pCrashInfo->Params[ValCount].ParamType == DEBUG_FLR_POSSIBLE_FAULTING_MODULE) {
                if (retval = AnalyzeValue(&pCrashInfo->Params[ValCount], Verbose, !FollowUpShown)) {
                    DriverShown = TRUE;
                    FollowUpShown = FollowUpShown || (retval & 2);
                    if (!Verbose && FollowUpShown) {
                        // We got the faulting driver
                        break;
                    }
                }
            }
        }

        // Now check for any other things showing faulting IP
        for (ValCount=0; ValCount<pCrashInfo->ParamCount; ValCount++) {
            ULONG retval;

            if ((((pCrashInfo->Params[ValCount].ParamType & 0xf0000000) == DEBUG_FLR_THREAD) ||
                 (pCrashInfo->Params[ValCount].ParamType == DEBUG_FLR_IP) ||
                 (pCrashInfo->Params[ValCount].ParamType == DEBUG_FLR_FAULTING_MODULE) ||
                 (pCrashInfo->Params[ValCount].ParamType == DEBUG_FLR_POSSIBLE_FAULTING_MODULE)) &&
                DriverShown) {
                continue;
            }

            if ((pCrashInfo->Params[ValCount].ParamType & 0xf0000000) == DEBUG_FLR_IP) {
                if (retval = AnalyzeValue(&pCrashInfo->Params[ValCount], Verbose, !FollowUpShown)) {
                    DriverShown = TRUE;
                    FollowUpShown = FollowUpShown || (retval & 2);
                    if (!Verbose && FollowUpShown) {
                        // We got the followup info
                        break;
                    }
                }
            }
        }
    } else {
        for (ValCount=0; ValCount<pCrashInfo->ParamCount; ValCount++) {
            ULONG retval;

            if (retval = AnalyzeValue(&pCrashInfo->Params[ValCount], Verbose, !FollowUpShown)) {
                DriverShown = TRUE;
                FollowUpShown = FollowUpShown || (retval & 2);
            }
            if ((pCrashInfo->Params[ValCount].ParamType & 0xf0000000) == DEBUG_FLR_THREAD) {
                StackShown = TRUE;
            }
        }
    }
    if (!FollowUpShown) {
        EXT_TRIAGE_FOLLOWP FollowUp = NULL;
        if (g_ExtControl->GetExtensionFunction(0, "GetTriageFollowupFromSymbol", (FARPROC *)&FollowUp) == S_OK) {
            DEBUG_TRIAGE_FOLLOWUP_INFO fInfo;

            if (FollowUp) {
                CHAR Buffer[100];
                fInfo.SizeOfStruct = sizeof(fInfo);
                fInfo.OwnerName.Buffer = &Buffer[0];
                fInfo.OwnerName.MaximumLength = sizeof(Buffer);

                if ((*FollowUp)("default", &fInfo)) {
                    dprintf("Followup : %s\n", fInfo.OwnerName.Buffer);
                }
            }

        }
    }
    if (pCrashInfo->DriverNameOffset && Verbose) {
        PWCHAR DriverName;

        DriverName = (PWCHAR) ((PCHAR) pCrashInfo + pCrashInfo->DriverNameOffset);
        dprintf("Driver at fault : %ws\n", DriverName);
    }
    free (pCrashInfo);
    if (!Verbose) {
        dprintf("\n");
    } else if (!StackShown) {
        g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS, NULL, 20, 
                                       DEBUG_STACK_FRAME_ADDRESSES |
                                       DEBUG_STACK_COLUMN_NAMES);
    }
    return TRUE;
}

BOOL
ReadUnicodeString(
    ULONG64 Address,
    PWCHAR Buffer,
    ULONG BufferSize,
    PULONG StringSize)
{
    UNICODE_STRING64 uStr;
    UNICODE_STRING32 uStr32;
    ULONG res;

    if (!Buffer) {
        return FALSE;
    }
    if (!IsPtr64()) {

        if (!ReadMemory(Address, &uStr32, sizeof(uStr32), &res)) {
            return FALSE;
        }
        uStr.Length = uStr32.Length;
        uStr.MaximumLength = uStr32.MaximumLength;
        uStr.Buffer = (ULONG64) (LONG64) (LONG) uStr32.Buffer;
    } else {
        if (!ReadMemory(Address, &uStr, sizeof(uStr), &res)) {
            return FALSE;
        }

    }
    if (StringSize) {
        *StringSize = uStr.Length;
    }
    uStr.Length = (USHORT) min(BufferSize, uStr.Length);

    if (!ReadMemory(uStr.Buffer, Buffer, uStr.Length, &res)) {
        return FALSE;
    }
    return TRUE;
}

BOOL
AddKiBugcheckDriver(
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
/*
 Add driver name to CrashInfo if a KiBugCheckReferences a valid name
 */
{
    ULONG64 KiBugCheckDriver;
    WCHAR DriverName[MAX_PATH];

    KiBugCheckDriver = GetExpression("NT!KiBugCheckDriver");

    if (KiBugCheckDriver) {
        ULONG length;
        PDEBUG_FAILURE_ANALYSIS NewInfo;

        ZeroMemory(DriverName, sizeof(DriverName));
        if (!ReadUnicodeString(KiBugCheckDriver, DriverName, sizeof(DriverName), &length)) {
            return FALSE;
        }

        DriverName[sizeof(DriverName) - 1] = 0;
        length = wcslen(DriverName);
        
        if (length) {
            NewInfo = FAInitMemBlock((*pCrashInfo)->Size + length + sizeof(WCHAR));
            if (!NewInfo) {
                return FALSE;
            }
            memcpy(NewInfo, *pCrashInfo, (*pCrashInfo)->Size);
            NewInfo->Size = (*pCrashInfo)->Size + length + sizeof(WCHAR);
            NewInfo->DriverNameOffset = (*pCrashInfo)->Size;
            memcpy((PCHAR) NewInfo + NewInfo->DriverNameOffset, DriverName, length + sizeof(WCHAR));

            *pCrashInfo = NewInfo;
            return TRUE;
        }

    }

    return FALSE;
}

BOOL
IsFunctionAddr(
    ULONG64 IP,
    PSTR FuncName
    )
// Check if IP is in the function FuncName
{
    CHAR Buffer[MAX_PATH], *scan, *FnIP;
    ULONG64 Disp;

    GetSymbol(IP, Buffer, &Disp);

    if (scan = strchr(Buffer, '!')) {
        FnIP = scan+1;
        while (*FnIP == '_') ++FnIP;
    } else {
        FnIP = &Buffer[0];
    }

    return !strncmp(FnIP, FuncName, strlen(FuncName));
}

BOOL
GetFirstNonNtModOnStack(
    PDEBUG_STACK_FRAME Stack,
    ULONG nFrames,
    PDEBUG_STACK_FRAME *pFrame
    );

BOOL
IsNtModuleAddress(
    ULONG64 Address
    );

BOOL
GetFirstTriageableRoutineOnStack(
    PDEBUG_STACK_FRAME Stack,
    ULONG nFrames,
    PDEBUG_STACK_FRAME *pFollowupFrame,
    PDEBUG_STACK_FRAME *pNonNtFrame
    );

BOOL
GetFollowupInfo(
    IN OPTIONAL ULONG64 Addr,
    IN OPTIONAL PSTR SymbolName,
    OUT OPTIONAL PCHAR *pOwner,
    ULONG OwnerSize
    );

BOOL
AddContextInfoFromStack(
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
//
// Add trap frame, context info from the current stack
//
//      Note(kksharma):We only need one of these to get to faulting stack (and only 
//                     one of them should should be available otherwise somethings wrong)
//
{
    PDEBUG_FAILURE_ANALYSIS CrashInfo;
    ULONG i;
    ULONG ContextInfoIndex = -1;
    ULONG FaultingAddressIndex = -1;
    ULONG64 TrapFrame = 0;
    ULONG64 Exr=0, Cxr=0;
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES];
    ULONG frames;
    ULONG64 FollowupAddress = 0;
    ULONG64 PossibleFaultingAddress = 0;
    ULONG64 OriginalFaultingAddress = 0;
    ULONG nNewEntries = 0;

    CrashInfo = *pCrashInfo;
    if (CrashInfo) {
        // Check if we have anything to get context from
        for (i=0; i<CrashInfo->ParamCount; ++i) {
            if ((CrashInfo->Params[i].ParamType == DEBUG_FLR_TRAP) ||
                (CrashInfo->Params[i].ParamType == DEBUG_FLR_CONTEXT) ||
                (CrashInfo->Params[i].ParamType == DEBUG_FLR_THREAD)) {
                // We already have context info
                ContextInfoIndex = i;
            }
            if ((CrashInfo->Params[i].ParamType & 0xf0000000) == DEBUG_FLR_IP) {
                // We already have context info
                FaultingAddressIndex = i;
                OriginalFaultingAddress = CrashInfo->Params[i].Value;
            }

            if ((ContextInfoIndex != -1) && 
                (FaultingAddressIndex != -1)) {
                break;
            }
        }
    }
    if (ContextInfoIndex == -1) {
        //
        // Get the current stack and check if we can get tarp frame/context from it
        //
        ULONG64 ExceptionPointers = 0;

        if (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &frames ) == S_OK) {
            for (i=0; i<frames; ++i) {
#if 0
                // Stack walker taskes care of these when walking stack

                if (GetTrapFromStackFrameFPO(&stk[i], &TrapFrame)) {
                    break;
                }
                // ebp of KiTrap0E is the trap frame
                if (IsFunctionAddr(stk[i].InstructionOffset, "KiTrap0E")) {
                    TrapFrame = stk[i].FrameOffset;
                    break;
                }
#endif                
                // First arg of KiMemoryFault is the trap frame
                if (IsFunctionAddr(stk[i].InstructionOffset, "KiMemoryFault")) {
                    TrapFrame = stk[i].Params[0];
                    break;
                }
                // Third arg of KiMemoryFault is the trap frame
                if (IsFunctionAddr(stk[i].InstructionOffset, "KiDispatchException")) {
                    TrapFrame = stk[i].Params[2];
                    break;
                }
                // First argument of this function is EXCEPTION_POINTERS
                if (IsFunctionAddr(stk[i].InstructionOffset, "PspUnhandledExceptionInSystemThread")) {
                    ExceptionPointers = stk[i].Params[0];
                    break;
                }
            }
        }
    
        if (ExceptionPointers) {
            ULONG PtrSize= IsPtr64() ? 8 : 4;

            if (!ReadPointer(ExceptionPointers, &Exr) ||
                !ReadPointer(ExceptionPointers + PtrSize, &Cxr)) {
                // dprintf("Unable to read exception poointers at %p\n", ExcepPtr);

            }
        }


        if (TrapFrame) nNewEntries++;
        if (Exr) nNewEntries++;
        if (Cxr) nNewEntries++;
    }

    //
    // We are done with context info, now track down faulting module / IP 
    //
    if (FaultingAddressIndex != -1) {
        // We are done if this has some followup info available
        if (GetFollowupInfo((*pCrashInfo)->Params[FaultingAddressIndex].Value, NULL, NULL, 0)) {
            if (nNewEntries) {
                goto AddNewEntries;
            }
            return TRUE;
        }
    }

    //
    // Set the context
    //
    CHAR Command[50] = {0};
    if (ContextInfoIndex != -1) {
        switch ((*pCrashInfo)->Params[i].ParamType) {
        case DEBUG_FLR_CONTEXT:
            sprintf(Command, ".cxr %I64lx", (*pCrashInfo)->Params[i].Value);
            break;
        case DEBUG_FLR_TRAP:
            sprintf(Command, ".trap %I64lx", (*pCrashInfo)->Params[i].Value);
            break;
        case DEBUG_FLR_TSS:
            sprintf(Command, ".tss %I64lx", (*pCrashInfo)->Params[i].Value);
            break;
        case DEBUG_FLR_THREAD:
            sprintf(Command, ".thread %I64lx", (*pCrashInfo)->Params[i].Value);
            break;
        }
        if (Command[0]) {
            g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, Command, DEBUG_EXECUTE_NOT_LOGGED);
        }
    } else {
        if (TrapFrame) {
            sprintf(Command, ".trap %I64lx", TrapFrame);
        } else if (Cxr) {
            sprintf(Command, ".cxr %I64lx", Cxr);
        }
        if (Command[0]) {
            g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, Command, DEBUG_EXECUTE_NOT_LOGGED);
        }

    }
    //
    // Get relevant stack
    // 
    if (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &frames ) != S_OK) {
        frames = 0;
    }

    //
    // Last resort, Go through stack to guess likely culprit
    //
    CrashInfo = *pCrashInfo;

    PDEBUG_STACK_FRAME FollowupFrame = NULL, FirstNonNtFrame = NULL;
    GetFirstTriageableRoutineOnStack(&stk[0], frames, &FollowupFrame, &FirstNonNtFrame);

    if (Command[0]) {
        //
        // Clear the set context
        //
        g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE, ".cxr", DEBUG_EXECUTE_NOT_LOGGED);
    }

    if (FollowupFrame && FollowupFrame->InstructionOffset) {
        FollowupAddress = FollowupFrame->InstructionOffset;
        nNewEntries++;
    }

    //
    // If the faulting address we had doesn't seem right, check FollowupFrame
    //
    if ((FaultingAddressIndex == -1) || !OriginalFaultingAddress ||
        IsNtModuleAddress(OriginalFaultingAddress)) {
        //
        // If we got the FollowupFrame, use it as the possible cause of fault
        //
        if (FollowupFrame && FollowupFrame->InstructionOffset && 
            (FollowupFrame->InstructionOffset != OriginalFaultingAddress)) {
            PossibleFaultingAddress = FollowupFrame->InstructionOffset;
            nNewEntries++;
        } 
    }

AddNewEntries:

    if (nNewEntries) {
        PDEBUG_FAILURE_ANALYSIS NewInfo;

        if (CrashInfo) {
            NewInfo = FAReInitMemBlock(CrashInfo, CrashInfo->Size+ (nNewEntries*sizeof(DEBUG_FLR_PARAM_VALUES)));
            free(CrashInfo);
        } else {
            NewInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + (nNewEntries * sizeof(DEBUG_FLR_PARAM_VALUES)));
        }
        if (!NewInfo) {
            return FALSE;
        }
        if (PossibleFaultingAddress) {
            NewInfo->Params[NewInfo->ParamCount].ParamType = DEBUG_FLR_POSSIBLE_FAULTING_MODULE;
            NewInfo->Params[NewInfo->ParamCount].Value     = PossibleFaultingAddress;
            NewInfo->ParamCount++;
        }
        if (FollowupAddress) {
            NewInfo->Params[NewInfo->ParamCount].ParamType = DEBUG_FLR_FOLLOWUP_IP;
            NewInfo->Params[NewInfo->ParamCount].Value     = FollowupAddress;
            NewInfo->ParamCount++;
        }
        if (TrapFrame) {
            NewInfo->Params[NewInfo->ParamCount].ParamType = DEBUG_FLR_TRAP;
            NewInfo->Params[NewInfo->ParamCount].Value     = TrapFrame;
            ContextInfoIndex = NewInfo->ParamCount;
            NewInfo->ParamCount++;
        }
        if (Exr) {
            NewInfo->Params[NewInfo->ParamCount].ParamType = DEBUG_FLR_EXCEPTION_RECORD;
            NewInfo->Params[NewInfo->ParamCount].Value     = Exr;
            NewInfo->ParamCount++;
        }
        if (Cxr) {
            NewInfo->Params[NewInfo->ParamCount].ParamType = DEBUG_FLR_CONTEXT;
            NewInfo->Params[NewInfo->ParamCount].Value     = Cxr;
            ContextInfoIndex = NewInfo->ParamCount;
            NewInfo->ParamCount++;
        }
        *pCrashInfo = NewInfo;
    }


    return TRUE;

}

void
GetModuleBaseAndOffset(
    ULONG64 Address,
    PULONG64 Base,
    PULONG64 Offset
    )
//
// Split the address into module base and offset in module
//
{
    CHAR Buffer[MAX_PATH], *scan;
    
    Buffer[0] = 0;
    GetSymbol(Address, Buffer, Offset);
    *Base = 0;
    if (scan = strchr(Buffer, '!')) {
        *scan = 0;
        *Base = GetExpression(Buffer);
        *Offset = Address - *Base;
    }

}
BOOL
GetFollowupInfo(
    IN OPTIONAL ULONG64 Addr,
    IN OPTIONAL PSTR SymbolName,
    OUT OPTIONAL PCHAR *pOwner,
    ULONG OwnerSize
    )
{
    static CHAR Buffer[MAX_PATH], Owner[100];

    EXT_TRIAGE_FOLLOWP FollowUp = NULL;
    if (g_ExtControl->GetExtensionFunction(0, "GetTriageFollowupFromSymbol", (FARPROC *)&FollowUp) == S_OK) {
        DEBUG_TRIAGE_FOLLOWUP_INFO fInfo;

        if (!SymbolName) {
            ULONG64 Disp;
            GetSymbol(Addr, Buffer, &Disp);
            SymbolName = &Buffer[0];
        }
        if (FollowUp && *SymbolName) {
            fInfo.SizeOfStruct = sizeof(fInfo);
            if (pOwner) {
                fInfo.OwnerName.Buffer = *pOwner;
                fInfo.OwnerName.MaximumLength = (USHORT)OwnerSize;
            } else {
                fInfo.OwnerName.Buffer = &Owner[0];
                fInfo.OwnerName.MaximumLength = sizeof(Owner);
            }

            if ((*FollowUp)(SymbolName, &fInfo)) {
                    // This is an interesting routine to followup on
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
IsNtModuleAddress(
    ULONG64 Address
    )
{
    ULONG64 Disp, KernBase=0;
    ULONG KernSize=0,i;

    if (g_ExtSymbols->GetModuleByModuleName("nt", 0, &i, &KernBase) == S_OK) {
        DEBUG_MODULE_PARAMETERS Params;
        if (g_ExtSymbols->GetModuleParameters(1, &KernBase, i, &Params) == S_OK) {
            KernSize = Params.Size;
        
            if (((ULONG) (Address - KernBase) < KernSize) &&
                (Address >= KernBase)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}
BOOL
GetFirstTriageableRoutineOnStack(
    PDEBUG_STACK_FRAME Stack,
    ULONG nFrames,
    PDEBUG_STACK_FRAME *pFollowupFrame,
    PDEBUG_STACK_FRAME *pNonNtFrame
    )
//
// Find and return first routine on stack which can be succesfully traiged
// If no such routine is found, this will default to first non-nt routine
//
{
    ULONG i;
    CHAR Buffer[MAX_PATH], *scan, Owner[100];
    ULONG64 Disp, KernBase=0;
    ULONG KernSize=0;

    *pFollowupFrame = NULL;
    *pNonNtFrame = NULL;
    if (g_ExtSymbols->GetModuleByModuleName("nt", 0, &i, &KernBase) == S_OK) {
        DEBUG_MODULE_PARAMETERS Params;
        if (g_ExtSymbols->GetModuleParameters(1, &KernBase, i, &Params) == S_OK) {
            KernSize = Params.Size;
        }
    }

    EXT_TRIAGE_FOLLOWP FollowUp = NULL;
    if (g_ExtControl->GetExtensionFunction(0, "GetTriageFollowupFromSymbol", (FARPROC *)&FollowUp) != S_OK) {
        FollowUp = NULL;
    }

    for (i=0; i<nFrames; ++i) {
        DEBUG_TRIAGE_FOLLOWUP_INFO fInfo;

        Buffer[0] = 0;

        GetSymbol(Stack[i].InstructionOffset, Buffer, &Disp);
        
        if (FollowUp && (*pFollowupFrame == NULL)) {
            fInfo.SizeOfStruct = sizeof(fInfo);
            fInfo.OwnerName.Buffer = &Owner[0];
            fInfo.OwnerName.MaximumLength = sizeof(Owner);

            if ((*FollowUp)(Buffer, &fInfo)) {
                // This is an interesting routine to followup on
                *pFollowupFrame = &Stack[i];
            }
        }

        if (*pNonNtFrame == NULL) {
            if (KernSize && KernBase) {
                if ((KernBase > Stack[i].InstructionOffset) ||
                    (KernBase + KernSize) <= Stack[i].InstructionOffset) {
                    *pNonNtFrame = &Stack[i];
                }
            } else {
                if (strncmp(Buffer, "nt", 2)) {
                    *pNonNtFrame = &Stack[i];
                }
            }
        }
        if (*pFollowupFrame && *pNonNtFrame) {
            return TRUE;
        }
    }
    if (*pFollowupFrame || *pNonNtFrame) {
        return TRUE;
    }
    return FALSE;
}

BOOL
GetFirstNonNtModOnStack(
    PDEBUG_STACK_FRAME Stack,
    ULONG nFrames,
    PDEBUG_STACK_FRAME *pFrame
    )
//
// Find and return first routine on stack which is not from nt module
//
{
    ULONG i;
    CHAR Buffer[MAX_PATH], *scan;
    ULONG64 Disp, KernBase=0;
    ULONG KernSize=0;

    if (g_ExtSymbols->GetModuleByModuleName("nt", 0, &i, &KernBase) == S_OK) {
        DEBUG_MODULE_PARAMETERS Params;
        if (g_ExtSymbols->GetModuleParameters(1, &KernBase, i, &Params) == S_OK) {
            KernSize = Params.Size;
        }
    }

    for (i=0; i<nFrames; ++i) {
        
        if (KernSize && KernBase) {
            if (KernBase <= Stack[i].InstructionOffset &&
                (KernBase + KernSize) >= Stack[i].InstructionOffset) {
                *pFrame = &Stack[i];
                return TRUE;
            }
        } else {
            Buffer[0] = 0;

            GetSymbol(Stack[i].InstructionOffset, Buffer, &Disp);
            if (strncmp(Buffer, "nt", 2)) {
                *pFrame = &Stack[i];
                return TRUE;
            }
        }
    }
    return FALSE;
}

BOOL
GetFirstNonNtModAddr(
    ULONG64 *pAddr
    )
//
// Find and return first routine on stack which is not from nt module
//
{
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES], *Frame;
    ULONG nFrames;

    if (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &nFrames ) == S_OK) {
        if (GetFirstNonNtModOnStack(&stk[0], nFrames, &Frame)) {
            *pAddr = Frame->InstructionOffset;
            return TRUE;
        }
    }
    return FALSE;
}

BOOL 
GetTssFromStackFrameFPO(
    PDEBUG_STACK_FRAME StackFrame,
    PULONG Tss
    )
{
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        return FALSE;
    }
    if (StackFrame->FuncTableEntry) {
        PFPO_DATA FpoData = (PFPO_DATA)StackFrame->FuncTableEntry;
        if (FpoData->cbFrame == FRAME_TSS) {
            *Tss = (ULONG)StackFrame->Reserved[1];
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
GetIPFromTss(
    ULONG Tss,
    PULONG64 IP
    )
{
    CHAR Buffer[MAX_PATH];
    HRESULT Hr = E_FAIL;

    if (g_ExtControl) {
        sprintf(Buffer, ".tss %lx", Tss);
        g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE,Buffer,DEBUG_EXECUTE_DEFAULT);
        Hr = g_ExtRegisters->GetInstructionOffset(IP);
        g_ExtControl->Execute(DEBUG_OUTCTL_IGNORE,".thread",DEBUG_EXECUTE_DEFAULT);
    }
    return Hr == S_OK;
}

BOOL 
GetTrapFromStackFrameFPO(
    PDEBUG_STACK_FRAME StackFrame,
    PULONG64 TrapFrame
    )
//
// Check stack frame if it has trap info in it.
// Return TRUE if trap frame address is initialised in TrapFrame
//
{
    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        return FALSE;
    }
    if (StackFrame->FuncTableEntry) {
        PFPO_DATA FpoData = (PFPO_DATA)StackFrame->FuncTableEntry;
        if (FpoData->cbFrame == FRAME_TRAP) {
            *TrapFrame = StackFrame->Reserved[2];
            return TRUE;
        }
    }
    return FALSE;

}

void
GetInfoForKMODE_EXCEPTION_NOT_HANDLED( //  (1e)
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
/*
*/
{
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES];
    ULONG frames, i;
    ULONG64 TrapFrame=0;
    ULONG ParamCount = 4;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;

#if 0
// This is now grabbed in another generic routine
    if (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &frames ) == S_OK) {
        for (i=0; i<frames; ++i) {
            if (IsFunctionAddr(stk[i].InstructionOffset, "KiDispatchException")) {
                TrapFrame = stk[i].Params[2];
                break;
            }
        }
    }

    if (TrapFrame) {
        ParamCount++;
    }
#endif 

    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES));
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;
    
    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;

    CrashInfo->Params[0].ParamType = DEBUG_FLR_EXCEPTION_CODE;
    CrashInfo->Params[0].Value     = Bc->Args[0];
    CrashInfo->Params[1].ParamType = DEBUG_FLR_IP;
    CrashInfo->Params[1].Value     = Bc->Args[1];
    CrashInfo->Params[2].ParamType = DEBUG_FLR_EXCEPTION_PARAMETER1;
    CrashInfo->Params[2].Value     = Bc->Args[2];
    CrashInfo->Params[3].ParamType = DEBUG_FLR_EXCEPTION_PARAMETER2;
    CrashInfo->Params[3].Value     = Bc->Args[3];
    if (TrapFrame) {
        CrashInfo->Params[4].ParamType = DEBUG_FLR_TRAP;
        CrashInfo->Params[4].Value     = TrapFrame;
    }
    *pCrashInfo = CrashInfo;

    return;
}



void
GetInfoForUNEXPECTED_KERNEL_MODE_TRAP( // (7f)
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
// It would be good to have TSS or TRAP address as exception parameter 
{
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES];
    ULONG frames, i;
    ULONG Tss=0;
    ULONG64 TrapFrame=0;
    ULONG ParamCount = 1;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;

#if 0
    // unnecessary
    if (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &frames ) == S_OK) {
        for (i=0; i<frames; ++i) {
            if (GetTssFromStackFrameFPO(&stk[i], &Tss)) {
                break;
            } 
            if (GetTrapFromStackFrameFPO(&stk[i], &TrapFrame)) {
                break;
            }
            if (IsFunctionAddr(stk[i].InstructionOffset, "KiTrap")) {
                TrapFrame = stk[i].FrameOffset;
                break;
            }
        }
    }
#endif
    if (Tss || TrapFrame) {
        ParamCount++;
    }
    
    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES));
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;

    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;
    CrashInfo->Params[0].ParamType = DEBUG_FLR_TRAP_EXCEPTION;
    CrashInfo->Params[0].Value     = Bc->Args[0];
    if (Tss) {
        CrashInfo->Params[1].ParamType = DEBUG_FLR_TSS;
        CrashInfo->Params[1].Value     = Tss;
    } else if (TrapFrame) {
        CrashInfo->Params[1].ParamType = DEBUG_FLR_TRAP;
        CrashInfo->Params[1].Value     = TrapFrame;
    } 
    *pCrashInfo = CrashInfo;
}


void GetInfoForIRQL_NOT_LESS_OR_EQUAL( // (a)
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
/*
 * Parameters
 * 
 * Parameter 1  Memory referenced
 * Parameter 2  IRQL Value
 * Parameter 3  0 - Read 1 - Write
 * Parameter 4  Address that referenced the memory
 * 
 * 
 * Special Case
 * 
 * If Parameter 3 is nonzero and equal to Parameter 1, this means that
 * a worker routine returned at a raised IRQL.
 * In this case:
 * 
 * Parameter 1  Address of work routine
 * Parameter 2  IRQL at time of reference
 * Parameter 3  Address of work routine
 * Parameter 4  Work item
 * 
*/
{
    ULONG ParamCount = 3;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;
    
    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES));
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    *pCrashInfo = CrashInfo;

    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;

    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;
    
    if ((Bc->Args[0] == Bc->Args[2]) && Bc->Args[2]) {
        // special case
        CrashInfo->Params[0].ParamType = DEBUG_FLR_WORKER_ROUTINE;
        CrashInfo->Params[0].Value     = Bc->Args[2];
        CrashInfo->Params[1].ParamType = DEBUG_FLR_WORK_ITEM;
        CrashInfo->Params[1].Value     = Bc->Args[3];
        CrashInfo->Params[2].ParamType = DEBUG_FLR_CURRENT_IRQL;
        CrashInfo->Params[2].Value     = Bc->Args[1];
        return;
    }

    
    CrashInfo->Params[0].ParamType = Bc->Args[2] ? DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS;
    CrashInfo->Params[0].Value     = Bc->Args[0];
    CrashInfo->Params[1].ParamType = DEBUG_FLR_CURRENT_IRQL;
    CrashInfo->Params[1].Value     = Bc->Args[1];
    CrashInfo->Params[2].ParamType = DEBUG_FLR_IP;
    CrashInfo->Params[2].Value     = Bc->Args[3];
    return;
}

void GetInfoForSPECIAL_POOL_DETECTED_MEMORY_CORRUPTION( // (c1)
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
/*
*/
{
    PDEBUG_FAILURE_ANALYSIS CrashInfo;
    DEBUG_STACK_FRAME stk[MAX_STACK_FRAMES], *Frame;
    ULONG   ParamCount = 1;
    ULONG   frames;
    ULONG64 ModBase, Offset;

    if (g_ExtControl->GetStackTrace(0, 0, 0, stk, MAX_STACK_FRAMES, &frames ) == S_OK) {
        if (GetFirstNonNtModOnStack(&stk[0], frames, &Frame)) {
            GetModuleBaseAndOffset(Frame->InstructionOffset, &ModBase, &Offset);
            ParamCount = 3;
        }
    }
    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES));
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;

    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;

    CrashInfo->Params[0].ParamType = DEBUG_FLR_SPECIAL_POOL_CORRUPTION_TYPE;
    CrashInfo->Params[0].Value     = Bc->Args[3];
    if (ParamCount == 3) {
        CrashInfo->Params[1].ParamType = DEBUG_FLR_POSSIBLE_FAULTING_MODULE;
        CrashInfo->Params[1].Value     = ModBase;
        CrashInfo->Params[2].ParamType = DEBUG_FLR_POSSIBLE_FAULTING_MODULE_OFFSET;
        CrashInfo->Params[2].Value     = Offset;
    }

    *pCrashInfo = CrashInfo;
    return;
}


void GetInfoForDRIVER_CAUGHT_MODIFYING_FREED_POOL( // (c6)
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
/*
  An attempt was made to access freed pool memory.  The faulty component is
  displayed in the current kernel stack.
  Arguments:
   Arg1: memory referenced
   Arg2: value 0 = read operation, 1 = write operation
   Arg3: previous mode.
   Arg4: 4.
*/
{
    DEBUG_POOL_DATA PoolData;
    ULONG ParamCount = 3;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;
    
    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES));
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;

    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;
    CrashInfo->Params[0].ParamType = Bc->Args[1] ? DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS;
    CrashInfo->Params[0].Value     = Bc->Args[0];
    CrashInfo->Params[1].ParamType = DEBUG_FLR_PREVIOUS_MODE;
    CrashInfo->Params[1].Value     = Bc->Args[2];
    CrashInfo->Params[2].ParamType = DEBUG_FLR_POOL_ADDRESS;
    CrashInfo->Params[2].Value     = Bc->Args[0];  // This is address in the pool, 
                                                   // _EFN_GetPoolData will give more info
    *pCrashInfo = CrashInfo;
    return;
}



void GetInfoForTIMER_OR_DPC_INVALID( // (c7)
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
/*
 *
 * This is issued if a kernel timer or DPC is found somewhere in
 * memory where it is not permitted.
 *
 * Bugcheck Parameters
 *
 * Parameter 1  0: Timer object 1: DPC object 2: DPC routine
 * Parameter 2  Address of object
 * Parameter 3  Beginning of memory range checked
 * Parameter 4 End of memory range checked
 *
 * This condition is usually caused by a driver failing to cancel a
 * timer or DPC before freeing the memory where it resides.
 *
 * This returns the address of DPC routine
 */
{

    ULONG ParamCount = 0;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;
    ULONG PtrSize = IsPtr64() ? 8 : 4;
    ULONG64 ObjAddress;
    ULONG64 ModBase, ModOffset;
    CHAR  Buffer[MAX_PATH];

    ObjAddress = Bc->Args[1];
    switch (Bc->Args[0]) {
    case 0: //Timer object
        ULONG DpcOffsetInTimer;
        /* 
        KTIMER struct:
           +0x000 Header           :
              +0x000 Type             : UChar
              +0x001 Absolute         : UChar
              +0x002 Size             : UChar
              +0x003 Inserted         : UChar
              +0x004 SignalState      : Int4B
              +0x008 WaitListHead     :
                 +0x000 Flink            : Ptr
                 +0x004 Blink            : Ptr
           +0x010 DueTime          :
              +0x000 LowPart          : Uint4B
              +0x004 HighPart         : Uint4B
              +0x000 u                :
                 +0x000 LowPart          : Uint4B
                 +0x004 HighPart         : Uint4B
              +0x000 QuadPart         : Uint8B
           +0x018 TimerListEntry   :
              +0x000 Flink            : Ptr
              +0x004 Blink            : Ptr
           +0x020 Dpc              : Ptr
           */
        if (GetFieldOffset("nt!_KTIMER", "Dpc", &DpcOffsetInTimer)) {
            // we don't have types
            DpcOffsetInTimer = 0x10 + PtrSize*4; 
        }
        if (!ReadPointer(ObjAddress + DpcOffsetInTimer, &ObjAddress)) {
            // fail
            break;
        }
        // Fall thru
    case 1:
        ULONG DeferredRoutinOffsetInKDPC;
        /*
        KDPC struct
           +0x000 Type             : Int2B
           +0x002 Number           : UChar
           +0x003 Importance       : UChar
           +0x004 DpcListEntry     : _LIST_ENTRY
           +0x00c DeferredRoutine  : Ptr32
        */
        if (GetFieldOffset("nt!_KDPC", "DeferredRoutine", &DeferredRoutinOffsetInKDPC)) {
            DeferredRoutinOffsetInKDPC = 4 + PtrSize*2;
        }
        if (!ReadPointer(ObjAddress + DeferredRoutinOffsetInKDPC, &ObjAddress)) {
            // fail
            break;
        }
        // Fall thru
    case 2:
        GetModuleBaseAndOffset(ObjAddress, &ModBase, &ModOffset);
        if (ModBase) {
            ParamCount = 3;
        }
    }

    ULONG64 Disp;
    ULONG NameLen;
    ULONG ParamSize;

    ParamSize = ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES);
    GetSymbol(ObjAddress, Buffer, &Disp);
    NameLen = strlen(Buffer) + 1;
    NameLen = DWORD_ALIGN(NameLen);

    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamSize + NameLen);
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;

    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;
    if (ParamCount) {
        CrashInfo->Params[0].ParamType = DEBUG_FLR_INVALID_DPC_FOUND;
        CrashInfo->Params[0].Value     = ObjAddress;
        CrashInfo->Params[1].ParamType = DEBUG_FLR_POSSIBLE_FAULTING_MODULE;
        CrashInfo->Params[1].Value     = ModBase;
        CrashInfo->Params[2].ParamType = DEBUG_FLR_POSSIBLE_FAULTING_MODULE_OFFSET;
        CrashInfo->Params[2].Value     = ModOffset;
    
        CrashInfo->SymNameOffset = sizeof(DEBUG_FAILURE_ANALYSIS) + ParamSize;
        strncpy(((char *) CrashInfo) + CrashInfo->SymNameOffset, Buffer, NameLen);
    }
    *pCrashInfo = CrashInfo;
    return;
}


void GetInfoForDRIVER_VERIFIER_IOMANAGER_VIOLATION( // (c9)
    PBUGCHECK_ANALYSIS Bc,
    PDEBUG_FAILURE_ANALYSIS *pCrashInfo
    )
/*
    The IO manager has caught a misbehaving driver
*/
{
    ULONG ParamCount = 0;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;
    DEBUG_FLR_PARAM_VALUES Values[6];
    ULONG64 Irp, DevObj, DrvObj;
    

    Values[0].ParamType = DEBUG_FLR_DRIVER_VERIFIER_IOMANAGER_VIOLATION_TYPE;
    Values[0].Value = Bc->Args[0];
    ParamCount = 1;

    Irp = DevObj = DrvObj = 0;

    if (Bc->Args[ 0 ] == 0x1) {
        // "Invalid IRP passed to IoFreeIrp";
        Irp = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_IRP_ADDRESS;
        Values[1].Value = Irp;
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x2) {
        // "IRP still associated with a thread at IoFreeIrp";
        Irp = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_IRP_ADDRESS;
        Values[1].Value = Irp;
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x3) {
        // "Invalid IRP passed to IoCallDriver";
        Irp = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_IRP_ADDRESS;
        Values[1].Value = Irp;
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x4) {
        // "Invalid Device object passed to IoCallDriver";
        DevObj = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_DEVICE_OBJECT;
        Values[1].Value = DevObj;
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x5) {
        // "Irql not equal across call to the driver dispatch routine"
        DevObj = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_DEVICE_OBJECT;
        Values[1].Value = DevObj;
        Values[2].ParamType = DEBUG_FLR_PREVIOUS_IRQL;
        Values[2].Value = Bc->Args[2];
        Values[3].ParamType = DEBUG_FLR_CURRENT_IRQL;
        Values[3].Value = Bc->Args[3];
        ParamCount+=3;
    } else if (Bc->Args[ 0 ] == 0x6) {
        // "IRP passed to IoCompleteRequest contains invalid status"
        // Param 1 = "the status";
        Irp = Bc->Args[2];
        Values[1].ParamType = DEBUG_FLR_IRP_ADDRESS;
        Values[1].Value = Irp;
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x7) {
        // "IRP passed to IoCompleteRequest still has cancel routine"
        Irp = Bc->Args[2];
        Values[1].ParamType = DEBUG_FLR_IRP_ADDRESS;
        Values[1].Value = Irp;
        Values[2].ParamType = DEBUG_FLR_IRP_CANCEL_ROUTINE;
        Values[2].Value = Bc->Args[1];
        ParamCount+=2;
    } else if (Bc->Args[ 0 ] == 0x8) {
        // "Call to IoBuildAsynchronousFsdRequest threw an exce
        DevObj = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_DEVICE_OBJECT;
        Values[1].Value = DevObj;
        Values[2].ParamType = DEBUG_FLR_IRP_MAJOR_FN;
        Values[2].Value = Bc->Args[2];
        Values[3].ParamType = DEBUG_FLR_EXCEPTION_CODE;
        Values[3].Value = Bc->Args[3];
        ParamCount+=3;
    } else if (Bc->Args[ 0 ] == 0x9) {
        // "Call to IoBuildDeviceIoControlRequest threw an exce
        DevObj = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_DEVICE_OBJECT;
        Values[1].Value = DevObj;
        Values[2].ParamType = DEBUG_FLR_IOCONTROL_CODE;
        Values[2].Value = Bc->Args[2];
        Values[3].ParamType = DEBUG_FLR_EXCEPTION_CODE;
        Values[3].Value = Bc->Args[3];
        ParamCount+=3;
    } else if (Bc->Args[ 0 ] == 0x10) {
        // "Reinitialization of Device object timer";
        DevObj = Bc->Args[1];
        Values[1].ParamType = DEBUG_FLR_DEVICE_OBJECT;
        Values[1].Value = DevObj;
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x12) {
        // "Invalid IOSB in IRP at APC IopCompleteRequest (appe
        Values[1].ParamType = DEBUG_FLR_IOSB_ADDRESS;
        Values[1].Value = DevObj;
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x13) {
        // "Invalid UserEvent in IRP at APC IopCompleteRequest
        Values[1].ParamType = DEBUG_FLR_INVALID_USEREVENT;
        Values[1].Value = Bc->Args[1];
        ParamCount++;
    } else if (Bc->Args[ 0 ] == 0x14) {
        // "Irql > DPC at IoCompleteRequest";
        Irp = Bc->Args[2];
        Values[1].ParamType = DEBUG_FLR_IRP_ADDRESS;
        Values[1].Value = Irp;
        Values[2].ParamType = DEBUG_FLR_CURRENT_IRQL;
        Values[2].Value = Bc->Args[1];
        ParamCount+=2;
    }

    ULONG ParamSize;

    ParamSize = ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES);
    
    if (Irp != 0) {
        DEBUG_IRP_INFO IrpInfo;
        PGET_IRP_INFO GetIrpInfo;

        if (g_ExtControl->GetExtensionFunction(0, "GetIrpInfo", (FARPROC*)&GetIrpInfo) == S_OK) {
            IrpInfo.SizeOfStruct = sizeof(IrpInfo);
            if (GetIrpInfo &&
                ((*GetIrpInfo)(g_ExtClient,Irp, &IrpInfo) == S_OK)) {

                DevObj = IrpInfo.CurrentStack.DeviceObject;
            }
        }

    }

    if (DevObj != 0) {
        DEBUG_DEVICE_OBJECT_INFO DevObjInfo;
        PGET_DEVICE_OBJECT_INFO GetDevObjInfo;

        if (g_ExtControl->GetExtensionFunction(0, "GetDevObjInfo", (FARPROC*)&GetDevObjInfo) == S_OK) {
            DevObjInfo.SizeOfStruct = sizeof(DEBUG_DEVICE_OBJECT_INFO);
            if (GetDevObjInfo &&
                ((*GetDevObjInfo)(g_ExtClient,DevObj, &DevObjInfo) == S_OK)) {
                DrvObj = DevObjInfo.DriverObject;
            }
        }
    }

    ULONG64 DriverName = 0;
    ULONG   DriverNameLen = 0;
    if (DrvObj != 0) {
        DEBUG_DRIVER_OBJECT_INFO DrvObjInfo;
        PGET_DRIVER_OBJECT_INFO GetDrvObjInfo;

        if (g_ExtControl->GetExtensionFunction(0, "GetDrvObjInfo", (FARPROC*)&GetDrvObjInfo) == S_OK) {
            DrvObjInfo.SizeOfStruct = sizeof(DEBUG_DRIVER_OBJECT_INFO);
            if (GetDrvObjInfo &&
                ((*GetDrvObjInfo)(g_ExtClient,DrvObj, &DrvObjInfo) == S_OK)) {
                DriverNameLen = DrvObjInfo.DriverName.Length;
                DriverName = DrvObjInfo.DriverName.Buffer;
            }
        }
    }

    if (DriverName) {
        if (DriverNameLen > 1024) { // sanity check
            DriverNameLen = 1024;
        }
        DriverNameLen = DWORD_ALIGN(DriverNameLen + sizeof(WCHAR));
    }
    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamSize + DriverNameLen);
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    *pCrashInfo = CrashInfo;
    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;

    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;

    memcpy(&CrashInfo->Params, Values, ParamSize);
    if (DriverName) {
        ULONG result, b;
        CrashInfo->DriverNameOffset = sizeof(DEBUG_FAILURE_ANALYSIS) + ParamSize;
        b = ReadMemory(DriverName, 
                   ((PCHAR) CrashInfo) + CrashInfo->DriverNameOffset,
                   DriverNameLen,
                   &result);
        if (!b || (result != DriverNameLen)) {
            wcscpy((PWCHAR) (((PCHAR) CrashInfo) + CrashInfo->DriverNameOffset),L"Name paged out");
        }
        *((PWCHAR) (((PCHAR) CrashInfo) + DriverNameLen)) = 0;
    }

}


DECL_GETINFO( DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL ) // 0xD5
/*
 * Parameters
 *
 * Parameter 1 Memory referenced
 * Parameter 2 0: Read 1: Write
 * Parameter 3 Address that referenced memory (if known)
 * Parameter 4 Reserved
 *
 */
{
    ULONG ParamCount;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;
    
    ParamCount = Bc->Args[2] ? 3 : 2;
    CrashInfo = FAInitMemBlock(sizeof(DEBUG_FAILURE_ANALYSIS) + ParamCount*sizeof(DEBUG_FLR_PARAM_VALUES));
    if (!CrashInfo) {
        *pCrashInfo = NULL;
        return;
    }

    CrashInfo->FailureType = DEBUG_FLR_BUGCHECK;
    CrashInfo->BugCode = Bc->Code;

    // Initialize known parameters
    CrashInfo->ParamCount = ParamCount;
    CrashInfo->Params[0].ParamType = Bc->Args[1] ? DEBUG_FLR_WRITE_ADDRESS : DEBUG_FLR_READ_ADDRESS;
    CrashInfo->Params[0].Value     = Bc->Args[0];
    if (Bc->Args[2]) {
        CrashInfo->Params[1].ParamType = DEBUG_FLR_IP;
        CrashInfo->Params[1].Value     = Bc->Args[2];
    }
    CrashInfo->Params[ParamCount - 1].ParamType = DEBUG_FLR_MM_INTERNAL_CODE;
    CrashInfo->Params[ParamCount - 1].Value     = Bc->Args[3];

    *pCrashInfo = CrashInfo;

    AddKiBugcheckDriver(pCrashInfo);
}

DECL_GETINFO( DRIVER_VERIFIER_DETECTED_VIOLATION ) // 0xC4
/*
 * Parameters
 *
 * Parameter 1 subclass of violation
 * Parameter 2, 3, 4 vary depending on parameter 1
 *
 */
{
    ULONG64 DriverNameAddr;
    WCHAR DriverName[MAX_PATH];
    CHAR RoutineName[MAX_PATH];
    ULONG res;
    ULONG ParamCount = 0;
    PDEBUG_FAILURE_ANALYSIS CrashInfo;

    DriverName[0] = 0;
    if (DriverNameAddr = GetExpression("ViBadDriver")) {
        if (ReadMemory(DriverNameAddr, DriverName, sizeof(DriverName), &res)) {
            // We have driver name
        }
    }

    RoutineName[0] = 0;
    ULONG64 Addr, Disp;
    if (GetFirstNonNtModAddr(&Addr)) {
        GetSymbol(Addr, &RoutineName[0], &Disp);
    }
}
#undef DECL_GETINFO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\bugcheck.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    bugcheck.h

Abstract:

    WinDbg Extension Api

Environment:

    User Mode.

Revision History:
 
    Kshitix K. Sharma (kksharma)
        
    bugcheck analyzer headers.

--*/

#ifndef _BUGCHECK_H_
#define _BUGCHECK_H_

#include "bugcodes.h"


typedef struct _BUGCHECK_ANALYSIS
{
    ULONG Code;
    ULONG64 Args[4];
    PCHAR szName;
    PCHAR szDescription;
    PCHAR szParamsDesc[4];
} BUGCHECK_ANALYSIS, *PBUGCHECK_ANALYSIS;


typedef void (WINAPI *PBUGCHECK_EXAMINE) (
    PBUGCHECK_ANALYSIS pBugCheck
);

typedef struct _BUGDESC_APIREFS {
    ULONG Code;
    PBUGCHECK_EXAMINE pExamineRoutine;
} BUGDESC_APIREFS, *PBUGDESC_APIREFS;

// why is this not defined in bugcodes.h ??
#ifndef HEAP_INITIALIZATION_FAILED
#define HEAP_INITIALIZATION_FAILED       0x5D
#endif

#endif // _BUGCHECK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\kext.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass, g_TargetQual;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES    g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS2       g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &g_TargetQual)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


DECLARE_API ( time )
{
    dprintf("*** !time is obsolete: Use '.time'\n");
    return S_OK;
}

HRESULT
PrintString(
    BOOL Unicode,
    PDEBUG_CLIENT Client,
    LPCSTR args
    )
{
    ULONG64 AddrString;
    ULONG64 Displacement;
    STRING32 String;
    UNICODE_STRING UnicodeString;
    ULONG64 AddrBuffer;
    CHAR Symbol[1024];
    LPSTR StringData;
    HRESULT hResult;
    BOOL b;


    AddrString = GetExpression(args);
    if (!AddrString)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol(AddrString, Symbol, &Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory(AddrString, &String, sizeof(String), NULL);

    if ( !b )
    {
        return E_FAIL;
    }

    INIT_API();

    if (IsPtr64())
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING64, Buffer),
                             &AddrBuffer);
    }
    else
    {
        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + FIELD_OFFSET(STRING32, Buffer),
                             &AddrBuffer);
    }

    EXIT_API();

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    StringData = (LPSTR) LocalAlloc(LMEM_ZEROINIT,
                                    String.Length + sizeof(UNICODE_NULL));

    if (!StringData)
    {
        return E_FAIL;
    }

    dprintf("String(%d,%d)", String.Length, String.MaximumLength);
    if (Symbol[0])
    {
        dprintf(" %s+%p", Symbol, Displacement);
    }

    b = ReadMemory(AddrBuffer, StringData, String.Length, NULL);

    if ( b )
    {
        if (Unicode)
        {
            ANSI_STRING AnsiString;

            UnicodeString.Buffer = (PWSTR)StringData;
            UnicodeString.Length = String.Length;
            UnicodeString.MaximumLength = String.Length+sizeof(UNICODE_NULL);

            RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString,TRUE);

            dprintf(" at %p: %s\n", AddrString, AnsiString.Buffer);

            RtlFreeAnsiString(&AnsiString);
        }
        else
        {
            dprintf(" at %p: %s\n", AddrString, StringData);
        }

        LocalFree(StringData);
        return S_OK;
    }
    else
    {
        LocalFree(StringData);
        return E_FAIL;
    }
}

DECLARE_API( str )

/*++

Routine Description:

    This function is called to format and dump counted (ansi) string.

Arguments:

    args - Address

Return Value:

    None.

--*/
{
    return PrintString(FALSE, Client, args);
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called to format and dump counted (unicode) string.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    return PrintString(TRUE, Client, args);
}

DECLARE_API( obja )

/*++

Routine Description:

    This function is called to format and dump an object attributes structure.

Arguments:

    args - Address

Return Value:

    None.

--*/

{
    ULONG64 AddrObja;
    ULONG64 Displacement;
    ULONG64 AddrString;
    STRING32 String;
    ULONG64 StrAddr = NULL;
    CHAR Symbol[1024];
    LPSTR StringData;
    BOOL b;
    ULONG Attr;
    HRESULT hResult;
    ULONG ObjectNameOffset;
    ULONG AttrOffset;
    ULONG StringOffset;

    if (IsPtr64())
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES64, Attributes);
        StringOffset = FIELD_OFFSET(STRING64, Buffer);
    }
    else
    {
        ObjectNameOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, ObjectName);
        AttrOffset = FIELD_OFFSET(OBJECT_ATTRIBUTES32, Attributes);
        StringOffset = FIELD_OFFSET(STRING32, Buffer);
    }


    AddrObja = GetExpression(args);
    if (!AddrObja)
    {
        return E_FAIL;
    }

    //
    // Get the symbolic name of the Obja
    //

    GetSymbol(AddrObja, Symbol, &Displacement);

    dprintf("Obja %s+%p at %p:\n", Symbol, Displacement, AddrObja);


    INIT_API();

    hResult = g_ExtData->ReadPointersVirtual(1,
                         AddrObja + ObjectNameOffset,
                         &AddrString);

    if (hResult != S_OK)
    {
        return E_FAIL;
    }

    if (AddrString)
    {
        b = ReadMemory(AddrString, &String, sizeof(String), NULL);

        hResult = g_ExtData->ReadPointersVirtual(1,
                             AddrString + StringOffset,
                             &StrAddr);
    }

    EXIT_API();


    if (StrAddr)
    {
        StringData = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                       String.Length+sizeof(UNICODE_NULL));

        if (StringData)
        {

            b = ReadMemory(StrAddr, StringData, String.Length, NULL);

            if (b)
            {
                dprintf("\tName is %ws\n", StringData);
            }

            LocalFree(StringData);
        }

    }

    b = ReadMemory(AddrObja + AttrOffset, &Attr, sizeof(Attr), NULL);

    if (!b)
    {
        return E_FAIL;
    }

    if (Attr & OBJ_INHERIT )
    {
        dprintf("\tOBJ_INHERIT\n");
    }
    if (Attr & OBJ_PERMANENT )
    {
        dprintf("\tOBJ_PERMANENT\n");
    }
    if (Attr & OBJ_EXCLUSIVE )
    {
        dprintf("\tOBJ_EXCLUSIVE\n");
    }
    if (Attr & OBJ_CASE_INSENSITIVE )
    {
        dprintf("\tOBJ_CASE_INSENSITIVE\n");
    }
    if (Attr & OBJ_OPENIF )
    {
        dprintf("\tOBJ_OPENIF\n");
    }


    return S_OK;
}


DECLARE_API( help )
{
    dprintf("analyzebugcheck                - Perform bugcheck analysis\n");
    dprintf("ecb                            - Edit PCI ConfigSpace byte\n");
    dprintf("ecd                            - Edit PCI ConfigSpace dword\n");
    dprintf("ecw                            - Edit PCI ConfigSpace word\n");
    dprintf("exca <BasePort>.<SktNum>       - Dump ExCA registers\n");
    dprintf("help                           - Show this help\n");
    dprintf("pci [flag] [bus] [device] [function] [rawdump:minaddr] [maxaddr] - Dumps pci type1 config\n");
    dprintf("    flag: 0x01 - verbose\n");
    dprintf("          0x02 - from bus 0 to 'bus'\n");
    dprintf("          0x04 - dump raw bytes\n");
    dprintf("          0x08 - dump raw dwords\n");
    dprintf("          0x10 - do not skip invalid devices\n");
    dprintf("          0x20 - do not skip invalid functions\n");
    dprintf("          0x40 - dump Capabilities if found\n");
    dprintf("          0x80 - dump device specific on VendorID:8086\n");
    dprintf("         0x100 - dump config space\n");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\makefile.inc ===
$O\bugchkex.cpp : gnbugcds.pl $(BASE_INC_PATH)\bugcodes.txt
        perl gnbugcds.pl -o $O\bugchkex.cpp -i $(BASE_INC_PATH)\bugcodes.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\kextfn.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    kextfn.h

Abstract:


Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 3/5/2001

--*/

#ifndef _KEXTFN_H
#define _KEXTFN_H
#endif // _KEXTFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\mts.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mts.c

Abstract:

    MikeTs's little KD extension.

Author:

    Michael Tsang (mikets) 18-November-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "pcskthw.h"
#include "pci.h"
#pragma hdrstop

BOOL
ReadPci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    OUT PUCHAR                  Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

BOOLEAN
WritePci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

typedef struct _PCI_BRIDBG_CTRL_REG {
    USHORT PERRREnable:1;
    USHORT SERREnable:1;
    USHORT ISAEnable:1;
    USHORT VGAEnable:1;

    USHORT Reserved:1;
    USHORT MasterAbort:1;
    USHORT CBRst:1;
    USHORT IRQRoutingEnable:1;

    USHORT Mem0Prefetch:1;
    USHORT Mem1Prefetch:1;
    USHORT WritePostEnable:1;

    USHORT Reserved1:5;
} PCI_BRIDBG_CTRL_REG;

VOID PrintClassInfo(PBYTE  pb, DWORD dwReg);

void PrintPciStatusReg(
    USHORT Status
    )
{
    if (Status & PCI_STATUS_CAPABILITIES_LIST) {
        dprintf("CapList ");
    }
    if (Status & PCI_STATUS_66MHZ_CAPABLE) {
        dprintf("66MHzCapable ");
    }
    if (Status & PCI_STATUS_UDF_SUPPORTED) {
        dprintf("UDFSupported ");
    }
    if (Status & PCI_STATUS_FAST_BACK_TO_BACK) {
        dprintf("FB2BCapable ");
    }
    if (Status & PCI_STATUS_DATA_PARITY_DETECTED) {
        dprintf("DataPERR ");
    }
    if (Status & PCI_STATUS_SIGNALED_TARGET_ABORT) {
        dprintf("TargetDevAbort ");
    }
    if (Status & PCI_STATUS_RECEIVED_TARGET_ABORT) {
        dprintf("TargetAbort ");
    }
    if (Status & PCI_STATUS_RECEIVED_MASTER_ABORT) {
        dprintf("InitiatorAbort ");
    }
    if (Status & PCI_STATUS_SIGNALED_SYSTEM_ERROR) {
        dprintf("SERR ");
    }
    if (Status & PCI_STATUS_DETECTED_PARITY_ERROR) {
        dprintf("PERR ");
    }
    if (Status & PCI_STATUS_DEVSEL) {
        dprintf("DEVSELTiming:%lx",(Status & PCI_STATUS_DEVSEL) >> 9);
    }
    dprintf("\n");
}

void PrintPciBridgeCtrlReg(
    USHORT Bridge
    )
{
    PCI_BRIDBG_CTRL_REG bReg = *((PCI_BRIDBG_CTRL_REG *) &Bridge);

    if (bReg.PERRREnable) {
        dprintf("PERRREnable ");
    }
    if (bReg.SERREnable) {
        dprintf("SERREnable ");
    }
    if (bReg.ISAEnable) {
        dprintf("ISAEnable ");
    }
    if (bReg.MasterAbort) {
        dprintf("MasterAbort ");
    }
    if (bReg.CBRst) {
        dprintf("CBRst ");
    }
    if (bReg.IRQRoutingEnable) {
        dprintf("IRQRoutingEnable ");
    }
    if (bReg.Mem0Prefetch) {
        dprintf("Mem0Prefetch ");
    }
    if (bReg.Mem1Prefetch) {
        dprintf("Mem1Prefetch ");
    }
    if (bReg.WritePostEnable) {
        dprintf("WritePostEnable ");
    }
    dprintf("\n");
} 

BOOL
PrintCommonConfigSpace(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    if (!Pad) {
        Pad = "";
    }

    dprintf("%sVendorID      %04lx\n", Pad, pCmnCfg->VendorID);
    dprintf("%sDeviceID      %04lx\n", Pad, pCmnCfg->DeviceID);
    dprintf("%sCommand       ", Pad);
    if (pCmnCfg->Command & PCI_ENABLE_IO_SPACE) {
        dprintf("IOSpaceEnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_MEMORY_SPACE) {
        dprintf("MemSpaceEnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_BUS_MASTER) {
        dprintf("BusInitiate ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_SPECIAL_CYCLES) {
        dprintf("SpecialCycle ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_WRITE_AND_INVALIDATE) {
        dprintf("MemWriteEnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_VGA_COMPATIBLE_PALETTE) {
        dprintf("VGASnoop ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_PARITY) {
        dprintf("PERREnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_WAIT_CYCLE) {
        dprintf("WaitCycle ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_SERR) {
        dprintf("SERREnable ");
    }
    if (pCmnCfg->Command & PCI_ENABLE_FAST_BACK_TO_BACK) {
        dprintf("FB2BEnable ");
    }
    dprintf("\n");


    dprintf("%sStatus        ", Pad);
    PrintPciStatusReg(pCmnCfg->Status);

    dprintf("%sRevisionID    %02lx\n%sProgIF        %02lx", 
            Pad, 
            pCmnCfg->RevisionID,
            Pad,
            pCmnCfg->ProgIf);
    PrintClassInfo((PBYTE) pCmnCfg, FIELD_OFFSET(PCI_COMMON_CONFIG, ProgIf));
    dprintf("%sSubClass      %02lx", Pad, 
            pCmnCfg->SubClass);
    PrintClassInfo((PBYTE) pCmnCfg, FIELD_OFFSET(PCI_COMMON_CONFIG, SubClass));
    dprintf("%sBaseClass     %02lx", Pad,
            pCmnCfg->BaseClass);
    PrintClassInfo((PBYTE) pCmnCfg, FIELD_OFFSET(PCI_COMMON_CONFIG, BaseClass));

    dprintf("%sCacheLineSize %04lx", Pad, pCmnCfg->CacheLineSize);

    if (pCmnCfg->CacheLineSize & 0xf0) {
        dprintf("BurstDisabled ");
    }
    if (pCmnCfg->CacheLineSize & 0xf) {
        dprintf("Burst4DW");
    }
    dprintf("\n");

    dprintf("%sLatencyTimer  %02lx\n", Pad, pCmnCfg->LatencyTimer);
    dprintf("%sHeaderType    %02lx\n", Pad, pCmnCfg->HeaderType);
    dprintf("%sBIST          %02lx\n", Pad, pCmnCfg->BIST);

    return TRUE;
}

BOOL
PrintCfgSpaceType0(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    int i;

    if (!Pad) {
        Pad = "";
    }

    for (i=0; i<PCI_TYPE0_ADDRESSES; ++i) {
        dprintf("%sBAR%x          %08lx\n", Pad, i, pCmnCfg->u.type0.BaseAddresses[i]);
    }
    dprintf("%sCBCISPtr      %08lx\n", Pad, pCmnCfg->u.type0.CIS); 
    dprintf("%sSubSysVenID   %04lx\n", Pad, pCmnCfg->u.type0.SubVendorID); 
    dprintf("%sSubSysID      %04lx\n", Pad, pCmnCfg->u.type0.SubSystemID); 
    dprintf("%sROMBAR        %08lx\n", Pad, pCmnCfg->u.type0.ROMBaseAddress); 
    dprintf("%sCapPtr        %02lx\n", Pad, pCmnCfg->u.type0.CapabilitiesPtr); 
    dprintf("%sIntLine       %02lx\n", Pad, pCmnCfg->u.type0.InterruptLine); 
    dprintf("%sIntPin        %02lx\n", Pad, pCmnCfg->u.type0.InterruptPin); 
    dprintf("%sMinGnt        %02lx\n", Pad, pCmnCfg->u.type0.MinimumGrant); 
    dprintf("%sMaxLat        %02lx\n", Pad, pCmnCfg->u.type0.MaximumLatency); 

    return TRUE;
}

BOOL
PrintCfgSpaceType1(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    int i;

    if (!Pad) {
        Pad = "";
    }

    for (i=0; i<PCI_TYPE1_ADDRESSES; ++i) {
        dprintf("%sBAR%x          %08lx\n", Pad, i, pCmnCfg->u.type1.BaseAddresses[i]);
    }
    
    dprintf("%sPriBusNum     %02lx\n", Pad, pCmnCfg->u.type1.PrimaryBus); 
    dprintf("%sSecBusNum     %02lx\n", Pad, pCmnCfg->u.type1.SecondaryBus); 
    dprintf("%sSubBusNum     %02lx\n", Pad, pCmnCfg->u.type1.SubordinateBus); 
    dprintf("%sSecLatencyTmr %02lx\n", Pad, pCmnCfg->u.type1.SecondaryLatency); 
    dprintf("%sIOBase        %02lx\n", Pad, pCmnCfg->u.type1.IOBase); 
    dprintf("%sIOLimit       %02lx\n", Pad, pCmnCfg->u.type1.IOLimit); 
    dprintf("%sSecStatus     ",Pad);
    PrintPciStatusReg(pCmnCfg->u.type1.SecondaryStatus);

    dprintf("%sMemBase       %04lx\n", Pad, pCmnCfg->u.type1.MemoryBase); 
    dprintf("%sMemLimit      %04lx\n", Pad, pCmnCfg->u.type1.MemoryLimit); 
    dprintf("%sPrefMemBase   %04lx\n", Pad, pCmnCfg->u.type1.PrefetchBase); 
    dprintf("%sPrefMemLimit  %04lx\n", Pad, pCmnCfg->u.type1.PrefetchLimit); 
    dprintf("%sPrefBaseHi    %08lx\n", Pad, pCmnCfg->u.type1.PrefetchBaseUpper32); 
    dprintf("%sPrefLimitHi   %08lx\n", Pad, pCmnCfg->u.type1.PrefetchLimitUpper32); 
    dprintf("%sIOBaseHi      %04lx\n", Pad, pCmnCfg->u.type1.IOBaseUpper16); 
    dprintf("%sIOLimitHi     %04lx\n", Pad, pCmnCfg->u.type1.IOLimitUpper16); 
    dprintf("%sCapPtr        %02lx\n", Pad, pCmnCfg->u.type1.CapabilitiesPtr); 
    dprintf("%sROMBAR        %08lx\n", Pad, pCmnCfg->u.type1.ROMBaseAddress); 
    dprintf("%sIntLine       %02lx\n", Pad, pCmnCfg->u.type1.InterruptLine); 
    dprintf("%sIntPin        %02lx\n", Pad, pCmnCfg->u.type1.InterruptPin); 
    dprintf("%sBridgeCtrl    %04lx\n", Pad, pCmnCfg->u.type1.BridgeControl); 

    return TRUE;
}

BOOL
PrintCfgSpaceType2(
    PCI_COMMON_CONFIG *pCmnCfg,
    PCHAR Pad
    )
{
    int i;

    if (!Pad) {
        Pad = "";
    }

    dprintf("%sRegBaseAddr    %08lx\n", Pad, pCmnCfg->u.type2.SocketRegistersBaseAddress);
    dprintf("%sCapPtr         %02lx\n", Pad, pCmnCfg->u.type2.CapabilitiesPtr);
    dprintf("%sSecStatus      ", Pad);
    PrintPciStatusReg(pCmnCfg->u.type2.SecondaryStatus);

    dprintf("%sPCIBusNum      %02lx\n", Pad, pCmnCfg->u.type2.PrimaryBus);
    dprintf("%sCBBusNum       %02lx\n", Pad, pCmnCfg->u.type2.SecondaryBus);
    dprintf("%sSubBusNum      %02lx\n", Pad, pCmnCfg->u.type2.SubordinateBus);
    dprintf("%sCBLatencyTimer %02lx\n", Pad, pCmnCfg->u.type2.SecondaryLatency);
    for (i=0; i< PCI_TYPE2_ADDRESSES; ++i) {
        dprintf("%sRange[%lx].Base  %08lx\n", Pad, i, pCmnCfg->u.type2.Range[i].Base);
        dprintf("%sRange[%lx].Limit %08lx\n", Pad, i, pCmnCfg->u.type2.Range[i].Limit);
    }
    dprintf("%sIntLine        %02lx\n", Pad, pCmnCfg->u.type2.InterruptLine);
    dprintf("%sIntPin         %02lx\n", Pad, pCmnCfg->u.type2.InterruptPin);
    dprintf("%sBridgeCtrl     %02lx\n", Pad);
    PrintPciBridgeCtrlReg(pCmnCfg->u.type2.BridgeControl);
#if 0
    // Not part of type2 typedef, but were present in old !dcs
    {"SubSysVenID=",   (PFMTHDR)&fmtHexWord,       NULL},
    {"SubSysID=",      (PFMTHDR)&fmtHexWord,       NULL},
    {"LegacyBaseAddr=",(PFMTHDR)&fmtHexDWord,      NULL},
#endif
    return TRUE;
}

void
PrintDataRange(
    PCHAR pData,
    ULONG nDwords,
    ULONG base,
    PCHAR Pad
    )
{
    unsigned int i;
    unsigned int j;
    PULONG pRange;

    pRange = (PULONG) pData;
    if (!Pad) {
        Pad = "";
    }
    for (i=0; i<((nDwords+3)/4); i++) {
        dprintf("%s%02lx:", Pad,  base + i*16);
        for (j=0; (j < 4) && (i*4+j < nDwords); j++) {
            dprintf(" %08lx", pRange[i*4+j]);
        }
        dprintf("\n");
    }
}

BOOL
PrintPciCapHeader(
    PCI_CAPABILITIES_HEADER *pCapHdr,
    PCHAR Pad
    )
{
    if (!Pad) Pad = "";

    dprintf("%sCapID         ", Pad);
    if (pCapHdr->CapabilityID & PCI_CAPABILITY_ID_POWER_MANAGEMENT) {
        dprintf("PwrMgmt ");
    }
    if (pCapHdr->CapabilityID & PCI_CAPABILITY_ID_AGP) {
        dprintf("AGP ");
    }
    if (pCapHdr->CapabilityID & PCI_CAPABILITY_ID_MSI) {
        dprintf("MSI ");
    }
    dprintf("\n");

    dprintf("%sNextPtr       %02lx\n", Pad, pCapHdr->Next);

    return TRUE;
}

void 
PrintPciPwrMgmtCaps(
    USHORT Capabilities
    )
{
    PCI_PMC pmc;

    pmc = *((PCI_PMC *) &Capabilities);

    if (pmc.PMEClock) {
        dprintf("PMECLK ");
    }
    if (pmc.Rsvd1) {
        dprintf("AUXPWR ");
    }
    if (pmc.DeviceSpecificInitialization) {
        dprintf("DSI ");
    }
    if (pmc.Support.D1) {
        dprintf("D1Support ");
    }
    if (pmc.Support.D2) {
        dprintf("D2Support ");
    }
    if (pmc.Support.PMED0) {
        dprintf("PMED0 ");
    }
    if (pmc.Support.PMED1) {
        dprintf("PMED1 ");
    }
    if (pmc.Support.PMED2) {
        dprintf("PMED2 ");
    }
    if (pmc.Support.PMED3Hot) {
        dprintf("PMED3Hot ");
    }
    if (pmc.Support.PMED3Cold) {
        dprintf("PMED3Cold ");
    }
    dprintf("Version=%lx\n", pmc.Version);
}
BOOL
PrintPciPowerManagement(
    PCHAR pData,
    PCHAR Pad
    )
{
    PPCI_PM_CAPABILITY pPmC;
    int i;

    pPmC = (PPCI_PM_CAPABILITY) pData;
    if (!Pad) {
        Pad = "";
    }
    dprintf("%sPwrMgmtCap    ", Pad);
    PrintPciPwrMgmtCaps(pPmC->PMC.AsUSHORT);
    
    dprintf("%sPwrMgmtCtrl   ", Pad);
    PCI_PMCSR CtrlStatus = pPmC->PMCSR.ControlStatus;
    if (CtrlStatus.PMEEnable) {
        dprintf("PMEEnable ");
    }
    if (CtrlStatus.PMEStatus) {
        dprintf("PMESTAT ");
    }
    dprintf("DataScale:%lx ", CtrlStatus.DataScale);
    dprintf("DataSel:%lx ", CtrlStatus.DataSelect);
    dprintf("D%lx%s", CtrlStatus.PowerState, (CtrlStatus.PowerState == 3) ? "Hot " : " ");
    dprintf("\n");

    dprintf("%sPwrMgmtBridge ", Pad);
    if (pPmC->PMCSR_BSE.BridgeSupport.D3HotSupportsStopClock) {
        dprintf("D3HotStopClock ");
    }
    if (pPmC->PMCSR_BSE.BridgeSupport.BusPowerClockControlEnabled) {
        dprintf("BPCCEnable ");
    }
    dprintf("\n");
    return TRUE;
}

BOOL
PrintPciAGP(
    PCHAR pData,
    PCHAR Pad
    )
{
    PPCI_AGP_CAPABILITY pAGP;
    int i;

    pAGP = (PPCI_AGP_CAPABILITY) pData;
    if (!Pad) {
        Pad = "";
    }
    dprintf("%sVersion       Major %lx, Minor %lx\n", 
            Pad,
            pAGP->Major,
            pAGP->Minor);

    dprintf("%sStatus        MaxRQDepth:%lx",
            Pad,
            pAGP->AGPStatus.RequestQueueDepthMaximum);
    if (pAGP->AGPStatus.SideBandAddressing) {
        dprintf(" SBA");
    }
    dprintf(" Rate:%lx\n", pAGP->AGPStatus.Rate);

    dprintf("%sCommand       ", Pad);
    if (pAGP->AGPCommand.SBAEnable) {
        dprintf("SBAEnable ");
    }
    if (pAGP->AGPCommand.AGPEnable) {
        dprintf("AGPEnable ");
    }
    dprintf("RQDepth:%lx ", pAGP->AGPCommand.RequestQueueDepth);
    dprintf("Rate:%lx ", pAGP->AGPCommand.Rate);
    dprintf("\n");
    return TRUE;
}

BOOL
PrintPciMSICaps(
    PCHAR pData,
    PCHAR Pad
    )
{
    PPCI_PCI_CAPABILITY pMsiCap;
    pMsiCap = (PPCI_PCI_CAPABILITY) pData;
    if (!Pad) {
        Pad = "";
    }

    dprintf("%sMsgCtrl       ", Pad);
    if (pMsiCap->MessageControl.CapableOf64Bits) {
        dprintf("64BitCapable ");
    }
    if (pMsiCap->MessageControl.MSIEnable) {
        dprintf("MSIEnable ");
    }
    dprintf("MultipleMsgEnable:%lx ", pMsiCap->MessageControl.MultipleMessageEnable);
    dprintf("MultipleMsgCapable:%lx ", pMsiCap->MessageControl.MultipleMessageCapable);
    dprintf("%sMsgAddr      %lx\n", Pad, pMsiCap->MessageAddress.Raw);
    
    if (pMsiCap->MessageControl.CapableOf64Bits) {
        dprintf("%sMsgAddrHi      %lx\n", pMsiCap->Data.Bit64.MessageUpperAddress);
        dprintf("%sMsData         %lx\n", pMsiCap->Data.Bit64.MessageData);
    } else {
        dprintf("%sMsData         %lx\n", pMsiCap->Data.Bit32.MessageData);
    }
    return TRUE;
}

/*** CardBus Registers
 */

void
PrintCBSktEventReg(
    UCHAR Register
    )
{
    dprintf("%lx ", Register);
    if (Register & SKTEVENT_CSTSCHG) {
        dprintf("CSTSCHG ");
    }
    if (Register & SKTEVENT_CCD1) {
        dprintf("/CCD1 ");
    }
    if (Register & SKTEVENT_CCD2) {
        dprintf("/CCD2 ");
    }
    if (Register & SKTEVENT_POWERCYCLE) {
        dprintf("PowerCycle ");
    }
}

//Socket Mask Register

void
PrintCBSktMaskReg(
    UCHAR Register
    )
{
    dprintf("%lx ", Register);
    
    if (Register & SKTMSK_POWERCYCLE) {
        dprintf("PowerCycle ");
    }
    if (Register & SKTMSK_CSTSCHG) {
        dprintf("CSTSCHG ");
    }
    if ((Register & SKTMSK_CCD) == 0) {
        dprintf("CSCDisabled ");
    } else if ((Register & SKTMSK_CCD) == SKTMSK_CCD) {
        dprintf("CSCEnabled ");
    } else {
        dprintf("Undefined ");
    }

}


//Socket Present State Register
void
PrintCBSktStateReg(
    ULONG Register
    )
{
    dprintf("%08lx ", Register);

    if (Register & SKTSTATE_CSTSCHG) {
        dprintf("CSTSCHG ");
    }
    if (Register & SKTSTATE_POWERCYCLE) {
        dprintf("PowerCycle ");
    }
    if (Register & SKTSTATE_CARDTYPE_MASK) {
        dprintf("");
    }
    if (Register & SKTSTATE_R2CARD) {
        dprintf("R2Card ");
    }
    if (Register & SKTSTATE_CBCARD) {
        dprintf("CBCard ");
    }
    if (Register & SKTSTATE_OPTI_DOCK) {
        dprintf("OptiDock ");
    }
    if (Register & SKTSTATE_CARDINT) {
        dprintf("CardInt ");
    }
    if (Register & SKTSTATE_NOTACARD) {
        dprintf("NotACard ");
    }
    if (Register & SKTSTATE_DATALOST) {
        dprintf("DataLoss ");
    }
    if (Register & SKTSTATE_BADVCCREQ) {
        dprintf("BadVccReq ");
    }
    if (Register & SKTSTATE_5VCARD) {
        dprintf("5VCard ");
    }
    if (Register & SKTSTATE_3VCARD) {
        dprintf("3VCard ");
    }
    if (Register & SKTSTATE_XVCARD) {
        dprintf("XVCard ");
    }
    if (Register & SKTSTATE_YVCARD) {
        dprintf("YVCard ");
    }
    if (Register & SKTSTATE_5VSOCKET) {
        dprintf("5VSkt ");
    }
    if (Register & SKTSTATE_3VSOCKET) {
        dprintf("3VSkt ");
    }
    if (Register & SKTSTATE_XVSOCKET) {
        dprintf("XVSkt ");
    }
    if (Register & SKTSTATE_YVSOCKET) {
        dprintf("YVSkt ");
    }
    if ((Register & SKTSTATE_CCD_MASK) == 0) {
        dprintf("CardPresent ");
    } else if ((Register & SKTSTATE_CCD_MASK) == SKTSTATE_CCD_MASK) {
        dprintf("NoCard ");
    } else {
        dprintf("CardMayPresent ");
    }
}

//Socket Control Register
void PrintCBSktCtrlReg(
    ULONG Register
    )
{
    ULONG Ctrl;
    dprintf("%08lx ", Register);

    Ctrl = Register & SKTPOWER_VPP_CONTROL;
    dprintf("Vpp:");
    switch (Ctrl) {
    case SKTPOWER_VPP_OFF:
        dprintf("Off");
        break;
    case SKTPOWER_VPP_120V:
        dprintf("12V");
        break;
    case SKTPOWER_VPP_050V:
        dprintf("5V");
        break;
    case SKTPOWER_VPP_033V:
        dprintf("3.3V");
        break;
    case SKTPOWER_VPP_0XXV:
        dprintf("X.XV");
        break;
    case SKTPOWER_VPP_0YYV:
        dprintf("Y.YV");
        break;
    }

    dprintf(" Vcc:");
    switch (Register & SKTPOWER_VCC_CONTROL) {
    case SKTPOWER_VCC_OFF:
        dprintf("Off");
        break;
    case SKTPOWER_VCC_050V: 
        dprintf("5V");
        break;
    case SKTPOWER_VCC_033V:
        dprintf("3.3V");
        break;
    case SKTPOWER_VCC_0XXV:
        dprintf("X.XV");
        break;
    case SKTPOWER_VCC_0YYV:
        dprintf("Y.YV");
        break;
    }
    if (Register & SKTPOWER_STOPCLOCK) {
        dprintf(" ClockStopEnabled ");
    }
}

BOOL
PrintCBRegs(
    PCHAR pData,
    PCHAR Pad
    )
{
    ULONG Off=0;
    dprintf("%s%02lx: SktEvent      ", Pad, Off);
    PrintCBSktEventReg(*pData);
    dprintf("\n");
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktMask       ", Pad, Off);
    PrintCBSktMaskReg(*pData);
    dprintf("\n");
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktState      ", Pad, Off);
    PrintCBSktStateReg(*((PULONG)pData));
    dprintf("\n");
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktForce      %08lx\n", Pad, Off, *((PULONG)pData));
    pData+=4; Off+=4;
    dprintf("%s%02lx: SktCtrl       ", Pad, Off);
    PrintCBSktEventReg(*(pData));
    dprintf("\n");

    return FALSE;
}

/*** ExCA Registers
 */

void 
PrintExCARegs(
    PEXCAREGS pExCARegs
    )
{
    struct _MEMWIN_EXCA {
        USHORT Start;
        USHORT Stop;
        USHORT Offset;
        USHORT Reserved;
    } MemWin, *pMemWin;
    
    dprintf("%02lx: IDRev           %02lx", FIELD_OFFSET(EXCAREGS, bIDRev),pExCARegs->bIDRev);
    if ((pExCARegs->bIDRev & IDREV_IFID_MASK) == IDREV_IFID_IO) {
        dprintf(" IOOnly");
    }
    else if ((pExCARegs->bIDRev & IDREV_IFID_MASK) == IDREV_IFID_MEM) {
        dprintf(" MemOnly");
    } else if ((pExCARegs->bIDRev & IDREV_IFID_MASK) == IDREV_IFID_IOMEM) {
        dprintf(" IO&Mem");
    }
    dprintf(" Rev: %02lx\n", pExCARegs->bIDRev & IDREV_REV_MASK);

    dprintf("%02lx: IFStatus        %02lx", 
            FIELD_OFFSET(EXCAREGS, bInterfaceStatus), 
            pExCARegs->bInterfaceStatus);
    
    if (pExCARegs->bInterfaceStatus & IFS_BVD1) {
        dprintf(" BVD1");
    }
    if (pExCARegs->bInterfaceStatus & IFS_BVD2) {
        dprintf(" BVD2");
    }
    if (pExCARegs->bInterfaceStatus & IFS_CD1) {
        dprintf(" CD1");
    }
    if (pExCARegs->bInterfaceStatus & IFS_CD2) {
        dprintf(" CD2");
    }
    if (pExCARegs->bInterfaceStatus & IFS_WP) {
        dprintf(" WP");
    }
    if (pExCARegs->bInterfaceStatus & IFS_RDYBSY) {
        dprintf(" Ready");
    }
    if (pExCARegs->bInterfaceStatus & IFS_CARDPWR_ACTIVE) {
        dprintf(" PowerActive");
    }
    if (pExCARegs->bInterfaceStatus & IFS_VPP_VALID) {
        dprintf(" VppValid");
    }
    dprintf("\n");

    dprintf("%02lx: PwrCtrl         %02lx", FIELD_OFFSET(EXCAREGS, bPowerControl), pExCARegs->bPowerControl);
    
    dprintf(" Vpp1=");
    switch (pExCARegs->bPowerControl & PC_VPP1_MASK) {
    case PC_VPP_NO_CONNECT:
        dprintf("Off");
        break;
    case PC_VPP_SETTO_VCC:
        dprintf("Vcc");
        break;
    case PC_VPP_SETTO_VPP:
        dprintf("Vpp");
        break;
    }
    dprintf(" Vpp2=");
    switch ((pExCARegs->bPowerControl & PC_VPP2_MASK) >> 4) {
    case PC_VPP_NO_CONNECT:
        dprintf("Off");
        break;
    case PC_VPP_SETTO_VCC:
        dprintf("Vcc");
        break;
    case PC_VPP_SETTO_VPP:
        dprintf("Vpp");
        break;
    }
    if (pExCARegs->bPowerControl & PC_CARDPWR_ENABLE) {
        dprintf(" PwrEnable");
    }
    if (pExCARegs->bPowerControl & PC_AUTOPWR_ENABLE) {
        dprintf(" AutoPwrEnabled");
    }
    if (pExCARegs->bPowerControl & PC_RESETDRV_DISABLE) {
        dprintf(" RESETDRVDisabled");
    }
    if (pExCARegs->bPowerControl & PC_OUTPUT_ENABLE) {
        dprintf(" OutputEnable");
    }
    dprintf("\n");

    dprintf("%02lx: IntGenCtrl      %02lx", 
            FIELD_OFFSET(EXCAREGS, bIntGenControl),
            pExCARegs->bIntGenControl);
    switch (pExCARegs->bIntGenControl & ~IGC_IRQ_MASK) {
    case IGC_INTR_ENABLE:
        dprintf(" INTREnable");
        break;
    case IGC_PCCARD_IO:     
        dprintf(" IOCard");
        break;
    case IGC_PCCARD_RESETLO:
        dprintf(" ResetOff");
        break;
    case IGC_RINGIND_ENABLE:
        dprintf(" RingIndEnable");
        break;
    }
    dprintf(" CardIRQ:%lx\n", pExCARegs->bIntGenControl & IGC_IRQ_MASK);

    dprintf("%02lx: CardStatChange  %02lx", FIELD_OFFSET(EXCAREGS, bCardStatusChange), pExCARegs->bCardStatusChange);
    if (pExCARegs->bCardStatusChange & CSC_BATT_DEAD) {
        dprintf(" BATTDEAD");
    }
    if (pExCARegs->bCardStatusChange & CSC_BATT_WARNING) {
        dprintf(" BATTWARN");
    }
    if (pExCARegs->bCardStatusChange & CSC_READY_CHANGE) {
        dprintf(" RDYC");
    }
    if (pExCARegs->bCardStatusChange & CSC_CD_CHANGE) {
        dprintf(" CDC");
    }
    dprintf("\n");
    
    dprintf("%02lx: IntConfig       %02lx", 
            FIELD_OFFSET(EXCAREGS,  bCardStatusIntConfig), 
            pExCARegs->bCardStatusIntConfig);
    if (pExCARegs->bCardStatusIntConfig & CSCFG_BATT_DEAD) {
        dprintf(" BattDeadEnable");
    }
    if (pExCARegs->bCardStatusIntConfig & CSCFG_BATT_WARNING) {
        dprintf(" BattWarnEnable");
    }
    if (pExCARegs->bCardStatusIntConfig & CSCFG_READY_ENABLE) {
        dprintf(" RDYEnable");
    }
    if (pExCARegs->bCardStatusIntConfig & CSCFG_CD_ENABLE) {
        dprintf(" CDEnable");
    }
    dprintf(" CSCIRQ:%lx\n",(pExCARegs->bCardStatusIntConfig & CSCFG_IRQ_MASK));
    
    dprintf("%02lx: WinEnable       %02lx", 
            FIELD_OFFSET(EXCAREGS, bWindowEnable),
            pExCARegs->bWindowEnable);
    if (pExCARegs->bWindowEnable & WE_MEM0_ENABLE) {
        dprintf(" Mem0Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM1_ENABLE) {
        dprintf(" Mem1Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM2_ENABLE) {
        dprintf(" Mem2Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM3_ENABLE) {
        dprintf(" Mem3Enable");
    }
    if (pExCARegs->bWindowEnable & WE_MEM4_ENABLE) {
        dprintf(" Mem4Enable");
    }
                      
    if (pExCARegs->bWindowEnable & WE_MEMCS16_DECODE) {
        dprintf(" DecodeA23-A12");
    }
    if (pExCARegs->bWindowEnable & WE_IO0_ENABLE) {
        dprintf(" IO0Enable");
    }
    if (pExCARegs->bWindowEnable & WE_IO1_ENABLE) {
        dprintf(" IO1Enable");
    }
    dprintf("\n");

    dprintf("%02lx: IOWinCtrl       %02lx", 
            FIELD_OFFSET(EXCAREGS, bIOControl),
            pExCARegs->bIOControl);
    if (pExCARegs->bIOControl & IOC_IO0_DATASIZE) {
        dprintf(" IO0CardIOCS");
    }
    if (pExCARegs->bIOControl & IOC_IO0_IOCS16) {
        dprintf(" IO016Bit");
    }
    if (pExCARegs->bIOControl & IOC_IO0_ZEROWS) {
        dprintf(" IO0ZeroWS");
    }
    if (pExCARegs->bIOControl & IOC_IO0_WAITSTATE) {
        dprintf(" IO0WS");
    }
    if (pExCARegs->bIOControl & IOC_IO1_DATASIZE) {
        dprintf(" IO1CardIOCS");
    }
    if (pExCARegs->bIOControl & IOC_IO1_IOCS16) {
        dprintf(" IO116Bit");
    }
    if (pExCARegs->bIOControl & IOC_IO1_ZEROWS) {
        dprintf(" IO1ZeroWS");
    }
    if (pExCARegs->bIOControl & IOC_IO1_WAITSTATE) {
        dprintf(" IO1WS");
    }
    dprintf("\n");

    dprintf("%02lx: IOWin0Start     %02lx %02lx\n", 
            FIELD_OFFSET(EXCAREGS, bIO0StartLo), 
            pExCARegs->bIO0StartHi, pExCARegs->bIO0StartLo);
    dprintf("%02lx: IOWin0Stop      %02lx %02lx\n", 
            FIELD_OFFSET(EXCAREGS, bIO0StopLo), 
            pExCARegs->bIO0StopHi, pExCARegs->bIO0StopLo);
    dprintf("%02lx: IOWin1Start     %02lx %02lx\n", 
            FIELD_OFFSET(EXCAREGS, bIO1StartLo), 
            pExCARegs->bIO1StartHi, pExCARegs->bIO1StartLo);
    dprintf("%02lx: IOWin1Stop      %02lx %02lx\n", 
            FIELD_OFFSET(EXCAREGS, bIO1StopLo), 
            pExCARegs->bIO1StopHi, pExCARegs->bIO1StopLo);
    
    pMemWin = (struct _MEMWIN_EXCA*) &pExCARegs->bMem0StartLo;
    for (int i=0; 
         i<5; 
         i++, pMemWin++) {
        
        dprintf("%02lx: MemWin%lxStart    %04lx", 
                FIELD_OFFSET(EXCAREGS, bMem0StartLo) + i*sizeof(_MEMWIN_EXCA),
                i, pMemWin->Start & MEMBASE_ADDR_MASK);
        if (pMemWin->Start & MEMBASE_ZEROWS) {
            dprintf(" ZeroWs");
        } else if (pMemWin->Start & MEMBASE_16BIT) {
            dprintf(" 16Bit");
        }
        dprintf("\n");

        dprintf("%02lx: MemWin%lxStop     %04lx, WaitState:%lx\n", 
                FIELD_OFFSET(EXCAREGS, bMem0StopLo) + i*sizeof(_MEMWIN_EXCA),
                i,
                (pMemWin->Stop & MEMEND_ADDR_MASK),
                (pMemWin->Stop & MEMEND_WS_MASK));
        dprintf("%02lx: MemWin%lxOffset   %04lx %s%s\n", 
                FIELD_OFFSET(EXCAREGS, bMem0OffsetLo) + i*sizeof(_MEMWIN_EXCA),
                i,
                (pMemWin->Offset & MEMOFF_ADDR_MASK), 
                ((pMemWin->Offset & MEMOFF_REG_ACTIVE) ? " RegActive" : ""),
                ((pMemWin->Offset & MEMOFF_WP) ? " WP" : "")
                );

    }
}

void
PrintExCAHiRegs(
    PUCHAR pExCaReg,
    PCHAR Pad
    )
{
    ULONG Off = sizeof(EXCAREGS);
    dprintf("%s%02lx: MemWin0High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin1High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin2High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin3High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: MemWin4High     %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: CLIOWin0High    %02lx\n", Pad, Off++, *(pExCaReg++));
    dprintf("%s%02lx: CLIOWin1High    %02lx\n", Pad, Off++, *(pExCaReg++));

}

/***LP  ReadExCAByte - Read ExCA byte register
 *
 *  ENTRY
 *      dwBaseAddr - Base port address
 *      dwReg - register offset
 *
 *  EXIT
 *      returns data read
 */

BYTE ReadExCAByte(ULONG64 dwBaseAddr, DWORD dwReg)
{
    BYTE bData=0;
    ULONG ulSize;

    ulSize = sizeof(BYTE);
    WriteIoSpace64(dwBaseAddr, dwReg, &ulSize);
    ulSize = sizeof(BYTE);
    ReadIoSpace64(dwBaseAddr + 1, (PULONG)&bData, &ulSize);

    return bData;
}       //ReadExCAByte

/***LP  GetClassDesc - Get class description string
 *
 *  ENTRY
 *      bBaseClass - Base Class code
 *      bSubClass - Sub Class code
 *      bProgIF - Program Interface code
 *
 *  EXIT-SUCCESS
 *      returns pointer to description string
 *  EXIT-FAILURE
 *      returns NULL
 */

PSZ GetClassDesc(BYTE bBaseClass, BYTE bSubClass, BYTE bProgIF)
{
    char *psz = NULL;
    int i;
    static struct classtab_s
    {
        BYTE bBaseClass;
        BYTE bSubClass;
        BYTE bProgIF;
        PSZ  pszDesc;
    } ClassTable[] =
        {
            {0x00, 0xff, 0xff, "Legacy controller"},
            {0x00, 0x00, 0x00, "All legacy controller except VGA"},
            {0x00, 0x01, 0x00, "All legacy VGA device"},

            {0x01, 0xff, 0xff, "Mass storage controller"},
            {0x01, 0x00, 0x00, "SCSI bus controller"},
            {0x01, 0x01, 0xff, "IDE controller"},
            {0x01, 0x02, 0x00, "Floppy disk controller"},
            {0x01, 0x03, 0x00, "IPI bus controller"},
            {0x01, 0x04, 0x00, "RAID controller"},
            {0x01, 0x80, 0x00, "Other mass storage controller"},

            {0x02, 0xff, 0xff, "Network controller"},
            {0x02, 0x00, 0x00, "Ethernet controller"},
            {0x02, 0x01, 0x00, "Token ring controller"},
            {0x02, 0x02, 0x00, "FDDI controller"},
            {0x02, 0x03, 0x00, "ATM controller"},
            {0x02, 0x80, 0x00, "Other network controller"},

            {0x03, 0xff, 0xff, "Display controller"},
            {0x03, 0x00, 0x00, "VGA compatible controller"},
            {0x03, 0x00, 0x01, "8514 compatible controller"},
            {0x03, 0x01, 0x00, "XGA controller"},
            {0x03, 0x80, 0x00, "Other display controller"},

            {0x04, 0xff, 0xff, "Multimedia device"},
            {0x04, 0x00, 0x00, "Video device"},
            {0x04, 0x01, 0x00, "Audio device"},
            {0x04, 0x80, 0x00, "Other multimedia device"},

            {0x05, 0xff, 0xff, "Memory controller"},
            {0x05, 0x00, 0x00, "RAM controller"},
            {0x05, 0x01, 0x00, "Flash controller"},
            {0x05, 0x80, 0x00, "Other memory controller"},

            {0x06, 0xff, 0xff, "Bridge device"},
            {0x06, 0x00, 0x00, "Host bridge"},
            {0x06, 0x01, 0x00, "ISA bridge"},
            {0x06, 0x02, 0x00, "EISA bridge"},
            {0x06, 0x03, 0x00, "MCA bridge"},
            {0x06, 0x04, 0x00, "PCI-PCI bridge"},
            {0x06, 0x05, 0x00, "PCMCIA bridge"},
            {0x06, 0x06, 0x00, "NuBus bridge"},
            {0x06, 0x07, 0x00, "CardBus bridge"},
            {0x06, 0x80, 0x00, "Other bridge device"},

            {0x07, 0xff, 0xff, "Simple com device"},
            {0x07, 0x00, 0x00, "Generic XT compatible serial controller"},
            {0x07, 0x00, 0x01, "16450 compatible serial controller"},
            {0x07, 0x00, 0x02, "16550 compatible serial controller"},
            {0x07, 0x01, 0x00, "Parallel port"},
            {0x07, 0x01, 0x01, "Bidirectional parallel port"},
            {0x07, 0x01, 0x02, "ECP 1.X compliant parallel port"},
            {0x07, 0x80, 0x00, "Other communication device"},

            {0x08, 0xff, 0xff, "Base system peripherals"},
            {0x08, 0x00, 0x00, "Generic 8259 PIC"},
            {0x08, 0x00, 0x01, "ISA PIC"},
            {0x08, 0x00, 0x02, "EISA PIC"},
            {0x08, 0x01, 0x00, "Generic 8237 DMA controller"},
            {0x08, 0x01, 0x01, "ISA DMA controller"},
            {0x08, 0x01, 0x02, "EISA DMA controller"},
            {0x08, 0x02, 0x00, "Generic 8254 system timer"},
            {0x08, 0x02, 0x01, "ISA system timer"},
            {0x08, 0x02, 0x02, "EISA system timer"},
            {0x08, 0x03, 0x00, "Generic RTC controller"},
            {0x08, 0x03, 0x01, "ISA RTC controller"},
            {0x08, 0x80, 0x00, "Other system peripheral"},

            {0x09, 0xff, 0xff, "Input device"},
            {0x09, 0x00, 0x00, "Keyboard controller"},
            {0x09, 0x01, 0x00, "Digitizer (pen)"},
            {0x09, 0x02, 0x00, "Mouse controller"},
            {0x09, 0x80, 0x00, "Other input controller"},

            {0x0a, 0xff, 0xff, "Docking station"},
            {0x0a, 0x00, 0x00, "Generic docking station"},
            {0x0a, 0x80, 0x00, "Other type of docking station"},

            {0x0b, 0xff, 0xff, "Processor"},
            {0x0b, 0x00, 0x00, "386"},
            {0x0b, 0x01, 0x00, "486"},
            {0x0b, 0x02, 0x00, "Pentium"},
            {0x0b, 0x10, 0x00, "Alpha"},
            {0x0b, 0x20, 0x00, "PowerPC"},
            {0x0b, 0x40, 0x00, "Co-processor"},

            {0x0c, 0xff, 0xff, "Serial bus controller"},
            {0x0c, 0x00, 0x00, "FireWire (IEEE 1394)"},
            {0x0c, 0x01, 0x00, "ACCESS bus"},
            {0x0c, 0x02, 0x00, "SSA"},
            {0x0c, 0x03, 0x00, "Universal Serial Bus (USB)"},
            {0x0c, 0x04, 0x00, "Fibre Channel"},

            {0xff, 0xff, 0xff, "Unknown"},
            {0x00, 0x00, 0x00, NULL}
        };

    for (i = 0; ClassTable[i].pszDesc != NULL; ++i)
    {
        if ((ClassTable[i].bBaseClass == bBaseClass) &&
            (ClassTable[i].bSubClass == bSubClass) &&
            (ClassTable[i].bProgIF == bProgIF))
        {
            psz = ClassTable[i].pszDesc;
        }
    }

    return psz;
}       //GetClassDesc


/***LP  PrintClassInfo - Print device class info.
 *
 *  ENTRY
 *      pb -> ConfigSpace
 *      dwReg - ConfigSpace register
 *
 *  EXIT
 *      None
 */

VOID PrintClassInfo(PBYTE pb, DWORD dwReg)
{
    PPCI_COMMON_CONFIG pcc = (PPCI_COMMON_CONFIG) pb;
    BYTE bBaseClass, bSubClass, bProgIF;
    PSZ psz;

    if (dwReg == FIELD_OFFSET(PCI_COMMON_CONFIG ,BaseClass))
    {
        bBaseClass = pcc->BaseClass;
        bSubClass = 0xff;
        bProgIF = 0xff;
    }
    else if (dwReg == FIELD_OFFSET(PCI_COMMON_CONFIG ,SubClass))
    {
        bBaseClass = pcc->BaseClass;
        bSubClass = pcc->SubClass;
        bProgIF = 0xff;
    }
    else        //must be CFGSPACE_CLASSCODE_PI
    {
        bBaseClass = pcc->BaseClass;
        bSubClass = pcc->SubClass;
        bProgIF = pcc->ProgIf;
    }

    if ((psz = GetClassDesc(bBaseClass, bSubClass, bProgIF)) != NULL)
        dprintf(" (%s)", psz);
    else if ((bBaseClass == 0x01) && (bSubClass == 0x01) && (bProgIF != 0xff) &&
             (bProgIF != 0x00))
    {
        dprintf(" (");
        if (bProgIF & 0x80)
            dprintf("MasterIDE ");
        if (bProgIF & 0x02)
            dprintf("PriNativeCapable ");
        if (bProgIF & 0x01)
            dprintf("PriNativeMode ");
        if (bProgIF & 0x08)
            dprintf("SecNativeCapable ");
        if (bProgIF & 0x04)
            dprintf("SecNativeMode");
        dprintf(")");
    }

    dprintf("\n");
}       //PrintClassInfo

VOID
DumpCfgSpace (
    IN PPCI_COMMON_CONFIG pcs
    )
{
    BYTE bHeaderType = pcs->HeaderType & ~PCI_MULTIFUNCTION;
    DWORD dwOffset;
    PSZ pszDataFmt = "%02x: ";

    dwOffset = 0;       

    if (PrintCommonConfigSpace(pcs, "  ")) {
        switch (bHeaderType)
        {
        case PCI_DEVICE_TYPE:
            dprintf("    DeviceType (@%02lx):\n", FIELD_OFFSET(PCI_COMMON_CONFIG,u));
            PrintCfgSpaceType0(pcs, "    ");
            break;

        case PCI_BRIDGE_TYPE:
            dprintf("    BridgeType (@%02lx):\n", FIELD_OFFSET(PCI_COMMON_CONFIG,u));
            PrintCfgSpaceType1(pcs, "    ");
            break;

        case PCI_CARDBUS_BRIDGE_TYPE:
            dprintf("    CardBusBridgeType (@%02lx):\n", FIELD_OFFSET(PCI_COMMON_CONFIG,u));
            PrintCfgSpaceType2(pcs, "    ");
            break;

        default:
            dprintf("    TypeUnknown:\n");
            PrintDataRange((PCHAR) &pcs->u, 12, FIELD_OFFSET(PCI_COMMON_CONFIG, u),  "    ");
        }

        if ((pcs->Status & PCI_STATUS_CAPABILITIES_LIST)) {
            if (bHeaderType == PCI_DEVICE_TYPE) {
                dwOffset = pcs->u.type0.CapabilitiesPtr;
            }
            else if (bHeaderType == PCI_BRIDGE_TYPE) {
                dwOffset = pcs->u.type1.CapabilitiesPtr;
            }
            else if (bHeaderType == PCI_CARDBUS_BRIDGE_TYPE) {
                dwOffset = pcs->u.type2.CapabilitiesPtr;
            }
            else {
                dwOffset = 0;
            }
            dprintf("      Capabilities (@%02lx):\n", dwOffset);
            while ((dwOffset != 0)) {
                PPCI_CAPABILITIES_HEADER pCap;

                pCap = (PPCI_CAPABILITIES_HEADER)&((PBYTE)pcs)[dwOffset];
                
                if (PrintPciCapHeader(pCap, "      ")) {
                    switch (pCap->CapabilityID) {
                    case PCI_CAPABILITY_ID_POWER_MANAGEMENT:
                        PrintPciPowerManagement(((PCHAR)pCap), "      ");
                        break;

                    case PCI_CAPABILITY_ID_AGP:
                        PrintPciAGP(((PCHAR)pCap), "      ");
                        break;

                    case PCI_CAPABILITY_ID_MSI:
                        PrintPciMSICaps(((PCHAR)pCap), "      ");
                        break;
                    }
                    dwOffset = pCap->Next;
                } else {
                    break;
                }
            }
        }
    
    }
    PrintDataRange((PCHAR) pcs, sizeof(PCI_COMMON_CONFIG)/4, 0, "  ");
}

/***LP  DumpCBRegs - Dump CardBus registers
 *
 *  ENTRY
 *      pbBuff -> register base
 *
 *  EXIT
 *      None
 */

VOID DumpCBRegs(PBYTE pbBuff)
{

    PrintCBRegs((PCHAR) pbBuff, "");
}       //DumpCBRegs

/***LP  DumpExCARegs - Dump ExCA registers
 *
 *  ENTRY
 *      pbBuff -> buffer
 *      dwSize - size of buffer
 *
 *  EXIT
 *      None
 */

VOID DumpExCARegs(PBYTE pbBuff, DWORD dwSize)
{
    DWORD dwOffset = 0;
    char *pszDataFmt = "%02x: ";

    PrintExCARegs((PEXCAREGS) pbBuff);
    PrintExCAHiRegs(pbBuff + sizeof(EXCAREGS), "");
}       //DumpExCARegs

DECLARE_API( dcs )
/*++

Routine Description:

    Dumps PCI ConfigSpace

Arguments:

    args - Supplies the Bus.Dev.Fn numbers

Return Value:

    None

--*/
{
    LONG lcArgs;
    DWORD dwBus = 0;
    DWORD dwDev = 0;
    DWORD dwFn = 0;
    

    lcArgs = sscanf(args, "%lx.%lx.%lx", &dwBus, &dwDev, &dwFn);
    
    dprintf("!dcs now integrated into !pci 1xx (flag 100).\n"
            "Use !pci 100 %lx %lx %lx to dump PCI config space.\n",
            dwBus, dwDev, dwFn);
    return E_INVALIDARG;

    
    if (lcArgs != 3)
    {
        dprintf("invalid command syntax\n"
                "Usage: dcs <Bus>.<Dev>.<Func>\n");
    }
    else
    {
        PCI_TYPE1_CFG_BITS PciCfg1;
        PCI_COMMON_CONFIG  cs;

        PciCfg1.u.AsULONG = 0;
        PciCfg1.u.bits.BusNumber = dwBus;
        PciCfg1.u.bits.DeviceNumber = dwDev;
        PciCfg1.u.bits.FunctionNumber = dwFn;
        PciCfg1.u.bits.Enable = TRUE;
    
        ReadPci(&PciCfg1, (PUCHAR)&cs, 0, sizeof(cs));
        DumpCfgSpace(&cs);
        
    }
    return S_OK;
}

DECLARE_API( ecs )
/*++

Routine Description:

    Edit PCI ConfigSpace

Arguments:

    args - Bus.Dev.Fn 
           Dword Offset
           Data

Return Value:

    None

--*/
{
    
    dprintf("Edit PCI ConfigSpace - must use one of the following:\n"
            "!ecd - edit dword\n"
            "!ecw - edit word\n"
            "!ecb - edit byte\n");
    
    return S_OK;
}

DECLARE_API( ecb )
/*++

Routine Description:

    Edit PCI ConfigSpace BYTE

Arguments:

    args - Bus.Dev.Fn Offset Data

Return Value:

    None

--*/
{
    LONG                lcArgs;
    DWORD               bus = 0, dev = 0, fn = 0;
    DWORD               offset = 0, data = 0;
    PCI_TYPE1_CFG_BITS  pcicfg;

    lcArgs = sscanf(args, "%lx.%lx.%lx %lx %lx", &bus, &dev, &fn, &offset, &data);
    if (lcArgs != 5)
    {
        dprintf("invalid command syntax\n"
                "Usage: ecb <Bus>.<Dev>.<Func> Offset Data\n");
    }else{

        //
        // Init for PCI config.
        //
        pcicfg.u.AsULONG = 0;
        pcicfg.u.bits.BusNumber = bus;
        pcicfg.u.bits.DeviceNumber = dev;
        pcicfg.u.bits.FunctionNumber = fn;
        pcicfg.u.bits.Enable = TRUE;
        
        if (!(WritePci (&pcicfg, (PUCHAR)&data, offset, sizeof(UCHAR)))){
            dprintf("write operation failed!\n");
            return S_FALSE;
        }
    }
    return S_OK;
}

DECLARE_API( ecw )
/*++

Routine Description:

    Edit PCI ConfigSpace WORD

Arguments:

    args - Bus.Dev.Fn Offset Data

Return Value:

    None

--*/
{
    LONG                lcArgs;
    DWORD               bus = 0, dev = 0, fn = 0;
    DWORD               offset = 0, data = 0;
    PCI_TYPE1_CFG_BITS  pcicfg;

    lcArgs = sscanf(args, "%lx.%lx.%lx %lx %lx", &bus, &dev, &fn, &offset, &data);
    if (lcArgs != 5)
    {
        dprintf("invalid command syntax\n"
                "Usage: ecw <Bus>.<Dev>.<Func> Offset Data\n");
    }else{
        
        if ((offset & 0x1) || (offset > 0xfe)) {
            //
            //  not word aligned.
            //
            dprintf("offset must be word aligned and no greater than 0xfe\n");
            return S_OK;
        }
        
        //
        // Init for PCI config.
        //
        pcicfg.u.AsULONG = 0;
        pcicfg.u.bits.BusNumber = bus;
        pcicfg.u.bits.DeviceNumber = dev;
        pcicfg.u.bits.FunctionNumber = fn;
        pcicfg.u.bits.Enable = TRUE;
        
        if (!(WritePci (&pcicfg, (PUCHAR)&data, offset, sizeof(USHORT)))){
            dprintf("write operation failed!\n");
            return S_FALSE;
        }
        
    }
    return S_OK;
}

DECLARE_API( ecd )
/*++

Routine Description:

    Edit PCI ConfigSpace DWORD

Arguments:

    args - Bus.Dev.Fn Offset Data

Return Value:

    None

--*/
{
    LONG                lcArgs;
    DWORD               bus = 0, dev = 0, fn = 0;
    DWORD               offset = 0, data = 0;
    PCI_TYPE1_CFG_BITS  pcicfg;

    lcArgs = sscanf(args, "%lx.%lx.%lx %lx %lx", &bus, &dev, &fn, &offset, &data);
    if (lcArgs != 5)
    {
        dprintf("invalid command syntax\n"
                "Usage: ecd <Bus>.<Dev>.<Func> Offset Data\n");
    }else{
        
        if ((offset & 0x3) || (offset > 0xfc)) {
            //
            //  not dword aligned.
            //
            dprintf("offset must be dword aligned and no greater than 0xfc\n");
            return S_OK;
        }
        
        //
        // Init for PCI config.
        //
        pcicfg.u.AsULONG = 0;
        pcicfg.u.bits.BusNumber = bus;
        pcicfg.u.bits.DeviceNumber = dev;
        pcicfg.u.bits.FunctionNumber = fn;
        pcicfg.u.bits.Enable = TRUE;
        
        if (!(WritePci (&pcicfg, (PUCHAR)&data, offset, sizeof(ULONG)))){
            dprintf("write operation failed!\n");
            return S_FALSE;
        }
        
    }
    return S_OK;
}

DECLARE_API( cbreg )
/*++

Routine Description:

    Dumps CardBus registers

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    BOOL rc = TRUE;
    LONG lcArgs;
    BOOL fPhysical = FALSE;
    DWORD dwAddr = 0;

    if (args == NULL)
    {
        dprintf("invalid command syntax\n"
                "Usage: cbreg <RegBaseAddr>\n");
        rc = FALSE;
    }
    else if ((args[0] == '%') && (args[1] == '%'))
    {
        lcArgs = sscanf(&args[2], "%lx", &dwAddr);
        fPhysical = TRUE;
    }
    else
    {
        lcArgs = sscanf(args, "%lx", &dwAddr);
    }

    if ((rc == TRUE) && (lcArgs == 1))
    {
        BYTE abCBRegs[0x14];
        BYTE abExCARegs[0x47];
        DWORD dwSize;

        if (fPhysical)
        {
            ULONG64 phyaddr = 0;

            phyaddr = dwAddr;
            ReadPhysical(phyaddr, abCBRegs, sizeof(abCBRegs), &dwSize);
            if (dwSize != sizeof(abCBRegs))
            {
                dprintf("failed to read physical CBRegs (SizeRead=%x)\n",
                        dwSize);
                rc = FALSE;
            }
            else
            {
                phyaddr += 0x800;
                ReadPhysical(phyaddr, abExCARegs, sizeof(abExCARegs), &dwSize);
                if (dwSize != sizeof(abExCARegs))
                {
                    dprintf("failed to read physical ExCARegs (SizeRead=%x)\n",
                            dwSize);
                    rc = FALSE;
                }
            }
        }
        else if (!ReadMemory(dwAddr, abCBRegs, sizeof(abCBRegs), &dwSize) ||
                 (dwSize != sizeof(abCBRegs)))
        {
            dprintf("failed to read CBRegs (SizeRead=%x)\n", dwSize);
            rc = FALSE;
        }
        else if (!ReadMemory(dwAddr + 0x800, abExCARegs, sizeof(abExCARegs),
                             &dwSize) ||
                 (dwSize != sizeof(abExCARegs)))
        {
            dprintf("failed to read CBRegs (SizeRead=%x)\n", dwSize);
            rc = FALSE;
        }

        if (rc == TRUE)
        {
            dprintf("\nCardBus Registers:\n");
            DumpCBRegs(abCBRegs);
            dprintf("\nExCA Registers:\n");
            DumpExCARegs(abExCARegs, sizeof(abExCARegs));
        }
    }
    return S_OK;
}

DECLARE_API( exca )
/*++

Routine Description:

    Dumps CardBus ExCA registers

Arguments:

    args - Supplies <BasePort>.<SktNum>

Return Value:

    None

--*/
{
    LONG lcArgs;
    DWORD dwBasePort = 0;
    DWORD dwSktNum = 0;

    if (TargetMachine != IMAGE_FILE_MACHINE_I386) {
        dprintf("X86 target only API.\n");
        return E_INVALIDARG;
    }

    lcArgs = sscanf(args, "%lx.%lx", &dwBasePort, &dwSktNum);
    if (lcArgs != 2)
    {
        dprintf("invalid command syntax\n"
                "Usage: exca <BasePort>.<SocketNum>\n");
    }
    else
    {
        int i;
        BYTE abExCARegs[0x40];

        for (i = 0; i < sizeof(abExCARegs); ++i)
        {
            abExCARegs[i] = ReadExCAByte(dwBasePort,
                                         (ULONG)(dwSktNum*0x40 + i));
        }

        DumpExCARegs(abExCARegs, sizeof(abExCARegs));
    }
    return S_OK; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\pci.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pci.c

Abstract:

    WinDbg Extension Api

Author:

    Ken Reneris (kenr) 18-August-1997

Environment:

    User Mode.

Revision History:

--*/

#include "precomp.h"
#include "pci.h"
#pragma hdrstop


#define DUMP_VERBOSE                    0x01
#define DUMP_TO_MAX_BUS                 0x02        // from 0 to max
#define DUMP_RAW_BYTES                  0x04        // hex dump dump raw bytes
#define DUMP_RAW_DWORDS                 0x08        // hex dump dump raw dwords

#define DUMP_ALLOW_INVALID_DEVICE       0x10
#define DUMP_ALLOW_INVALID_FUNCTION     0x20
#define DUMP_CAPABILITIES               0x40
#define DUMP_INTEL                      0x80

#define DUMP_CONFIGSPACE               0x100




#define ANY                 0xFF

PSZ GetClassDesc(BYTE bBaseClass, BYTE bSubClass, BYTE bProgIF);

UCHAR PCIDeref[4][4] = { {4,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };

VOID
DumpCfgSpace (
    IN PPCI_COMMON_CONFIG pcs
    );

VOID
HexDump (
    IN ULONG    indent,
    IN ULONG    va,
    IN ULONG    len,
    IN ULONG    width,
    IN PUCHAR   buf
    )
{
    UCHAR   s[80], t[80];
    PUCHAR  ps, pt;
    ULONG   i;
    static  UCHAR rgHexDigit[] = "0123456789abcdef";

    i = 0;

    //
    // If width = 4, dull dump, similar to debugger's dd command.
    //

    if (width == 4) {
        if (len & 3) {
            dprintf("hexdump internal error, dump dword, (len & 3) != 0\n");

            // round up.

            len += 3;
            len &= ~3;
        }
        while (len) {
            if (i == 0) {
                dprintf("%*s%08x: ", indent, "", va);
                va += 16;
            }
            dprintf(" %08x", *(ULONG UNALIGNED *)buf);
            len -= 4;
            buf += 4;
            if (i == 3) {
                dprintf("\n");
                i = 0;
            } else {
                i++;
            }
        }
        return;
    }

    if (width != 1) {
        dprintf ("hexdump internal error\n");
        return ;
    }

    //
    // Width = 1, pretty dump, similar to debugger's db command.
    //

    while (len) {
        ps = s;
        pt = t;

        ps[0] = 0;
        pt[0] = '*';
        pt++;

        for (i=0; i < 16; i++) {
            ps[0] = ' ';
            ps[1] = ' ';
            ps[2] = ' ';

            if (len) {
                ps[0] = rgHexDigit[buf[0] >> 4];
                ps[1] = rgHexDigit[buf[0] & 0xf];
                pt[0] = buf[0] < ' ' || buf[0] > 'z' ? '.' : buf[0];

                len -= 1;
                buf += 1;
                pt  += 1;
            }
            ps += 3;
        }

        ps[0] = 0;
        pt[0] = '*';
        pt[1] = 0;
        s[23] = '-';

        if (s[0]) {
            dprintf ("%*s%08lx: %s  %s\n", indent, "", va, s, t);
            va += 16;
        }
    }

}

BOOL
ReadPci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    OUT PUCHAR                  Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    ULONG                   InputSize;
    ULONG                   IoSize;
    ULONG                   i;
    BUSDATA                 busData;
    PCI_SLOT_NUMBER         slot;
    BOOL                    b;
    
    //
    // Zap input buffer
    //

    for (i=0; i < Length; i++) {
        Buffer[i] = 0xff;
    }

    //
    // It appears that we are only safe to call the HAL for reading
    // configuration space if the HAL has actually been initialized far
    // enough to do so.  Since we have already hit a case where we hadnt
    // initialized everything and it crashed the debugger, we are restoring
    // X86 so that it reads configspace the way it always used to do.
    //
    // For non-X86 (i.e IA64) we are forced to call the HAL because we
    // currently have no other option.  This means we may still crash on
    // those platforms in the case where
    // the HAL hasnt been initialized enough to handle it.
    //

    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        while (Length) {
            PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
            IoSize = sizeof(ULONG);
#ifdef IG_IO_SPACE_RETURN
            b = 
#else
            b = TRUE;
#endif          
                WriteIoSpace64 ( PCI_TYPE1_ADDR_PORT, PciCfg1->u.AsULONG, &IoSize );
            if (!b) {
                return FALSE;
            }
            IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
            i = IoSize;
    
            ReadIoSpace64 (
                PCI_TYPE1_DATA_PORT + (Offset % sizeof(ULONG)),
                (PULONG) Buffer,
                &i
                );
    
            Offset += IoSize;
            Buffer += IoSize;
            Length -= IoSize;
        }
    }else{
    
        //
        //  Here we are going to call the debugger api that results in the 
        //  call to HalGetBusDataByOffset for the read.
        //  
        //  Note: This will crash the current debug session of attempted too
        //  early in boot.
        //

        slot.u.AsULONG              = 0;
        slot.u.bits.DeviceNumber    = PciCfg1->u.bits.DeviceNumber;
        slot.u.bits.FunctionNumber  = PciCfg1->u.bits.FunctionNumber;
    
        busData.BusDataType         = PCIConfiguration;
        busData.BusNumber           = PciCfg1->u.bits.BusNumber;
        busData.SlotNumber          = slot.u.AsULONG;
        busData.Offset              = Offset;
        busData.Buffer              = Buffer;
        busData.Length              = Length;
    
        //
        // Read it
        //
#ifdef IG_IO_SPACE_RETURN
        b = 
#else
        b = TRUE;
#endif          
        Ioctl(IG_GET_BUS_DATA, &busData, sizeof(busData));
        if (!b) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOLEAN
WritePci (
    IN PPCI_TYPE1_CFG_BITS      PciCfg1,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    
    ULONG                   IoSize;
    ULONG                   i;
    BUSDATA                 busData;
    PCI_SLOT_NUMBER         slot;
    
    if (TargetMachine == IMAGE_FILE_MACHINE_I386) {

        //
        //  For the same reasons as the read, we are only calling the HAL
        //  on non-x86 targets for now.
        // 
    
        while (Length) {
            PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
            IoSize = sizeof(ULONG);
            WriteIoSpace64 ((ULONG) PCI_TYPE1_ADDR_PORT, PciCfg1->u.AsULONG, &IoSize );
    
            IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
            i = IoSize;
    
            WriteIoSpace64 (
                PCI_TYPE1_DATA_PORT + (Offset % sizeof(ULONG)),
                *(PULONG)Buffer,
                &i);
    
            Offset += IoSize;
            Buffer += IoSize;
            Length -= IoSize;
        }
    }else{

        slot.u.AsULONG              = 0;
        slot.u.bits.DeviceNumber    = PciCfg1->u.bits.DeviceNumber;
        slot.u.bits.FunctionNumber  = PciCfg1->u.bits.FunctionNumber;
    
        busData.BusDataType         = PCIConfiguration;
        busData.BusNumber           = PciCfg1->u.bits.BusNumber;
        busData.SlotNumber          = slot.u.AsULONG;
        busData.Offset              = Offset;
        busData.Buffer              = Buffer;
        busData.Length              = Length;

        //
        // Write it
        //
        if (!(Ioctl(IG_SET_BUS_DATA, &busData, sizeof(busData)))){
            return FALSE;
        }


    }

    return TRUE;
}

VOID
DumpPciBar (
    IN ULONG        barno,
    IN ULONG        indent,
    IN ULONG        bar,
    IN OUT PULONG   state
    )
{
    ULONG       type, i;
    CHAR        m[20], str[80];

    if (bar) {

        if (bar & 1) {
            sprintf (str, "IO[%d]:%x  ", barno, bar);

        } else {
            type = (bar >> 1) & 0x3;

            if (bar & 8) {
                strcpy (m, "MPF");
            } else {
                strcpy (m, "MEM");
            }

            if (type == 0x01) {
                m[1] = '1';         // less then 1M
            }

            sprintf (str, "%s[%d]:%x  ", m, barno, bar);

            if (type == 0x10) {
                dprintf ("warning - 64bit bar not decoded\n");
                *state = 0;
            }
            if (type == 0x11) {
                dprintf ("bar type is reserved\n");
                *state = 0;
            }
        }

        if (!*state) {
            dprintf ("%*s", indent, "");
        }

        i = strlen(str);
        dprintf("%s%*s", str, 17-i, "");
        *state += i;
    }
}


VOID
DumpPciType2Bar(
    IN BOOLEAN    barIsIo,
    IN BOOLEAN    barIsBase,
    IN ULONG      barno,
    IN ULONG      indent,
    IN ULONG      bar,
    IN OUT PULONG state
    )
{
   ULONG      i;
   CHAR       str[80];
   if (bar) {
     if (barIsIo) {
          sprintf (str, "IO[%d].%s:%x  ", barno, (barIsBase?"base":"limit"), bar);
     } else {
          sprintf (str, "MEM[%d].%s:%x  ", barno, (barIsBase?"base":"limit"), bar);
     }
     if (!*state) {
          dprintf("%*s", indent, "");
     }
     i = strlen(str);
     dprintf("%s%*s", str, 17-i, "");
     *state += i;
   }
}
    
               
VOID
DumpPciBarComplete(
    IN OUT PULONG   state
    )
{
    if (*state) {
        dprintf ("\n");
        *state = 0;
    }
}


VOID
DumpCapabilities(
    IN UCHAR                    CapPtr,
    IN PPCI_TYPE1_CFG_BITS      PciCfg1
    )
{
    union _cap_buffer {
        PCI_CAPABILITIES_HEADER header;
        PCI_PM_CAPABILITY       pm;
        PCI_AGP_CAPABILITY      agp;
    } cap;

    PCHAR ts;
    ULONG  t;

    do {
        if (CapPtr < PCI_COMMON_HDR_LENGTH) {

            dprintf("       Error: Capability pointer 0x%02x points to common header (invalid).\n",
                CapPtr
                );
            break;
        }

        if (CapPtr & 0x3) {

            dprintf("       Error: Capability pointer 0x%02x not DWORD aligned (invalid).\n",
                CapPtr
                );
            break;
        }

        ReadPci (
            PciCfg1,
            (PUCHAR)&cap,
            CapPtr,
            sizeof(cap.header)
            );

        switch (cap.header.CapabilityID) {
            case PCI_CAPABILITY_ID_POWER_MANAGEMENT:

                ReadPci (
                    PciCfg1,
                    (PUCHAR)&cap,
                    CapPtr,
                    sizeof(cap.pm)
                    );
                t = cap.pm.PMC.AsUSHORT;
                dprintf("      Cap[%02x] ID %02x \n",
                    CapPtr,
                    cap.header.CapabilityID
                    );
                dprintf("          PMC   %04x (%s%s%s%s%s%s %s%s%s%s%s%sv%x)\n",
                    t,
                    t & 0xf800 ? "PME from D" : "<No PME>",
                    t & 0x8000 ? "3C" : "",
                    t & 0x4000 ? "3H" : "",
                    t & 0x2000 ? "2" : "",
                    t & 0x1000 ? "1" : "",
                    t & 0x0800 ? "0" : "",
                    t & 0x0600 ? "Supports D" : "",
                    cap.pm.PMC.Capabilities.Support.D2 ? "2" : "",
                    cap.pm.PMC.Capabilities.Support.D1 ? "1" : "",
                    t & 0x0600 ? " " : "",
                    cap.pm.PMC.Capabilities.DeviceSpecificInitialization ?
                        "DSI " : "",
                    cap.pm.PMC.Capabilities.PMEClock ? "PME needs Clock, " : "",
                    cap.pm.PMC.Capabilities.Version
                    );
                        
                t &= 0x01d0;
                if (t) {
                    dprintf("                         WARNING PMC non-zero reserved fields %04x\n",
                        t
                        );
                }

                t = cap.pm.PMCSR.AsUSHORT;
                dprintf("          PMCSR %04x (PME_Status=%d PME_En=%d State=D%d%s)\n",
                    t,
                    cap.pm.PMCSR.ControlStatus.PMEStatus,
                    cap.pm.PMCSR.ControlStatus.PMEEnable,
                    cap.pm.PMCSR.ControlStatus.PowerState,
                    cap.pm.PMCSR.ControlStatus.PowerState == 3 ?
                        "hot" : ""
                    );

                //
                // Here would be a good time to run
                // run down the data registers if
                // they exist.
                //

                break;

            case PCI_CAPABILITY_ID_AGP:

                ReadPci (
                    PciCfg1,
                    (PUCHAR)&cap,
                    CapPtr,
                    sizeof(cap.agp)
                    );

                switch (cap.agp.AGPStatus.Rate) {
                    case 1:
                        ts = "1X";
                        break;
                    case 2:
                        ts = "2X";
                        break;
                    case 3:
                        ts = "1,2X";
                        break;
                    default:
                        ts = "<inv>";
                        break;
                }
                t = *(PULONG)&cap.agp.AGPStatus;

                dprintf("      Cap[%02x] ID %02x AGP mj/mn=%x/%x\n",
                    CapPtr,
                    cap.header.CapabilityID,
                    cap.agp.Major,
                    cap.agp.Minor
                    );

                dprintf("          Status  %08x (Rq:%02x SBA:%x Rate:%x (%s))\n",
                    t,
                    cap.agp.AGPStatus.RequestQueueDepthMaximum,
                    cap.agp.AGPStatus.SideBandAddressing,
                    cap.agp.AGPStatus.Rate,
                    ts
                    );

                switch (cap.agp.AGPCommand.Rate) {
                    case 1:
                        ts = "1X";
                        break;
                    case 2:
                        ts = "2X";
                        break;
                    case 4:
                        ts = "4X";
                        break;
                    default:
                        ts = "<not set>";
                        break;
                }
                t = *(PULONG)&cap.agp.AGPCommand;

                dprintf("          Command %08x (Rq:%02x SBA:%x AGP:%x Rate:%x (%s)\n",
                    t,
                    cap.agp.AGPCommand.RequestQueueDepth,
                    cap.agp.AGPCommand.SBAEnable,
                    cap.agp.AGPCommand.AGPEnable,
                    cap.agp.AGPCommand.Rate,
                    ts
                    );

                break;

            default:

                break;
        }
        CapPtr = cap.header.Next;
    } while (CapPtr != 0);
}

VOID
pcidump (
    IN ULONG        Flags,
    IN ULONG        MinBus,
    IN ULONG        MaxBus,
    IN ULONG        MinDevice,
    IN ULONG        MaxDevice,
    IN ULONG        MinFunction,
    IN ULONG        MaxFunction,
    IN ULONG        MinAddr,
    IN ULONG        MaxAddr
    )
{
    ULONG                   Bus, Device, Function;
    PCI_TYPE1_CFG_BITS      PciCfg1;
    PCI_COMMON_CONFIG       PciHdr;
    BOOLEAN                 BusHeader, SkipLine, BarIsIo;
    ULONG                   Type, Len, i;
    UCHAR                   s[40];
    PUCHAR                  Buf;
    ULONG                   state;
    ULONG                   bar, barno;

    if (MinBus > 0xFF || MaxBus > 0xFF ||
        MinDevice > PCI_MAX_DEVICES || MaxDevice > PCI_MAX_DEVICES ||
        MinFunction > PCI_MAX_FUNCTION || MaxFunction > PCI_MAX_FUNCTION ||
        MinAddr > 0xFF || MaxAddr > 0x100 || MinAddr > MaxAddr) {

        dprintf ("Bad pci dump parameter\n");

        //dprintf ("Flags %d  MinBus %d  MaxBus %d\n", Flags, MinBus, MaxBus);
        //dprintf ("MinDev %d  MaxDev %d  MinFnc %d MinFnc %d\n", MinDevice, MaxDevice, MinFunction, MaxFunction);

        return ;
    }

    //dprintf ("Flags %d  MinAddr %d  MaxAddr %d\n", Flags, MinAddr, MaxAddr);

    for (Bus=MinBus; Bus <= MaxBus; Bus++) {

        BusHeader = FALSE;

        for (Device=MinDevice; Device <= MaxDevice; Device++) {

            if (CheckControlC()) {
                return;
            }

            //
            // Read the device ID
            //

            PciCfg1.u.AsULONG = 0;
            PciCfg1.u.bits.BusNumber = Bus;
            PciCfg1.u.bits.DeviceNumber = Device;
            PciCfg1.u.bits.FunctionNumber = 0;
            PciCfg1.u.bits.Enable = TRUE;

            ReadPci (&PciCfg1, (PUCHAR) &PciHdr, 0, sizeof(ULONG));

            //
            // If not a valid ID, skip to next device

            if (PciHdr.VendorID == PCI_INVALID_VENDORID) {
                if (!(Flags & DUMP_ALLOW_INVALID_DEVICE)) {
                    dprintf ("%02x\r", Device);
                    continue;
                }
            }


            for (Function=MinFunction; Function <= MaxFunction; Function++) {

                if (CheckControlC()) {
                    return;
                }

                PciCfg1.u.bits.FunctionNumber = Function;

                //
                // Read device ID
                //

                if (Function) {
                    ReadPci (&PciCfg1, (PUCHAR) &PciHdr, 0, sizeof(ULONG));
                }

                if (PciHdr.VendorID == PCI_INVALID_VENDORID) {
                    if (!(Flags & DUMP_ALLOW_INVALID_DEVICE)) {
                        continue;
                    }
                }

                //
                // Dump ID
                //

                if (!BusHeader) {
                    dprintf ("PCI Bus %d\n", Bus);
                    BusHeader = TRUE;
                }

                dprintf ("%02x:%x  %04x:%04x",
                        Device,
                        Function,
                        PciHdr.VendorID,
                        PciHdr.DeviceID
                        );

                //
                // Read the rest of the common header
                //

                ReadPci (
                    &PciCfg1,
                    ((PUCHAR) &PciHdr)  + sizeof(ULONG),
                    0                   + sizeof(ULONG),
                    PCI_COMMON_HDR_LENGTH
                    );

                Type = PciHdr.HeaderType & ~PCI_MULTIFUNCTION;

                if (Type == 0x7f && PciHdr.BaseClass == 0xff && PciHdr.SubClass == 0xff) {
                    if (!(Flags & DUMP_ALLOW_INVALID_FUNCTION)) {
                        dprintf ("  bogus, skipping rest of device\n");
                        break;
                    }
                }

                //
                // Dump it
                //

                s[0] = PciHdr.Command & PCI_ENABLE_IO_SPACE                 ? 'i' : '.';
                s[1] = PciHdr.Command & PCI_ENABLE_MEMORY_SPACE             ? 'm' : '.';
                s[2] = PciHdr.Command & PCI_ENABLE_BUS_MASTER               ? 'b' : '.';
                s[3] = PciHdr.Command & PCI_ENABLE_VGA_COMPATIBLE_PALETTE   ? 'v' : '.';
                s[4] = PciHdr.Command & PCI_ENABLE_PARITY                   ? 'p' : '.';
                s[5] = PciHdr.Command & PCI_ENABLE_SERR                     ? 's' : '.';
                s[6] = 0;
                dprintf (".%02x  Cmd[%04x:%s]  ", PciHdr.RevisionID, PciHdr.Command, s);

                s[0] = PciHdr.Status & PCI_STATUS_CAPABILITIES_LIST        ? 'c' : '.';
                s[1] = PciHdr.Status & PCI_STATUS_66MHZ_CAPABLE            ? '6' : '.';
                s[2] = PciHdr.Status & PCI_STATUS_DATA_PARITY_DETECTED     ? 'P' : '.';
                s[3] = PciHdr.Status & PCI_STATUS_SIGNALED_TARGET_ABORT    ? 'A' : '.';
                s[4] = PciHdr.Status & PCI_STATUS_SIGNALED_SYSTEM_ERROR    ? 'S' : '.';
                s[5] = 0;
                dprintf ("Sts[%04x:%s]  ", PciHdr.Status, s);


                switch (Type) {
                    case PCI_DEVICE_TYPE:
                        dprintf ("Device");

                        if (PciHdr.u.type0.SubVendorID || PciHdr.u.type0.SubSystemID) {
                            dprintf ("  SubID:%04x:%04x",
                                PciHdr.u.type0.SubVendorID,
                                PciHdr.u.type0.SubSystemID
                                );
                        }
                        break;

                    case PCI_BRIDGE_TYPE:
                        dprintf ("PciBridge %d->%d-%d",
                            PciHdr.u.type1.PrimaryBus,
                            PciHdr.u.type1.SecondaryBus,
                            PciHdr.u.type1.SubordinateBus
                            );
                        break;

                    case PCI_CARDBUS_BRIDGE_TYPE:
                        dprintf ("CardbusBridge  %d->%d-%d",
                            PciHdr.u.type2.PrimaryBus,
                            PciHdr.u.type2.SecondaryBus,
                            PciHdr.u.type2.SubordinateBus
                            );
                        break;

                    default:
                        dprintf ("type %x", Type);
                        break;
                }

                //
                // Search for a class code match
                //
                PCHAR Desc = GetClassDesc(PciHdr.BaseClass, PciHdr.SubClass, PciHdr.ProgIf);

                if (Desc) {
                    dprintf ("  %s", Desc);
                } else {
                    dprintf ("  Class:%x:%x:%x",
                        PciHdr.BaseClass,
                        PciHdr.SubClass,
                        PciHdr.ProgIf
                        );
                }

                dprintf ("\n");
                SkipLine = FALSE;

                if (Flags & DUMP_VERBOSE) {
                    SkipLine = TRUE;
                    PciCfg1.u.bits.RegisterNumber = 0;
                    switch (Type) {
                        case PCI_DEVICE_TYPE:
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  Rom:%x  cis:%x  cap:%x\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type0.InterruptPin,
                                PciHdr.u.type0.InterruptLine,
                                PciHdr.u.type0.ROMBaseAddress,
                                PciHdr.u.type0.CIS,
                                PciHdr.u.type0.CapabilitiesPtr
                            );

                            state = 0;
                            for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
                                bar = PciHdr.u.type0.BaseAddresses[i];
                                DumpPciBar(i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;

                        case PCI_BRIDGE_TYPE:
                            i = PciHdr.u.type1.BridgeControl;
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  Rom:%x  cap:%x  2sts:%x  BCtrl:%x%s%s%s\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type1.InterruptPin,
                                PciHdr.u.type1.InterruptLine,
                                PciHdr.u.type1.ROMBaseAddress,
                                PciHdr.u.type1.CapabilitiesPtr,
                                PciHdr.u.type1.SecondaryStatus,
                                PciHdr.u.type1.BridgeControl,
                                i & PCI_ENABLE_BRIDGE_VGA   ? " VGA" : "",
                                i & PCI_ENABLE_BRIDGE_ISA   ? " ISA" : "",
                                i & PCI_ASSERT_BRIDGE_RESET ? " RESET" : ""
                                );

                            dprintf ("      IO:%x-%x  Mem:%x-%x  PMem:%x-%x\n",
                                PciBridgeIO2Base (PciHdr.u.type1.IOBase,  PciHdr.u.type1.IOBaseUpper16),
                                PciBridgeIO2Limit(PciHdr.u.type1.IOLimit, PciHdr.u.type1.IOLimitUpper16),
                                PciBridgeMemory2Base (PciHdr.u.type1.MemoryBase),
                                PciBridgeMemory2Limit(PciHdr.u.type1.MemoryLimit),
                                PciBridgeMemory2Base (PciHdr.u.type1.PrefetchBase),
                                PciBridgeMemory2Limit(PciHdr.u.type1.PrefetchLimit)
                                );

                            state = 0;
                            for (i=0; i < PCI_TYPE1_ADDRESSES; i++) {
                                bar = PciHdr.u.type1.BaseAddresses[i];
                                DumpPciBar(i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;

                        case PCI_CARDBUS_BRIDGE_TYPE:
                            i = PciHdr.u.type2.BridgeControl;
                            dprintf ("      cf8:%x  IntPin:%x  IntLine:%x  SocketRegBase:%x  cap:%x  2sts:%x  BCtrl:%x%s%s%s\n",
                                PciCfg1.u.AsULONG,
                                PciHdr.u.type2.InterruptPin,
                                PciHdr.u.type2.InterruptLine,
                                PciHdr.u.type2.SocketRegistersBaseAddress,
                                PciHdr.u.type2.CapabilitiesPtr,
                                PciHdr.u.type2.SecondaryStatus,
                                PciHdr.u.type2.BridgeControl,
                                i & PCI_ENABLE_BRIDGE_VGA   ? " VGA" : "",
                                i & PCI_ENABLE_BRIDGE_ISA   ? " ISA" : "",
                                i & PCI_ASSERT_BRIDGE_RESET ? " RESET" : ""
                                );
                            dprintf("\n");
                            state=0;
                            for (i = 0; i < (PCI_TYPE2_ADDRESSES - 1); i++) {
                                bar = PciHdr.u.type2.Range[i].Base;
                                //
                                // First 2 BARs (base+limit) are memory
                                //
                                BarIsIo =  (i > 1);
                                barno =  i;
                                if (BarIsIo) {
                                      barno -= 2;
                                }
                                DumpPciType2Bar(BarIsIo,TRUE, barno, 6, bar, &state);

                                bar = PciHdr.u.type2.Range[i].Limit;
                                DumpPciType2Bar(BarIsIo, FALSE, i, 6, bar, &state);
                            }
                            DumpPciBarComplete(&state);
                            break;
                    }
                }

                //
                // Dump CAPABILITIES if any.
                //

                if (Flags & DUMP_CAPABILITIES) {
                    if (PciHdr.Status & PCI_STATUS_CAPABILITIES_LIST) {
                        UCHAR capPtr = 0;

                        SkipLine = TRUE;

                        switch (Type) {
                            case PCI_DEVICE_TYPE:
                                capPtr = PciHdr.u.type0.CapabilitiesPtr;
                                break;
        
                            case PCI_BRIDGE_TYPE:
                                capPtr = PciHdr.u.type1.CapabilitiesPtr;
                                break;
        
                            case PCI_CARDBUS_BRIDGE_TYPE:
                                capPtr = PciHdr.u.type2.CapabilitiesPtr;
                                break;
                        }

                        if (capPtr != 0) {
                            DumpCapabilities(capPtr, &PciCfg1);
                        } else {

                            //
                            // Capabilities flag is set in Status but
                            // pointer is 0???  Something's broken.
                            //

                            dprintf("       Warning: Capability bit set in Status but capability pointer is 0.\n");
                        }
                    }
                }

                //
                // Dump hex bytes
                //

                if (Flags & DUMP_RAW_BYTES) {

                    ULONG w;

                    //
                    // Raw dump requested, if no range default to common
                    // config.
                    //

                    if (!MinAddr && !MaxAddr) {
                        MaxAddr = PCI_COMMON_HDR_LENGTH - 1;
                    }

                    //
                    // Default width to 1.  If dumping dwords, set width
                    // width to 4 and round min and max accordingly.
                    //

                    w = 1;
                    if (Flags & DUMP_RAW_DWORDS) {
                        w = 4;
                        MinAddr &= ~3;
                        MaxAddr &= ~3;
                        MaxAddr += 3;
                    }
                    Buf = ((PUCHAR) &PciHdr) + MinAddr;
                    Len = MaxAddr - MinAddr + 1;

                    if (MinAddr <= PCI_COMMON_HDR_LENGTH) {
                        if (MaxAddr > PCI_COMMON_HDR_LENGTH) {
                            ReadPci (
                                &PciCfg1,
                                PciHdr.DeviceSpecific,
                                PCI_COMMON_HDR_LENGTH,
                                MaxAddr - PCI_COMMON_HDR_LENGTH
                                );
                        }

                    } else {
                        ReadPci (&PciCfg1, Buf, MinAddr, Len);
                    }

                    HexDump (w == 4 ? 6 : 1, MinAddr, Len, w, Buf);
                    SkipLine = TRUE;

                } else if ((Flags & DUMP_INTEL) && PciHdr.VendorID == 0x8086) {

                    Buf = PciHdr.DeviceSpecific;
                    Len = sizeof (PciHdr) - PCI_COMMON_HDR_LENGTH;

                    ReadPci (&PciCfg1, Buf, PCI_COMMON_HDR_LENGTH, Len);
                    HexDump (1, PCI_COMMON_HDR_LENGTH,  Len, 1, Buf);
                    SkipLine = TRUE;
                }

                if (Flags & DUMP_CONFIGSPACE) {
                    PCI_COMMON_CONFIG  cs;
                    
                    ReadPci(&PciCfg1, (PUCHAR)&cs, 0, sizeof(cs));
                    dprintf ("Config Space:\n", 
                             PciCfg1.u.bits.BusNumber,
                             PciCfg1.u.bits.DeviceNumber,
                             PciCfg1.u.bits.FunctionNumber);
                    DumpCfgSpace(&cs);
                    dprintf ("\n");
                }

                if (SkipLine) {
                    dprintf ("\n");
                }

                //
                // If no more functions on this device, skip the rest
                // of the functions
                //

                if (Function == 0 && !(PciHdr.HeaderType & PCI_MULTIFUNCTION)) {
                    if (!(Flags & DUMP_ALLOW_INVALID_FUNCTION)) {
                        break;
                    }
                }

            }
        }
    }
}


DECLARE_API( pci )

/*++

Routine Description:

    Dumps pci type2 config data

Arguments:

    args - Supplies the address in hex.

Return Value:

    None

--*/
{
    LONG        noargs;
    ULONG       Flags;
    ULONG       MinBus, MaxBus;
    ULONG       Device, MinDevice, MaxDevice;
    ULONG       Function, MinFunction, MaxFunction;
    ULONG       MinAddr, MaxAddr;

    MinBus = 0;
    MaxBus = 0;
    MinDevice = 0;
    MaxDevice = PCI_MAX_DEVICES - 1;
    MinFunction = 0;
    MaxFunction = PCI_MAX_FUNCTION - 1;
    MinAddr = 0;
    MaxAddr = 0;
    Flags = 0;
    
   if (g_TargetQual == DEBUG_DUMP_SMALL || 
       g_TargetQual == DEBUG_DUMP_DEFAULT || 
       g_TargetQual == DEBUG_DUMP_FULL) {
        dprintf("!pci does not work for dump targets\n");
        return E_INVALIDARG;
    }
    
    {
    INIT_API();


    noargs = sscanf(args,"%lX %lX %lX %lX %lX %lX",
                    &Flags,         // 1
                    &MaxBus,        // 2
                    &Device,        // 3
                    &Function,      // 4
                    &MinAddr,       // 5
                    &MaxAddr        // 6
                    );

    MinBus = MaxBus;
    if (Flags & DUMP_TO_MAX_BUS) {
        MinBus = 0;
    }

    if (noargs >= 3) {
        Flags |= DUMP_ALLOW_INVALID_DEVICE;
        MinDevice = Device;
        MaxDevice = Device;
    }

    if (noargs >= 4) {
        MinFunction = Function;
        MaxFunction = Function;
    }

    if (MinAddr || MaxAddr) {
        Flags |= DUMP_RAW_BYTES;
    }

    if (Flags & DUMP_RAW_DWORDS) {
        Flags |= DUMP_RAW_BYTES;
    }

    pcidump (
        Flags,
        MinBus,        MaxBus,
        MinDevice,     MaxDevice,
        MinFunction,   MaxFunction,
        MinAddr,       MaxAddr
        );

    EXIT_API();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\pci.h ===
/*++

Module Name:

    pci.h

Abstract:

    This is the PCI bus specific header file used by device drivers.

Author:

Revision History:

--*/

#ifndef _PCI_
#define _PCI_

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_wdm begin_ntminiport begin_ntndis

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG Reserved:2;              // always zero, DWORD aligned address
               ULONG Address:30;
            } Register;
            ULONG Raw;
      } MessageAddress; // was ULONG_PTR

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_wdm end_ntminiport

// end_ntddk end_ntosp

//
// PCI_REGISTRY_INFO - this structure is passed into the HAL from
// the firmware.  It signifies how many PCI bus(es) are present and
// what style of access the PCI bus(es) support.
//

typedef struct _PCI_REGISTRY_INFO {
    UCHAR       MajorRevision;
    UCHAR       MinorRevision;
    UCHAR       NoBuses;
    UCHAR       HardwareMechanism;
} PCI_REGISTRY_INFO, *PPCI_REGISTRY_INFO;

//
// PCI definitions for IOBase & IOLimit
// PCIBridgeIO2Base(a,b)  - convert IOBase  & IOBaseUpper16 to ULONG IOBase
// PCIBridgeIO2Limit(a,b) - convert IOLimit & IOLimitUpper6 to ULONG IOLimit
//

#define PciBridgeIO2Base(a,b)   \
        ( ((a >> 4) << 12) + (((a & 0xf) == 1) ? (b << 16) : 0) )

#define PciBridgeIO2Limit(a,b)  (PciBridgeIO2Base(a,b) | 0xfff)

#define PciBridgeMemory2Base(a)  (ULONG) ((a & 0xfff0) << 16)
#define PciBridgeMemory2Limit(a) (PciBridgeMemory2Base(a) | 0xfffff)

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1/2.BridgeControl
//

#define PCI_ENABLE_BRIDGE_PARITY_ERROR        0x0001
#define PCI_ENABLE_BRIDGE_SERR                0x0002
#define PCI_ENABLE_BRIDGE_ISA                 0x0004
#define PCI_ENABLE_BRIDGE_VGA                 0x0008
#define PCI_ENABLE_BRIDGE_MASTER_ABORT_SERR   0x0020
#define PCI_ASSERT_BRIDGE_RESET               0x0040

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1.BridgeControl
//

#define PCI_ENABLE_BRIDGE_FAST_BACK_TO_BACK   0x0080

//
// Bit encodes for PCI_COMMON_CONFIG.u.type2.BridgeControl
//

#define PCI_ENABLE_CARDBUS_IRQ_ROUTING        0x0080
#define PCI_ENABLE_CARDBUS_MEM0_PREFETCH      0x0100
#define PCI_ENABLE_CARDBUS_MEM1_PREFETCH      0x0200
#define PCI_ENABLE_CARDBUS_WRITE_POSTING      0x0400

//
//  Definitions needed for Access to Hardware Type 1
//

#define PCI_TYPE1_ADDR_PORT     (0xCF8)
#define PCI_TYPE1_DATA_PORT     0xCFC

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


//
//  Definitions needed for Access to Hardware Type 2
//

#define PCI_TYPE2_CSE_PORT              ((PUCHAR) 0xCF8)
#define PCI_TYPE2_FORWARD_PORT          ((PUCHAR) 0xCFA)
#define PCI_TYPE2_ADDRESS_BASE          0xC


typedef struct _PCI_TYPE2_CSE_BITS {
    union {
        struct {
            UCHAR   Enable:1;
            UCHAR   FunctionNumber:3;
            UCHAR   Key:4;
        } bits;
        UCHAR   AsUCHAR;
    } u;
} PCI_TYPE2_CSE_BITS, PPCI_TYPE2_CSE_BITS;


typedef struct _PCI_TYPE2_ADDRESS_BITS {
    union {
        struct {
            USHORT  RegisterNumber:8;
            USHORT  Agent:4;
            USHORT  AddressBase:4;
        } bits;
        USHORT  AsUSHORT;
    } u;
} PCI_TYPE2_ADDRESS_BITS, *PPCI_TYPE2_ADDRESS_BITS;


//
// Definitions for the config cycle format on the PCI bus.
//

typedef struct _PCI_TYPE0_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   Reserved2:21;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE0_CFG_CYCLE_BITS, *PPCI_TYPE0_CFG_CYCLE_BITS;

typedef struct _PCI_TYPE1_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:8;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_CYCLE_BITS, *PPCI_TYPE1_CFG_CYCLE_BITS;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>
#include "bugcheck.h"
//#include "kextfn.h"
#include "extsfns.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#ifndef EXTENSION_API
#define EXTENSION_API( name )  \
HRESULT _EFN_##name
#endif // EXTENSION_API

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES    g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS2       g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern ULONG64  STeip;
extern ULONG64  STebp;
extern ULONG64  STesp;
extern ULONG64  EXPRLastDump;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;
extern ULONG g_TargetQual;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\pcskthw.h ===
/*** pcskthw.h - PC Card Socket Hardware Definitions
 *
 *  Copyright (c) 1995,1996 Microsoft Corporation
 *  Author:     Michael Tsang (MikeTs)
 *  Created     08/28/95
 *
 *  MODIFICATION HISTORY
 */


#ifndef _PCSKTHW_H
#define _PCSKTHW_H


//#ifdef CARDBUS

/*** CardBus Constants
 */

//PCI IDs
#define PCIID_TI_PCI1130                0xac12104c
#define PCIID_TI_PCI1131		0xac15104c
#define PCIID_TI_PCI1031		0xac13104c
#define PCIID_OPTI_82C824		0xc8241045
#define PCIID_OPTI_82C814		0xc8141045	//Docking chip
//#define PCIID_TO_TOPIC95                0x06031179	//Seattle2
#define PCIID_TO_TOPIC95		0x060a1179	//SeattleX
#define PCIID_CL_PD6832			0x11101013
#define PCIID_DBK_DB87144		0x310610b3
#define PCIID_RICOH_RL5C466		0x04661180

//ConfigSpace Registers
#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_STATUS                 0x06
#define CFGSPACE_REV_ID                 0x08
#define CFGSPACE_CLASS_CODE             0x09
#define CFGSPACE_CLASSCODE_PI           0x09
#define CFGSPACE_CLASSCODE_SUBCLASS     0x0a
#define CFGSPACE_CLASSCODE_BASECLASS    0x0b
#define CFGSPACE_CACHE_LINESIZE         0x0c
#define CFGSPACE_LATENCY_TIMER          0x0d
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_BIST                   0x0f
#define CFGSPACE_REGBASE_ADDR           0x10
#define CFGSPACE_SECOND_STATUS          0x16
#define CFGSPACE_PCI_BUSNUM             0x18
#define CFGSPACE_CARDBUS_BUSNUM         0x19
#define CFGSPACE_SUB_BUSNUM             0x1a
#define CFGSPACE_CB_LATENCY_TIMER       0x1b
#define CFGSPACE_MEMBASE_0              0x1c
#define CFGSPACE_MEMLIMIT_0             0x20
#define CFGSPACE_MEMBASE_1              0x24
#define CFGSPACE_MEMLIMIT_1             0x28
#define CFGSPACE_IOBASE_0               0x2c
#define CFGSPACE_IOLIMIT_0              0x30
#define CFGSPACE_IOBASE_1               0x34
#define CFGSPACE_IOLIMIT_1              0x38
#define CFGSPACE_INT_LINE               0x3c
#define CFGSPACE_INT_PIN                0x3d
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_SUBSYS_VENDOR_ID       0x40
#define CFGSPACE_SUBSYS_ID              0x42
#define CFGSPACE_LEGACY_MODE_BASE_ADDR	0x44

//Command Register bits
#define CMD_IOSPACE_ENABLE		0x0001
#define CMD_MEMSPACE_ENABLE		0x0002
#define CMD_BUSMASTER_ENABLE		0x0004
#define CMD_SPECIALCYCLE_ENABLE		0x0008
#define CMD_MEMWR_INVALIDATE_ENABLE	0x0010
#define CMD_VGA_PALETTE_SNOOP		0x0020
#define CMD_PARITY_ERROR_ENABLE		0x0040
#define CMD_WAIT_CYCLE_CTRL		0x0080
#define CMD_SYSTEM_ERROR_ENABLE		0x0100
#define CMD_FAST_BACKTOBACK_ENABLE	0x0200

//Bridge Control Register bits
#define BCTRL_PERR_RESPONSE_ENABLE	0x0001
#define BCTRL_SERR_ENABLE		0x0002
#define BCTRL_ISA_ENABLE		0x0004
#define BCTRL_VGA_ENABLE		0x0008
#define BCTRL_MASTER_ABORT_MODE		0x0020
#define BCTRL_CRST			0x0040
#define BCTRL_IRQROUTING_ENABLE		0x0080
#define BCTRL_MEMWIN0_PREFETCH_ENABLE	0x0100
#define BCTRL_MEMWIN1_PREFETCH_ENABLE	0x0200
#define BCTRL_WRITE_POSTING_ENABLE	0x0400
#define BCTRL_CL_CSCIRQROUTING_ENABLE	0x0800

//ConfigSpace Registers (TI PCI1130)
#define CFGSPACE_TI_SYSTEM_CTRL		0x80
#define CFGSPACE_TI_RETRY_STATUS        0x90
#define CFGSPACE_TI_CARD_CTRL           0x91
#define CFGSPACE_TI_DEV_CTRL            0x92
#define CFGSPACE_TI_BUFF_CTRL           0x93

//ConfigSpace Registers (TOPIC95)
#define CFGSPACE_TO_PC16_SKTCTRL	0x90
#define CFGSPACE_TO_SLOT_CTRL		0xa0
#define CFGSPACE_TO_CARD_CTRL		0xa1
#define CFGSPACE_TO_CD_CTRL		0xa3
#define CFGSPACE_TO_CBREG_CTRL		0xa4

//ConfigSpace Registers (OPTi 82C824)
#define CFGSPACE_OPTI_HF_CTRL           0x50
#define HFC_ZV_SUPPORT                  0x80

//ConfigSpace Registers (RICOH RL5C466)
#define CFGSPACE_RICOH_MISC_CTRL        0x82
#define CFGSPACE_RICOH_IF16_CTRL        0x84
#define CFGSPACE_RICOH_IO16_TIMING0     0x88
#define CFGSPACE_RICOH_MEM16_TIMING0    0x8a
#define CFGSPACE_RICOH_DMA_SLAVE_CFG    0x90

//RICOH 16-bit Interface Control Register bits
#define IF16_INDEX_RANGE_SELECT         0x0008
#define IF16_LEGACY_LEVEL_1             0x0010
#define IF16_LEGACY_LEVEL_2             0x0020
#define IF16_IO16_ENHANCE_TIMING        0x0100
#define IF16_MEM16_ENHANCE_TIMING       0x0200

//PC Card-16 Socket Control Register bits (TOPIC95)
#define S16CTRL_CSC_ISAIRQ		0x00000001

//Card Control Register bits (TOPIC95)
#define CARDCTRL_INTPIN_ASSIGNMASK	0x30
#define CARDCTRL_INTPIN_NONE		0x00
#define CARDCTRL_INTPIN_INTA		0x01
#define CARDCTRL_INTPIN_INTB		0x02

//Card Detect Control Register bits (TOPIC95)
#define CDCTRL_SW_DETECT		0x01
#define CDCTRL_VS_MASK			0x06
#define CDCTRL_PCCARD_16_32		0x80

//System Control Register bits (TI PCI1130)
#define SYSCTRL_PCICLKRUN_ENABLE	0x00000001
#define SYSCTRL_KEEPCLK_ENABLE		0x00000002
#define SYSCTRL_ASYNC_INTMODE		0x00000004
#define SYSCTRL_PCPCI_DMA_ENABLE	0x00000008
#define SYSCTRL_CBDATAPARITY_SERR	0x00000010
#define SYSCTRL_EXCAIDREV_READONLY	0x00000020
#define SYSCTRL_INTERROGATING		0x00000100
#define SYSCTRL_POWERING_UP		0x00000200
#define SYSCTRL_POWERING_DOWN		0x00000400
#define SYSCTRL_POWER_STREAMING		0x00000800
#define SYSCTRL_SOCKET_ACTIVITY		0x00001000
#define SYSCTRL_PCPCI_DMA_CHAN_MASK	0x00070000
#define SYSCTRL_PCPCI_DMA_CARD_ENABLE	0x00080000
#define SYSCTRL_REDUCED_ZV_ENABLE	0x00100000
#define SYSCTRL_VCC_PROTECT_OVERRIDE	0x00200000
#define SYSCTRL_SMI_INT_ENABLE		0x01000000
#define SYSCTRL_SMI_INT_ROUTING_SELECT	0x02000000

//Retry Status Register bits (TI PCI1130)
#define RETRY_PCIM_RETRY_EXPIRED	0x01
#define RETRY_PCI_RETRY_EXPIRED		0x02
#define RETRY_CBMA_RETRY_EXPIRED	0x04
#define RETRY_CBA_RETRY_EXPIRED		0x08
#define RETRY_CBMB_RETRY_EXPIRED	0x10
#define RETRY_CBB_RETRY_EXPIRED		0x20
#define RETRY_CBRETRY_TIMEOUT_ENABLE	0x40
#define RETRY_PCIRETRY_TIMEOUT_ENABLE	0x80

//Card Control Register bits (TI PCI1130)
#define CARDCTRL_PCCARD_INTFLAG         0x01
#define CARDCTRL_SPKR_ENABLE            0x02
#define CARDCTRL_CSCINT_ENABLE          0x08
#define CARDCTRL_FUNCINT_ENABLE         0x10
#define CARDCTRL_PCIINT_ENABLE          0x20
#define CARDCTRL_ZV_ENABLE		0x40
#define CARDCTRL_RIOUT_ENABLE           0x80

//Device Control Register bits (TI PCI1130)
#define DEVCTRL_INTMODE_MASK            0x06
#define DEVCTRL_INTMODE_DISABLED        0x00
#define DEVCTRL_INTMODE_ISA             0x02
#define DEVCTRL_INTMODE_COMPAQ          0x04
#define DEVCTRL_INTMODE_SERIAL		0x06
#define DEVCTRL_ALWAYS_ONE              0x10
#define DEVCTRL_3V_ENABLE               0x20
#define DEVCTRL_5V_ENABLE               0x40

//CardBus Registers
#define CBREG_SKTEVENT                  0x00
#define CBREG_SKTMASK                   0x04
#define CBREG_SKTSTATE                  0x08
#define CBREG_SKTFORCE                  0x0c
#define CBREG_SKTPOWER                  0x10

//Socket Event Register bits
#define SKTEVENT_CSTSCHG                0x00000001L
#define SKTEVENT_CCD1                   0x00000002L
#define SKTEVENT_CCD2                   0x00000004L
#define SKTEVENT_CCD_MASK		(SKTEVENT_CCD1 | SKTEVENT_CCD2)
#define SKTEVENT_POWERCYCLE             0x00000008L
#define SKTEVENT_MASK                   0x0000000fL

//Socket Mask Register bits
#define SKTMSK_CSTSCHG                  0x00000001L
#define SKTMSK_CCD                      0x00000006L
#define SKTMSK_CCD1                     0x00000002L
#define SKTMSK_CCD2                     0x00000004L
#define SKTMSK_POWERCYCLE               0x00000008L

//Socket Present State Register bits
#define SKTSTATE_CSTSCHG                0x00000001L
#define SKTSTATE_CCD1                   0x00000002L
#define SKTSTATE_CCD2                   0x00000004L
#define SKTSTATE_CCD_MASK               (SKTSTATE_CCD1 | SKTSTATE_CCD2)
#define SKTSTATE_POWERCYCLE             0x00000008L
#define SKTSTATE_CARDTYPE_MASK		0x00000030L
#define SKTSTATE_R2CARD                 0x00000010L
#define SKTSTATE_CBCARD                 0x00000020L
#define SKTSTATE_OPTI_DOCK		0x00000030L
#define CARDTYPE(dw)			((dw) & SKTSTATE_CARDTYPE_MASK)
#define SKTSTATE_CARDINT                0x00000040L
#define SKTSTATE_NOTACARD               0x00000080L
#define SKTSTATE_DATALOST               0x00000100L
#define SKTSTATE_BADVCCREQ              0x00000200L
#define SKTSTATE_5VCARD                 0x00000400L
#define SKTSTATE_3VCARD                 0x00000800L
#define SKTSTATE_XVCARD                 0x00001000L
#define SKTSTATE_YVCARD                 0x00002000L
#define SKTSTATE_CARDVCC_MASK		(SKTSTATE_5VCARD | SKTSTATE_3VCARD | \
					 SKTSTATE_XVCARD | SKTSTATE_YVCARD)
#define SKTSTATE_5VSOCKET               0x10000000L
#define SKTSTATE_3VSOCKET               0x20000000L
#define SKTSTATE_XVSOCKET               0x40000000L
#define SKTSTATE_YVSOCKET               0x80000000L
#define SKTSTATE_SKTVCC_MASK		(SKTSTATE_5VSOCKET | \
					 SKTSTATE_3VSOCKET | \
					 SKTSTATE_XVSOCKET | \
					 SKTSTATE_YVSOCKET)

//Socket Froce Register bits
#define SKTFORCE_CSTSCHG                0x00000001L
#define SKTFORCE_CCD1                   0x00000002L
#define SKTFORCE_CCD2                   0x00000004L
#define SKTFORCE_POWERCYCLE             0x00000008L
#define SKTFORCE_R2CARD                 0x00000010L
#define SKTFORCE_CBCARD                 0x00000020L
#define SKTFORCE_NOTACARD               0x00000080L
#define SKTFORCE_DATALOST               0x00000100L
#define SKTFORCE_BADVCCREQ              0x00000200L
#define SKTFORCE_5VCARD                 0x00000400L
#define SKTFORCE_3VCARD                 0x00000800L
#define SKTFORCE_XVCARD                 0x00001000L
#define SKTFORCE_YVCARD                 0x00002000L
#define SKTFORCE_CVSTEST                0x00004000L
#define SKTFORCE_5VSOCKET		0x10000000L
#define SKTFORCE_3VSOCKET		0x20000000L
#define SKTFORCE_XVSOCKET		0x40000000L
#define SKTFORCE_YVSOCKET		0x80000000L

//Power Control Register bits
#define SKTPOWER_VPP_CONTROL            0x00000007L
#define SKTPOWER_VPP_OFF                0x00000000L
#define SKTPOWER_VPP_120V               0x00000001L
#define SKTPOWER_VPP_050V               0x00000002L
#define SKTPOWER_VPP_033V               0x00000003L
#define SKTPOWER_VPP_0XXV               0x00000004L
#define SKTPOWER_VPP_0YYV               0x00000005L
#define SKTPOWER_VCC_CONTROL            0x00000070L
#define SKTPOWER_VCC_OFF                0x00000000L
#define SKTPOWER_VCC_050V               0x00000020L
#define SKTPOWER_VCC_033V               0x00000030L
#define SKTPOWER_VCC_0XXV               0x00000040L
#define SKTPOWER_VCC_0YYV               0x00000050L
#define SKTPOWER_STOPCLOCK              0x00000080L

//Misc. CardBus Constants
#define NUMWIN_BRIDGE                   4       //2 Mem + 2 IO
#define EXCAREG_OFFSET                  0x0800


/*** CardBus Type and Structure Definitions
 */

typedef struct cfgspace_s {
    WORD  wVendorID;
    WORD  wDeviceID;
    WORD  wCommand;
    WORD  wStatus;
    BYTE  bRevID;
    BYTE  bClassCodePI;
    BYTE  bClassCodeSubClass;
    BYTE  bClassCodeBaseClass;
    BYTE  bCacheLineSize;
    BYTE  bLatencyTimer;
    BYTE  bHeaderType;
    BYTE  bBIST;
    DWORD dwRegBaseAddr;
    BYTE  bPCIBusNum;
    BYTE  bCBBusNum;
    BYTE  bSubBusNum;
    BYTE  bCBLatencyTimer;
    DWORD dwMemBase0;
    DWORD dwMemLimit0;
    DWORD dwMemBase1;
    DWORD dwMemLimit1;
    DWORD dwIOBase0;
    DWORD dwIOLimit0;
    DWORD dwIOBase1;
    DWORD dwIOLimit1;
    BYTE  bIntLine;
    BYTE  bIntPin;
    BYTE  bBridgeCtrl;
    WORD  wSubSysVendorID;
    WORD  wSubSysID;
} CFGSPACE;
typedef CFGSPACE *PCFGSPACE;

typedef struct cbregs_s {
    DWORD dwSktEvent;
    DWORD dwSktMask;
    DWORD dwSktState;
    DWORD dwSktForce;
    DWORD dwSktPower;
} CBREGS;
typedef CBREGS *PCBREGS;

//#endif  //ifdef CARDBUS


/*** 16-Bit Socket Constants
 */

//Device IDs for various controllers
#define DEVID_VALID_LO			0x82
#define DEVID_CL			0x82
#define DEVID_VADEM			0x83
#define DEVID_RICOH			0x83
#define DEVID_GEN_PCIC			0x84
#define DEVID_IBM_KING			0x8a
#define DEVID_OPTI_82C824		0x87
#define DEVID_OPTI_82C852		0x8f

//ExCA Registers
#define EXCAREG_IDREV                   0x00
#define EXCAREG_VLSI_EA0		0x00
#define EXCAREG_INTERFACE_STATUS        0x01
#define EXCAREG_VLSI_EA1		0x01
#define EXCAREG_POWER_CTRL              0x02
#define EXCAREG_VLSI_EA2		0x02
#define EXCAREG_INT_GENCTRL             0x03
#define EXCAREG_VLSI_EXT_CHIPCTRL	0x03
#define EXCAREG_CARD_STATUS             0x04
#define EXCAREG_CSC_CFG                 0x05
#define EXCAREG_WIN_ENABLE              0x06
#define EXCAREG_IO_CTRL                 0x07
#define EXCAREG_IOWIN0_START            0x08
#define EXCAREG_IOWIN0_END              0x0a
#define EXCAREG_IOWIN1_START            0x0c
#define EXCAREG_IOWIN1_END              0x0e
#define EXCAREG_MEMWIN0_START           0x10
#define EXCAREG_MEMWIN0_END             0x12
#define EXCAREG_MEMWIN0_OFFSET          0x14
#define EXCAREG_CARDDET_GENCTRL		0x16
#define EXCAREG_CL_MISC_CTRL1		0x16
#define EXCAREG_TO_ADDITIONAL_GENCTRL	0x16
#define EXCAREG_CL_FIFO_CTRL		0x17
#define EXCAREG_KING_CVS		0x17
#define EXCAREG_MEMWIN1_START           0x18
#define EXCAREG_MEMWIN1_END             0x1a
#define EXCAREG_MEMWIN1_OFFSET          0x1c
#define EXCAREG_GLOBAL_CTRL		0x1e
#define EXCAREG_CL_MISC_CTRL2		0x1e
#define EXCAREG_CL_CHIP_INFO		0x1f
#define EXCAREG_VADEM_VSENSE		0x1f
#define EXCAREG_MEMWIN2_START           0x20
#define EXCAREG_MEMWIN2_END             0x22
#define EXCAREG_MEMWIN2_OFFSET          0x24
#define EXCAREG_CL_ATA_CTRL		0x26
#define EXCAREG_MEMWIN3_START           0x28
#define EXCAREG_MEMWIN3_END             0x2a
#define EXCAREG_MEMWIN3_OFFSET          0x2c
#define EXCAREG_CL_EXT_INDEX		0x2e
#define EXCAREG_CL_EXT_DATA		0x2f
#define EXCAREG_VADEM_VSEL		0x2f
#define EXCAREG_RICOH_MISC_CTRL1        0x2f
#define EXCAREG_MEMWIN4_START           0x30
#define EXCAREG_MEMWIN4_END             0x32
#define EXCAREG_MEMWIN4_OFFSET          0x34
#define EXCAREG_CL_IOWIN0_OFFSET	0x36
#define EXCAREG_CL_IOWIN1_OFFSET	0x38
#define EXCAREG_CL_SETUP_TIMING0	0x3a
#define EXCAREG_VADEM_MISC		0x3a
#define EXCAREG_CL_COMMAND_TIMING0	0x3b
#define EXCAREG_DBK_ZV_ENABLE		0x3b
#define EXCAREG_TO_MMI_CTRL		0x3c
#define EXCAREG_CL_RECOVERY_TIMING0	0x3c
#define EXCAREG_CL_SETUP_TIMING1	0x3d
#define EXCAREG_CL_COMMAND_TIMING1	0x3e
#define EXCAREG_TO_FUNC_CTRL		0x3e
#define EXCAREG_CL_RECOVERY_TIMING1	0x3f
#define EXCAREG_MEMWIN0_HI              0x40
#define EXCAREG_MEMWIN1_HI              0x41
#define EXCAREG_MEMWIN2_HI              0x42
#define EXCAREG_MEMWIN3_HI              0x43
#define EXCAREG_MEMWIN4_HI              0x44
#define EXCAREG_CL_IOWIN0_HI            0x45
#define EXCAREG_CL_IOWIN1_HI            0x46
#define EXCAREG_CL_EXT_CTRL1            0x103
#define EXCAREG_CL_EXTERNAL_DATA        0x10a
#define EXCAREG_CL_EXT_CTRL2            0x10b
#define EXCAREG_CL_MISC_CTRL3           0x125
#define EXCAREG_CL_MASK_REV		0x134
#define EXCAREG_CL_PRODUCT_ID		0x135
#define EXCAREG_CL_DEV_CAP_A		0x136
#define EXCAREG_CL_DEV_CAP_B		0x137
#define EXCAREG_CL_DEV_IMP_A		0x138
#define EXCAREG_CL_DEV_IMP_B		0x139
#define EXCAREG_CL_DEV_IMP_C		0x13a
#define EXCAREG_CL_DEV_IMP_D		0x13b

//TI PCI-1130 specific registers
#define EXCAREG_TI_MEMWIN_PAGE		0x40

//ID and Revision Register bits
#define IDREV_REV_MASK                  0x0f
#define IDREV_IFID_MASK                 0xc0
#define IDREV_IFID_IO                   0x00
#define IDREV_IFID_MEM                  0x40
#define IDREV_IFID_IOMEM                0x80

//Interface Status Register bits
#define IFS_BVD_MASK                    0x03
#define IFS_BVD1                        0x01
#define IFS_BVD2                        0x02
#define IFS_CD_MASK                     0x0c
#define IFS_CD1                         0x04
#define IFS_CD2                         0x08
#define IFS_WP                          0x10
#define IFS_RDYBSY                      0x20
#define IFS_CARDPWR_ACTIVE              0x40
#define IFS_VPP_VALID                   0x80

//Power and RESETDRV Control Register bits
#define PC_VPP1_MASK                    0x03
#define PC_VPP2_MASK                    0x0c
#define PC_CARDPWR_ENABLE               0x10
#define PC_AUTOPWR_ENABLE               0x20
#define PC_RESETDRV_DISABLE             0x40
#define PC_OUTPUT_ENABLE                0x80

#define PC_VPP_NO_CONNECT		0x00
#define PC_VPP_SETTO_VCC		0x01
#define PC_VPP_SETTO_VPP		0x02
#define PC_VPP_RESERVED			0x03

#define PC_VPP_VLSI_MASK		0x03
#define PC_VPP_VLSI_NO_CONNECT		0x00
#define PC_VPP_VLSI_050V		0x01
#define PC_VPP_VLSI_120V		0x02
#define PC_VPP_VLSI_RESERVED		0x03

#define PC_VCC_TOPIC_033V		0x08

#define PC_VCC_VLSI_MASK		0x18
#define PC_VCC_VLSI_NO_CONNECT		0x00
#define PC_VCC_VLSI_RESERVED		0x08
#define PC_VCC_VLSI_050V		0x10
#define PC_VCC_VLSI_033V		0x18

#define PC_VPP_KING_MASK		0x03
#define PC_VPP_KING_NO_CONNECT		0x00
#define PC_VPP_KING_050V		0x01
#define PC_VPP_KING_120V		0x02
#define PC_VPP_KING_SETTO_VCC		0x03

#define PC_VCC_KING_MASK		0x0c
#define PC_VCC_KING_NO_CONNECT		0x00
#define PC_VCC_KING_050V		0x04
#define PC_VCC_KING_RESERVED		0x08
#define PC_VCC_KING_033V		0x0c

#define PC_VPP_OPTI_MASK		0x03
#define PC_VPP_OPTI_NO_CONNECT		0x00
#define PC_VPP_OPTI_SETTO_VCC		0x01
#define PC_VPP_OPTI_120V		0x02
#define PC_VPP_OPTI_0V			0x03

#define PC_VCC_OPTI_MASK		0x18
#define PC_VCC_OPTI_NO_CONNECT		0x00
#define PC_VCC_OPTI_033V		0x08
#define PC_VCC_OPTI_050V		0x10
#define PC_VCC_OPTI_0XXV		0x18

//Interrupt and General Control Register bits
#define IGC_IRQ_MASK                    0x0f
#define IGC_INTR_ENABLE                 0x10
#define IGC_PCCARD_IO                   0x20
#define IGC_PCCARD_RESETLO              0x40
#define IGC_RINGIND_ENABLE              0x80

//Card Status Change Register bits
#define CSC_CHANGE_MASK                 0x0f
#define CSC_BATT_DEAD                   0x01
#define CSC_BATT_WARNING                0x02
#define CSC_BATT_MASK			(CSC_BATT_DEAD | CSC_BATT_WARNING)
#define CSC_READY_CHANGE                0x04
#define CSC_CD_CHANGE                   0x08

//Card Status Change Interrupt Configuration Register bits
#define CSCFG_ENABLE_MASK               0x0f
#define CSCFG_BATT_DEAD                 0x01
#define CSCFG_BATT_WARNING              0x02
#define CSCFG_BATT_MASK			(CSCFG_BATT_DEAD | CSCFG_BATT_WARNING)
#define CSCFG_READY_ENABLE              0x04
#define CSCFG_CD_ENABLE                 0x08
#define CSCFG_IRQ_MASK                  0xf0

//Address Window Enable Register bits
#define WE_MEM0_ENABLE                  0x01
#define WE_MEM1_ENABLE                  0x02
#define WE_MEM2_ENABLE                  0x04
#define WE_MEM3_ENABLE                  0x08
#define WE_MEM4_ENABLE                  0x10
#define WE_MEMWIN_MASK			(WE_MEM0_ENABLE | WE_MEM1_ENABLE | \
					 WE_MEM2_ENABLE | WE_MEM3_ENABLE | \
					 WE_MEM4_ENABLE)
#define WE_MEMCS16_DECODE               0x20
#define WE_IO0_ENABLE                   0x40
#define WE_IO1_ENABLE                   0x80
#define WE_IOWIN_MASK			(WE_IO0_ENABLE | WE_IO1_ENABLE)

//I/O Control Register bits
#define IOC_IO0_MASK                    0x0f
#define IOC_IO0_DATASIZE                0x01
#define IOC_IO0_IOCS16                  0x02
#define IOC_IO0_ZEROWS                  0x04
#define IOC_IO0_WAITSTATE               0x08
#define IOC_IO1_MASK                    0xf0
#define IOC_IO1_DATASIZE                0x10
#define IOC_IO1_IOCS16                  0x20
#define IOC_IO1_ZEROWS                  0x40
#define IOC_IO1_WAITSTATE               0x80

//Card Detection and General Control Register
#define CDGC_SW_DET_INT			0x20

//Memory Window Start Register bits
#define MEMBASE_ADDR_MASK               0x0fff
#define MEMBASE_ZEROWS                  0x4000
#define MEMBASE_16BIT                   0x8000

//Memory Window Stop Register bits
#define MEMEND_ADDR_MASK                0x0fff
#define MEMEND_WS_MASK                  0xc000

//Memory Window Offset Register bits
#define MEMOFF_ADDR_MASK                0x3fff
#define MEMOFF_REG_ACTIVE               0x4000
#define MEMOFF_WP                       0x8000

//Cirrus Logic Miscellaneous Control 1 Register bits
#define CL_MC1_5V_DETECT		0x01
#define CL_MC1_MM_ENABLE		0x01
#define CL_MC1_VCC_33V			0x02
#define CL_MC1_PULSE_MGMT_INT		0x04
#define CL_MC1_PULSE_SYSTEM_IRQ		0x08
#define CL_MC1_SPKR_ENABLE		0x10
#define CL_MC1_INPACK_ENABLE		0x80

//Cirrus Logic Miscellaneous Control 2 Register bits
#define CL_MC2_BFS			0x01
#define CL_MC2_LPDYNAMIC_MODE		0x02
#define CL_MC2_SUSPEND			0x04
#define CL_MC2_5VCORE			0x08
#define CL_MC2_DRIVELED_ENABLE		0x10
#define CL_MC2_TIMERCLK_DIVIDE		0x10
#define CL_MC2_3STATE_BIT7		0x20
#define CL_MC2_DMA_SYSTEM		0x40
#define CL_MC2_IRQ15_RIOUT		0x80

//Cirrus Logic Miscellaneous Control 3 Register bits
#define CL_MC3_INTMODE_MASK             0x03
#define CL_MC3_INTMODE_SERIAL           0x00
#define CL_MC3_INTMODE_EXTHW            0x01
#define CL_MC3_INTMODE_PCIWAY           0x02
#define CL_MC3_INTMODE_PCI              0x03    //default
#define CL_MC3_PWRMODE_MASK             0x0c
#define CL_MC3_HWSUSPEND_ENABLE         0x10
#define CL_MC3_MM_ARM			0x80

//Cirrus Logic Chip Info Register bits
#define CL_CI_REV_MASK			0x1e
#define CL_CI_DUAL_SOCKET		0x20
#define CL_CI_CHIP_ID			0xc0

//Cirrus Logic Mask Revision Register bits
#define CL_MSKREV_MASK			0x0f

//Cirrus Logic Product ID Register bits
#define CL_PID_PRODUCT_CODE_MASK	0x0f
#define CL_PID_FAMILY_CODE_MASK		0xf0

//Cirrus Logic Device Capability Register A bits
#define CL_CAPA_NUMSKT_MASK		0x03
#define CL_CAPA_IDE_INTERFACE		0x04
#define CL_CAPA_SLAVE_DMA		0x08
#define CL_CAPA_CPSTB_CAPABLE		0x20
#define CL_CAPA_PER_SKT_LED		0x80

//Cirrus Logic Device Capability Register B bits
#define CL_CAPB_CARDBUS_CAPABLE		0x01
#define CL_CAPB_LOCK_SUPPORT		0x02
#define CL_CAPB_CLKRUN_SUPPORT		0x04
#define CL_CAPB_EXT_DEF			0x80

//Cirrus Logic Device Implementation Register A bits
#define CL_IMPA_NUMSKT_MASK		0x03
#define CL_IMPA_SLAVE_DMA		0x04
#define CL_IMPA_VS1_VS2			0x08
#define CL_IMPA_GPSTB_A			0x10
#define CL_IMPA_GPSTB_B			0x20
#define CL_IMPA_HW_SUSPEND		0x40
#define CL_IMPA_RI_OUT			0x80

//Cirrus Logic Device Implementation Register B bits
#define CL_IMPB_033_VCC			0x01
#define CL_IMPB_050_VCC			0x02
#define CL_IMPB_0YY_VCC			0x04
#define CL_IMPB_0XX_VCC			0x08
#define CL_IMPB_120_VPP			0x10
#define CL_IMPB_VPP_VCC_1A		0x20
#define CL_IMPB_RFRATED_SKT		0x40

//Cirrus Logic Device Implementation Register C bits
#define CL_IMPC_LED			0x01
#define CL_IMPC_PER_SKT_LED		0x02
#define CL_IMPC_SPK			0x04
#define CL_IMPC_ZVP_A			0x08
#define CL_IMPC_ZVP_B			0x10

//Cirrus Logic Device Implementation Register D bits
#define CL_IMPD_CLKRUN			0x01
#define CL_IMPD_LOCK			0x02
#define CL_IMPD_EXT_CLK			0x40

//Cirrus Logic Extension Registers
#define CLEXTREG_EXTCTRL_1		0x03
#define CLEXTREG_MEMWIN0_HIADDR		0x05
#define CLEXTREG_MEMWIN1_HIADDR		0x06
#define CLEXTREG_MEMWIN2_HIADDR		0x07
#define CLEXTREG_MEMWIN3_HIADDR		0x08
#define CLEXTREG_MEMWIN4_HIADDR		0x09
#define CLEXTREG_EXT_DATA		0x0a
#define CLEXTREG_EXTCTRL_2		0x0b

//Cirrus Logic External Data Register bits (Index=0x6f,ExtIndex=0x0a)
#define CL_EDATA_A_VS1			0x01
#define CL_EDATA_A_VS2			0x02
#define CL_EDATA_A_5V			(CL_EDATA_A_VS1 | CL_EDATA_A_VS2)
#define CL_EDATA_B_VS1			0x04
#define CL_EDATA_B_VS2			0x08
#define CL_EDATA_B_5V			(CL_EDATA_B_VS1 | CL_EDATA_B_VS2)

//Toshiba TOPIC95 Function Control Register bits
#define TO_FCTRL_CARDPWR_ENABLE		0x01
#define TO_FCTRL_VSSTATUS_ENABLE	0x02
#define TO_FCTRL_PPEC_TIMING_ENABLE	0x04
#define TO_FCTRL_CARD_TIMING_ENABLE	0x08
#define TO_FCTRL_CARD_MEMPAGE_ENABLE	0x10
#define TO_FCTRL_DMA_ENABLE		0x20
#define TO_FCTRL_PWRCTRL_BUFFER_ENABLE	0x40

//Toshiba TOPIC95 Multimedia Interface Control Register bits
#define TO_MMI_VIDEO_CTRL		0x01
#define TO_MMI_AUDIO_CTRL		0x02
#define TO_MMI_REV_BIT			0x80

//Toshiba TOPIC95 Addition General Control Register bits
#define TO_GCTRL_CARDREMOVAL_RESET	0x02
#define TO_GCTRL_SWCD_INT		0x20

//Databook DB87144 Zoom Video Port Enable Register
#define DBK_ZVE_MODE_MASK		0x03
#define DBK_ZVE_STANDARD_MODE		0x00
#define DBK_ZVE_MM_MODE			0x03

//OPTi Global Control Register bits
#define OPTI_ZV_ENABLE                  0x20

//VLSI ELC Constants
#define VLSI_ELC_ALIAS			0x8000
#define VLSI_EA2_EA_ENABLE		0x10
#define VLSI_CC_VS1			0x04

//VADEM Constants
#define VADEM_UNLOCK_SEQ1		0x0e
#define VADEM_UNLOCK_SEQ2		0x37
#define VADEM_MISC_UNLOCK_VADEMREV	0xc0
#define VADEM_IDREV_VG469_REV		0x0c
#define VADEM_VSEL_VCC_MASK		0x03
#define VADEM_VSEL_VCC_050V		0x00
#define VADEM_VSEL_VCC_033V		0x01
#define VADEM_VSEL_VCC_XXXV		0x02
#define VADEM_VSEL_VCC_033VB		0x03
#define VADEM_VSEL_SKT_MIXEDVOLT	0x40
#define VADEM_VSENSE_A_VS1		0x01
#define VADEM_VSENSE_A_VS2		0x02
#define VADEM_VSENSE_B_VS1		0x04
#define VADEM_VSENSE_B_VS2		0x08
#define VADEM_VSENSE_050V_ONLY		0x03

//IBM King Constants
#define KING_CVS_VS1			0x01
#define KING_CVS_VS2			0x02
#define KING_CVS_VS_MASK		(KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_5V			(KING_CVS_VS1 | KING_CVS_VS2)
#define KING_CVS_GPI			0x80

//Ricoh RL5C466 Miscellaneous Control 1 Register bits
#define RICOH_MC1_VS                    0x01
#define RICOH_MC1_IREQ_SENSE_SEL        0x02
#define RICOH_MC1_INPACK_ENABLE         0x04
#define RICOH_MC1_ZV_ENABLE             0x08
#define RICOH_MC1_DMA_ENABLE_MASK       0x30
#define RICOH_MC1_DMA_DISABLE           0x00
#define RICOH_MC1_DMA_INPACK            0x10
#define RICOH_MC1_DMA_IOIS16            0x20
#define RICOH_MC1_DMA_SPKR              0x30

//Misc. Constants
#define EXCAREGBASE_SPACE		0x40
#define NUMWIN_PCCARD16                 7       //5 mem + 2 io per socket
#define NUMWIN_PC16_MEM                 5
#define NUMWIN_PC16_IO                  2
#define PCCARD_IOWIN_START              5

//These are default values for the slowest and fastest memory speeds supported.
//It may be necessary to change the actual values with arguments, if the bus
//speed is not the default 8MHz/8.33MHz, which gives 120ns-125ns per cycle.
//Note that the SLOW_MEM_SPEED should be the same as the default
//WaitToSpeed[3], and FAST_MEM_SPEED might as well be 1ns, since the socket
//will support arbitrarily fast memory.
#define SLOW_MEM_SPEED                  0x72    //700ns
#define FAST_MEM_SPEED                  0x08    //1ns

#define RESET_DELAY                     2000    //2ms
#define PWRON_DELAY                     300000  //300ms

//I/O Control Register default nibble values
//The Xircom net PC cards fails with a 16-bit wait on the AcerNote which
//has a Cirrus Logic controller.  Why the addition of a wait state causes
//this to fail is a mystery.  The Socket EA PC card fails on the IBM ThinkPad
//755 if the 16-bit wait state is not set.
#define DEF_IOC_8BIT                    0x00
#define DEF_IOC_16BIT                   (IOC_IO0_DATASIZE | IOC_IO0_IOCS16 | \
                                         IOC_IO0_WAITSTATE)


/*** ExCA Type and Structure Definitions
 */

typedef struct excaregs_s {
    BYTE  bIDRev;                       //0x00
    BYTE  bInterfaceStatus;             //0x01
    BYTE  bPowerControl;                //0x02
    BYTE  bIntGenControl;               //0x03
    BYTE  bCardStatusChange;            //0x04
    BYTE  bCardStatusIntConfig;         //0x05
    BYTE  bWindowEnable;                //0x06
    BYTE  bIOControl;                   //0x07
    BYTE  bIO0StartLo;                  //0x08
    BYTE  bIO0StartHi;                  //0x09
    BYTE  bIO0StopLo;                   //0x0a
    BYTE  bIO0StopHi;                   //0x0b
    BYTE  bIO1StartLo;                  //0x0c
    BYTE  bIO1StartHi;                  //0x0d
    BYTE  bIO1StopLo;                   //0x0e
    BYTE  bIO1StopHi;                   //0x0f
    BYTE  bMem0StartLo;                 //0x10
    BYTE  bMem0StartHi;                 //0x11
    BYTE  bMem0StopLo;                  //0x12
    BYTE  bMem0StopHi;                  //0x13
    BYTE  bMem0OffsetLo;                //0x14
    BYTE  bMem0OffsetHi;                //0x15
    WORD  wReserved0;                   //0x16
    BYTE  bMem1StartLo;                 //0x18
    BYTE  bMem1StartHi;                 //0x19
    BYTE  bMem1StopLo;                  //0x1a
    BYTE  bMem1StopHi;                  //0x1b
    BYTE  bMem1OffsetLo;                //0x1c
    BYTE  bMem1OffsetHi;                //0x1d
    WORD  wReserved1;                   //0x1e
    BYTE  bMem2StartLo;                 //0x20
    BYTE  bMem2StartHi;                 //0x21
    BYTE  bMem2StopLo;                  //0x22
    BYTE  bMem2StopHi;                  //0x23
    BYTE  bMem2OffsetLo;                //0x24
    BYTE  bMem2OffsetHi;                //0x25
    WORD  wReserved2;                   //0x26
    BYTE  bMem3StartLo;                 //0x28
    BYTE  bMem3StartHi;                 //0x29
    BYTE  bMem3StopLo;                  //0x2a
    BYTE  bMem3StopHi;                  //0x2b
    BYTE  bMem3OffsetLo;                //0x2c
    BYTE  bMem3OffsetHi;                //0x2d
    WORD  wReserved3;                   //0x2e
    BYTE  bMem4StartLo;                 //0x30
    BYTE  bMem4StartHi;                 //0x31
    BYTE  bMem4StopLo;                  //0x32
    BYTE  bMem4StopHi;                  //0x33
    BYTE  bMem4OffsetLo;                //0x34
    BYTE  bMem4OffsetHi;                //0x35
    WORD  wReserved4;                   //0x36
    DWORD dgReserved5;                  //0x38
    DWORD dgReserved6;                  //0x3c
} EXCAREGS;
typedef EXCAREGS *PEXCAREGS;


#endif  //ifndef _PCSKTHW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\physical.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    physical.cpp

Abstract:
    Extensions to read/display physocal memory

Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 5/9/2001

--*/

#include "precomp.h"
#pragma hdrstop

ULONG64 g_LastAddress = 0;

/*++

Routine Description:

    Dumps specified range of physical memory in given format

Arguments:

    Address - Address to start
    
    NumEntries - Number of entries to dump 
    
    EntrySize - Size of each entry

    ShowAsAscii - print corresponding ascii chars
        
Return Value:

    None.


--*/
BOOL
DumpPhysicalMemory(
    ULONG64 Address,
    ULONG NumEntries,
    ULONG EntrySize,
    BOOL ShowAsAscii
    )
{
#define NumberBytesToRead 32*4

    UCHAR Buffer[NumberBytesToRead];
    ULONG ActualRead=0;
    
    if ((EntrySize != 1) && (EntrySize != 2) && (EntrySize != 4) && (EntrySize != 8)) {
        EntrySize=4;
    }
    while (1) {
        if (CheckControlC()) {
            break;
        }
        ReadPhysical(Address,Buffer,sizeof(Buffer),&ActualRead);
        if (ActualRead != sizeof(Buffer)) {
            dprintf("Physical memory read at %I64lx failed\n", Address);
            return FALSE;
        } else {
            PCHAR DumpByte = (PCHAR)&Buffer[0], pRow;
            ULONG cnt;
            pRow = DumpByte;
            for(cnt=0;cnt<NumberBytesToRead;DumpByte+=EntrySize) {
                if (!(cnt & 0xf)) {
                    dprintf("#%8I64lx", Address+cnt);
                }
                switch (EntrySize) {
                case 1:
                    dprintf("%c%02lx", ((cnt&0xf) == 8 ? '-' : ' '),*((PUCHAR)DumpByte));
                    break;
                case 2:
                    dprintf(" %04lx", *((PUSHORT) DumpByte));
                    break;
                case 4:
                    dprintf(" %08lx", *((PULONG) DumpByte));
                    break;
                case 8:
                    dprintf(" %08lx'%08lx", *((PULONG) DumpByte), *((PULONG) (DumpByte+4)));
                    break;
                }

                cnt+=EntrySize, NumEntries--;
                if ((cnt && !(cnt & 0xf)) || !NumEntries) {
                    if (ShowAsAscii) {
                        char ch;
                        dprintf(" ");
                        for (ULONG d=0; d < 16; d++) {
                            ch = pRow[d];
                            if (ch < 0x20 || ch > 0x7e) {
                                ch = '.';
                            }
                            dprintf("%c", ch);
                        }
                    }
                    dprintf("\n");
                    pRow = DumpByte;

                }
                if (!NumEntries) {
                    break;
                }
            }
            Address += cnt;
            if (!NumEntries) {
                break;
            }
        }
    }
    g_LastAddress = Address;

    return TRUE;
}

/*++

Routine Description:

    Reverse sign extension of the value returned by GetExpression()
    based on the assumption that no physical address may be bigger 
    than 0xfffffff00000000.

Arguments:

    Val - points to the value to reverse sign extension

Return Value:

    None.

--*/

void
ReverseSignExtension(ULONG64* Val)
{
    if ((*Val & 0xffffffff00000000) == 0xffffffff00000000) 
    {
        *Val &= 0x00000000ffffffff;
    }
}


void
GetPhyDumpArgs(
    PCSTR Args,
    PULONG64 Address,
    PULONG Range
    )
{
    CHAR Buffer[100]={0};

    if(*Args == '\0') {
        *Address=g_LastAddress;
    } else {
        sscanf(Args, "%s", Buffer);
        *Address = GetExpression((PCSTR) &Buffer[0]);
        ReverseSignExtension(Address);
        *Address &= (~0x3);      // Truncate to dword boundary
        g_LastAddress=*Address;
        Args += strlen(&Buffer[0]);
        while (*Args && (*Args == ' ' || *Args == '\t')) {
            ++Args;
        }
        if (*Args == 'l' || *Args == 'L') {
            ++Args;
            *Range = (ULONG) GetExpression(Args);
        }
    }
    return;
}

DECLARE_API( db )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;

    GetPhyDumpArgs(args, &Address, &Range);
    if (!Range) {
        Range = 128;
    }
    DumpPhysicalMemory(Address, Range, 1, TRUE);
    return S_OK;
}

DECLARE_API( dd )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;

    GetPhyDumpArgs(args, &Address, &Range);
    if (!Range) {
        Range = 32;
    }
    DumpPhysicalMemory(Address, Range, 4, FALSE);
    return S_OK;
}

DECLARE_API( dw )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;

    GetPhyDumpArgs(args, &Address, &Range);
    if (!Range) {
        Range = 64;
    }
    DumpPhysicalMemory(Address, Range, 2, FALSE);
    return S_OK;
}

DECLARE_API( dp )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;

    GetPhyDumpArgs(args, &Address, &Range);
    if (!Range) {
        Range = IsPtr64() ? 16 : 32;
    }
    DumpPhysicalMemory(Address, Range, IsPtr64() ? 8 : 4, FALSE);
    return S_OK;
}
DECLARE_API( dc )

/*++

Routine Description:

    Does a read of N ULONGS from the physical memory of the target machine,
    dumping both hex and ASCII.

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0;

    GetPhyDumpArgs(args, &Address, &Range);
    if (!Range) {
        Range = 32;
    }
    DumpPhysicalMemory(Address, Range, 4, TRUE);
    return S_OK;
}

DECLARE_API( du )

/*++

Routine Description:

    Does a read of 16 ULONGS from the physical memory of the target machine

Arguments:

    args - Supplies physical address

Return Value:

    None.

--*/

{

    ULONG64 Address = 0;
    ULONG Range = 0, ActualRead;
    WCHAR Buffer[MAX_PATH]={0};
    GetPhyDumpArgs(args, &Address, &Range);
    if (Range>MAX_PATH) {
        Range = MAX_PATH;
    }
    if (!Range) {
        Range = 16;
    }
    ReadPhysical(Address,Buffer,Range,&ActualRead);
    if (ActualRead != Range) {
        dprintf("Physical memory read at %I64lx failed\n", Address);
        return FALSE;
    } else {
        ULONG cnt;
        
        dprintf("#%8I64lx \"", Address);
        for (ULONG d=0; d < Range; d++) {
            WCHAR ch = Buffer[d];
            if (ch < 0x20 || ch > 0x7e) {
                ch = '.';
            }
            dprintf("%wc", ch);
        }
        dprintf("\"\n", Address);
    }
    return S_OK;
}


DECLARE_API( ed )

/*++

Routine Description:

    Writes a sequence of ULONGs into a given physical address on the
    target machine.

Arguments:

    arg - Supplies both the target address and the data in the form of
          "PHYSICAL_ADDRESS ULONG [ULONG, ULONG,...]"

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG Buffer;
    ULONG ActualWritten=0;
    PCHAR NextToken;

    Address = GetExpression(args);

    strtok((PSTR)args," \t,");      // The first token is the address

    // Since we're picking off one ULONG at a time, we'll make
    // one DbgKdWritePhysicalMemoryAddress call per ULONG.  This
    // is slow, but easy to code.
    while((NextToken=strtok(NULL," \t,")) != NULL) {
        if (!sscanf(NextToken,"%lx",&Buffer)) {
            break;
        }
        WritePhysical(Address,&Buffer,sizeof(Buffer),&ActualWritten);
        Address+=sizeof(Buffer);
    }
    return S_OK;
}


DECLARE_API( eb )

/*++

Routine Description:

    Writes a sequence of BYTEs into a given physical address on the
    target machine.

Arguments:

    arg - Supplies both the target address and the data in the form of
          "PHYSICAL_ADDRESS ULONG [ULONG, ULONG,...]"

Return Value:

    None.

--*/

{
    ULONG64 Address = 0;
    ULONG Buffer;
    UCHAR c;
    ULONG ActualWritten;
    PCHAR NextToken;

    UNREFERENCED_PARAMETER (Client);

    Address = GetExpression(args);

    strtok((PSTR)args," \t,");      // The first token is the address

    // Since we're picking off one BYTE at a time, we'll make
    // one DbgKdWritePhysicalMemoryAddress call per BYTE.  This
    // is slow, but easy to code.
    while((NextToken=strtok(NULL," \t,")) != NULL) {
        if (!sscanf(NextToken,"%lx",&Buffer)) {
            break;
        }
        c = (UCHAR)Buffer;
        WritePhysical(Address,&c,sizeof(UCHAR),&ActualWritten);
        Address+=sizeof(UCHAR);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\kextdll\pooltag.cpp ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:
    pooltag.cpp

Abstract:


Environment:

    User Mode.

Revision History:

    Kshitiz K. Sharma (kksharma) 3/5/2001

--*/

#include "precomp.h"


ULONG
MatchPoolTag(
    PSTR Tag,
    PSTR TagToMatch
    )
{
    return !strcmp(Tag, TagToMatch);
}

BOOL
FindOwnerAndComponent(
    PSTR pszDesc,
    PDEBUG_POOLTAG_DESCRIPTION pDetails
    )
{
    PSTR pSrch, szTmp, pCurr, pLast;

    if (pszDesc) {
        pLast = pszDesc + strlen(pszDesc);
        pSrch = strrchr(pszDesc, '-');
        
        if (pSrch) {
            pCurr = pSrch;
            *pSrch++;


            while (*pSrch == ' ' || *pSrch == '\t') ++pSrch;

            if (!strncmp(pSrch, "OWNER", 5)) {

                pSrch += strlen("OWNER");
                while (*pSrch == ' ' || *pSrch == '\t') ++pSrch;
                szTmp = pSrch;
                if (strlen(szTmp) < sizeof(pDetails->Owner)) {
                    strcpy(pDetails->Owner, szTmp);
                }

                pSrch = strchr(pszDesc, '-');
                pLast = pCurr;
            }
        }

        if (pSrch) {
            ULONG i=0;
            CHAR NextWord[50];

            pCurr = pSrch;
            *pSrch++;
            while (*pSrch == ' ' || *pSrch == '\t') ++pSrch;

            if (!strncmp(pSrch, "BIN", 3)) {
                ULONG i;

                szTmp = pSrch + strlen("BIN");

                while (*pSrch == ' ' || *pSrch == '\t') ++pSrch;
                if ((ULONG) (pLast - szTmp) < sizeof(pDetails->Binary)) {
                    strncpy(pDetails->Binary, szTmp, (ULONG) (pLast - szTmp));
                }
                pLast = pCurr;

            } else { // Try and fiure out if its a filename.???
                while (i<sizeof(NextWord) && *pSrch && (*pSrch != ' ' && *pSrch != '\t')) {
                    NextWord[i++] = *pSrch++;
                }
                NextWord[i] = 0;
                szTmp = strchr(NextWord, '.');
                if (szTmp && strlen(szTmp) == 4) {  // Looks like a binaray
                    if ((ULONG) strlen(NextWord) < sizeof(pDetails->Binary)) {
                        strcpy(pDetails->Binary, NextWord);
                    }
                    pLast = pCurr;
                }
            }

        }
        if ((ULONG) (pLast - pszDesc) < sizeof(pDetails->Description)) {
            strncpy(pDetails->Description, pszDesc, (ULONG) (pLast - pszDesc));
        }
    } else {
        return FALSE;
    }
    return TRUE;
}

PSTR
GetNextLine(
    HANDLE hFile
    )
// Returns next line in the file hFile
// Returns NULL if EOF is reached
{
    static CHAR FileLines1[MAX_PATH] = {0}, FileLines2[MAX_PATH] = {0};
    static CHAR FileLine[MAX_PATH];
    PCHAR pEOL;
    ULONG BytesRead;
    PCHAR pEndOfBuff;
    ULONG BuffLen, ReadLen;

    pEOL = NULL;
    if (!(pEOL = strchr(FileLines1, '\n'))) {
        // We have something that was already read but it isn't enough for a whole line
        // We need to read the data

        BuffLen = strlen(FileLines1);
        
        // sanity check
        if (BuffLen >= sizeof(FileLines1)) {
            return NULL;
        }

        pEndOfBuff = &FileLines1[0] + BuffLen;
        ReadLen = sizeof(FileLines1) - BuffLen;
        
        ZeroMemory(pEndOfBuff, ReadLen);
        if (ReadFile(hFile, pEndOfBuff, ReadLen - 1, &BytesRead, NULL)) {
            pEOL = strchr(FileLines1, '\n');
        }
    }

    if (pEOL) {
        FileLine[0] = 0;
        
        strncat(FileLine,FileLines1, (ULONG) (pEOL - &FileLines1[0]));
        strcpy(FileLines2, pEOL+1);
        strcpy(FileLines1, FileLines2);
        pEOL = strchr(FileLine, '\n');
        if (pEOL) *pEOL = 0;
        return FileLine;
    }

    return NULL;
}


BOOL
GetPoolTagDescriptionFromTxtFile(
    IN ULONG PoolTag,
    PDEBUG_POOLTAG_DESCRIPTION pDetails
    )
//
// Get pool tag description from pooltag.txt file, if present, in current dir
//
{
    const LPSTR PoolTagTxtFile = "triage\\pooltag.txt";
    static CHAR TagDesc[MAX_PATH];
    CHAR *pPoolTagTxtFile, ExeDir[MAX_PATH+50];  // make it big enough to append PoolTagTxtFile
    PSTR pCurrLine, pDescription, pOwner;
    CHAR PoolTagStr[5], PossiblePoolTag[5];
    ULONG i=0;
    ULONG Match, PrevMatch;

    HANDLE hFile;


    // Get the directory the debugger executable is in.
    if (!GetModuleFileName(NULL, ExeDir, MAX_PATH)) {
        // Error.  Use the current directory.
        strcpy(ExeDir, ".");
    } else {
        // Remove the executable name.
        PCHAR pszTmp = strrchr(ExeDir, '\\');
        if (pszTmp)
        {
            *pszTmp = 0;
        }
    }
    strcat(ExeDir, "\\");
    strcat(ExeDir, PoolTagTxtFile);
    pPoolTagTxtFile = &ExeDir[0];
    hFile = CreateFile(pPoolTagTxtFile, GENERIC_READ, FILE_SHARE_READ,
                       NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    *((PULONG) &PoolTagStr) = PoolTag;
    PoolTagStr[4] = 0;
    PrevMatch = 0;
    while (pCurrLine = GetNextLine(hFile)) {
        ++i;
        while (*pCurrLine == ' ' || *pCurrLine == '\t') {
            ++pCurrLine;
        }
        
        if (*pCurrLine == '%' || !_strnicmp(pCurrLine, "rem", 3)) {
            // a commented line
            continue;
        }
        
        strncpy(PossiblePoolTag, pCurrLine, 4);
        PossiblePoolTag[4] = 0;

        pCurrLine +=4;
        while (*pCurrLine == ' ' || *pCurrLine == '\t') {
            ++pCurrLine;
        }
        if (*pCurrLine == '-' && (Match = MatchPoolTag(PossiblePoolTag, PoolTagStr))) {
            // Its a match
            ++pCurrLine;
            while (*pCurrLine == ' ' || *pCurrLine == '\t') {
                ++pCurrLine;
            }
            break;
        }
    }

    CloseHandle(hFile);
    
    if (pCurrLine) {
        FindOwnerAndComponent(pCurrLine, pDetails);
    }
    return TRUE;

}

BOOL
GetPoolTagDescription(
    IN ULONG PoolTag,
    OUT PDEBUG_POOLTAG_DESCRIPTION pDescription
    )
{
    ULONG lo;
    
    return GetPoolTagDescriptionFromTxtFile(PoolTag, pDescription);
}

EXTENSION_API ( GetPoolTagDescription ) (
     IN ULONG PoolTag,
     OUT PDEBUG_POOLTAG_DESCRIPTION pDescription
     )
{
    if (!pDescription || (pDescription->SizeOfStruct != sizeof(DEBUG_POOLTAG_DESCRIPTION))) {
        return E_INVALIDARG;
    }
    if (GetPoolTagDescription(PoolTag, pDescription)) {
        return S_OK;
    } 
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\uextdll\precomp.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED       g_ExtAdvanced;
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_DATA_SPACES2   g_ExtData;
extern PDEBUG_REGISTERS      g_ExtRegisters;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

extern ULONG64  STeip;
extern ULONG64  STebp;
extern ULONG64  STesp;
extern ULONG64  EXPRLastDump;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);


//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\uextdll\handle.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    handle.cpp

Abstract:

    !handle using the debug engine handle query interface.

--*/

#include "precomp.h"
#pragma hdrstop

char * AccessMask[] = { "Delete", "ReadControl", "WriteDac", "WriteOwner",
                        "Synch", "", "", "",
                        "Sacl", "MaxAllowed", "", "",
                        "GenericAll", "GenericExec", "GenericWrite", "GenericRead"};

char * TokenRights[] = {"AssignPrimary", "Duplicate", "Impersonate", "Query",
                        "QuerySource", "AdjustPriv", "AdjustGroup", "AdjustDef"};

char * KeyRights[] = {  "QueryValue", "SetValue", "CreateSubKey", "EnumSubKey",
                        "Notify", "CreateLink", "", "" };

char * EventRights[] = {"QueryState", "ModifyState" };

char * MutantRights[]={ "QueryState" };

char * SemaphoreRights[] = { "QueryState", "ModifyState" };

char * TimerRights[] = {"QueryState", "ModifyState" };

char * ProfileRights[]={"Control"};

char * ProcessRights[]={"Terminate", "CreateThread", "", "VMOp",
                        "VMRead", "VMWrite", "DupHandle", "CreateProcess",
                        "SetQuota", "SetInfo", "QueryInfo", "SetPort" };

char * ThreadRights[] ={"Terminate", "Suspend", "Alert", "GetContext",
                        "SetContext", "SetInfo", "QueryInfo", "SetToken",
                        "Impersonate", "DirectImpersonate" };

char * SectionRights[]={"Query", "MapWrite", "MapRead", "MapExecute",
                        "Extend"};

char * FileRights[] = { "Read/List", "Write/Add", "Append/SubDir/CreatePipe", "ReadEA",
                        "WriteEA", "Execute/Traverse", "DelChild", "ReadAttr",
                        "WriteAttr"};

char * PortRights[] = { "Connect" };

char * DirRights[]  = { "Query", "Traverse", "Create", "CreateSubdir" };

char * SymLinkRights[]={"Query" };

char * WinstaRights[]={ "EnumDesktops", "ReadAttr", "Clipboard", "CreateDesktop",
                        "WriteAttr", "GlobalAtom", "ExitWindows", "",
                        "Enumerate", "ReadScreen" };

char * DesktopRights[]={"ReadObjects", "CreateWindow", "CreateMenu", "HookControl",
                        "JournalRecord", "JournalPlayback", "Enumerate", "WriteObjects",
                        "SwitchDesktop" };

char * CompletionRights[] = { "Query", "Modify" };

char * ChannelRights[] = { "ReadMessage", "WriteMessage", "Query", "SetInfo" };

char * JobRights[] = { "AssignProcess", "SetAttr", "Query", "Terminate", "SetSecAttr" };

#define GHI_TYPE        0x00000001
#define GHI_BASIC       0x00000002
#define GHI_NAME        0x00000004
#define GHI_SPECIFIC    0x00000008
#define GHI_VERBOSE     0x00000010
#define GHI_NOLOOKUP    0x00000020
#define GHI_SILENT      0x00000100

#define TYPE_NONE       0
#define TYPE_EVENT      1
#define TYPE_SECTION    2
#define TYPE_FILE       3
#define TYPE_PORT       4
#define TYPE_DIRECTORY  5
#define TYPE_LINK       6
#define TYPE_MUTANT     7
#define TYPE_WINSTA     8
#define TYPE_SEM        9
#define TYPE_KEY        10
#define TYPE_TOKEN      11
#define TYPE_PROCESS    12
#define TYPE_THREAD     13
#define TYPE_DESKTOP    14
#define TYPE_COMPLETE   15
#define TYPE_CHANNEL    16
#define TYPE_TIMER      17
#define TYPE_JOB        18
#define TYPE_WPORT      19
#define TYPE_MAX        20

typedef struct _TYPEINFO
{
    PSTR        Name;
    char * *    AccessRights;
    DWORD       NumberRights;
} TYPEINFO, * PTYPEINFO;

TYPEINFO g_TypeNames[TYPE_MAX] =
{
    { "None", NULL, 0 },
    { "Event", EventRights, 2 },
    { "Section", SectionRights, 5 },
    { "File", FileRights, 9 },
    { "Port", PortRights, 1 },
    { "Directory", DirRights, 4 },
    { "SymbolicLink", SymLinkRights, 1 },
    { "Mutant", MutantRights, 2 },
    { "WindowStation", WinstaRights, 10 },
    { "Semaphore", SemaphoreRights, 2 },
    { "Key", KeyRights, 6 },
    { "Token", TokenRights, 8 },
    { "Process", ProcessRights, 12 },
    { "Thread", ThreadRights, 10 },
    { "Desktop", DesktopRights, 10 },
    { "IoCompletion", CompletionRights, 2 },
    { "Channel", ChannelRights, 4},
    { "Timer", TimerRights, 2 },
    { "Job", JobRights, 5 },
    { "WaitablePort", PortRights, 1 }
};

void DisplayFlags(  DWORD       Flags,
                    DWORD       FlagLimit,
                    char        *flagset[],
                    PSTR        Buffer)
{
   char *         offset;
   DWORD          mask, test, i;
   DWORD          scratch;

   if (!Flags)
   {
      strcpy(Buffer, "None");
      return;
   }

   mask = 0;
   offset = Buffer;
   test = 1;
   for (i = 0 ; i < FlagLimit ; i++ )
   {
      if (Flags & test)
      {
         scratch = sprintf(offset, "%s", flagset[i]);
         offset += scratch;
         mask |= test;
         if (Flags & (~mask))
         {
            *offset++ = ',';
         }
      }
      test <<= 1;
   }
}

DWORD
GetObjectTypeIndex(
    LPCSTR TypeName
    )
{
    DWORD   i;

    for ( i = 1 ; i < TYPE_MAX ; i++ )
    {
        if (_stricmp( g_TypeNames[i].Name, TypeName ) == 0 )
        {
            return( i );
        }
    }

    return( (DWORD) -1 );
}

DWORD
GetHandleInfo(
    ULONG64 hThere,
    DWORD   Flags,
    DWORD * Type)
{
    HRESULT Status;
    DWORD   SuccessCount = 0;
    DWORD   i;
    UCHAR   Buffer[1024];
    CHAR    szBuf[256];

    if ( (Flags & GHI_SILENT) == 0)
    {
        dprintf("Handle %p\n", hThere );
    }

    if (Flags & GHI_TYPE)
    {
        if (g_ExtData->
            ReadHandleData(hThere,
                           DEBUG_HANDLE_DATA_TYPE_TYPE_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            if ((Flags & GHI_SILENT) == 0)
            {
                dprintf("  Type         \t%s\n", Buffer);
            }
            for (i = 1; i < TYPE_MAX ; i++)
            {
                if (strcmp((LPSTR)Buffer, g_TypeNames[i].Name) == 0)
                {
                    *Type = i;
                    break;
                }
            }
            if (i == TYPE_MAX)
            {
                *Type = 0;
            }
            SuccessCount++;
        }
    }

    if (Flags & GHI_BASIC)
    {
        DEBUG_HANDLE_DATA_BASIC Basic;

        if (g_ExtData->
            ReadHandleData(hThere,
                           DEBUG_HANDLE_DATA_TYPE_BASIC,
                           &Basic, sizeof(Basic), NULL) == S_OK)
        {
            dprintf("  Attributes   \t%#x\n", Basic.Attributes );
            dprintf("  GrantedAccess\t%#x:\n", Basic.GrantedAccess );
            DisplayFlags( Basic.GrantedAccess >> 16,
                          16,
                          AccessMask,
                          szBuf);
            dprintf("         %s\n", szBuf);
            DisplayFlags( Basic.GrantedAccess & 0xFFFF,
                          g_TypeNames[ *Type ].NumberRights,
                          g_TypeNames[ *Type ].AccessRights,
                          szBuf);
            dprintf("         %s\n", szBuf);
            dprintf("  HandleCount  \t%d\n", Basic.HandleCount );
            dprintf("  PointerCount \t%d\n", Basic.PointerCount );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ( (Flags & GHI_NAME) &&
         (*Type != TYPE_FILE ) )
    {
        if (g_ExtData->
            ReadHandleData(hThere,
                           DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME,
                           Buffer, sizeof(Buffer), NULL) == S_OK)
        {
            dprintf("  Name         \t%s\n",
                    Buffer[0] ? (PSTR)Buffer : "<none>" );
            SuccessCount++;
        }
        else
        {
            dprintf("unable to query object information\n");
        }
    }

    if ( Flags & GHI_SPECIFIC )
    {
        dprintf("  No object specific information available\n");
    }

    return( SuccessCount );
}

/*++

Routine Description:

    This function is called as an NTSD extension to mimic the !handle
    kd command.  This will walk through the debuggee's handle table
    and duplicate the handle into the ntsd process, then call NtQueryobjectInfo
    to find out what it is.

    Called as:

        !handle [handle [flags [Type]]]

    If the handle is 0 or -1, all handles are scanned.  If the handle is not
    zero, that particular handle is examined.  The flags are as follows
    (corresponding to secexts.c):
        1   - Get type information (default)
        2   - Get basic information
        4   - Get name information
        8   - Get object specific info (where available)

    If Type is specified, only object of that type are scanned.  Type is a
    standard NT type name, e.g. Event, Semaphore, etc.  Case sensitive, of
    course.

    Examples:

        !handle     -- dumps the types of all the handles, and a summary table
        !handle 0 0 -- dumps a summary table of all the open handles
        !handle 0 f -- dumps everything we can find about a handle.
        !handle 0 f Event
                    -- dumps everything we can find about open events

--*/
DECLARE_API( handle )
{
    ULONG64 hThere;
    DWORD   Type;
    DWORD   Mask;
    DWORD   HandleCount;
    DWORD   Total;
    DWORD   TypeCounts[TYPE_MAX];
    DWORD   Handle;
    DWORD   Hits;
    DWORD   Matches;
    DWORD   ObjectType;
    ULONG   SessionType;
    ULONG   SessionQual;

    INIT_API();

    //
    // This particular implementation is only used for
    // dump debug sessions as more information can be
    // retrieved on live sessions via the NtQuery APIs.
    // If this isn't a dump session let the !handle
    // search continue on.
    //
    
    if (g_ExtControl == NULL ||
        g_ExtControl->
        GetDebuggeeType(&SessionType, &SessionQual) != S_OK)
    {
        SessionType = DEBUG_CLASS_USER_WINDOWS;
        SessionQual = DEBUG_USER_WINDOWS_PROCESS;
    }
    if (SessionType == DEBUG_CLASS_USER_WINDOWS &&
        SessionQual == DEBUG_USER_WINDOWS_PROCESS)
    {
        ExtRelease();
        return DEBUG_EXTENSION_CONTINUE_SEARCH;
    }

    Mask = GHI_TYPE;
    hThere = (ULONG64)(LONG_PTR)INVALID_HANDLE_VALUE;
    Type = 0;

    while (*args == ' ')
    {
        args++;
    }

    hThere = GetExpression( args );

    while (*args && (*args != ' ') )
    {
        args++;
    }
    while (*args == ' ')
    {
        args++;
    }

    if (*args)
    {
        Mask = (DWORD)GetExpression( args );
    }

    while (*args && (*args != ' ') )
    {
        args++;
    }
    while (*args == ' ')
    {
        args++;
    }

    if (*args)
    {
        Type = GetObjectTypeIndex( (LPSTR)args );
        if (Type == (DWORD) -1)
        {
            dprintf("Unknown type '%s'\n", args );
            goto Exit;
        }
    }

    //
    // if they specified 0, they just want the summary.  Make sure nothing
    // sneaks out.
    //

    if ( Mask == 0 )
    {
        Mask = GHI_SILENT;
    }

    if (g_ExtData->
        ReadHandleData(0, DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT,
                       &HandleCount, sizeof(HandleCount),
                       NULL) != S_OK) {
        dprintf("Unable to read handle information\n");
        goto Exit;
    }

    //
    // hThere of 0 indicates all handles.
    //
    if ((hThere == 0) || (hThere == (ULONG64)(LONG_PTR)INVALID_HANDLE_VALUE))
    {
        Hits = 0;
        Handle = 0;
        Matches = 0;
        ZeroMemory( TypeCounts, sizeof(TypeCounts) );

        while ( Hits < HandleCount )
        {
            if ( Type )
            {
                if (GetHandleInfo( Handle,
                                   GHI_TYPE | GHI_SILENT,
                                   &ObjectType ) )
                {
                    Hits++;
                    if ( ObjectType == Type )
                    {
                        GetHandleInfo( Handle,
                                       Mask,
                                       &ObjectType );
                        Matches ++;
                    }
                }
            }
            else
            {
                if (GetHandleInfo( Handle,
                                   GHI_TYPE | GHI_SILENT,
                                   &ObjectType) )
                {
                    Hits++;
                    TypeCounts[ ObjectType ] ++;

                    GetHandleInfo( Handle,
                                   Mask,
                                   &ObjectType );
                }
            }

            Handle += 4;
        }

        if ( Type == 0 )
        {
            dprintf( "%d Handles\n", Hits );
            dprintf( "Type           \tCount\n");
            for (Type = 0; Type < TYPE_MAX ; Type++ )
            {
                if (TypeCounts[Type])
                {
                    dprintf("%-15s\t%d\n",
                            g_TypeNames[Type].Name, TypeCounts[Type]);
                }
            }
        }
        else
        {
            dprintf("%d handles of type %s\n",
                    Matches, g_TypeNames[Type].Name );
        }
    }
    else
    {
        GetHandleInfo( hThere, Mask, &Type );
    }

 Exit:
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\makefile.inc ===
EMDBDIR = ..\emdb
PERL = perl
PERL_INCLIST = -I $(IA64_DIS_INC) -I $(EMDBDIR)
EEXT = .exe
MHDR = $(PERL) $(IA64_DIS_INC)\makehdr.pl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\uextdll\vmem.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    vmem.cpp

Abstract:

    !vprot using the debug engine virtual query interface.

--*/

#include "precomp.h"
#pragma hdrstop

#define PAGE_ALL (PAGE_READONLY|\
                  PAGE_READWRITE|\
                  PAGE_WRITECOPY|\
                  PAGE_EXECUTE|\
                  PAGE_EXECUTE_READ|\
                  PAGE_EXECUTE_READWRITE|\
                  PAGE_EXECUTE_WRITECOPY|\
                  PAGE_NOACCESS)

VOID
PrintPageFlags(
    DWORD Flags
    )
{
    switch (Flags & PAGE_ALL)
    {
    case PAGE_READONLY:
        dprintf("PAGE_READONLY");
        break;
    case PAGE_READWRITE:
        dprintf("PAGE_READWRITE");
        break;
    case PAGE_WRITECOPY:
        dprintf("PAGE_WRITECOPY");
        break;
    case PAGE_EXECUTE:
        dprintf("PAGE_EXECUTE");
        break;
    case PAGE_EXECUTE_READ:
        dprintf("PAGE_EXECUTE_READ");
        break;
    case PAGE_EXECUTE_READWRITE:
        dprintf("PAGE_EXECUTE_READWRITE");
        break;
    case PAGE_EXECUTE_WRITECOPY:
        dprintf("PAGE_EXECUTE_WRITECOPY");
        break;
    case PAGE_NOACCESS:
        if ((Flags & ~PAGE_NOACCESS) == 0)
        {
            dprintf("PAGE_NOACCESS");
            break;
        } // else fall through
    default:
        dprintf("*** Invalid page protection ***\n");
        return;
    }

    if (Flags & PAGE_NOCACHE)
    {
        dprintf(" + PAGE_NOCACHE");
    }
    if (Flags & PAGE_GUARD)
    {
        dprintf(" + PAGE_GUARD");
    }
    dprintf("\n");
}

DECLARE_API( vprot )
/*++

Routine Description:

    This debugger extension dumps the virtual memory info for the
    address specified.

Arguments:


Return Value:

--*/
{
    ULONG64 Address;
    MEMORY_BASIC_INFORMATION64 Basic;

    INIT_API();

    Address = GetExpression( args );

    if ((Status = g_ExtData->QueryVirtual(Address, &Basic)) != S_OK)
    {
        dprintf("vprot: QueryVirtual failed, error = 0x%08X\n", Status);
        goto Exit;
    }

    dprintf("BaseAddress:       %p\n", Basic.BaseAddress);
    dprintf("AllocationBase:    %p\n", Basic.AllocationBase);
    dprintf("AllocationProtect: %08x  ", Basic.AllocationProtect);
    PrintPageFlags(Basic.AllocationProtect);

    dprintf("RegionSize:        %p\n", Basic.RegionSize);
    dprintf("State:             %08x  ", Basic.State);
    switch (Basic.State)
    {
    case MEM_COMMIT:
        dprintf("MEM_COMMIT\n");
        break;
    case MEM_FREE:
        dprintf("MEM_FREE\n");
        break;
    case MEM_RESERVE:
        dprintf("MEM_RESERVE\n");
        break;
    default:
        dprintf("*** Invalid page state ***\n");
        break;
    }

    dprintf("Protect:           %08x  ", Basic.Protect);
    PrintPageFlags(Basic.Protect);

    dprintf("Type:              %08x  ", Basic.Type);
    switch(Basic.Type)
    {
    case MEM_IMAGE:
        dprintf("MEM_IMAGE\n");
        break;
    case MEM_MAPPED:
        dprintf("MEM_MAPPED\n");
        break;
    case MEM_PRIVATE:
        dprintf("MEM_PRIVATE\n");
        break;
    default:
        dprintf("*** Invalid page type ***\n");
        break;
    }

 Exit:
    EXIT_API();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\sources.inc ===
!include ..\makefile.inc

# Old decem had encrypted mnemonics which it
# modified at startup so string pooling and read-only
# strings had to be turned off.  This is no longer
# necessary.
!if 0
NO_READONLY_STRINGS = 1
NO_STRING_POOLING = 1
!endif

386_STDCALL = 0
        
DISASM_INC = disem.h
DECODER_INC = decem.h

XVER_MAJOR = 9
XVER_MINOR = 60                 ### 2 digits, 09 maybe a problem ?!
API_MAJOR  = 9
API_MINOR  = 6

VFLAG = -DDISASM_NAME=\"$(DISASM_INC)\"                        \
        -DDECODER_NAME=\"$(DECODER_INC)\"                      \
        -DVER=$(VER) -DVER_STR=$(VER) -DAPI_MINOR=$(API_MINOR) \
        -DAPI_MAJOR=$(API_MAJOR) -DXVER_MAJOR=$(XVER_MAJOR)    \
        -DXVER_MINOR=$(XVER_MINOR)

INCLUDES = $(IA64_DIS_INC);..\iel

USE_MSVCRT = 1

TARGETLIBS = \
        ..\iel\$O\iel.lib\
        $(SDK_LIB_PATH)\kernel32.lib

UMTYPE = console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\exts\uextdll\uext.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    exts.cpp

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntverp.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED       g_ExtAdvanced;
PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_DATA_SPACES2   g_ExtData;
PDEBUG_REGISTERS      g_ExtRegisters;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS g_ExtSystem;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\debuggers\ia64tools\decem\decision_tree.c ===
/*** decision_tree.c ***/

#include "decision_tree.h"

Node_t em_decision_tree[] = {
/*00000*/     {80, 33, 3},
/*00001*/     {424, 33, 3},
/*00002*/     {476, 33, 1},
/*00003*/     {594, 27, 6},
/*00004*/     {850, 27, 9},
/*00005*/     {0, -1, -1},
/*00006*/     {1362, 33, 3},
/*00007*/     {1434, 33, 1},
/*00008*/     {1572, 32, 4},
/*00009*/     {0, -1, -1},
/*00010*/     {0, -1, -1},
/*00011*/     {0, -1, -1},
/*00012*/     {0, -1, -1},
/*00013*/     {1620, 27, 6},
/*00014*/     {0, -1, -1},
/*00015*/     {0, -1, -1},
/*00016*/     {0, -1, -1},
/*00017*/     {0, -1, -1},
/*00018*/     {1, -1, -1},
/*00019*/     {0, -1, -1},
/*00020*/     {173, -1, -1},
/*00021*/     {1828, 30, 7},
/*00022*/     {2628, 33, 4},
/*00023*/     {2676, 33, 3},
/*00024*/     {0, -1, -1},
/*00025*/     {2844, 33, 3},
/*00026*/     {2880, 28, 8},
/*00027*/     {3136, 12, 1},
/*00028*/     {3138, 33, 3},
/*00029*/     {0, -1, -1},
/*00030*/     {0, -1, -1},
/*00031*/     {3162, 30, 7},
/*00032*/     {0, -1, -1},
/*00033*/     {1, -1, -1},
/*00034*/     {3802, 20, 1},
/*00035*/     {3804, 32, 5},
/*00036*/     {4008, 28, 8},
/*00037*/     {0, -1, -1},
/*00038*/     {4264, 0, 6},
/*00039*/     {0, -1, -1},
/*00040*/     {4336, 33, 3},
/*00041*/     {4540, 33, 3},
/*00042*/     {4744, 34, 3},
/*00043*/     {0, -1, -1},
/*00044*/     {0, -1, -1},
/*00045*/     {20, -1, -1},
/*00046*/     {20, -1, -1},
/*00047*/     {4752, 34, 3},
/*00048*/     {0, -1, -1},
/*00049*/     {0, -1, -1},
/*00050*/     {0, -1, -1},
/*00051*/     {0, -1, -1},
/*00052*/     {4760, 34, 3},
/*00053*/     {0, -1, -1},
/*00054*/     {0, -1, -1},
/*00055*/     {0, -1, -1},
/*00056*/     {0, -1, -1},
/*00057*/     {4768, 34, 3},
/*00058*/     {0, -1, -1},
/*00059*/     {0, -1, -1},
/*00060*/     {4776, 33, 3},
/*00061*/     {4816, 33, 3},
/*00062*/     {4856, 34, 3},
/*00063*/     {0, -1, -1},
/*00064*/     {4864, 33, 3},
/*00065*/     {4952, 33, 3},
/*00066*/     {4992, 33, 3},
/*00067*/     {5032, 34, 3},
/*00068*/     {0, -1, -1},
/*00069*/     {5040, 33, 3},
/*00070*/     {5064, 33, 3},
/*00071*/     {5104, 33, 3},
/*00072*/     {5144, 36, 1},
/*00073*/     {0, -1, -1},
/*00074*/     {0, -1, -1},
/*00075*/     {0, -1, -1},
/*00076*/     {0, -1, -1},
/*00077*/     {0, -1, -1},
/*00078*/     {0, -1, -1},
/*00079*/     {0, -1, -1},
/*00080*/     {88, 27, 6},
/*00081*/     {192, -1, -1},
/*00082*/     {207, -1, -1},
/*00083*/     {206, -1, -1},
/*00084*/     {0, -1, -1},
/*00085*/     {0, -1, -1},
/*00086*/     {0, -1, -1},
/*00087*/     {152, 20, 4},
/*00088*/     {190, -1, -1},
/*00089*/     {191, -1, -1},
/*00090*/     {0, -1, -1},
/*00091*/     {0, -1, -1},
/*00092*/     {0, -1, -1},
/*00093*/     {0, -1, -1},
/*00094*/     {0, -1, -1},
/*00095*/     {0, -1, -1},
/*00096*/     {0, -1, -1},
/*00097*/     {0, -1, -1},
/*00098*/     {211, -1, -1},
/*00099*/     {0, -1, -1},
/*00100*/     {0, -1, -1},
/*00101*/     {0, -1, -1},
/*00102*/     {0, -1, -1},
/*00103*/     {0, -1, -1},
/*00104*/     {213, -1, -1},
/*00105*/     {214, -1, -1},
/*00106*/     {215, -1, -1},
/*00107*/     {0, -1, -1},
/*00108*/     {216, -1, -1},
/*00109*/     {217, -1, -1},
/*00110*/     {218, -1, -1},
/*00111*/     {0, -1, -1},
/*00112*/     {219, -1, -1},
/*00113*/     {220, -1, -1},
/*00114*/     {0, -1, -1},
/*00115*/     {0, -1, -1},
/*00116*/     {221, -1, -1},
/*00117*/     {222, -1, -1},
/*00118*/     {0, -1, -1},
/*00119*/     {0, -1, -1},
/*00120*/     {0, -1, -1},
/*00121*/     {0, -1, -1},
/*00122*/     {0, -1, -1},
/*00123*/     {0, -1, -1},
/*00124*/     {0, -1, -1},
/*00125*/     {0, -1, -1},
/*00126*/     {0, -1, -1},
/*00127*/     {0, -1, -1},
/*00128*/     {0, -1, -1},
/*00129*/     {0, -1, -1},
/*00130*/     {210, -1, -1},
/*00131*/     {0, -1, -1},
/*00132*/     {0, -1, -1},
/*00133*/     {0, -1, -1},
/*00134*/     {0, -1, -1},
/*00135*/     {0, -1, -1},
/*00136*/     {208, -1, -1},
/*00137*/     {205, -1, -1},
/*00138*/     {212, -1, -1},
/*00139*/     {209, -1, -1},
/*00140*/     {0, -1, -1},
/*00141*/     {0, -1, -1},
/*00142*/     {0, -1, -1},
/*00143*/     {0, -1, -1},
/*00144*/     {0, -1, -1},
/*00145*/     {0, -1, -1},
/*00146*/     {0, -1, -1},
/*00147*/     {0, -1, -1},
/*00148*/     {0, -1, -1},
/*00149*/     {0, -1, -1},
/*00150*/     {0, -1, -1},
/*00151*/     {0, -1, -1},
/*00152*/     {168, 9, 4},
/*00153*/     {184, 9, 4},
/*00154*/     {200, 9, 4},
/*00155*/     {216, 9, 4},
/*00156*/     {232, 9, 4},
/*00157*/     {248, 9, 4},
/*00158*/     {264, 9, 4},
/*00159*/     {280, 9, 4},
/*00160*/     {296, 9, 4},
/*00161*/     {312, 9, 4},
/*00162*/     {328, 9, 4},
/*00163*/     {344, 9, 4},
/*00164*/     {360, 9, 4},
/*00165*/     {376, 9, 4},
/*00166*/     {392, 9, 4},
/*00167*/     {408, 9, 4},
/*00168*/     {193, -1, -1},
/*00169*/     {0, -1, -1},
/*00170*/     {0, -1, -1},
/*00171*/     {0, -1, -1},
/*00172*/     {0, -1, -1},
/*00173*/     {0, -1, -1},
/*00174*/     {0, -1, -1},
/*00175*/     {0, -1, -1},
/*00176*/     {0, -1, -1},
/*00177*/     {0, -1, -1},
/*00178*/     {0, -1, -1},
/*00179*/     {0, -1, -1},
/*00180*/     {0, -1, -1},
/*00181*/     {0, -1, -1},
/*00182*/     {0, -1, -1},
/*00183*/     {0, -1, -1},
/*00184*/     {195, -1, -1},
/*00185*/     {0, -1, -1},
/*00186*/     {0, -1, -1},
/*00187*/     {0, -1, -1},
/*00188*/     {0, -1, -1},
/*00189*/     {0, -1, -1},
/*00190*/     {0, -1, -1},
/*00191*/     {0, -1, -1},
/*00192*/     {0, -1, -1},
/*00193*/     {0, -1, -1},
/*00194*/     {0, -1, -1},
/*00195*/     {0, -1, -1},
/*00196*/     {0, -1, -1},
/*00197*/     {0, -1, -1},
/*00198*/     {0, -1, -1},
/*00199*/     {0, -1, -1},
/*00200*/     {197, -1, -1},
/*00201*/     {0, -1, -1},
/*00202*/     {0, -1, -1},
/*00203*/     {0, -1, -1},
/*00204*/     {0, -1, -1},
/*00205*/     {0, -1, -1},
/*00206*/     {0, -1, -1},
/*00207*/     {0, -1, -1},
/*00208*/     {0, -1, -1},
/*00209*/     {0, -1, -1},
/*00210*/     {0, -1, -1},
/*00211*/     {0, -1, -1},
/*00212*/     {0, -1, -1},
/*00213*/     {0, -1, -1},
/*00214*/     {0, -1, -1},
/*00215*/     {0, -1, -1},
/*00216*/     {195, -1, -1},
/*00217*/     {0, -1, -1},
/*00218*/     {0, -1, -1},
/*00219*/     {0, -1, -1},
/*00220*/     {0, -1, -1},
/*00221*/     {0, -1, -1},
/*00222*/     {0, -1, -1},
/*00223*/     {0, -1, -1},
/*00224*/     {0, -1, -1},
/*00225*/     {0, -1, -1},
/*00226*/     {0, -1, -1},
/*00227*/     {0, -1, -1},
/*00228*/     {0, -1, -1},
/*00229*/     {0, -1, -1},
/*00230*/     {0, -1, -1},
/*00231*/     {0, -1, -1},
/*00232*/     {199, -1, -1},
/*00233*/     {0, -1, -1},
/*00234*/     {0, -1, -1},
/*00235*/     {0, -1, -1},
/*00236*/     {0, -1, -1},
/*00237*/     {0, -1, -1},
/*00238*/     {0, -1, -1},
/*00239*/     {0, -1, -1},
/*00240*/     {0, -1, -1},
/*00241*/     {0, -1, -1},
/*00242*/     {0, -1, -1},
/*00243*/     {0, -1, -1},
/*00244*/     {0, -1, -1},
/*00245*/     {0, -1, -1},
/*00246*/     {0, -1, -1},
/*00247*/     {0, -1, -1},
/*00248*/     {201, -1, -1},
/*00249*/     {0, -1, -1},
/*00250*/     {0, -1, -1},
/*00251*/     {0, -1, -1},
/*00252*/     {0, -1, -1},
/*00253*/     {0, -1, -1},
/*00254*/     {0, -1, -1},
/*00255*/     {0, -1, -1},
/*00256*/     {0, -1, -1},
/*00257*/     {0, -1, -1},
/*00258*/     {0, -1, -1},
/*00259*/     {0, -1, -1},
/*00260*/     {0, -1, -1},
/*00261*/     {0, -1, -1},
/*00262*/     {0, -1, -1},
/*00263*/     {0, -1, -1},
/*00264*/     {203, -1, -1},
/*00265*/     {0, -1, -1},
/*00266*/     {0, -1, -1},
/*00267*/     {0, -1, -1},
/*00268*/     {0, -1, -1},
/*00269*/     {0, -1, -1},
/*00270*/     {0, -1, -1},
/*00271*/     {0, -1, -1},
/*00272*/     {0, -1, -1},
/*00273*/     {0, -1, -1},
/*00274*/     {0, -1, -1},
/*00275*/     {0, -1, -1},
/*00276*/     {0, -1, -1},
/*00277*/     {0, -1, -1},
/*00278*/     {0, -1, -1},
/*00279*/     {0, -1, -1},
/*00280*/     {201, -1, -1},
/*00281*/     {0, -1, -1},
/*00282*/     {0, -1, -1},
/*00283*/     {0, -1, -1},
/*00284*/     {0, -1, -1},
/*00285*/     {0, -1, -1},
/*00286*/     {0, -1, -1},
/*00287*/     {0, -1, -1},
/*00288*/     {0, -1, -1},
/*00289*/     {0, -1, -1},
/*00290*/     {0, -1, -1},
/*00291*/     {0, -1, -1},
/*00292*/     {0, -1, -1},
/*00293*/     {0, -1, -1},
/*00294*/     {0, -1, -1},
/*00295*/     {0, -1, -1},
/*00296*/     {194, -1, -1},
/*00297*/     {0, -1, -1},
/*00298*/     {0, -1, -1},
/*00299*/     {0, -1, -1},
/*00300*/     {0, -1, -1},
/*00301*/     {0, -1, -1},
/*00302*/     {0, -1, -1},
/*00303*/     {0, -1, -1},
/*00304*/     {0, -1, -1},
/*00305*/     {0, -1, -1},
/*00306*/     {0, -1, -1},
/*00307*/     {0, -1, -1},
/*00308*/     {0, -1, -1},
/*00309*/     {0, -1, -1},
/*00310*/     {0, -1, -1},
/*00311*/     {0, -1, -1},
/*00312*/     {196, -1, -1},
/*00313*/     {0, -1, -1},
/*00314*/     {0, -1, -1},
/*00315*/     {0, -1, -1},
/*00316*/     {0, -1, -1},
/*00317*/     {0, -1, -1},
/*00318*/     {0, -1, -1},
/*00319*/     {0, -1, -1},
/*00320*/     {0, -1, -1},
/*00321*/     {0, -1, -1},
/*00322*/     {0, -1, -1},
/*00323*/     {0, -1, -1},
/*00324*/     {0, -1, -1},
/*00325*/     {0, -1, -1},
/*00326*/     {0, -1, -1},
/*00327*/     {0, -1, -1},
/*00328*/     {198, -1, -1},
/*00329*/     {0, -1, -1},
/*00330*/     {0, -1, -1},
/*00331*/     {0, -1, -1},
/*00332*/     {0, -1, -1},
/*00333*/     {0, -1, -1},
/*00334*/     {0, -1, -1},
/*00335*/     {0, -1, -1},
/*00336*/     {0, -1, -1},
/*00337*/     {0, -1, -1},
/*00338*/     {0, -1, -1},
/*00339*/     {0, -1, -1},
/*00340*/     {0, -1, -1},
/*00341*/     {0, -1, -1},
/*00342*/     {0, -1, -1},
/*00343*/     {0, -1, -1},
/*00344*/     {196, -1, -1},
/*00345*/     {0, -1, -1},
/*00346*/     {0, -1, -1},
/*00347*/     {0, -1, -1},
/*00348*/     {0, -1, -1},
/*00349*/     {0, -1, -1},
/*00350*/     {0, -1, -1},
/*00351*/     {0, -1, -1},
/*00352*/     {0, -1, -1},
/*00353*/     {0, -1, -1},
/*00354*/     {0, -1, -1},
/*00355*/     {0, -1, -1},
/*00356*/     {0, -1, -1},
/*00357*/     {0, -1, -1},
/*00358*/     {0, -1, -1},
/*00359*/     {0, -1, -1},
/*00360*/     {200, -1, -1},
/*00361*/     {0, -1, -1},
/*00362*/     {0, -1, -1},
/*00363*/     {0, -1, -1},
/*00364*/     {0, -1, -1},
/*00365*/     {0, -1, -1},
/*00366*/     {0, -1, -1},
/*00367*/     {0, -1, -1},
/*00368*/     {0, -1, -1},
/*00369*/     {0, -1, -1},
/*00370*/     {0, -1, -1},
/*00371*/     {0, -1, -1},
/*00372*/     {0, -1, -1},
/*00373*/     {0, -1, -1},
/*00374*/     {0, -1, -1},
/*00375*/     {0, -1, -1},
/*00376*/     {202, -1, -1},
/*00377*/     {0, -1, -1},
/*00378*/     {0, -1, -1},
/*00379*/     {0, -1, -1},
/*00380*/     {0, -1, -1},
/*00381*/     {0, -1, -1},
/*00382*/     {0, -1, -1},
/*00383*/     {0, -1, -1},
/*00384*/     {0, -1, -1},
/*00385*/     {0, -1, -1},
/*00386*/     {0, -1, -1},
/*00387*/     {0, -1, -1},
/*00388*/     {0, -1, -1},
/*00389*/     {0, -1, -1},
/*00390*/     {0, -1, -1},
/*00391*/     {0, -1, -1},
/*00392*/     {204, -1, -1},
/*00393*/     {0, -1, -1},
/*00394*/     {0, -1, -1},
/*00395*/     {0, -1, -1},
/*00396*/     {0, -1, -1},
/*00397*/     {0, -1, -1},
/*00398*/     {0, -1, -1},
/*00399*/     {0, -1, -1},
/*00400*/     {0, -1, -1},
/*00401*/     {0, -1, -1},
/*00402*/     {0, -1, -1},
/*00403*/     {0, -1, -1},
/*00404*/     {0, -1, -1},
/*00405*/     {0, -1, -1},
/*00406*/     {0, -1, -1},
/*00407*/     {0, -1, -1},
/*00408*/     {202, -1, -1},
/*00409*/     {0, -1, -1},
/*00410*/     {0, -1, -1},
/*00411*/     {0, -1, -1},
/*00412*/     {0, -1, -1},
/*00413*/     {0, -1, -1},
/*00414*/     {0, -1, -1},
/*00415*/     {0, -1, -1},
/*00416*/     {0, -1, -1},
/*00417*/     {0, -1, -1},
/*00418*/     {0, -1, -1},
/*00419*/     {0, -1, -1},
/*00420*/     {0, -1, -1},
/*00421*/     {0, -1, -1},
/*00422*/     {0, -1, -1},
/*00423*/     {0, -1, -1},
/*00424*/     {432, 27, 4},
/*00425*/     {0, -1, -1},
/*00426*/     {0, -1, -1},
/*00427*/     {0, -1, -1},
/*00428*/     {1051, -1, -1},
/*00429*/     {1052, -1, -1},
/*00430*/     {1053, -1, -1},
/*00431*/     {1054, -1, -1},
/*00432*/     {448, 31, 2},
/*00433*/     {452, 31, 2},
/*00434*/     {456, 31, 2},
/*00435*/     {460, 31, 2},
/*00436*/     {1106, -1, -1},
/*00437*/     {1107, -1, -1},
/*00438*/     {1108, -1, -1},
/*00439*/     {1109, -1, -1},
/*00440*/     {464, 31, 2},
/*00441*/     {0, -1, -1},
/*00442*/     {468, 31, 2},
/*00443*/     {0, -1, -1},
/*00444*/     {472, 31, 2},
/*00445*/     {0, -1, -1},
/*00446*/     {0, -1, -1},
/*00447*/     {0, -1, -1},
/*00448*/     {1078, -1, -1},
/*00449*/     {1055, -1, -1},
/*00450*/     {1056, -1, -1},
/*00451*/     {1059, -1, -1},
/*00452*/     {1079, -1, -1},
/*00453*/     {0, -1, -1},
/*00454*/     {0, -1, -1},
/*00455*/     {1060, -1, -1},
/*00456*/     {0, -1, -1},
/*00457*/     {1064, -1, -1},
/*00458*/     {1057, -1, -1},
/*00459*/     {0, -1, -1},
/*00460*/     {0, -1, -1},
/*00461*/     {1065, -1, -1},
/*00462*/     {1058, -1, -1},
/*00463*/     {1061, -1, -1},
/*00464*/     {0, -1, -1},
/*00465*/     {0, -1, -1},
/*00466*/     {1069, -1, -1},
/*00467*/     {0, -1, -1},
/*00468*/     {1063, -1, -1},
/*00469*/     {0, -1, -1},
/*00470*/     {0, -1, -1},
/*00471*/     {0, -1, -1},
/*00472*/     {1062, -1, -1},
/*00473*/     {0, -1, -1},
/*00474*/     {0, -1, -1},
/*00475*/     {0, -1, -1},
/*00476*/     {478, 27, 6},
/*00477*/     {586, 34, 3},
/*00478*/     {1552, -1, -1},
/*00479*/     {1553, -1, -1},
/*00480*/     {0, -1, -1},
/*00481*/     {0, -1, -1},
/*00482*/     {542, 34, 2},
/*00483*/     {546, 34, 2},
/*00484*/     {0, -1, -1},
/*00485*/     {0, -1, -1},
/*00486*/     {550, 34, 2},
/*00487*/     {0, -1, -1},
/*00488*/     {0, -1, -1},
/*00489*/     {0, -1, -1},
/*00490*/     {0, -1, -1},
/*00491*/     {0, -1, -1},
/*00492*/     {0, -1, -1},
/*00493*/     {0, -1, -1},
/*00494*/     {1488, -1, -1},
/*00495*/     {1489, -1, -1},
/*00496*/     {1490, -1, -1},
/*00497*/     {0, -1, -1},
/*00498*/     {554, 34, 2},
/*00499*/     {558, 34, 2},
/*00500*/     {562, 34, 2},
/*00501*/     {566, 34, 2},
/*00502*/     {570, 34, 2},
/*00503*/     {574, 34, 2},
/*00504*/     {578, 34, 2},
/*00505*/     {582, 34, 2},
/*00506*/     {1539, -1, -1},
/*00507*/     {0, -1, -1},
/*00508*/     {0, -1, -1},
/*00509*/     {0, -1, -1},
/*00510*/     {0, -1, -1},
/*00511*/     {0, -1, -1},
/*00512*/     {0, -1, -1},
/*00513*/     {0, -1, -1},
/*00514*/     {0, -1, -1},
/*00515*/     {0, -1, -1},
/*00516*/     {0, -1, -1},
/*00517*/     {0, -1, -1},
/*00518*/     {1496, -1, -1},
/*00519*/     {0, -1, -1},
/*00520*/     {0, -1, -1},
/*00521*/     {0, -1, -1},
/*00522*/     {1500, -1, -1},
/*00523*/     {1501, -1, -1},
/*00524*/     {1502, -1, -1},
/*00525*/     {1503, -1, -1},
/*00526*/     {0, -1, -1},
/*00527*/     {0, -1, -1},
/*00528*/     {0, -1, -1},
/*00529*/     {0, -1, -1},
/*00530*/     {1497, -1, -1},
/*00531*/     {1498, -1, -1},
/*00532*/     {1499, -1, -1},
/*00533*/     {0, -1, -1},
/*00534*/     {0, -1, -1},
/*00535*/     {1491, -1, -1},
/*00536*/     {1492, -1, -1},
/*00537*/     {1493, -1, -1},
/*00538*/     {1494, -1, -1},
/*00539*/     {1495, -1, -1},
/*00540*/     {0, -1, -1},
/*00541*/     {0, -1, -1},
/*00542*/     {1540, -1, -1},
/*00543*/     {1541, -1, -1},
/*00544*/     {1542, -1, -1},
/*00545*/     {1543, -1, -1},
/*00546*/     {1544, -1, -1},
/*00547*/     {1545, -1, -1},
/*00548*/     {1546, -1, -1},
/*00549*/     {1547, -1, -1},
/*00550*/     {1548, -1, -1},
/*00551*/     {1549, -1, -1},
/*00552*/     {1550, -1, -1},
/*00553*/     {1551, -1, -1},
/*00554*/     {1424, -1, -1},
/*00555*/     {1425, -1, -1},
/*00556*/     {1426, -1, -1},
/*00557*/     {1427, -1, -1},
/*00558*/     {1428, -1, -1},
/*00559*/     {1429, -1, -1},
/*00560*/     {1430, -1, -1},
/*00561*/     {1431, -1, -1},
/*00562*/     {1432, -1, -1},
/*00563*/     {1433, -1, -1},
/*00564*/     {1434, -1, -1},
/*00565*/     {1435, -1, -1},
/*00566*/     {1436, -1, -1},
/*00567*/     {1437, -1, -1},
/*00568*/     {1438, -1, -1},
/*00569*/     {1439, -1, -1},
/*00570*/     {1507, -1, -1},
/*00571*/     {1508, -1, -1},
/*00572*/     {1509, -1, -1},
/*00573*/     {1510, -1, -1},
/*00574*/     {1511, -1, -1},
/*00575*/     {1512, -1, -1},
/*00576*/     {1513, -1, -1},
/*00577*/     {1514, -1, -1},
/*00578*/     {1515, -1, -1},
/*00579*/     {1516, -1, -1},
/*00580*/     {1517, -1, -1},
/*00581*/     {1518, -1, -1},
/*00582*/     {1519, -1, -1},
/*00583*/     {1520, -1, -1},
/*00584*/     {1521, -1, -1},
/*00585*/     {1522, -1, -1},
/*00586*/     {1408, -1, -1},
/*00587*/     {1409, -1, -1},
/*00588*/     {1410, -1, -1},
/*00589*/     {1411, -1, -1},
/*00590*/     {1416, -1, -1},
/*00591*/     {1417, -1, -1},
/*00592*/     {1418, -1, -1},
/*00593*/     {1419, -1, -1},
/*00594*/     {1320, -1, -1},
/*00595*/     {0, -1, -1},
/*00596*/     {1312, -1, -1},
/*00597*/     {0, -1, -1},
/*00598*/     {1313, -1, -1},
/*00599*/     {1314, -1, -1},
/*00600*/     {0, -1, -1},
/*00601*/     {0, -1, -1},
/*00602*/     {1315, -1, -1},
/*00603*/     {1316, -1, -1},
/*00604*/     {0, -1, -1},
/*00605*/     {0, -1, -1},
/*00606*/     {1317, -1, -1},
/*00607*/     {1318, -1, -1},
/*00608*/     {0, -1, -1},
/*00609*/     {0, -1, -1},
/*00610*/     {1319, -1, -1},
/*00611*/     {0, -1, -1},
/*00612*/     {0, -1, -1},
/*00613*/     {0, -1, -1},
/*00614*/     {0, -1, -1},
/*00615*/     {0, -1, -1},
/*00616*/     {0, -1, -1},
/*00617*/     {0, -1, -1},
/*00618*/     {0, -1, -1},
/*00619*/     {0, -1, -1},
/*00620*/     {0, -1, -1},
/*00621*/     {0, -1, -1},
/*00622*/     {0, -1, -1},
/*00623*/     {0, -1, -1},
/*00624*/     {0, -1, -1},
/*00625*/     {0, -1, -1},
/*00626*/     {658, 33, 3},
/*00627*/     {762, 33, 3},
/*00628*/     {0, -1, -1},
/*00629*/     {0, -1, -1},
/*00630*/     {0, -1, -1},
/*00631*/     {0, -1, -1},
/*00632*/     {0, -1, -1},
/*00633*/     {0, -1, -1},
/*00634*/     {0, -1, -1},
/*00635*/     {0, -1, -1},
/*00636*/     {0, -1, -1},
/*00637*/     {0, -1, -1},
/*00638*/     {0, -1, -1},
/*00639*/     {0, -1, -1},
/*00640*/     {0, -1, -1},
/*00641*/     {0, -1, -1},
/*00642*/     {0, -1, -1},
/*00643*/     {0, -1, -1},
/*00644*/     {0, -1, -1},
/*00645*/     {0, -1, -1},
/*00646*/     {0, -1, -1},
/*00647*/     {0, -1, -1},
/*00648*/     {0, -1, -1},
/*00649*/     {0, -1, -1},
/*00650*/     {0, -1, -1},
/*00651*/     {0, -1, -1},
/*00652*/     {0, -1, -1},
/*00653*/     {0, -1, -1},
/*00654*/     {0, -1, -1},
/*00655*/     {0, -1, -1},
/*00656*/     {0, -1, -1},
/*00657*/     {0, -1, -1},
/*00658*/     {666, 6, 3},
/*00659*/     {678, 6, 3},
/*00660*/     {690, 6, 3},
/*00661*/     {702, 6, 3},
/*00662*/     {714, 6, 3},
/*00663*/     {726, 6, 3},
/*00664*/     {738, 6, 3},
/*00665*/     {750, 6, 3},
/*00666*/     {674, 12, 1},
/*00667*/     {676, 12, 1},
/*00668*/     {0, -1, -1},
/*00669*/     {0, -1, -1},
/*00670*/     {0, -1, -1},
/*00671*/     {0, -1, -1},
/*00672*/     {0, -1, -1},
/*00673*/     {0, -1, -1},
/*00674*/     {1232, -1, -1},
/*00675*/     {1233, -1, -1},
/*00676*/     {1248, -1, -1},
/*00677*/     {1249, -1, -1},
/*00678*/     {686, 12, 1},
/*00679*/     {688, 12, 1},
/*00680*/     {0, -1, -1},
/*00681*/     {0, -1, -1},
/*00682*/     {0, -1, -1},
/*00683*/     {0, -1, -1},
/*00684*/     {0, -1, -1},
/*00685*/     {0, -1, -1},
/*00686*/     {1234, -1, -1},
/*00687*/     {1235, -1, -1},
/*00688*/     {1250, -1, -1},
/*00689*/     {1251, -1, -1},
/*00690*/     {698, 12, 1},
/*00691*/     {700, 12, 1},
/*00692*/     {0, -1, -1},
/*00693*/     {0, -1, -1},
/*00694*/     {0, -1, -1},
/*00695*/     {0, -1, -1},
/*00696*/     {0, -1, -1},
/*00697*/     {0, -1, -1},
/*00698*/     {1236, -1, -1},
/*00699*/     {1237, -1, -1},
/*00700*/     {1252, -1, -1},
/*00701*/     {1253, -1, -1},
/*00702*/     {710, 12, 1},
/*00703*/     {712, 12, 1},
/*00704*/     {0, -1, -1},
/*00705*/     {0, -1, -1},
/*00706*/     {0, -1, -1},
/*00707*/     {0, -1, -1},
/*00708*/     {0, -1, -1},
/*00709*/     {0, -1, -1},
/*00710*/     {1238, -1, -1},
/*00711*/     {1239, -1, -1},
/*00712*/     {1254, -1, -1},
/*00713*/     {1255, -1, -1},
/*00714*/     {722, 12, 1},
/*00715*/     {724, 12, 1},
/*00716*/     {0, -1, -1},
/*00717*/     {0, -1, -1},
/*00718*/     {0, -1, -1},
/*00719*/     {0, -1, -1},
/*00720*/     {0, -1, -1},
/*00721*/     {0, -1, -1},
/*00722*/     {1240, -1, -1},
/*00723*/     {1241, -1, -1},
/*00724*/     {1256, -1, -1},
/*00725*/     {1257, -1, -1},
/*00726*/     {734, 12, 1},
/*00727*/     {736, 12, 1},
/*00728*/     {0, -1, -1},
/*00729*/     {0, -1, -1},
/*00730*/     {0, -1, -1},
/*00731*/     {0, -1, -1},
/*00732*/     {0, -1, -1},
/*00733*/     {0, -1, -1},
/*00734*/     {1242, -1, -1},
/*00735*/     {1243, -1, -1},
/*00736*/     {1258, -1, -1},
/*00737*/     {1259, -1, -1},
/*00738*/     {746, 12, 1},
/*00739*/     {748, 12, 1},
/*00740*/     {0, -1, -1},
/*00741*/     {0, -1, -1},
/*00742*/     {0, -1, -1},
/*00743*/     {0, -1, -1},
/*00744*/     {0, -1, -1},
/*00745*/     {0, -1, -1},
/*00746*/     {1244, -1, -1},
/*00747*/     {1245, -1, -1},
/*00748*/     {1260, -1, -1},
/*00749*/     {1261, -1, -1},
/*00750*/     {758, 12, 1},
/*00751*/     {760, 12, 1},
/*00752*/     {0, -1, -1},
/*00753*/     {0, -1, -1},
/*00754*/     {0, -1, -1},
/*00755*/     {0, -1, -1},
/*00756*/     {0, -1, -1},
/*00757*/     {0, -1, -1},
/*00758*/     {1246, -1, -1},
/*00759*/     {1247, -1, -1},
/*00760*/     {1262, -1, -1},
/*00761*/     {1263, -1, -1},
/*00762*/     {770, 6, 3},
/*00763*/     {780, 6, 3},
/*00764*/     {790, 6, 3},
/*00765*/     {800, 6, 3},
/*00766*/     {810, 6, 3},
/*00767*/     {820, 6, 3},
/*00768*/     {830, 6, 3},
/*00769*/     {840, 6, 3},
/*00770*/     {0, -1, -1},
/*00771*/     {0, -1, -1},
/*00772*/     {0, -1, -1},
/*00773*/     {0, -1, -1},
/*00774*/     {778, 12, 1},
/*00775*/     {0, -1, -1},
/*00776*/     {0, -1, -1},
/*00777*/     {0, -1, -1},
/*00778*/     {1264, -1, -1},
/*00779*/     {1265, -1, -1},
/*00780*/     {0, -1, -1},
/*00781*/     {0, -1, -1},
/*00782*/     {0, -1, -1},
/*00783*/     {0, -1, -1},
/*00784*/     {788, 12, 1},
/*00785*/     {0, -1, -1},
/*00786*/     {0, -1, -1},
/*00787*/     {0, -1, -1},
/*00788*/     {1266, -1, -1},
/*00789*/     {1267, -1, -1},
/*00790*/     {0, -1, -1},
/*00791*/     {0, -1, -1},
/*00792*/     {0, -1, -1},
/*00793*/     {0, -1, -1},
/*00794*/     {798, 12, 1},
/*00795*/     {0, -1, -1},
/*00796*/     {0, -1, -1},
/*00797*/     {0, -1, -1},
/*00798*/     {1268, -1, -1},
/*00799*/     {1269, -1, -1},
/*00800*/     {0, -1, -1},
/*00801*/     {0, -1, -1},
/*00802*/     {0, -1, -1},
/*00803*/     {0, -1, -1},
/*00804*/     {808, 12, 1},
/*00805*/     {0, -1, -1},
/*00806*/     {0, -1, -1},
/*00807*/     {0, -1, -1},
/*00808*/     {1270, -1, -1},
/*00809*/     {1271, -1, -1},
/*00810*/     {0, -1, -1},
/*00811*/     {0, -1, -1},
/*00812*/     {0, -1, -1},
/*00813*/     {0, -1, -1},
/*00814*/     {818, 12, 1},
/*00815*/     {0, -1, -1},
/*00816*/     {0, -1, -1},
/*00817*/     {0, -1, -1},
/*00818*/     {1272, -1, -1},
/*00819*/     {1273, -1, -1},
/*00820*/     {0, -1, -1},
/*00821*/     {0, -1, -1},
/*00822*/     {0, -1, -1},
/*00823*/     {0, -1, -1},
/*00824*/     {828, 12, 1},
/*00825*/     {0, -1, -1},
/*00826*/     {0, -1, -1},
/*00827*/     {0, -1, -1},
/*00828*/     {1274, -1, -1},
/*00829*/     {1275, -1, -1},
/*00830*/     {0, -1, -1},
/*00831*/     {0, -1, -1},
/*00832*/     {0, -1, -1},
/*00833*/     {0, -1, -1},
/*00834*/     {838, 12, 1},
/*00835*/     {0, -1, -1},
/*00836*/     {0, -1, -1},
/*00837*/     {0, -1, -1},
/*00838*/     {1276, -1, -1},
/*00839*/     {1277, -1, -1},
/*00840*/     {0, -1, -1},
/*00841*/     {0, -1, -1},
/*00842*/     {0, -1, -1},
/*00843*/     {0, -1, -1},
/*00844*/     {848, 12, 1},
/*00845*/     {0, -1, -1},
/*00846*/     {0, -1, -1},
/*00847*/     {0, -1, -1},
/*00848*/     {1278, -1, -1},
/*00849*/     {1279, -1, -1},
/*00850*/     {1554, -1, -1},
/*00851*/     {1555, -1, -1},
/*00852*/     {0, -1, -1},
/*00853*/     {0, -1, -1},
/*00854*/     {0, -1, -1},
/*00855*/     {0, -1, -1},
/*00856*/     {0, -1, -1},
/*00857*/     {0, -1, -1},
/*00858*/     {0, -1, -1},
/*00859*/     {0, -1, -1},
/*00860*/     {0, -1, -1},
/*00861*/     {0, -1, -1},
/*00862*/     {0, -1, -1},
/*00863*/     {0, -1, -1},
/*00864*/     {0, -1, -1},
/*00865*/     {0, -1, -1},
/*00866*/     {0, -1, -1},
/*00867*/     {0, -1, -1},
/*00868*/     {0, -1, -1},
/*00869*/     {0, -1, -1},
/*00870*/     {0, -1, -1},
/*00871*/     {0, -1, -1},
/*00872*/     {0, -1, -1},
/*00873*/     {0, -1, -1},
/*00874*/     {0, -1, -1},
/*00875*/     {0, -1, -1},
/*00876*/     {0, -1, -1},
/*00877*/     {0, -1, -1},
/*00878*/     {0, -1, -1},
/*00879*/     {0, -1, -1},
/*00880*/     {0, -1, -1},
/*00881*/     {0, -1, -1},
/*00882*/     {0, -1, -1},
/*00883*/     {0, -1, -1},
/*00884*/     {0, -1, -1},
/*00885*/     {0, -1, -1},
/*00886*/     {0, -1, -1},
/*00887*/     {0, -1, -1},
/*00888*/     {0, -1, -1},
/*00889*/     {0, -1, -1},
/*00890*/     {0, -1, -1},
/*00891*/     {0, -1, -1},
/*00892*/     {0, -1, -1},
/*00893*/     {0, -1, -1},
/*00894*/     {0, -1, -1},
/*00895*/     {0, -1, -1},
/*00896*/     {0, -1, -1},
/*00897*/     {0, -1, -1},
/*00898*/     {0, -1, -1},
/*00899*/     {0, -1, -1},
/*00900*/     {0, -1, -1},
/*00901*/     {0, -1, -1},
/*00902*/     {0, -1, -1},
/*00903*/     {0, -1, -1},
/*00904*/     {0, -1, -1},
/*00905*/     {0, -1, -1},
/*00906*/     {0, -1, -1},
/*00907*/     {0, -1, -1},
/*00908*/     {0, -1, -1},
/*00909*/     {0, -1, -1},
/*00910*/     {0, -1, -1},
/*00911*/     {0, -1, -1},
/*00912*/     {0, -1, -1},
/*00913*/     {0, -1, -1},
/*00914*/     {0, -1, -1},
/*00915*/     {0, -1, -1},
/*00916*/     {0, -1, -1},
/*00917*/     {0, -1, -1},
/*00918*/     {0, -1, -1},
/*00919*/     {0, -1, -1},
/*00920*/     {0, -1, -1},
/*00921*/     {0, -1, -1},
/*00922*/     {0, -1, -1},
/*00923*/     {0, -1, -1},
/*00924*/     {0, -1, -1},
/*00925*/     {0, -1, -1},
/*00926*/     {0, -1, -1},
/*00927*/     {0, -1, -1},
/*00928*/     {0, -1, -1},
/*00929*/     {0, -1, -1},
/*00930*/     {0, -1, -1},
/*00931*/     {0, -1, -1},
/*00932*/     {0, -1, -1},
/*00933*/     {0, -1, -1},
/*00934*/     {0, -1, -1},
/*00935*/     {0, -1, -1},
/*00936*/     {0, -1, -1},
/*00937*/     {0, -1, -1},
/*00938*/     {0, -1, -1},
/*00939*/     {0, -1, -1},
/*00940*/     {0, -1, -1},
/*00941*/     {0, -1, -1},
/*00942*/     {0, -1, -1},
/*00943*/     {0, -1, -1},
/*00944*/     {0, -1, -1},
/*00945*/     {0, -1, -1},
/*00946*/     {0, -1, -1},
/*00947*/     {0, -1, -1},
/*00948*/     {0, -1, -1},
/*00949*/     {0, -1, -1},
/*00950*/     {0, -1, -1},
/*00951*/     {0, -1, -1},
/*00952*/     {0, -1, -1},
/*00953*/     {0, -1, -1},
/*00954*/     {0, -1, -1},
/*00955*/     {0, -1, -1},
/*00956*/     {0, -1, -1},
/*00957*/     {0, -1, -1},
/*00958*/     {0, -1, -1},
/*00959*/     {0, -1, -1},
/*00960*/     {0, -1, -1},
/*00961*/     {0, -1, -1},
/*00962*/     {0, -1, -1},
/*00963*/     {0, -1, -1},
/*00964*/     {0, -1, -1},
/*00965*/     {0, -1, -1},
/*00966*/     {0, -1, -1},
/*00967*/     {0, -1, -1},
/*00968*/     {0, -1, -1},
/*00969*/     {0, -1, -1},
/*00970*/     {0, -1, -1},
/*00971*/     {0, -1, -1},
/*00972*/     {0, -1, -1},
/*00973*/     {0, -1, -1},
/*00974*/     {0, -1, -1},
/*00975*/     {0, -1, -1},
/*00976*/     {0, -1, -1},
/*00977*/     {0, -1, -1},
/*00978*/     {0, -1, -1},
/*00979*/     {0, -1, -1},
/*00980*/     {0, -1, -1},
/*00981*/     {0, -1, -1},
/*00982*/     {0, -1, -1},
/*00983*/     {0, -1, -1},
/*00984*/     {0, -1, -1},
/*00985*/     {0, -1, -1},
/*00986*/     {0, -1, -1},
/*00987*/     {0, -1, -1},
/*00988*/     {0, -1, -1},
/*00989*/     {0, -1, -1},
/*00990*/     {0, -1, -1},
/*00991*/     {0, -1, -1},
/*00992*/     {0, -1, -1},
/*00993*/     {0, -1, -1},
/*00994*/     {0, -1, -1},
/*00995*/     {0, -1, -1},
/*00996*/     {0, -1, -1},
/*00997*/     {0, -1, -1},
/*00998*/     {0, -1, -1},
/*00999*/     {0, -1, -1},
/*01000*/     {0, -1, -1},
/*01001*/     {0, -1, -1},
/*01002*/     {0, -1, -1},
/*01003*/     {0, -1, -1},
/*01004*/     {0, -1, -1},
/*01005*/     {0, -1, -1},
/*01006*/     {0, -1, -1},
/*01007*/     {0, -1, -1},
/*01008*/     {0, -1, -1},
/*01009*/     {0, -1, -1},
/*01010*/     {0, -1, -1},
/*01011*/     {0, -1, -1},
/*01012*/     {0, -1, -1},
/*01013*/     {0, -1, -1},
/*01014*/     {0, -1, -1},
/*01015*/     {0, -1, -1},
/*01016*/     {0, -1, -1},
/*01017*/     {0, -1, -1},
/*01018*/     {0, -1, -1},
/*01019*/     {0, -1, -1},
/*01020*/     {0, -1, -1},
/*01021*/     {0, -1, -1},
/*01022*/     {0, -1, -1},
/*01023*/     {0, -1, -1},
/*01024*/     {0, -1, -1},
/*01025*/     {0, -1, -1},
/*01026*/     {0, -1, -1},
/*01027*/     {0, -1, -1},
/*01028*/     {0, -1, -1},
/*01029*/     {0, -1, -1},
/*01030*/     {0, -1, -1},
/*01031*/     {0, -1, -1},
/*01032*/     {0, -1, -1},
/*01033*/     {0, -1, -1},
/*01034*/     {0, -1, -1},
/*01035*/     {0, -1, -1},
/*01036*/     {0, -1, -1},
/*01037*/     {0, -1, -1},
/*01038*/     {0, -1, -1},
/*01039*/     {0, -1, -1},
/*01040*/     {0, -1, -1},
/*01041*/     {0, -1, -1},
/*01042*/     {0, -1, -1},
/*01043*/     {0, -1, -1},
/*01044*/     {0, -1, -1},
/*01045*/     {0, -1, -1},
/*01046*/     {0, -1, -1},
/*01047*/     {0, -1, -1},
/*01048*/     {0, -1, -1},
/*01049*/     {0, -1, -1},
/*01050*/     {0, -1, -1},
/*01051*/     {0, -1, -1},
/*01052*/     {0, -1, -1},
/*01053*/     {0, -1, -1},
/*01054*/     {0, -1, -1},
/*01055*/     {0, -1, -1},
/*01056*/     {0, -1, -1},
/*01057*/     {0, -1, -1},
/*01058*/     {0, -1, -1},
/*01059*/     {0, -1, -1},
/*01060*/     {0, -1, -1},
/*01061*/     {0, -1, -1},
/*01062*/     {0, -1, -1},
/*01063*/     {0, -1, -1},
/*01064*/     {0, -1, -1},
/*01065*/     {0, -1, -1},
/*01066*/     {0, -1, -1},
/*01067*/     {0, -1, -1},
/*01068*/     {0, -1, -1},
/*01069*/     {0, -1, -1},
/*01070*/     {0, -1, -1},
/*01071*/     {0, -1, -1},
/*01072*/     {0, -1, -1},
/*01073*/     {0, -1, -1},
/*01074*/     {0, -1, -1},
/*01075*/     {0, -1, -1},
/*01076*/     {0, -1, -1},
/*01077*/     {0, -1, -1},
/*01078*/     {0, -1, -1},
/*01079*/     {0, -1, -1},
/*01080*/     {0, -1, -1},
/*01081*/     {0, -1, -1},
/*01082*/     {0, -1, -1},
/*01083*/     {0, -1, -1},
/*01084*/     {0, -1, -1},
/*01085*/     {0, -1, -1},
/*01086*/     {0, -1, -1},
/*01087*/     {0, -1, -1},
/*01088*/     {0, -1, -1},
/*01089*/     {0, -1, -1},
/*01090*/     {0, -1, -1},
/*01091*/     {0, -1, -1},
/*01092*/     {0, -1, -1},
/*01093*/     {0, -1, -1},
/*01094*/     {0, -1, -1},
/*01095*/     {0, -1, -1},
/*01096*/     {0, -1, -1},
/*01097*/     {0, -1, -1},
/*01098*/     {0, -1, -1},
/*01099*/     {0, -1, -1},
/*01100*/     {0, -1, -1},
/*01101*/     {0, -1, -1},
/*01102*/     {0, -1, -1},
/*01103*/     {0, -1, -1},
/*01104*/     {0, -1, -1},
/*01105*/     {0, -1, -1},
/*01106*/     {0, -1, -1},
/*01107*/     {0, -1, -1},
/*01108*/     {0, -1, -1},
/*01109*/     {0, -1, -1},
/*01110*/     {0, -1, -1},
/*01111*/     {0, -1, -1},
/*01112*/     {0, -1, -1},
/*01113*/     {0, -1, -1},
/*01114*/     {0, -1, -1},
/*01115*/     {0, -1, -1},
/*01116*/     {0, -1, -1},
/*01117*/     {0, -1, -1},
/*01118*/     {0, -1, -1},
/*01119*/     {0, -1, -1},
/*01120*/     {0, -1, -1},
/*01121*/     {0, -1, -1},
/*01122*/     {0, -1, -1},
/*01123*/     {0, -1, -1},
/*01124*/     {0, -1, -1},
/*01125*/     {0, -1, -1},
/*01126*/     {0, -1, -1},
/*01127*/     {0, -1, -1},
/*01128*/     {0, -1, -1},
/*01129*/     {0, -1, -1},
/*01130*/     {0, -1, -1},
/*01131*/     {0, -1, -1},
/*01132*/     {0, -1, -1},
/*01133*/     {0, -1, -1},
/*01134*/     {0, -1, -1},
/*01135*/     {0, -1, -1},
/*01136*/     {0, -1, -1},
/*01137*/     {0, -1, -1},
/*01138*/     {0, -1, -1},
/*01139*/     {0, -1, -1},
/*01140*/     {0, -1, -1},
/*01141*/     {0, -1, -1},
/*01142*/     {0, -1, -1},
/*01143*/     {0, -1, -1},
/*01144*/     {0, -1, -1},
/*01145*/     {0, -1, -1},
/*01146*/     {0, -1, -1},
/*01147*/     {0, -1, -1},
/*01148*/     {0, -1, -1},
/*01149*/     {0, -1, -1},
/*01150*/     {0, -1, -1},
/*01151*/     {0, -1, -1},
/*01152*/     {0, -1, -1},
/*01153*/     {0, -1, -1},
/*01154*/     {0, -1, -1},
/*01155*/     {0, -1, -1},
/*01156*/     {0, -1, -1},
/*01157*/     {0, -1, -1},
/*01158*/     {0, -1, -1},
/*01159*/     {0, -1, -1},
/*01160*/     {0, -1, -1},
/*01161*/     {0, -1, -1},
/*01162*/     {0, -1, -1},
/*01163*/     {0, -1, -1},
/*01164*/     {0, -1, -1},
/*01165*/     {0, -1, -1},
/*01166*/     {0, -1, -1},
/*01167*/     {0, -1, -1},
/*01168*/     {0, -1, -1},
/*01169*/     {0, -1, -1},
/*01170*/     {0, -1, -1},
/*01171*/     {0, -1, -1},
/*01172*/     {0, -1, -1},
/*01173*/     {0, -1, -1},
/*01174*/     {0, -1, -1},
/*01175*/     {0, -1, -1},
/*01176*/     {0, -1, -1},
/*01177*/     {0, -1, -1},
/*01178*/     {0, -1, -1},
/*01179*/     {0, -1, -1},
/*01180*/     {0, -1, -1},
/*01181*/     {0, -1, -1},
/*01182*/     {0, -1, -1},
/*01183*/     {0, -1, -1},
/*01184*/     {0, -1, -1},
/*01185*/     {0, -1, -1},
/*01186*/     {0, -1, -1},
/*01187*/     {0, -1, -1},
/*01188*/     {0, -1, -1},
/*01189*/     {0, -1, -1},
/*01190*/     {0, -1, -1},
/*01191*/     {0, -1, -1},
/*01192*/     {0, -1, -1},
/*01193*/     {0, -1, -1},
/*01194*/     {0, -1, -1},
/*01195*/     {0, -1, -1},
/*01196*/     {0, -1, -1},
/*01197*/     {0, -1, -1},
/*01198*/     {0, -1, -1},
/*01199*/     {0, -1, -1},
/*01200*/     {0, -1, -1},
/*01201*/     {0, -1, -1},
/*01202*/     {0, -1, -1},
/*01203*/     {0, -1, -1},
/*01204*/     {0, -1, -1},
/*01205*/     {0, -1, -1},
/*01206*/     {0, -1, -1},
/*01207*/     {0, -1, -1},
/*01208*/     {0, -1, -1},
/*01209*/     {0, -1, -1},
/*01210*/     {0, -1, -1},
/*01211*/     {0, -1, -1},
/*01212*/     {0, -1, -1},
/*01213*/     {0, -1, -1},
/*01214*/     {0, -1, -1},
/*01215*/     {0, -1, -1},
/*01216*/     {0, -1, -1},
/*01217*/     {0, -1, -1},
/*01218*/     {0, -1, -1},
/*01219*/     {0, -1, -1},
/*01220*/     {0, -1, -1},
/*01221*/     {0, -1, -1},
/*01222*/     {0, -1, -1},
/*01223*/     {0, -1, -1},
/*01224*/     {0, -1, -1},
/*01225*/     {0, -1, -1},
/*01226*/     {0, -1, -1},
/*01227*/     {0, -1, -1},
/*01228*/     {0, -1, -1},
/*01229*/     {0, -1, -1},
/*01230*/     {0, -1, -1},
/*01231*/     {0, -1, -1},
/*01232*/     {0, -1, -1},
/*01233*/     {0, -1, -1},
/*01234*/     {0, -1, -1},
/*01235*/     {0, -1, -1},
/*01236*/     {0, -1, -1},
/*01237*/     {0, -1, -1},
/*01238*/     {0, -1, -1},
/*01239*/     {0, -1, -1},
/*01240*/     {0, -1, -1},
/*01241*/     {0, -1, -1},
/*01242*/     {0, -1, -1},
/*01243*/     {0, -1, -1},
/*01244*/     {0, -1, -1},
/*01245*/     {0, -1, -1},
/*01246*/     {0, -1, -1},
/*01247*/     {0, -1, -1},
/*01248*/     {0, -1, -1},
/*01249*/     {0, -1, -1},
/*01250*/     {0, -1, -1},
/*01251*/     {0, -1, -1},
/*01252*/     {0, -1, -1},
/*01253*/     {0, -1, -1},
/*01254*/     {0, -1, -1},
/*01255*/     {0, -1, -1},
/*01256*/     {0, -1, -1},
/*01257*/     {0, -1, -1},
/*01258*/     {0, -1, -1},
/*01259*/     {0, -1, -1},
/*01260*/     {0, -1, -1},
/*01261*/     {0, -1, -1},
/*01262*/     {0, -1, -1},
/*01263*/     {0, -1, -1},
/*01264*/     {0, -1, -1},
/*01265*/     {0, -1, -1},
/*01266*/     {0, -1, -1},
/*01267*/     {0, -1, -1},
/*01268*/     {0, -1, -1},
/*01269*/     {0, -1, -1},
/*01270*/     {0, -1, -1},
/*01271*/     {0, -1, -1},
/*01272*/     {0, -1, -1},
/*01273*/     {0, -1, -1},
/*01274*/     {0, -1, -1},
/*01275*/     {0, -1, -1},
/*01276*/     {0, -1, -1},
/*01277*/     {0, -1, -1},
/*01278*/     {0, -1, -1},
/*01279*/     {0, -1, -1},
/*01280*/     {0, -1, -1},
/*01281*/     {0, -1, -1},
/*01282*/     {0, -1, -1},
/*01283*/     {0, -1, -1},
/*01284*/     {0, -1, -1},
/*01285*/     {0, -1, -1},
/*01286*/     {0, -1, -1},
/*01287*/     {0, -1, -1},
/*01288*/     {0, -1, -1},
/*01289*/     {0, -1, -1},
/*01290*/     {0, -1, -1},
/*01291*/     {0, -1, -1},
/*01292*/     {0, -1, -1},
/*01293*/     {0, -1, -1},
/*01294*/     {0, -1, -1},
/*01295*/     {0, -1, -1},
/*01296*/     {0, -1, -1},
/*01297*/     {0, -1, -1},
/*01298*/     {0, -1, -1},
/*01299*/     {0, -1, -1},
/*01300*/     {0, -1, -1},
/*01301*/     {0, -1, -1},
/*01302*/     {0, -1, -1},
/*01303*/     {0, -1, -1},
/*01304*/     {0, -1, -1},
/*01305*/     {0, -1, -1},
/*01306*/     {0, -1, -1},
/*01307*/     {0, -1, -1},
/*01308*/     {0, -1, -1},
/*01309*/     {0, -1, -1},
/*01310*/     {0, -1, -1},
/*01311*/     {0, -1, -1},
/*01312*/     {0, -1, -1},
/*01313*/     {0, -1, -1},
/*01314*/     {0, -1, -1},
/*01315*/     {0, -1, -1},
/*01316*/     {0, -1, -1},
/*01317*/     {0, -1, -1},
/*01318*/     {0, -1, -1},
/*01319*/     {0, -1, -1},
/*01320*/     {0, -1, -1},
/*01321*/     {0, -1, -1},
/*01322*/     {0, -1, -1},
/*01323*/     {0, -1, -1},
/*01324*/     {0, -1, -1},
/*01325*/     {0, -1, -1},
/*01326*/     {0, -1, -1},
/*01327*/     {0, -1, -1},
/*01328*/     {0, -1, -1},
/*01329*/     {0, -1, -1},
/*01330*/     {0, -1, -1},
/*01331*/     {0, -1, -1},
/*01332*/     {0, -1, -1},
/*01333*/     {0, -1, -1},
/*01334*/     {0, -1, -1},
/*01335*/     {0, -1, -1},
/*01336*/     {0, -1, -1},
/*01337*/     {0, -1, -1},
/*01338*/     {0, -1, -1},
/*01339*/     {0, -1, -1},
/*01340*/     {0, -1, -1},
/*01341*/     {0, -1, -1},
/*01342*/     {0, -1, -1},
/*01343*/     {0, -1, -1},
/*01344*/     {0, -1, -1},
/*01345*/     {0, -1, -1},
/*01346*/     {0, -1, -1},
/*01347*/     {0, -1, -1},
/*01348*/     {0, -1, -1},
/*01349*/     {0, -1, -1},
/*01350*/     {0, -1, -1},
/*01351*/     {0, -1, -1},
/*01352*/     {0, -1, -1},
/*01353*/     {0, -1, -1},
/*01354*/     {0, -1, -1},
/*01355*/     {0, -1, -1},
/*01356*/     {0, -1, -1},
/*01357*/     {0, -1, -1},
/*01358*/     {0, -1, -1},
/*01359*/     {0, -1, -1},
/*01360*/     {0, -1, -1},
/*01361*/     {0, -1, -1},
/*01362*/     {1370, 27, 6},
/*01363*/     {1049, -1, -1},
/*01364*/     {0, -1, -1},
/*01365*/     {1050, -1, -1},
/*01366*/     {0, -1, -1},
/*01367*/     {0, -1, -1},
/*01368*/     {1073, -1, -1},
/*01369*/     {0, -1, -1},
/*01370*/     {1089, -1, -1},
/*01371*/     {1090, -1, -1},
/*01372*/     {1091, -1, -1},
/*01373*/     {1092, -1, -1},
/*01374*/     {1093, -1, -1},
/*01375*/     {1094, -1, -1},
/*01376*/     {1095, -1, -1},
/*01377*/     {0, -1, -1},
/*01378*/     {0, -1, -1},
/*01379*/     {1110, -1, -1},
/*01380*/     {1111, -1, -1},
/*01381*/     {1112, -1, -1},
/*01382*/     {1113, -1, -1},
/*01383*/     {1114, -1, -1},
/*01384*/     {1096, -1, -1},
/*01385*/     {1097, -1, -1},
/*01386*/     {1098, -1, -1},
/*01387*/     {1099, -1, -1},
/*01388*/     {1100, -1, -1},
/*01389*/     {1101, -1, -1},
/*01390*/     {1102, -1, -1},
/*01391*/     {1104, -1, -1},
/*01392*/     {1103, -1, -1},
/*01393*/     {1105, -1, -1},
/*01394*/     {1082, -1, -1},
/*01395*/     {1083, -1, -1},
/*01396*/     {1115, -1, -1},
/*01397*/     {1116, -1, -1},
/*01398*/     {0, -1, -1},
/*01399*/     {0, -1, -1},
/*01400*/     {1117, -1, -1},
/*01401*/     {1118, -1, -1},
/*01402*/     {0, -1, -1},
/*01403*/     {1077, -1, -1},
/*01404*/     {1070, -1, -1},
/*01405*/     {0, -1, -1},
/*01406*/     {1072, -1, -1},
/*01407*/     {1076, -1, -1},
/*01408*/     {0, -1, -1},
/*01409*/     {0, -1, -1},
/*01410*/     {0, -1, -1},
/*01411*/     {1075, -1, -1},
/*01412*/     {1068, -1, -1},
/*01413*/     {0, -1, -1},
/*01414*/     {1071, -1, -1},
/*01415*/     {1074, -1, -1},
/*01416*/     {1087, -1, -1},
/*01417*/     {1088, -1, -1},
/*01418*/     {1066, -1, -1},
/*01419*/     {1084, -1, -1},
/*01420*/     {1085, -1, -1},
/*01421*/     {1086, -1, -1},
/*01422*/     {1067, -1, -1},
/*01423*/     {0, -1, -1},
/*01424*/     {0, -1, -1},
/*01425*/     {0, -1, -1},
/*01426*/     {1080, -1, -1},
/*01427*/     {1081, -1, -1},
/*01428*/     {0, -1, -1},
/*01429*/     {0, -1, -1},
/*01430*/     {1119, -1, -1},
/*01431*/     {0, -1, -1},
/*01432*/     {0, -1, -1},
/*01433*/     {0, -1, -1},
/*01434*/     {1436, 27, 6},
/*01435*/     {1564, 34, 3},
/*01436*/     {0, -1, -1},
/*01437*/     {0, -1, -1},
/*01438*/     {0, -1, -1},
/*01439*/     {0, -1, -1},
/*01440*/     {0, -1, -1},
/*01441*/     {0, -1, -1},
/*01442*/     {0, -1, -1},
/*01443*/     {0, -1, -1},
/*01444*/     {0, -1, -1},
/*01445*/     {0, -1, -1},
/*01446*/     {0, -1, -1},
/*01447*/     {0, -1, -1},
/*01448*/     {0, -1, -1},
/*01449*/     {0, -1, -1},
/*01450*/     {0, -1, -1},
/*01451*/     {0, -1, -1},
/*01452*/     {1504, -1, -1},
/*01453*/     {1505, -1, -1},
/*01454*/     {1506, -1, -1},
/*01455*/     {0, -1, -1},
/*01456*/     {1500, 34, 2},
/*01457*/     {1504, 34, 2},
/*01458*/     {1508, 34, 2},
/*01459*/     {1512, 34, 2},
/*01460*/     {1516, 34, 2},
/*01461*/     {1520, 34, 2},
/*01462*/     {1524, 34, 2},
/*01463*/     {1528, 34, 2},
/*01464*/     {0, -1, -1},
/*01465*/     {0, -1, -1},
/*01466*/     {0, -1, -1},
/*01467*/     {0, -1, -1},
/*01468*/     {0, -1, -1},
/*01469*/     {0, -1, -1},
/*01470*/     {0, -1, -1},
/*01471*/     {0, -1, -1},
/*01472*/     {0, -1, -1},
/*01473*/     {0, -1, -1},
/*01474*/     {0, -1, -1},
/*01475*/     {0, -1, -1},
/*01476*/     {0, -1, -1},
/*01477*/     {0, -1, -1},
/*01478*/     {0, -1, -1},
/*01479*/     {0, -1, -1},
/*01480*/     {0, -1, -1},
/*01481*/     {0, -1, -1},
/*01482*/     {0, -1, -1},
/*01483*/     {0, -1, -1},
/*01484*/     {1532, 34, 2},
/*01485*/     {1536, 34, 2},
/*01486*/     {1540, 34, 2},
/*01487*/     {1544, 34, 2},
/*01488*/     {1548, 34, 2},
/*01489*/     {1552, 34, 2},
/*01490*/     {1556, 34, 2},
/*01491*/     {1560, 34, 2},
/*01492*/     {0, -1, -1},
/*01493*/     {0, -1, -1},
/*01494*/     {0, -1, -1},
/*01495*/     {0, -1, -1},
/*01496*/     {0, -1, -1},
/*01497*/     {0, -1, -1},
/*01498*/     {0, -1, -1},
/*01499*/     {0, -1, -1},
/*01500*/     {1440, -1, -1},
/*01501*/     {1441, -1, -1},
/*01502*/     {1442, -1, -1},
/*01503*/     {1443, -1, -1},
/*01504*/     {1444, -1, -1},
/*01505*/     {1445, -1, -1},
/*01506*/     {1446, -1, -1},
/*01507*/     {1447, -1, -1},
/*01508*/     {1448, -1, -1},
/*01509*/     {1449, -1, -1},
/*01510*/     {1450, -1, -1},
/*01511*/     {1451, -1, -1},
/*01512*/     {1452, -1, -1},
/*01513*/     {1453, -1, -1},
/*01514*/     {1454, -1, -1},
/*01515*/     {1455, -1, -1},
/*01516*/     {1523, -1, -1},
/*01517*/     {1524, -1, -1},
/*01518*/     {1525, -1, -1},
/*01519*/     {1526, -1, -1},
/*01520*/     {1527, -1, -1},
/*01521*/     {1528, -1, -1},
/*01522*/     {1529, -1, -1},
/*01523*/     {1530, -1, -1},
/*01524*/     {1531, -1, -1},
/*01525*/     {1532, -1, -1},
/*01526*/     {1533, -1, -1},
/*01527*/     {1534, -1, -1},
/*01528*/     {1535, -1, -1},
/*01529*/     {1536, -1, -1},
/*01530*/     {1537, -1, -1},
/*01531*/     {1538, -1, -1},
/*01532*/     {1456, -1, -1},
/*01533*/     {1457, -1, -1},
/*01534*/     {1458, -1, -1},
/*01535*/     {1459, -1, -1},
/*01536*/     {1460, -1, -1},
/*01537*/     {1461, -1, -1},
/*01538*/     {1462, -1, -1},
/*01539*/     {1463, -1, -1},
/*01540*/     {1464, -1, -1},
/*01541*/     {1465, -1, -1},
/*01542*/     {1466, -1, -1},
/*01543*/     {1467, -1, -1},
/*01544*/     {1468, -1, -1},
/*01545*/     {1469, -1, -1},
/*01546*/     {1470, -1, -1},
/*01547*/     {1471, -1, -1},
/*01548*/     {1472, -1, -1},
/*01549*/     {1473, -1, -1},
/*01550*/     {1474, -1, -1},
/*01551*/     {1475, -1, -1},
/*01552*/     {1476, -1, -1},
/*01553*/     {1477, -1, -1},
/*01554*/     {1478, -1, -1},
/*01555*/     {1479, -1, -1},
/*01556*/     {1480, -1, -1},
/*01557*/     {1481, -1, -1},
/*01558*/     {1482, -1, -1},
/*01559*/     {1483, -1, -1},
/*01560*/     {1484, -1, -1},
/*01561*/     {1485, -1, -1},
/*01562*/     {1486, -1, -1},
/*01563*/     {1487, -1, -1},
/*01564*/     {1412, -1, -1},
/*01565*/     {1413, -1, -1},
/*01566*/     {1414, -1, -1},
/*01567*/     {1415, -1, -1},
/*01568*/     {1420, -1, -1},
/*01569*/     {1421, -1, -1},
/*01570*/     {1422, -1, -1},
/*01571*/     {1423, -1, -1},
/*01572*/     {1588, 12, 1},
/*01573*/     {1590, 12, 1},
/*01574*/     {1592, 12, 1},
/*01575*/     {1594, 12, 1},
/*01576*/     {1596, 12, 1},
/*01577*/     {1598, 12, 1},
/*01578*/     {1600, 12, 1},
/*01579*/     {1602, 12, 1},
/*01580*/     {1604, 12, 1},
/*01581*/     {1606, 12, 1},
/*01582*/     {1608, 12, 1},
/*01583*/     {1610, 12, 1},
/*01584*/     {1612, 12, 1},
/*01585*/     {1614, 12, 1},
/*01586*/     {1616, 12, 1},
/*01587*/     {1618, 12, 1},
/*01588*/     {1280, -1, -1},
/*01589*/     {1281, -1, -1},
/*01590*/     {1280, -1, -1},
/*01591*/     {1281, -1, -1},
/*01592*/     {1280, -1, -1},
/*01593*/     {1281, -1, -1},
/*01594*/     {1282, -1, -1},
/*01595*/     {1283, -1, -1},
/*01596*/     {1280, -1, -1},
/*01597*/     {1281, -1, -1},
/*01598*/     {1284, -1, -1},
/*01599*/     {1285, -1, -1},
/*01600*/     {1280, -1, -1},
/*01601*/     {1281, -1, -1},
/*01602*/     {1286, -1, -1},
/*01603*/     {1287, -1, -1},
/*01604*/     {1288, -1, -1},
/*01605*/     {1289, -1, -1},
/*01606*/     {1288, -1, -1},
/*01607*/     {1289, -1, -1},
/*01608*/     {1288, -1, -1},
/*01609*/     {1289, -1, -1},
/*01610*/     {1290, -1, -1},
/*01611*/     {1291, -1, -1},
/*01612*/     {1288, -1, -1},
/*01613*/     {1289, -1, -1},
/*01614*/     {1292, -1, -1},
/*01615*/     {1293, -1, -1},
/*01616*/     {1288, -1, -1},
/*01617*/     {1289, -1, -1},
/*01618*/     {1294, -1, -1},
/*01619*/     {1295, -1, -1},
/*01620*/     {1321, -1, -1},
/*01621*/     {0, -1, -1},
/*01622*/     {0, -1, -1},
/*01623*/     {0, -1, -1},
/*01624*/     {0, -1, -1},
/*01625*/     {0, -1, -1},
/*01626*/     {0, -1, -1},
/*01627*/     {0, -1, -1},
/*01628*/     {0, -1, -1},
/*01629*/     {0, -1, -1},
/*01630*/     {0, -1, -1},
/*01631*/     {0, -1, -1},
/*01632*/     {0, -1, -1},
/*01633*/     {0, -1, -1},
/*01634*/     {0, -1, -1},
/*01635*/     {0, -1, -1},
/*01636*/     {1684, 0, 6},
/*01637*/     {1756, 0, 6},
/*01638*/     {0, -1, -1},
/*01639*/     {0, -1, -1},
/*01640*/     {0, -1, -1},
/*01641*/     {0, -1, -1},
/*01642*/     {0, -1, -1},
/*01643*/     {0, -1, -1},
/*01644*/     {0, -1, -1},
/*01645*/     {0, -1, -1},
/*01646*/     {0, -1, -1},
/*01647*/     {0, -1, -1},
/*01648*/     {0, -1, -1},
/*01649*/     {0, -1, -1},
/*01650*/     {0, -1, -1},
/*01651*/     {0, -1, -1},
/*01652*/     {0, -1, -1},
/*01653*/     {0, -1, -1},
/*01654*/     {0, -1, -1},
/*01655*/     {0, -1, -1},
/*01656*/     {0, -1, -1},
/*01657*/     {0, -1, -1},
/*01658*/     {0, -1, -1},
/*01659*/     {0, -1, -1},
/*01660*/     {0, -1, -1},
/*01661*/     {0, -1, -1},
/*01662*/     {0, -1, -1},
/*01663*/     {0, -1, -1},
/*01664*/     {0, -1, -1},
/*01665*/     {0, -1, -1},
/*01666*/     {0, -1, -1},
/*01667*/     {0, -1, -1},
/*01668*/     {0, -1, -1},
/*01669*/     {0, -1, -1},
/*01670*/     {0, -1, -1},
/*01671*/     {0, -1, -1},
/*01672*/     {0, -1, -1},
/*01673*/     {0, -1, -1},
/*01674*/     {0, -1, -1},
/*01675*/     {0, -1, -1},
/*01676*/     {0, -1, -1},
/*01677*/     {0, -1, -1},
/*01678*/     {0, -1, -1},
/*01679*/     {0, -1, -1},
/*01680*/     {0, -1, -1},
/*01681*/     {0, -1, -1},
/*01682*/     {0, -1, -1},
/*01683*/     {0, -1, -1},
/*01684*/     {1748, 35, 1},
/*01685*/     {0, -1, -1},
/*01686*/     {0, -1, -1},
/*01687*/     {0, -1, -1},
/*01688*/     {0, -1, -1},
/*01689*/     {0, -1, -1},
/*01690*/     {0, -1, -1},
/*01691*/     {0, -1, -1},
/*01692*/     {1750, 35, 1},
/*01693*/     {0, -1, -1},
/*01694*/     {0, -1, -1},
/*01695*/     {0, -1, -1},
/*01696*/     {0, -1, -1},
/*01697*/     {0, -1, -1},
/*01698*/     {0, -1, -1},
/*01699*/     {0, -1, -1},
/*01700*/     {1752, 35, 1},
/*01701*/     {0, -1, -1},
/*01702*/     {0, -1, -1},
/*01703*/     {0, -1, -1},
/*01704*/     {0, -1, -1},
/*01705*/     {0, -1, -1},
/*01706*/     {0, -1, -1},
/*01707*/     {0, -1, -1},
/*01708*/     {1754, 35, 1},
/*01709*/     {0, -1, -1},
/*01710*/     {0, -1, -1},
/*01711*/     {0, -1, -1},
/*01712*/     {0, -1, -1},
/*01713*/     {0, -1, -1},
/*01714*/     {0, -1, -1},
/*01715*/     {0, -1, -1},
/*01716*/     {0, -1, -1},
/*01717*/     {0, -1, -1},
/*01718*/     {0, -1, -1},
/*01719*/     {0, -1, -1},
/*01720*/     {0, -1, -1},
/*01721*/     {0, -1, -1},
/*01722*/     {0, -1, -1},
/*01723*/     {0, -1, -1},
/*01724*/     {0, -1, -1},
/*01725*/     {0, -1, -1},
/*01726*/     {0, -1, -1},
/*01727*/     {0, -1, -1},
/*01728*/     {0, -1, -1},
/*01729*/     {0, -1, -1},
/*01730*/     {0, -1, -1},
/*01731*/     {0, -1, -1},
/*01732*/     {0, -1, -1},
/*01733*/     {0, -1, -1},
/*01734*/     {0, -1, -1},
/*01735*/     {0, -1, -1},
/*01736*/     {0, -1, -1},
/*01737*/     {0, -1, -1},
/*01738*/     {0, -1, -1},
/*01739*/     {0, -1, -1},
/*01740*/     {0, -1, -1},
/*01741*/     {0, -1, -1},
/*01742*/     {0, -1, -1},
/*01743*/     {0, -1, -1},
/*01744*/     {0, -1, -1},
/*01745*/     {0, -1, -1},
/*01746*/     {0, -1, -1},
/*01747*/     {0, -1, -1},
/*01748*/     {1304, -1, -1},
/*01749*/     {1305, -1, -1},
/*01750*/     {1304, -1, -1},
/*01751*/     {1305, -1, -1},
/*01752*/     {1306, -1, -1},
/*01753*/     {1307, -1, -1},
/*01754*/     {1304, -1, -1},
/*01755*/     {1305, -1, -1},
/*01756*/     {1820, 35, 1},
/*01757*/     {0, -1, -1},
/*01758*/     {0, -1, -1},
/*01759*/     {0, -1, -1},
/*01760*/     {0, -1, -1},
/*01761*/     {0, -1, -1},
/*01762*/     {0, -1, -1},
/*01763*/     {0, -1, -1},
/*01764*/     {1822, 35, 1},
/*01765*/     {0, -1, -1},
/*01766*/     {0, -1, -1},
/*01767*/     {0, -1, -1},
/*01768*/     {0, -1, -1},
/*01769*/     {0, -1, -1},
/*01770*/     {0, -1, -1},
/*01771*/     {0, -1, -1},
/*01772*/     {1824, 35, 1},
/*01773*/     {0, -1, -1},
/*01774*/     {0, -1, -1},
/*01775*/     {0, -1, -1},
/*01776*/     {0, -1, -1},
/*01777*/     {0, -1, -1},
/*01778*/     {0, -1, -1},
/*01779*/     {0, -1, -1},
/*01780*/     {1826, 35, 1},
/*01781*/     {0, -1, -1},
/*01782*/     {0, -1, -1},
/*01783*/     {0, -1, -1},
/*01784*/     {0, -1, -1},
/*01785*/     {0, -1, -1},
/*01786*/     {0, -1, -1},
/*01787*/     {0, -1, -1},
/*01788*/     {0, -1, -1},
/*01789*/     {0, -1, -1},
/*01790*/     {0, -1, -1},
/*01791*/     {0, -1, -1},
/*01792*/     {0, -1, -1},
/*01793*/     {0, -1, -1},
/*01794*/     {0, -1, -1},
/*01795*/     {0, -1, -1},
/*01796*/     {0, -1, -1},
/*01797*/     {0, -1, -1},
/*01798*/     {0, -1, -1},
/*01799*/     {0, -1, -1},
/*01800*/     {0, -1, -1},
/*01801*/     {0, -1, -1},
/*01802*/     {0, -1, -1},
/*01803*/     {0, -1, -1},
/*01804*/     {0, -1, -1},
/*01805*/     {0, -1, -1},
/*01806*/     {0, -1, -1},
/*01807*/     {0, -1, -1},
/*01808*/     {0, -1, -1},
/*01809*/     {0, -1, -1},
/*01810*/     {0, -1, -1},
/*01811*/     {0, -1, -1},
/*01812*/     {0, -1, -1},
/*01813*/     {0, -1, -1},
/*01814*/     {0, -1, -1},
/*01815*/     {0, -1, -1},
/*01816*/     {0, -1, -1},
/*01817*/     {0, -1, -1},
/*01818*/     {0, -1, -1},
/*01819*/     {0, -1, -1},
/*01820*/     {1308, -1, -1},
/*01821*/     {1309, -1, -1},
/*01822*/     {1308, -1, -1},
/*01823*/     {1309, -1, -1},
/*01824*/     {1310, -1, -1},
/*01825*/     {1311, -1, -1},
/*01826*/     {1308, -1, -1},
/*01827*/     {1309, -1, -1},
/*01828*/     {1956, 27, 3},
/*01829*/     {1964, 27, 3},
/*01830*/     {1972, 27, 3},
/*01831*/     {1980, 27, 3},
/*01832*/     {1988, 27, 3},
/*01833*/     {1996, 27, 3},
/*01834*/     {2004, 27, 3},
/*01835*/     {2012, 27, 3},
/*01836*/     {2020, 27, 3},
/*01837*/     {2028, 27, 3},
/*01838*/     {2036, 27, 3},
/*01839*/     {2044, 27, 3},
/*01840*/     {2052, 27, 3},
/*01841*/     {2060, 27, 3},
/*01842*/     {2068, 27, 3},
/*01843*/     {2076, 27, 3},
/*01844*/     {2084, 27, 3},
/*01845*/     {2092, 27, 3},
/*01846*/     {2100, 27, 3},
/*01847*/     {2108, 27, 3},
/*01848*/     {2116, 27, 3},
/*01849*/     {2124, 27, 3},
/*01850*/     {2132, 27, 3},
/*01851*/     {2140, 27, 3},
/*01852*/     {0, -1, -1},
/*01853*/     {0, -1, -1},
/*01854*/     {0, -1, -1},
/*01855*/     {2148, 27, 3},
/*01856*/     {2156, 27, 1},
/*01857*/     {2158, 27, 1},
/*01858*/     {2160, 27, 1},
/*01859*/     {2162, 27, 1},
/*01860*/     {2164, 27, 3},
/*01861*/     {2172, 27, 3},
/*01862*/     {2180, 27, 3},
/*01863*/     {2188, 27, 3},
/*01864*/     {2196, 27, 3},
/*01865*/     {2204, 27, 3},
/*01866*/     {2212, 27, 3},
/*01867*/     {2220, 27, 3},
/*01868*/     {2228, 27, 3},
/*01869*/     {2236, 27, 3},
/*01870*/     {2244, 27, 3},
/*01871*/     {2252, 27, 3},
/*01872*/     {0, -1, -1},
/*01873*/     {0, -1, -1},
/*01874*/     {0, -1, -1},
/*01875*/     {0, -1, -1},
/*01876*/     {2260, 27, 3},
/*01877*/     {2268, 27, 3},
/*01878*/     {2276, 27, 3},
/*01879*/     {2284, 27, 3},
/*01880*/     {2292, 27, 3},
/*01881*/     {2300, 27, 3},
/*01882*/     {2308, 27, 3},
/*01883*/     {2316, 27, 3},
/*01884*/     {0, -1, -1},
/*01885*/     {0, -1, -1},
/*01886*/     {0, -1, -1},
/*01887*/     {2324, 27, 3},
/*01888*/     {0, -1, -1},
/*01889*/     {0, -1, -1},
/*01890*/     {0, -1, -1},
/*01891*/     {0, -1, -1},
/*01892*/     {2332, 27, 3},
/*01893*/     {2340, 27, 3},
/*01894*/     {2348, 27, 3},
/*01895*/     {2356, 27, 3},
/*01896*/     {2364, 27, 3},
/*01897*/     {2372, 27, 3},
/*01898*/     {2380, 27, 3},
/*01899*/     {2388, 27, 3},
/*01900*/     {2396, 27, 3},
/*01901*/     {2404, 27, 3},
/*01902*/     {2412, 27, 3},
/*01903*/     {2420, 27, 3},
/*01904*/     {2428, 27, 3},
/*01905*/     {2436, 27, 3},
/*01906*/     {2444, 27, 3},
/*01907*/     {2452, 27, 3},
/*01908*/     {2460, 27, 3},
/*01909*/     {2468, 27, 3},
/*01910*/     {2476, 27, 3},
/*01911*/     {2484, 27, 3},
/*01912*/     {2492, 27, 3},
/*01913*/     {2500, 27, 3},
/*01914*/     {2508, 27, 3},
/*01915*/     {2516, 27, 3},
/*01916*/     {0, -1, -1},
/*01917*/     {0, -1, -1},
/*01918*/     {0, -1, -1},
/*01919*/     {2524, 27, 3},
/*01920*/     {0, -1, -1},
/*01921*/     {0, -1, -1},
/*01922*/     {0, -1, -1},
/*01923*/     {0, -1, -1},
/*01924*/     {2532, 27, 3},
/*01925*/     {2540, 27, 3},
/*01926*/     {2548, 27, 3},
/*01927*/     {2556, 27, 3},
/*01928*/     {2564, 27, 3},
/*01929*/     {2572, 27, 3},
/*01930*/     {2580, 27, 3},
/*01931*/     {2588, 27, 3},
/*01932*/     {2596, 27, 3},
/*01933*/     {2604, 27, 3},
/*01934*/     {2612, 27, 3},
/*01935*/     {2620, 27, 3},
/*01936*/     {0, -1, -1},
/*01937*/     {0, -1, -1},
/*01938*/     {0, -1, -1},
/*01939*/     {0, -1, -1},
/*01940*/     {0, -1, -1},
/*01941*/     {0, -1, -1},
/*01942*/     {0, -1, -1},
/*01943*/     {0, -1, -1},
/*01944*/     {0, -1, -1},
/*01945*/     {0, -1, -1},
/*01946*/     {0, -1, -1},
/*01947*/     {0, -1, -1},
/*01948*/     {0, -1, -1},
/*01949*/     {0, -1, -1},
/*01950*/     {0, -1, -1},
/*01951*/     {0, -1, -1},
/*01952*/     {0, -1, -1},
/*01953*/     {0, -1, -1},
/*01954*/     {0, -1, -1},
/*01955*/     {0, -1, -1},
/*01956*/     {223, -1, -1},
/*01957*/     {993, -1, -1},
/*01958*/     {224, -1, -1},
/*01959*/     {994, -1, -1},
/*01960*/     {223, -1, -1},
/*01961*/     {993, -1, -1},
/*01962*/     {225, -1, -1},
/*01963*/     {995, -1, -1},
/*01964*/     {226, -1, -1},
/*01965*/     {996, -1, -1},
/*01966*/     {227, -1, -1},
/*01967*/     {997, -1, -1},
/*01968*/     {226, -1, -1},
/*01969*/     {996, -1, -1},
/*01970*/     {228, -1, -1},
/*01971*/     {998, -1, -1},
/*01972*/     {229, -1, -1},
/*01973*/     {999, -1, -1},
/*01974*/     {230, -1, -1},
/*01975*/     {1000, -1, -1},
/*01976*/     {229, -1, -1},
/*01977*/     {999, -1, -1},
/*01978*/     {231, -1, -1},
/*01979*/     {1001, -1, -1},
/*01980*/     {232, -1, -1},
/*01981*/     {1002, -1, -1},
/*01982*/     {233, -1, -1},
/*01983*/     {1003, -1, -1},
/*01984*/     {232, -1, -1},
/*01985*/     {1002, -1, -1},
/*01986*/     {234, -1, -1},
/*01987*/     {1004, -1, -1},
/*01988*/     {235, -1, -1},
/*01989*/     {1005, -1, -1},
/*01990*/     {236, -1, -1},
/*01991*/     {1006, -1, -1},
/*01992*/     {235, -1, -1},
/*01993*/     {1005, -1, -1},
/*01994*/     {237, -1, -1},
/*01995*/     {1007, -1, -1},
/*01996*/     {238, -1, -1},
/*01997*/     {1008, -1, -1},
/*01998*/     {239, -1, -1},
/*01999*/     {1009, -1, -1},
/*02000*/     {238, -1, -1},
/*02001*/     {1008, -1, -1},
/*02002*/     {240, -1, -1},
/*02003*/     {1010, -1, -1},
/*02004*/     {241, -1, -1},
/*02005*/     {1011, -1, -1},
/*02006*/     {242, -1, -1},
/*02007*/     {1012, -1, -1},
/*02008*/     {241, -1, -1},
/*02009*/     {1011, -1, -1},
/*02010*/     {243, -1, -1},
/*02011*/     {1013, -1, -1},
/*02012*/     {244, -1, -1},
/*02013*/     {1014, -1, -1},
/*02014*/     {245, -1, -1},
/*02015*/     {1015, -1, -1},
/*02016*/     {244, -1, -1},
/*02017*/     {1014, -1, -1},
/*02018*/     {246, -1, -1},
/*02019*/     {1016, -1, -1},
/*02020*/     {247, -1, -1},
/*02021*/     {1017, -1, -1},
/*02022*/     {248, -1, -1},
/*02023*/     {1018, -1, -1},
/*02024*/     {247, -1, -1},
/*02025*/     {1017, -1, -1},
/*02026*/     {249, -1, -1},
/*02027*/     {1019, -1, -1},
/*02028*/     {250, -1, -1},
/*02029*/     {1020, -1, -1},
/*02030*/     {251, -1, -1},
/*02031*/     {1021, -1, -1},
/*02032*/     {250, -1, -1},
/*02033*/     {1020, -1, -1},
/*02034*/     {252, -1, -1},
/*02035*/     {1022, -1, -1},
/*02036*/     {253, -1, -1},
/*02037*/     {1023, -1, -1},
/*02038*/     {254, -1, -1},
/*02039*/     {1024, -1, -1},
/*02040*/     {253, -1, -1},
/*02041*/     {1023, -1, -1},
/*02042*/     {255, -1, -1},
/*02043*/     {1025, -1, -1},
/*02044*/     {256, -1, -1},
/*02045*/     {1026, -1, -1},
/*02046*/     {257, -1, -1},
/*02047*/     {1027, -1, -1},
/*02048*/     {256, -1, -1},
/*02049*/     {1026, -1, -1},
/*02050*/     {258, -1, -1},
/*02051*/     {1028, -1, -1},
/*02052*/     {259, -1, -1},
/*02053*/     {0, -1, -1},
/*02054*/     {260, -1, -1},
/*02055*/     {0, -1, -1},
/*02056*/     {259, -1, -1},
/*02057*/     {0, -1, -1},
/*02058*/     {261, -1, -1},
/*02059*/     {0, -1, -1},
/*02060*/     {262, -1, -1},
/*02061*/     {0, -1, -1},
/*02062*/     {263, -1, -1},
/*02063*/     {0, -1, -1},
/*02064*/     {262, -1, -1},
/*02065*/     {0, -1, -1},
/*02066*/     {264, -1, -1},
/*02067*/     {0, -1, -1},
/*02068*/     {265, -1, -1},
/*02069*/     {0, -1, -1},
/*02070*/     {266, -1, -1},
/*02071*/     {0, -1, -1},
/*02072*/     {265, -1, -1},
/*02073*/     {0, -1, -1},
/*02074*/     {267, -1, -1},
/*02075*/     {0, -1, -1},
/*02076*/     {268, -1, -1},
/*02077*/     {0, -1, -1},
/*02078*/     {269, -1, -1},
/*02079*/     {0, -1, -1},
/*02080*/     {268, -1, -1},
/*02081*/     {0, -1, -1},
/*02082*/     {270, -1, -1},
/*02083*/     {0, -1, -1},
/*02084*/     {271, -1, -1},
/*02085*/     {0, -1, -1},
/*02086*/     {272, -1, -1},
/*02087*/     {0, -1, -1},
/*02088*/     {271, -1, -1},
/*02089*/     {0, -1, -1},
/*02090*/     {273, -1, -1},
/*02091*/     {0, -1, -1},
/*02092*/     {274, -1, -1},
/*02093*/     {0, -1, -1},
/*02094*/     {275, -1, -1},
/*02095*/     {0, -1, -1},
/*02096*/     {274, -1, -1},
/*02097*/     {0, -1, -1},
/*02098*/     {276, -1, -1},
/*02099*/     {0, -1, -1},
/*02100*/     {277, -1, -1},
/*02101*/     {1029, -1, -1},
/*02102*/     {278, -1, -1},
/*02103*/     {1030, -1, -1},
/*02104*/     {277, -1, -1},
/*02105*/     {1029, -1, -1},
/*02106*/     {279, -1, -1},
/*02107*/     {1031, -1, -1},
/*02108*/     {280, -1, -1},
/*02109*/     {1032, -1, -1},
/*02110*/     {281, -1, -1},
/*02111*/     {1033, -1, -1},
/*02112*/     {280, -1, -1},
/*02113*/     {1032, -1, -1},
/*02114*/     {282, -1, -1},
/*02115*/     {1034, -1, -1},
/*02116*/     {283, -1, -1},
/*02117*/     {0, -1, -1},
/*02118*/     {284, -1, -1},
/*02119*/     {0, -1, -1},
/*02120*/     {283, -1, -1},
/*02121*/     {0, -1, -1},
/*02122*/     {285, -1, -1},
/*02123*/     {0, -1, -1},
/*02124*/     {286, -1, -1},
/*02125*/     {0, -1, -1},
/*02126*/     {287, -1, -1},
/*02127*/     {0, -1, -1},
/*02128*/     {286, -1, -1},
/*02129*/     {0, -1, -1},
/*02130*/     {288, -1, -1},
/*02131*/     {0, -1, -1},
/*02132*/     {289, -1, -1},
/*02133*/     {1035, -1, -1},
/*02134*/     {290, -1, -1},
/*02135*/     {1036, -1, -1},
/*02136*/     {289, -1, -1},
/*02137*/     {1035, -1, -1},
/*02138*/     {291, -1, -1},
/*02139*/     {1037, -1, -1},
/*02140*/     {292, -1, -1},
/*02141*/     {1038, -1, -1},
/*02142*/     {293, -1, -1},
/*02143*/     {1039, -1, -1},
/*02144*/     {292, -1, -1},
/*02145*/     {1038, -1, -1},
/*02146*/     {294, -1, -1},
/*02147*/     {1040, -1, -1},
/*02148*/     {295, -1, -1},
/*02149*/     {0, -1, -1},
/*02150*/     {296, -1, -1},
/*02151*/     {0, -1, -1},
/*02152*/     {295, -1, -1},
/*02153*/     {0, -1, -1},
/*02154*/     {297, -1, -1},
/*02155*/     {0, -1, -1},
/*02156*/     {0, -1, -1},
/*02157*/     {1045, -1, -1},
/*02158*/     {0, -1, -1},
/*02159*/     {1046, -1, -1},
/*02160*/     {0, -1, -1},
/*02161*/     {1047, -1, -1},
/*02162*/     {0, -1, -1},
/*02163*/     {1048, -1, -1},
/*02164*/     {298, -1, -1},
/*02165*/     {0, -1, -1},
/*02166*/     {299, -1, -1},
/*02167*/     {0, -1, -1},
/*02168*/     {298, -1, -1},
/*02169*/     {0, -1, -1},
/*02170*/     {300, -1, -1},
/*02171*/     {0, -1, -1},
/*02172*/     {301, -1, -1},
/*02173*/     {0, -1, -1},
/*02174*/     {302, -1, -1},
/*02175*/     {0, -1, -1},
/*02176*/     {301, -1, -1},
/*02177*/     {0, -1, -1},
/*02178*/     {303, -1, -1},
/*02179*/     {0, -1, -1},
/*02180*/     {304, -1, -1},
/*02181*/     {0, -1, -1},
/*02182*/     {305, -1, -1},
/*02183*/     {0, -1, -1},
/*02184*/     {304, -1, -1},
/*02185*/     {0, -1, -1},
/*02186*/     {306, -1, -1},
/*02187*/     {0, -1, -1},
/*02188*/     {307, -1, -1},
/*02189*/     {0, -1, -1},
/*02190*/     {308, -1, -1},
/*02191*/     {0, -1, -1},
/*02192*/     {307, -1, -1},
/*02193*/     {0, -1, -1},
/*02194*/     {309, -1, -1},
/*02195*/     {0, -1, -1},
/*02196*/     {310, -1, -1},
/*02197*/     {0, -1, -1},
/*02198*/     {311, -1, -1},
/*02199*/     {0, -1, -1},
/*02200*/     {310, -1, -1},
/*02201*/     {0, -1, -1},
/*02202*/     {312, -1, -1},
/*02203*/     {0, -1, -1},
/*02204*/     {313, -1, -1},
/*02205*/     {0, -1, -1},
/*02206*/     {314, -1, -1},
/*02207*/     {0, -1, -1},
/*02208*/     {313, -1, -1},
/*02209*/     {0, -1, -1},
/*02210*/     {315, -1, -1},
/*02211*/     {0, -1, -1},
/*02212*/     {316, -1, -1},
/*02213*/     {0, -1, -1},
/*02214*/     {317, -1, -1},
/*02215*/     {0, -1, -1},
/*02216*/     {316, -1, -1},
/*02217*/     {0, -1, -1},
/*02218*/     {318, -1, -1},
/*02219*/     {0, -1, -1},
/*02220*/     {319, -1, -1},
/*02221*/     {0, -1, -1},
/*02222*/     {320, -1, -1},
/*02223*/     {0, -1, -1},
/*02224*/     {319, -1, -1},
/*02225*/     {0, -1, -1},
/*02226*/     {321, -1, -1},
/*02227*/     {0, -1, -1},
/*02228*/     {322, -1, -1},
/*02229*/     {0, -1, -1},
/*02230*/     {323, -1, -1},
/*02231*/     {0, -1, -1},
/*02232*/     {322, -1, -1},
/*02233*/     {0, -1, -1},
/*02234*/     {324, -1, -1},
/*02235*/     {0, -1, -1},
/*02236*/     {325, -1, -1},
/*02237*/     {0, -1, -1},
/*02238*/     {326, -1, -1},
/*02239*/     {0, -1, -1},
/*02240*/     {325, -1, -1},
/*02241*/     {0, -1, -1},
/*02242*/     {327, -1, -1},
/*02243*/     {0, -1, -1},
/*02244*/     {328, -1, -1},
/*02245*/     {0, -1, -1},
/*02246*/     {329, -1, -1},
/*02247*/     {0, -1, -1},
/*02248*/     {328, -1, -1},
/*02249*/     {0, -1, -1},
/*02250*/     {330, -1, -1},
/*02251*/     {0, -1, -1},
/*02252*/     {331, -1, -1},
/*02253*/     {0, -1, -1},
/*02254*/     {332, -1, -1},
/*02255*/     {0, -1, -1},
/*02256*/     {331, -1, -1},
/*02257*/     {0, -1, -1},
/*02258*/     {333, -1, -1},
/*02259*/     {0, -1, -1},
/*02260*/     {556, -1, -1},
/*02261*/     {0, -1, -1},
/*02262*/     {556, -1, -1},
/*02263*/     {0, -1, -1},
/*02264*/     {556, -1, -1},
/*02265*/     {0, -1, -1},
/*02266*/     {557, -1, -1},
/*02267*/     {0, -1, -1},
/*02268*/     {558, -1, -1},
/*02269*/     {0, -1, -1},
/*02270*/     {558, -1, -1},
/*02271*/     {0, -1, -1},
/*02272*/     {558, -1, -1},
/*02273*/     {0, -1, -1},
/*02274*/     {559, -1, -1},
/*02275*/     {0, -1, -1},
/*02276*/     {560, -1, -1},
/*02277*/     {0, -1, -1},
/*02278*/     {560, -1, -1},
/*02279*/     {0, -1, -1},
/*02280*/     {560, -1, -1},
/*02281*/     {0, -1, -1},
/*02282*/     {561, -1, -1},
/*02283*/     {0, -1, -1},
/*02284*/     {562, -1, -1},
/*02285*/     {0, -1, -1},
/*02286*/     {562, -1, -1},
/*02287*/     {0, -1, -1},
/*02288*/     {562, -1, -1},
/*02289*/     {0, -1, -1},
/*02290*/     {563, -1, -1},
/*02291*/     {0, -1, -1},
/*02292*/     {564, -1, -1},
/*02293*/     {0, -1, -1},
/*02294*/     {564, -1, -1},
/*02295*/     {0, -1, -1},
/*02296*/     {564, -1, -1},
/*02297*/     {0, -1, -1},
/*02298*/     {565, -1, -1},
/*02299*/     {0, -1, -1},
/*02300*/     {566, -1, -1},
/*02301*/     {0, -1, -1},
/*02302*/     {566, -1, -1},
/*02303*/     {0, -1, -1},
/*02304*/     {566, -1, -1},
/*02305*/     {0, -1, -1},
/*02306*/     {567, -1, -1},
/*02307*/     {0, -1, -1},
/*02308*/     {568, -1, -1},
/*02309*/     {0, -1, -1},
/*02310*/     {568, -1, -1},
/*02311*/     {0, -1, -1},
/*02312*/     {568, -1, -1},
/*02313*/     {0, -1, -1},
/*02314*/     {569, -1, -1},
/*02315*/     {0, -1, -1},
/*02316*/     {570, -1, -1},
/*02317*/     {0, -1, -1},
/*02318*/     {570, -1, -1},
/*02319*/     {0, -1, -1},
/*02320*/     {570, -1, -1},
/*02321*/     {0, -1, -1},
/*02322*/     {571, -1, -1},
/*02323*/     {0, -1, -1},
/*02324*/     {572, -1, -1},
/*02325*/     {0, -1, -1},
/*02326*/     {572, -1, -1},
/*02327*/     {0, -1, -1},
/*02328*/     {572, -1, -1},
/*02329*/     {0, -1, -1},
/*02330*/     {573, -1, -1},
/*02331*/     {0, -1, -1},
/*02332*/     {334, -1, -1},
/*02333*/     {0, -1, -1},
/*02334*/     {335, -1, -1},
/*02335*/     {0, -1, -1},
/*02336*/     {334, -1, -1},
/*02337*/     {0, -1, -1},
/*02338*/     {336, -1, -1},
/*02339*/     {0, -1, -1},
/*02340*/     {337, -1, -1},
/*02341*/     {0, -1, -1},
/*02342*/     {338, -1, -1},
/*02343*/     {0, -1, -1},
/*02344*/     {337, -1, -1},
/*02345*/     {0, -1, -1},
/*02346*/     {339, -1, -1},
/*02347*/     {0, -1, -1},
/*02348*/     {340, -1, -1},
/*02349*/     {0, -1, -1},
/*02350*/     {341, -1, -1},
/*02351*/     {0, -1, -1},
/*02352*/     {340, -1, -1},
/*02353*/     {0, -1, -1},
/*02354*/     {342, -1, -1},
/*02355*/     {0, -1, -1},
/*02356*/     {343, -1, -1},
/*02357*/     {0, -1, -1},
/*02358*/     {344, -1, -1},
/*02359*/     {0, -1, -1},
/*02360*/     {343, -1, -1},
/*02361*/     {0, -1, -1},
/*02362*/     {345, -1, -1},
/*02363*/     {0, -1, -1},
/*02364*/     {346, -1, -1},
/*02365*/     {0, -1, -1},
/*02366*/     {347, -1, -1},
/*02367*/     {0, -1, -1},
/*02368*/     {346, -1, -1},
/*02369*/     {0, -1, -1},
/*02370*/     {348, -1, -1},
/*02371*/     {0, -1, -1},
/*02372*/     {349, -1, -1},
/*02373*/     {0, -1, -1},
/*02374*/     {350, -1, -1},
/*02375*/     {0, -1, -1},
/*02376*/     {349, -1, -1},
/*02377*/     {0, -1, -1},
/*02378*/     {351, -1, -1},
/*02379*/     {0, -1, -1},
/*02380*/     {352, -1, -1},
/*02381*/     {0, -1, -1},
/*02382*/     {353, -1, -1},
/*02383*/     {0, -1, -1},
/*02384*/     {352, -1, -1},
/*02385*/     {0, -1, -1},
/*02386*/     {354, -1, -1},
/*02387*/     {0, -1, -1},
/*02388*/     {355, -1, -1},
/*02389*/     {0, -1, -1},
/*02390*/     {356, -1, -1},
/*02391*/     {0, -1, -1},
/*02392*/     {355, -1, -1},
/*02393*/     {0, -1, -1},
/*02394*/     {357, -1, -1},
/*02395*/     {0, -1, -1},
/*02396*/     {358, -1, -1},
/*02397*/     {0, -1, -1},
/*02398*/     {359, -1, -1},
/*02399*/     {0, -1, -1},
/*02400*/     {358, -1, -1},
/*02401*/     {0, -1, -1},
/*02402*/     {360, -1, -1},
/*02403*/     {0, -1, -1},
/*02404*/     {361, -1, -1},
/*02405*/     {0, -1, -1},
/*02406*/     {362, -1, -1},
/*02407*/     {0, -1, -1},
/*02408*/     {361, -1, -1},
/*02409*/     {0, -1, -1},
/*02410*/     {363, -1, -1},
/*02411*/     {0, -1, -1},
/*02412*/     {364, -1, -1},
/*02413*/     {0, -1, -1},
/*02414*/     {365, -1, -1},
/*02415*/     {0, -1, -1},
/*02416*/     {364, -1, -1},
/*02417*/     {0, -1, -1},
/*02418*/     {366, -1, -1},
/*02419*/     {0, -1, -1},
/*02420*/     {367, -1, -1},
/*02421*/     {0, -1, -1},
/*02422*/     {368, -1, -1},
/*02423*/     {0, -1, -1},
/*02424*/     {367, -1, -1},
/*02425*/     {0, -1, -1},
/*02426*/     {369, -1, -1},
/*02427*/     {0, -1, -1},
/*02428*/     {370, -1, -1},
/*02429*/     {0, -1, -1},
/*02430*/     {371, -1, -1},
/*02431*/     {0, -1, -1},
/*02432*/     {370, -1, -1},
/*02433*/     {0, -1, -1},
/*02434*/     {372, -1, -1},
/*02435*/     {0, -1, -1},
/*02436*/     {373, -1, -1},
/*02437*/     {0, -1, -1},
/*02438*/     {374, -1, -1},
/*02439*/     {0, -1, -1},
/*02440*/     {373, -1, -1},
/*02441*/     {0, -1, -1},
/*02442*/     {375, -1, -1},
/*02443*/     {0, -1, -1},
/*02444*/     {376, -1, -1},
/*02445*/     {0, -1, -1},
/*02446*/     {377, -1, -1},
/*02447*/     {0, -1, -1},
/*02448*/     {376, -1, -1},
/*02449*/     {0, -1, -1},
/*02450*/     {378, -1, -1},
/*02451*/     {0, -1, -1},
/*02452*/     {379, -1, -1},
/*02453*/     {0, -1, -1},
/*02454*/     {380, -1, -1},
/*02455*/     {0, -1, -1},
/*02456*/     {379, -1, -1},
/*02457*/     {0, -1, -1},
/*02458*/     {381, -1, -1},
/*02459*/     {0, -1, -1},
/*02460*/     {382, -1, -1},
/*02461*/     {0, -1, -1},
/*02462*/     {383, -1, -1},
/*02463*/     {0, -1, -1},
/*02464*/     {382, -1, -1},
/*02465*/     {0, -1, -1},
/*02466*/     {384, -1, -1},
/*02467*/     {0, -1, -1},
/*02468*/     {385, -1, -1},
/*02469*/     {0, -1, -1},
/*02470*/     {386, -1, -1},
/*02471*/     {0, -1, -1},
/*02472*/     {385, -1, -1},
/*02473*/     {0, -1, -1},
/*02474*/     {387, -1, -1},
/*02475*/     {0, -1, -1},
/*02476*/     {388, -1, -1},
/*02477*/     {0, -1, -1},
/*02478*/     {389, -1, -1},
/*02479*/     {0, -1, -1},
/*02480*/     {388, -1, -1},
/*02481*/     {0, -1, -1},
/*02482*/     {390, -1, -1},
/*02483*/     {0, -1, -1},
/*02484*/     {391, -1, -1},
/*02485*/     {0, -1, -1},
/*02486*/     {392, -1, -1},
/*02487*/     {0, -1, -1},
/*02488*/     {391, -1, -1},
/*02489*/     {0, -1, -1},
/*02490*/     {393, -1, -1},
/*02491*/     {0, -1, -1},
/*02492*/     {394, -1, -1},
/*02493*/     {0, -1, -1},
/*02494*/     {395, -1, -1},
/*02495*/     {0, -1, -1},
/*02496*/     {394, -1, -1},
/*02497*/     {0, -1, -1},
/*02498*/     {396, -1, -1},
/*02499*/     {0, -1, -1},
/*02500*/     {397, -1, -1},
/*02501*/     {0, -1, -1},
/*02502*/     {398, -1, -1},
/*02503*/     {0, -1, -1},
/*02504*/     {397, -1, -1},
/*02505*/     {0, -1, -1},
/*02506*/     {399, -1, -1},
/*02507*/     {0, -1, -1},
/*02508*/     {400, -1, -1},
/*02509*/     {0, -1, -1},
/*02510*/     {401, -1, -1},
/*02511*/     {0, -1, -1},
/*02512*/     {400, -1, -1},
/*02513*/     {0, -1, -1},
/*02514*/     {402, -1, -1},
/*02515*/     {0, -1, -1},
/*02516*/     {403, -1, -1},
/*02517*/     {0, -1, -1},
/*02518*/     {404, -1, -1},
/*02519*/     {0, -1, -1},
/*02520*/     {403, -1, -1},
/*02521*/     {0, -1, -1},
/*02522*/     {405, -1, -1},
/*02523*/     {0, -1, -1},
/*02524*/     {406, -1, -1},
/*02525*/     {0, -1, -1},
/*02526*/     {407, -1, -1},
/*02527*/     {0, -1, -1},
/*02528*/     {406, -1, -1},
/*02529*/     {0, -1, -1},
/*02530*/     {408, -1, -1},
/*02531*/     {0, -1, -1},
/*02532*/     {409, -1, -1},
/*02533*/     {0, -1, -1},
/*02534*/     {410, -1, -1},
/*02535*/     {0, -1, -1},
/*02536*/     {409, -1, -1},
/*02537*/     {0, -1, -1},
/*02538*/     {411, -1, -1},
/*02539*/     {0, -1, -1},
/*02540*/     {412, -1, -1},
/*02541*/     {0, -1, -1},
/*02542*/     {413, -1, -1},
/*02543*/     {0, -1, -1},
/*02544*/     {412, -1, -1},
/*02545*/     {0, -1, -1},
/*02546*/     {414, -1, -1},
/*02547*/     {0, -1, -1},
/*02548*/     {415, -1, -1},
/*02549*/     {0, -1, -1},
/*02550*/     {416, -1, -1},
/*02551*/     {0, -1, -1},
/*02552*/     {415, -1, -1},
/*02553*/     {0, -1, -1},
/*02554*/     {417, -1, -1},
/*02555*/     {0, -1, -1},
/*02556*/     {418, -1, -1},
/*02557*/     {0, -1, -1},
/*02558*/     {419, -1, -1},
/*02559*/     {0, -1, -1},
/*02560*/     {418, -1, -1},
/*02561*/     {0, -1, -1},
/*02562*/     {420, -1, -1},
/*02563*/     {0, -1, -1},
/*02564*/     {421, -1, -1},
/*02565*/     {0, -1, -1},
/*02566*/     {422, -1, -1},
/*02567*/     {0, -1, -1},
/*02568*/     {421, -1, -1},
/*02569*/     {0, -1, -1},
/*02570*/     {423, -1, -1},
/*02571*/     {0, -1, -1},
/*02572*/     {424, -1, -1},
/*02573*/     {0, -1, -1},
/*02574*/     {425, -1, -1},
/*02575*/     {0, -1, -1},
/*02576*/     {424, -1, -1},
/*02577*/     {0, -1, -1},
/*02578*/     {426, -1, -1},
/*02579*/     {0, -1, -1},
/*02580*/     {427, -1, -1},
/*02581*/     {0, -1, -1},
/*02582*/     {428, -1, -1},
/*02583*/     {0, -1, -1},
/*02584*/     {427, -1, -1},
/*02585*/     {0, -1, -1},
/*02586*/     {429, -1, -1},
/*02587*/     {0, -1, -1},
/*02588*/     {430, -1, -1},
/*02589*/     {0, -1, -1},
/*02590*/     {431, -1, -1},
/*02591*/     {0, -1, -1},
/*02592*/     {430, -1, -1},
/*02593*/     {0, -1, -1},
/*02594*/     {432, -1, -1},
/*02595*/     {0, -1, -1},
/*02596*/     {433, -1, -1},
/*02597*/     {0, -1, -1},
/*02598*/     {434, -1, -1},
/*02599*/     {0, -1, -1},
/*02600*/     {433, -1, -1},
/*02601*/     {0, -1, -1},
/*02602*/     {435, -1, -1},
/*02603*/     {0, -1, -1},
/*02604*/     {436, -1, -1},
/*02605*/     {0, -1, -1},
/*02606*/     {437, -1, -1},
/*02607*/     {0, -1, -1},
/*02608*/     {436, -1, -1},
/*02609*/     {0, -1, -1},
/*02610*/     {438, -1, -1},
/*02611*/     {0, -1, -1},
/*02612*/     {439, -1, -1},
/*02613*/     {0, -1, -1},
/*02614*/     {440, -1, -1},
/*02615*/     {0, -1, -1},
/*02616*/     {439, -1, -1},
/*02617*/     {0, -1, -1},
/*02618*/     {441, -1, -1},
/*02619*/     {0, -1, -1},
/*02620*/     {442, -1, -1},
/*02621*/     {0, -1, -1},
/*02622*/     {443, -1, -1},
/*02623*/     {0, -1, -1},
/*02624*/     {442, -1, -1},
/*02625*/     {0, -1, -1},
/*02626*/     {444, -1, -1},
/*02627*/     {0, -1, -1},
/*02628*/     {2644, 12, 1},
/*02629*/     {2646, 12, 1},
/*02630*/     {2648, 12, 1},
/*02631*/     {2650, 12, 1},
/*02632*/     {2652, 12, 1},
/*02633*/     {2654, 12, 1},
/*02634*/     {2656, 12, 1},
/*02635*/     {2658, 12, 1},
/*02636*/     {2660, 12, 1},
/*02637*/     {2662, 12, 1},
/*02638*/     {2664, 12, 1},
/*02639*/     {2666, 12, 1},
/*02640*/     {2668, 12, 1},
/*02641*/     {2670, 12, 1},
/*02642*/     {2672, 12, 1},
/*02643*/     {2674, 12, 1},
/*02644*/     {1374, -1, -1},
/*02645*/     {1390, -1, -1},
/*02646*/     {1382, -1, -1},
/*02647*/     {1398, -1, -1},
/*02648*/     {1375, -1, -1},
/*02649*/     {1391, -1, -1},
/*02650*/     {1383, -1, -1},
/*02651*/     {1399, -1, -1},
/*02652*/     {1376, -1, -1},
/*02653*/     {1392, -1, -1},
/*02654*/     {1384, -1, -1},
/*02655*/     {1400, -1, -1},
/*02656*/     {1377, -1, -1},
/*02657*/     {1393, -1, -1},
/*02658*/     {1385, -1, -1},
/*02659*/     {1401, -1, -1},
/*02660*/     {1378, -1, -1},
/*02661*/     {1394, -1, -1},
/*02662*/     {1386, -1, -1},
/*02663*/     {1402, -1, -1},
/*02664*/     {1379, -1, -1},
/*02665*/     {1395, -1, -1},
/*02666*/     {1387, -1, -1},
/*02667*/     {1403, -1, -1},
/*02668*/     {1380, -1, -1},
/*02669*/     {1396, -1, -1},
/*02670*/     {1388, -1, -1},
/*02671*/     {1404, -1, -1},
/*02672*/     {1381, -1, -1},
/*02673*/     {1397, -1, -1},
/*02674*/     {1389, -1, -1},
/*02675*/     {1405, -1, -1},
/*02676*/     {2684, 6, 3},
/*02677*/     {2704, 6, 3},
/*02678*/     {2724, 6, 3},
/*02679*/     {2744, 6, 3},
/*02680*/     {2764, 6, 3},
/*02681*/     {2784, 6, 3},
/*02682*/     {2804, 6, 3},
/*02683*/     {2824, 6, 3},
/*02684*/     {2692, 12, 1},
/*02685*/     {0, -1, -1},
/*02686*/     {2694, 12, 1},
/*02687*/     {2696, 12, 1},
/*02688*/     {0, -1, -1},
/*02689*/     {2698, 12, 1},
/*02690*/     {2700, 12, 1},
/*02691*/     {2702, 12, 1},
/*02692*/     {1120, -1, -1},
/*02693*/     {1121, -1, -1},
/*02694*/     {1136, -1, -1},
/*02695*/     {1137, -1, -1},
/*02696*/     {1152, -1, -1},
/*02697*/     {1153, -1, -1},
/*02698*/     {1168, -1, -1},
/*02699*/     {1169, -1, -1},
/*02700*/     {1184, -1, -1},
/*02701*/     {1185, -1, -1},
/*02702*/     {1200, -1, -1},
/*02703*/     {1201, -1, -1},
/*02704*/     {2712, 12, 1},
/*02705*/     {0, -1, -1},
/*02706*/     {2714, 12, 1},
/*02707*/     {2716, 12, 1},
/*02708*/     {0, -1, -1},
/*02709*/     {2718, 12, 1},
/*02710*/     {2720, 12, 1},
/*02711*/     {2722, 12, 1},
/*02712*/     {1122, -1, -1},
/*02713*/     {1123, -1, -1},
/*02714*/     {1138, -1, -1},
/*02715*/     {1139, -1, -1},
/*02716*/     {1154, -1, -1},
/*02717*/     {1155, -1, -1},
/*02718*/     {1170, -1, -1},
/*02719*/     {1171, -1, -1},
/*02720*/     {1186, -1, -1},
/*02721*/     {1187, -1, -1},
/*02722*/     {1202, -1, -1},
/*02723*/     {1203, -1, -1},
/*02724*/     {2732, 12, 1},
/*02725*/     {0, -1, -1},
/*02726*/     {2734, 12, 1},
/*02727*/     {2736, 12, 1},
/*02728*/     {0, -1, -1},
/*02729*/     {2738, 12, 1},
/*02730*/     {2740, 12, 1},
/*02731*/     {2742, 12, 1},
/*02732*/     {1124, -1, -1},
/*02733*/     {1125, -1, -1},
/*02734*/     {1140, -1, -1},
/*02735*/     {1141, -1, -1},
/*02736*/     {1156, -1, -1},
/*02737*/     {1157, -1, -1},
/*02738*/     {1172, -1, -1},
/*02739*/     {1173, -1, -1},
/*02740*/     {1188, -1, -1},
/*02741*/     {1189, -1, -1},
/*02742*/     {1204, -1, -1},
/*02743*/     {1205, -1, -1},
/*02744*/     {2752, 12, 1},
/*02745*/     {0, -1, -1},
/*02746*/     {2754, 12, 1},
/*02747*/     {2756, 12, 1},
/*02748*/     {0, -1, -1},
/*02749*/     {2758, 12, 1},
/*02750*/     {2760, 12, 1},
/*02751*/     {2762, 12, 1},
/*02752*/     {1126, -1, -1},
/*02753*/     {1127, -1, -1},
/*02754*/     {1142, -1, -1},
/*02755*/     {1143, -1, -1},
/*02756*/     {1158, -1, -1},
/*02757*/     {1159, -1, -1},
/*02758*/     {1174, -1, -1},
/*02759*/     {1175, -1, -1},
/*02760*/     {1190, -1, -1},
/*02761*/     {1191, -1, -1},
/*02762*/     {1206, -1, -1},
/*02763*/     {1207, -1, -1},
/*02764*/     {2772, 12, 1},
/*02765*/     {0, -1, -1},
/*02766*/     {2774, 12, 1},
/*02767*/     {2776, 12, 1},
/*02768*/     {0, -1, -1},
/*02769*/     {2778, 12, 1},
/*02770*/     {2780, 12, 1},
/*02771*/     {2782, 12, 1},
/*02772*/     {1128, -1, -1},
/*02773*/     {1129, -1, -1},
/*02774*/     {1144, -1, -1},
/*02775*/     {1145, -1, -1},
/*02776*/     {1160, -1, -1},
/*02777*/     {1161, -1, -1},
/*02778*/     {1176, -1, -1},
/*02779*/     {1177, -1, -1},
/*02780*/     {1192, -1, -1},
/*02781*/     {1193, -1, -1},
/*02782*/     {1208, -1, -1},
/*02783*/     {1209, -1, -1},
/*02784*/     {2792, 12, 1},
/*02785*/     {0, -1, -1},
/*02786*/     {2794, 12, 1},
/*02787*/     {2796, 12, 1},
/*02788*/     {0, -1, -1},
/*02789*/     {2798, 12, 1},
/*02790*/     {2800, 12, 1},
/*02791*/     {2802, 12, 1},
/*02792*/     {1130, -1, -1},
/*02793*/     {1131, -1, -1},
/*02794*/     {1146, -1, -1},
/*02795*/     {1147, -1, -1},
/*02796*/     {1162, -1, -1},
/*02797*/     {1163, -1, -1},
/*02798*/     {1178, -1, -1},
/*02799*/     {1179, -1, -1},
/*02800*/     {1194, -1, -1},
/*02801*/     {1195, -1, -1},
/*02802*/     {1210, -1, -1},
/*02803*/     {1211, -1, -1},
/*02804*/     {2812, 12, 1},
/*02805*/     {0, -1, -1},
/*02806*/     {2814, 12, 1},
/*02807*/     {2816, 12, 1},
/*02808*/     {0, -1, -1},
/*02809*/     {2818, 12, 1},
/*02810*/     {2820, 12, 1},
/*02811*/     {2822, 12, 1},
/*02812*/     {1132, -1, -1},
/*02813*/     {1133, -1, -1},
/*02814*/     {1148, -1, -1},
/*02815*/     {1149, -1, -1},
/*02816*/     {1164, -1, -1},
/*02817*/     {1165, -1, -1},
/*02818*/     {1180, -1, -1},
/*02819*/     {1181, -1, -1},
/*02820*/     {1196, -1, -1},
/*02821*/     {1197, -1, -1},
/*02822*/     {1212, 