        //
                // If the read capacity fails, set the geometry to reasonable parameter
                // so things don't fail at unexpected places.  Zero the geometry
                // except for the bytes per sector and sector shift.
                //

                /*
                 *  This request can sometimes fail legitimately
                 *  (e.g. when a SCSI device is attached but turned off)
                 *  so this is not necessarily a device/driver bug.
                 */
                DBGTRACE(ClassDebugWarning, ("ClassReadDriveCapacity on Fdo %xh failed with status %xh.", Fdo, status));

                /*
                 *  Write in a default disk geometry which we HOPE is right (??).
                 *      BUGBUG !!
                 */
                RtlZeroMemory(&fdoExt->DiskGeometry, sizeof(DISK_GEOMETRY));
                fdoExt->DiskGeometry.BytesPerSector = 512;
                fdoExt->SectorShift = 9;
                fdoExt->CommonExtension.PartitionLength.QuadPart = (LONGLONG) 0;

                /*
                 *  Is this removable or fixed media
                 */
                if (TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)){
                    fdoExt->DiskGeometry.MediaType = RemovableMedia;
                }
                else {
                    fdoExt->DiskGeometry.MediaType = FixedMedia;
                }
            }

        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        FreeDeviceInputMdl(driveCapMdl);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


/*++////////////////////////////////////////////////////////////////////////////

ClassSendStartUnit()

Routine Description:

    Send command to SCSI unit to start or power up.
    Because this command is issued asynchronounsly, that is, without
    waiting on it to complete, the IMMEDIATE flag is not set. This
    means that the CDB will not return until the drive has powered up.
    This should keep subsequent requests from being submitted to the
    device before it has completely spun up.

    This routine is called from the InterpretSense routine, when a
    request sense returns data indicating that a drive must be
    powered up.

    This routine may also be called from a class driver's error handler,
    or anytime a non-critical start device should be sent to the device.

Arguments:

    Fdo - The functional device object for the stopped device.

Return Value:

    None.

--*/
VOID
ClassSendStartUnit(
    IN PDEVICE_OBJECT Fdo
    )
{
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCOMPLETION_CONTEXT context;
    PCDB cdb;

    //
    // Allocate Srb from nonpaged pool.
    //

    context = ExAllocatePoolWithTag(NonPagedPool,
                             sizeof(COMPLETION_CONTEXT),
                             '6CcS');

    if(context == NULL) {

        //
        // ISSUE-2000/02/03-peterwie
        // This code path was inheritted from the NT 4.0 class2.sys driver.
        // It needs to be changed to survive low-memory conditions.
        //

        KeBugCheck(SCSI_DISK_DRIVER_INTERNAL);
    }

    //
    // Save the device object in the context for use by the completion
    // routine.
    //

    context->DeviceObject = Fdo;
    srb = &context->Srb;

    //
    // Zero out srb.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Write length to SRB.
    //

    srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Set timeout value large enough for drive to spin up.
    //

    srb->TimeOutValue = START_UNIT_TIMEOUT;

    //
    // Set the transfer length.
    //

    srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER |
                    SRB_FLAGS_DISABLE_AUTOSENSE |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

    //
    // Build the start unit CDB.
    //

    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;

    cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb->START_STOP.Start = 1;
    cdb->START_STOP.Immediate = 0;
    cdb->START_STOP.LogicalUnitNumber = srb->Lun;

    //
    // Build the asynchronous request to be sent to the port driver.
    // Since this routine is called from a DPC the IRP should always be
    // available.
    //

    irp = IoAllocateIrp(Fdo->StackSize, FALSE);

    if(irp == NULL) {

        //
        // ISSUE-2000/02/03-peterwie
        // This code path was inheritted from the NT 4.0 class2.sys driver.
        // It needs to be changed to survive low-memory conditions.
        //

        KeBugCheck(SCSI_DISK_DRIVER_INTERNAL);

    }

    ClassAcquireRemoveLock(Fdo, irp);

    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE)ClassAsynchronousCompletion,
                           context,
                           TRUE,
                           TRUE,
                           TRUE);

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MajorFunction = IRP_MJ_SCSI;
    srb->OriginalRequest = irp;

    //
    // Store the SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = srb;

    //
    // Call the port driver with the IRP.
    //

    IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    return;

} // end StartUnit()

/*++////////////////////////////////////////////////////////////////////////////

ClassAsynchronousCompletion() ISSUE-2000/02/18-henrygab - why public?!

Routine Description:

    This routine is called when an asynchronous I/O request
    which was issused by the class driver completes.  Examples of such requests
    are release queue or START UNIT. This routine releases the queue if
    necessary.  It then frees the context and the IRP.

Arguments:

    DeviceObject - The device object for the logical unit; however since this
        is the top stack location the value is NULL.

    Irp - Supplies a pointer to the Irp to be processed.

    Context - Supplies the context to be used to process this request.

Return Value:

    None.

--*/
NTSTATUS
ClassAsynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PCOMPLETION_CONTEXT context = Context;
    PSCSI_REQUEST_BLOCK srb;

    if(DeviceObject == NULL) {

        DeviceObject = context->DeviceObject;
    }

    srb = &context->Srb;

    //
    // If this is an execute srb, then check the return status and make sure.
    // the queue is not frozen.
    //

    if (srb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

        //
        // Check for a frozen queue.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            //
            // Unfreeze the queue getting the device object from the context.
            //

            ClassReleaseQueue(context->DeviceObject);
        }
    }

    { // free port-allocated sense buffer if we can detect

        if (((PCOMMON_DEVICE_EXTENSION)(DeviceObject->DeviceExtension))->IsFdo) {

            PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
            if (PORT_ALLOCATED_SENSE(fdoExtension, srb)) {
                FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, srb);
            }

        } else {

            ASSERT(!TEST_FLAG(srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));

        }
    }


    //
    // Free the context and the Irp.
    //

    if (Irp->MdlAddress != NULL) {
        MmUnlockPages(Irp->MdlAddress);
        IoFreeMdl(Irp->MdlAddress);

        Irp->MdlAddress = NULL;
    }

    ClassReleaseRemoveLock(DeviceObject, Irp);

    ExFreePool(context);
    IoFreeIrp(Irp);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // end ClassAsynchronousCompletion()



VOID ServiceTransferRequest(PDEVICE_OBJECT Fdo, PIRP Irp)
{
    PCOMMON_DEVICE_EXTENSION commonExt = Fdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PSTORAGE_ADAPTER_DESCRIPTOR adapterDesc = commonExt->PartitionZeroExtension->AdapterDescriptor;
    PIO_STACK_LOCATION currentSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG entireXferLen = currentSp->Parameters.Read.Length;
    PUCHAR bufPtr = MmGetMdlVirtualAddress(Irp->MdlAddress);
    LARGE_INTEGER targetLocation = currentSp->Parameters.Read.ByteOffset;
    PTRANSFER_PACKET pkt;
    SINGLE_LIST_ENTRY pktList;
    PSINGLE_LIST_ENTRY slistEntry;
    ULONG numPackets;
    KIRQL oldIrql;
    ULONG i;

    /*
     *  Compute the number of hw xfers we'll have to do.
     *  Calculate this without allowing for an overflow condition.
     */
    ASSERT(fdoData->HwMaxXferLen >= PAGE_SIZE);
    numPackets = entireXferLen/fdoData->HwMaxXferLen;
    if (entireXferLen % fdoData->HwMaxXferLen){
        numPackets++;
    }

    /*
     *  First get all the TRANSFER_PACKETs that we'll need at once.
     *  Use our 'simple' slist functions since we don't need interlocked.
     */
    SimpleInitSlistHdr(&pktList);
    for (i = 0; i < numPackets; i++){
        pkt = DequeueFreeTransferPacket(Fdo, TRUE);
        if (pkt){
            SimplePushSlist(&pktList, &pkt->SlistEntry);
        }
        else {
            break;
        }
    }

    if (i == numPackets){
        /*
         *  Initialize the original IRP's status to success.
         *  If any of the packets fail, they will set it to an error status.
         *  The IoStatus.Information field will be incremented to the
         *  transfer length as the pieces complete.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        /*
         *  Store the number of transfer pieces inside the original IRP.
         *  It will be used to count down the pieces as they complete.
         */
        Irp->Tail.Overlay.DriverContext[0] = LongToPtr(numPackets);

        /*
         *  We are proceeding with the transfer.
         *  Mark the client IRP pending since it may complete on a different thread.
         */
        IoMarkIrpPending(Irp);

        /*
         *  Transmit the pieces of the transfer.
         */
        while (entireXferLen > 0){
            ULONG thisPieceLen = MIN(fdoData->HwMaxXferLen, entireXferLen);

            /*
             *  Set up a TRANSFER_PACKET for this piece and send it.
             */
            slistEntry = SimplePopSlist(&pktList);
            ASSERT(slistEntry);
            pkt = CONTAINING_RECORD(slistEntry, TRANSFER_PACKET, SlistEntry);
            SetupReadWriteTransferPacket(   pkt,
                                        bufPtr,
                                        thisPieceLen,
                                        targetLocation,
                                        Irp);
            SubmitTransferPacket(pkt);

            entireXferLen -= thisPieceLen;
            bufPtr += thisPieceLen;
            targetLocation.QuadPart += thisPieceLen;
        }
        ASSERT(SimpleIsSlistEmpty(&pktList));
    }
    else if (i >= 1){
        /*
         *  We were unable to get all the TRANSFER_PACKETs we need,
         *  but we did get at least one.
         *  That means that we are in extreme low-memory stress.
         *  We'll try doing this transfer using a single packet.
         *  The port driver is certainly also in stress, so use one-page
         *  transfers.
         */

        /*
         *  Free all but one of the TRANSFER_PACKETs.
         */
        while (i-- > 1){
            slistEntry = SimplePopSlist(&pktList);
            ASSERT(slistEntry);
            pkt = CONTAINING_RECORD(slistEntry, TRANSFER_PACKET, SlistEntry);
            EnqueueFreeTransferPacket(Fdo, pkt);
        }

        /*
         *  Get the single TRANSFER_PACKET that we'll be using.
         */
        slistEntry = SimplePopSlist(&pktList);
        ASSERT(slistEntry);
        ASSERT(SimpleIsSlistEmpty(&pktList));
        pkt = CONTAINING_RECORD(slistEntry, TRANSFER_PACKET, SlistEntry);
        DBGWARN(("Insufficient packets available in ServiceTransferRequest - entering lowMemRetry with pkt=%xh.", pkt));

        /*
         *  Set default status and the number of transfer packets (one)
         *  inside the original irp.
         */
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        Irp->Tail.Overlay.DriverContext[0] = LongToPtr(1);

        /*
         *  Mark the client irp pending since it may complete on
         *  another thread.
         */
        IoMarkIrpPending(Irp);

        /*
         *  Set up the TRANSFER_PACKET for a lowMem transfer and launch.
         */
        SetupReadWriteTransferPacket(  pkt,
                                    bufPtr,
                                    entireXferLen,
                                    targetLocation,
                                    Irp);
        InitLowMemRetry(pkt, bufPtr, entireXferLen, targetLocation);
        StepLowMemRetry(pkt);
    }
    else {
        /*
         *  We were unable to get ANY TRANSFER_PACKETs.
         *  Defer this client irp until some TRANSFER_PACKETs free up.
         */
        DBGWARN(("No packets available in ServiceTransferRequest - deferring transfer (Irp=%xh)...", Irp));
        IoMarkIrpPending(Irp);
        EnqueueDeferredClientIrp(fdoData, Irp);
    }

}


/*++////////////////////////////////////////////////////////////////////////////

ClassIoComplete()

Routine Description:

    This routine executes when the port driver has completed a request.
    It looks at the SRB status in the completing SRB and if not success
    it checks for valid request sense buffer information. If valid, the
    info is used to update status with more precise message of type of
    error. This routine deallocates the SRB.

    This routine should only be placed on the stack location for a class
    driver FDO.

Arguments:

    Fdo - Supplies the device object which represents the logical
        unit.

    Irp - Supplies the Irp which has completed.

    Context - Supplies a pointer to the SRB.

Return Value:

    NT status

--*/
NTSTATUS
ClassIoComplete(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = Context;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExtension->PrivateFdoData;
    NTSTATUS status;
    BOOLEAN retry;
    BOOLEAN callStartNextPacket;

    ASSERT(fdoExtension->CommonExtension.IsFdo);

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {
        ULONG retryInterval;

        DebugPrint((2, "ClassIoComplete: IRP %p, SRB %p\n", Irp, srb));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(Fdo);
        }

        retry = ClassInterpretSenseInfo(
                    Fdo,
                    srb,
                    irpStack->MajorFunction,
                    irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL ?
                     irpStack->Parameters.DeviceIoControl.IoControlCode :
                     0,
                    MAXIMUM_RETRIES -
                        ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4),
                    &status,
                    &retryInterval);

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (TEST_FLAG(irpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME) &&
            status == STATUS_VERIFY_REQUIRED) {

            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry && ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4)--) {

            //
            // Retry request.
            //

            DebugPrint((1, "Retry request %p\n", Irp));

            if (PORT_ALLOCATED_SENSE(fdoExtension, srb)) {
                FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, srb);
            }

            RetryRequest(Fdo, Irp, srb, FALSE, retryInterval);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

    } else {

        //
        // Set status for successful request
        //
        fdoData->LoggedTURFailureSinceLastIO = FALSE;
        ClasspPerfIncrementSuccessfulIo(fdoExtension);
        status = STATUS_SUCCESS;
    } // end if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS)


    //
    // ensure we have returned some info, and it matches what the
    // original request wanted for PAGING operations only
    //

    if ((NT_SUCCESS(status)) && TEST_FLAG(Irp->Flags, IRP_PAGING_IO)) {
        ASSERT(Irp->IoStatus.Information != 0);
        ASSERT(irpStack->Parameters.Read.Length == Irp->IoStatus.Information);
    }

    //
    // remember if the caller wanted to skip calling IoStartNextPacket.
    // for legacy reasons, we cannot call IoStartNextPacket for IoDeviceControl
    // calls.  this setting only affects device objects with StartIo routines.
    //

    callStartNextPacket = !TEST_FLAG(srb->SrbFlags, SRB_FLAGS_DONT_START_NEXT_PACKET);
    if (irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        callStartNextPacket = FALSE;
    }

    //
    // Free the srb
    //

    if(!TEST_FLAG(srb->SrbFlags, SRB_CLASS_FLAGS_PERSISTANT)) {

        if (PORT_ALLOCATED_SENSE(fdoExtension, srb)) {
            FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, srb);
        }

        if (fdoExtension->CommonExtension.IsSrbLookasideListInitialized){
            ClassFreeOrReuseSrb(fdoExtension, srb);
        }
        else {
            DBGWARN(("ClassIoComplete is freeing an SRB (possibly) on behalf of another driver."));
            ExFreePool(srb);
        }

    } else {

        DebugPrint((2, "ClassIoComplete: Not Freeing srb @ %p because "
                    "SRB_CLASS_FLAGS_PERSISTANT set\n", srb));
        if (PORT_ALLOCATED_SENSE(fdoExtension, srb)) {
            DebugPrint((2, "ClassIoComplete: Not Freeing sensebuffer @ %p "
                        " because SRB_CLASS_FLAGS_PERSISTANT set\n",
                        srb->SenseInfoBuffer));
        }

    }

    //
    // Set status in completing IRP.
    //

    Irp->IoStatus.Status = status;

    //
    // Set the hard error if necessary.
    //

    if (!NT_SUCCESS(status) &&
        IoIsErrorUserInduced(status) &&
        (Irp->Tail.Overlay.Thread != NULL)
        ) {

        //
        // Store DeviceObject for filesystem, and clear
        // in IoStatus.Information field.
        //

        IoSetHardErrorOrVerifyDevice(Irp, Fdo);
        Irp->IoStatus.Information = 0;
    }

    //
    // If pending has be returned for this irp then mark the current stack as
    // pending.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    if (fdoExtension->CommonExtension.DriverExtension->InitData.ClassStartIo) {
        if (callStartNextPacket) {
            KIRQL oldIrql;
            KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
            IoStartNextPacket(Fdo, FALSE);
            KeLowerIrql(oldIrql);
        }
    }

    ClassReleaseRemoveLock(Fdo, Irp);

    return status;

} // end ClassIoComplete()


/*++////////////////////////////////////////////////////////////////////////////

ClassSendSrbSynchronous()

Routine Description:

    This routine is called by SCSI device controls to complete an
    SRB and send it to the port driver synchronously (ie wait for
    completion). The CDB is already completed along with the SRB CDB
    size and request timeout value.

Arguments:

    Fdo - Supplies the functional device object which represents the target.

    Srb - Supplies a partially initialized SRB. The SRB cannot come from zone.

    BufferAddress - Supplies the address of the buffer.

    BufferLength - Supplies the length in bytes of the buffer.

    WriteToDevice - Indicates the data should be transfer to the device.

Return Value:

    NTSTATUS indicating the final results of the operation.

    If NT_SUCCESS(), then the amount of usable data is contained in the field
       Srb->DataTransferLength

--*/
NTSTATUS
ClassSendSrbSynchronous(
    PDEVICE_OBJECT Fdo,
    PSCSI_REQUEST_BLOCK Srb,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    )
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExtension->PrivateFdoData;
    IO_STATUS_BLOCK ioStatus;
    ULONG controlType;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT event;
    PUCHAR senseInfoBuffer;
    ULONG retryCount = MAXIMUM_RETRIES;
    NTSTATUS status;
    BOOLEAN retry;

    //
    // NOTE: This code is only pagable because we are not freezing
    //       the queue.  Allowing the queue to be frozen from a pagable
    //       routine could leave the queue frozen as we try to page in
    //       the code to unfreeze the queue.  The result would be a nice
    //       case of deadlock.  Therefore, since we are unfreezing the
    //       queue regardless of the result, just set the NO_FREEZE_QUEUE
    //       flag in the SRB.
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    ASSERT(fdoExtension->CommonExtension.IsFdo);

    //
    // Write length to SRB.
    //

    Srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set SCSI bus address.
    //

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Enable auto request sense.
    //

    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Sense buffer is in aligned nonpaged pool.
    //
        //
    senseInfoBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     SENSE_BUFFER_SIZE,
                                     '7CcS');

    if (senseInfoBuffer == NULL) {

        DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate request sense "
                       "buffer\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Srb->SenseInfoBuffer = senseInfoBuffer;
    Srb->DataBuffer = BufferAddress;

    //
    // Start retries here.
    //

retry:

    //
    // use fdoextension's flags by default.
    // do not move out of loop, as the flag may change due to errors
    // sending this command.
    //

    Srb->SrbFlags = fdoExtension->SrbFlags;

    if(BufferAddress != NULL) {
        if(WriteToDevice) {
            SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_OUT);
        } else {
            SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_IN);
        }
    }

    //
    // Initialize the QueueAction field.
    //

    Srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Disable synchronous transfer for these requests.
    // Disable freezing the queue, since all we do is unfreeze it anyways.
    //

    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Build device I/O control request with METHOD_NEITHER data transfer.
    // We'll queue a completion routine to cleanup the MDL's and such ourself.
    //

    irp = IoAllocateIrp(
            (CCHAR) (fdoExtension->CommonExtension.LowerDeviceObject->StackSize + 1),
            FALSE);

    if(irp == NULL) {
        ExFreePool(senseInfoBuffer);
        DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate Irp\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Get next stack location.
    //

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set up SRB for execute scsi request. Save SRB address in next stack
    // for the port driver.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->Parameters.Scsi.Srb = Srb;

    IoSetCompletionRoutine(irp,
                           ClasspSendSynchronousCompletion,
                           Srb,
                           TRUE,
                           TRUE,
                           TRUE);

    irp->UserIosb = &ioStatus;
    irp->UserEvent = &event;

    if(BufferAddress) {
        //
        // Build an MDL for the data buffer and stick it into the irp.  The
        // completion routine will unlock the pages and free the MDL.
        //

        irp->MdlAddress = IoAllocateMdl( BufferAddress,
                                         BufferLength,
                                         FALSE,
                                         FALSE,
                                         irp );
        if (irp->MdlAddress == NULL) {
            ExFreePool(senseInfoBuffer);
            Srb->SenseInfoBuffer = NULL;
            IoFreeIrp( irp );
            DebugPrint((1, "ClassSendSrbSynchronous: Can't allocate MDL\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        try {

            //
            // the io manager unlocks these pages upon completion
            //

            MmProbeAndLockPages( irp->MdlAddress,
                                 KernelMode,
                                 (WriteToDevice ? IoReadAccess :
                                                  IoWriteAccess));

        } except(EXCEPTION_EXECUTE_HANDLER) {
            status = GetExceptionCode();

            ExFreePool(senseInfoBuffer);
            Srb->SenseInfoBuffer = NULL;
            IoFreeMdl(irp->MdlAddress);
            IoFreeIrp(irp);

            DebugPrint((1, "ClassSendSrbSynchronous: Exception %lx "
                           "locking buffer\n", status));
            return status;
        }
    }

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = BufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;
    Srb->NextSrb = 0;

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = irp;

    //
    // Call the port driver with the request and wait for it to complete.
    //

    status = IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // Check that request completed without error.
    //

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        DBGTRACE(ClassDebugWarning, ("ClassSendSrbSynchronous - srb %ph failed (op=%s srbstat=%s(%xh), irpstat=%xh, sense=%s/%s/%s)", Srb, DBGGETSCSIOPSTR(Srb), DBGGETSRBSTATUSSTR(Srb), (ULONG)Srb->SrbStatus, status, DBGGETSENSECODESTR(Srb), DBGGETADSENSECODESTR(Srb), DBGGETADSENSEQUALIFIERSTR(Srb)));

        //
        // assert that the queue is not frozen
        //

        ASSERT(!TEST_FLAG(Srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN));

        //
        // Update status and determine if request should be retried.
        //

        retry = ClassInterpretSenseInfo(Fdo,
                                        Srb,
                                        IRP_MJ_SCSI,
                                        0,
                                        MAXIMUM_RETRIES  - retryCount,
                                        &status,
                                        &retryInterval);


        if (retry) {

            if ((status == STATUS_DEVICE_NOT_READY &&
                 ((PSENSE_DATA) senseInfoBuffer)->AdditionalSenseCode ==
                                SCSI_ADSENSE_LUN_NOT_READY) ||
                (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT)) {

                LARGE_INTEGER delay;

                //
                // Delay for at least 2 seconds.
                //

                if(retryInterval < 2) {
                    retryInterval = 2;
                }

                delay.QuadPart = (LONGLONG)( - 10 * 1000 * (LONGLONG)1000 * retryInterval);

                //
                // Stall for a while to let the device become ready
                //

                KeDelayExecutionThread(KernelMode, FALSE, &delay);

            }

            //
            // If retries are not exhausted then retry this operation.
            //

            if (retryCount--) {

                if (PORT_ALLOCATED_SENSE(fdoExtension, Srb)) {
                    FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, Srb);
                }

                goto retry;
            }
        }

    } else {
        fdoData->LoggedTURFailureSinceLastIO = FALSE;
        status = STATUS_SUCCESS;
    }

    //
    // required even though we allocated our own, since the port driver may
    // have allocated one also
    //

    if (PORT_ALLOCATED_SENSE(fdoExtension, Srb)) {
        FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, Srb);
    }

    Srb->SenseInfoBuffer = NULL;
    ExFreePool(senseInfoBuffer);

    return status;
}


/*++////////////////////////////////////////////////////////////////////////////

ClassInterpretSenseInfo()

Routine Description:

    This routine interprets the data returned from the SCSI
    request sense. It determines the status to return in the
    IRP and whether this request can be retried.

Arguments:

    DeviceObject - Supplies the device object associated with this request.

    Srb - Supplies the scsi request block which failed.

    MajorFunctionCode - Supplies the function code to be used for logging.

    IoDeviceCode - Supplies the device code to be used for logging.

    Status - Returns the status for the request.

Return Value:

    BOOLEAN TRUE: Drivers should retry this request.
            FALSE: Drivers should not retry this request.

--*/
BOOLEAN
ClassInterpretSenseInfo(
    IN PDEVICE_OBJECT Fdo,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status,
    OUT OPTIONAL ULONG *RetryInterval
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExtension->PrivateFdoData;

    PSENSE_DATA       senseBuffer = Srb->SenseInfoBuffer;

    BOOLEAN           retry = TRUE;
    BOOLEAN           logError = FALSE;
    BOOLEAN           unhandledError = FALSE;
    BOOLEAN           incrementErrorCount = FALSE;

    ULONG             badSector = 0;
    ULONG             uniqueId = 0;

    NTSTATUS          logStatus;

    ULONG             readSector;
    ULONG             index;

    ULONG             retryInterval = 0;
    KIRQL oldIrql;


    logStatus = -1;

    if(TEST_FLAG(Srb->SrbFlags, SRB_CLASS_FLAGS_PAGING)) {

        //
        // Log anything remotely incorrect about paging i/o
        //

        logError = TRUE;
        uniqueId = 301;
        logStatus = IO_WARNING_PAGING_FAILURE;
    }

    //
    // Check that request sense buffer is valid.
    //

    ASSERT(fdoExtension->CommonExtension.IsFdo);


    //
    // must handle the SRB_STATUS_INTERNAL_ERROR case first,
    // as it has  all the flags set.
    //

    if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_INTERNAL_ERROR) {

        DebugPrint((ClassDebugSenseInfo,
                    "ClassInterpretSenseInfo: Internal Error code is %x\n",
                    Srb->InternalStatus));

        retry = FALSE;
        *Status = Srb->InternalStatus;

    } else if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
        (Srb->SenseInfoBufferLength >=
            offsetof(SENSE_DATA, CommandSpecificInformation))) {

        //
        // Zero the additional sense code and additional sense code qualifier
        // if they were not returned by the device.
        //

        readSector = senseBuffer->AdditionalSenseLength +
            offsetof(SENSE_DATA, AdditionalSenseLength);

        if (readSector > Srb->SenseInfoBufferLength) {
            readSector = Srb->SenseInfoBufferLength;
        }

        if (readSector <= offsetof(SENSE_DATA, AdditionalSenseCode)) {
            senseBuffer->AdditionalSenseCode = 0;
        }

        if (readSector <= offsetof(SENSE_DATA, AdditionalSenseCodeQualifier)) {
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }

        DebugPrint((ClassDebugSenseInfo,
                    "ClassInterpretSenseInfo: Error code is %x\n",
                    senseBuffer->ErrorCode));
        DebugPrint((ClassDebugSenseInfo,
                    "ClassInterpretSenseInfo: Sense key is %x\n",
                    senseBuffer->SenseKey));
        DebugPrint((ClassDebugSenseInfo,
                    "ClassInterpretSenseInfo: Additional sense code is %x\n",
                    senseBuffer->AdditionalSenseCode));
        DebugPrint((ClassDebugSenseInfo,
                    "ClassInterpretSenseInfo: Additional sense code qualifier "
                    "is %x\n",
                    senseBuffer->AdditionalSenseCodeQualifier));


        switch (senseBuffer->SenseKey & 0xf) {

        case SCSI_SENSE_NOT_READY: {

            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Device not ready\n"));
            *Status = STATUS_DEVICE_NOT_READY;

            switch (senseBuffer->AdditionalSenseCode) {

            case SCSI_ADSENSE_LUN_NOT_READY: {

                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Lun not ready\n"));

                switch (senseBuffer->AdditionalSenseCodeQualifier) {

                case SCSI_SENSEQ_OPERATION_IN_PROGRESS: {
                    DEVICE_EVENT_BECOMING_READY notReady;

                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Operation In Progress\n"));
                    retryInterval = NOT_READY_RETRY_INTERVAL;

                    RtlZeroMemory(&notReady, sizeof(DEVICE_EVENT_BECOMING_READY));
                    notReady.Version = 1;
                    notReady.Reason = 2;
                    notReady.Estimated100msToReady = retryInterval * 10;
                    ClasspSendNotification(fdoExtension,
                                           &GUID_IO_DEVICE_BECOMING_READY,
                                           sizeof(DEVICE_EVENT_BECOMING_READY),
                                           &notReady);

                    break;
                }

                case SCSI_SENSEQ_BECOMING_READY: {
                    DEVICE_EVENT_BECOMING_READY notReady;

                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "In process of becoming ready\n"));
                    retryInterval = NOT_READY_RETRY_INTERVAL;

                    RtlZeroMemory(&notReady, sizeof(DEVICE_EVENT_BECOMING_READY));
                    notReady.Version = 1;
                    notReady.Reason = 1;
                    notReady.Estimated100msToReady = retryInterval * 10;
                    ClasspSendNotification(fdoExtension,
                                           &GUID_IO_DEVICE_BECOMING_READY,
                                           sizeof(DEVICE_EVENT_BECOMING_READY),
                                           &notReady);
                    break;
                }

                case SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS: {
                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Long write in progress\n"));
                    retry = FALSE;
                    break;
                }

                case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED: {
                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Manual intervention required\n"));
                    *Status = STATUS_NO_MEDIA_IN_DEVICE;
                    retry = FALSE;
                    break;
                }

                case SCSI_SENSEQ_FORMAT_IN_PROGRESS: {
                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Format in progress\n"));
                    retry = FALSE;
                    break;
                }

                case SCSI_SENSEQ_CAUSE_NOT_REPORTABLE: {

                    if(!TEST_FLAG(fdoExtension->ScanForSpecialFlags,
                                 CLASS_SPECIAL_CAUSE_NOT_REPORTABLE_HACK)) {

                        DebugPrint((ClassDebugSenseInfo,
                                    "ClassInterpretSenseInfo: "
                                    "not ready, cause unknown\n"));
                        /*
                        Many non-WHQL certified drives (mostly CD-RW) return
                        this when they have no media instead of the obvious
                        choice of:

                        SCSI_SENSE_NOT_READY/SCSI_ADSENSE_NO_MEDIA_IN_DEVICE

                        These drives should not pass WHQL certification due
                        to this discrepency.

                        */
                        retry = FALSE;
                        break;

                    } else {

                        //
                        // Treat this as init command required and fall through.
                        //
                    }
                }

                case SCSI_SENSEQ_INIT_COMMAND_REQUIRED:
                default: {
                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Initializing command required\n"));

                    //
                    // This sense code/additional sense code
                    // combination may indicate that the device
                    // needs to be started.  Send an start unit if this
                    // is a disk device.
                    //

                    if(TEST_FLAG(fdoExtension->DeviceFlags,
                                 DEV_SAFE_START_UNIT) &&
                        !TEST_FLAG(Srb->SrbFlags,
                                   SRB_CLASS_FLAGS_LOW_PRIORITY)) {
                        ClassSendStartUnit(Fdo);
                    }
                    break;
                }


                } // end switch (senseBuffer->AdditionalSenseCodeQualifier)
                break;
            }

            case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "No Media in device.\n"));
                *Status = STATUS_NO_MEDIA_IN_DEVICE;
                retry = FALSE;

                //
                // signal MCN that there isn't any media in the device
                //
                if (!TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)) {
                    DebugPrint((ClassDebugError, "ClassInterpretSenseInfo: "
                                "No Media in a non-removable device %p\n",
                                Fdo));
                }
                ClassSetMediaChangeState(fdoExtension, MediaNotPresent, FALSE);

                break;
            }
            } // end switch (senseBuffer->AdditionalSenseCode)

            break;
        } // end SCSI_SENSE_NOT_READY

        case SCSI_SENSE_DATA_PROTECT: {
            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Media write protected\n"));
            *Status = STATUS_MEDIA_WRITE_PROTECTED;
            retry = FALSE;
            break;
        } // end SCSI_SENSE_DATA_PROTECT

        case SCSI_SENSE_MEDIUM_ERROR: {
            DebugPrint((ClassDebugSenseInfo,"ClassInterpretSenseInfo: "
                        "Medium Error (bad block)\n"));
            *Status = STATUS_DEVICE_DATA_ERROR;

            retry = FALSE;
            logError = TRUE;
            uniqueId = 256;
            logStatus = IO_ERR_BAD_BLOCK;

            //
            // Check if this error is due to unknown format
            //
            if (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_INVALID_MEDIA){

                switch (senseBuffer->AdditionalSenseCodeQualifier) {

                case SCSI_SENSEQ_UNKNOWN_FORMAT: {

                    *Status = STATUS_UNRECOGNIZED_MEDIA;

                    //
                    // Log error only if this is a paging request
                    //
                    if(!TEST_FLAG(Srb->SrbFlags, SRB_CLASS_FLAGS_PAGING)) {
                        logError = FALSE;
                    }
                    break;
                }

                case SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED: {

                    *Status = STATUS_CLEANER_CARTRIDGE_INSTALLED;
                    logError = FALSE;
                    break;

                }
                default: {
                    break;
                }
                } // end switch AdditionalSenseCodeQualifier

            } // end SCSI_ADSENSE_INVALID_MEDIA

            break;

        } // end SCSI_SENSE_MEDIUM_ERROR

        case SCSI_SENSE_HARDWARE_ERROR: {
            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Hardware error\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            logError = TRUE;
            uniqueId = 257;
            logStatus = IO_ERR_CONTROLLER_ERROR;
            break;
        } // end SCSI_SENSE_HARDWARE_ERROR

        case SCSI_SENSE_ILLEGAL_REQUEST: {

            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Illegal SCSI request\n"));
            *Status = STATUS_INVALID_DEVICE_REQUEST;
            retry = FALSE;

            switch (senseBuffer->AdditionalSenseCode) {

            case SCSI_ADSENSE_ILLEGAL_COMMAND: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Illegal command\n"));
                break;
            }

            case SCSI_ADSENSE_ILLEGAL_BLOCK: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Illegal block address\n"));
                *Status = STATUS_NONEXISTENT_SECTOR;
                break;
            }

            case SCSI_ADSENSE_INVALID_LUN: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Invalid LUN\n"));
                *Status = STATUS_NO_SUCH_DEVICE;
                break;
            }

            case SCSI_ADSENSE_MUSIC_AREA: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Music area\n"));
                break;
            }

            case SCSI_ADSENSE_DATA_AREA: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Data area\n"));
                break;
            }

            case SCSI_ADSENSE_VOLUME_OVERFLOW: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Volume overflow\n"));
                break;
            }

            case SCSI_ADSENSE_COPY_PROTECTION_FAILURE: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Copy protection failure\n"));

                *Status = STATUS_COPY_PROTECTION_FAILURE;

                switch (senseBuffer->AdditionalSenseCodeQualifier) {
                    case SCSI_SENSEQ_AUTHENTICATION_FAILURE:
                        DebugPrint((ClassDebugSenseInfo,
                                    "ClassInterpretSenseInfo: "
                                    "Authentication failure\n"));
                        *Status = STATUS_CSS_AUTHENTICATION_FAILURE;
                        break;
                    case SCSI_SENSEQ_KEY_NOT_PRESENT:
                        DebugPrint((ClassDebugSenseInfo,
                                    "ClassInterpretSenseInfo: "
                                    "Key not present\n"));
                        *Status = STATUS_CSS_KEY_NOT_PRESENT;
                        break;
                    case SCSI_SENSEQ_KEY_NOT_ESTABLISHED:
                        DebugPrint((ClassDebugSenseInfo,
                                    "ClassInterpretSenseInfo: "
                                    "Key not established\n"));
                        *Status = STATUS_CSS_KEY_NOT_ESTABLISHED;
                        break;
                    case SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION:
                        DebugPrint((ClassDebugSenseInfo,
                                    "ClassInterpretSenseInfo: "
                                    "Read of scrambled sector w/o "
                                    "authentication\n"));
                        *Status = STATUS_CSS_SCRAMBLED_SECTOR;
                        break;
                    case SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT:
                        DebugPrint((ClassDebugSenseInfo,
                                    "ClassInterpretSenseInfo: "
                                    "Media region does not logical unit "
                                    "region\n"));
                        *Status = STATUS_CSS_REGION_MISMATCH;
                        break;
                    case SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR:
                        DebugPrint((ClassDebugSenseInfo,
                                    "ClassInterpretSenseInfo: "
                                    "Region set error -- region may "
                                    "be permanent\n"));
                        *Status = STATUS_CSS_RESETS_EXHAUSTED;
                        break;
                } // end switch of ASCQ for COPY_PROTECTION_FAILURE

                break;
            }


            case SCSI_ADSENSE_INVALID_CDB: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Invalid CDB\n"));

                //
                // Note: the retry interval is not typically used.
                // it is set here only because a ClassErrorHandler
                // cannot set the retryInterval, and the error may
                // require a few commands to be sent to clear whatever
                // caused this condition (i.e. disk clears the write
                // cache, requiring at least two commands)
                //
                // hopefully, this shortcoming can be changed for
                // blackcomb.
                //

                retryInterval = 3;
                break;
            }

            } // end switch (senseBuffer->AdditionalSenseCode)

            break;
        } // end SCSI_SENSE_ILLEGAL_REQUEST

        case SCSI_SENSE_UNIT_ATTENTION: {

            PVPB vpb;
            ULONG count;

            //
            // A media change may have occured so increment the change
            // count for the physical device
            //

            count = InterlockedIncrement(&fdoExtension->MediaChangeCount);
            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Media change count for device %d incremented to %#lx\n",
                        fdoExtension->DeviceNumber, count));


            switch (senseBuffer->AdditionalSenseCode) {
            case SCSI_ADSENSE_MEDIUM_CHANGED: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Media changed\n"));

                if (!TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)) {
                    DebugPrint((ClassDebugError, "ClassInterpretSenseInfo: "
                                "Media Changed on non-removable device %p\n",
                                Fdo));
                }
                ClassSetMediaChangeState(fdoExtension, MediaPresent, FALSE);
                break;
            }

            case SCSI_ADSENSE_BUS_RESET: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Bus reset\n"));
                break;
            }

            case SCSI_ADSENSE_OPERATOR_REQUEST: {
                switch (senseBuffer->AdditionalSenseCodeQualifier) {

                case SCSI_SENSEQ_MEDIUM_REMOVAL: {
                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Ejection request received!\n"));
                    ClassSendEjectionNotification(fdoExtension);
                    break;
                }

                case SCSI_SENSEQ_WRITE_PROTECT_ENABLE: {
                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Operator selected write permit?! "
                                "(unsupported!)\n"));
                    break;
                }

                case SCSI_SENSEQ_WRITE_PROTECT_DISABLE: {
                    DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                                "Operator selected write protect?! "
                                "(unsupported!)\n"));
                    break;
                }

                }
            }

            default: {
                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Unit attention\n"));
                break;
            }

            } // end  switch (senseBuffer->AdditionalSenseCode)

            if (TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA))
            {
                //
                // TODO : Is the media lockable?
                //

                if ((ClassGetVpb(Fdo) != NULL) && (ClassGetVpb(Fdo)->Flags & VPB_MOUNTED))
                {
                    //
                    // Set bit to indicate that media may have changed
                    // and volume needs verification.
                    //

                    SET_FLAG(Fdo->Flags, DO_VERIFY_VOLUME);

                    *Status = STATUS_VERIFY_REQUIRED;
                    retry = FALSE;
                }
            }
            else
            {
                *Status = STATUS_IO_DEVICE_ERROR;
            }

            break;

        } // end SCSI_SENSE_UNIT_ATTENTION

        case SCSI_SENSE_ABORTED_COMMAND: {
            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Command aborted\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            retryInterval = 1;
            break;
        } // end SCSI_SENSE_ABORTED_COMMAND

        case SCSI_SENSE_BLANK_CHECK: {
            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Media blank check\n"));
            retry = FALSE;
            *Status = STATUS_NO_DATA_DETECTED;
            break;
        } // end SCSI_SENSE_BLANK_CHECK

        case SCSI_SENSE_RECOVERED_ERROR: {

            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Recovered error\n"));
            *Status = STATUS_SUCCESS;
            retry = FALSE;
            logError = TRUE;
            uniqueId = 258;

            switch(senseBuffer->AdditionalSenseCode) {
            case SCSI_ADSENSE_SEEK_ERROR:
            case SCSI_ADSENSE_TRACK_ERROR: {
                logStatus = IO_ERR_SEEK_ERROR;
                break;
            }

            case SCSI_ADSENSE_REC_DATA_NOECC:
            case SCSI_ADSENSE_REC_DATA_ECC: {
                logStatus = IO_RECOVERED_VIA_ECC;
                break;
            }

            case SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED: {
                UCHAR wmiEventData[5];

                *((PULONG)wmiEventData) = sizeof(UCHAR);
                wmiEventData[sizeof(ULONG)] = senseBuffer->AdditionalSenseCodeQualifier;

                //
                // Don't log another eventlog if we have already logged once
                // NOTE: this should have been interlocked, but the structure
                //       was publicly defined to use a BOOLEAN (char).  Since
                //       media only reports these errors once per X minutes,
                //       the potential race condition is nearly non-existant.
                //       the worst case is duplicate log entries, so ignore.
                //

                if (fdoExtension->FailurePredicted == 0) {
                    logError = TRUE;
                }
                fdoExtension->FailurePredicted = TRUE;
                fdoExtension->FailureReason = senseBuffer->AdditionalSenseCodeQualifier;
                logStatus = IO_WRN_FAILURE_PREDICTED;

                ClassNotifyFailurePredicted(fdoExtension,
                                            (PUCHAR)&wmiEventData,
                                            sizeof(wmiEventData),
                                            0,
                                            4,
                                            Srb->PathId,
                                            Srb->TargetId,
                                            Srb->Lun);
                break;
            }

            default: {
                logStatus = IO_ERR_CONTROLLER_ERROR;
                break;
            }

            } // end switch(senseBuffer->AdditionalSenseCode)

            if (senseBuffer->IncorrectLength) {

                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Incorrect length detected.\n"));
                *Status = STATUS_INVALID_BLOCK_LENGTH ;
            }

            break;
        } // end SCSI_SENSE_RECOVERED_ERROR

        case SCSI_SENSE_NO_SENSE: {

            //
            // Check other indicators.
            //

            if (senseBuffer->IncorrectLength) {

                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "Incorrect length detected.\n"));
                *Status = STATUS_INVALID_BLOCK_LENGTH ;
                retry   = FALSE;

            } else {

                DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                            "No specific sense key\n"));
                *Status = STATUS_IO_DEVICE_ERROR;
                retry   = TRUE;
            }

            break;
        } // end SCSI_SENSE_NO_SENSE

        default: {
            DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                        "Unrecognized sense code\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            break;
        }

        } // end switch (senseBuffer->SenseKey & 0xf)

        //
        // Try to determine the bad sector from the inquiry data.
        //

        if ((((PCDB)Srb->Cdb)->CDB10.OperationCode == SCSIOP_READ ||
            ((PCDB)Srb->Cdb)->CDB10.OperationCode == SCSIOP_VERIFY ||
            ((PCDB)Srb->Cdb)->CDB10.OperationCode == SCSIOP_WRITE)) {

            for (index = 0; index < 4; index++) {
                badSector = (badSector << 8) | senseBuffer->Information[index];
            }

            readSector = 0;
            for (index = 0; index < 4; index++) {
                readSector = (readSector << 8) | Srb->Cdb[index+2];
            }

            index = (((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8) |
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb;

            //
            // Make sure the bad sector is within the read sectors.
            //

            if (!(badSector >= readSector && badSector < readSector + index)) {
                badSector = readSector;
            }
        }

    } else {

        //
        // Request sense buffer not valid. No sense information
        // to pinpoint the error. Return general request fail.
        //

        DebugPrint((ClassDebugSenseInfo, "ClassInterpretSenseInfo: "
                    "Request sense info not valid. SrbStatus %2x\n",
                    SRB_STATUS(Srb->SrbStatus)));
        retry = TRUE;

        switch (SRB_STATUS(Srb->SrbStatus)) {
        case SRB_STATUS_INVALID_LUN:
        case SRB_STATUS_INVALID_TARGET_ID:
        case SRB_STATUS_NO_DEVICE:
        case SRB_STATUS_NO_HBA:
        case SRB_STATUS_INVALID_PATH_ID: {
            *Status = STATUS_NO_SUCH_DEVICE;
            retry = FALSE;
            break;
        }

        case SRB_STATUS_COMMAND_TIMEOUT:
        case SRB_STATUS_TIMEOUT: {

            //
            // Update the error count for the device.
            //

            incrementErrorCount = TRUE;
            *Status = STATUS_IO_TIMEOUT;
            break;
        }

        case SRB_STATUS_ABORTED: {

            //
            // Update the error count for the device.
            //

            incrementErrorCount = TRUE;
            *Status = STATUS_IO_TIMEOUT;
            retryInterval = 1;
            break;
        }


        case SRB_STATUS_SELECTION_TIMEOUT: {
            logError = TRUE;
            logStatus = IO_ERR_NOT_READY;
            uniqueId = 260;
            *Status = STATUS_DEVICE_NOT_CONNECTED;
            retry = FALSE;
            break;
        }

        case SRB_STATUS_DATA_OVERRUN: {
            *Status = STATUS_DATA_OVERRUN;
            retry = FALSE;
            break;
        }

        case SRB_STATUS_PHASE_SEQUENCE_FAILURE: {

            //
            // Update the error count for the device.
            //

            incrementErrorCount = TRUE;
            *Status = STATUS_IO_DEVICE_ERROR;

            //
            // If there was  phase sequence error then limit the number of
            // retries.
            //

            if (RetryCount > 1 ) {
                retry = FALSE;
            }

            break;
        }

        case SRB_STATUS_REQUEST_FLUSHED: {

            //
            // If the status needs verification bit is set.  Then set
            // the status to need verification and no retry; otherwise,
            // just retry the request.
            //

            if (TEST_FLAG(Fdo->Flags, DO_VERIFY_VOLUME)) {

                *Status = STATUS_VERIFY_REQUIRED;
                retry = FALSE;

            } else {
                *Status = STATUS_IO_DEVICE_ERROR;
            }

            break;
        }

        case SRB_STATUS_INVALID_REQUEST: {
            *Status = STATUS_INVALID_DEVICE_REQUEST;
            retry = FALSE;
            break;
        }

        case SRB_STATUS_UNEXPECTED_BUS_FREE:
        case SRB_STATUS_PARITY_ERROR:

            //
            // Update the error count for the device
            // and fall through to below
            //

            incrementErrorCount = TRUE;

        case SRB_STATUS_BUS_RESET: {
            *Status = STATUS_IO_DEVICE_ERROR;
            break;
        }

        case SRB_STATUS_ERROR: {

            *Status = STATUS_IO_DEVICE_ERROR;
            if (Srb->ScsiStatus == 0) {

                //
                // This is some strange return code.  Update the error
                // count for the device.
                //

                incrementErrorCount = TRUE;

            } if (Srb->ScsiStatus == SCSISTAT_BUSY) {

                *Status = STATUS_DEVICE_NOT_READY;

            } if (Srb->ScsiStatus == SCSISTAT_RESERVATION_CONFLICT) {

                *Status = STATUS_DEVICE_BUSY;
                retry = FALSE;
                logError = FALSE;

            }

            break;
        }

        default: {
            logError = TRUE;
            logStatus = IO_ERR_CONTROLLER_ERROR;
            uniqueId = 259;
            *Status = STATUS_IO_DEVICE_ERROR;
            unhandledError = TRUE;
            break;
        }

        }

        //
        // NTRAID #183546 - if we support GESN subtype NOT_READY events, and
        // we know from a previous poll when the device will be ready (ETA)
        // we should delay the retry more appropriately than just guessing.
        //
        /*
        if (fdoExtension->MediaChangeDetectionInfo &&
            fdoExtension->MediaChangeDetectionInfo->Gesn.Supported &&
            TEST_FLAG(fdoExtension->MediaChangeDetectionInfo->Gesn.EventMask,
                      NOTIFICATION_DEVICE_BUSY_CLASS_MASK)
            ) {
            // check if Gesn.ReadyTime if greater than current tick count
            // if so, delay that long (from 1 to 30 seconds max?)
            // else, leave the guess of time alone.
        }
        */

    }

    if (incrementErrorCount) {

        //
        // if any error count occurred, delay the retry of this io by
        // at least one second, if caller supports it.
        //

        if (retryInterval == 0) {
            retryInterval = 1;
        }
        ClasspPerfIncrementErrorCount(fdoExtension);
    }

    //
    // If there is a class specific error handler call it.
    //

    if (fdoExtension->CommonExtension.DevInfo->ClassError != NULL) {

        fdoExtension->CommonExtension.DevInfo->ClassError(Fdo,
                                                          Srb,
                                                          Status,
                                                          &retry);
    }

    //
    // If the caller wants to know the suggested retry interval tell them.
    //

    if(ARGUMENT_PRESENT(RetryInterval)) {
        *RetryInterval = retryInterval;
    }


    /*
     *  LOG the error:
     *      Always log the error in our internal log.
     *      If logError is set, also log the error in the system log.
     */
    {
        ULONG totalSize;
        ULONG senseBufferSize = 0;
        IO_ERROR_LOG_PACKET staticErrLogEntry = {0};
        CLASS_ERROR_LOG_DATA staticErrLogData = {0};

        //
        // Calculate the total size of the error log entry.
        // add to totalSize in the order that they are used.
        // the advantage to calculating all the sizes here is
        // that we don't have to do a bunch of extraneous checks
        // later on in this code path.
        //
        totalSize = sizeof(IO_ERROR_LOG_PACKET)  // required
                  - sizeof(ULONG)                // struct includes one ULONG
                  + sizeof(CLASS_ERROR_LOG_DATA);// struct for ease

        //
        // also save any available extra sense data, up to the maximum errlog
        // packet size .  WMI should be used for real-time analysis.
        // the event log should only be used for post-mortem debugging.
        //
        if (TEST_FLAG(Srb->SrbStatus, SRB_STATUS_AUTOSENSE_VALID)) {
            ULONG validSenseBytes;
            BOOLEAN validSense;

            //
            // make sure we can at least access the AdditionalSenseLength field
            //
            validSense = RTL_CONTAINS_FIELD(senseBuffer,
                                            Srb->SenseInfoBufferLength,
                                            AdditionalSenseLength);
            if (validSense) {

                //
                // if extra info exists, copy the maximum amount of available
                // sense data that is safe into the the errlog.
                //
                validSenseBytes = senseBuffer->AdditionalSenseLength
                                + offsetof(SENSE_DATA, AdditionalSenseLength);

                //
                // this is invalid because it causes overflow!
                // whoever sent this type of request would cause
                // a system crash.
                //
                ASSERT(validSenseBytes < MAX_ADDITIONAL_SENSE_BYTES);

                //
                // set to save the most sense buffer possible
                //
                senseBufferSize = max(validSenseBytes, sizeof(SENSE_DATA));
                senseBufferSize = min(senseBufferSize, Srb->SenseInfoBufferLength);
            } else {
                //
                // it's smaller than required to read the total number of
                // valid bytes, so just use the SenseInfoBufferLength field.
                //
                senseBufferSize = Srb->SenseInfoBufferLength;
            }

            /*
             *  Bump totalSize by the number of extra senseBuffer bytes
             *  (beyond the default sense buffer within CLASS_ERROR_LOG_DATA).
             *  Make sure to never allocate more than ERROR_LOG_MAXIMUM_SIZE.
             */
            if (senseBufferSize > sizeof(SENSE_DATA)){
                totalSize += senseBufferSize-sizeof(SENSE_DATA);
                if (totalSize > ERROR_LOG_MAXIMUM_SIZE){
                    senseBufferSize -= totalSize-ERROR_LOG_MAXIMUM_SIZE;
                    totalSize = ERROR_LOG_MAXIMUM_SIZE;
                }
            }
        }

        //
        // If we've used up all of our retry attempts, set the final status to
        // reflect the appropriate result.
        //
        if (retry && RetryCount < MAXIMUM_RETRIES) {
            staticErrLogEntry.FinalStatus = STATUS_SUCCESS;
            staticErrLogData.ErrorRetried = TRUE;
        } else {
            staticErrLogEntry.FinalStatus = *Status;
        }
        if (TEST_FLAG(Srb->SrbFlags, SRB_CLASS_FLAGS_PAGING)) {
            staticErrLogData.ErrorPaging = TRUE;
        }
        if (unhandledError) {
            staticErrLogData.ErrorUnhandled = TRUE;
        }

        //
        // Calculate the device offset if there is a geometry.
        //
        staticErrLogEntry.DeviceOffset.QuadPart = (LONGLONG)badSector;
        staticErrLogEntry.DeviceOffset.QuadPart *= (LONGLONG)fdoExtension->DiskGeometry.BytesPerSector;
        if (logStatus == -1){
            staticErrLogEntry.ErrorCode = STATUS_IO_DEVICE_ERROR;
        } else {
            staticErrLogEntry.ErrorCode = logStatus;
        }

        /*
         *  The dump data follows the IO_ERROR_LOG_PACKET,
         *  with the first ULONG of dump data inside the packet.
         */
        staticErrLogEntry.DumpDataSize = (USHORT)totalSize - sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG);

        staticErrLogEntry.SequenceNumber = 0;
        staticErrLogEntry.MajorFunctionCode = MajorFunctionCode;
        staticErrLogEntry.IoControlCode = IoDeviceCode;
        staticErrLogEntry.RetryCount = (UCHAR) RetryCount;
        staticErrLogEntry.UniqueErrorValue = uniqueId;

        KeQueryTickCount(&staticErrLogData.TickCount);
        staticErrLogData.PortNumber = (ULONG)-1;

        /*
         *  Save the entire contents of the SRB.
         */
        staticErrLogData.Srb = *Srb;

        /*
         *  For our private log, save just the default length of the SENSE_DATA.
         */
        if (senseBufferSize != 0){
            RtlCopyMemory(&staticErrLogData.SenseData, senseBuffer, min(senseBufferSize, sizeof(SENSE_DATA)));
        }

        /*
         *  Save the error log in our context.
         *  We only save the default sense buffer length.
         */
        KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);
        fdoData->ErrorLogs[fdoData->ErrorLogNextIndex] = staticErrLogData;
        fdoData->ErrorLogNextIndex++;
        fdoData->ErrorLogNextIndex %= NUM_ERROR_LOG_ENTRIES;
        KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);

        /*
         *  If logError is set, also save this log in the system's error log.
         *  But make sure we don't log TUR failures over and over 
         *  (e.g. if an external drive was switched off and we're still sending TUR's to it every second).
         */
        if ((((PCDB)Srb->Cdb)->CDB10.OperationCode == SCSIOP_TEST_UNIT_READY) && logError){
            if (fdoData->LoggedTURFailureSinceLastIO){
                logError = FALSE;
            }
            else {
                fdoData->LoggedTURFailureSinceLastIO = TRUE;    
            }
        }
        if (logError){
            PIO_ERROR_LOG_PACKET errorLogEntry;
            PCLASS_ERROR_LOG_DATA errlogData;

            errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(Fdo, (UCHAR)totalSize);
            if (errorLogEntry){
                errlogData = (PCLASS_ERROR_LOG_DATA)errorLogEntry->DumpData;

                *errorLogEntry = staticErrLogEntry;
                *errlogData = staticErrLogData;

                /*
                 *  For the system log, copy as much of the sense buffer as possible.
                 */
                if (senseBufferSize != 0) {
                    RtlCopyMemory(&errlogData->SenseData, senseBuffer, senseBufferSize);
                }

                /*
                 *  Write the error log packet to the system error logging thread.
                 */
                IoWriteErrorLogEntry(errorLogEntry);
            }
        }
    }

    return retry;

} // end ClassInterpretSenseInfo()



/*++////////////////////////////////////////////////////////////////////////////

ClassModeSense()

Routine Description:

    This routine sends a mode sense command to a target ID and returns
    when it is complete.

Arguments:

    Fdo - Supplies the functional device object associated with this request.

    ModeSenseBuffer - Supplies a buffer to store the sense data.

    Length - Supplies the length in bytes of the mode sense buffer.

    PageMode - Supplies the page or pages of mode sense data to be retrived.

Return Value:

    Length of the transferred data is returned.

--*/
ULONG ClassModeSense(   IN PDEVICE_OBJECT Fdo,
                        IN PCHAR ModeSenseBuffer,
                        IN ULONG Length,
                        IN UCHAR PageMode)
{
    ULONG lengthTransferred = 0;
    PMDL senseBufferMdl;

    PAGED_CODE();

    senseBufferMdl = BuildDeviceInputMdl(ModeSenseBuffer, Length);
    if (senseBufferMdl){

        TRANSFER_PACKET *pkt = DequeueFreeTransferPacket(Fdo, TRUE);
        if (pkt){
            KEVENT event;
            NTSTATUS pktStatus;
            IRP pseudoIrp = {0};

            /*
             *  Store the number of packets servicing the irp (one)
             *  inside the original IRP.  It will be used to counted down
             *  to zero when the packet completes.
             *  Initialize the original IRP's status to success.
             *  If the packet fails, we will set it to the error status.
             */
            pseudoIrp.Tail.Overlay.DriverContext[0] = LongToPtr(1);
            pseudoIrp.IoStatus.Status = STATUS_SUCCESS;
            pseudoIrp.IoStatus.Information = 0;
            pseudoIrp.MdlAddress = senseBufferMdl;

            /*
             *  Set this up as a SYNCHRONOUS transfer, submit it,
             *  and wait for the packet to complete.  The result
             *  status will be written to the original irp.
             */
            ASSERT(Length <= 0x0ff);
            KeInitializeEvent(&event, SynchronizationEvent, FALSE);
            SetupModeSenseTransferPacket(pkt, &event, ModeSenseBuffer, (UCHAR)Length, PageMode, &pseudoIrp);
            SubmitTransferPacket(pkt);
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

            if (NT_SUCCESS(pseudoIrp.IoStatus.Status)){
                lengthTransferred = (ULONG)pseudoIrp.IoStatus.Information;
            }
            else {
                /*
                 *  This request can sometimes fail legitimately
                 *  (e.g. when a SCSI device is attached but turned off)
                 *  so this is not necessarily a device/driver bug.
                 */
                DBGTRACE(ClassDebugWarning, ("ClassModeSense on Fdo %ph failed with status %xh.", Fdo, pseudoIrp.IoStatus.Status));
            }
        }

        FreeDeviceInputMdl(senseBufferMdl);
    }

    return lengthTransferred;
}


/*++////////////////////////////////////////////////////////////////////////////

ClassFindModePage()

Routine Description:

    This routine scans through the mode sense data and finds the requested
    mode sense page code.

Arguments:
    ModeSenseBuffer - Supplies a pointer to the mode sense data.

    Length - Indicates the length of valid data.

    PageMode - Supplies the page mode to be searched for.

    Use6Byte - Indicates whether 6 or 10 byte mode sense was used.

Return Value:

    A pointer to the the requested mode page.  If the mode page was not found
    then NULL is return.

--*/
PVOID
ClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode,
    IN BOOLEAN Use6Byte
    )
{
    PUCHAR limit;
    ULONG  parameterHeaderLength;
    PVOID result = NULL;

    limit = ModeSenseBuffer + Length;
    parameterHeaderLength = (Use6Byte) ? sizeof(MODE_PARAMETER_HEADER) : sizeof(MODE_PARAMETER_HEADER10);

    if (Length >= parameterHeaderLength) {

        PMODE_PARAMETER_HEADER10 modeParam10;
        ULONG blockDescriptorLength;

        /*
         *  Skip the mode select header and block descriptors.
         */
        if (Use6Byte){
            blockDescriptorLength = ((PMODE_PARAMETER_HEADER) ModeSenseBuffer)->BlockDescriptorLength;
        }
        else {
            modeParam10 = (PMODE_PARAMETER_HEADER10) ModeSenseBuffer;
            blockDescriptorLength = modeParam10->BlockDescriptorLength[1];
        }

        ModeSenseBuffer += parameterHeaderLength + blockDescriptorLength;

        //
        // ModeSenseBuffer now points at pages.  Walk the pages looking for the
        // requested page until the limit is reached.
        //

        while (ModeSenseBuffer +
               RTL_SIZEOF_THROUGH_FIELD(MODE_DISCONNECT_PAGE, PageLength) < limit) {

            if (((PMODE_DISCONNECT_PAGE) ModeSenseBuffer)->PageCode == PageMode) {

                /*
                 * found the mode page.  make sure it's safe to touch it all
                 * before returning the pointer to caller
                 */

                if (ModeSenseBuffer + ((PMODE_DISCONNECT_PAGE)ModeSenseBuffer)->PageLength > limit) {
                    /*
                     *  Return NULL since the page is not safe to access in full
                     */
                    result = NULL;
                }
                else {
                    result = ModeSenseBuffer;
                }
                break;
            }

            //
            // Advance to the next page which is 4-byte-aligned offset after this page.
            //
            ModeSenseBuffer +=
                ((PMODE_DISCONNECT_PAGE) ModeSenseBuffer)->PageLength +
                RTL_SIZEOF_THROUGH_FIELD(MODE_DISCONNECT_PAGE, PageLength);

        }
    }

    return result;
} // end ClassFindModePage()

/*++////////////////////////////////////////////////////////////////////////////

ClassSendSrbAsynchronous()

Routine Description:

    This routine takes a partially built Srb and an Irp and sends it down to
    the port driver.

    This routine must be called with the remove lock held for the specified
    Irp.

Arguments:

    Fdo - Supplies the functional device object for the orginal request.

    Srb - Supplies a paritally build ScsiRequestBlock.  In particular, the
        CDB and the SRB timeout value must be filled in.  The SRB must not be
        allocated from zone.

    Irp - Supplies the requesting Irp.

    BufferAddress - Supplies a pointer to the buffer to be transfered.

    BufferLength - Supplies the length of data transfer.

    WriteToDevice - Indicates the data transfer will be from system memory to
        device.

Return Value:

    Returns STATUS_PENDING if the request is dispatched (since the
    completion routine may change the irp's status value we cannot simply
    return the value of the dispatch)

    or returns a status value to indicate why it failed.

--*/
NTSTATUS
ClassSendSrbAsynchronous(
    PDEVICE_OBJECT Fdo,
    PSCSI_REQUEST_BLOCK Srb,
    PIRP Irp,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    )
{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack;

    ULONG savedFlags;

    //
    // Write length to SRB.
    //

    Srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set SCSI bus address.
    //

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // This is a violation of the SCSI spec but it is required for
    // some targets.
    //

    // Srb->Cdb[1] |= deviceExtension->Lun << 5;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    Srb->SenseInfoBuffer = fdoExtension->SenseData;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;
    Srb->DataBuffer = BufferAddress;

    //
    // Save the class driver specific flags away.
    //

    savedFlags = Srb->SrbFlags & SRB_FLAGS_CLASS_DRIVER_RESERVED;

    //
    // Allow the caller to specify that they do not wish
    // IoStartNextPacket() to be called in the completion routine.
    //

    SET_FLAG(savedFlags, (Srb->SrbFlags & SRB_FLAGS_DONT_START_NEXT_PACKET));

    if (BufferAddress != NULL) {

        //
        // Build Mdl if necessary.
        //

        if (Irp->MdlAddress == NULL) {

            if (IoAllocateMdl(BufferAddress,
                              BufferLength,
                              FALSE,
                              FALSE,
                              Irp) == NULL) {

                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                //
                // ClassIoComplete() would have free'd the srb
                //

                if (PORT_ALLOCATED_SENSE(fdoExtension, Srb)) {
                    FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, Srb);
                }
                ClassFreeOrReuseSrb(fdoExtension, Srb);
                ClassReleaseRemoveLock(Fdo, Irp);
                ClassCompleteRequest(Fdo, Irp, IO_NO_INCREMENT);

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            MmBuildMdlForNonPagedPool(Irp->MdlAddress);

        } else {

            //
            // Make sure the buffer requested matches the MDL.
            //

            ASSERT(BufferAddress == MmGetMdlVirtualAddress(Irp->MdlAddress));
        }

        //
        // Set read flag.
        //

        Srb->SrbFlags = WriteToDevice ? SRB_FLAGS_DATA_OUT : SRB_FLAGS_DATA_IN;

    } else {

        //
        // Clear flags.
        //

        Srb->SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER;
    }

    //
    // Restore saved flags.
    //

    SET_FLAG(Srb->SrbFlags, savedFlags);

    //
    // Disable synchronous transfer for these requests.
    //

    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

    //
    // Set the transfer length.
    //

    Srb->DataTransferLength = BufferLength;

    //
    // Zero out status.
    //

    Srb->ScsiStatus = Srb->SrbStatus = 0;

    Srb->NextSrb = 0;

    //
    // Save a few parameters in the current stack location.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Save retry count in current Irp stack.
    //

    irpStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine(Irp, ClassIoComplete, Srb, TRUE, TRUE, TRUE);

    //
    // Get next stack location and
    // set major function code.
    //

    irpStack = IoGetNextIrpStackLocation(Irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = Srb;

    //
    // Set up Irp Address.
    //

    Srb->OriginalRequest = Irp;

    //
    // Call the port driver to process the request.
    //

    IoMarkIrpPending(Irp);

    IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, Irp);

    return STATUS_PENDING;

} // end ClassSendSrbAsynchronous()

/*++////////////////////////////////////////////////////////////////////////////

ClassDeviceControlDispatch()

Routine Description:

    The routine is the common class driver device control dispatch entry point.
    This routine is invokes the device-specific drivers DeviceControl routine,
    (which may call the Class driver's common DeviceControl routine).

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   Returns the status returned from the device-specific driver.

--*/
NTSTATUS
ClassDeviceControlDispatch(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{

    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    ULONG isRemoved;

    isRemoved = ClassAcquireRemoveLock(DeviceObject, Irp);

    if(isRemoved) {

        ClassReleaseRemoveLock(DeviceObject, Irp);

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Call the class specific driver DeviceControl routine.
    // If it doesn't handle it, it will call back into ClassDeviceControl.
    //

    ASSERT(commonExtension->DevInfo->ClassDeviceControl);

    return commonExtension->DevInfo->ClassDeviceControl(DeviceObject,Irp);
} // end ClassDeviceControlDispatch()


/*++////////////////////////////////////////////////////////////////////////////

ClassDeviceControl()

Routine Description:

    The routine is the common class driver device control dispatch function.
    This routine is called by a class driver when it get an unrecognized
    device control request.  This routine will perform the correct action for
    common requests such as lock media.  If the device request is unknown it
    passed down to the next level.

    This routine must be called with the remove lock held for the specified
    irp.

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   Returns back a STATUS_PENDING or a completion status.

--*/
NTSTATUS
ClassDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextStack = NULL;

    ULONG controlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    PSCSI_REQUEST_BLOCK srb = NULL;
    PCDB cdb = NULL;

    NTSTATUS status;
    ULONG modifiedIoControlCode;

    //
    // If this is a pass through I/O control, set the minor function code
    // and device address and pass it to the port driver.
    //

    if ((controlCode == IOCTL_SCSI_PASS_THROUGH) ||
        (controlCode == IOCTL_SCSI_PASS_THROUGH_DIRECT)) {

        PSCSI_PASS_THROUGH scsiPass;

        //
        // Validiate the user buffer.
        //
        #if defined (_WIN64)

            if (IoIs32bitProcess(Irp)) {

                if (irpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSI_PASS_THROUGH32)){

                    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                    ClassReleaseRemoveLock(DeviceObject, Irp);
                    ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

                    status = STATUS_INVALID_PARAMETER;
                    goto SetStatusAndReturn;
                }
            }
            else
        #endif
            {
                if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(SCSI_PASS_THROUGH)) {

                    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                    ClassReleaseRemoveLock(DeviceObject, Irp);
                    ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

                    status = STATUS_INVALID_PARAMETER;
                    goto SetStatusAndReturn;
                }
            }

        IoCopyCurrentIrpStackLocationToNext(Irp);

        nextStack = IoGetNextIrpStackLocation(Irp);
        nextStack->MinorFunction = 1;

        ClassReleaseRemoveLock(DeviceObject, Irp);

        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        goto SetStatusAndReturn;
    }

    Irp->IoStatus.Information = 0;

    switch (controlCode) {

        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID: {

            PMOUNTDEV_UNIQUE_ID uniqueId;

            if (!commonExtension->MountedDeviceInterfaceName.Buffer) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(MOUNTDEV_UNIQUE_ID)) {

                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
                break;
            }

            uniqueId = Irp->AssociatedIrp.SystemBuffer;
            uniqueId->UniqueIdLength =
                    commonExtension->MountedDeviceInterfaceName.Length;

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(USHORT) + uniqueId->UniqueIdLength) {

                status = STATUS_BUFFER_OVERFLOW;
                Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
                break;
            }

            RtlCopyMemory(uniqueId->UniqueId,
                          commonExtension->MountedDeviceInterfaceName.Buffer,
                          uniqueId->UniqueIdLength);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(USHORT) +
                                        uniqueId->UniqueIdLength;
            break;
        }

        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME: {

            PMOUNTDEV_NAME name;

            ASSERT(commonExtension->DeviceName.Buffer);

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(MOUNTDEV_NAME)) {

                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
                break;
            }

            name = Irp->AssociatedIrp.SystemBuffer;
            name->NameLength = commonExtension->DeviceName.Length;

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(USHORT) + name->NameLength) {

                status = STATUS_BUFFER_OVERFLOW;
                Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
                break;
            }

            RtlCopyMemory(name->Name, commonExtension->DeviceName.Buffer,
                          name->NameLength);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(USHORT) + name->NameLength;
            break;
        }

        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME: {

            PMOUNTDEV_SUGGESTED_LINK_NAME suggestedName;
            WCHAR driveLetterNameBuffer[10];
            RTL_QUERY_REGISTRY_TABLE queryTable[2];
            PWSTR valueName;
            UNICODE_STRING driveLetterName;

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(MOUNTDEV_SUGGESTED_LINK_NAME)) {

                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
                break;
            }

            valueName = ExAllocatePoolWithTag(
                            PagedPool,
                            commonExtension->DeviceName.Length + sizeof(WCHAR),
                            '8CcS');

            if (!valueName) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlCopyMemory(valueName, commonExtension->DeviceName.Buffer,
                          commonExtension->DeviceName.Length);
            valueName[commonExtension->DeviceName.Length/sizeof(WCHAR)] = 0;

            driveLetterName.Buffer = driveLetterNameBuffer;
            driveLetterName.MaximumLength = 20;
            driveLetterName.Length = 0;

            RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
            queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                                  RTL_QUERY_REGISTRY_DIRECT;
            queryTable[0].Name = valueName;
            queryTable[0].EntryContext = &driveLetterName;

            status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\Machine\\System\\DISK",
                                            queryTable, NULL, NULL);

            if (!NT_SUCCESS(status)) {
                ExFreePool(valueName);
                break;
            }

            if (driveLetterName.Length == 4 &&
                driveLetterName.Buffer[0] == '%' &&
                driveLetterName.Buffer[1] == ':') {

                driveLetterName.Buffer[0] = 0xFF;

            } else if (driveLetterName.Length != 4 ||
                driveLetterName.Buffer[0] < FirstDriveLetter ||
                driveLetterName.Buffer[0] > LastDriveLetter ||
                driveLetterName.Buffer[1] != ':') {

                status = STATUS_NOT_FOUND;
                ExFreePool(valueName);
                break;
            }

            suggestedName = Irp->AssociatedIrp.SystemBuffer;
            suggestedName->UseOnlyIfThereAreNoOtherLinks = TRUE;
            suggestedName->NameLength = 28;

            Irp->IoStatus.Information =
                    FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME, Name) + 28;

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                Irp->IoStatus.Information) {

                Irp->IoStatus.Information =
                        sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
                status = STATUS_BUFFER_OVERFLOW;
                ExFreePool(valueName);
                break;
            }

            RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                   L"\\Registry\\Machine\\System\\DISK",
                                   valueName);

            ExFreePool(valueName);

            RtlCopyMemory(suggestedName->Name, L"\\DosDevices\\", 24);
            suggestedName->Name[12] = driveLetterName.Buffer[0];
            suggestedName->Name[13] = ':';

            //
            // NT_SUCCESS(status) based on RtlQueryRegistryValues
            //
            status = STATUS_SUCCESS;

            break;
        }

        default:
            status = STATUS_PENDING;
            break;
    }

    if (status != STATUS_PENDING) {
        ClassReleaseRemoveLock(DeviceObject, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (commonExtension->IsFdo){

        PULONG_PTR function;

        srb = ExAllocatePoolWithTag(NonPagedPool,
                             sizeof(SCSI_REQUEST_BLOCK) +
                             (sizeof(ULONG_PTR) * 2),
                             '9CcS');

        if (srb == NULL) {

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetStatusAndReturn;
        }

        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        cdb = (PCDB)srb->Cdb;

        //
        // Save the function code and the device object in the memory after
        // the SRB.
        //

        function = (PULONG_PTR) ((PSCSI_REQUEST_BLOCK) (srb + 1));
        *function = (ULONG_PTR) DeviceObject;
        function++;
        *function = (ULONG_PTR) controlCode;

    } else {
        srb = NULL;
    }

    //
    // Change the device type to storage for the switch statement, but only
    // if from a legacy device type
    //

    if (((controlCode & 0xffff0000) == (IOCTL_DISK_BASE  << 16)) ||
        ((controlCode & 0xffff0000) == (IOCTL_TAPE_BASE  << 16)) ||
        ((controlCode & 0xffff0000) == (IOCTL_CDROM_BASE << 16))
        ) {

        modifiedIoControlCode = (controlCode & ~0xffff0000);
        modifiedIoControlCode |= (IOCTL_STORAGE_BASE << 16);

    } else {

        modifiedIoControlCode = controlCode;

    }

    DBGTRACE(ClassDebugTrace, ("> ioctl %xh (%s)", modifiedIoControlCode, DBGGETIOCTLSTR(modifiedIoControlCode)));

    switch (modifiedIoControlCode) {

    case IOCTL_STORAGE_GET_HOTPLUG_INFO: {

        if (srb) {
            ExFreePool(srb);
            srb = NULL;
        }

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
           sizeof(STORAGE_HOTPLUG_INFO)) {

            //
            // Indicate unsuccessful status and no data transferred.
            //

            Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(STORAGE_HOTPLUG_INFO);

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            status = STATUS_BUFFER_TOO_SMALL;

        } else if(!commonExtension->IsFdo) {

            //
            // Just forward this down and return
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

        } else {

            PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
            PSTORAGE_HOTPLUG_INFO info;

            fdoExtension = (PFUNCTIONAL_DEVICE_EXTENSION)commonExtension;
            info = Irp->AssociatedIrp.SystemBuffer;

            *info = fdoExtension->PrivateFdoData->HotplugInfo;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(STORAGE_HOTPLUG_INFO);
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            status = STATUS_SUCCESS;

        }
        break;
    }

    case IOCTL_STORAGE_SET_HOTPLUG_INFO: {

        if (srb)
        {
            ExFreePool(srb);
            srb = NULL;
        }

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(STORAGE_HOTPLUG_INFO)) {

            //
            // Indicate unsuccessful status and no data transferred.
            //

            Irp->IoStatus.Status = STATUS_INFO_LENGTH_MISMATCH;

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            status = STATUS_INFO_LENGTH_MISMATCH;
            goto SetStatusAndReturn;

        }

        if(!commonExtension->IsFdo) {

            //
            // Just forward this down and return
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

        } else {

            PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = (PFUNCTIONAL_DEVICE_EXTENSION)commonExtension;
            PSTORAGE_HOTPLUG_INFO info = Irp->AssociatedIrp.SystemBuffer;

            status = STATUS_SUCCESS;

            if (info->Size != fdoExtension->PrivateFdoData->HotplugInfo.Size)
            {
                status = STATUS_INVALID_PARAMETER_1;
            }

            if (info->MediaRemovable != fdoExtension->PrivateFdoData->HotplugInfo.MediaRemovable)
            {
                status = STATUS_INVALID_PARAMETER_2;
            }

            if (info->MediaHotplug != fdoExtension->PrivateFdoData->HotplugInfo.MediaHotplug)
            {
                status = STATUS_INVALID_PARAMETER_3;
            }

            if (info->WriteCacheEnableOverride != fdoExtension->PrivateFdoData->HotplugInfo.WriteCacheEnableOverride)
            {
                status = STATUS_INVALID_PARAMETER_5;
            }

            if (NT_SUCCESS(status))
            {
                fdoExtension->PrivateFdoData->HotplugInfo.DeviceHotplug = info->DeviceHotplug;

                //
                // Store the user-defined override in the registry
                //

                ClassSetDeviceParameter(fdoExtension,
                                        CLASSP_REG_SUBKEY_NAME,
                                        CLASSP_REG_REMOVAL_POLICY_VALUE_NAME,
                                        (info->DeviceHotplug) ? RemovalPolicyExpectSurpriseRemoval : RemovalPolicyExpectOrderlyRemoval);
            }

            Irp->IoStatus.Status = status;

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        }

        break;
    }

    case IOCTL_STORAGE_CHECK_VERIFY:
    case IOCTL_STORAGE_CHECK_VERIFY2: {

        PIRP irp2 = NULL;
        PIO_STACK_LOCATION newStack;

        PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;

        DebugPrint((1,"DeviceIoControl: Check verify\n"));

        //
        // If a buffer for a media change count was provided, make sure it's
        // big enough to hold the result
        //

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength) {

            //
            // If the buffer is too small to hold the media change count
            // then return an error to the caller
            //

            if(irpStack->Parameters.DeviceIoControl.OutputBufferLength <
               sizeof(ULONG)) {

                DebugPrint((3,"DeviceIoControl: media count "
                              "buffer too small\n"));

                Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(ULONG);

                if(srb != NULL) {
                    ExFreePool(srb);
                }

                ClassReleaseRemoveLock(DeviceObject, Irp);
                ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

                status = STATUS_BUFFER_TOO_SMALL;
                goto SetStatusAndReturn;

            }
        }

        if(!commonExtension->IsFdo) {

            //
            // If this is a PDO then we should just forward the request down
            //
            ASSERT(!srb);

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);

            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

            goto SetStatusAndReturn;

        } else {

            fdoExtension = DeviceObject->DeviceExtension;

        }

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength) {

            //
            // The caller has provided a valid buffer.  Allocate an additional
            // irp and stick the CheckVerify completion routine on it.  We will
            // then send this down to the port driver instead of the irp the
            // caller sent in
            //

            DebugPrint((2,"DeviceIoControl: Check verify wants "
                          "media count\n"));

            //
            // Allocate a new irp to send the TestUnitReady to the port driver
            //

            irp2 = IoAllocateIrp((CCHAR) (DeviceObject->StackSize + 3), FALSE);

            if(irp2 == NULL) {
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                ASSERT(srb);
                ExFreePool(srb);
                ClassReleaseRemoveLock(DeviceObject, Irp);
                ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto SetStatusAndReturn;

                break;
            }

            //
            // Make sure to acquire the lock for the new irp.
            //

            ClassAcquireRemoveLock(DeviceObject, irp2);

            irp2->Tail.Overlay.Thread = Irp->Tail.Overlay.Thread;
            IoSetNextIrpStackLocation(irp2);

            //
            // Set the top stack location and shove the master Irp into the
            // top location
            //

            newStack = IoGetCurrentIrpStackLocation(irp2);
            newStack->Parameters.Others.Argument1 = Irp;
            newStack->DeviceObject = DeviceObject;

            //
            // Stick the check verify completion routine onto the stack
            // and prepare the irp for the port driver
            //

            IoSetCompletionRoutine(irp2,
                                   ClassCheckVerifyComplete,
                                   NULL,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            IoSetNextIrpStackLocation(irp2);
            newStack = IoGetCurrentIrpStackLocation(irp2);
            newStack->DeviceObject = DeviceObject;
            newStack->MajorFunction = irpStack->MajorFunction;
            newStack->MinorFunction = irpStack->MinorFunction;

            //
            // Mark the master irp as pending - whether the lower level
            // driver completes it immediately or not this should allow it
            // to go all the way back up.
            //

            IoMarkIrpPending(Irp);

            Irp = irp2;

        }

        //
        // Test Unit Ready
        //

        srb->CdbLength = 6;
        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        //
        // Set timeout value.
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        //
        // If this was a CV2 then mark the request as low-priority so we don't
        // spin up the drive just to satisfy it.
        //

        if(controlCode == IOCTL_STORAGE_CHECK_VERIFY2) {
            SET_FLAG(srb->SrbFlags, SRB_CLASS_FLAGS_LOW_PRIORITY);
        }

        //
        // Since this routine will always hand the request to the
        // port driver if there isn't a data transfer to be done
        // we don't have to worry about completing the request here
        // on an error
        //

        //
        // This routine uses a completion routine so we don't want to release
        // the remove lock until then.
        //

        status = ClassSendSrbAsynchronous(DeviceObject,
                                          srb,
                                          Irp,
                                          NULL,
                                          0,
                                          FALSE);

        break;
    }

    case IOCTL_STORAGE_MEDIA_REMOVAL:
    case IOCTL_STORAGE_EJECTION_CONTROL: {

        PPREVENT_MEDIA_REMOVAL mediaRemoval = Irp->AssociatedIrp.SystemBuffer;

        DebugPrint((3, "DiskIoControl: ejection control\n"));

        if(srb) {
            ExFreePool(srb);
        }

        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
           sizeof(PREVENT_MEDIA_REMOVAL)) {

            //
            // Indicate unsuccessful status and no data transferred.
            //

            Irp->IoStatus.Status = STATUS_INFO_LENGTH_MISMATCH;

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            status = STATUS_INFO_LENGTH_MISMATCH;
            goto SetStatusAndReturn;
        }

        if(!commonExtension->IsFdo) {

            //
            // Just forward this down and return
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        }
        else {

            // i don't believe this assertion is valid.  this is a request
            // from user-mode, so they could request this for any device
            // they want?  also, we handle it properly.
            // ASSERT(TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA));
            status = ClasspEjectionControl(
                        DeviceObject,
                        Irp,
                        ((modifiedIoControlCode ==
                        IOCTL_STORAGE_EJECTION_CONTROL) ? SecureMediaLock :
                                                          SimpleMediaLock),
                        mediaRemoval->PreventMediaRemoval);

            Irp->IoStatus.Status = status;
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        }

        break;
    }

    case IOCTL_STORAGE_MCN_CONTROL: {

        DebugPrint((3, "DiskIoControl: MCN control\n"));

        if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
           sizeof(PREVENT_MEDIA_REMOVAL)) {

            //
            // Indicate unsuccessful status and no data transferred.
            //

            Irp->IoStatus.Status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = 0;

            if(srb) {
                ExFreePool(srb);
            }

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            status = STATUS_INFO_LENGTH_MISMATCH;
            goto SetStatusAndReturn;
        }

        if(!commonExtension->IsFdo) {

            //
            // Just forward this down and return
            //

            if(srb) {
                ExFreePool(srb);
            }

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

        } else {

            //
            // Call to the FDO - handle the ejection control.
            //

            status = ClasspMcnControl(DeviceObject->DeviceExtension,
                                      Irp,
                                      srb);
        }
        goto SetStatusAndReturn;
    }

    case IOCTL_STORAGE_RESERVE:
    case IOCTL_STORAGE_RELEASE: {

        //
        // Reserve logical unit.
        //

        PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;

        if(!commonExtension->IsFdo) {

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
            goto SetStatusAndReturn;
        } else {
            fdoExtension = DeviceObject->DeviceExtension;
        }

        srb->CdbLength = 6;

        if(modifiedIoControlCode == IOCTL_STORAGE_RESERVE) {
            cdb->CDB6GENERIC.OperationCode = SCSIOP_RESERVE_UNIT;
        } else {
            cdb->CDB6GENERIC.OperationCode = SCSIOP_RELEASE_UNIT;
        }

        //
        // Set timeout value.
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        status = ClassSendSrbAsynchronous(DeviceObject,
                                          srb,
                                          Irp,
                                          NULL,
                                          0,
                                          FALSE);

        break;
    }

    case IOCTL_STORAGE_EJECT_MEDIA:
    case IOCTL_STORAGE_LOAD_MEDIA:
    case IOCTL_STORAGE_LOAD_MEDIA2:{

        //
        // Eject media.
        //

        PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = NULL;

        if(!commonExtension->IsFdo) {

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);

            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
            goto SetStatusAndReturn;
        } else {
            fdoExtension = DeviceObject->DeviceExtension;
        }

        if(commonExtension->PagingPathCount != 0) {

            DebugPrint((1, "ClassDeviceControl: call to eject paging device - "
                           "failure\n"));

            status = STATUS_FILES_OPEN;
            Irp->IoStatus.Status = status;

            Irp->IoStatus.Information = 0;

            if(srb) {
                ExFreePool(srb);
            }

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            goto SetStatusAndReturn;
        }

        //
        // Synchronize with ejection control and ejection cleanup code as
        // well as other eject/load requests.
        //

        KeEnterCriticalRegion();
        KeWaitForSingleObject(&(fdoExtension->EjectSynchronizationEvent),
                              UserRequest,
                              UserMode,
                              FALSE,
                              NULL);

        if(fdoExtension->ProtectedLockCount != 0) {

            DebugPrint((1, "ClassDeviceControl: call to eject protected locked "
                           "device - failure\n"));

            status = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            if(srb) {
                ExFreePool(srb);
            }

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

            KeSetEvent(&fdoExtension->EjectSynchronizationEvent,
                       IO_NO_INCREMENT,
                       FALSE);
            KeLeaveCriticalRegion();

            goto SetStatusAndReturn;
        }

        srb->CdbLength = 6;

        cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
        cdb->START_STOP.LoadEject = 1;

        if(modifiedIoControlCode == IOCTL_STORAGE_EJECT_MEDIA) {
            cdb->START_STOP.Start = 0;
        } else {
            cdb->START_STOP.Start = 1;
        }

        //
        // Set timeout value.
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        status = ClassSendSrbAsynchronous(DeviceObject,
                                              srb,
                                              Irp,
                                              NULL,
                                              0,
                                              FALSE);

        KeSetEvent(&fdoExtension->EjectSynchronizationEvent, IO_NO_INCREMENT, FALSE);
        KeLeaveCriticalRegion();

        break;
    }

    case IOCTL_STORAGE_FIND_NEW_DEVICES: {

        if(srb) {
            ExFreePool(srb);
        }

        if(commonExtension->IsFdo) {

            IoInvalidateDeviceRelations(
                ((PFUNCTIONAL_DEVICE_EXTENSION) commonExtension)->LowerPdo,
                BusRelations);

            status = STATUS_SUCCESS;
            Irp->IoStatus.Status = status;

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        }
        else {

            IoCopyCurrentIrpStackLocationToNext(Irp);

            ClassReleaseRemoveLock(DeviceObject, Irp);
            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        }
        break;
    }

    case IOCTL_STORAGE_GET_DEVICE_NUMBER: {

        if(srb) {
            ExFreePool(srb);
        }

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength >=
           sizeof(STORAGE_DEVICE_NUMBER)) {

            PSTORAGE_DEVICE_NUMBER deviceNumber =
                Irp->AssociatedIrp.SystemBuffer;
            PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
                commonExtension->PartitionZeroExtension;

            deviceNumber->DeviceType = fdoExtension->CommonExtension.DeviceObject->DeviceType;
            deviceNumber->DeviceNumber = fdoExtension->DeviceNumber;
            deviceNumber->PartitionNumber = commonExtension->PartitionNumber;

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(STORAGE_DEVICE_NUMBER);

        } else {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(STORAGE_DEVICE_NUMBER);
        }

        Irp->IoStatus.Status = status;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

        break;
    }

    default: {

        DebugPrint((4, "IoDeviceControl: Unsupported device IOCTL %x for %p\n",
                    controlCode, DeviceObject));

        //
        // Pass the device control to the next driver.
        //

        if(srb) {
            ExFreePool(srb);
        }

        //
        // Copy the Irp stack parameters to the next stack location.
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);

        ClassReleaseRemoveLock(DeviceObject, Irp);
        status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        break;
    }

    } // end switch( ...

SetStatusAndReturn:

    DBGTRACE(ClassDebugTrace, ("< ioctl %xh (%s): status %xh.", modifiedIoControlCode, DBGGETIOCTLSTR(modifiedIoControlCode), status));

    return status;
} // end ClassDeviceControl()

/*++////////////////////////////////////////////////////////////////////////////

ClassShutdownFlush()

Routine Description:

    This routine is called for a shutdown and flush IRPs.  These are sent by the
    system before it actually shuts down or when the file system does a flush.
    If it exists, the device-specific driver's routine will be invoked. If there
    wasn't one specified, the Irp will be completed with an Invalid device request.

Arguments:

    DriverObject - Pointer to device object to being shutdown by system.

    Irp - IRP involved.

Return Value:

    NT Status

--*/
NTSTATUS
ClassShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    ULONG isRemoved;

    NTSTATUS status;

    isRemoved = ClassAcquireRemoveLock(DeviceObject, Irp);

    if(isRemoved) {

        ClassReleaseRemoveLock(DeviceObject, Irp);

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    if (commonExtension->DevInfo->ClassShutdownFlush) {

        //
        // Call the device-specific driver's routine.
        //

        return commonExtension->DevInfo->ClassShutdownFlush(DeviceObject, Irp);
    }

    //
    // Device-specific driver doesn't support this.
    //

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

    return STATUS_INVALID_DEVICE_REQUEST;
} // end ClassShutdownFlush()

/*++////////////////////////////////////////////////////////////////////////////

ClassCreateDeviceObject()

Routine Description:

    This routine creates an object for the physical device specified and
    sets up the deviceExtension's function pointers for each entry point
    in the device-specific driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    ObjectNameBuffer - Dir. name of the object to create.

    LowerDeviceObject - Pointer to the lower device object

    IsFdo - should this be an fdo or a pdo

    DeviceObject - Pointer to the device object pointer we will return.

Return Value:

    NTSTATUS

--*/
NTSTATUS
ClassCreateDeviceObject(
    IN PDRIVER_OBJECT          DriverObject,
    IN PCCHAR                  ObjectNameBuffer,
    IN PDEVICE_OBJECT          LowerDevice,
    IN BOOLEAN                 IsFdo,
    IN OUT PDEVICE_OBJECT      *DeviceObject
    )
{
    BOOLEAN        isPartitionable;
    STRING         ntNameString;
    UNICODE_STRING ntUnicodeString;
    NTSTATUS       status, status2;
    PDEVICE_OBJECT deviceObject = NULL;

    ULONG          characteristics;

    PCLASS_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(DriverObject,
                                                     CLASS_DRIVER_EXTENSION_KEY);

    PCLASS_DEV_INFO devInfo;

    PAGED_CODE();

    *DeviceObject = NULL;
    RtlInitUnicodeString(&ntUnicodeString, NULL);

    DebugPrint((2, "ClassCreateFdo: Create device object\n"));

    ASSERT(LowerDevice);

    //
    // Make sure that if we're making PDO's we have an enumeration routine
    //

    isPartitionable = (driverExtension->InitData.ClassEnumerateDevice != NULL);

    ASSERT(IsFdo || isPartitionable);

    //
    // Grab the correct dev-info structure out of the init data
    //

    if(IsFdo) {
        devInfo = &(driverExtension->InitData.FdoData);
    } else {
        devInfo = &(driverExtension->InitData.PdoData);
    }

    characteristics = devInfo->DeviceCharacteristics;

    if(ARGUMENT_PRESENT(ObjectNameBuffer)) {
        DebugPrint((2, "ClassCreateFdo: Name is %s\n", ObjectNameBuffer));

        RtlInitString(&ntNameString, ObjectNameBuffer);

        status = RtlAnsiStringToUnicodeString(&ntUnicodeString, &ntNameString, TRUE);

        if (!NT_SUCCESS(status)) {

            DebugPrint((1,
                        "ClassCreateFdo: Cannot convert string %s\n",
                        ObjectNameBuffer));

            ntUnicodeString.Buffer = NULL;
            return status;
        }
    } else {
        DebugPrint((2, "ClassCreateFdo: Object will be unnamed\n"));

        if(IsFdo == FALSE) {

            //
            // PDO's have to have some sort of name.
            //

            SET_FLAG(characteristics, FILE_AUTOGENERATED_DEVICE_NAME);
        }

        RtlInitUnicodeString(&ntUnicodeString, NULL);
    }

    status = IoCreateDevice(DriverObject,
                            devInfo->DeviceExtensionSize,
                            &ntUnicodeString,
                            devInfo->DeviceType,
                            devInfo->DeviceCharacteristics,
                            FALSE,
                            &deviceObject);

    if (!NT_SUCCESS(status)) {

        DebugPrint((1, "ClassCreateFdo: Can not create device object %lx\n",
                    status));
        ASSERT(deviceObject == NULL);

        //
        // buffer is not used any longer here.
        //

        if (ntUnicodeString.Buffer != NULL) {
            DebugPrint((1, "ClassCreateFdo: Freeing unicode name buffer\n"));
            ExFreePool(ntUnicodeString.Buffer);
            RtlInitUnicodeString(&ntUnicodeString, NULL);
        }

    } else {

        PCOMMON_DEVICE_EXTENSION commonExtension = deviceObject->DeviceExtension;

        RtlZeroMemory(
            deviceObject->DeviceExtension,
            devInfo->DeviceExtensionSize);

        //
        // Setup version code
        //

        commonExtension->Version = 0x03;

        //
        // Setup the remove lock and event
        //

        commonExtension->IsRemoved = NO_REMOVE;
        commonExtension->RemoveLock = 0;
        KeInitializeEvent(&commonExtension->RemoveEvent,
                          SynchronizationEvent,
                          FALSE);

        #if DBG
            KeInitializeSpinLock(&commonExtension->RemoveTrackingSpinlock);
            commonExtension->RemoveTrackingList = NULL;
        #else
            commonExtension->RemoveTrackingSpinlock = (ULONG_PTR) -1;
            commonExtension->RemoveTrackingList = (PVOID) -1;
        #endif

        //
        // Acquire the lock once.  This reference will be released when the
        // remove IRP has been received.
        //

        ClassAcquireRemoveLock(deviceObject, (PIRP) deviceObject);

        //
        // Store a pointer to the driver extension so we don't have to do
        // lookups to get it.
        //

        commonExtension->DriverExtension = driverExtension;

        //
        // Fill in entry points
        //

        commonExtension->DevInfo = devInfo;

        //
        // Initialize some of the common values in the structure
        //

        commonExtension->DeviceObject = deviceObject;

        commonExtension->LowerDeviceObject = NULL;

        if(IsFdo) {

            PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = (PVOID) commonExtension;

            commonExtension->PartitionZeroExtension = deviceObject->DeviceExtension;

            //
            // Set the initial device object flags.
            //

            SET_FLAG(deviceObject->Flags, DO_POWER_PAGABLE);

            //
            // Clear the PDO list
            //

            commonExtension->ChildList = NULL;

            commonExtension->DriverData =
                ((PFUNCTIONAL_DEVICE_EXTENSION) deviceObject->DeviceExtension + 1);

            if(isPartitionable) {

                commonExtension->PartitionNumber = 0;
            } else {
                commonExtension->PartitionNumber = (ULONG) (-1L);
            }

            fdoExtension->DevicePowerState = PowerDeviceD0;

            KeInitializeEvent(&fdoExtension->EjectSynchronizationEvent,
                              SynchronizationEvent,
                              TRUE);

            KeInitializeEvent(&fdoExtension->ChildLock,
                              SynchronizationEvent,
                              TRUE);

            status = ClasspAllocateReleaseRequest(deviceObject);

            if(!NT_SUCCESS(status)) {
                IoDeleteDevice(deviceObject);
                *DeviceObject = NULL;

                if (ntUnicodeString.Buffer != NULL) {
                    DebugPrint((1, "ClassCreateFdo: Freeing unicode name buffer\n"));
                    ExFreePool(ntUnicodeString.Buffer);
                    RtlInitUnicodeString(&ntUnicodeString, NULL);
                }

                return status;
            }

        } else {

            PPHYSICAL_DEVICE_EXTENSION pdoExtension =
                deviceObject->DeviceExtension;

            PFUNCTIONAL_DEVICE_EXTENSION p0Extension =
                LowerDevice->DeviceExtension;

            SET_FLAG(deviceObject->Flags, DO_POWER_PAGABLE);

            commonExtension->PartitionZeroExtension = p0Extension;

            //
            // Stick this onto the PDO list
            //

            ClassAddChild(p0Extension, pdoExtension, TRUE);

            commonExtension->DriverData = (PVOID) (pdoExtension + 1);

            //
            // Get the top of stack for the lower device - this allows
            // filters to get stuck in between the partitions and the
            // physical disk.
            //

            commonExtension->LowerDeviceObject =
                IoGetAttachedDeviceReference(LowerDevice);

            //
            // Pnp will keep a reference to the lower device object long
            // after this partition has been deleted.  Dereference now so
            // we don't have to deal with it later.
            //

            ObDereferenceObject(commonExtension->LowerDeviceObject);
        }

        KeInitializeEvent(&commonExtension->PathCountEvent, SynchronizationEvent, TRUE);

        commonExtension->IsFdo = IsFdo;

        commonExtension->DeviceName = ntUnicodeString;

        commonExtension->PreviousState = 0xff;

        InitializeDictionary(&(commonExtension->FileObjectDictionary));

        commonExtension->CurrentState = IRP_MN_STOP_DEVICE;
    }

    *DeviceObject = deviceObject;

    return status;
} // end ClassCreateDeviceObject()

/*++////////////////////////////////////////////////////////////////////////////

ClassClaimDevice()

Routine Description:

    This function claims a device in the port driver.  The port driver object
    is updated with the correct driver object if the device is successfully
    claimed.

Arguments:

    LowerDeviceObject - Supplies the base port device object.

    Release - Indicates the logical unit should be released rather than claimed.

Return Value:

    Returns a status indicating success or failure of the operation.

--*/
NTSTATUS
ClassClaimDevice(
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN BOOLEAN Release
    )
{
    IO_STATUS_BLOCK    ioStatus;
    PIRP               irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT             event;
    NTSTATUS           status;
    SCSI_REQUEST_BLOCK srb;

    PAGED_CODE();

    //
    // Clear the SRB fields.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Write length to SRB.
    //

    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    srb.Function = Release ? SRB_FUNCTION_RELEASE_DEVICE :
        SRB_FUNCTION_CLAIM_DEVICE;

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Build synchronous request with no transfer.
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_EXECUTE_NONE,
                                        LowerDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        TRUE,
                                        &event,
                                        &ioStatus);

    if (irp == NULL) {
        DebugPrint((1, "ClassClaimDevice: Can't allocate Irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = &srb;

    //
    // Set up IRP Address.
    //

    srb.OriginalRequest = irp;

    //
    // Call the port driver with the request and wait for it to complete.
    //

    status = IoCallDriver(LowerDeviceObject, irp);
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // If this is a release request, then just decrement the reference count
    // and return.  The status does not matter.
    //

    if (Release) {

        // ObDereferenceObject(LowerDeviceObject);
        return STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(status)) {
        return status;
    }

    ASSERT(srb.DataBuffer != NULL);
    ASSERT(!TEST_FLAG(srb.SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));

    return status;
} // end ClassClaimDevice()

/*++////////////////////////////////////////////////////////////////////////////

ClassInternalIoControl()

Routine Description:

    This routine passes internal device controls to the port driver.
    Internal device controls are used by higher level drivers both for ioctls
    and to pass through scsi requests.

    If the IoControlCode does not match any of the handled ioctls and is
    a valid system address then the request will be treated as an SRB and
    passed down to the lower driver.  If the IoControlCode is not a valid
    system address the ioctl will be failed.

    Callers must therefore be extremely cautious to pass correct, initialized
    values to this function.

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

   Returns back a STATUS_PENDING or a completion status.

--*/
NTSTATUS
ClassInternalIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextStack = IoGetNextIrpStackLocation(Irp);

    ULONG isRemoved;

    PSCSI_REQUEST_BLOCK srb;

    isRemoved = ClassAcquireRemoveLock(DeviceObject, Irp);

    if(isRemoved) {

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        ClassReleaseRemoveLock(DeviceObject, Irp);

        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Get a pointer to the SRB.
    //

    srb = irpStack->Parameters.Scsi.Srb;

    //
    // Set the parameters in the next stack location.
    //

    if(commonExtension->IsFdo) {
        nextStack->Parameters.Scsi.Srb = srb;
        nextStack->MajorFunction = IRP_MJ_SCSI;
        nextStack->MinorFunction = IRP_MN_SCSI_CLASS;

    } else {

        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    ClassReleaseRemoveLock(DeviceObject, Irp);

    return IoCallDriver(commonExtension->LowerDeviceObject, Irp);
} // end ClassInternalIoControl()

/*++////////////////////////////////////////////////////////////////////////////

ClassQueryTimeOutRegistryValue()

Routine Description:

    This routine determines whether a reg key for a user-specified timeout
    value exists.  This should be called at initialization time.

Arguments:

    DeviceObject - Pointer to the device object we are retrieving the timeout
                   value for

Return Value:

    None, but it sets a new default timeout for a class of devices.

--*/
ULONG
ClassQueryTimeOutRegistryValue(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    //
    // Find the appropriate reg. key
    //

    PCLASS_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                     CLASS_DRIVER_EXTENSION_KEY);

    PUNICODE_STRING registryPath = &(driverExtension->RegistryPath);

    PRTL_QUERY_REGISTRY_TABLE parameters = NULL;
    PWSTR path;
    NTSTATUS status;
    LONG     timeOut = 0;
    ULONG    zero = 0;
    ULONG    size;

    PAGED_CODE();

    if (!registryPath) {
        return 0;
    }

    parameters = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(RTL_QUERY_REGISTRY_TABLE)*2,
                                '1BcS');

    if (!parameters) {
        return 0;
    }

    size = registryPath->MaximumLength + sizeof(WCHAR);
    path = ExAllocatePoolWithTag(NonPagedPool, size, '2BcS');

    if (!path) {
        ExFreePool(parameters);
        return 0;
    }

    RtlZeroMemory(path,size);
    RtlCopyMemory(path, registryPath->Buffer, size - sizeof(WCHAR));


    //
    // Check for the Timeout value.
    //

    RtlZeroMemory(parameters,
                  (sizeof(RTL_QUERY_REGISTRY_TABLE)*2));

    parameters[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name          = L"TimeOutValue";
    parameters[0].EntryContext  = &timeOut;
    parameters[0].DefaultType   = REG_DWORD;
    parameters[0].DefaultData   = &zero;
    parameters[0].DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                    path,
                                    parameters,
                                    NULL,
                                    NULL);

    if (!(NT_SUCCESS(status))) {
        timeOut = 0;
    }

    ExFreePool(parameters);
    ExFreePool(path);

    DebugPrint((2,
                "ClassQueryTimeOutRegistryValue: Timeout value %d\n",
                timeOut));


    return timeOut;

} // end ClassQueryTimeOutRegistryValue()

/*++////////////////////////////////////////////////////////////////////////////

ClassCheckVerifyComplete() ISSUE-2000/02/18-henrygab - why public?!

Routine Description:

    This routine executes when the port driver has completed a check verify
    ioctl.  It will set the status of the master Irp, copy the media change
    count and complete the request.

Arguments:

    Fdo - Supplies the functional device object which represents the logical unit.

    Irp - Supplies the Irp which has completed.

    Context - NULL

Return Value:

    NT status

--*/
NTSTATUS
ClassCheckVerifyComplete(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PIRP originalIrp;

    ASSERT_FDO(Fdo);

    originalIrp = irpStack->Parameters.Others.Argument1;

    //
    // Copy the media change count and status
    //

    *((PULONG) (originalIrp->AssociatedIrp.SystemBuffer)) =
        fdoExtension->MediaChangeCount;

    DebugPrint((2, "ClassCheckVerifyComplete - Media change count for"
                   "device %d is %lx - saved as %lx\n",
                fdoExtension->DeviceNumber,
                fdoExtension->MediaChangeCount,
                *((PULONG) originalIrp->AssociatedIrp.SystemBuffer)));

    originalIrp->IoStatus.Status = Irp->IoStatus.Status;
    originalIrp->IoStatus.Information = sizeof(ULONG);

    ClassReleaseRemoveLock(Fdo, originalIrp);
    ClassCompleteRequest(Fdo, originalIrp, IO_DISK_INCREMENT);

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;

} // end ClassCheckVerifyComplete()

/*++////////////////////////////////////////////////////////////////////////////

ClassGetDescriptor()

Routine Description:

    This routine will perform a query for the specified property id and will
    allocate a non-paged buffer to store the data in.  It is the responsibility
    of the caller to ensure that this buffer is freed.

    This routine must be run at IRQL_PASSIVE_LEVEL

Arguments:

    DeviceObject - the device to query
    DeviceInfo - a location to store a pointer to the buffer we allocate

Return Value:

    status
    if status is unsuccessful *DeviceInfo will be set to NULL, else the
    buffer allocated on behalf of the caller.

--*/
NTSTATUS
ClassGetDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *Descriptor
    )
{
    STORAGE_PROPERTY_QUERY query;
    IO_STATUS_BLOCK ioStatus;

    PSTORAGE_DESCRIPTOR_HEADER descriptor = NULL;
    ULONG length;

    UCHAR pass = 0;

    PAGED_CODE();

    //
    // Set the passed-in descriptor pointer to NULL as default
    //

    *Descriptor = NULL;


    RtlZeroMemory(&query, sizeof(STORAGE_PROPERTY_QUERY));
    query.PropertyId = *PropertyId;
    query.QueryType = PropertyStandardQuery;

    //
    // On the first pass we just want to get the first few
    // bytes of the descriptor so we can read it's size
    //

    descriptor = (PVOID)&query;

    ASSERT(sizeof(STORAGE_PROPERTY_QUERY) >= (sizeof(ULONG)*2));

    ClassSendDeviceIoControlSynchronous(
        IOCTL_STORAGE_QUERY_PROPERTY,
        DeviceObject,
        &query,
        sizeof(STORAGE_PROPERTY_QUERY),
        sizeof(ULONG) * 2,
        FALSE,
        &ioStatus
        );

    if(!NT_SUCCESS(ioStatus.Status)) {

        DebugPrint((1, "ClassGetDescriptor: error %lx trying to "
                       "query properties #1\n", ioStatus.Status));
        return ioStatus.Status;
    }

    if (descriptor->Size == 0) {

        //
        // This DebugPrint is to help third-party driver writers
        //

        DebugPrint((0, "ClassGetDescriptor: size returned was zero?! (status "
                    "%x\n", ioStatus.Status));
        return STATUS_UNSUCCESSFUL;

    }

    //
    // This time we know how much data there is so we can
    // allocate a buffer of the correct size
    //

    length = descriptor->Size;

    descriptor = ExAllocatePoolWithTag(NonPagedPool, length, '4BcS');

    if(descriptor == NULL) {

        DebugPrint((1, "ClassGetDescriptor: unable to memory for descriptor "
                    "(%d bytes)\n", length));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // setup the query again, as it was overwritten above
    //

    RtlZeroMemory(&query, sizeof(STORAGE_PROPERTY_QUERY));
    query.PropertyId = *PropertyId;
    query.QueryType = PropertyStandardQuery;

    //
    // copy the input to the new outputbuffer
    //

    RtlCopyMemory(descriptor,
                  &query,
                  sizeof(STORAGE_PROPERTY_QUERY)
                  );

    ClassSendDeviceIoControlSynchronous(
        IOCTL_STORAGE_QUERY_PROPERTY,
        DeviceObject,
        descriptor,
        sizeof(STORAGE_PROPERTY_QUERY),
        length,
        FALSE,
        &ioStatus
        );

    if(!NT_SUCCESS(ioStatus.Status)) {

        DebugPrint((1, "ClassGetDescriptor: error %lx trying to "
                       "query properties #1\n", ioStatus.Status));
        ExFreePool(descriptor);
        return ioStatus.Status;
    }

    //
    // return the memory we've allocated to the caller
    //

    *Descriptor = descriptor;
    return ioStatus.Status;
} // end ClassGetDescriptor()

/*++////////////////////////////////////////////////////////////////////////////

ClassSignalCompletion()

Routine Description:

    This completion routine will signal the event given as context and then
    return STATUS_MORE_PROCESSING_REQUIRED to stop event completion.  It is
    the responsibility of the routine waiting on the event to complete the
    request and free the event.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp

    Event - a pointer to the event to signal

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
NTSTATUS
ClassSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    )
{
    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
} // end ClassSignalCompletion()

/*++////////////////////////////////////////////////////////////////////////////

ClassPnpQueryFdoRelations()

Routine Description:

    This routine will call the driver's enumeration routine to update the
    list of PDO's.  It will then build a response to the
    IRP_MN_QUERY_DEVICE_RELATIONS and place it into the information field in
    the irp.

Arguments:

    Fdo - a pointer to the functional device object we are enumerating

    Irp - a pointer to the enumeration request

Return Value:

    status

--*/
NTSTATUS
ClassPnpQueryFdoRelations(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCLASS_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Fdo->DriverObject,
                                                     CLASS_DRIVER_EXTENSION_KEY);
    NTSTATUS status;

    PAGED_CODE();

    //
    // If there's already an enumeration in progress then don't start another
    // one.
    //

    if(InterlockedIncrement(&(fdoExtension->EnumerationInterlock)) == 1) {
        status = driverExtension->InitData.ClassEnumerateDevice(Fdo);
    }

    Irp->IoStatus.Information = (ULONG_PTR) NULL;

    Irp->IoStatus.Status = ClassRetrieveDeviceRelations(
                                Fdo,
                                BusRelations,
                                &((PDEVICE_RELATIONS) Irp->IoStatus.Information));
    InterlockedDecrement(&(fdoExtension->EnumerationInterlock));

    return Irp->IoStatus.Status;
} // end ClassPnpQueryFdoRelations()

/*++////////////////////////////////////////////////////////////////////////////

ClassMarkChildrenMissing()

Routine Description:

    This routine will call ClassMarkChildMissing() for all children.
    It acquires the ChildLock before calling ClassMarkChildMissing().

Arguments:

    Fdo - the "bus's" device object, such as the disk FDO for non-removable
        disks with multiple partitions.

Return Value:

    None

--*/
VOID
ClassMarkChildrenMissing(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = &(Fdo->CommonExtension);
    PPHYSICAL_DEVICE_EXTENSION nextChild = commonExtension->ChildList;

    PAGED_CODE();

    ClassAcquireChildLock(Fdo);

    while (nextChild){
        PPHYSICAL_DEVICE_EXTENSION tmpChild;

        /*
         *  ClassMarkChildMissing will also dequeue the child extension.
         *  So get the next pointer before calling ClassMarkChildMissing.
         */
        tmpChild = nextChild;
        nextChild = tmpChild->CommonExtension.ChildList;
        ClassMarkChildMissing(tmpChild, FALSE);
    }
    ClassReleaseChildLock(Fdo);
    return;
} // end ClassMarkChildrenMissing()

/*++////////////////////////////////////////////////////////////////////////////

ClassMarkChildMissing()

Routine Description:

    This routine will make an active child "missing."  If the device has never
    been enumerated then it will be deleted on the spot.  If the device has
    not been enumerated then it will be marked as missing so that we can
    not report it in the next device enumeration.

Arguments:

    Child - the child device to be marked as missing.

    AcquireChildLock - TRUE if the child lock should be acquired before removing
                       the missing child.  FALSE if the child lock is already
                       acquired by this thread.

Return Value:

    returns whether or not the child device object has previously been reported
    to PNP.

--*/
BOOLEAN
ClassMarkChildMissing(
    IN PPHYSICAL_DEVICE_EXTENSION Child,
    IN BOOLEAN AcquireChildLock
    )
{
    BOOLEAN returnValue = Child->IsEnumerated;

    PAGED_CODE();
    ASSERT_PDO(Child->DeviceObject);

    Child->IsMissing = TRUE;

    //
    // Make sure this child is not in the active list.
    //

    ClassRemoveChild(Child->CommonExtension.PartitionZeroExtension,
                     Child,
                     AcquireChildLock);

    if(Child->IsEnumerated == FALSE) {
        ClassRemoveDevice(Child->DeviceObject, IRP_MN_REMOVE_DEVICE);
    }

    return returnValue;
} // end ClassMarkChildMissing()

/*++////////////////////////////////////////////////////////////////////////////

ClassRetrieveDeviceRelations()

Routine Description:

    This routine will allocate a buffer to hold the specified list of
    relations.  It will then fill in the list with referenced device pointers
    and will return the request.

Arguments:

    Fdo - pointer to the FDO being queried

    RelationType - what type of relations are being queried

    DeviceRelations - a location to store a pointer to the response

Return Value:

    status

--*/
NTSTATUS
ClassRetrieveDeviceRelations(
    IN PDEVICE_OBJECT Fdo,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    ULONG count = 0;
    ULONG i;

    PPHYSICAL_DEVICE_EXTENSION nextChild;

    ULONG relationsSize;
    PDEVICE_RELATIONS deviceRelations = NULL;

    NTSTATUS status;

    PAGED_CODE();

    ClassAcquireChildLock(fdoExtension);

    nextChild = fdoExtension->CommonExtension.ChildList;

    //
    // Count the number of PDO's attached to this disk
    //

    while(nextChild != NULL) {
        PCOMMON_DEVICE_EXTENSION commonExtension;

        commonExtension = &(nextChild->CommonExtension);

        ASSERTMSG("ClassPnp internal error: missing child on active list\n",
                  (nextChild->IsMissing == FALSE));

        nextChild = commonExtension->ChildList;

        count++;
    };

    relationsSize = (sizeof(DEVICE_RELATIONS) +
                     (count * sizeof(PDEVICE_OBJECT)));

    deviceRelations = ExAllocatePoolWithTag(PagedPool, relationsSize, '5BcS');

    if(deviceRelations == NULL) {

        DebugPrint((1, "ClassRetrieveDeviceRelations: unable to allocate "
                       "%d bytes for device relations\n", relationsSize));

        ClassReleaseChildLock(fdoExtension);

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(deviceRelations, relationsSize);

    nextChild = fdoExtension->CommonExtension.ChildList;
    i = count - 1;

    while(nextChild != NULL) {
        PCOMMON_DEVICE_EXTENSION commonExtension;

        commonExtension = &(nextChild->CommonExtension);

        ASSERTMSG("ClassPnp internal error: missing child on active list\n",
                  (nextChild->IsMissing == FALSE));

        deviceRelations->Objects[i--] = nextChild->DeviceObject;

        status = ObReferenceObjectByPointer(
                    nextChild->DeviceObject,
                    0,
                    NULL,
                    KernelMode);
        ASSERT(NT_SUCCESS(status));

        nextChild->IsEnumerated = TRUE;
        nextChild = commonExtension->ChildList;
    }

    ASSERTMSG("Child list has changed: ", i == -1);

    deviceRelations->Count = count;
    *DeviceRelations = deviceRelations;
    ClassReleaseChildLock(fdoExtension);
    return STATUS_SUCCESS;
} // end ClassRetrieveDeviceRelations()

/*++////////////////////////////////////////////////////////////////////////////

ClassGetPdoId()

Routine Description:

    This routine will call into the driver to retrieve a copy of one of it's
    id strings.

Arguments:

    Pdo - a pointer to the pdo being queried

    IdType - which type of id string is being queried

    IdString - an allocated unicode string structure which the driver
               can fill in.

Return Value:

    status

--*/
NTSTATUS
ClassGetPdoId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING IdString
    )
{
    PCLASS_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Pdo->DriverObject,
                                                     CLASS_DRIVER_EXTENSION_KEY);

    ASSERT_PDO(Pdo);
    ASSERT(driverExtension->InitData.ClassQueryId);

    PAGED_CODE();

    return driverExtension->InitData.ClassQueryId( Pdo, IdType, IdString);
} // end ClassGetPdoId()

/*++////////////////////////////////////////////////////////////////////////////

ClassQueryPnpCapabilities()

Routine Description:

    This routine will call into the class driver to retrieve it's pnp
    capabilities.

Arguments:

    PhysicalDeviceObject - The physical device object to retrieve properties
                           for.

Return Value:

    status

--*/
NTSTATUS
ClassQueryPnpCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    )
{
    PCLASS_DRIVER_EXTENSION driverExtension =
        ClassGetDriverExtension(DeviceObject->DriverObject);
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PCLASS_QUERY_PNP_CAPABILITIES queryRoutine = NULL;

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Capabilities);

    if(commonExtension->IsFdo) {
        queryRoutine = driverExtension->InitData.FdoData.ClassQueryPnpCapabilities;
    } else {
        queryRoutine = driverExtension->InitData.PdoData.ClassQueryPnpCapabilities;
    }

    if(queryRoutine) {
        return queryRoutine(DeviceObject,
                            Capabilities);
    } else {
        return STATUS_NOT_IMPLEMENTED;
    }
} // end ClassQueryPnpCapabilities()

/*++////////////////////////////////////////////////////////////////////////////

ClassInvalidateBusRelations()

Routine Description:

    This routine re-enumerates the devices on the "bus".  It will call into
    the driver's ClassEnumerate routine to update the device objects
    immediately.  It will then schedule a bus re-enumeration for pnp by calling
    IoInvalidateDeviceRelations.

Arguments:

    Fdo - a pointer to the functional device object for this bus

Return Value:

    none

--*/
VOID
ClassInvalidateBusRelations(
    IN PDEVICE_OBJECT Fdo
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCLASS_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(Fdo->DriverObject,
                                                     CLASS_DRIVER_EXTENSION_KEY);

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT_FDO(Fdo);
    ASSERT(driverExtension->InitData.ClassEnumerateDevice != NULL);

    if(InterlockedIncrement(&(fdoExtension->EnumerationInterlock)) == 1) {
        status = driverExtension->InitData.ClassEnumerateDevice(Fdo);
    }
    InterlockedDecrement(&(fdoExtension->EnumerationInterlock));

    if(!NT_SUCCESS(status)) {

        DebugPrint((1, "ClassInvalidateBusRelations: EnumerateDevice routine "
                       "returned %lx\n", status));
    }

    IoInvalidateDeviceRelations(fdoExtension->LowerPdo, BusRelations);

    return;
} // end ClassInvalidateBusRelations()

/*++////////////////////////////////////////////////////////////////////////////

ClassRemoveDevice() ISSUE-2000/02/18-henrygab - why public?!

Routine Description:

    This routine is called to handle the "removal" of a device.  It will
    forward the request downwards if necesssary, call into the driver
    to release any necessary resources (memory, events, etc) and then
    will delete the device object.

Arguments:

    DeviceObject - a pointer to the device object being removed

    RemoveType - indicates what type of remove this is (regular or surprise).

Return Value:

    status

--*/
NTSTATUS
ClassRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR RemoveType
    )
{
    PCLASS_DRIVER_EXTENSION
        driverExtension = IoGetDriverObjectExtension(DeviceObject->DriverObject,
                                                     CLASS_DRIVER_EXTENSION_KEY);
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT lowerDeviceObject = commonExtension->LowerDeviceObject;
    PCLASS_WMI_INFO classWmiInfo;
    BOOLEAN proceedWithRemove = TRUE;
    NTSTATUS status;

    PAGED_CODE();

    commonExtension->IsRemoved = REMOVE_PENDING;

    /*
     *  Deregister from WMI.
     */
    classWmiInfo = commonExtension->IsFdo ?
                            &driverExtension->InitData.FdoData.ClassWmiInfo :
                            &driverExtension->InitData.PdoData.ClassWmiInfo;
    if (classWmiInfo->GuidRegInfo){
        status = IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_DEREGISTER);
        DBGTRACE(ClassDebugInfo, ("ClassRemoveDevice: IoWMIRegistrationControl(%p, WMI_ACTION_DEREGISTER) --> %lx", DeviceObject, status));
    }

    /*
     *  If we exposed a "shingle" (a named device interface openable by CreateFile)
     *  then delete it now.
     */
    if (commonExtension->MountedDeviceInterfaceName.Buffer){
        IoSetDeviceInterfaceState(&commonExtension->MountedDeviceInterfaceName, FALSE);
        RtlFreeUnicodeString(&commonExtension->MountedDeviceInterfaceName);
        RtlInitUnicodeString(&commonExtension->MountedDeviceInterfaceName, NULL);
    }

    //
    // If this is a surprise removal we leave the device around - which means
    // we don't have to (or want to) drop the remove lock and wait for pending
    // requests to complete.
    //

    if (RemoveType == IRP_MN_REMOVE_DEVICE){

        //
        // Release the lock we acquired when the device object was created.
        //

        ClassReleaseRemoveLock(DeviceObject, (PIRP) DeviceObject);

        DebugPrint((1, "ClasspRemoveDevice - Reference count is now %d\n",
                    commonExtension->RemoveLock));

        KeWaitForSingleObject(&commonExtension->RemoveEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        DebugPrint((1, "ClasspRemoveDevice - removing device %p\n", DeviceObject));

        if(commonExtension->IsFdo) {

            DebugPrint((1, "ClasspRemoveDevice - FDO %p has received a "
                           "remove request.\n", DeviceObject));

        }
        else {
            PPHYSICAL_DEVICE_EXTENSION pdoExtension = DeviceObject->DeviceExtension;

            if (pdoExtension->IsMissing){
                /*
                 *  The child partition PDO is missing, so we are going to go ahead
                 *  and delete it for the remove.
                 */
                DBGTRACE(ClassDebugWarning, ("ClasspRemoveDevice - PDO %p is missing and will be removed", DeviceObject));
            }
            else {
                /*
                 *  We got a remove for a child partition PDO which is not actually missing.
                 *  So we will NOT actually delete it.
                 */
                DBGTRACE(ClassDebugWarning, ("ClasspRemoveDevice - PDO %p still exists and will be removed when it disappears", DeviceObject));

                //
                // Reacquire the remove lock for the next time this comes around.
                //

                ClassAcquireRemoveLock(DeviceObject, (PIRP) DeviceObject);

                //
                // the device wasn't missing so it's not really been removed.
                //

                commonExtension->IsRemoved = NO_REMOVE;

                IoInvalidateDeviceRelations(
                    commonExtension->PartitionZeroExtension->LowerPdo,
                    BusRelations);

                proceedWithRemove = FALSE;
            }
        }
    }


    if (proceedWithRemove){

        /*
         *  Call the class driver's remove handler.
         *  All this is supposed to do is clean up its data and device interfaces.
         */
        ASSERT(commonExtension->DevInfo->ClassRemoveDevice);
        status = commonExtension->DevInfo->ClassRemoveDevice(DeviceObject, RemoveType);
        ASSERT(NT_SUCCESS(status));
        status = STATUS_SUCCESS;

        if (commonExtension->IsFdo){
            PDEVICE_OBJECT pdo;
            PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

            ClasspDisableTimer(fdoExtension->DeviceObject);

            if (RemoveType == IRP_MN_REMOVE_DEVICE){

                PPHYSICAL_DEVICE_EXTENSION child;

                //
                // Cleanup the media detection resources now that the class driver
                // has stopped it's timer (if any) and we can be sure they won't
                // call us to do detection again.
                //

                ClassCleanupMediaChangeDetection(fdoExtension);

                //
                // Cleanup any Failure Prediction stuff
                //
                if (fdoExtension->FailurePredictionInfo) {
                    ExFreePool(fdoExtension->FailurePredictionInfo);
                    fdoExtension->FailurePredictionInfo = NULL;
                }

                /*
                 *  Ordinarily all child PDOs will be removed by the time
                 *  that the parent gets the REMOVE_DEVICE.
                 *  However, if a child PDO has been created but has not
                 *  been announced in a QueryDeviceRelations, then it is
                 *  just a private data structure unknown to pnp, and we have
                 *  to delete it ourselves.
                 */
                ClassAcquireChildLock(fdoExtension);
                while (child = ClassRemoveChild(fdoExtension, NULL, FALSE)){

                    //
                    // Yank the pdo.  This routine will unlink the device from the
                    // pdo list so NextPdo will point to the next one when it's
                    // complete.
                    //
                    child->IsMissing = TRUE;
                    ClassRemoveDevice(child->DeviceObject, IRP_MN_REMOVE_DEVICE);
                }
                ClassReleaseChildLock(fdoExtension);
            }
            else if (RemoveType == IRP_MN_SURPRISE_REMOVAL){
                /*
                 *  This is a surprise-remove on the parent FDO.
                 *  We will mark the child PDOs as missing so that they
                 *  will actually get deleted when they get a REMOVE_DEVICE.
                 */
                ClassMarkChildrenMissing(fdoExtension);
            }

            ClasspFreeReleaseRequest(DeviceObject);

            if (RemoveType == IRP_MN_REMOVE_DEVICE){

                //
                // Free FDO-specific data structs
                //
                if (fdoExtension->PrivateFdoData){

                    DestroyAllTransferPackets(DeviceObject);

                    ExFreePool(fdoExtension->PrivateFdoData);
                    fdoExtension->PrivateFdoData = NULL;
                }

                if (commonExtension->DeviceName.Buffer) {
                    ExFreePool(commonExtension->DeviceName.Buffer);
                    RtlInitUnicodeString(&commonExtension->DeviceName, NULL);
                }

                if (fdoExtension->AdapterDescriptor) {
                    ExFreePool(fdoExtension->AdapterDescriptor);
                    fdoExtension->AdapterDescriptor = NULL;
                }

                if (fdoExtension->DeviceDescriptor) {
                    ExFreePool(fdoExtension->DeviceDescriptor);
                    fdoExtension->DeviceDescriptor = NULL;
                }

                //
                // Detach our device object from the stack - there's no reason
                // to hold off our cleanup any longer.
                //

                IoDetachDevice(lowerDeviceObject);
            }
        }
        else {
            /*
             *  This is a child partition PDO.
             *  We have already determined that it was previously marked
             *  as missing.  So if this is a REMOVE_DEVICE, we will actually
             *  delete it.
             */
            if (RemoveType == IRP_MN_REMOVE_DEVICE){
                PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
                    commonExtension->PartitionZeroExtension;
                PPHYSICAL_DEVICE_EXTENSION pdoExtension =
                    (PPHYSICAL_DEVICE_EXTENSION) commonExtension;

                //
                // See if this device is in the child list (if this was a suprise
                // removal it might be) and remove it.
                //

                ClassRemoveChild(fdoExtension, pdoExtension, TRUE);
            }
        }

        commonExtension->PartitionLength.QuadPart = 0;

        if (RemoveType == IRP_MN_REMOVE_DEVICE){
            IoDeleteDevice(DeviceObject);
        }
    }

    return STATUS_SUCCESS;
} // end ClassRemoveDevice()

/*++////////////////////////////////////////////////////////////////////////////

ClassGetDriverExtension()

Routine Description:

    This routine will return the classpnp's driver extension.

Arguments:

    DriverObject - the driver object for which to get classpnp's extension

Return Value:

    Either NULL if none, or a pointer to the driver extension

--*/
PCLASS_DRIVER_EXTENSION
ClassGetDriverExtension(
    IN PDRIVER_OBJECT DriverObject
    )
{
    return IoGetDriverObjectExtension(DriverObject, CLASS_DRIVER_EXTENSION_KEY);
} // end ClassGetDriverExtension()

/*++////////////////////////////////////////////////////////////////////////////

ClasspStartIo()

Routine Description:

    This routine wraps the class driver's start io routine.  If the device
    is being removed it will complete any requests with
    STATUS_DEVICE_DOES_NOT_EXIST and fire up the next packet.

Arguments:

Return Value:

    none

--*/
VOID
ClasspStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    //
    // We're already holding the remove lock so just check the variable and
    // see what's going on.
    //

    if(commonExtension->IsRemoved) {

        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;

        ClassAcquireRemoveLock(DeviceObject, (PIRP) ClasspStartIo);
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_DISK_INCREMENT);
        IoStartNextPacket(DeviceObject, FALSE);
        ClassReleaseRemoveLock(DeviceObject, (PIRP) ClasspStartIo);
        return;
    }

    commonExtension->DriverExtension->InitData.ClassStartIo(
        DeviceObject,
        Irp);

    return;
} // ClasspStartIo()

/*++////////////////////////////////////////////////////////////////////////////

ClassUpdateInformationInRegistry()

Routine Description:

    This routine has knowledge about the layout of the device map information
    in the registry.  It will update this information to include a value
    entry specifying the dos device name that is assumed to get assigned
    to this NT device name.  For more information on this assigning of the
    dos device name look in the drive support routine in the hal that assigns
    all dos names.

    Since some versions of some device's firmware did not work and some
    vendors did not bother to follow the specification, the entire inquiry
    information must also be stored in the registry so than someone can
    figure out the firmware version.

Arguments:

    DeviceObject - A pointer to the device object for the tape device.

Return Value:

    None

--*/
VOID
ClassUpdateInformationInRegistry(
    IN PDEVICE_OBJECT     Fdo,
    IN PCHAR              DeviceName,
    IN ULONG              DeviceNumber,
    IN PINQUIRYDATA       InquiryData,
    IN ULONG              InquiryDataLength
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    NTSTATUS          status;
    SCSI_ADDRESS      scsiAddress;
    OBJECT_ATTRIBUTES objectAttributes;
    PUCHAR            buffer;
    STRING            string;
    UNICODE_STRING    unicodeName;
    UNICODE_STRING    unicodeRegistryPath;
    UNICODE_STRING    unicodeData;
    HANDLE            targetKey;
    IO_STATUS_BLOCK   ioStatus;


    PAGED_CODE();

    ASSERT(DeviceName);
    fdoExtension = Fdo->DeviceExtension;
    buffer = NULL;
    targetKey = NULL;
    RtlZeroMemory(&unicodeName,         sizeof(UNICODE_STRING));
    RtlZeroMemory(&unicodeData,         sizeof(UNICODE_STRING));
    RtlZeroMemory(&unicodeRegistryPath, sizeof(UNICODE_STRING));

    TRY {

        //
        // Issue GET_ADDRESS Ioctl to determine path, target, and lun information.
        //

        ClassSendDeviceIoControlSynchronous(
            IOCTL_SCSI_GET_ADDRESS,
            Fdo,
            &scsiAddress,
            0,
            sizeof(SCSI_ADDRESS),
            FALSE,
            &ioStatus
            );

        if (!NT_SUCCESS(ioStatus.Status)) {

            status = ioStatus.Status;
            DebugPrint((1,
                        "UpdateInformationInRegistry: Get Address failed %lx\n",
                        status));
            LEAVE;

        } else {

            DebugPrint((1,
                        "GetAddress: Port %x, Path %x, Target %x, Lun %x\n",
                        scsiAddress.PortNumber,
                        scsiAddress.PathId,
                        scsiAddress.TargetId,
                        scsiAddress.Lun));

        }

        //
        // Allocate a buffer for the reg. spooge.
        //

        buffer = ExAllocatePoolWithTag(PagedPool, 1024, '6BcS');

        if (buffer == NULL) {

            //
            // There is not return value for this.  Since this is done at
            // claim device time (currently only system initialization) getting
            // the registry information correct will be the least of the worries.
            //

            LEAVE;
        }

        sprintf(buffer,
                "\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target Id %d\\Logical Unit Id %d",
                scsiAddress.PortNumber,
                scsiAddress.PathId,
                scsiAddress.TargetId,
                scsiAddress.Lun);

        RtlInitString(&string, buffer);

        status = RtlAnsiStringToUnicodeString(&unicodeRegistryPath,
                                              &string,
                                              TRUE);

        if (!NT_SUCCESS(status)) {
            LEAVE;
        }

        //
        // Open the registry key for the scsi information for this
        // scsibus, target, lun.
        //

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeRegistryPath,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        status = ZwOpenKey(&targetKey,
                           KEY_READ | KEY_WRITE,
                           &objectAttributes);

        if (!NT_SUCCESS(status)) {
            LEAVE;
        }

        //
        // Now construct and attempt to create the registry value
        // specifying the device name in the appropriate place in the
        // device map.
        //

        RtlInitUnicodeString(&unicodeName, L"DeviceName");

        sprintf(buffer, "%s%d", DeviceName, DeviceNumber);
        RtlInitString(&string, buffer);
        status = RtlAnsiStringToUnicodeString(&unicodeData,
                                              &string,
                                              TRUE);
        if (NT_SUCCESS(status)) {
            status = ZwSetValueKey(targetKey,
                                   &unicodeName,
                                   0,
                                   REG_SZ,
                                   unicodeData.Buffer,
                                   unicodeData.Length);
        }

        //
        // if they sent in data, update the registry
        //

        if (InquiryDataLength) {

            ASSERT(InquiryData);

            RtlInitUnicodeString(&unicodeName, L"InquiryData");
            status = ZwSetValueKey(targetKey,
                                   &unicodeName,
                                   0,
                                   REG_BINARY,
                                   InquiryData,
                                   InquiryDataLength);
        }

        // that's all, except to clean up.

    } FINALLY {

        if (unicodeData.Buffer) {
            RtlFreeUnicodeString(&unicodeData);
        }
        if (unicodeRegistryPath.Buffer) {
            RtlFreeUnicodeString(&unicodeRegistryPath);
        }
        if (targetKey) {
            ZwClose(targetKey);
        }
        if (buffer) {
            ExFreePool(buffer);
        }

    }

} // end ClassUpdateInformationInRegistry()

/*++////////////////////////////////////////////////////////////////////////////

ClasspSendSynchronousCompletion()

Routine Description:

    This completion routine will set the user event in the irp after
    freeing the irp and the associated MDL (if any).

Arguments:

    DeviceObject - the device object which requested the completion routine

    Irp - the irp being completed

    Context - unused

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
NTSTATUS
ClasspSendSynchronousCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    DebugPrint((3, "ClasspSendSynchronousCompletion: %p %p %p\n",
                   DeviceObject, Irp, Context));
    //
    // First set the status and information fields in the io status block
    // provided by the caller.
    //

    *(Irp->UserIosb) = Irp->IoStatus;

    //
    // Unlock the pages for the data buffer.
    //

    if(Irp->MdlAddress) {
        MmUnlockPages(Irp->MdlAddress);
        IoFreeMdl(Irp->MdlAddress);
    }

    //
    // Signal the caller's event.
    //

    KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, FALSE);

    //
    // Free the MDL and the IRP.
    //

    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
} // end ClasspSendSynchronousCompletion()

/*++

    ISSUE-2000/02/20-henrygab Not documented ClasspRegisterMountedDeviceInterface

--*/
VOID
ClasspRegisterMountedDeviceInterface(
    IN PDEVICE_OBJECT DeviceObject
    )
{

    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    BOOLEAN isFdo = commonExtension->IsFdo;

    PDEVICE_OBJECT pdo;
    UNICODE_STRING interfaceName;

    NTSTATUS status;

    if(isFdo) {

        PFUNCTIONAL_DEVICE_EXTENSION functionalExtension;

        functionalExtension =
            (PFUNCTIONAL_DEVICE_EXTENSION) commonExtension;
        pdo = functionalExtension->LowerPdo;
    } else {
        pdo = DeviceObject;
    }

    status = IoRegisterDeviceInterface(
                pdo,
                &MOUNTDEV_MOUNTED_DEVICE_GUID,
                NULL,
                &interfaceName
                );

    if(NT_SUCCESS(status)) {

        //
        // Copy the interface name before setting the interface state - the
        // name is needed by the components we notify.
        //

        commonExtension->MountedDeviceInterfaceName = interfaceName;
        status = IoSetDeviceInterfaceState(&interfaceName, TRUE);

        if(!NT_SUCCESS(status)) {
            RtlFreeUnicodeString(&interfaceName);
        }
    }

    if(!NT_SUCCESS(status)) {
        RtlInitUnicodeString(&(commonExtension->MountedDeviceInterfaceName),
                             NULL);
    }
    return;
} // end ClasspRegisterMountedDeviceInterface()

/*++////////////////////////////////////////////////////////////////////////////

ClassSendDeviceIoControlSynchronous()

Routine Description:

    This routine is based upon IoBuildDeviceIoControlRequest().  It has been
    modified to reduce code and memory by not double-buffering the io, using
    the same buffer for both input and output, allocating and deallocating
    the mdl on behalf of the caller, and waiting for the io to complete.

    This routine also works around the rare cases in which APC's are disabled.
    Since IoBuildDeviceIoControl() used APC's to signal completion, this had
    led to a number of difficult-to-detect hangs, where the irp was completed,
    but the event passed to IoBuild..() was still being waited upon by the
    caller.

Arguments:

    IoControlCode - the IOCTL to send

    TargetDeviceObject - the device object that should handle the ioctl

    Buffer - the input and output buffer, or NULL if no input/output

    InputBufferLength - the number of bytes prepared for the IOCTL in Buffer

    OutputBufferLength - the number of bytes to be filled in upon success

    InternalDeviceIoControl - if TRUE, uses IRP_MJ_INTERNAL_DEVICE_CONTROL

    IoStatus - the status block that contains the results of the operation

Return Value:

--*/
VOID
ClassSendDeviceIoControlSynchronous(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    OUT PIO_STATUS_BLOCK IoStatus
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG method;

    PAGED_CODE();

    irp = NULL;
    method = IoControlCode & 3;


    #if DBG // Begin Argument Checking (nop in fre version)

        ASSERT(ARGUMENT_PRESENT(IoStatus));

        if ((InputBufferLength != 0) || (OutputBufferLength != 0)) {
            ASSERT(ARGUMENT_PRESENT(Buffer));
        }
        else {
            ASSERT(!ARGUMENT_PRESENT(Buffer));
        }
    #endif

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(TargetDeviceObject->StackSize, FALSE);
    if (!irp) {
        (*IoStatus).Information = 0;
        (*IoStatus).Status = STATUS_INSUFFICIENT_RESOURCES;
        return;
    }

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    //
    // Set the major function code based on the type of device I/O control
    // function the caller has specified.
    //

    if (InternalDeviceIoControl) {
        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    } else {
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all four methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;

    //
    // Get the method bits from the I/O control code to determine how the
    // buffers are to be passed to the driver.
    //

    switch (method) {
        // case 0
        case METHOD_BUFFERED: {
            if ((InputBufferLength != 0) || (OutputBufferLength != 0)) {

                irp->AssociatedIrp.SystemBuffer =
                    ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                          max(InputBufferLength, OutputBufferLength),
                                          CLASS_TAG_DEVICE_CONTROL
                                          );

                if (irp->AssociatedIrp.SystemBuffer == NULL) {
                    IoFreeIrp(irp);
                    (*IoStatus).Information = 0;
                    (*IoStatus).Status = STATUS_INSUFFICIENT_RESOURCES;
                    return;
                }

                if (InputBufferLength != 0) {
                    RtlCopyMemory(irp->AssociatedIrp.SystemBuffer,
                                  Buffer,
                                  InputBufferLength);
                }
            } // end of buffering

            irp->UserBuffer = Buffer;
            break;
        }

        // case 1, case 2
        case METHOD_IN_DIRECT:
        case METHOD_OUT_DIRECT: {


            if (InputBufferLength != 0) {
                irp->AssociatedIrp.SystemBuffer = Buffer;
            }

            if (OutputBufferLength != 0) {

                irp->MdlAddress = IoAllocateMdl(Buffer,
                                                OutputBufferLength,
                                                FALSE, FALSE,
                                                (PIRP) NULL);

                if (irp->MdlAddress == NULL) {
                    IoFreeIrp(irp);
                    (*IoStatus).Information = 0;
                    (*IoStatus).Status = STATUS_INSUFFICIENT_RESOURCES;
                    return;
                }

                if (method == METHOD_IN_DIRECT) {
                    MmProbeAndLockPages(irp->MdlAddress,
                                        KernelMode,
                                        IoReadAccess);
                } else if (method == METHOD_OUT_DIRECT) {
                    MmProbeAndLockPages(irp->MdlAddress,
                                        KernelMode,
                                        IoWriteAccess);
                } else {
                    ASSERT(!"If other methods reach here, code is out of date");
                }
            }
            break;
        }

        // case 3
        case METHOD_NEITHER: {

            ASSERT(!"This routine does not support METHOD_NEITHER ioctls");
            IoStatus->Information = 0;
            IoStatus->Status = STATUS_NOT_SUPPORTED;
            return;
            break;
        }
    } // end of switch(method)

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // send the irp synchronously
    //

    ClassSendIrpSynchronous(TargetDeviceObject, irp);

    //
    // copy the iostatus block for the caller
    //

    *IoStatus = irp->IoStatus;

    //
    // free any allocated resources
    //

    switch (method) {
        case METHOD_BUFFERED: {

            ASSERT(irp->UserBuffer == Buffer);

            //
            // first copy the buffered result, if any
            // Note that there are no security implications in
            // not checking for success since only drivers can
            // call into this routine anyways...
            //

            if (OutputBufferLength != 0) {
                RtlCopyMemory(Buffer, // irp->UserBuffer
                              irp->AssociatedIrp.SystemBuffer,
                              OutputBufferLength
                              );
            }

            //
            // then free the memory allocated to buffer the io
            //

            if ((InputBufferLength !=0) || (OutputBufferLength != 0)) {
                ExFreePool(irp->AssociatedIrp.SystemBuffer);
                irp->AssociatedIrp.SystemBuffer = NULL;
            }
            break;
        }

        case METHOD_IN_DIRECT:
        case METHOD_OUT_DIRECT: {

            //
            // we alloc a mdl if there is an output buffer specified
            // free it here after unlocking the pages
            //

            if (OutputBufferLength != 0) {
                ASSERT(irp->MdlAddress != NULL);
                MmUnlockPages(irp->MdlAddress);
                IoFreeMdl(irp->MdlAddress);
                irp->MdlAddress = (PMDL) NULL;
            }
            break;
        }

        case METHOD_NEITHER: {
            ASSERT(!"Code is out of date");
            break;
        }
    }

    //
    // we always have allocated an irp.  free it here.
    //

    IoFreeIrp(irp);
    irp = (PIRP) NULL;

    //
    // return the io status block's status to the caller
    //

    return;
} // end ClassSendDeviceIoControlSynchronous()

/*++////////////////////////////////////////////////////////////////////////////

ClassForwardIrpSynchronous()

Routine Description:

    Forwards a given irp to the next lower device object.

Arguments:

    CommonExtension - the common class extension

    Irp - the request to forward down the stack

Return Value:

--*/
NTSTATUS
ClassForwardIrpSynchronous(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PIRP Irp
    )
{
    IoCopyCurrentIrpStackLocationToNext(Irp);
    return ClassSendIrpSynchronous(CommonExtension->LowerDeviceObject, Irp);
} // end ClassForwardIrpSynchronous()

/*++////////////////////////////////////////////////////////////////////////////

ClassSendIrpSynchronous()

Routine Description:

    This routine sends the given irp to the given device object, and waits for
    it to complete.  On debug versions, will print out a debug message and
    optionally assert for "lost" irps based upon classpnp's globals

Arguments:

    TargetDeviceObject - the device object to handle this irp

    Irp - the request to be sent

Return Value:

--*/
NTSTATUS
ClassSendIrpSynchronous(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIRP Irp
    )
{
    KEVENT event;
    NTSTATUS status;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
    ASSERT(TargetDeviceObject != NULL);
    ASSERT(Irp != NULL);
    ASSERT(Irp->StackCount >= TargetDeviceObject->StackSize);

    //
    // ISSUE-2000/02/20-henrygab   What if APCs are disabled?
    //    May need to enter critical section before IoCallDriver()
    //    until the event is hit?
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);
    IoSetCompletionRoutine(Irp, ClassSignalCompletion, &event,
                           TRUE, TRUE, TRUE);

    status = IoCallDriver(TargetDeviceObject, Irp);

    if (status == STATUS_PENDING) {

        #if DBG
            LARGE_INTEGER timeout;

            timeout.QuadPart = (LONGLONG)(-1 * 10 * 1000 * (LONGLONG)1000 *
                                          ClasspnpGlobals.SecondsToWaitForIrps);

            do {
                status = KeWaitForSingleObject(&event,
                                               Executive,
                                               KernelMode,
                                               FALSE,
                                               &timeout);


                if (status == STATUS_TIMEOUT) {

                    //
                    // This DebugPrint should almost always be investigated by the
                    // party who sent the irp and/or the current owner of the irp.
                    // Synchronous Irps should not take this long (currently 30
                    // seconds) without good reason.  This points to a potentially
                    // serious problem in the underlying device stack.
                    //

                    DebugPrint((0, "ClassSendIrpSynchronous: (%p) irp %p did not "
                                "complete within %x seconds\n",
                                TargetDeviceObject, Irp,
                                ClasspnpGlobals.SecondsToWaitForIrps
                                ));

                    if (ClasspnpGlobals.BreakOnLostIrps != 0) {
                        ASSERT(!" - Irp failed to complete within 30 seconds - ");
                    }
                }


            } while (status==STATUS_TIMEOUT);
        #else
            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        #endif

        status = Irp->IoStatus.Status;
    }

    return status;
} // end ClassSendIrpSynchronous()

/*++////////////////////////////////////////////////////////////////////////////

ClassGetVpb()

Routine Description:

    This routine returns the current VPB (Volume Parameter Block) for the
    given device object.
    The Vpb field is only visible in the ntddk.h (not the wdm.h) definition
    of DEVICE_OBJECT; hence this exported function.

Arguments:

    DeviceObject - the device to get the VPB for

Return Value:

    the VPB, or NULL if none.

--*/
PVPB
ClassGetVpb(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    return DeviceObject->Vpb;
} // end ClassGetVpb()

/*++

    ISSUE-2000/02/20-henrygab Not documented ClasspAllocateReleaseRequest

--*/
NTSTATUS
ClasspAllocateReleaseRequest(
    IN PDEVICE_OBJECT Fdo
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack;

    KeInitializeSpinLock(&(fdoExtension->ReleaseQueueSpinLock));

    fdoExtension->ReleaseQueueNeeded = FALSE;
    fdoExtension->ReleaseQueueInProgress = FALSE;
    fdoExtension->ReleaseQueueIrpFromPool = FALSE;

    //
    // The class driver is responsible for allocating a properly sized irp,
    // or ClassReleaseQueue will attempt to do it on the first error.
    //

    fdoExtension->ReleaseQueueIrp = NULL;

    //
    // Write length to SRB.
    //

    fdoExtension->ReleaseQueueSrb.Length = sizeof(SCSI_REQUEST_BLOCK);

    return STATUS_SUCCESS;
} // end ClasspAllocateReleaseRequest()

/*++

    ISSUE-2000/02/20-henrygab Not documented ClasspFreeReleaseRequest

--*/
VOID
ClasspFreeReleaseRequest(
    IN PDEVICE_OBJECT Fdo
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    //KIRQL oldIrql;

    ASSERT(fdoExtension->CommonExtension.IsRemoved != NO_REMOVE);

    //
    // free anything the driver allocated
    //

    if (fdoExtension->ReleaseQueueIrp) {
        if (fdoExtension->ReleaseQueueIrpFromPool) {
            ExFreePool(fdoExtension->ReleaseQueueIrp);
        } else {
            IoFreeIrp(fdoExtension->ReleaseQueueIrp);
        }
        fdoExtension->ReleaseQueueIrp = NULL;
    }

    //
    // free anything that we allocated
    //

    if ((fdoExtension->PrivateFdoData) &&
        (fdoExtension->PrivateFdoData->ReleaseQueueIrpAllocated)) {

        ExFreePool(fdoExtension->PrivateFdoData->ReleaseQueueIrp);
        fdoExtension->PrivateFdoData->ReleaseQueueIrpAllocated = FALSE;
        fdoExtension->PrivateFdoData->ReleaseQueueIrp = NULL;
    }

    return;
} // end ClasspFreeReleaseRequest()

/*++////////////////////////////////////////////////////////////////////////////

ClassReleaseQueue()

Routine Description:

    This routine issues an internal device control command
    to the port driver to release a frozen queue. The call
    is issued asynchronously as ClassReleaseQueue will be invoked
    from the IO completion DPC (and will have no context to
    wait for a synchronous call to complete).

    This routine must be called with the remove lock held.

Arguments:

    Fdo - The functional device object for the device with the frozen queue.

Return Value:

    None.

--*/
VOID
ClassReleaseQueue(
    IN PDEVICE_OBJECT Fdo
    )
{
    ClasspReleaseQueue(Fdo, NULL);
    return;
} // end ClassReleaseQueue()

/*++////////////////////////////////////////////////////////////////////////////

ClasspAllocateReleaseQueueIrp()

Routine Description:

    This routine allocates the release queue irp held in classpnp's private
    extension.  This was added to allow no-memory conditions to be more
    survivable.

Return Value:

    NT_SUCCESS value.

Notes:

    Does not grab the spinlock.  Should only be called from StartDevice()
    routine.  May be called elsewhere for poorly-behaved drivers that cause
    the queue to lockup before the device is started.  This should *never*
    occur, since it's illegal to send a request to a non-started PDO.  This
    condition is checked for in ClasspReleaseQueue().

--*/
NTSTATUS
ClasspAllocateReleaseQueueIrp(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    KIRQL oldIrql;
    UCHAR lowerStackSize;

    //
    // do an initial check w/o the spinlock
    //

    if (FdoExtension->PrivateFdoData->ReleaseQueueIrpAllocated) {
        return STATUS_SUCCESS;
    }


    lowerStackSize = FdoExtension->CommonExtension.LowerDeviceObject->StackSize;

    //
    // don't allocate one if one is in progress!  this means whoever called
    // this routine didn't check if one was in progress.
    //

    ASSERT(!(FdoExtension->ReleaseQueueInProgress));

    FdoExtension->PrivateFdoData->ReleaseQueueIrp =
        ExAllocatePoolWithTag(NonPagedPool,
                              IoSizeOfIrp(lowerStackSize),
                              CLASS_TAG_RELEASE_QUEUE
                              );

    if (FdoExtension->PrivateFdoData->ReleaseQueueIrp == NULL) {
        DebugPrint((0, "ClassPnpStartDevice: Cannot allocate for "
                    "release queue irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    IoInitializeIrp(FdoExtension->PrivateFdoData->ReleaseQueueIrp,
                    IoSizeOfIrp(lowerStackSize),
                    lowerStackSize);
    FdoExtension->PrivateFdoData->ReleaseQueueIrpAllocated = TRUE;

    return STATUS_SUCCESS;
}


/*++////////////////////////////////////////////////////////////////////////////

ClasspReleaseQueue()

Routine Description:

    This routine issues an internal device control command
    to the port driver to release a frozen queue. The call
    is issued asynchronously as ClassReleaseQueue will be invoked
    from the IO completion DPC (and will have no context to
    wait for a synchronous call to complete).

    This routine must be called with the remove lock held.

Arguments:

    Fdo - The functional device object for the device with the frozen queue.

    ReleaseQueueIrp - If this irp is supplied then the test to determine whether
                      a release queue request is in progress will be ignored.
                      The irp provided must be the IRP originally allocated
                      for release queue requests (so this parameter can only
                      really be provided by the release queue completion
                      routine.)

Return Value:

    None.

--*/
VOID
ClasspReleaseQueue(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP ReleaseQueueIrp OPTIONAL
    )
{
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PDEVICE_OBJECT lowerDevice;
    PSCSI_REQUEST_BLOCK srb;
    KIRQL currentIrql;

    lowerDevice = fdoExtension->CommonExtension.LowerDeviceObject;

    //
    // we raise irql seperately so we're not swapped out or suspended
    // while holding the release queue irp in this routine.  this lets
    // us release the spin lock before lowering irql.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

    KeAcquireSpinLockAtDpcLevel(&(fdoExtension->ReleaseQueueSpinLock));

    //
    // make sure that if they passed us an irp, it matches our allocated irp.
    //

    ASSERT((ReleaseQueueIrp == NULL) ||
           (ReleaseQueueIrp == fdoExtension->PrivateFdoData->ReleaseQueueIrp));

    //
    // ASSERT that we've already allocated this. (should not occur)
    // try to allocate it anyways, then finally bugcheck if
    // there's still no memory...
    //

    ASSERT(fdoExtension->PrivateFdoData->ReleaseQueueIrpAllocated);
    if (!fdoExtension->PrivateFdoData->ReleaseQueueIrpAllocated) {
        ClasspAllocateReleaseQueueIrp(fdoExtension);
    }
    if (!fdoExtension->PrivateFdoData->ReleaseQueueIrpAllocated) {
        KeBugCheckEx(SCSI_DISK_DRIVER_INTERNAL, 0x12, (ULONG_PTR)Fdo, 0x0, 0x0);
    }

    if ((fdoExtension->ReleaseQueueInProgress) && (ReleaseQueueIrp == NULL)) {

        //
        // Someone is already using the irp - just set the flag to indicate that
        // we need to release the queue again.
        //

        fdoExtension->ReleaseQueueNeeded = TRUE;
        KeReleaseSpinLockFromDpcLevel(&(fdoExtension->ReleaseQueueSpinLock));
        KeLowerIrql(currentIrql);
        return;

    }

    //
    // Mark that there is a release queue in progress and drop the spinlock.
    //

    fdoExtension->ReleaseQueueInProgress = TRUE;
    if (ReleaseQueueIrp) {
        irp = ReleaseQueueIrp;
    } else {
        irp = fdoExtension->PrivateFdoData->ReleaseQueueIrp;
    }
    srb = &(fdoExtension->ReleaseQueueSrb);

    KeReleaseSpinLockFromDpcLevel(&(fdoExtension->ReleaseQueueSpinLock));

    ASSERT(irp != NULL);

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    srb->OriginalRequest = irp;

    //
    // Store the SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = srb;

    //
    // If this device is removable then flush the queue.  This will also
    // release it.
    //

    if (TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)){
       srb->Function = SRB_FUNCTION_FLUSH_QUEUE;
    }
    else {
       srb->Function = SRB_FUNCTION_RELEASE_QUEUE;
    }

    ClassAcquireRemoveLock(Fdo, irp);

    IoSetCompletionRoutine(irp,
                           ClassReleaseQueueCompletion,
                           Fdo,
                           TRUE,
                           TRUE,
                           TRUE);

    IoCallDriver(lowerDevice, irp);

    KeLowerIrql(currentIrql);

    return;

} // end ClassReleaseQueue()

/*++////////////////////////////////////////////////////////////////////////////

ClassReleaseQueueCompletion()

Routine Description:

    This routine is called when an asynchronous I/O request
    which was issused by the class driver completes.  Examples of such requests
    are release queue or START UNIT. This routine releases the queue if
    necessary.  It then frees the context and the IRP.

Arguments:

    DeviceObject - The device object for the logical unit; however since this
        is the top stack location the value is NULL.

    Irp - Supplies a pointer to the Irp to be processed.

    Context - Supplies the context to be used to process this request.

Return Value:

    None.

--*/
NTSTATUS
ClassReleaseQueueCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    KIRQL oldIrql;

    BOOLEAN releaseQueueNeeded;

    DeviceObject = Context;

    fdoExtension = DeviceObject->DeviceExtension;

    ClassReleaseRemoveLock(DeviceObject, Irp);

    //
    // Grab the spinlock and clear the release queue in progress flag so others
    // can run.  Save (and clear) the state of the release queue needed flag
    // so that we can issue a new release queue outside the spinlock.
    //

    KeAcquireSpinLock(&(fdoExtension->ReleaseQueueSpinLock), &oldIrql);

    releaseQueueNeeded = fdoExtension->ReleaseQueueNeeded;

    fdoExtension->ReleaseQueueNeeded = FALSE;
    fdoExtension->ReleaseQueueInProgress = FALSE;

    KeReleaseSpinLock(&(fdoExtension->ReleaseQueueSpinLock), oldIrql);

    //
    // If we need a release queue then issue one now.  Another processor may
    // have already started one in which case we'll try to issue this one after
    // it is done - but we should never recurse more than one deep.
    //

    if(releaseQueueNeeded) {
        ClasspReleaseQueue(DeviceObject, Irp);
    }

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // ClassAsynchronousCompletion()

/*++////////////////////////////////////////////////////////////////////////////

ClassAcquireChildLock()

Routine Description:

    This routine acquires the lock protecting children PDOs.  It may be
    acquired recursively by the same thread, but must be release by the
    thread once for each acquisition.

Arguments:

    FdoExtension - the device whose child list is protected.

Return Value:

    None

--*/
VOID
ClassAcquireChildLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PAGED_CODE();

    if(FdoExtension->ChildLockOwner != KeGetCurrentThread()) {
        KeWaitForSingleObject(&FdoExtension->ChildLock,
                              Executive, KernelMode,
                              FALSE, NULL);

        ASSERT(FdoExtension->ChildLockOwner == NULL);
        ASSERT(FdoExtension->ChildLockAcquisitionCount == 0);

        FdoExtension->ChildLockOwner = KeGetCurrentThread();
    } else {
        ASSERT(FdoExtension->ChildLockAcquisitionCount != 0);
    }

    FdoExtension->ChildLockAcquisitionCount++;
    return;
}

/*++////////////////////////////////////////////////////////////////////////////

ClassReleaseChildLock() ISSUE-2000/02/18-henrygab - not documented

Routine Description:

    This routine releases the lock protecting children PDOs.  It must be
    called once for each time ClassAcquireChildLock was called.

Arguments:

    FdoExtension - the device whose child list is protected

Return Value:

    None.

--*/
VOID
ClassReleaseChildLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    ASSERT(FdoExtension->ChildLockOwner == KeGetCurrentThread());
    ASSERT(FdoExtension->ChildLockAcquisitionCount != 0);

    FdoExtension->ChildLockAcquisitionCount -= 1;

    if(FdoExtension->ChildLockAcquisitionCount == 0) {
        FdoExtension->ChildLockOwner = NULL;
        KeSetEvent(&FdoExtension->ChildLock, IO_NO_INCREMENT, FALSE);
    }

    return;
} // end ClassReleaseChildLock(

/*++////////////////////////////////////////////////////////////////////////////

ClassAddChild()

Routine Description:

    This routine will insert a new child into the head of the child list.

Arguments:

    Parent - the child's parent (contains the head of the list)
    Child - the child to be inserted.
    AcquireLock - whether the child lock should be acquired (TRUE) or whether
                  it's already been acquired by or on behalf of the caller
                  (FALSE).

Return Value:

    None.

--*/
VOID
ClassAddChild(
    IN PFUNCTIONAL_DEVICE_EXTENSION Parent,
    IN PPHYSICAL_DEVICE_EXTENSION Child,
    IN BOOLEAN AcquireLock
    )
{
    if(AcquireLock) {
        ClassAcquireChildLock(Parent);
    }

    #if DBG
        //
        // Make sure this child's not already in the list.
        //
        {
            PPHYSICAL_DEVICE_EXTENSION testChild;

            for (testChild = Parent->CommonExtension.ChildList;
                 testChild != NULL;
                 testChild = testChild->CommonExtension.ChildList) {

                ASSERT(testChild != Child);
            }
        }
    #endif

    Child->CommonExtension.ChildList = Parent->CommonExtension.ChildList;
    Parent->CommonExtension.ChildList = Child;

    if(AcquireLock) {
        ClassReleaseChildLock(Parent);
    }
    return;
} // end ClassAddChild()

/*++////////////////////////////////////////////////////////////////////////////

ClassRemoveChild()

Routine Description:

    This routine will remove a child from the child list.

Arguments:

    Parent - the parent to be removed from.

    Child - the child to be removed or NULL if the first child should be
            removed.

    AcquireLock - whether the child lock should be acquired (TRUE) or whether
                  it's already been acquired by or on behalf of the caller
                  (FALSE).

Return Value:

    A pointer to the child which was removed or NULL if no such child could
    be found in the list (or if Child was NULL but the list is empty).

--*/
PPHYSICAL_DEVICE_EXTENSION
ClassRemoveChild(
    IN PFUNCTIONAL_DEVICE_EXTENSION Parent,
    IN PPHYSICAL_DEVICE_EXTENSION Child,
    IN BOOLEAN AcquireLock
    )
{
    if(AcquireLock) {
        ClassAcquireChildLock(Parent);
    }

    TRY {
        PCOMMON_DEVICE_EXTENSION previousChild = &Parent->CommonExtension;

        //
        // If the list is empty then bail out now.
        //

        if(Parent->CommonExtension.ChildList == NULL) {
            Child = NULL;
            LEAVE;
        }

        //
        // If the caller specified a child then find the child object before
        // it.  If none was specified then the FDO is the child object before
        // the one we want to remove.
        //

        if(Child != NULL) {

            //
            // Scan through the child list to find the entry which points to
            // this one.
            //

            do {
                ASSERT(previousChild != &Child->CommonExtension);

                if(previousChild->ChildList == Child) {
                    break;
                }

                previousChild = &previousChild->ChildList->CommonExtension;
            } while(previousChild != NULL);

            if(previousChild == NULL) {
                Child = NULL;
                LEAVE;
            }
        }

        //
        // Save the next child away then unlink it from the list.
        //

        Child = previousChild->ChildList;
        previousChild->ChildList = Child->CommonExtension.ChildList;
        Child->CommonExtension.ChildList = NULL;

    } FINALLY {
        if(AcquireLock) {
            ClassReleaseChildLock(Parent);
        }
    }
    return Child;
} // end ClassRemoveChild()


/*++

    ISSUE-2000/02/20-henrygab Not documented ClasspRetryRequestDpc

--*/
VOID
ClasspRetryRequestDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Arg1,
    IN PVOID Arg2
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData;
    PCLASS_RETRY_INFO retryList;
    KIRQL irql;


    commonExtension = DeviceObject->DeviceExtension;
    ASSERT(commonExtension->IsFdo);
    fdoExtension = DeviceObject->DeviceExtension;
    fdoData = fdoExtension->PrivateFdoData;


    KeAcquireSpinLock(&fdoData->Retry.Lock, &irql);
    {
        LARGE_INTEGER now;
        KeQueryTickCount(&now);

        //
        // if CurrentTick is less than now
        //      fire another DPC
        // else
        //      retry entire list
        // endif
        //

        if (now.QuadPart < fdoData->Retry.Tick.QuadPart) {

            ClasspRetryDpcTimer(fdoData);
            retryList = NULL;

        } else {

            retryList = fdoData->Retry.ListHead;
            fdoData->Retry.ListHead = NULL;
            fdoData->Retry.Delta.QuadPart = (LONGLONG)0;
            fdoData->Retry.Tick.QuadPart  = (LONGLONG)0;

        }
    }
    KeReleaseSpinLock(&fdoData->Retry.Lock, irql);

    while (retryList != NULL) {

        PIRP irp;

        irp = CONTAINING_RECORD(retryList, IRP, Tail.Overlay.DriverContext[0]);
        DebugPrint((ClassDebugDelayedRetry, "ClassRetry:  -- %p\n", irp));
        retryList = retryList->Next;
        #if DBG
            irp->Tail.Overlay.DriverContext[0] = ULongToPtr(0xdddddddd); // invalidate data
            irp->Tail.Overlay.DriverContext[1] = ULongToPtr(0xdddddddd); // invalidate data
            irp->Tail.Overlay.DriverContext[2] = ULongToPtr(0xdddddddd); // invalidate data
            irp->Tail.Overlay.DriverContext[3] = ULongToPtr(0xdddddddd); // invalidate data
        #endif

        IoCallDriver(commonExtension->LowerDeviceObject, irp);

    }
    return;

} // end ClasspRetryRequestDpc()

/*++

    ISSUE-2000/02/20-henrygab Not documented ClassRetryRequest

--*/
VOID
ClassRetryRequest(
    IN PDEVICE_OBJECT SelfDeviceObject,
    IN PIRP           Irp,
    IN LARGE_INTEGER  TimeDelta100ns // in 100ns units
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData;
    PCLASS_RETRY_INFO  retryInfo;
    PCLASS_RETRY_INFO *previousNext;
    LARGE_INTEGER      delta;
    KIRQL irql;

    //
    // this checks we aren't destroying irps
    //
    ASSERT(sizeof(CLASS_RETRY_INFO) <= (4*sizeof(PVOID)));

    fdoExtension = SelfDeviceObject->DeviceExtension;
    fdoData = fdoExtension->PrivateFdoData;

    if (!fdoExtension->CommonExtension.IsFdo) {

        //
        // this debug print/assertion should ALWAYS be investigated.
        // ClassRetryRequest can currently only be used by FDO's
        //

        DebugPrint((ClassDebugError, "ClassRetryRequestEx: LOST IRP %p\n", Irp));
        ASSERT(!"ClassRetryRequestEx Called From PDO? LOST IRP");
        return;

    }

    if (TimeDelta100ns.QuadPart < 0) {
        ASSERT(!"ClassRetryRequest - must use positive delay");
        TimeDelta100ns.QuadPart *= -1;
    }

    //
    // prepare what we can out of the loop
    //

    retryInfo = (PCLASS_RETRY_INFO)(&Irp->Tail.Overlay.DriverContext[0]);
    RtlZeroMemory(retryInfo, sizeof(CLASS_RETRY_INFO));

    delta.QuadPart = (TimeDelta100ns.QuadPart / fdoData->Retry.Granularity);
    if (TimeDelta100ns.QuadPart % fdoData->Retry.Granularity) {
        delta.QuadPart ++; // round up to next tick
    }
    if (delta.QuadPart == (LONGLONG)0) {
        delta.QuadPart = MINIMUM_RETRY_UNITS;
    }

    //
    // now determine if we should fire another DPC or not
    //

    KeAcquireSpinLock(&fdoData->Retry.Lock, &irql);

    //
    // always add request to the list
    //

    retryInfo->Next = fdoData->Retry.ListHead;
    fdoData->Retry.ListHead = retryInfo;

    if (fdoData->Retry.Delta.QuadPart == (LONGLONG)0) {

        DebugPrint((ClassDebugDelayedRetry, "ClassRetry: +++ %p\n", Irp));

        //
        // must be exactly one item on list
        //

        ASSERT(fdoData->Retry.ListHead       != NULL);
        ASSERT(fdoData->Retry.ListHead->Next == NULL);

        //
        // if currentDelta is zero, always fire a DPC
        //

        KeQueryTickCount(&fdoData->Retry.Tick);
        fdoData->Retry.Tick.QuadPart  += delta.QuadPart;
        fdoData->Retry.Delta.QuadPart  = delta.QuadPart;
        ClasspRetryDpcTimer(fdoData);

    } else if (delta.QuadPart > fdoData->Retry.Delta.QuadPart) {

        //
        // if delta is greater than the list's current delta,
        // increase the DPC handling time by difference
        // and update the delta to new larger value
        // allow the DPC to re-fire itself if needed
        //

        DebugPrint((ClassDebugDelayedRetry, "ClassRetry:  ++ %p\n", Irp));

        //
        // must be at least two items on list
        //

        ASSERT(fdoData->Retry.ListHead       != NULL);
        ASSERT(fdoData->Retry.ListHead->Next != NULL);

        fdoData->Retry.Tick.QuadPart  -= fdoData->Retry.Delta.QuadPart;
        fdoData->Retry.Tick.QuadPart  += delta.QuadPart;

        fdoData->Retry.Delta.QuadPart  = delta.QuadPart;

    } else {

        //
        // just inserting it on the list was enough
        //

        DebugPrint((ClassDebugDelayedRetry, "ClassRetry:  ++ %p\n", Irp));

    }


    KeReleaseSpinLock(&fdoData->Retry.Lock, irql);


} // end ClassRetryRequest()

/*++

    ISSUE-2000/02/20-henrygab Not documented ClasspRetryDpcTimer

--*/
VOID
ClasspRetryDpcTimer(
    IN PCLASS_PRIVATE_FDO_DATA FdoData
    )
{
    LARGE_INTEGER fire;

    ASSERT(FdoData->Retry.Tick.QuadPart != (LONGLONG)0);
    ASSERT(FdoData->Retry.ListHead      != NULL);  // never fire an empty list

    //
    // fire == (CurrentTick - now) * (100ns per tick)
    //
    // NOTE: Overflow is nearly impossible and is ignored here
    //

    KeQueryTickCount(&fire);
    fire.QuadPart =  FdoData->Retry.Tick.QuadPart - fire.QuadPart;
    fire.QuadPart *= FdoData->Retry.Granularity;

    //
    // fire is now multiples of 100ns until should fire the timer.
    // if timer should already have expired, or would fire too quickly,
    // fire it in some arbitrary number of ticks to prevent infinitely
    // recursing.
    //

    if (fire.QuadPart < MINIMUM_RETRY_UNITS) {
        fire.QuadPart = MINIMUM_RETRY_UNITS;
    }

    DebugPrint((ClassDebugDelayedRetry,
                "ClassRetry: ======= %I64x ticks\n",
                fire.QuadPart));

    //
    // must use negative to specify relative time to fire
    //

    fire.QuadPart = fire.QuadPart * ((LONGLONG)-1);

    //
    // set the timer, since this is the first addition
    //

    KeSetTimerEx(&FdoData->Retry.Timer, fire, 0, &FdoData->Retry.Dpc);

    return;
} // end ClasspRetryDpcTimer()

NTSTATUS
ClasspInitializeHotplugInfo(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PCLASS_PRIVATE_FDO_DATA fdoData = FdoExtension->PrivateFdoData;
    DEVICE_REMOVAL_POLICY deviceRemovalPolicy;
    NTSTATUS status;
    ULONG resultLength = 0;
    ULONG writeCacheOverride;

    PAGED_CODE();

    //
    // start with some default settings
    //
    RtlZeroMemory(&(fdoData->HotplugInfo), sizeof(STORAGE_HOTPLUG_INFO));

    //
    // set the size (aka version)
    //

    fdoData->HotplugInfo.Size = sizeof(STORAGE_HOTPLUG_INFO);

    //
    // set if the device has removable media
    //

    if (FdoExtension->DeviceDescriptor->RemovableMedia) {
        fdoData->HotplugInfo.MediaRemovable = TRUE;
    } else {
        fdoData->HotplugInfo.MediaRemovable = FALSE;
    }

    //
    // this refers to devices which, for reasons not yet understood,
    // do not fail PREVENT_MEDIA_REMOVAL requests even though they
    // have no way to lock the media into the drive.  this allows
    // the filesystems to turn off delayed-write caching for these
    // devices as well.
    //

    if (TEST_FLAG(FdoExtension->PrivateFdoData->HackFlags,
                  FDO_HACK_CANNOT_LOCK_MEDIA)) {
        fdoData->HotplugInfo.MediaHotplug = TRUE;
    } else {
        fdoData->HotplugInfo.MediaHotplug = FALSE;
    }


    //
    // Look into the registry to  see if the user has  chosen
    // to override the default setting for the removal policy
    //

    RtlZeroMemory(&deviceRemovalPolicy, sizeof(DEVICE_REMOVAL_POLICY));

    ClassGetDeviceParameter(FdoExtension,
                            CLASSP_REG_SUBKEY_NAME,
                            CLASSP_REG_REMOVAL_POLICY_VALUE_NAME,
                            (PULONG)&deviceRemovalPolicy);

    if (deviceRemovalPolicy == 0)
    {
        //
        // Query the default removal policy from the kernel
        //

        status = IoGetDeviceProperty(FdoExtension->LowerPdo,
                                     DevicePropertyRemovalPolicy,
                                     sizeof(DEVICE_REMOVAL_POLICY),
                                     (PVOID)&deviceRemovalPolicy,
                                     &resultLength);
        if (!NT_SUCCESS(status))
        {
            return status;
        }

        if (resultLength != sizeof(DEVICE_REMOVAL_POLICY))
        {
            return STATUS_UNSUCCESSFUL;
        }
    }

    //
    // use this info to set the DeviceHotplug setting
    // don't rely on DeviceCapabilities, since it can't properly
    // determine device relations, etc.  let the kernel figure this
    // stuff out instead.
    //

    if (deviceRemovalPolicy == RemovalPolicyExpectSurpriseRemoval) {
        fdoData->HotplugInfo.DeviceHotplug = TRUE;
    } else {
        fdoData->HotplugInfo.DeviceHotplug = FALSE;
    }

    //
    // this refers to the *filesystem* caching, but has to be included
    // here since it's a per-device setting.  this may change to be
    // stored by the system in the future.
    //

    writeCacheOverride = FALSE;
    ClassGetDeviceParameter(FdoExtension,
                            CLASSP_REG_SUBKEY_NAME,
                            CLASSP_REG_WRITE_CACHE_VALUE_NAME,
                            &writeCacheOverride);

    if (writeCacheOverride) {
        fdoData->HotplugInfo.WriteCacheEnableOverride = TRUE;
    } else {
        fdoData->HotplugInfo.WriteCacheEnableOverride = FALSE;
    }

    return STATUS_SUCCESS;
}

VOID
ClasspScanForClassHacks(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG_PTR Data
    )
{
    PAGED_CODE();

    //
    // remove invalid flags and save
    //

    CLEAR_FLAG(Data, FDO_HACK_INVALID_FLAGS);
    SET_FLAG(FdoExtension->PrivateFdoData->HackFlags, Data);
    return;
}

VOID
ClasspScanForSpecialInRegistry(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    HANDLE             deviceParameterHandle; // device instance key
    HANDLE             classParameterHandle; // classpnp subkey
    OBJECT_ATTRIBUTES  objectAttributes;
    UNICODE_STRING     subkeyName;
    NTSTATUS           status;

    //
    // seeded in the ENUM tree by ClassInstaller
    //
    ULONG deviceHacks;
    RTL_QUERY_REGISTRY_TABLE queryTable[2]; // null terminated array

    PAGED_CODE();

    deviceParameterHandle = NULL;
    classParameterHandle = NULL;
    deviceHacks = 0;

    status = IoOpenDeviceRegistryKey(FdoExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_WRITE,
                                     &deviceParameterHandle
                                     );

    if (!NT_SUCCESS(status)) {
        goto cleanupScanForSpecial;
    }

    RtlInitUnicodeString(&subkeyName, CLASSP_REG_SUBKEY_NAME);
    InitializeObjectAttributes(&objectAttributes,
                               &subkeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               deviceParameterHandle,
                               NULL
                               );

    status = ZwOpenKey( &classParameterHandle,
                        KEY_READ,
                        &objectAttributes
                        );

    if (!NT_SUCCESS(status)) {
        goto cleanupScanForSpecial;
    }

    //
    // Zero out the memory
    //

    RtlZeroMemory(&queryTable[0], 2*sizeof(RTL_QUERY_REGISTRY_TABLE));

    //
    // Setup the structure to read
    //

    queryTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name          = CLASSP_REG_HACK_VALUE_NAME;
    queryTable[0].EntryContext  = &deviceHacks;
    queryTable[0].DefaultType   = REG_DWORD;
    queryTable[0].DefaultData   = &deviceHacks;
    queryTable[0].DefaultLength = 0;

    //
    // read values
    //

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR)classParameterHandle,
                                    &queryTable[0],
                                    NULL,
                                    NULL
                                    );
    if (!NT_SUCCESS(status)) {
        goto cleanupScanForSpecial;
    }

    //
    // remove unknown values and save...
    //

    KdPrintEx((DPFLTR_CLASSPNP_ID, DPFLTR_ERROR_LEVEL,
               "Classpnp => ScanForSpecial: HackFlags %#08x\n",
               deviceHacks));

    CLEAR_FLAG(deviceHacks, FDO_HACK_INVALID_FLAGS);
    SET_FLAG(FdoExtension->PrivateFdoData->HackFlags, deviceHacks);


cleanupScanForSpecial:

    if (deviceParameterHandle) {
        ZwClose(deviceParameterHandle);
    }

    if (classParameterHandle) {
        ZwClose(classParameterHandle);
    }

    //
    // we should modify the system hive to include another key for us to grab
    // settings from.  in this case:  Classpnp\HackFlags
    //
    // the use of a DWORD value for the HackFlags allows 32 hacks w/o
    // significant use of the registry, and also reduces OEM exposure.
    //
    // definition of bit flags:
    //   0x00000001 -- Device succeeds PREVENT_MEDIUM_REMOVAL, but
    //                 cannot actually prevent removal.
    //   0x00000002 -- Device hard-hangs or times out for GESN requests.
    //   0xfffffffc -- Currently reserved, may be used later.
    //

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\debug.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    debug.c

Abstract:

    CLASSPNP debug code and data

Environment:

    kernel mode only

Notes:


Revision History:

--*/


#include "classp.h"
#include "debug.h"

#if DBG

    //
    // default to not breaking in for lost irps, five minutes before we even
    // bother checking for lost irps, using standard debug print macros, and
    // using a 64k debug print buffer
    //

    #ifndef     CLASS_GLOBAL_BREAK_ON_LOST_IRPS
        #error "CLASS_GLOBAL_BREAK_ON_LOST_IRPS undefined"
        #define CLASS_GLOBAL_BREAK_ON_LOST_IRPS 0
    #endif   // CLASS_GLOBAL_BREAK_ON_LOST_IRPS

    #ifndef     CLASS_GLOBAL_SECONDS_TO_WAIT_FOR_SYNCHRONOUS_SRB
        #error "CLASS_GLOBAL_SECONDS_TO_WAIT_FOR_SYNCHRONOUS_SRB undefined"
        #define CLASS_GLOBAL_SECONDS_TO_WAIT_FOR_SYNCHRONOUS_SRB 300
    #endif   // CLASS_GLOBAL_SECONDS_TO_WAIT_FOR_SYNCHRONOUS_SRB

    #ifndef     CLASS_GLOBAL_USE_DELAYED_RETRY
        #error "CLASS_GLOBAL_USE_DELAYED_RETRY undefined"
        #define CLASS_GLOBAL_USE_DELAYED_RETRY 1
    #endif   // CLASS_GLOBAL_USE_DELAYED_RETRY

    #ifndef     CLASS_GLOBAL_BUFFERED_DEBUG_PRINT
        #error "CLASS_GLOBAL_BUFFERED_DEBUG_PRINT undefined"
        #define CLASS_GLOBAL_BUFFERED_DEBUG_PRINT 0
    #endif   // CLASS_GLOBAL_BUFFERED_DEBUG_PRINT

    #ifndef     CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFER_SIZE
        #error "CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFER_SIZE undefined"
        #define CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFER_SIZE 512
    #endif   // CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFER_SIZE

    #ifndef     CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFERS
        #error "CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFERS undefined"
        #define CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFERS 512
    #endif   // CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFERS

    #pragma data_seg("NONPAGE")



    CLASSPNP_GLOBALS ClasspnpGlobals;

    //
    // the low sixteen bits are used to see if the debug level is high enough
    // the high sixteen bits are used to singly enable debug levels 1-16
    //
    LONG ClassDebug = 0x00000000;

    BOOLEAN DebugTrapOnWarn = FALSE;

    VOID ClasspInitializeDebugGlobals()
    {
        KIRQL irql;

        if (InterlockedCompareExchange(&ClasspnpGlobals.Initializing, 1, 0) == 0) {

            KeInitializeSpinLock(&ClasspnpGlobals.SpinLock);

            KeAcquireSpinLock(&ClasspnpGlobals.SpinLock, &irql);

            DebugPrint((1, "CLASSPNP.SYS => Initializing ClasspnpGlobals...\n"));

            ClasspnpGlobals.Buffer = NULL;
            ClasspnpGlobals.Index = -1;
            ClasspnpGlobals.BreakOnLostIrps = CLASS_GLOBAL_BREAK_ON_LOST_IRPS;
            ClasspnpGlobals.EachBufferSize = CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFER_SIZE;
            ClasspnpGlobals.NumberOfBuffers = CLASS_GLOBAL_BUFFERED_DEBUG_PRINT_BUFFERS;
            ClasspnpGlobals.SecondsToWaitForIrps = CLASS_GLOBAL_SECONDS_TO_WAIT_FOR_SYNCHRONOUS_SRB;

            //
            // this should be the last item set
            //

            ClasspnpGlobals.UseBufferedDebugPrint = CLASS_GLOBAL_BUFFERED_DEBUG_PRINT;

            KeReleaseSpinLock(&ClasspnpGlobals.SpinLock, irql);

            InterlockedExchange(&ClasspnpGlobals.Initialized, 1);

        }
    }



    /*++////////////////////////////////////////////////////////////////////////////

    ClassDebugPrint()

    Routine Description:

        Debug print for all class drivers, NOOP on FRE versions.
        Allows printing to a debug buffer (with auto fallback to kdprint) by
        properly setting the Globals in classpnp on CHK versions.

    Arguments:

        Debug print level, or from 0 to 3 for legacy drivers.

    Return Value:

        None

    --*/
    VOID ClassDebugPrint(CLASS_DEBUG_LEVEL DebugPrintLevel, PCCHAR DebugMessage, ...)
    {
        va_list ap;
        va_start(ap, DebugMessage);

        if ((DebugPrintLevel <= (ClassDebug & 0x0000ffff)) ||
            ((1 << (DebugPrintLevel + 15)) & ClassDebug)) {

            if (ClasspnpGlobals.UseBufferedDebugPrint &&
                ClasspnpGlobals.Buffer == NULL) {

                //
                // this double-check prevents always taking
                // a spinlock just to ensure we have a buffer
                //

                KIRQL irql;

                KeAcquireSpinLock(&ClasspnpGlobals.SpinLock, &irql);
                if (ClasspnpGlobals.Buffer == NULL) {

                    SIZE_T bufferSize;
                    bufferSize = ClasspnpGlobals.NumberOfBuffers *
                                 ClasspnpGlobals.EachBufferSize;
                    DbgPrintEx(DPFLTR_CLASSPNP_ID, DPFLTR_ERROR_LEVEL,
                               "ClassDebugPrint: Allocating %x bytes for "
                               "classdebugprint buffer\n", bufferSize);
                    ClasspnpGlobals.Index       = -1;
                    ClasspnpGlobals.Buffer =
                        ExAllocatePoolWithTag(NonPagedPool, bufferSize, 'bDcS');
                    DbgPrintEx(DPFLTR_CLASSPNP_ID, DPFLTR_ERROR_LEVEL,
                               "ClassDebugPrint: Allocated buffer at %p\n",
                               ClasspnpGlobals.Buffer);

                }
                KeReleaseSpinLock(&ClasspnpGlobals.SpinLock, irql);

            }

            if (ClasspnpGlobals.UseBufferedDebugPrint &&
                ClasspnpGlobals.Buffer != NULL) {

                //
                // we never free the buffer, so once it exists,
                // we can just print to it with immunity
                //

                ULONG index;
                PUCHAR buffer;
                index = InterlockedIncrement(&ClasspnpGlobals.Index);
                index %= ClasspnpGlobals.NumberOfBuffers;
                index *= (ULONG)ClasspnpGlobals.EachBufferSize;

                buffer = ClasspnpGlobals.Buffer;
                buffer += index;

                _vsnprintf(buffer, ClasspnpGlobals.EachBufferSize, DebugMessage, ap);

            } else {

                //
                // either we could not allocate a buffer for debug prints
                // or buffered debug prints are disabled
                //

                vDbgPrintEx(DPFLTR_CLASSPNP_ID, DPFLTR_INFO_LEVEL, DebugMessage, ap);

            }

        }

        va_end(ap);

    } 


    char *DbgGetIoctlStr(ULONG ioctl)
    {
        char *ioctlStr = "?";
        
        switch (ioctl){
            
            #undef MAKE_CASE             
            #define MAKE_CASE(ioctlCode) case ioctlCode: ioctlStr = #ioctlCode; break;

            MAKE_CASE(IOCTL_STORAGE_CHECK_VERIFY)
            MAKE_CASE(IOCTL_STORAGE_CHECK_VERIFY2)
            MAKE_CASE(IOCTL_STORAGE_MEDIA_REMOVAL)
            MAKE_CASE(IOCTL_STORAGE_EJECT_MEDIA)
            MAKE_CASE(IOCTL_STORAGE_LOAD_MEDIA)
            MAKE_CASE(IOCTL_STORAGE_LOAD_MEDIA2)
            MAKE_CASE(IOCTL_STORAGE_RESERVE)
            MAKE_CASE(IOCTL_STORAGE_RELEASE)
            MAKE_CASE(IOCTL_STORAGE_FIND_NEW_DEVICES)
            MAKE_CASE(IOCTL_STORAGE_EJECTION_CONTROL)
            MAKE_CASE(IOCTL_STORAGE_MCN_CONTROL)
            MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_TYPES)
            MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_TYPES_EX)
            MAKE_CASE(IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER)
            MAKE_CASE(IOCTL_STORAGE_GET_HOTPLUG_INFO)
            MAKE_CASE(IOCTL_STORAGE_RESET_BUS)
            MAKE_CASE(IOCTL_STORAGE_RESET_DEVICE)
            MAKE_CASE(IOCTL_STORAGE_GET_DEVICE_NUMBER)
            MAKE_CASE(IOCTL_STORAGE_PREDICT_FAILURE)
            MAKE_CASE(IOCTL_STORAGE_QUERY_PROPERTY)
            MAKE_CASE(OBSOLETE_IOCTL_STORAGE_RESET_BUS)
            MAKE_CASE(OBSOLETE_IOCTL_STORAGE_RESET_DEVICE)
        }
      
        return ioctlStr;
    }

    char *DbgGetScsiOpStr(PSCSI_REQUEST_BLOCK Srb)
    {
        PCDB pCdb = (PCDB)Srb->Cdb;
        UCHAR scsiOp = pCdb->CDB6GENERIC.OperationCode;
        char *scsiOpStr = "?";

        switch (scsiOp){

            #undef MAKE_CASE             
            #define MAKE_CASE(scsiOpCode) case scsiOpCode: scsiOpStr = #scsiOpCode; break;
            
            MAKE_CASE(SCSIOP_TEST_UNIT_READY)
            MAKE_CASE(SCSIOP_REWIND)    // aka SCSIOP_REZERO_UNIT
            MAKE_CASE(SCSIOP_REQUEST_BLOCK_ADDR)
            MAKE_CASE(SCSIOP_REQUEST_SENSE)
            MAKE_CASE(SCSIOP_FORMAT_UNIT)
            MAKE_CASE(SCSIOP_READ_BLOCK_LIMITS)
            MAKE_CASE(SCSIOP_INIT_ELEMENT_STATUS)   // aka SCSIOP_REASSIGN_BLOCKS
            MAKE_CASE(SCSIOP_RECEIVE)       // aka SCSIOP_READ6
            MAKE_CASE(SCSIOP_SEND)  // aka SCSIOP_WRITE6, SCSIOP_PRINT
            MAKE_CASE(SCSIOP_SLEW_PRINT)    // aka SCSIOP_SEEK6, SCSIOP_TRACK_SELECT
            MAKE_CASE(SCSIOP_SEEK_BLOCK)
            MAKE_CASE(SCSIOP_PARTITION)
            MAKE_CASE(SCSIOP_READ_REVERSE)
            MAKE_CASE(SCSIOP_FLUSH_BUFFER)      // aka SCSIOP_WRITE_FILEMARKS
            MAKE_CASE(SCSIOP_SPACE)
            MAKE_CASE(SCSIOP_INQUIRY)
            MAKE_CASE(SCSIOP_VERIFY6)
            MAKE_CASE(SCSIOP_RECOVER_BUF_DATA)
            MAKE_CASE(SCSIOP_MODE_SELECT)
            MAKE_CASE(SCSIOP_RESERVE_UNIT)
            MAKE_CASE(SCSIOP_RELEASE_UNIT)
            MAKE_CASE(SCSIOP_COPY)
            MAKE_CASE(SCSIOP_ERASE)
            MAKE_CASE(SCSIOP_MODE_SENSE)
            MAKE_CASE(SCSIOP_START_STOP_UNIT)   // aka SCSIOP_STOP_PRINT, SCSIOP_LOAD_UNLOAD
            MAKE_CASE(SCSIOP_RECEIVE_DIAGNOSTIC)
            MAKE_CASE(SCSIOP_SEND_DIAGNOSTIC)
            MAKE_CASE(SCSIOP_MEDIUM_REMOVAL)
            MAKE_CASE(SCSIOP_READ_FORMATTED_CAPACITY)
            MAKE_CASE(SCSIOP_READ_CAPACITY)
            MAKE_CASE(SCSIOP_READ)
            MAKE_CASE(SCSIOP_WRITE)
            MAKE_CASE(SCSIOP_SEEK)  // aka SCSIOP_LOCATE, SCSIOP_POSITION_TO_ELEMENT
            MAKE_CASE(SCSIOP_WRITE_VERIFY)
            MAKE_CASE(SCSIOP_VERIFY)
            MAKE_CASE(SCSIOP_SEARCH_DATA_HIGH)
            MAKE_CASE(SCSIOP_SEARCH_DATA_EQUAL)
            MAKE_CASE(SCSIOP_SEARCH_DATA_LOW)
            MAKE_CASE(SCSIOP_SET_LIMITS)
            MAKE_CASE(SCSIOP_READ_POSITION)
            MAKE_CASE(SCSIOP_SYNCHRONIZE_CACHE)
            MAKE_CASE(SCSIOP_COMPARE)
            MAKE_CASE(SCSIOP_COPY_COMPARE)
            MAKE_CASE(SCSIOP_WRITE_DATA_BUFF)
            MAKE_CASE(SCSIOP_READ_DATA_BUFF)
            MAKE_CASE(SCSIOP_CHANGE_DEFINITION)
            MAKE_CASE(SCSIOP_READ_SUB_CHANNEL)
            MAKE_CASE(SCSIOP_READ_TOC)
            MAKE_CASE(SCSIOP_READ_HEADER)
            MAKE_CASE(SCSIOP_PLAY_AUDIO)
            MAKE_CASE(SCSIOP_GET_CONFIGURATION)
            MAKE_CASE(SCSIOP_PLAY_AUDIO_MSF)
            MAKE_CASE(SCSIOP_PLAY_TRACK_INDEX)
            MAKE_CASE(SCSIOP_PLAY_TRACK_RELATIVE)
            MAKE_CASE(SCSIOP_GET_EVENT_STATUS)
            MAKE_CASE(SCSIOP_PAUSE_RESUME)
            MAKE_CASE(SCSIOP_LOG_SELECT)
            MAKE_CASE(SCSIOP_LOG_SENSE)
            MAKE_CASE(SCSIOP_STOP_PLAY_SCAN)
            MAKE_CASE(SCSIOP_READ_DISK_INFORMATION)
            MAKE_CASE(SCSIOP_READ_TRACK_INFORMATION)
            MAKE_CASE(SCSIOP_RESERVE_TRACK_RZONE)
            MAKE_CASE(SCSIOP_SEND_OPC_INFORMATION)
            MAKE_CASE(SCSIOP_MODE_SELECT10)
            MAKE_CASE(SCSIOP_MODE_SENSE10)
            MAKE_CASE(SCSIOP_CLOSE_TRACK_SESSION)
            MAKE_CASE(SCSIOP_READ_BUFFER_CAPACITY)
            MAKE_CASE(SCSIOP_SEND_CUE_SHEET)
            MAKE_CASE(SCSIOP_PERSISTENT_RESERVE_IN)
            MAKE_CASE(SCSIOP_PERSISTENT_RESERVE_OUT)
            MAKE_CASE(SCSIOP_REPORT_LUNS)
            MAKE_CASE(SCSIOP_BLANK)
            MAKE_CASE(SCSIOP_SEND_KEY)
            MAKE_CASE(SCSIOP_REPORT_KEY)
            MAKE_CASE(SCSIOP_MOVE_MEDIUM)
            MAKE_CASE(SCSIOP_LOAD_UNLOAD_SLOT)  // aka SCSIOP_EXCHANGE_MEDIUM
            MAKE_CASE(SCSIOP_SET_READ_AHEAD)
            MAKE_CASE(SCSIOP_READ_DVD_STRUCTURE)
            MAKE_CASE(SCSIOP_REQUEST_VOL_ELEMENT)
            MAKE_CASE(SCSIOP_SEND_VOLUME_TAG)
            MAKE_CASE(SCSIOP_READ_ELEMENT_STATUS)
            MAKE_CASE(SCSIOP_READ_CD_MSF)
            MAKE_CASE(SCSIOP_SCAN_CD)
            MAKE_CASE(SCSIOP_SET_CD_SPEED)
            MAKE_CASE(SCSIOP_PLAY_CD)
            MAKE_CASE(SCSIOP_MECHANISM_STATUS)
            MAKE_CASE(SCSIOP_READ_CD)
            MAKE_CASE(SCSIOP_SEND_DVD_STRUCTURE)
            MAKE_CASE(SCSIOP_INIT_ELEMENT_RANGE)
        }
        
        return scsiOpStr;
    }


    char *DbgGetSrbStatusStr(PSCSI_REQUEST_BLOCK Srb)
    {
        char *srbStatStr = "?";
        
        switch (Srb->SrbStatus){

            #undef MAKE_CASE
            #define MAKE_CASE(srbStat) \
                        case srbStat: \
                            srbStatStr = #srbStat; \
                            break; \
                        case srbStat|SRB_STATUS_QUEUE_FROZEN: \
                            srbStatStr = #srbStat "|SRB_STATUS_QUEUE_FROZEN"; \
                            break; \
                        case srbStat|SRB_STATUS_AUTOSENSE_VALID: \
                            srbStatStr = #srbStat "|SRB_STATUS_AUTOSENSE_VALID"; \
                            break; \
                        case srbStat|SRB_STATUS_QUEUE_FROZEN|SRB_STATUS_AUTOSENSE_VALID: \
                            srbStatStr = #srbStat "|SRB_STATUS_QUEUE_FROZEN|SRB_STATUS_AUTOSENSE_VALID"; \
                            break; 

            MAKE_CASE(SRB_STATUS_PENDING)
            MAKE_CASE(SRB_STATUS_SUCCESS)
            MAKE_CASE(SRB_STATUS_ABORTED)
            MAKE_CASE(SRB_STATUS_ABORT_FAILED)
            MAKE_CASE(SRB_STATUS_ERROR)
            MAKE_CASE(SRB_STATUS_BUSY)
            MAKE_CASE(SRB_STATUS_INVALID_REQUEST)
            MAKE_CASE(SRB_STATUS_INVALID_PATH_ID)
            MAKE_CASE(SRB_STATUS_NO_DEVICE)
            MAKE_CASE(SRB_STATUS_TIMEOUT)
            MAKE_CASE(SRB_STATUS_SELECTION_TIMEOUT)
            MAKE_CASE(SRB_STATUS_COMMAND_TIMEOUT)
            MAKE_CASE(SRB_STATUS_MESSAGE_REJECTED)
            MAKE_CASE(SRB_STATUS_BUS_RESET)
            MAKE_CASE(SRB_STATUS_PARITY_ERROR)
            MAKE_CASE(SRB_STATUS_REQUEST_SENSE_FAILED)
            MAKE_CASE(SRB_STATUS_NO_HBA)
            MAKE_CASE(SRB_STATUS_DATA_OVERRUN)
            MAKE_CASE(SRB_STATUS_UNEXPECTED_BUS_FREE)
            MAKE_CASE(SRB_STATUS_PHASE_SEQUENCE_FAILURE)
            MAKE_CASE(SRB_STATUS_BAD_SRB_BLOCK_LENGTH)
            MAKE_CASE(SRB_STATUS_REQUEST_FLUSHED)
            MAKE_CASE(SRB_STATUS_INVALID_LUN)
            MAKE_CASE(SRB_STATUS_INVALID_TARGET_ID)
            MAKE_CASE(SRB_STATUS_BAD_FUNCTION)
            MAKE_CASE(SRB_STATUS_ERROR_RECOVERY)
            MAKE_CASE(SRB_STATUS_NOT_POWERED)
            MAKE_CASE(SRB_STATUS_INTERNAL_ERROR)
        }

        return srbStatStr;
    }

    
    char *DbgGetSenseCodeStr(PSCSI_REQUEST_BLOCK Srb)
    {
        char *senseCodeStr = "?";

        if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID){
            PSENSE_DATA senseData;
            UCHAR senseCode;

            ASSERT(Srb->SenseInfoBuffer);
            senseData = Srb->SenseInfoBuffer;
            senseCode = senseData->SenseKey & 0xf;
                        
            switch (senseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(snsCod) case snsCod: senseCodeStr = #snsCod; break;
            
                MAKE_CASE(SCSI_SENSE_NO_SENSE)
                MAKE_CASE(SCSI_SENSE_RECOVERED_ERROR)
                MAKE_CASE(SCSI_SENSE_NOT_READY)
                MAKE_CASE(SCSI_SENSE_MEDIUM_ERROR)
                MAKE_CASE(SCSI_SENSE_HARDWARE_ERROR)
                MAKE_CASE(SCSI_SENSE_ILLEGAL_REQUEST)
                MAKE_CASE(SCSI_SENSE_UNIT_ATTENTION)
                MAKE_CASE(SCSI_SENSE_DATA_PROTECT)
                MAKE_CASE(SCSI_SENSE_BLANK_CHECK)
                MAKE_CASE(SCSI_SENSE_UNIQUE)
                MAKE_CASE(SCSI_SENSE_COPY_ABORTED)
                MAKE_CASE(SCSI_SENSE_ABORTED_COMMAND)
                MAKE_CASE(SCSI_SENSE_EQUAL)
                MAKE_CASE(SCSI_SENSE_VOL_OVERFLOW)
                MAKE_CASE(SCSI_SENSE_MISCOMPARE)
                MAKE_CASE(SCSI_SENSE_RESERVED)               
            }
        }

        return senseCodeStr;
    }


    char *DbgGetAdditionalSenseCodeStr(PSCSI_REQUEST_BLOCK Srb)
    {
        char *adSenseCodeStr = "?";
        
        if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID){
            PSENSE_DATA senseData;
            UCHAR adSenseCode;

            ASSERT(Srb->SenseInfoBuffer);
            senseData = Srb->SenseInfoBuffer;
            adSenseCode = senseData->AdditionalSenseCode;
                        
            switch (adSenseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(adSnsCod) case adSnsCod: adSenseCodeStr = #adSnsCod; break;
    
                MAKE_CASE(SCSI_ADSENSE_NO_SENSE)
                MAKE_CASE(SCSI_ADSENSE_LUN_NOT_READY)
                MAKE_CASE(SCSI_ADSENSE_TRACK_ERROR)
                MAKE_CASE(SCSI_ADSENSE_SEEK_ERROR)
                MAKE_CASE(SCSI_ADSENSE_REC_DATA_NOECC)
                MAKE_CASE(SCSI_ADSENSE_REC_DATA_ECC)
                MAKE_CASE(SCSI_ADSENSE_ILLEGAL_COMMAND)
                MAKE_CASE(SCSI_ADSENSE_ILLEGAL_BLOCK)
                MAKE_CASE(SCSI_ADSENSE_INVALID_CDB)
                MAKE_CASE(SCSI_ADSENSE_INVALID_LUN)
                MAKE_CASE(SCSI_ADSENSE_WRITE_PROTECT)   // aka SCSI_ADWRITE_PROTECT
                MAKE_CASE(SCSI_ADSENSE_MEDIUM_CHANGED)
                MAKE_CASE(SCSI_ADSENSE_BUS_RESET)
                MAKE_CASE(SCSI_ADSENSE_INVALID_MEDIA)
                MAKE_CASE(SCSI_ADSENSE_NO_MEDIA_IN_DEVICE)
                MAKE_CASE(SCSI_ADSENSE_POSITION_ERROR)
                MAKE_CASE(SCSI_ADSENSE_OPERATOR_REQUEST)
                MAKE_CASE(SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED)
                MAKE_CASE(SCSI_ADSENSE_COPY_PROTECTION_FAILURE)
                MAKE_CASE(SCSI_ADSENSE_VENDOR_UNIQUE)
                MAKE_CASE(SCSI_ADSENSE_MUSIC_AREA)
                MAKE_CASE(SCSI_ADSENSE_DATA_AREA)
                MAKE_CASE(SCSI_ADSENSE_VOLUME_OVERFLOW)
            }
        }

        return adSenseCodeStr;
    }


    char *DbgGetAdditionalSenseCodeQualifierStr(PSCSI_REQUEST_BLOCK Srb)
    {
        char *adSenseCodeQualStr = "?";
        
        if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID){
            PSENSE_DATA senseData;
            UCHAR adSenseCode;
            UCHAR adSenseCodeQual;
            
            ASSERT(Srb->SenseInfoBuffer);
            senseData = Srb->SenseInfoBuffer;
            adSenseCode = senseData->AdditionalSenseCode;
            adSenseCodeQual = senseData->AdditionalSenseCodeQualifier;
            
            switch (adSenseCode){

                #undef MAKE_CASE             
                #define MAKE_CASE(adSnsCodQual) case adSnsCodQual: adSenseCodeQualStr = #adSnsCodQual; break;

                case SCSI_ADSENSE_LUN_NOT_READY:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_CAUSE_NOT_REPORTABLE)
                        MAKE_CASE(SCSI_SENSEQ_BECOMING_READY)
                        MAKE_CASE(SCSI_SENSEQ_INIT_COMMAND_REQUIRED)
                        MAKE_CASE(SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED)
                        MAKE_CASE(SCSI_SENSEQ_FORMAT_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_REBUILD_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_RECALCULATION_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_OPERATION_IN_PROGRESS)
                        MAKE_CASE(SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS)                        
                    }
                    break;
                case SCSI_ADSENSE_NO_SENSE:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_FILEMARK_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_END_OF_MEDIA_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_SETMARK_DETECTED)
                        MAKE_CASE(SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED)
                    }
                    break;
                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR)
                    }
                    break;
                case SCSI_ADSENSE_POSITION_ERROR:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_DESTINATION_FULL)
                        MAKE_CASE(SCSI_SENSEQ_SOURCE_EMPTY)
                    }
                    break;
                case SCSI_ADSENSE_INVALID_MEDIA:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED)
                        MAKE_CASE(SCSI_SENSEQ_UNKNOWN_FORMAT)
                        MAKE_CASE(SCSI_SENSEQ_INCOMPATIBLE_FORMAT)
                        MAKE_CASE(SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED)
                    }
                    break;
                case SCSI_ADSENSE_OPERATOR_REQUEST:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_STATE_CHANGE_INPUT)
                        MAKE_CASE(SCSI_SENSEQ_MEDIUM_REMOVAL)
                        MAKE_CASE(SCSI_SENSEQ_WRITE_PROTECT_ENABLE)
                        MAKE_CASE(SCSI_SENSEQ_WRITE_PROTECT_DISABLE)
                    }
                    break;
                case SCSI_ADSENSE_COPY_PROTECTION_FAILURE:
                    switch (adSenseCodeQual){
                        MAKE_CASE(SCSI_SENSEQ_AUTHENTICATION_FAILURE)
                        MAKE_CASE(SCSI_SENSEQ_KEY_NOT_PRESENT)
                        MAKE_CASE(SCSI_SENSEQ_KEY_NOT_ESTABLISHED)
                        MAKE_CASE(SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION)
                        MAKE_CASE(SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT)
                        MAKE_CASE(SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR)
                    }
                    break;
            }
        }

        return adSenseCodeQualStr;
    }


    /*
     *  DbgCheckReturnedPkt
     *
     *      Check a completed TRANSFER_PACKET for all sorts of error conditions
     *      and warn/trap appropriately.
     */
    VOID DbgCheckReturnedPkt(TRANSFER_PACKET *Pkt)
    {
        PCDB pCdb = (PCDB)Pkt->Srb.Cdb;
        
        ASSERT(Pkt->Srb.OriginalRequest == Pkt->Irp);
        ASSERT(Pkt->Srb.DataBuffer == Pkt->BufPtrCopy);
        ASSERT(Pkt->Srb.DataTransferLength <= Pkt->BufLenCopy);
        ASSERT(!Pkt->Irp->CancelRoutine);
            
        if (SRB_STATUS(Pkt->Srb.SrbStatus) == SRB_STATUS_PENDING){
            DBGERR(("SRB completed with status PENDING in packet %ph: (op=%s srbstat=%s(%xh), irpstat=%xh)",
                        Pkt, 
                        DBGGETSCSIOPSTR(&Pkt->Srb), 
                        DBGGETSRBSTATUSSTR(&Pkt->Srb),
                        (ULONG)Pkt->Srb.SrbStatus, 
                        Pkt->Irp->IoStatus.Status));
        }
        else if (SRB_STATUS(Pkt->Srb.SrbStatus) == SRB_STATUS_SUCCESS){
            /*
             *  Make sure SRB and IRP status match.
             */
            if (!NT_SUCCESS(Pkt->Irp->IoStatus.Status)){
                DBGWARN(("SRB and IRP status don't match in packet %ph: (op=%s srbstat=%s(%xh), irpstat=%xh)",
                            Pkt, 
                            DBGGETSCSIOPSTR(&Pkt->Srb), 
                            DBGGETSRBSTATUSSTR(&Pkt->Srb),
                            (ULONG)Pkt->Srb.SrbStatus, 
                            Pkt->Irp->IoStatus.Status));
            }

            if (Pkt->Irp->IoStatus.Information != Pkt->Srb.DataTransferLength){
                DBGERR(("SRB and IRP result transfer lengths don't match in succeeded packet %ph: (op=%s, SrbStatus=%s, Srb.DataTransferLength=%xh, Irp->IoStatus.Information=%xh).",
                            Pkt, 
                            DBGGETSCSIOPSTR(&Pkt->Srb), 
                            DBGGETSRBSTATUSSTR(&Pkt->Srb),
                            Pkt->Srb.DataTransferLength,
                            Pkt->Irp->IoStatus.Information));
            }            
        }
        else {
            if (NT_SUCCESS(Pkt->Irp->IoStatus.Status)){
                DBGWARN(("SRB and IRP status don't match in packet %ph: (op=%s srbstat=%s(%xh), irpstat=%xh)",
                            Pkt, 
                            DBGGETSCSIOPSTR(&Pkt->Srb), 
                            DBGGETSRBSTATUSSTR(&Pkt->Srb),
                            (ULONG)Pkt->Srb.SrbStatus, 
                            Pkt->Irp->IoStatus.Status));
            }            
            DBGTRACE(ClassDebugWarning, ("Packet %ph failed (op=%s srbstat=%s(%xh), irpstat=%xh, sense=%s/%s/%s)", 
                            Pkt, 
                            DBGGETSCSIOPSTR(&Pkt->Srb), 
                            DBGGETSRBSTATUSSTR(&Pkt->Srb),
                            (ULONG)Pkt->Srb.SrbStatus, 
                            Pkt->Irp->IoStatus.Status, 
                            DBGGETSENSECODESTR(&Pkt->Srb), 
                            DBGGETADSENSECODESTR(&Pkt->Srb), 
                            DBGGETADSENSEQUALIFIERSTR(&Pkt->Srb)));

            /*
             *  If the SRB failed with underrun or overrun, then the actual
             *  transferred length should be returned in both SRB and IRP.
             *  (SRB's only have an error status for overrun, so it's overloaded).
             */
            if ((SRB_STATUS(Pkt->Srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) &&
               (Pkt->Irp->IoStatus.Information != Pkt->Srb.DataTransferLength)){
                DBGERR(("SRB and IRP result transfer lengths don't match in failed packet %ph: (op=%s, SrbStatus=%s, Srb.DataTransferLength=%xh, Irp->IoStatus.Information=%xh).",
                            Pkt, 
                            DBGGETSCSIOPSTR(&Pkt->Srb), 
                            DBGGETSRBSTATUSSTR(&Pkt->Srb),
                            Pkt->Srb.DataTransferLength,
                            Pkt->Irp->IoStatus.Information));
            }            
        }


        /*
         *  Some miniport drivers have been caught changing the SCSI operation
         *  code in the SRB.  This is absolutely disallowed as it breaks our error handling.
         */
        switch (pCdb->CDB10.OperationCode){
            case SCSIOP_MEDIUM_REMOVAL:
            case SCSIOP_MODE_SENSE:
            case SCSIOP_READ_CAPACITY:
            case SCSIOP_READ:
            case SCSIOP_WRITE:
            case SCSIOP_START_STOP_UNIT:    
                break;
            default:
                DBGERR(("Miniport illegally changed Srb.Cdb.OperationCode in packet %ph failed (op=%s srbstat=%s(%xh), irpstat=%xh, sense=%s/%s/%s)", 
                                Pkt, 
                                DBGGETSCSIOPSTR(&Pkt->Srb), 
                                DBGGETSRBSTATUSSTR(&Pkt->Srb),
                                (ULONG)Pkt->Srb.SrbStatus, 
                                Pkt->Irp->IoStatus.Status, 
                                DBGGETSENSECODESTR(&Pkt->Srb), 
                                DBGGETADSENSECODESTR(&Pkt->Srb), 
                                DBGGETADSENSEQUALIFIERSTR(&Pkt->Srb)));
                break;
        }
        
    }
    
#else

    // We have to keep this in the retail build for legacy.
    VOID ClassDebugPrint(CLASS_DEBUG_LEVEL DebugPrintLevel, PCCHAR DebugMessage, ...)
    {
    } 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\classwmi.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    classwmi.c

Abstract:

    SCSI class driver routines

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "stddef.h"
#include "ntddk.h"
#include "scsi.h"

#include "classpnp.h"

#include "mountdev.h"

#include <stdarg.h>

#include "wmistr.h"

NTSTATUS
ClassSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
ClassFindGuid(
    PGUIDREGINFO GuidList,
    ULONG GuidCount,
    LPGUID Guid,
    PULONG GuidIndex
    );

//
// This is the name for the MOF resource that must be part of all drivers that
// register via this interface.
#define MOFRESOURCENAME L"MofResourceName"

//
// What can be paged ???
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ClassSystemControl)
#pragma alloc_text(PAGE, ClassFindGuid)
#endif


/*++////////////////////////////////////////////////////////////////////////////

ClassFindGuid()

Routine Description:

    This routine will search the list of guids registered and return
    the index for the one that was registered.

Arguments:

    GuidList is the list of guids to search

    GuidCount is the count of guids in the list

    Guid is the guid being searched for

    *GuidIndex returns the index to the guid

Return Value:

    TRUE if guid is found else FALSE

--*/
BOOLEAN
ClassFindGuid(
    PGUIDREGINFO GuidList,
    ULONG GuidCount,
    LPGUID Guid,
    PULONG GuidIndex
    )
{
    ULONG i;

    PAGED_CODE();

    for (i = 0; i < GuidCount; i++)
    {
        if (IsEqualGUID(Guid, &GuidList[i].Guid))
        {
            *GuidIndex = i;
            return(TRUE);
        }
    }

    return(FALSE);
} // end ClassFindGuid()

/*++////////////////////////////////////////////////////////////////////////////

ClassSystemControl()

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL. This routine will process
    all wmi requests received, forwarding them if they are not for this
    driver or determining if the guid is valid and if so passing it to
    the driver specific function for handing wmi requests.

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.

Return Value:

    status

--*/
NTSTATUS
ClassSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PCLASS_DRIVER_EXTENSION driverExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG isRemoved;
    ULONG bufferSize;
    PUCHAR buffer;
    NTSTATUS status;
    UCHAR minorFunction;
    ULONG guidIndex;
    PCLASS_WMI_INFO classWmiInfo;

    PAGED_CODE();

    //
    // Make sure device has not been removed
    isRemoved = ClassAcquireRemoveLock(DeviceObject, Irp);
    if(isRemoved)
    {
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // If the irp is not a WMI irp or it is not targetted at this device
    // or this device has not regstered with WMI then just forward it on.
    minorFunction = irpStack->MinorFunction;
    if ((minorFunction > IRP_MN_EXECUTE_METHOD) ||
        (irpStack->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject) ||
        ((minorFunction != IRP_MN_REGINFO) &&
         (commonExtension->GuidRegInfo == NULL)))
    {
        //
        // CONSIDER: Do I need to hang onto lock until IoCallDriver returns ?
        IoSkipCurrentIrpStackLocation(Irp);
        ClassReleaseRemoveLock(DeviceObject, Irp);
        return(IoCallDriver(commonExtension->LowerDeviceObject, Irp));
    }

    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    if (minorFunction != IRP_MN_REGINFO)
    {
        //
        // For all requests other than query registration info we are passed
        // a guid. Determine if the guid is one that is supported by the
        // device.
        if (ClassFindGuid(commonExtension->GuidRegInfo,
                            commonExtension->GuidCount,
                            (LPGUID)irpStack->Parameters.WMI.DataPath,
                            &guidIndex))
        {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }

        if (NT_SUCCESS(status) &&
            ((minorFunction == IRP_MN_QUERY_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_INSTANCE) ||
             (minorFunction == IRP_MN_CHANGE_SINGLE_ITEM) ||
             (minorFunction == IRP_MN_EXECUTE_METHOD)))
        {
            if ( (((PWNODE_HEADER)buffer)->Flags) &
                                          WNODE_FLAG_STATIC_INSTANCE_NAMES)
            {
                if ( ((PWNODE_SINGLE_INSTANCE)buffer)->InstanceIndex != 0 )
                {
                    status = STATUS_WMI_INSTANCE_NOT_FOUND;
                }
            } else {
                status = STATUS_WMI_INSTANCE_NOT_FOUND;
            }
        }

        if (! NT_SUCCESS(status))
        {
            Irp->IoStatus.Status = status;
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            return(status);
        }
    }

    driverExtension = commonExtension->DriverExtension;

    classWmiInfo = commonExtension->IsFdo ?
                           &driverExtension->InitData.FdoData.ClassWmiInfo :
                           &driverExtension->InitData.PdoData.ClassWmiInfo;
    switch(minorFunction)
    {
        case IRP_MN_REGINFO:
        {
            ULONG guidCount;
            PGUIDREGINFO guidList;
            PWMIREGINFOW wmiRegInfo;
            PWMIREGGUIDW wmiRegGuid;
            PDEVICE_OBJECT pdo;
            PUNICODE_STRING regPath;
            PWCHAR stringPtr;
            ULONG retSize;
            ULONG registryPathOffset;
            ULONG mofResourceOffset;
            ULONG bufferNeeded;
            ULONG i;
            ULONG_PTR nameInfo;
            ULONG nameSize, nameOffset, nameFlags;
            UNICODE_STRING name, mofName;
            PCLASS_QUERY_WMI_REGINFO_EX ClassQueryWmiRegInfoEx;

            name.Buffer = NULL;
            name.Length = 0;
            name.MaximumLength = 0;
            nameFlags = 0;

            ClassQueryWmiRegInfoEx = commonExtension->IsFdo ?
                               driverExtension->ClassFdoQueryWmiRegInfoEx :
                               driverExtension->ClassPdoQueryWmiRegInfoEx;
        
            if (ClassQueryWmiRegInfoEx == NULL)
            {
                status = classWmiInfo->ClassQueryWmiRegInfo(
                                                        DeviceObject,
                                                        &nameFlags,
                                                        &name);
                
                RtlInitUnicodeString(&mofName, MOFRESOURCENAME);
            } else {
                RtlInitUnicodeString(&mofName, L"");
                status = (*ClassQueryWmiRegInfoEx)(
                                                    DeviceObject,
                                                    &nameFlags,
                                                    &name,
                                                    &mofName);
            }

            if (NT_SUCCESS(status) &&
                (! (nameFlags &  WMIREG_FLAG_INSTANCE_PDO) &&
                (name.Buffer == NULL)))
            {
                //
                // if PDO flag not specified then an instance name must be
                status = STATUS_INVALID_DEVICE_REQUEST;
            }

            if (NT_SUCCESS(status))
            {
                guidList = classWmiInfo->GuidRegInfo;
                guidCount = classWmiInfo->GuidCount;

                nameOffset = sizeof(WMIREGINFO) +
                                      guidCount * sizeof(WMIREGGUIDW);

                if (nameFlags & WMIREG_FLAG_INSTANCE_PDO)
                {
                    nameSize = 0;
                    nameInfo = commonExtension->IsFdo ?
                                   (ULONG_PTR)((PFUNCTIONAL_DEVICE_EXTENSION)commonExtension)->LowerPdo :
                                   (ULONG_PTR)DeviceObject;
                } else {
                    nameFlags |= WMIREG_FLAG_INSTANCE_LIST;
                    nameSize = name.Length + sizeof(USHORT);
                    nameInfo = nameOffset;
                }

                mofResourceOffset = nameOffset + nameSize;

                registryPathOffset = mofResourceOffset +
                                  mofName.Length + sizeof(USHORT);

                regPath = &driverExtension->RegistryPath;
                bufferNeeded = registryPathOffset +
                regPath->Length + sizeof(USHORT);

                if (bufferNeeded <= bufferSize)
                {
                    retSize = bufferNeeded;

                    commonExtension->GuidCount = guidCount;
                    commonExtension->GuidRegInfo = guidList;

                    wmiRegInfo = (PWMIREGINFO)buffer;
                    wmiRegInfo->BufferSize = bufferNeeded;
                    wmiRegInfo->NextWmiRegInfo = 0;
                    wmiRegInfo->MofResourceName = mofResourceOffset;
                    wmiRegInfo->RegistryPath = registryPathOffset;
                    wmiRegInfo->GuidCount = guidCount;

                    for (i = 0; i < guidCount; i++)
                    {
                        wmiRegGuid = &wmiRegInfo->WmiRegGuid[i];
                        wmiRegGuid->Guid = guidList[i].Guid;
                        wmiRegGuid->Flags = guidList[i].Flags | nameFlags;
                        wmiRegGuid->InstanceInfo = nameInfo;
                        wmiRegGuid->InstanceCount = 1;
                    }

                    if ( nameFlags &  WMIREG_FLAG_INSTANCE_LIST)
                    {
                        stringPtr = (PWCHAR)((PUCHAR)buffer + nameOffset);
                        *stringPtr++ = name.Length;
                        RtlCopyMemory(stringPtr,
                                  name.Buffer,
                                  name.Length);
                    }

                    stringPtr = (PWCHAR)((PUCHAR)buffer + mofResourceOffset);
                    *stringPtr++ = mofName.Length;
                    RtlCopyMemory(stringPtr,
                                  mofName.Buffer,
                                  mofName.Length);

                    stringPtr = (PWCHAR)((PUCHAR)buffer + registryPathOffset);
                    *stringPtr++ = regPath->Length;
                    RtlCopyMemory(stringPtr,
                              regPath->Buffer,
                              regPath->Length);
                } else {
                    *((PULONG)buffer) = bufferNeeded;
                    retSize = sizeof(ULONG);
                }
            } else {
                retSize = 0;
            }

            if (name.Buffer != NULL)
            {
                ExFreePool(name.Buffer);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = retSize;
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
            return(status);
        }

        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            ULONG bufferAvail;

            wnode = (PWNODE_ALL_DATA)buffer;

            if (bufferSize < sizeof(WNODE_ALL_DATA))
            {
                bufferAvail = 0;
            } else {
                bufferAvail = bufferSize - sizeof(WNODE_ALL_DATA);
            }

            wnode->DataBlockOffset = sizeof(WNODE_ALL_DATA);

            status = classWmiInfo->ClassQueryWmiDataBlock(
                                             DeviceObject,
                                             Irp,
                                             guidIndex,
                                             bufferAvail,
                                             buffer + sizeof(WNODE_ALL_DATA));

            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            ULONG dataBlockOffset;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            dataBlockOffset = wnode->DataBlockOffset;

            status = classWmiInfo->ClassQueryWmiDataBlock(
                                          DeviceObject,
                                          Irp,
                                          guidIndex,
                                          bufferSize - dataBlockOffset,
                                          (PUCHAR)wnode + dataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            status = classWmiInfo->ClassSetWmiDataBlock(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     wnode->SizeDataBlock,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            break;
        }

        case IRP_MN_CHANGE_SINGLE_ITEM:
        {
            PWNODE_SINGLE_ITEM wnode;

            wnode = (PWNODE_SINGLE_ITEM)buffer;

            status = classWmiInfo->ClassSetWmiDataItem(
                                     DeviceObject,
                                     Irp,
                                     guidIndex,
                                     wnode->ItemId,
                                     wnode->SizeDataItem,
                                     (PUCHAR)wnode + wnode->DataBlockOffset);

            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;

            wnode = (PWNODE_METHOD_ITEM)buffer;

            status = classWmiInfo->ClassExecuteWmiMethod(
                                         DeviceObject,
                                         Irp,
                                         guidIndex,
                                         wnode->MethodId,
                                         wnode->SizeDataBlock,
                                         bufferSize - wnode->DataBlockOffset,
                                         buffer + wnode->DataBlockOffset);


            break;
        }

        case IRP_MN_ENABLE_EVENTS:
        {
            status = classWmiInfo->ClassWmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           EventGeneration,
                                                           TRUE);
            break;
        }

        case IRP_MN_DISABLE_EVENTS:
        {
            status = classWmiInfo->ClassWmiFunctionControl(
                                                           DeviceObject,
                                                           Irp,
                                                           guidIndex,
                                                           EventGeneration,
                                                           FALSE);
            break;
        }

        case IRP_MN_ENABLE_COLLECTION:
        {
            status = classWmiInfo->ClassWmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         DataBlockCollection,
                                                         TRUE);
            break;
        }

        case IRP_MN_DISABLE_COLLECTION:
        {
            status = classWmiInfo->ClassWmiFunctionControl(
                                                         DeviceObject,
                                                         Irp,
                                                         guidIndex,
                                                         DataBlockCollection,
                                                         FALSE);
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

    }

    return(status);
} // end ClassSystemControl()

/*++////////////////////////////////////////////////////////////////////////////

ClassWmiCompleteRequest()

Routine Description:


    This routine will do the work of completing a WMI irp. Depending upon the
    the WMI request this routine will fixup the returned WNODE appropriately.

    NOTE: This routine assumes that the ClassRemoveLock is held and it will
          release it.

Arguments:

    DeviceObject - Supplies a pointer to the device object for this request.

    Irp - Supplies the Irp making the request.
    
    Status - Status to complete the irp with.  STATUS_BUFFER_TOO_SMALL is used
        to indicate that more buffer is required for the data requested.
    
    BufferUsed - number of bytes of actual data to return (not including WMI
        specific structures)
    
    PriorityBoost - priority boost to pass to ClassCompleteRequest

Return Value:

    status

--*/
SCSIPORT_API
NTSTATUS
ClassWmiCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    UCHAR MinorFunction;
    PUCHAR buffer;
    ULONG retSize;
    UCHAR minorFunction;
    ULONG bufferSize;

    minorFunction = irpStack->MinorFunction;
    buffer = (PUCHAR)irpStack->Parameters.WMI.Buffer;
    bufferSize = irpStack->Parameters.WMI.BufferSize;

    switch(minorFunction)
    {
        case IRP_MN_QUERY_ALL_DATA:
        {
            PWNODE_ALL_DATA wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_ALL_DATA)buffer;

            bufferNeeded = sizeof(WNODE_ALL_DATA) + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                wnode->WnodeHeader.Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;
                wnode->FixedInstanceSize = BufferUsed;
                wnode->InstanceCount = 1;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = sizeof(WNODE_ALL_DATA) + BufferUsed;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_QUERY_SINGLE_INSTANCE:
        {
            PWNODE_SINGLE_INSTANCE wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_SINGLE_INSTANCE)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        case IRP_MN_EXECUTE_METHOD:
        {
            PWNODE_METHOD_ITEM wnode;
            PWNODE_TOO_SMALL wnodeTooSmall;
            ULONG bufferNeeded;

            wnode = (PWNODE_METHOD_ITEM)buffer;

            bufferNeeded = wnode->DataBlockOffset + BufferUsed;

            if (NT_SUCCESS(Status))
            {
                retSize = bufferNeeded;
                wnode->WnodeHeader.BufferSize = bufferNeeded;
                KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
                wnode->SizeDataBlock = BufferUsed;

            } else if (Status == STATUS_BUFFER_TOO_SMALL) {
                wnodeTooSmall = (PWNODE_TOO_SMALL)wnode;

                wnodeTooSmall->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);
                wnodeTooSmall->WnodeHeader.Flags = WNODE_FLAG_TOO_SMALL;
                wnodeTooSmall->SizeNeeded = bufferNeeded;
                retSize = sizeof(WNODE_TOO_SMALL);
                Status = STATUS_SUCCESS;
            } else {
                retSize = 0;
            }
            break;
        }

        default:
        {
            //
            // All other requests don't return any data
            retSize = 0;
            break;
        }

    }

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = retSize;
    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject, Irp, PriorityBoost);
    return(Status);
} // end ClassWmiCompleteRequest()

/*++////////////////////////////////////////////////////////////////////////////

ClassWmiFireEvent()

Routine Description:

    This routine will fire a WMI event using the data buffer passed. This
    routine may be called at or below DPC level

Arguments:

    DeviceObject - Supplies a pointer to the device object for this event

    Guid is pointer to the GUID that represents the event

    InstanceIndex is the index of the instance of the event

    EventDataSize is the number of bytes of data that is being fired with
       with the event

    EventData is the data that is fired with the events. This may be NULL
        if there is no data associated with the event


Return Value:

    status

--*/
NTSTATUS
ClassWmiFireEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    )
{

    ULONG sizeNeeded;
    PWNODE_SINGLE_INSTANCE event;
    NTSTATUS status;

    if (EventData == NULL)
    {
        EventDataSize = 0;
    }

    sizeNeeded = sizeof(WNODE_SINGLE_INSTANCE) + EventDataSize;

    event = ExAllocatePoolWithTag(NonPagedPool, sizeNeeded, CLASS_TAG_WMI);
    if (event != NULL)
    {
        event->WnodeHeader.Guid = *Guid;
        event->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(DeviceObject);
        event->WnodeHeader.BufferSize = sizeNeeded;
        event->WnodeHeader.Flags =  WNODE_FLAG_SINGLE_INSTANCE |
                                    WNODE_FLAG_EVENT_ITEM |
                                    WNODE_FLAG_STATIC_INSTANCE_NAMES;
        KeQuerySystemTime(&event->WnodeHeader.TimeStamp);

        event->InstanceIndex = InstanceIndex;
        event->SizeDataBlock = EventDataSize;
        event->DataBlockOffset = sizeof(WNODE_SINGLE_INSTANCE);
        if (EventData != NULL)
        {
            RtlCopyMemory( &event->VariableData, EventData, EventDataSize);
        }

        status = IoWMIWriteEvent(event);
        if (! NT_SUCCESS(status))
        {
            ExFreePool(event);
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
} // end ClassWmiFireEvent()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\debug.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    debug.h

Abstract:


Author:

Environment:

    kernel mode only

Notes:


Revision History:

--*/


VOID ClassDebugPrint(CLASS_DEBUG_LEVEL DebugPrintLevel, PCCHAR DebugMessage, ...);

#if DBG

    typedef struct _CLASSPNP_GLOBALS {

        //
        // whether or not to ASSERT for lost irps
        //

        ULONG BreakOnLostIrps;
        ULONG SecondsToWaitForIrps;

        //
        // use a buffered debug print to help
        // catch timing issues that do not
        // reproduce with std debugprints enabled
        //

        ULONG UseBufferedDebugPrint;
        ULONG UseDelayedRetry;

        //
        // the next four are the buffered printing support
        // (currently unimplemented) and require the spinlock
        // to use
        //

        ULONG Index;                // index into buffer
        KSPIN_LOCK SpinLock;
        PUCHAR Buffer;              // requires spinlock to access
        ULONG NumberOfBuffers;      // number of buffers available
        SIZE_T EachBufferSize;      // size of each buffer

        //
        // interlocked variables to initialize
        // this data only once
        //

        LONG Initializing;
        LONG Initialized;

    } CLASSPNP_GLOBALS, *PCLASSPNP_GLOBALS;

    #define DBGTRACE(dbgTraceLevel, args_in_parens)                                \
        if (ClassDebug & (1 << (dbgTraceLevel+15))){                                               \
            DbgPrint("CLASSPNP> *** TRACE *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("    >  "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (DebugTrapOnWarn && (dbgTraceLevel == ClassDebugWarning)){ \
                DbgBreakPoint();  \
            } \
        }
    #define DBGWARN(args_in_parens)                                \
        {                                               \
            DbgPrint("CLASSPNP> *** WARNING *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("    >  "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            if (DebugTrapOnWarn){ \
                DbgBreakPoint();  \
            } \
        }
    #define DBGERR(args_in_parens)                                \
        {                                               \
            DbgPrint("CLASSPNP> *** ERROR *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("    >  "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }
    #define DBGTRAP(args_in_parens)                                \
        {                                               \
            DbgPrint("CLASSPNP> *** COVERAGE TRAP *** (file %s, line %d)\n", __FILE__, __LINE__ ); \
            DbgPrint("    >  "); \
            DbgPrint args_in_parens; \
            DbgPrint("\n"); \
            DbgBreakPoint();                            \
        }


    #define DBGGETIOCTLSTR(_ioctl) DbgGetIoctlStr(_ioctl)
    #define DBGGETSCSIOPSTR(_pSrb) DbgGetScsiOpStr(_pSrb)
    #define DBGGETSENSECODESTR(_pSrb) DbgGetSenseCodeStr(_pSrb)
    #define DBGGETADSENSECODESTR(_pSrb) DbgGetAdditionalSenseCodeStr(_pSrb)
    #define DBGGETADSENSEQUALIFIERSTR(_pSrb) DbgGetAdditionalSenseCodeQualifierStr(_pSrb)
    #define DBGCHECKRETURNEDPKT(_pkt) DbgCheckReturnedPkt(_pkt)
    #define DBGGETSRBSTATUSSTR(_pSrb) DbgGetSrbStatusStr(_pSrb)
    
    VOID ClasspInitializeDebugGlobals();
    char *DbgGetIoctlStr(ULONG ioctl);
    char *DbgGetScsiOpStr(PSCSI_REQUEST_BLOCK Srb);
    char *DbgGetSenseCodeStr(PSCSI_REQUEST_BLOCK Srb);
    char *DbgGetAdditionalSenseCodeStr(PSCSI_REQUEST_BLOCK Srb);
    char *DbgGetAdditionalSenseCodeQualifierStr(PSCSI_REQUEST_BLOCK Srb);
    VOID DbgCheckReturnedPkt(TRANSFER_PACKET *Pkt);
    char *DbgGetSrbStatusStr(PSCSI_REQUEST_BLOCK Srb);


    extern CLASSPNP_GLOBALS ClasspnpGlobals;
    extern LONG ClassDebug;
    extern BOOLEAN DebugTrapOnWarn;

#else

    #define ClasspInitializeDebugGlobals()
    #define DBGWARN(args_in_parens)                                
    #define DBGERR(args_in_parens)                                
    #define DBGTRACE(dbgTraceLevel, args_in_parens)                                
    #define DBGTRAP(args_in_parens)
    
    #define DBGGETIOCTLSTR(_ioctl)
    #define DBGGETSCSIOPSTR(_pSrb)
    #define DBGGETSENSECODESTR(_pSrb)    
    #define DBGGETADSENSECODESTR(_pSrb)
    #define DBGGETADSENSEQUALIFIERSTR(_pSrb)
    #define DBGCHECKRETURNEDPKT(_pkt)
    #define DBGGETSRBSTATUSSTR(_pSrb)
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\power.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    class.c

Abstract:

    SCSI class driver routines

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "stddef.h"
#include "ntddk.h"
#include "scsi.h"
#include "classp.h"

#include <stdarg.h>

#define CLASS_TAG_POWER     'WLcS'

NTSTATUS
ClasspPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN CLASS_POWER_OPTIONS Options
    );

NTSTATUS
ClasspPowerDownCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCLASS_POWER_CONTEXT Context
    );

NTSTATUS
ClasspPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCLASS_POWER_CONTEXT Context
    );

VOID
RetryPowerRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PCLASS_POWER_CONTEXT Context
    );

NTSTATUS
ClasspStartNextPowerIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*++////////////////////////////////////////////////////////////////////////////

ClassDispatchPower()

Routine Description:

    This routine acquires the removelock for the irp and then calls the
    appropriate power callback.

Arguments:

    DeviceObject -
    Irp -

Return Value:

--*/
NTSTATUS
ClassDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    ULONG isRemoved;
    PCLASS_POWER_DEVICE powerRoutine = NULL;

    //
    // NOTE: This code may be called at PASSIVE or DISPATCH, depending
    //       upon the device object it is being called for.
    //       don't do anything that would break under either circumstance.
    //

    NTSTATUS status;

    isRemoved = ClassAcquireRemoveLock(DeviceObject, Irp);

    if(isRemoved) {
        ClassReleaseRemoveLock(DeviceObject, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        PoStartNextPowerIrp(Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    return commonExtension->DevInfo->ClassPowerDevice(DeviceObject, Irp);
} // end ClassDispatchPower()

/*++////////////////////////////////////////////////////////////////////////////

ClasspPowerUpCompletion()

Routine Description:

    This routine is used for intermediate completion of a power up request.
    PowerUp requires four requests to be sent to the lower driver in sequence.

        * The queue is "power locked" to ensure that the class driver power-up
          work can be done before request processing resumes.

        * The power irp is sent down the stack for any filter drivers and the
          port driver to return power and resume command processing for the
          device.  Since the queue is locked, no queued irps will be sent
          immediately.

        * A start unit command is issued to the device with appropriate flags
          to override the "power locked" queue.

        * The queue is "power unlocked" to start processing requests again.

    This routine uses the function in the srb which just completed to determine
    which state it is in.

Arguments:

    DeviceObject - the device object being powered up

    Irp - the IO_REQUEST_PACKET containing the power request

    Srb - the SRB used to perform port/class operations.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED or
    STATUS_SUCCESS

--*/
NTSTATUS
ClasspPowerUpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCLASS_POWER_CONTEXT Context
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION currentStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextStack = IoGetNextIrpStackLocation(Irp);


    NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;

    DebugPrint((1, "ClasspPowerUpCompletion: Device Object %p, Irp %p, "
                   "Context %p\n",
                DeviceObject, Irp, Context));

    ASSERT(!TEST_FLAG(Context->Srb.SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
    ASSERT(!TEST_FLAG(Context->Srb.SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));
    ASSERT(Context->Options.PowerDown == FALSE);
    ASSERT(Context->Options.HandleSpinUp);

    if(Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    Context->PowerChangeState.PowerUp++;

    switch(Context->PowerChangeState.PowerUp) {

        case PowerUpDeviceLocked: {

            DebugPrint((1, "(%p)\tPreviously sent power lock\n", Irp));

            //
            // Issue the actual power request to the lower driver.
            //

            IoCopyCurrentIrpStackLocationToNext(Irp);

            //
            // If the lock wasn't successful then just bail out on the power
            // request unless we can ignore failed locks
            //

            if((Context->Options.LockQueue == TRUE) &&
               (!NT_SUCCESS(Irp->IoStatus.Status))) {

                DebugPrint((1, "(%p)\tIrp status was %lx\n",
                            Irp, Irp->IoStatus.Status));
                DebugPrint((1, "(%p)\tSrb status was %lx\n",
                            Irp, Context->Srb.SrbStatus));

                //
                // Lock was not successful - throw down the power IRP
                // by itself and don't try to spin up the drive or unlock
                // the queue.
                //

                Context->InUse = FALSE;
                Context = NULL;

                //
                // Set the new power state
                //

                fdoExtension->DevicePowerState =
                    currentStack->Parameters.Power.State.DeviceState;

                Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       ClasspStartNextPowerIrpCompletion,
                                       NULL,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                //
                // Indicate to Po that we've been successfully powered up so
                // it can do it's notification stuff.
                //

                PoSetPowerState(DeviceObject,
                                currentStack->Parameters.Power.Type,
                                currentStack->Parameters.Power.State);

                PoCallDriver(commonExtension->LowerDeviceObject, Irp);

                ClassReleaseRemoveLock(commonExtension->DeviceObject,
                                       Irp);

                return STATUS_MORE_PROCESSING_REQUIRED;

            } else {
                Context->QueueLocked = (UCHAR) Context->Options.LockQueue;
            }

            Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

            Context->PowerChangeState.PowerUp = PowerUpDeviceLocked;

            IoSetCompletionRoutine(Irp,
                                   ClasspPowerUpCompletion,
                                   Context,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            status = PoCallDriver(commonExtension->LowerDeviceObject, Irp);

            DebugPrint((2, "(%p)\tPoCallDriver returned %lx\n", Irp, status));
            break;
        }

        case PowerUpDeviceOn: {

            PCDB cdb;

            if(NT_SUCCESS(Irp->IoStatus.Status)) {

                DebugPrint((1, "(%p)\tSending start unit to device\n", Irp));

                //
                // Issue the start unit command to the device.
                //

                Context->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
                Context->Srb.Function = SRB_FUNCTION_EXECUTE_SCSI;

                Context->Srb.SrbStatus = Context->Srb.ScsiStatus = 0;
                Context->Srb.DataTransferLength = 0;

                Context->Srb.TimeOutValue = START_UNIT_TIMEOUT;

                Context->Srb.SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER |
                                        SRB_FLAGS_DISABLE_AUTOSENSE |
                                        SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                                        SRB_FLAGS_NO_QUEUE_FREEZE;

                if(Context->Options.LockQueue) {
                    SET_FLAG(Context->Srb.SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE);
                }

                Context->Srb.CdbLength = 6;

                cdb = (PCDB) (Context->Srb.Cdb);
                RtlZeroMemory(cdb, sizeof(CDB));


                cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
                cdb->START_STOP.Start = 1;

                Context->PowerChangeState.PowerUp = PowerUpDeviceOn;

                IoSetCompletionRoutine(Irp,
                                       ClasspPowerUpCompletion,
                                       Context,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                nextStack->Parameters.Scsi.Srb = &(Context->Srb);
                nextStack->MajorFunction = IRP_MJ_SCSI;

                status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

                DebugPrint((2, "(%p)\tIoCallDriver returned %lx\n", Irp, status));

            } else {

                //
                // we're done.
                //

                Context->FinalStatus = Irp->IoStatus.Status;
                goto ClasspPowerUpCompletionFailure;
            }

            break;
        }

        case PowerUpDeviceStarted: { // 3

            //
            // First deal with an error if one occurred.
            //

            if(SRB_STATUS(Context->Srb.SrbStatus) != SRB_STATUS_SUCCESS) {

                BOOLEAN retry;

                DebugPrint((1, "%p\tError occured when issuing START_UNIT "
                            "command to device. Srb %p, Status %x\n",
                            Irp,
                            &Context->Srb,
                            Context->Srb.SrbStatus));

                ASSERT(!(TEST_FLAG(Context->Srb.SrbStatus,
                                   SRB_STATUS_QUEUE_FROZEN)));
                ASSERT(Context->Srb.Function == SRB_FUNCTION_EXECUTE_SCSI);

                Context->RetryInterval = 0;

                retry = ClassInterpretSenseInfo(
                            commonExtension->DeviceObject,
                            &Context->Srb,
                            IRP_MJ_SCSI,
                            IRP_MJ_POWER,
                            MAXIMUM_RETRIES - Context->RetryCount,
                            &status,
                            &Context->RetryInterval);

                if((retry == TRUE) && (Context->RetryCount-- != 0)) {

                    DebugPrint((1, "(%p)\tRetrying failed request\n", Irp));

                    //
                    // Decrement the state so we come back through here the
                    // next time.
                    //

                    Context->PowerChangeState.PowerUp--;

                    RetryPowerRequest(commonExtension->DeviceObject,
                                      Irp,
                                      Context);

                    break;

                }

                // reset retries
                Context->RetryCount = MAXIMUM_RETRIES;

            }

ClasspPowerUpCompletionFailure:

            DebugPrint((1, "(%p)\tPreviously spun device up\n", Irp));

            if (Context->QueueLocked) {
                DebugPrint((1, "(%p)\tUnlocking queue\n", Irp));

                Context->Srb.Function = SRB_FUNCTION_UNLOCK_QUEUE;
                Context->Srb.SrbFlags = SRB_FLAGS_BYPASS_LOCKED_QUEUE;
                Context->Srb.SrbStatus = Context->Srb.ScsiStatus = 0;
                Context->Srb.DataTransferLength = 0;

                nextStack->Parameters.Scsi.Srb = &(Context->Srb);
                nextStack->MajorFunction = IRP_MJ_SCSI;

                Context->PowerChangeState.PowerUp = PowerUpDeviceStarted;

                IoSetCompletionRoutine(Irp,
                                       ClasspPowerUpCompletion,
                                       Context,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
                DebugPrint((1, "(%p)\tIoCallDriver returned %lx\n",
                            Irp, status));
                break;
            }

            // Fall-through to next case...

        }

        case PowerUpDeviceUnlocked: {

            //
            // This is the end of the dance.  Free the srb and complete the
            // request finally.  We're ignoring possible intermediate
            // error conditions ....
            //

            if (Context->QueueLocked) {
                DebugPrint((1, "(%p)\tPreviously unlocked queue\n", Irp));
                ASSERT(NT_SUCCESS(Irp->IoStatus.Status));
                ASSERT(Context->Srb.SrbStatus == SRB_STATUS_SUCCESS);
            } else {
                DebugPrint((1, "(%p)\tFall-through (queue not locked)\n", Irp));
            }

            DebugPrint((1, "(%p)\tFreeing srb and completing\n", Irp));
            Context->InUse = FALSE;

            status = Context->FinalStatus;
            Irp->IoStatus.Status = status;

            Context = NULL;

            //
            // Set the new power state
            //

            if(NT_SUCCESS(status)) {
                fdoExtension->DevicePowerState =
                    currentStack->Parameters.Power.State.DeviceState;
            }

            //
            // Indicate to Po that we've been successfully powered up so
            // it can do it's notification stuff.
            //

            PoSetPowerState(DeviceObject,
                            currentStack->Parameters.Power.Type,
                            currentStack->Parameters.Power.State);

            DebugPrint((1, "(%p)\tStarting next power irp\n", Irp));
            ClassReleaseRemoveLock(DeviceObject, Irp);
            PoStartNextPowerIrp(Irp);

            return status;
        }
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
} // end ClasspPowerUpCompletion()

/*++////////////////////////////////////////////////////////////////////////////

ClasspPowerDownCompletion()

Routine Description:

    This routine is used for intermediate completion of a power up request.
    PowerUp requires four requests to be sent to the lower driver in sequence.

        * The queue is "power locked" to ensure that the class driver power-up
          work can be done before request processing resumes.

        * The power irp is sent down the stack for any filter drivers and the
          port driver to return power and resume command processing for the
          device.  Since the queue is locked, no queued irps will be sent
          immediately.

        * A start unit command is issued to the device with appropriate flags
          to override the "power locked" queue.

        * The queue is "power unlocked" to start processing requests again.

    This routine uses the function in the srb which just completed to determine
    which state it is in.

Arguments:

    DeviceObject - the device object being powered up

    Irp - the IO_REQUEST_PACKET containing the power request

    Srb - the SRB used to perform port/class operations.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED or
    STATUS_SUCCESS

--*/
NTSTATUS
ClasspPowerDownCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PCLASS_POWER_CONTEXT Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION currentStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextStack = IoGetNextIrpStackLocation(Irp);

    NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;

    DebugPrint((1, "ClasspPowerDownCompletion: Device Object %p, "
                   "Irp %p, Context %p\n",
                DeviceObject, Irp, Context));

    ASSERT(!TEST_FLAG(Context->Srb.SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
    ASSERT(!TEST_FLAG(Context->Srb.SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));
    ASSERT(Context->Options.PowerDown == TRUE);
    ASSERT(Context->Options.HandleSpinDown);

    if(Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    Context->PowerChangeState.PowerDown2++;

    switch(Context->PowerChangeState.PowerDown2) {

        case PowerDownDeviceLocked2: {

            PCDB cdb;

            DebugPrint((1, "(%p)\tPreviously sent power lock\n", Irp));

            if((Context->Options.LockQueue == TRUE) &&
               (!NT_SUCCESS(Irp->IoStatus.Status))) {

                DebugPrint((1, "(%p)\tIrp status was %lx\n",
                            Irp,
                            Irp->IoStatus.Status));
                DebugPrint((1, "(%p)\tSrb status was %lx\n",
                            Irp,
                            Context->Srb.SrbStatus));

                Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                //
                // Lock was not successful - throw down the power IRP
                // by itself and don't try to spin down the drive or unlock
                // the queue.
                //

                Context->InUse = FALSE;
                Context = NULL;

                //
                // Set the new power state
                //

                fdoExtension->DevicePowerState =
                    currentStack->Parameters.Power.State.DeviceState;

                //
                // Indicate to Po that we've been successfully powered down
                // so it can do it's notification stuff.
                //

                IoCopyCurrentIrpStackLocationToNext(Irp);
                IoSetCompletionRoutine(Irp,
                                       ClasspStartNextPowerIrpCompletion,
                                       NULL,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                PoSetPowerState(DeviceObject,
                                currentStack->Parameters.Power.Type,
                                currentStack->Parameters.Power.State);

                fdoExtension->PowerDownInProgress = FALSE;

                PoCallDriver(commonExtension->LowerDeviceObject, Irp);

                ClassReleaseRemoveLock(commonExtension->DeviceObject,
                                       Irp);

                return STATUS_MORE_PROCESSING_REQUIRED;

            } else {
                Context->QueueLocked = (UCHAR) Context->Options.LockQueue;
            }

            if (!TEST_FLAG(fdoExtension->PrivateFdoData->HackFlags,
                           FDO_HACK_NO_SYNC_CACHE)) {

                //
                // send SCSIOP_SYNCHRONIZE_CACHE
                //

                Context->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
                Context->Srb.Function = SRB_FUNCTION_EXECUTE_SCSI;

                Context->Srb.TimeOutValue = fdoExtension->TimeOutValue;

                Context->Srb.SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER |
                                        SRB_FLAGS_DISABLE_AUTOSENSE |
                                        SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                                        SRB_FLAGS_NO_QUEUE_FREEZE |
                                        SRB_FLAGS_BYPASS_LOCKED_QUEUE;

                Context->Srb.SrbStatus = Context->Srb.ScsiStatus = 0;
                Context->Srb.DataTransferLength = 0;

                Context->Srb.CdbLength = 10;

                cdb = (PCDB) Context->Srb.Cdb;

                RtlZeroMemory(cdb, sizeof(CDB));
                cdb->SYNCHRONIZE_CACHE10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;

                IoSetCompletionRoutine(Irp,
                                       ClasspPowerDownCompletion,
                                       Context,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                nextStack->Parameters.Scsi.Srb = &(Context->Srb);
                nextStack->MajorFunction = IRP_MJ_SCSI;

                status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

                DebugPrint((1, "(%p)\tIoCallDriver returned %lx\n", Irp, status));
                break;

            } else {

                DebugPrint((1, "(%p)\tPower Down: not sending SYNCH_CACHE\n",
                            DeviceObject));
                Context->PowerChangeState.PowerDown2++;
                Context->Srb.SrbStatus = SRB_STATUS_SUCCESS;
                // and fall through....
            }
            // no break in case the device doesn't like synch_cache commands

        }

        case PowerDownDeviceFlushed2: {

            PCDB cdb;

            DebugPrint((1, "(%p)\tPreviously send SCSIOP_SYNCHRONIZE_CACHE\n",
                        Irp));

            //
            // SCSIOP_SYNCHRONIZE_CACHE was sent
            //

            if(SRB_STATUS(Context->Srb.SrbStatus) != SRB_STATUS_SUCCESS) {

                BOOLEAN retry;

                DebugPrint((1, "(%p)\tError occured when issuing "
                            "SYNCHRONIZE_CACHE command to device. "
                            "Srb %p, Status %lx\n",
                            Irp,
                            &Context->Srb,
                            Context->Srb.SrbStatus));

                ASSERT(!(TEST_FLAG(Context->Srb.SrbStatus,
                                   SRB_STATUS_QUEUE_FROZEN)));
                ASSERT(Context->Srb.Function == SRB_FUNCTION_EXECUTE_SCSI);

                Context->RetryInterval = 0;
                retry = ClassInterpretSenseInfo(
                            commonExtension->DeviceObject,
                            &Context->Srb,
                            IRP_MJ_SCSI,
                            IRP_MJ_POWER,
                            MAXIMUM_RETRIES - Context->RetryCount,
                            &status,
                            &Context->RetryInterval);

                if((retry == TRUE) && (Context->RetryCount-- != 0)) {

                        DebugPrint((1, "(%p)\tRetrying failed request\n", Irp));

                        //
                        // decrement the state so we come back through here
                        // the next time.
                        //

                        Context->PowerChangeState.PowerDown2--;
                        RetryPowerRequest(commonExtension->DeviceObject,
                                          Irp,
                                          Context);
                        break;
                }

                DebugPrint((1, "(%p)\tSYNCHRONIZE_CACHE not retried\n", Irp));
                Context->RetryCount = MAXIMUM_RETRIES;

            } // end !SRB_STATUS_SUCCESS

            //
            // note: we are purposefully ignoring any errors.  if the drive
            //       doesn't support a synch_cache, then we're up a creek
            //       anyways.
            //

            DebugPrint((1, "(%p)\tSending stop unit to device\n", Irp));

            //
            // Issue the start unit command to the device.
            //

            Context->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
            Context->Srb.Function = SRB_FUNCTION_EXECUTE_SCSI;

            Context->Srb.TimeOutValue = START_UNIT_TIMEOUT;

            Context->Srb.SrbFlags = SRB_FLAGS_NO_DATA_TRANSFER |
                                    SRB_FLAGS_DISABLE_AUTOSENSE |
                                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                                    SRB_FLAGS_NO_QUEUE_FREEZE |
                                    SRB_FLAGS_BYPASS_LOCKED_QUEUE;

            Context->Srb.SrbStatus = Context->Srb.ScsiStatus = 0;
            Context->Srb.DataTransferLength = 0;

            Context->Srb.CdbLength = 6;

            cdb = (PCDB) Context->Srb.Cdb;
            RtlZeroMemory(cdb, sizeof(CDB));

            cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
            cdb->START_STOP.Start = 0;
            cdb->START_STOP.Immediate = 1;

            IoSetCompletionRoutine(Irp,
                                   ClasspPowerDownCompletion,
                                   Context,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            nextStack->Parameters.Scsi.Srb = &(Context->Srb);
            nextStack->MajorFunction = IRP_MJ_SCSI;

            status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);

            DebugPrint((1, "(%p)\tIoCallDriver returned %lx\n", Irp, status));
            break;

        }

        case PowerDownDeviceStopped2: {

            BOOLEAN ignoreError = TRUE;

            //
            // stop was sent
            //

            if(SRB_STATUS(Context->Srb.SrbStatus) != SRB_STATUS_SUCCESS) {

                BOOLEAN retry;

                DebugPrint((1, "(%p)\tError occured when issueing STOP_UNIT "
                            "command to device. Srb %p, Status %lx\n",
                            Irp,
                            &Context->Srb,
                            Context->Srb.SrbStatus));

                ASSERT(!(TEST_FLAG(Context->Srb.SrbStatus,
                                   SRB_STATUS_QUEUE_FROZEN)));
                ASSERT(Context->Srb.Function == SRB_FUNCTION_EXECUTE_SCSI);

                Context->RetryInterval = 0;
                retry = ClassInterpretSenseInfo(
                            commonExtension->DeviceObject,
                            &Context->Srb,
                            IRP_MJ_SCSI,
                            IRP_MJ_POWER,
                            MAXIMUM_RETRIES - Context->RetryCount,
                            &status,
                            &Context->RetryInterval);

                if((retry == TRUE) && (Context->RetryCount-- != 0)) {

                        DebugPrint((1, "(%p)\tRetrying failed request\n", Irp));

                        //
                        // decrement the state so we come back through here
                        // the next time.
                        //

                        Context->PowerChangeState.PowerDown2--;
                        RetryPowerRequest(commonExtension->DeviceObject,
                                          Irp,
                                          Context);
                        break;
                }

                DebugPrint((1, "(%p)\tSTOP_UNIT not retried\n", Irp));
                Context->RetryCount = MAXIMUM_RETRIES;

            } // end !SRB_STATUS_SUCCESS


            DebugPrint((1, "(%p)\tPreviously sent stop unit\n", Irp));

            //
            // some operations, such as a physical format in progress,
            // should not be ignored and should fail the power operation.
            //

            if (!NT_SUCCESS(status)) {

                PSENSE_DATA senseBuffer = Context->Srb.SenseInfoBuffer;

                if (TEST_FLAG(Context->Srb.SrbStatus,
                              SRB_STATUS_AUTOSENSE_VALID) &&
                    ((senseBuffer->SenseKey & 0xf) == SCSI_SENSE_NOT_READY) &&
                    (senseBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY) &&
                    (senseBuffer->AdditionalSenseCodeQualifier == SCSI_SENSEQ_FORMAT_IN_PROGRESS)
                    ) {
                    ignoreError = FALSE;
                    Context->FinalStatus = STATUS_DEVICE_BUSY;
                    status = Context->FinalStatus;
                }

            }

            if (NT_SUCCESS(status) || ignoreError) {

                //
                // Issue the actual power request to the lower driver.
                //

                Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(Irp,
                                       ClasspPowerDownCompletion,
                                       Context,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = PoCallDriver(commonExtension->LowerDeviceObject, Irp);

                DebugPrint((1, "(%p)\tPoCallDriver returned %lx\n", Irp, status));
                break;
            }

            // else fall through w/o sending the power irp, since the device
            // is reporting an error that would be "really bad" to power down
            // during.

        }

        case PowerDownDeviceOff2: {

            //
            // SpinDown request completed ... whether it succeeded or not is
            // another matter entirely.
            //

            DebugPrint((1, "(%p)\tPreviously sent power irp\n", Irp));

            if (Context->QueueLocked) {

                DebugPrint((1, "(%p)\tUnlocking queue\n", Irp));

                Context->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);

                Context->Srb.SrbStatus = Context->Srb.ScsiStatus = 0;
                Context->Srb.DataTransferLength = 0;

                Context->Srb.Function = SRB_FUNCTION_UNLOCK_QUEUE;
                Context->Srb.SrbFlags = SRB_FLAGS_BYPASS_LOCKED_QUEUE;
                nextStack->Parameters.Scsi.Srb = &(Context->Srb);
                nextStack->MajorFunction = IRP_MJ_SCSI;

                IoSetCompletionRoutine(Irp,
                                       ClasspPowerDownCompletion,
                                       Context,
                                       TRUE,
                                       TRUE,
                                       TRUE);

                status = IoCallDriver(commonExtension->LowerDeviceObject, Irp);
                DebugPrint((1, "(%p)\tIoCallDriver returned %lx\n",
                            Irp,
                            status));
                break;
            }

        }

        case PowerDownDeviceUnlocked2: {

            //
            // This is the end of the dance.  Free the srb and complete the
            // request finally.  We're ignoring possible intermediate
            // error conditions ....
            //

            if (Context->QueueLocked == FALSE) {
                DebugPrint((1, "(%p)\tFall through (queue not locked)\n", Irp));
            } else {
                DebugPrint((1, "(%p)\tPreviously unlocked queue\n", Irp));
                ASSERT(NT_SUCCESS(Irp->IoStatus.Status));
                ASSERT(Context->Srb.SrbStatus == SRB_STATUS_SUCCESS);
            }

            DebugPrint((1, "(%p)\tFreeing srb and completing\n", Irp));
            Context->InUse = FALSE;
            status = Context->FinalStatus; // allow failure to propogate
            Context = NULL;

            if(Irp->PendingReturned) {
                IoMarkIrpPending(Irp);
            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information = 0;

            if (NT_SUCCESS(status)) {

                //
                // Set the new power state
                //

                fdoExtension->DevicePowerState =
                    currentStack->Parameters.Power.State.DeviceState;

            }


            DebugPrint((1, "(%p)\tStarting next power irp\n", Irp));

            ClassReleaseRemoveLock(DeviceObject, Irp);
            PoStartNextPowerIrp(Irp);
            fdoExtension->PowerDownInProgress = FALSE;

            return status;
        }
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
} // end ClasspPowerDownCompletion()

/*++////////////////////////////////////////////////////////////////////////////

ClasspPowerHandler()

Routine Description:

    This routine reduces the number of useless spinups and spindown requests
    sent to a given device by ignoring transitions to power states we are
    currently in.

    ISSUE-2000/02/20-henrygab - by ignoring spin-up requests, we may be
          allowing the drive

Arguments:

    DeviceObject - the device object which is transitioning power states
    Irp - the power irp
    Options - a set of flags indicating what the device handles

Return Value:

--*/
NTSTATUS
ClasspPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN CLASS_POWER_OPTIONS Options  // ISSUE-2000/02/20-henrygab - pass pointer, not whole struct
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT lowerDevice = commonExtension->LowerDeviceObject;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCLASS_POWER_CONTEXT context;

    if (!commonExtension->IsFdo) {

        //
        // certain assumptions are made here,
        // particularly: having the fdoExtension
        //

        DebugPrint((0, "ClasspPowerHandler: Called for PDO %p???\n",
                    DeviceObject));
        ASSERT(!"PDO using ClasspPowerHandler");
        return STATUS_NOT_SUPPORTED;
    }

    DebugPrint((1, "ClasspPowerHandler: Power irp %p to %s %p\n",
                Irp, (commonExtension->IsFdo ? "fdo" : "pdo"), DeviceObject));

    switch(irpStack->MinorFunction) {

        case IRP_MN_SET_POWER: {
            PCLASS_PRIVATE_FDO_DATA fdoData = fdoExtension->PrivateFdoData;

            DebugPrint((1, "(%p)\tIRP_MN_SET_POWER\n", Irp));

            DebugPrint((1, "(%p)\tSetting %s state to %d\n",
                        Irp,
                        (irpStack->Parameters.Power.Type == SystemPowerState ?
                            "System" : "Device"),
                        irpStack->Parameters.Power.State.SystemState));

                switch (irpStack->Parameters.Power.ShutdownType){

                    case PowerActionSleep:
                    case PowerActionHibernate:
                        if (fdoData->HotplugInfo.MediaRemovable || fdoData->HotplugInfo.MediaHotplug){
                            /*
                             *  We are suspending and this drive is either hot-pluggable
                             *  or contains removeable media.
                             *  Set the media dirty bit, since the media may change while
                             *  we are suspended.
                             */
                            SET_FLAG(DeviceObject->Flags, DO_VERIFY_VOLUME);

                            //
                            // Bumping the media  change count  will force the
                            // file system to verify the volume when we resume
                            //

                            InterlockedIncrement(&fdoExtension->MediaChangeCount);
                        }
                        break;
                }

            break;
        }

        default: {

            DebugPrint((1, "(%p)\tIrp minor code = %#x\n",
                        Irp, irpStack->MinorFunction));
            break;
        }
    }

    if (irpStack->Parameters.Power.Type != DevicePowerState ||
        irpStack->MinorFunction != IRP_MN_SET_POWER) {

        DebugPrint((1, "(%p)\tSending to lower device\n", Irp));

        goto ClasspPowerHandlerCleanup;

    }

    nextIrpStack = IoGetNextIrpStackLocation(Irp);

    //
    // already in exact same state, don't work to transition to it.
    //

    if(irpStack->Parameters.Power.State.DeviceState ==
       fdoExtension->DevicePowerState) {

        DebugPrint((1, "(%p)\tAlready in device state %x\n",
                    Irp, fdoExtension->DevicePowerState));
        goto ClasspPowerHandlerCleanup;

    }

    //
    // or powering down from non-d0 state (device already stopped)
    // NOTE -- we're not sure whether this case can exist or not (the
    // power system may never send this sort of request) but it's trivial
    // to deal with.
    //

    if ((irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0) &&
        (fdoExtension->DevicePowerState != PowerDeviceD0)) {
        DebugPrint((1, "(%p)\tAlready powered down to %x???\n",
                    Irp, fdoExtension->DevicePowerState));
        fdoExtension->DevicePowerState =
            irpStack->Parameters.Power.State.DeviceState;
        goto ClasspPowerHandlerCleanup;
    }

    //
    // or going into a hibernation state when we're in the hibernation path.
    // If the device is spinning then we should leave it spinning - if it's not
    // then the dump driver will start it up for us.
    //

    if((irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) &&
       (irpStack->Parameters.Power.ShutdownType == PowerActionHibernate) &&
       (commonExtension->HibernationPathCount != 0)) {

        DebugPrint((1, "(%p)\tdoing nothing for hibernation request for "
                       "state %x???\n",
                    Irp, fdoExtension->DevicePowerState));
        fdoExtension->DevicePowerState =
            irpStack->Parameters.Power.State.DeviceState;
        goto ClasspPowerHandlerCleanup;
    }
    //
    // or when not handling powering up and are powering up
    //

    if ((!Options.HandleSpinUp) &&
        (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0)) {

        DebugPrint((2, "(%p)\tNot handling spinup to state %x\n",
                    Irp, fdoExtension->DevicePowerState));
        fdoExtension->DevicePowerState =
            irpStack->Parameters.Power.State.DeviceState;
        goto ClasspPowerHandlerCleanup;

    }

    //
    // or when not handling powering down and are powering down
    //

    if ((!Options.HandleSpinDown) &&
        (irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0)) {

        DebugPrint((2, "(%p)\tNot handling spindown to state %x\n",
                    Irp, fdoExtension->DevicePowerState));
        fdoExtension->DevicePowerState =
            irpStack->Parameters.Power.State.DeviceState;
        goto ClasspPowerHandlerCleanup;

    }

    context = &(fdoExtension->PowerContext);

#if DBG
    //
    // Mark the context as in use.  We should be synchronizing this but
    // since it's just for debugging purposes we don't worry too much.
    //

    ASSERT(context->InUse == FALSE);
#endif

    RtlZeroMemory(context, sizeof(CLASS_POWER_CONTEXT));
    context->InUse = TRUE;

    nextIrpStack->Parameters.Scsi.Srb = &(context->Srb);
    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    context->FinalStatus = STATUS_SUCCESS;

    context->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
    context->Srb.OriginalRequest = Irp;
    context->Srb.SrbFlags |= SRB_FLAGS_BYPASS_LOCKED_QUEUE
                          |  SRB_FLAGS_NO_QUEUE_FREEZE;
    context->Srb.Function = SRB_FUNCTION_LOCK_QUEUE;

    context->Srb.SenseInfoBuffer =
        commonExtension->PartitionZeroExtension->SenseData;
    context->Srb.SenseInfoBufferLength = SENSE_BUFFER_SIZE;
    context->RetryCount = MAXIMUM_RETRIES;

    context->Options = Options;
    context->DeviceObject = DeviceObject;
    context->Irp = Irp;

    if(irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0) {

        ASSERT(Options.HandleSpinUp);

        DebugPrint((2, "(%p)\tpower up - locking queue\n", Irp));

        //
        // We need to issue a queue lock request so that we
        // can spin the drive back up after the power is restored
        // but before any requests are processed.
        //

        context->Options.PowerDown = FALSE;
        context->PowerChangeState.PowerUp = PowerUpDeviceInitial;
        context->CompletionRoutine = ClasspPowerUpCompletion;

    } else {

        ASSERT(Options.HandleSpinDown);

        fdoExtension->PowerDownInProgress = TRUE;

        DebugPrint((2, "(%p)\tPowering down - locking queue\n", Irp));

        PoSetPowerState(DeviceObject,
                        irpStack->Parameters.Power.Type,
                        irpStack->Parameters.Power.State);

        context->Options.PowerDown = TRUE;
        context->PowerChangeState.PowerDown2 = PowerDownDeviceInitial2;
        context->CompletionRoutine = ClasspPowerDownCompletion;

    }

    //
    // we are not dealing with port-allocated sense in these routines.
    //

    ASSERT(!TEST_FLAG(context->Srb.SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
    ASSERT(!TEST_FLAG(context->Srb.SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));

    //
    // we are always returning STATUS_PENDING, so we need to always
    // set the irp as pending.
    //

    IoMarkIrpPending(Irp);

    if(Options.LockQueue) {

        //
        // Send the lock irp down.
        //

        IoSetCompletionRoutine(Irp,
                               context->CompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);

        IoCallDriver(lowerDevice, Irp);

    } else {

        //
        // Call the completion routine directly.  It won't care what the
        // status of the "lock" was - it will just go and do the next
        // step of the operation.
        //

        context->CompletionRoutine(DeviceObject, Irp, context);
    }

    return STATUS_PENDING;

ClasspPowerHandlerCleanup:

    ClassReleaseRemoveLock(DeviceObject, Irp);

    DebugPrint((1, "(%p)\tStarting next power irp\n", Irp));
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp,
                           ClasspStartNextPowerIrpCompletion,
                           NULL,
                           TRUE,
                           TRUE,
                           TRUE);
    return PoCallDriver(lowerDevice, Irp);
} // end ClasspPowerHandler()

/*++////////////////////////////////////////////////////////////////////////////

ClassMinimalPowerHandler()

Routine Description:

    This routine is the minimum power handler for a storage driver.  It does
    the least amount of work possible.

--*/
NTSTATUS
ClassMinimalPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    ClassReleaseRemoveLock(DeviceObject, Irp);
    PoStartNextPowerIrp(Irp);

    switch (irpStack->MinorFunction)
    {
        case IRP_MN_SET_POWER:
        {
            switch (irpStack->Parameters.Power.ShutdownType)
            {
                case PowerActionSleep:
                case PowerActionHibernate:
                {
                    if (TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA))
                    {
                        if ((ClassGetVpb(DeviceObject) != NULL) && (ClassGetVpb(DeviceObject)->Flags & VPB_MOUNTED))
                        {
                            //
                            // This flag will cause the filesystem to verify the
                            // volume when  coming out of hibernation or standby
                            //
                            SET_FLAG(DeviceObject->Flags, DO_VERIFY_VOLUME);
                        }
                    }
                }
                break;
            }
        }

        //
        // Fall through
        //

        case IRP_MN_QUERY_POWER:
        {
            if (!commonExtension->IsFdo)
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;
            }
        }
        break;
    }

    if (commonExtension->IsFdo)
    {
        IoCopyCurrentIrpStackLocationToNext(Irp);
        status = PoCallDriver(commonExtension->LowerDeviceObject, Irp);
    }
    else
    {
        status = Irp->IoStatus.Status;
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
    }

    return status;
} // end ClassMinimalPowerHandler()

/*++////////////////////////////////////////////////////////////////////////////

ClassSpinDownPowerHandler()

Routine Description:

    This routine is a callback for disks and other things which require both
    a start and a stop to be sent to the device.  (actually the starts are
    almost always optional, since most device power themselves on to process
    commands, but i digress).

    Determines proper use of spinup, spindown, and queue locking based upon
    ScanForSpecialFlags in the FdoExtension.  This is the most common power
    handler passed into classpnp.sys

Arguments:

    DeviceObject - Supplies the functional device object

    Irp - Supplies the request to be retried.

Return Value:

    None

--*/
NTSTATUS
ClassSpinDownPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    CLASS_POWER_OPTIONS options;

    fdoExtension = (PFUNCTIONAL_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // this will set all options to FALSE
    //

    RtlZeroMemory(&options, sizeof(CLASS_POWER_OPTIONS));

    //
    // check the flags to see what options we need to worry about
    //

    if (!TEST_FLAG(fdoExtension->ScanForSpecialFlags,
                  CLASS_SPECIAL_DISABLE_SPIN_DOWN)) {
        options.HandleSpinDown = TRUE;
    }

    if (!TEST_FLAG(fdoExtension->ScanForSpecialFlags,
                  CLASS_SPECIAL_DISABLE_SPIN_UP)) {
        options.HandleSpinUp = TRUE;
    }

    if (!TEST_FLAG(fdoExtension->ScanForSpecialFlags,
                  CLASS_SPECIAL_NO_QUEUE_LOCK)) {
        options.LockQueue = TRUE;
    }

    DebugPrint((3, "ClasspPowerHandler: Devobj %p\n"
                "\t%shandling spin down\n"
                "\t%shandling spin up\n"
                "\t%slocking queue\n",
                DeviceObject,
                (options.HandleSpinDown ? "" : "not "),
                (options.HandleSpinUp   ? "" : "not "),
                (options.LockQueue      ? "" : "not ")
                ));

    //
    // do all the dirty work
    //

    return ClasspPowerHandler(DeviceObject, Irp, options);
} // end ClassSpinDownPowerHandler()

/*++////////////////////////////////////////////////////////////////////////////

ClassStopUnitPowerHandler()

Routine Description:

    This routine is an outdated call.  To achieve equivalent functionality,
    the driver should set the following flags in ScanForSpecialFlags in the
    FdoExtension:

        CLASS_SPECIAL_DISABLE_SPIN_UP
        CLASS_SPECIAL_NO_QUEUE_LOCK

--*/
NTSTATUS
ClassStopUnitPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;

    DebugPrint((0, "ClassStopUnitPowerHandler - Devobj %p using outdated call\n"
                "Drivers should set the following flags in ScanForSpecialFlags "
                " in the FDO extension:\n"
                "\tCLASS_SPECIAL_DISABLE_SPIN_UP\n"
                "\tCLASS_SPECIAL_NO_QUEUE_LOCK\n"
                "This will provide equivalent functionality if the power "
                "routine is then set to ClassSpinDownPowerHandler\n\n",
                DeviceObject));

    fdoExtension = (PFUNCTIONAL_DEVICE_EXTENSION)DeviceObject->DeviceExtension;

    SET_FLAG(fdoExtension->ScanForSpecialFlags,
             CLASS_SPECIAL_DISABLE_SPIN_UP);
    SET_FLAG(fdoExtension->ScanForSpecialFlags,
             CLASS_SPECIAL_NO_QUEUE_LOCK);

    return ClassSpinDownPowerHandler(DeviceObject, Irp);
} // end ClassStopUnitPowerHandler()

/*++////////////////////////////////////////////////////////////////////////////

RetryPowerRequest()

Routine Description:

    This routine reinitalizes the necessary fields, and sends the request
    to the lower driver.

Arguments:

    DeviceObject - Supplies the device object associated with this request.

    Irp - Supplies the request to be retried.

    Context - Supplies a pointer to the power up context for this request.

Return Value:

    None

--*/
VOID
RetryPowerRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PCLASS_POWER_CONTEXT Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = &(Context->Srb);
    LARGE_INTEGER dueTime;

    DebugPrint((1, "(%p)\tDelaying retry by queueing DPC\n", Irp));

    ASSERT(Context->Irp == Irp);
    ASSERT(Context->DeviceObject == DeviceObject);
    ASSERT(!TEST_FLAG(Context->Srb.SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
    ASSERT(!TEST_FLAG(Context->Srb.SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));

    //
    // reset the retry interval
    //

    Context->RetryInterval = 0;

    //
    // Reset byte count of transfer in SRB Extension.
    //

    srb->DataTransferLength = 0;

    //
    // Zero SRB statuses.
    //

    srb->SrbStatus = srb->ScsiStatus = 0;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = srb;

    //
    // Set the completion routine up again.
    //

    IoSetCompletionRoutine(Irp, Context->CompletionRoutine, Context,
                           TRUE, TRUE, TRUE);


    if (Context->RetryInterval == 0) {

        DebugPrint((2, "(%p)\tDelaying minimum time (.2 sec)\n", Irp));
        dueTime.QuadPart = (LONGLONG)1000000 * 2;

    } else {

        DebugPrint((2, "(%p)\tDelaying %x seconds\n",
                    Irp, Context->RetryInterval));
        dueTime.QuadPart = (LONGLONG)1000000 * 10 * Context->RetryInterval;

    }

    ClassRetryRequest(DeviceObject, Irp, dueTime);

    return;

} // end RetryRequest()

/*++////////////////////////////////////////////////////////////////////////////

ClasspStartNextPowerIrpCompletion()

Routine Description:

    This routine guarantees that the next power irp (power up or down) is not
    sent until the previous one has fully completed.

--*/
NTSTATUS
ClasspStartNextPowerIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    if(Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    PoStartNextPowerIrp(Irp);
    return STATUS_SUCCESS;
} // end ClasspStartNextPowerIrpCompletion()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\data.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    disk.c

Abstract:

    SCSI disk class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "disk.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

/*
#define HackDisableTaggedQueuing            (0x01)
#define HackDisableSynchronousTransfers     (0x02)
#define HackDisableSpinDown                 (0x04)
#define HackDisableWriteCache               (0x08)
#define HackCauseNotReportableHack          (0x10)
#define HackRequiresStartUnitCommand        (0x20)
*/

CLASSPNP_SCAN_FOR_SPECIAL_INFO DiskBadControllers[] = {
    { "COMPAQ"  , "PD-1"                           , NULL,   0x02 },
    { "CONNER"  , "CP3500"                         , NULL,   0x02 },
    { "FUJITSU" , "M2652S-512"                     , NULL,   0x01 },
    { "HP      ", "C1113F  "                       , NULL,   0x20 },
    // iomegas require START_UNIT commands so be sure to match all of them.
    { "iomega"  , "jaz"                            , NULL,   0x30 },
    { "iomega"  , NULL                             , NULL,   0x20 },
    { "IOMEGA"  , "ZIP"                            , NULL,   0x27 },
    { "IOMEGA"  , NULL                             , NULL,   0x20 },
    { "MAXTOR"  , "MXT-540SL"                      , "I1.2", 0x01 },
    { "MICROP"  , "1936-21MW1002002"               , NULL,   0x03 },
    { "OLIVETTI", "CP3500"                         , NULL,   0x02 },
    { "SEAGATE" , "ST41601N"                       , "0102", 0x02 },
    { "SEAGATE" , "ST3655N"                        , NULL,   0x08 },
    { "SEAGATE" , "ST3390N"                        , NULL,   0x08 },
    { "SEAGATE" , "ST12550N"                       , NULL,   0x08 },
    { "SEAGATE" , "ST32430N"                       , NULL,   0x08 },
    { "SEAGATE" , "ST31230N"                       , NULL,   0x08 },
    { "SEAGATE" , "ST15230N"                       , NULL,   0x08 },
    { "SyQuest" , "SQ5110"                         , "CHC",  0x03 },
    { "TOSHIBA" , "MK538FB"                        , "60",   0x01 },
    { NULL      , NULL                             , NULL,   0x0  }
};

DISK_MEDIA_TYPES_LIST const DiskMediaTypes[] = {
    { "COMPAQ"  , "PD-1 LF-1094" , NULL,  1, 1, PC_5_RW           , 0      , 0      , 0 },
    { "HP"      , NULL           , NULL,  2, 2, MO_5_WO           , MO_5_RW, 0      , 0 },
    { "iomega"  , "jaz"          , NULL,  1, 1, IOMEGA_JAZ        , 0      , 0      , 0 },
    { "IOMEGA"  , "ZIP"          , NULL,  1, 1, IOMEGA_ZIP        , 0      , 0      , 0 },
    { "PINNACLE", "Apex 4.6GB"   , NULL,  3, 2, PINNACLE_APEX_5_RW, MO_5_RW, MO_5_WO, 0 },
    { "SONY"    , "SMO-F541"     , NULL,  2, 2, MO_5_WO           , MO_5_RW, 0      , 0 },
    { "SONY"    , "SMO-F551"     , NULL,  2, 2, MO_5_WO           , MO_5_RW, 0      , 0 },
    { NULL      , NULL           , NULL,  0, 0, 0                 , 0      , 0      , 0 }
};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\obsolete.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    obsolete.c

Abstract:

    THESE ARE EXPORTED CLASSPNP FUNCTIONS (and their subroutines)
    WHICH ARE NOW OBSOLETE.
    BUT WE NEED TO KEEP THEM AROUND FOR LEGACY REASONS.

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "classp.h"
#include "debug.h"

PIRP ClassRemoveCScanList(IN PCSCAN_LIST List);
VOID ClasspInitializeCScanList(IN PCSCAN_LIST List);

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, ClassDeleteSrbLookasideList)
    #pragma alloc_text(PAGE, ClassInitializeSrbLookasideList)
#endif

typedef struct _CSCAN_LIST_ENTRY {
    LIST_ENTRY Entry;
    ULONGLONG BlockNumber;
} CSCAN_LIST_ENTRY, *PCSCAN_LIST_ENTRY;





/*
 *  ClassSplitRequest
 *
 *      This is a legacy exported function.
 *      It is called by storage miniport driver that have their own
 *      StartIo routine when the transfer size is too large for the hardware.
 *      We map it to our new read/write handler.
 */
VOID ClassSplitRequest(IN PDEVICE_OBJECT Fdo, IN PIRP Irp, IN ULONG MaximumBytes)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;

    if (MaximumBytes > fdoData->HwMaxXferLen) {
        DBGERR(("ClassSplitRequest - driver requesting split to size that "
                "hardware is unable to handle!\n"));
    }

    if (MaximumBytes < fdoData->HwMaxXferLen){
        DBGWARN(("ClassSplitRequest - driver requesting smaller HwMaxXferLen "
                 "than required"));
        fdoData->HwMaxXferLen = MAX(MaximumBytes, PAGE_SIZE);
    }

    ServiceTransferRequest(Fdo, Irp);
} 


/*++////////////////////////////////////////////////////////////////////////////

ClassIoCompleteAssociated()

Routine Description:

    This routine executes when the port driver has completed a request.
    It looks at the SRB status in the completing SRB and if not success
    it checks for valid request sense buffer information. If valid, the
    info is used to update status with more precise message of type of
    error. This routine deallocates the SRB.  This routine is used for
    requests which were build by split request.  After it has processed
    the request it decrements the Irp count in the master Irp.  If the
    count goes to zero then the master Irp is completed.

Arguments:

    Fdo - Supplies the functional device object which represents the target.

    Irp - Supplies the Irp which has completed.

    Context - Supplies a pointer to the SRB.

Return Value:

    NT status

--*/
NTSTATUS
ClassIoCompleteAssociated(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = Context;

    PIRP originalIrp = Irp->AssociatedIrp.MasterIrp;
    LONG irpCount;

    NTSTATUS status;
    BOOLEAN retry;

    DBGWARN(("ClassIoCompleteAssociated is OBSOLETE !"));

    //
    // Check SRB status for success of completing request.
    //

    if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

        ULONG retryInterval;

        DebugPrint((2,"ClassIoCompleteAssociated: IRP %p, SRB %p", Irp, srb));

        //
        // Release the queue if it is frozen.
        //

        if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            ClassReleaseQueue(Fdo);
        }

        retry = ClassInterpretSenseInfo(
                    Fdo,
                    srb,
                    irpStack->MajorFunction,
                    irpStack->MajorFunction == IRP_MJ_DEVICE_CONTROL ?
                        irpStack->Parameters.DeviceIoControl.IoControlCode :
                        0,
                    MAXIMUM_RETRIES -
                        ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4),
                    &status,
                    &retryInterval);

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (irpStack->Flags & SL_OVERRIDE_VERIFY_VOLUME &&
            status == STATUS_VERIFY_REQUIRED) {

            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry && ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4)--) {

            //
            // Retry request. If the class driver has supplied a StartIo,
            // call it directly for retries.
            //

            DebugPrint((1, "Retry request %p\n", Irp));

            if (PORT_ALLOCATED_SENSE(fdoExtension, srb)) {
                FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, srb);
            }

            RetryRequest(Fdo, Irp, srb, TRUE, retryInterval);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

    } else {

        //
        // Set status for successful request.
        //

        status = STATUS_SUCCESS;

    } // end if (SRB_STATUS(srb->SrbStatus) ...

    //
    // Return SRB to list.
    //

    if (PORT_ALLOCATED_SENSE(fdoExtension, srb)) {
        FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExtension, srb);
    }

    ClassFreeOrReuseSrb(fdoExtension, srb);

    //
    // Set status in completing IRP.
    //

    Irp->IoStatus.Status = status;

    DebugPrint((2, "ClassIoCompleteAssociated: Partial xfer IRP %p\n", Irp));

    //
    // Get next stack location. This original request is unused
    // except to keep track of the completing partial IRPs so the
    // stack location is valid.
    //

    irpStack = IoGetNextIrpStackLocation(originalIrp);

    //
    // Update status only if error so that if any partial transfer
    // completes with error, then the original IRP will return with
    // error. If any of the asynchronous partial transfer IRPs fail,
    // with an error then the original IRP will return 0 bytes transfered.
    // This is an optimization for successful transfers.
    //

    if (!NT_SUCCESS(status)) {

        originalIrp->IoStatus.Status = status;
        originalIrp->IoStatus.Information = 0;

        //
        // Set the hard error if necessary.
        //

        if (IoIsErrorUserInduced(status)) {

            //
            // Store DeviceObject for filesystem.
            //

            IoSetHardErrorOrVerifyDevice(originalIrp, Fdo);
        }
    }

    //
    // Decrement and get the count of remaining IRPs.
    //

    irpCount = InterlockedDecrement(
                    (PLONG)&irpStack->Parameters.Others.Argument1);

    DebugPrint((2, "ClassIoCompleteAssociated: Partial IRPs left %d\n",
                irpCount));

    //
    // Ensure that the irpCount doesn't go negative.  This was happening once
    // because classpnp would get confused if it ran out of resources when
    // splitting the request.
    //

    ASSERT(irpCount >= 0);

    if (irpCount == 0) {

        //
        // All partial IRPs have completed.
        //

        DebugPrint((2,
                 "ClassIoCompleteAssociated: All partial IRPs complete %p\n",
                 originalIrp));

        if (fdoExtension->CommonExtension.DriverExtension->InitData.ClassStartIo) {

            //
            // Acquire a separate copy of the remove lock so the debugging code
            // works okay and we don't have to hold up the completion of this
            // irp until after we start the next packet(s).
            //

            KIRQL oldIrql;
            UCHAR uniqueAddress;
            ClassAcquireRemoveLock(Fdo, (PIRP)&uniqueAddress);
            ClassReleaseRemoveLock(Fdo, originalIrp);
            ClassCompleteRequest(Fdo, originalIrp, IO_DISK_INCREMENT);

            KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
            IoStartNextPacket(Fdo, FALSE);
            KeLowerIrql(oldIrql);

            ClassReleaseRemoveLock(Fdo, (PIRP)&uniqueAddress);

        } else {

            //
            // just complete this request
            //

            ClassReleaseRemoveLock(Fdo, originalIrp);
            ClassCompleteRequest(Fdo, originalIrp, IO_DISK_INCREMENT);

        }

    }

    //
    // Deallocate IRP and indicate the I/O system should not attempt any more
    // processing.
    //

    IoFreeIrp(Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;

} // end ClassIoCompleteAssociated()


/*++////////////////////////////////////////////////////////////////////////////

RetryRequest()

Routine Description:

    This is a wrapper around the delayed retry DPC routine, RetryRequestDPC.
    This reinitalizes the necessary fields, queues the request, and sets
    a timer to call the DPC if someone hasn't already done so.

Arguments:

    DeviceObject - Supplies the device object associated with this request.

    Irp - Supplies the request to be retried.

    Srb - Supplies a Pointer to the SCSI request block to be retied.

    Assocaiated - Indicates this is an assocatied Irp created by split request.

    RetryInterval - How long, in seconds, before retrying the request.

Return Value:

    None

--*/
VOID
RetryRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PSCSI_REQUEST_BLOCK Srb,
    BOOLEAN Associated,
    ULONG RetryInterval
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    ULONG transferByteCount;

    // This function is obsolete but is still used by some of our class drivers.
    // DBGWARN(("RetryRequest is OBSOLETE !"));

    //
    // Determine the transfer count of the request.  If this is a read or a
    // write then the transfer count is in the Irp stack.  Otherwise assume
    // the MDL contains the correct length.  If there is no MDL then the
    // transfer length must be zero.
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ ||
        currentIrpStack->MajorFunction == IRP_MJ_WRITE) {

        transferByteCount = currentIrpStack->Parameters.Read.Length;

    } else if (Irp->MdlAddress != NULL) {

        //
        // Note this assumes that only read and write requests are spilt and
        // other request do not need to be.  If the data buffer address in
        // the MDL and the SRB don't match then transfer length is most
        // likely incorrect.
        //

        ASSERT(Srb->DataBuffer == MmGetMdlVirtualAddress(Irp->MdlAddress));
        transferByteCount = Irp->MdlAddress->ByteCount;

    } else {

        transferByteCount = 0;
    }

    //
    // this is a safety net.  this should not normally be hit, since we are
    // not guaranteed to be an fdoExtension
    //

    ASSERT(!TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));

    //
    // Reset byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = transferByteCount;

    //
    // Zero SRB statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;

    //
    // Set the no disconnect flag, disable synchronous data transfers and
    // disable tagged queuing. This fixes some errors.
    // NOTE: Cannot clear these flags, just add to them
    //

    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT);
    SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    CLEAR_FLAG(Srb->SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE);

    Srb->QueueTag = SP_UNTAGGED;

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = Srb;


    IoSetCompletionRoutine(Irp, ClassIoComplete, Srb, TRUE, TRUE, TRUE);

    {
        LARGE_INTEGER retry100ns;
        retry100ns.QuadPart = RetryInterval;  // seconds
        retry100ns.QuadPart *= (LONGLONG)1000 * 1000 * 10;

        ClassRetryRequest(DeviceObject, Irp, retry100ns);
    }
    return;
} // end RetryRequest()


/*++

ClassBuildRequest()

Routine Description:

    This routine allocates an SRB for the specified request then calls
    ClasspBuildRequestEx to create a SCSI operation to read or write the device.

    If no SRB is available then the request will be queued to be issued later
    when requests are available.  Drivers which do not want the queueing
    behavior should allocate the SRB themselves and call ClasspBuildRequestEx
    to issue it.

Arguments:

    Fdo - Supplies the functional device object associated with this request.

    Irp - Supplies the request to be retried.

Note:

    If the IRP is for a disk transfer, the byteoffset field
    will already have been adjusted to make it relative to
    the beginning of the disk.


Return Value:

    NT Status

--*/
NTSTATUS
ClassBuildRequest(
    PDEVICE_OBJECT Fdo,
    PIRP Irp
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PSCSI_REQUEST_BLOCK srb;

    // This function is obsolete, but still called by CDROM.SYS .
    // DBGWARN(("ClassBuildRequest is OBSOLETE !"));

    //
    // Allocate an Srb.
    //

    srb = ClasspAllocateSrb(fdoExtension);

    if(srb == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ClasspBuildRequestEx(fdoExtension, Irp, srb);
    return STATUS_SUCCESS;

} // end ClassBuildRequest()


VOID
ClasspBuildRequestEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PIRP Irp,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

ClasspBuildRequestEx()

Routine Description:

    This routine allocates and builds an Srb for a read or write request.
    The block address and length are supplied by the Irp. The retry count
    is stored in the current stack for use by ClassIoComplete which
    processes these requests when they complete.  The Irp is ready to be
    passed to the port driver when this routine returns.

Arguments:

    FdoExtension - Supplies the device extension associated with this request.

    Irp - Supplies the request to be issued.

    Srb - Supplies an SRB to be used for the request.

Note:

    If the IRP is for a disk transfer, the byteoffset field
    will already have been adjusted to make it relative to
    the beginning of the disk.


Return Value:

    NT Status

--*/
{
    PIO_STACK_LOCATION  currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION  nextIrpStack = IoGetNextIrpStackLocation(Irp);

    LARGE_INTEGER       startingOffset = currentIrpStack->Parameters.Read.ByteOffset;

    PCDB                cdb;
    ULONG               logicalBlockAddress;
    USHORT              transferBlocks;

    // This function is obsolete, but still called by CDROM.SYS .
    // DBGWARN(("ClasspBuildRequestEx is OBSOLETE !"));

    //
    // Prepare the SRB.
    //

    RtlZeroMemory(Srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Calculate relative sector address.
    //

    logicalBlockAddress =
        (ULONG)(Int64ShrlMod32(startingOffset.QuadPart,
                               FdoExtension->SectorShift));

    //
    // Write length to SRB.
    //

    Srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set up IRP Address.
    //

    Srb->OriginalRequest = Irp;

    //
    // Set up target ID and logical unit number.
    //

    Srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    Srb->DataBuffer = MmGetMdlVirtualAddress(Irp->MdlAddress);

    //
    // Save byte count of transfer in SRB Extension.
    //

    Srb->DataTransferLength = currentIrpStack->Parameters.Read.Length;

    //
    // Initialize the queue actions field.
    //

    Srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Queue sort key is Relative Block Address.
    //

    Srb->QueueSortKey = logicalBlockAddress;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    Srb->SenseInfoBuffer = FdoExtension->SenseData;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Set timeout value of one unit per 64k bytes of data.
    //

    Srb->TimeOutValue = ((Srb->DataTransferLength + 0xFFFF) >> 16) *
                        FdoExtension->TimeOutValue;

    //
    // Zero statuses.
    //

    Srb->SrbStatus = Srb->ScsiStatus = 0;
    Srb->NextSrb = 0;

    //
    // Indicate that 10-byte CDB's will be used.
    //

    Srb->CdbLength = 10;

    //
    // Fill in CDB fields.
    //

    cdb = (PCDB)Srb->Cdb;

    transferBlocks = (USHORT)(currentIrpStack->Parameters.Read.Length >>
                              FdoExtension->SectorShift);

    //
    // Move little endian values into CDB in big endian format.
    //

    cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&logicalBlockAddress)->Byte3;
    cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&logicalBlockAddress)->Byte2;
    cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&logicalBlockAddress)->Byte1;
    cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&logicalBlockAddress)->Byte0;

    cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&transferBlocks)->Byte1;
    cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&transferBlocks)->Byte0;

    //
    // Set transfer direction flag and Cdb command.
    //

    if (currentIrpStack->MajorFunction == IRP_MJ_READ) {

        DebugPrint((3, "ClassBuildRequest: Read Command\n"));

        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_IN);
        cdb->CDB10.OperationCode = SCSIOP_READ;

    } else {

        DebugPrint((3, "ClassBuildRequest: Write Command\n"));

        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_DATA_OUT);
        cdb->CDB10.OperationCode = SCSIOP_WRITE;
    }

    //
    // If this is not a write-through request, then allow caching.
    //

    if (!(currentIrpStack->Flags & SL_WRITE_THROUGH)) {

        SET_FLAG(Srb->SrbFlags, SRB_FLAGS_ADAPTER_CACHE_ENABLE);

    } else {

        //
        // If write caching is enable then force media access in the
        // cdb.
        //

        if (FdoExtension->DeviceFlags & DEV_WRITE_CACHE) {
            cdb->CDB10.ForceUnitAccess = TRUE;
        }
    }

    if(TEST_FLAG(Irp->Flags, (IRP_PAGING_IO | IRP_SYNCHRONOUS_PAGING_IO))) {
        SET_FLAG(Srb->SrbFlags, SRB_CLASS_FLAGS_PAGING);
    }

    //
    // OR in the default flags from the device object.
    //

    SET_FLAG(Srb->SrbFlags, FdoExtension->SrbFlags);

    //
    // Set up major SCSI function.
    //

    nextIrpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    nextIrpStack->Parameters.Scsi.Srb = Srb;

    //
    // Save retry count in current IRP stack.
    //

    currentIrpStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine(Irp, ClassIoComplete, Srb, TRUE, TRUE, TRUE);

}


VOID ClasspInsertCScanList(IN PLIST_ENTRY ListHead, IN PCSCAN_LIST_ENTRY Entry)
{
    PCSCAN_LIST_ENTRY t;

    DBGWARN(("ClasspInsertCScanList is OBSOLETE !"));

    //
    // Iterate through the list.  Insert this entry in the sorted list in 
    // order (after other requests for the same block).  At each stop if 
    // blockNumber(Entry) >= blockNumber(t) then move on.
    //

    for(t = (PCSCAN_LIST_ENTRY) ListHead->Flink; 
        t != (PCSCAN_LIST_ENTRY) ListHead; 
        t = (PCSCAN_LIST_ENTRY) t->Entry.Flink) {

        if(Entry->BlockNumber < t->BlockNumber) {

            //
            // Set the pointers in entry to the right location.
            //

            Entry->Entry.Flink = &(t->Entry);
            Entry->Entry.Blink = t->Entry.Blink;

            //
            // Set the pointers in the surrounding elements to refer to us.
            //

            t->Entry.Blink->Flink = &(Entry->Entry);
            t->Entry.Blink = &(Entry->Entry);
            return;
        }
    }

    //
    // Insert this entry at the tail of the list.  If the list was empty this 
    // will also be the head of the list.
    //

    InsertTailList(ListHead, &(Entry->Entry));

}


VOID ClassInsertCScanList(IN PCSCAN_LIST List, IN PIRP Irp, IN ULONGLONG BlockNumber, IN BOOLEAN LowPriority)
/*++

Routine Description:

    This routine inserts an entry into the CScan list based on it's block number
    and priority.  It is assumed that the caller is providing synchronization
    to the access of the list.

    Low priority requests are always scheduled to run on the next sweep across
    the disk.  Normal priority requests will be inserted into the current or 
    next sweep based on the standard C-SCAN algorithm.

Arguments:

    List - the list to insert into
    
    Irp - the irp to be inserted.
    
    BlockNumber - the block number for this request.
    
    LowPriority - indicates that the request is lower priority and should be 
                  done on the next sweep across the disk.    

Return Value:

    none
    
--*/                      
{
    PCSCAN_LIST_ENTRY entry = (PCSCAN_LIST_ENTRY)Irp->Tail.Overlay.DriverContext;

    DBGWARN(("ClassInsertCScanList is OBSOLETE !"));

    //
    // Set the block number in the entry.  We need this to keep the list sorted.
    //
    entry->BlockNumber = BlockNumber;

    //
    // If it's a normal priority request and further down the disk than our 
    // current position then insert this entry into the current sweep.
    //

    if((LowPriority != TRUE) && (BlockNumber > List->BlockNumber)) {
        ClasspInsertCScanList(&(List->CurrentSweep), entry);
    } else {
        ClasspInsertCScanList(&(List->NextSweep), entry);
    }
    return;
}




VOID ClassFreeOrReuseSrb(   IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
                            IN PSCSI_REQUEST_BLOCK Srb)
/*++

Routine Description:

    This routine will attempt to reuse the provided SRB to start a blocked 
    read/write request.  
    If there is no need to reuse the request it will be returned
    to the SRB lookaside list.

Arguments:

    Fdo - the device extension
    
    Srb - the SRB which is to be reused or freed.
    
Return Value:

    none.
    
--*/            

{
    PCLASS_PRIVATE_FDO_DATA privateData = FdoExtension->PrivateFdoData;
    PCOMMON_DEVICE_EXTENSION commonExt = &FdoExtension->CommonExtension;
    KIRQL oldIrql;
    PIRP blockedIrp;

    // This function is obsolete, but still called by DISK.SYS .
    // DBGWARN(("ClassFreeOrReuseSrb is OBSOLETE !"));

    //
    // safety net.  this should never occur.  if it does, it's a potential
    // memory leak.
    //
    ASSERT(!TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
   
    if (commonExt->IsSrbLookasideListInitialized){
        /*
         *  Put the SRB back in our lookaside list.
         *
         *  BUGBUG - Some class drivers use ClassIoComplete
         *            to complete SRBs that they themselves allocated.
         *            So we may be putting a "foreign" SRB
         *            (e.g. with a different pool tag) into our lookaside list.
         */
        ClasspFreeSrb(FdoExtension, Srb);
    }
    else {
        DBGERR(("ClassFreeOrReuseSrb: someone is trying to use an uninitialized SrbLookasideList !!!"));;
        ExFreePool(Srb);
    }
}


/*++////////////////////////////////////////////////////////////////////////////

ClassDeleteSrbLookasideList()

Routine Description:

    This routine deletes a lookaside listhead for srbs, and should be called
    only during the final removal.
    
    If called at other times, the caller is responsible for
    synchronization and removal issues.

Arguments:

    CommonExtension - Pointer to the CommonExtension containing the listhead.

Return Value:

    None

--*/
VOID ClassDeleteSrbLookasideList(IN PCOMMON_DEVICE_EXTENSION CommonExtension)
{
    PAGED_CODE();

    // This function is obsolete, but is still called by some of our code.
    // DBGWARN(("ClassDeleteSrbLookasideList is OBSOLETE !"));

    if (CommonExtension->IsSrbLookasideListInitialized){
        CommonExtension->IsSrbLookasideListInitialized = FALSE;
        ExDeleteNPagedLookasideList(&CommonExtension->SrbLookasideList);
    }
    else {
        DBGWARN(("ClassDeleteSrbLookasideList: attempt to delete uninitialized or freed srblookasidelist"));
    }
} 


/*++////////////////////////////////////////////////////////////////////////////

ClassInitializeSrbLookasideList()

Routine Description:

    This routine sets up a lookaside listhead for srbs, and should be called
    only from the ClassInitDevice() routine to prevent race conditions.
    
    If called from other locations, the caller is responsible for
    synchronization and removal issues.

Arguments:

    CommonExtension - Pointer to the CommonExtension containing the listhead.

    NumberElements  - Supplies the maximum depth of the lookaside list.

    
Note:

    The Windows 2000 version of classpnp did not return any status value from
    this call.

--*/

VOID ClassInitializeSrbLookasideList(   IN PCOMMON_DEVICE_EXTENSION CommonExtension,
                                        IN ULONG NumberElements)
{
    PAGED_CODE();

    // This function is obsolete, but still called by DISK.SYS .
    // DBGWARN(("ClassInitializeSrbLookasideList is OBSOLETE !"));

    ASSERT(!CommonExtension->IsSrbLookasideListInitialized);
    if (!CommonExtension->IsSrbLookasideListInitialized){

        ExInitializeNPagedLookasideList(&CommonExtension->SrbLookasideList,
                                        NULL,
                                        NULL,
                                        NonPagedPool,
                                        sizeof(SCSI_REQUEST_BLOCK),
                                        '$scS',
                                        (USHORT)NumberElements);

        CommonExtension->IsSrbLookasideListInitialized = TRUE;
    }
    
} 




VOID ClasspInitializeCScanList(IN PCSCAN_LIST List)
{
    PAGED_CODE();
    RtlZeroMemory(List, sizeof(CSCAN_LIST));
    InitializeListHead(&(List->CurrentSweep));
    InitializeListHead(&(List->NextSweep));
}



VOID ClasspStartNextSweep(PCSCAN_LIST List)
{
    ASSERT(IsListEmpty(&(List->CurrentSweep)) == TRUE);

    //
    // If the next sweep is empty then there's nothing to do.
    //

    if(IsListEmpty(&(List->NextSweep))) {
        return;
    }

    //
    // Copy the next sweep list head into the current sweep list head.
    //

    List->CurrentSweep = List->NextSweep;

    //
    // Unlink the next sweep list from the list head now that we have a copy 
    // of it.
    //

    InitializeListHead(&(List->NextSweep));

    //
    // Update the next sweep list to point back to the current sweep list head.
    //

    List->CurrentSweep.Flink->Blink = &(List->CurrentSweep);
    List->CurrentSweep.Blink->Flink = &(List->CurrentSweep);

    return;
}



PIRP ClassRemoveCScanList(IN PCSCAN_LIST List)
{
    PCSCAN_LIST_ENTRY entry;

    //
    // If the current sweep is empty then promote the next sweep.
    //

    if(IsListEmpty(&(List->CurrentSweep))) {
        ClasspStartNextSweep(List);
    }

    //
    // If the current sweep is still empty then we're done.
    //

    if(IsListEmpty(&(List->CurrentSweep))) {
        return NULL;
    }

    //
    // Remove the head entry from the current sweep.  Record it's block number
    // so that nothing before it on the disk gets into the current sweep.
    //

    entry = (PCSCAN_LIST_ENTRY) RemoveHeadList(&(List->CurrentSweep));

    List->BlockNumber = entry->BlockNumber;

    return CONTAINING_RECORD(entry, IRP, Tail.Overlay.DriverContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\retry.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    retry.c

Abstract:

    Packet retry routines for CLASSPNP

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "classp.h"
#include "debug.h"



/*
 *  InterpretTransferPacketError
 *
 *      Interpret the SRB error into a meaningful IRP status.
 *      ClassInterpretSenseInfo also may modify the SRB for the retry.
 *
 *      Return TRUE iff packet should be retried.
 */
BOOLEAN InterpretTransferPacketError(PTRANSFER_PACKET Pkt)
{
    BOOLEAN shouldRetry = FALSE;
    PCDB pCdb = (PCDB)Pkt->Srb.Cdb;
    
    /*
     *  Interpret the error using the returned sense info first.
     */
    Pkt->RetryIntervalSec = 0;
    if (pCdb->MEDIA_REMOVAL.OperationCode == SCSIOP_MEDIUM_REMOVAL){
        /*
         *  This is an Ejection Control SRB.  Interpret its sense info specially.
         */
        shouldRetry = ClassInterpretSenseInfo(
                            Pkt->Fdo,
                            &Pkt->Srb,
                            IRP_MJ_SCSI,
                            0,
                            MAXIMUM_RETRIES - Pkt->NumRetries,
                            &Pkt->Irp->IoStatus.Status,
                            &Pkt->RetryIntervalSec);
        if (shouldRetry){
            /*
             *  If the device is not ready, wait at least 2 seconds before retrying.
             */
            PSENSE_DATA senseInfoBuffer = Pkt->Srb.SenseInfoBuffer; 
            ASSERT(senseInfoBuffer);
            if (((Pkt->Irp->IoStatus.Status == STATUS_DEVICE_NOT_READY) &&
                (senseInfoBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY)) ||
                    (SRB_STATUS(Pkt->Srb.SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT)){
                    
                Pkt->RetryIntervalSec = MAX(Pkt->RetryIntervalSec, 2); 
            }
        }
    }
    else if ((pCdb->MODE_SENSE.OperationCode == SCSIOP_MODE_SENSE) ||
            (pCdb->MODE_SENSE.OperationCode == SCSIOP_MODE_SENSE10)){
        /*
         *  This is an Mode Sense SRB.  Interpret its sense info specially.
         */
        shouldRetry = ClassInterpretSenseInfo(
                            Pkt->Fdo,
                            &Pkt->Srb,
                            IRP_MJ_SCSI,
                            0,
                            MAXIMUM_RETRIES - Pkt->NumRetries,
                            &Pkt->Irp->IoStatus.Status,
                            &Pkt->RetryIntervalSec);
        if (shouldRetry){
            /*
             *  If the device is not ready, wait at least 2 seconds before retrying.
             */
            PSENSE_DATA senseInfoBuffer = Pkt->Srb.SenseInfoBuffer; 
            ASSERT(senseInfoBuffer);
            if (((Pkt->Irp->IoStatus.Status == STATUS_DEVICE_NOT_READY) &&
                (senseInfoBuffer->AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY)) ||
                    (SRB_STATUS(Pkt->Srb.SrbStatus) == SRB_STATUS_SELECTION_TIMEOUT)){
                    
                Pkt->RetryIntervalSec = MAX(Pkt->RetryIntervalSec, 2); 
            }
        }
        
        /*
         *  Some special cases for mode sense.
         */
        if (Pkt->Irp->IoStatus.Status == STATUS_VERIFY_REQUIRED){
            shouldRetry = TRUE;
        }
        else if (SRB_STATUS(Pkt->Srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN){
            /*
             *  This is a HACK.
             *  Atapi returns SRB_STATUS_DATA_OVERRUN when it really means 
             *  underrun (i.e. success, and the buffer is longer than needed).
             *  So treat this as a success.
             */
            Pkt->Irp->IoStatus.Status = STATUS_SUCCESS;
            InterlockedExchangeAdd((PLONG)&Pkt->OriginalIrp->IoStatus.Information, (LONG)Pkt->Srb.DataTransferLength);            
            shouldRetry = FALSE;
        }
    }            
    else if (pCdb->CDB10.OperationCode == SCSIOP_READ_CAPACITY){
        /*
         *  This is a Drive Capacity SRB.  Interpret its sense info specially.
         */
        shouldRetry = ClassInterpretSenseInfo(
                            Pkt->Fdo,
                            &Pkt->Srb,
                            IRP_MJ_SCSI,
                            0,
                            MAXIMUM_RETRIES - Pkt->NumRetries,
                            &Pkt->Irp->IoStatus.Status,
                            &Pkt->RetryIntervalSec);
        if (Pkt->Irp->IoStatus.Status == STATUS_VERIFY_REQUIRED){
            shouldRetry = TRUE;            
        }
    }
    else if ((pCdb->CDB10.OperationCode == SCSIOP_READ) ||
            (pCdb->CDB10.OperationCode == SCSIOP_WRITE)){
        /*
         *  This is a Read/Write Data packet.
         */
        PIO_STACK_LOCATION origCurrentSp = IoGetCurrentIrpStackLocation(Pkt->OriginalIrp);
        
        shouldRetry = ClassInterpretSenseInfo(
                            Pkt->Fdo,
                            &Pkt->Srb,
                            origCurrentSp->MajorFunction,
                            0,
                            MAXIMUM_RETRIES - Pkt->NumRetries,
                            &Pkt->Irp->IoStatus.Status,
                            &Pkt->RetryIntervalSec);
        /*
         *  Deal with some special cases.
         */
        if (Pkt->Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES){
            /*
             *  We are in extreme low-memory stress.  
             *  We will retry in smaller chunks.
             */
            shouldRetry = TRUE;
        }
        else if (TEST_FLAG(origCurrentSp->Flags, SL_OVERRIDE_VERIFY_VOLUME) &&
                (Pkt->Irp->IoStatus.Status == STATUS_VERIFY_REQUIRED)){
            /*
             *  We are still verifying a (possibly) reloaded disk/cdrom.
             *  So retry the request.
             */
            Pkt->Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR; 
            shouldRetry = TRUE;
        }
    }
    else {
        DBGERR(("Unhandled SRB Function %xh in error path for packet %p (did miniport change Srb.Cdb.OperationCode ?)", (ULONG)pCdb->CDB10.OperationCode, Pkt));
    }

    return shouldRetry;
}


/*
 *  RetryTransferPacket
 *
 *      Retry sending a TRANSFER_PACKET.
 *
 *      Return TRUE iff the packet is complete.
 *          (if so the status in pkt->irp is the final status).
 */
BOOLEAN RetryTransferPacket(PTRANSFER_PACKET Pkt)
{
    BOOLEAN packetDone;

    DBGTRACE(ClassDebugTrace, ("retrying failed transfer (pkt=%ph, op=%s)", Pkt, DBGGETSCSIOPSTR(&Pkt->Srb)));

    ASSERT(Pkt->NumRetries > 0);
    Pkt->NumRetries--;

    /*
     *  Tone down performance on the retry.  
     *  This increases the chance for success on the retry.
     *  We've seen instances of drives that fail consistently but then start working
     *  once this scale-down is applied.
     */
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT);
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    CLEAR_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE);
    Pkt->Srb.QueueTag = SP_UNTAGGED;

    if (Pkt->Irp->IoStatus.Status == STATUS_INSUFFICIENT_RESOURCES){
        PCDB pCdb = (PCDB)Pkt->Srb.Cdb;
        BOOLEAN isReadWrite = ((pCdb->CDB10.OperationCode == SCSIOP_READ) ||
                                                (pCdb->CDB10.OperationCode == SCSIOP_WRITE));
    
        if (Pkt->InLowMemRetry || !isReadWrite){
            /*
             *  This should never happen.
             *  The memory manager guarantees that at least four pages will
             *  be available to allow forward progress in the port driver.
             *  So a one-page transfer should never fail with insufficient resources.
             */
            ASSERT(isReadWrite && !Pkt->InLowMemRetry);
            packetDone = TRUE;
        }
        else {
            /*
             *  We are in low-memory stress.  
             *  Start the low-memory retry state machine, which tries to
             *  resend the packet in little one-page chunks.
             */
            InitLowMemRetry(  Pkt, 
                                        Pkt->BufPtrCopy, 
                                        Pkt->BufLenCopy, 
                                        Pkt->TargetLocationCopy); 
            StepLowMemRetry(Pkt);
            packetDone = FALSE;
        }
    }
    else {      
        /*
         *  Retry the packet by simply resending it after a delay.
         *  Put the packet back in the pending queue and
         *  schedule a timer to retry the transfer.
         *
         *  Do not call SetupReadWriteTransferPacket again because:
         *  (1)  The minidriver may have set some bits 
         *       in the SRB that it needs again and
         *  (2)  doing so would reset numRetries.
         *
         *  BECAUSE we do not call SetupReadWriteTransferPacket again,
         *  we have to reset a couple fields in the SRB that
         *  some miniports overwrite when they fail an SRB.
         */
         
        Pkt->Srb.DataBuffer = Pkt->BufPtrCopy;
        Pkt->Srb.DataTransferLength = Pkt->BufLenCopy;
        
        if (Pkt->RetryIntervalSec == 0){
            /*
             *  Always delay by at least a little when retrying.
             *  Some problems (e.g. CRC errors) are not recoverable without a slight delay.
             */
            LARGE_INTEGER timerPeriod;

            timerPeriod.HighPart = -1;
            timerPeriod.LowPart = -(LONG)((ULONG)MINIMUM_RETRY_UNITS*KeQueryTimeIncrement());
            KeInitializeTimer(&Pkt->RetryTimer);
            KeInitializeDpc(&Pkt->RetryTimerDPC, TransferPacketRetryTimerDpc, Pkt);
            KeSetTimer(&Pkt->RetryTimer, timerPeriod, &Pkt->RetryTimerDPC);            
        }
        else {
            LARGE_INTEGER timerPeriod;

            ASSERT(Pkt->RetryIntervalSec < 100);    // sanity check
            timerPeriod.HighPart = -1;
            timerPeriod.LowPart = Pkt->RetryIntervalSec*-10000000;
            KeInitializeTimer(&Pkt->RetryTimer);
            KeInitializeDpc(&Pkt->RetryTimerDPC, TransferPacketRetryTimerDpc, Pkt);
            KeSetTimer(&Pkt->RetryTimer, timerPeriod, &Pkt->RetryTimerDPC);
        }
        packetDone = FALSE;
    }

    return packetDone;
}


VOID TransferPacketRetryTimerDpc(   IN PKDPC Dpc,
                                    IN PVOID DeferredContext,
                                    IN PVOID SystemArgument1,
                                    IN PVOID SystemArgument2)
{
    PTRANSFER_PACKET pkt = (PTRANSFER_PACKET)DeferredContext;
    SubmitTransferPacket(pkt);
}


VOID InitLowMemRetry(PTRANSFER_PACKET Pkt, PVOID BufPtr, ULONG Len, LARGE_INTEGER TargetLocation)
{
    ASSERT(Len > 0);
    ASSERT(!Pkt->InLowMemRetry);
    Pkt->InLowMemRetry = TRUE;
    Pkt->LowMemRetry_remainingBufPtr = BufPtr;
    Pkt->LowMemRetry_remainingBufLen = Len;
    Pkt->LowMemRetry_nextChunkTargetLocation = TargetLocation;
}


/*
 *  StepLowMemRetry
 *
 *      During extreme low-memory stress, this function retries
 *      a packet in small one-page chunks, sent serially.
 *
 *      Returns TRUE iff the packet is done.
 */
BOOLEAN StepLowMemRetry(PTRANSFER_PACKET Pkt)
{
    BOOLEAN packetDone;

    if (Pkt->LowMemRetry_remainingBufLen == 0){
        packetDone = TRUE;
    }
    else {
        ULONG thisChunkLen;
        ULONG bytesToNextPageBoundary;

        /*
         *  Make sure the little chunk we send is <= a page length
         *  AND that it does not cross any page boundaries.
         */
        bytesToNextPageBoundary = PAGE_SIZE-(ULONG)((ULONG_PTR)Pkt->LowMemRetry_remainingBufPtr%PAGE_SIZE);
        thisChunkLen = MIN(Pkt->LowMemRetry_remainingBufLen, bytesToNextPageBoundary);

        /*
         *  Set up the transfer packet for the new little chunk.
         *  This will reset numRetries so that we retry each chunk as required.
         */
        SetupReadWriteTransferPacket(Pkt, 
                                Pkt->LowMemRetry_remainingBufPtr, 
                                thisChunkLen, 
                                Pkt->LowMemRetry_nextChunkTargetLocation, 
                                Pkt->OriginalIrp);
    
        Pkt->LowMemRetry_remainingBufPtr += thisChunkLen;
        Pkt->LowMemRetry_remainingBufLen -= thisChunkLen;
        Pkt->LowMemRetry_nextChunkTargetLocation.QuadPart += thisChunkLen;

        SubmitTransferPacket(Pkt);
        packetDone = FALSE;
    }

    return packetDone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\utils.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    utils.c

Abstract:

    SCSI class driver routines

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "classp.h"
#include "debug.h"



#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, ClassGetDeviceParameter)
    #pragma alloc_text(PAGE, ClassScanForSpecial)
    #pragma alloc_text(PAGE, ClassSetDeviceParameter)
#endif



// custom string match -- careful!
BOOLEAN ClasspMyStringMatches(IN PCHAR StringToMatch OPTIONAL, IN PCHAR TargetString)
{
    ULONG length;  // strlen returns an int, not size_t (!)
    PAGED_CODE();
    ASSERT(TargetString);
    // if no match requested, return TRUE
    if (StringToMatch == NULL) {
        return TRUE;
    }
    // cache the string length for efficiency
    length = strlen(StringToMatch);
    // ZERO-length strings may only match zero-length strings
    if (length == 0) {
        return (strlen(TargetString) == 0);
    }
    // strncmp returns zero if the strings match
    return (strncmp(StringToMatch, TargetString, length) == 0);
}


VOID ClassGetDeviceParameter(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PWSTR SubkeyName OPTIONAL,
    IN PWSTR ParameterName,
    IN OUT PULONG ParameterValue  // also default value
    )
{
    NTSTATUS                 status;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    HANDLE                   deviceParameterHandle;
    HANDLE                   deviceSubkeyHandle;
    ULONG                    defaultParameterValue;

    PAGED_CODE();

    //
    // open the given parameter
    //

    status = IoOpenDeviceRegistryKey(FdoExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ,
                                     &deviceParameterHandle);

    if (NT_SUCCESS(status) && (SubkeyName != NULL)) {

        UNICODE_STRING subkeyName;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&subkeyName, SubkeyName);
        InitializeObjectAttributes(&objectAttributes,
                                   &subkeyName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   deviceParameterHandle,
                                   NULL);

        status = ZwOpenKey(&deviceSubkeyHandle,
                           KEY_READ,
                           &objectAttributes);
        if (!NT_SUCCESS(status)) {
            ZwClose(deviceParameterHandle);
        }

    }

    if (NT_SUCCESS(status)) {

        RtlZeroMemory(queryTable, sizeof(queryTable));

        defaultParameterValue = *ParameterValue;

        queryTable->Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        queryTable->Name          = ParameterName;
        queryTable->EntryContext  = ParameterValue;
        queryTable->DefaultType   = REG_DWORD;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR)(SubkeyName ?
                                                deviceSubkeyHandle :
                                                deviceParameterHandle),
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {
            *ParameterValue = defaultParameterValue; // use default value
        }

        //
        // close what we open
        //

        if (SubkeyName) {
            ZwClose(deviceSubkeyHandle);
        }

        ZwClose(deviceParameterHandle);
    }

    return;

} // end ClassGetDeviceParameter()


NTSTATUS ClassSetDeviceParameter(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PWSTR SubkeyName OPTIONAL,
    IN PWSTR ParameterName,
    IN ULONG ParameterValue)
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    HANDLE                   deviceSubkeyHandle;

    PAGED_CODE();

    //
    // open the given parameter
    //

    status = IoOpenDeviceRegistryKey(FdoExtension->LowerPdo,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     KEY_READ | KEY_WRITE,
                                     &deviceParameterHandle);

    if (NT_SUCCESS(status) && (SubkeyName != NULL)) {

        UNICODE_STRING subkeyName;
        OBJECT_ATTRIBUTES objectAttributes;

        RtlInitUnicodeString(&subkeyName, SubkeyName);
        InitializeObjectAttributes(&objectAttributes,
                                   &subkeyName,
                                   OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                   deviceParameterHandle,
                                   NULL);

        status = ZwCreateKey(&deviceSubkeyHandle,
                             KEY_READ | KEY_WRITE,
                             &objectAttributes,
                             0, NULL, 0, NULL);
        if (!NT_SUCCESS(status)) {
            ZwClose(deviceParameterHandle);
        }

    }

    if (NT_SUCCESS(status)) {

        status = RtlWriteRegistryValue(
            RTL_REGISTRY_HANDLE,
            (PWSTR) (SubkeyName ?
                     deviceSubkeyHandle :
                     deviceParameterHandle),
            ParameterName,
            REG_DWORD,
            &ParameterValue,
            sizeof(ULONG));

        //
        // close what we open
        //

        if (SubkeyName) {
            ZwClose(deviceSubkeyHandle);
        }

        ZwClose(deviceParameterHandle);
    }

    return status;

} // end ClassSetDeviceParameter()


/*
 *  ClassScanForSpecial
 *
 *      This routine was written to simplify scanning for special
 *      hardware based upon id strings.  it does not check the registry.
 */

VOID ClassScanForSpecial(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN CLASSPNP_SCAN_FOR_SPECIAL_INFO DeviceList[],
    IN PCLASS_SCAN_FOR_SPECIAL_HANDLER Function)
{
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor;
    PUCHAR vendorId;
    PUCHAR productId;
    PUCHAR productRevision;
    UCHAR nullString[] = "";
    ULONG j;

    PAGED_CODE();
    ASSERT(DeviceList);
    ASSERT(Function);

    deviceDescriptor = FdoExtension->DeviceDescriptor;

    if (DeviceList == NULL) {
        return;
    }
    if (Function == NULL) {
        return;
    }

    //
    // SCSI sets offsets to -1, ATAPI sets to 0.  check for both.
    //

    if (deviceDescriptor->VendorIdOffset != 0 &&
        deviceDescriptor->VendorIdOffset != -1) {
        vendorId = ((PUCHAR)deviceDescriptor);
        vendorId += deviceDescriptor->VendorIdOffset;
    } else {
        vendorId = nullString;
    }
    if (deviceDescriptor->ProductIdOffset != 0 &&
        deviceDescriptor->ProductIdOffset != -1) {
        productId = ((PUCHAR)deviceDescriptor);
        productId += deviceDescriptor->ProductIdOffset;
    } else {
        productId = nullString;
    }
    if (deviceDescriptor->VendorIdOffset != 0 &&
        deviceDescriptor->VendorIdOffset != -1) {
        productRevision = ((PUCHAR)deviceDescriptor);
        productRevision += deviceDescriptor->ProductRevisionOffset;
    } else {
        productRevision = nullString;
    }

    //
    // loop while the device list is valid (not null-filled)
    //

    for (;(DeviceList->VendorId        != NULL ||
           DeviceList->ProductId       != NULL ||
           DeviceList->ProductRevision != NULL);DeviceList++) {

        if (ClasspMyStringMatches(DeviceList->VendorId,        vendorId) &&
            ClasspMyStringMatches(DeviceList->ProductId,       productId) &&
            ClasspMyStringMatches(DeviceList->ProductRevision, productRevision)
            ) {

            DebugPrint((1, "ClasspScanForSpecialByInquiry: Found matching "
                        "controller Ven: %s Prod: %s Rev: %s\n",
                        vendorId, productId, productRevision));

            //
            // pass the context to the call back routine and exit
            //

            (Function)(FdoExtension, DeviceList->Data);

            //
            // for CHK builds, try to prevent wierd stacks by having a debug
            // print here. it's a hack, but i know of no other way to prevent
            // the stack from being wrong.
            //

            DebugPrint((16, "ClasspScanForSpecialByInquiry: "
                        "completed callback\n"));
            return;

        } // else the strings did not match

    } // none of the devices matched.

    DebugPrint((1, "ClasspScanForSpecialByInquiry: no match found for %p\n",
                FdoExtension->DeviceObject));
    return;

} // end ClasspScanForSpecialByInquiry()


//
// In order to provide better performance without the need to reboot,
// we need to implement a self-adjusting method to set and clear the
// srb flags based upon current performance.
//
// whenever there is an error, immediately grab the spin lock.  the
// MP perf hit here is acceptable, since we're in an error path.  this
// is also neccessary because we are guaranteed to be modifying the
// SRB flags here, setting SuccessfulIO to zero, and incrementing the
// actual error count (which is always done within this spinlock).
//
// whenever there is no error, increment a counter.  if there have been
// errors on the device, and we've enabled dynamic perf, *and* we've
// just crossed the perf threshhold, then grab the spin lock and
// double check that the threshhold has, indeed been hit(*). then
// decrement the error count, and if it's dropped sufficiently, undo
// some of the safety changes made in the SRB flags due to the errors.
//
// * this works in all cases.  even if lots of ios occur after the
//   previous guy went in and cleared the successfulio counter, that
//   just means that we've hit the threshhold again, and so it's proper
//   to run the inner loop again.
//

VOID
ClasspPerfIncrementErrorCount(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PCLASS_PRIVATE_FDO_DATA fdoData = FdoExtension->PrivateFdoData;
    KIRQL oldIrql;
    ULONG errors;

    KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);

    fdoData->Perf.SuccessfulIO = 0; // implicit interlock
    errors = InterlockedIncrement(&FdoExtension->ErrorCount);

    if (errors >= CLASS_ERROR_LEVEL_1) {

        //
        // If the error count has exceeded the error limit, then disable
        // any tagged queuing, multiple requests per lu queueing
        // and sychronous data transfers.
        //
        // Clearing the no queue freeze flag prevents the port driver
        // from sending multiple requests per logical unit.
        //

        CLEAR_FLAG(FdoExtension->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);
        CLEAR_FLAG(FdoExtension->SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE);

        SET_FLAG(FdoExtension->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

        DebugPrint((ClassDebugError, "ClasspPerfIncrementErrorCount: "
                    "Too many errors; disabling tagged queuing and "
                    "synchronous data tranfers.\n"));

    }

    if (errors >= CLASS_ERROR_LEVEL_2) {

        //
        // If a second threshold is reached, disable disconnects.
        //

        SET_FLAG(FdoExtension->SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT);
        DebugPrint((ClassDebugError, "ClasspPerfIncrementErrorCount: "
                    "Too many errors; disabling disconnects.\n"));
    }

    KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);
    return;
}

VOID
ClasspPerfIncrementSuccessfulIo(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PCLASS_PRIVATE_FDO_DATA fdoData = FdoExtension->PrivateFdoData;
    KIRQL oldIrql;
    ULONG errors;
    ULONG succeeded = 0;

    //
    // don't take a hit from the interlocked op unless we're in
    // a degraded state and we've got a threshold to hit.
    //

    if (FdoExtension->ErrorCount == 0) {
        return;
    }

    if (fdoData->Perf.ReEnableThreshhold == 0) {
        return;
    }

    succeeded = InterlockedIncrement(&fdoData->Perf.SuccessfulIO);
    if (succeeded < fdoData->Perf.ReEnableThreshhold) {
        return;
    }

    //
    // if we hit the threshold, grab the spinlock and verify we've
    // actually done so.  this allows us to ignore the spinlock 99%
    // of the time.
    //

    KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);

    //
    // re-read the value, so we don't run this multiple times
    // for a single threshhold being hit.  this keeps errorcount
    // somewhat useful.
    //

    succeeded = fdoData->Perf.SuccessfulIO;

    if ((FdoExtension->ErrorCount != 0) &&
        (fdoData->Perf.ReEnableThreshhold <= succeeded)
        ) {

        fdoData->Perf.SuccessfulIO = 0; // implicit interlock

        ASSERT(FdoExtension->ErrorCount > 0);
        errors = InterlockedDecrement(&FdoExtension->ErrorCount);

        //
        // note: do in reverse order of the sets "just in case"
        //

        if (errors < CLASS_ERROR_LEVEL_2) {
            if (errors == CLASS_ERROR_LEVEL_2 - 1) {
                DebugPrint((ClassDebugError, "ClasspPerfIncrementSuccessfulIo: "
                            "Error level 2 no longer required.\n"));
            }
            if (!TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                           SRB_FLAGS_DISABLE_DISCONNECT)) {
                CLEAR_FLAG(FdoExtension->SrbFlags,
                           SRB_FLAGS_DISABLE_DISCONNECT);
            }
        }

        if (errors < CLASS_ERROR_LEVEL_1) {
            if (errors == CLASS_ERROR_LEVEL_1 - 1) {
                DebugPrint((ClassDebugError, "ClasspPerfIncrementSuccessfulIo: "
                            "Error level 1 no longer required.\n"));
            }
            if (!TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                           SRB_FLAGS_DISABLE_SYNCH_TRANSFER)) {
                CLEAR_FLAG(FdoExtension->SrbFlags,
                           SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            }
            if (TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                          SRB_FLAGS_QUEUE_ACTION_ENABLE)) {
                SET_FLAG(FdoExtension->SrbFlags,
                         SRB_FLAGS_QUEUE_ACTION_ENABLE);
            }
            if (TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                          SRB_FLAGS_NO_QUEUE_FREEZE)) {
                SET_FLAG(FdoExtension->SrbFlags,
                         SRB_FLAGS_NO_QUEUE_FREEZE);
            }
        }
    } // end of threshhold definitely being hit for first time

    KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);
    return;
}


PMDL BuildDeviceInputMdl(PVOID Buffer, ULONG BufferLen)
{
    PMDL mdl;

    mdl = IoAllocateMdl(Buffer, BufferLen, FALSE, FALSE, NULL);
    if (mdl){
        try {
            /*
             *  We are reading from the device.
             *  Therefore, the device is WRITING to the locked memory.
             *  So we request IoWriteAccess.
             */
            MmProbeAndLockPages(mdl, KernelMode, IoWriteAccess);

        } except(EXCEPTION_EXECUTE_HANDLER) {
            NTSTATUS status = GetExceptionCode();

            DBGWARN(("BuildReadMdl: MmProbeAndLockPages failed with %xh.", status));
            IoFreeMdl(mdl);
            mdl = NULL;
        }
    }
    else {
        DBGWARN(("BuildReadMdl: IoAllocateMdl failed"));
    }

    return mdl;
}


VOID FreeDeviceInputMdl(PMDL Mdl)
{
    MmUnlockPages(Mdl);
    IoFreeMdl(Mdl);
}


#if 0
    VOID
    ClasspPerfResetCounters(
        IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
        )
    {
        PCLASS_PRIVATE_FDO_DATA fdoData = FdoExtension->PrivateFdoData;
        KIRQL oldIrql;

        KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);
        DebugPrint((ClassDebugError, "ClasspPerfResetCounters: "
                    "Resetting all perf counters.\n"));
        fdoData->Perf.SuccessfulIO = 0;
        FdoExtension->ErrorCount = 0;

        if (!TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                       SRB_FLAGS_DISABLE_DISCONNECT)) {
            CLEAR_FLAG(FdoExtension->SrbFlags,
                       SRB_FLAGS_DISABLE_DISCONNECT);
        }
        if (!TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                       SRB_FLAGS_DISABLE_SYNCH_TRANSFER)) {
            CLEAR_FLAG(FdoExtension->SrbFlags,
                       SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
        }
        if (TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                      SRB_FLAGS_QUEUE_ACTION_ENABLE)) {
            SET_FLAG(FdoExtension->SrbFlags,
                     SRB_FLAGS_QUEUE_ACTION_ENABLE);
        }
        if (TEST_FLAG(fdoData->Perf.OriginalSrbFlags,
                      SRB_FLAGS_NO_QUEUE_FREEZE)) {
            SET_FLAG(FdoExtension->SrbFlags,
                     SRB_FLAGS_NO_QUEUE_FREEZE);
        }
        KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);
        return;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\dictlib.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    dictlib.c

Abstract:

    Support library for maintaining a dictionary list (list of objects
    referenced by a key value).

Environment:

    kernel mode only

Notes:

    This module generates a static library

Revision History:

--*/

#include <ntddk.h>
#include <classpnp.h>

#define DICTIONARY_SIGNATURE (((ULONG)'dict' << 32) + 'sig ')

struct _DICTIONARY_HEADER {
    PDICTIONARY_HEADER Next;
    ULONGLONG Key;
    UCHAR Data[0];
};

struct _DICTIONARY_HEADER;
typedef struct _DICTIONARY_HEADER DICTIONARY_HEADER, *PDICTIONARY_HEADER;


VOID
InitializeDictionary(
    IN PDICTIONARY Dictionary
    )
{
    RtlZeroMemory(Dictionary, sizeof(Dictionary));
    Dictionary->Signature = DICTIONARY_SIGNATURE;
    KeInitializeSpinLock(&Dictionary->SpinLock);
    return;
}


BOOLEAN
TestDictionarySignature(
    IN PDICTIONARY Dictionary
    )
{
    return Dictionary->Signature == DICTIONARY_SIGNATURE;
}

NTSTATUS
AllocateDictionaryEntry(
    IN PDICTIONARY Dictionary,
    IN ULONGLONG Key,
    IN ULONG Size,
    IN ULONG Tag,
    OUT PVOID *Entry
    )
{
    PDICTIONARY_HEADER header;
    KIRQL oldIrql;
    PDICTIONARY_HEADER *entry;

    NTSTATUS status = STATUS_SUCCESS;

    *Entry = NULL;

    header = ExAllocatePoolWithTag(NonPagedPool,
                                   Size + sizeof(DICTIONARY_HEADER),
                                   Tag);

    if(header == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(header, sizeof(DICTIONARY_HEADER) + Size);
    header->Key = Key;

    //
    // Find the correct location for this entry in the dictionary.
    //

    KeAcquireSpinLock(&(Dictionary->SpinLock), &oldIrql);

    TRY {

        entry = &(Dictionary->List);

        while(*entry != NULL) {
            if((*entry)->Key == Key) {

                //
                // Dictionary must have unique keys.
                //

                status = STATUS_OBJECT_NAME_COLLISION;
                LEAVE;

            } else if ((*entry)->Key < Key) {

                //
                // We will go ahead and insert the key in here.
                //
                break;
            } else {
                entry = &((*entry)->Next);
            }
        }

        //
        // If we make it here then we will go ahead and do the insertion.
        //

        header->Next = *entry;
        *entry = header;

    } FINALLY {
        KeReleaseSpinLock(&(Dictionary->SpinLock), oldIrql);

        if(!NT_SUCCESS(status)) {
            ExFreePool(header);
        } else {
            *Entry = (PVOID) header->Data;
        }
    }
    return status;
}


PVOID
GetDictionaryEntry(
    IN PDICTIONARY Dictionary,
    IN ULONGLONG Key
    )
{
    PDICTIONARY_HEADER entry;
    PVOID data;
    KIRQL oldIrql;


    data = NULL;

    KeAcquireSpinLock(&(Dictionary->SpinLock), &oldIrql);

    entry = Dictionary->List;
    while (entry != NULL) {
        
        if (entry->Key == Key) {
            data = entry->Data;
            break;
        } else {
            entry = entry->Next;
        }
    }

    KeReleaseSpinLock(&(Dictionary->SpinLock), oldIrql);

    return data;
}


VOID
FreeDictionaryEntry(
    IN PDICTIONARY Dictionary,
    IN PVOID Entry
    )
{
    PDICTIONARY_HEADER header;
    PDICTIONARY_HEADER *entry;
    KIRQL oldIrql;
    BOOLEAN found;

    found = FALSE;
    header = CONTAINING_RECORD(Entry, DICTIONARY_HEADER, Data);

    KeAcquireSpinLock(&(Dictionary->SpinLock), &oldIrql);

    entry = &(Dictionary->List);
    while(*entry != NULL) {

        if(*entry == header) {
            *entry = header->Next;
            found = TRUE;
            break;
        } else {
            entry = &(*entry)->Next;
        }
    }

    KeReleaseSpinLock(&(Dictionary->SpinLock), oldIrql);

    //
    // calling this w/an invalid pointer invalidates the dictionary system,
    // so ASSERT() that we never try to Free something not in the list
    //

    ASSERT(found);
    if (found) {
        ExFreePool(header);
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\lock.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1998

Module Name:

    lock.c

Abstract:

    This is the NT SCSI port driver.

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "classp.h"
#include "debug.h"


LONG LockHighWatermark = 0;
LONG LockLowWatermark = 0;
LONG MaxLockedMinutes = 5;

//
// Structure used for tracking remove lock allocations in checked builds
//
typedef struct _REMOVE_TRACKING_BLOCK {
    struct _REMOVE_TRACKING_BLOCK *NextBlock;
    PVOID Tag;
    LARGE_INTEGER TimeLocked;
    PCSTR File;
    ULONG Line;
} REMOVE_TRACKING_BLOCK, *PREMOVE_TRACKING_BLOCK;


/*++////////////////////////////////////////////////////////////////////////////

ClassAcquireRemoveLockEx()

Routine Description:

    This routine is called to acquire the remove lock on the device object.
    While the lock is held, the caller can assume that no pending pnp REMOVE
    requests will be completed.

    The lock should be acquired immediately upon entering a dispatch routine.
    It should also be acquired before creating any new reference to the
    device object if there's a chance of releasing the reference before the
    new one is done.

    This routine will return TRUE if the lock was successfully acquired or
    FALSE if it cannot be because the device object has already been removed.

Arguments:

    DeviceObject - the device object to lock

    Tag - Used for tracking lock allocation and release.  If an irp is
          specified when acquiring the lock then the same Tag must be
          used to release the lock before the Tag is completed.

Return Value:

    The value of the IsRemoved flag in the device extension.  If this is
    non-zero then the device object has received a Remove irp and non-cleanup
    IRP's should fail.

    If the value is REMOVE_COMPLETE, the caller should not even release the
    lock.

--*/
ULONG
ClassAcquireRemoveLockEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag,
    IN PCSTR File,
    IN ULONG Line
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;



    //
    // Grab the remove lock
    //
    lockValue = InterlockedIncrement(&commonExtension->RemoveLock);

    #if DBG

        DebugPrint((ClassDebugRemoveLock, "ClassAcquireRemoveLock: "
                    "Acquired for Object %p & irp %p - count is %d\n",
                    DeviceObject, Tag, lockValue));

        ASSERTMSG("ClassAcquireRemoveLock - lock value was negative : ",
                  (lockValue > 0));

        ASSERTMSG("RemoveLock increased to meet LockHighWatermark",
                  ((LockHighWatermark == 0) ||
                   (lockValue != LockHighWatermark)));

        if (commonExtension->IsRemoved != REMOVE_COMPLETE){
            PREMOVE_TRACKING_BLOCK trackingBlock;

            trackingBlock = ExAllocatePool(NonPagedPool,
                                           sizeof(REMOVE_TRACKING_BLOCK));

            if(trackingBlock == NULL) {

                KIRQL oldIrql;

                KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                                  &oldIrql);

                commonExtension->RemoveTrackingUntrackedCount++;
            
                DebugPrint((ClassDebugWarning, ">>>>>ClassAcquireRemoveLock: "
                            "Cannot track Tag %p - currently %d untracked requsts\n",
                            Tag, commonExtension->RemoveTrackingUntrackedCount));

                KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock,
                                  oldIrql);
            } 
            else {
                PREMOVE_TRACKING_BLOCK *removeTrackingList =
                    &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

                KIRQL oldIrql;

                trackingBlock->Tag = Tag;

                trackingBlock->File = File;
                trackingBlock->Line = Line;

                KeQueryTickCount((&trackingBlock->TimeLocked));

                KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                                  &oldIrql);

                while(*removeTrackingList != NULL) {

                    if((*removeTrackingList)->Tag > Tag) {
                        break;
                    }

                    if((*removeTrackingList)->Tag == Tag) {

                        DebugPrint((ClassDebugError, ">>>>>ClassAcquireRemoveLock: "
                                    "already tracking Tag %p\n", Tag));
                        DebugPrint((ClassDebugError, ">>>>>ClassAcquireRemoveLock: "
                                    "acquired in file %s on line %d\n",
                                    (*removeTrackingList)->File,
                                    (*removeTrackingList)->Line));
                        ASSERT(FALSE);
                    }

                    removeTrackingList = &((*removeTrackingList)->NextBlock);
                }

                trackingBlock->NextBlock = *removeTrackingList;
                *removeTrackingList = trackingBlock;

                KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock,
                                  oldIrql);

            }
        }

    #endif

    return (commonExtension->IsRemoved);
}

/*++////////////////////////////////////////////////////////////////////////////

ClassReleaseRemoveLock()

Routine Description:

    This routine is called to release the remove lock on the device object.  It
    must be called when finished using a previously locked reference to the
    device object.  If an Tag was specified when acquiring the lock then the
    same Tag must be specified when releasing the lock.

    When the lock count reduces to zero, this routine will signal the waiting
    remove Tag to delete the device object.  As a result the DeviceObject
    pointer should not be used again once the lock has been released.

Arguments:

    DeviceObject - the device object to lock

    Tag - The irp (if any) specified when acquiring the lock.  This is used
          for lock tracking purposes

Return Value:

    none

--*/
VOID
ClassReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PIRP Tag
    )
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    LONG lockValue;

    #if DBG
        PREMOVE_TRACKING_BLOCK *listEntry =
            &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

        BOOLEAN found = FALSE;

        LONGLONG maxCount;

        BOOLEAN isRemoved = (commonExtension->IsRemoved == REMOVE_COMPLETE);

        KIRQL oldIrql;

        if(isRemoved) {
            DBGTRAP(("ClassReleaseRemoveLock: REMOVE_COMPLETE set; this should never happen"));
            InterlockedDecrement(&(commonExtension->RemoveLock));
            return;
        }

        //
        // Check the tick count and make sure this thing hasn't been locked
        // for more than MaxLockedMinutes.
        //

        maxCount = KeQueryTimeIncrement() * 10;     // microseconds
        maxCount *= 1000;                           // milliseconds
        maxCount *= 1000;                           // seconds
        maxCount *= 60;                             // minutes
        maxCount *= MaxLockedMinutes;

        DebugPrint((ClassDebugRemoveLock, "ClassReleaseRemoveLock: "
                    "maxCount = %0I64x\n", maxCount));

        KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                          &oldIrql);

        while(*listEntry != NULL) {

            PREMOVE_TRACKING_BLOCK block;
            LARGE_INTEGER difference;

            block = *listEntry;

            KeQueryTickCount((&difference));

            difference.QuadPart -= block->TimeLocked.QuadPart;

            DebugPrint((ClassDebugRemoveLock, "ClassReleaseRemoveLock: "
                        "Object %p (tag %p) locked for %I64d ticks\n",
                        DeviceObject, block->Tag, difference.QuadPart));

            if(difference.QuadPart >= maxCount) {

                DebugPrint((ClassDebugError, ">>>>>ClassReleaseRemoveLock: "
                            "Object %p (tag %p) locked for %I64d ticks - TOO LONG\n",
                            DeviceObject, block->Tag, difference.QuadPart));
                DebugPrint((ClassDebugError, ">>>>>ClassReleaseRemoveLock: "
                            "Lock acquired in file %s on line %d\n",
                            block->File, block->Line));
                ASSERT(FALSE);
            }

            if((found == FALSE) && ((*listEntry)->Tag == Tag)) {

                *listEntry = block->NextBlock;
                ExFreePool(block);
                found = TRUE;

            } else {

                listEntry = &((*listEntry)->NextBlock);

            }
        }

        if(!found) {
            if(commonExtension->RemoveTrackingUntrackedCount == 0) {
                DebugPrint((ClassDebugError, ">>>>>ClassReleaseRemoveLock: "
                            "Couldn't find Tag %p in the lock tracking list\n",
                            Tag));
                ASSERT(FALSE);
            } else {
                DebugPrint((ClassDebugError, ">>>>>ClassReleaseRemoveLock: "
                            "Couldn't find Tag %p in the lock tracking list - "
                            "may be one of the %d untracked requests still "
                            "outstanding\n",
                            Tag,
                            commonExtension->RemoveTrackingUntrackedCount));

                commonExtension->RemoveTrackingUntrackedCount--;
                ASSERT(commonExtension->RemoveTrackingUntrackedCount >= 0);
            }
        }

        KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock,
                          oldIrql);

    #endif

    lockValue = InterlockedDecrement(&commonExtension->RemoveLock);

    DebugPrint((ClassDebugRemoveLock, "ClassReleaseRemoveLock: "
                "Released for Object %p & irp %p - count is %d\n",
                DeviceObject, Tag, lockValue));

    ASSERT(lockValue >= 0);

    ASSERTMSG("RemoveLock decreased to meet LockLowWatermark",
              ((LockLowWatermark == 0) || !(lockValue == LockLowWatermark)));

    if(lockValue == 0) {

        ASSERT(commonExtension->IsRemoved);

        //
        // The device needs to be removed.  Signal the remove event
        // that it's safe to go ahead.
        //

        DebugPrint((ClassDebugRemoveLock, "ClassReleaseRemoveLock: "
                    "Release for object %p & irp %p caused lock to go to zero\n",
                    DeviceObject, Tag));

        KeSetEvent(&commonExtension->RemoveEvent,
                   IO_NO_INCREMENT,
                   FALSE);

    }
    return;
}

/*++////////////////////////////////////////////////////////////////////////////

ClassCompleteRequest()

Routine Description:

    This routine is a wrapper around (and should be used instead of)
    IoCompleteRequest.  It is used primarily for debugging purposes.
    The routine will assert if the Irp being completed is still holding
    the release lock.

Arguments:

    DeviceObject - the device object that was handling this request
    
    Irp - the irp to be completed by IoCompleteRequest
    
    PriorityBoost - the priority boost to pass to IoCompleteRequest

Return Value:

    none

--*/
VOID
ClassCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )
{

    #if DBG
        PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
        PREMOVE_TRACKING_BLOCK *listEntry =
            &((PREMOVE_TRACKING_BLOCK) commonExtension->RemoveTrackingList);

        KIRQL oldIrql;

        KeAcquireSpinLock(&commonExtension->RemoveTrackingSpinlock,
                          &oldIrql);

        while(*listEntry != NULL) {

            if((*listEntry)->Tag == Irp) {
                break;
            }

            listEntry = &((*listEntry)->NextBlock);
        }

        if(*listEntry != NULL) {

            DebugPrint((ClassDebugError, ">>>>>ClassCompleteRequest: "
                        "Irp %p completed while still holding the remove lock\n",
                        Irp));
            DebugPrint((ClassDebugError, ">>>>>ClassCompleteRequest: "
                        "Lock acquired in file %s on line %d\n",
                        (*listEntry)->File, (*listEntry)->Line));
            ASSERT(FALSE);
        }

        KeReleaseSpinLock(&commonExtension->RemoveTrackingSpinlock, oldIrql);
    #endif

    IoCompleteRequest(Irp, PriorityBoost);
    return;
} // end ClassCompleteRequest()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\classpnp\xferpkt.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    xferpkt.c

Abstract:

    Packet routines for CLASSPNP

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "classp.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, InitializeTransferPackets)
    #pragma alloc_text(PAGE, DestroyAllTransferPackets)
    #pragma alloc_text(PAGE, SetupEjectionTransferPacket)
    #pragma alloc_text(PAGE, SetupModeSenseTransferPacket)
#endif


ULONG MinWorkingSetTransferPackets = MIN_WORKINGSET_TRANSFER_PACKETS_Consumer;
ULONG MaxWorkingSetTransferPackets = MAX_WORKINGSET_TRANSFER_PACKETS_Consumer;


/*
 *  InitializeTransferPackets
 *
 *      Allocate/initialize TRANSFER_PACKETs and related resources.
 */
NTSTATUS InitializeTransferPackets(PDEVICE_OBJECT Fdo)
{
    PCOMMON_DEVICE_EXTENSION commonExt = Fdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PSTORAGE_ADAPTER_DESCRIPTOR adapterDesc = commonExt->PartitionZeroExtension->AdapterDescriptor;
    ULONG hwMaxPages;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();
    
    /*
     *  Precompute the maximum transfer length
     */
    ASSERT(adapterDesc->MaximumTransferLength);
    ASSERT(adapterDesc->MaximumPhysicalPages);
    hwMaxPages = adapterDesc->MaximumPhysicalPages ? adapterDesc->MaximumPhysicalPages-1 : 0;

#if defined(_AMD64_SIMULATOR_)

    //
    // The simulator appears to have a problem with large transfers.
    //

    if (hwMaxPages > 4) {
        hwMaxPages = 4;
    }

#endif

    fdoData->HwMaxXferLen = MIN(adapterDesc->MaximumTransferLength, hwMaxPages << PAGE_SHIFT);
    fdoData->HwMaxXferLen = MAX(fdoData->HwMaxXferLen, PAGE_SIZE);

    fdoData->NumTotalTransferPackets = 0;
    fdoData->NumFreeTransferPackets = 0;
    InitializeSListHead(&fdoData->FreeTransferPacketsList);
    InitializeListHead(&fdoData->AllTransferPacketsList);
    InitializeListHead(&fdoData->DeferredClientIrpList);
        
    /*
     *  Set the packet threshold numbers based on the Windows SKU.
     */
    if (ExVerifySuite(Personal)){
        // this is Windows Personal
        MinWorkingSetTransferPackets = MIN_WORKINGSET_TRANSFER_PACKETS_Consumer;
        MaxWorkingSetTransferPackets = MAX_WORKINGSET_TRANSFER_PACKETS_Consumer;
    }
    else if (ExVerifySuite(Enterprise) || ExVerifySuite(DataCenter)){
        // this is Advanced Server or Datacenter
        MinWorkingSetTransferPackets = MIN_WORKINGSET_TRANSFER_PACKETS_Enterprise;
        MaxWorkingSetTransferPackets = MAX_WORKINGSET_TRANSFER_PACKETS_Enterprise;
    }
    else if (ExVerifySuite(TerminalServer)){
        // this is standard Server or Pro with terminal server
        MinWorkingSetTransferPackets = MIN_WORKINGSET_TRANSFER_PACKETS_Server;
        MaxWorkingSetTransferPackets = MAX_WORKINGSET_TRANSFER_PACKETS_Server;
    }
    else {
        // this is Professional without terminal server
        MinWorkingSetTransferPackets = MIN_WORKINGSET_TRANSFER_PACKETS_Consumer;
        MaxWorkingSetTransferPackets = MAX_WORKINGSET_TRANSFER_PACKETS_Consumer;
    }

    while (fdoData->NumFreeTransferPackets < MIN_INITIAL_TRANSFER_PACKETS){
        PTRANSFER_PACKET pkt = NewTransferPacket(Fdo);
        if (pkt){
            InterlockedIncrement(&fdoData->NumTotalTransferPackets);
            EnqueueFreeTransferPacket(Fdo, pkt);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }
    fdoData->DbgPeakNumTransferPackets = fdoData->NumTotalTransferPackets;
    
    /*
     *  Pre-initialize our SCSI_REQUEST_BLOCK template with all
     *  the constant fields.  This will save a little time for each xfer.
     *  NOTE: a CdbLength field of 10 may not always be appropriate
     */
    RtlZeroMemory(&fdoData->SrbTemplate, sizeof(SCSI_REQUEST_BLOCK));
    fdoData->SrbTemplate.Length = sizeof(SCSI_REQUEST_BLOCK);
    fdoData->SrbTemplate.Function = SRB_FUNCTION_EXECUTE_SCSI;
    fdoData->SrbTemplate.QueueAction = SRB_SIMPLE_TAG_REQUEST;
    fdoData->SrbTemplate.SenseInfoBufferLength = sizeof(SENSE_DATA);
    fdoData->SrbTemplate.CdbLength = 10;

    return status;
}


VOID DestroyAllTransferPackets(PDEVICE_OBJECT Fdo)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    TRANSFER_PACKET *pkt;

    PAGED_CODE();
    
    ASSERT(IsListEmpty(&fdoData->DeferredClientIrpList));

    while (pkt = DequeueFreeTransferPacket(Fdo, FALSE)){
        DestroyTransferPacket(pkt);
        InterlockedDecrement(&fdoData->NumTotalTransferPackets);    
    }

    ASSERT(fdoData->NumTotalTransferPackets == 0);
}


PTRANSFER_PACKET NewTransferPacket(PDEVICE_OBJECT Fdo)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PTRANSFER_PACKET newPkt;

    newPkt = ExAllocatePoolWithTag(NonPagedPool, sizeof(TRANSFER_PACKET), 'pnPC');
    if (newPkt){
        RtlZeroMemory(newPkt, sizeof(TRANSFER_PACKET)); // just to be sure

        /*
         *  Allocate resources for the packet.
         */
        newPkt->Irp = IoAllocateIrp(Fdo->StackSize, FALSE);
        if (newPkt->Irp){
            KIRQL oldIrql;
            
            newPkt->Fdo = Fdo;

            /*
             *  Enqueue the packet in our static AllTransferPacketsList
             *  (just so we can find it during debugging if its stuck somewhere).
             */
            KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);
            InsertTailList(&fdoData->AllTransferPacketsList, &newPkt->AllPktsListEntry);
            KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);
        }
        else {
            ExFreePool(newPkt);
            newPkt = NULL;
        }
    }

    return newPkt;
}


/*
 *  DestroyTransferPacket
 *
 */
VOID DestroyTransferPacket(PTRANSFER_PACKET Pkt)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Pkt->Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    KIRQL oldIrql;

    ASSERT(!Pkt->SlistEntry.Next);
    ASSERT(!Pkt->OriginalIrp);

    KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);

    /*
     *  Delete the packet from our all-packets queue.
     */
    ASSERT(!IsListEmpty(&Pkt->AllPktsListEntry));
    ASSERT(!IsListEmpty(&fdoData->AllTransferPacketsList));
    RemoveEntryList(&Pkt->AllPktsListEntry);
    InitializeListHead(&Pkt->AllPktsListEntry);

    KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);

    IoFreeIrp(Pkt->Irp);
    ExFreePool(Pkt);
}


VOID EnqueueFreeTransferPacket(PDEVICE_OBJECT Fdo, PTRANSFER_PACKET Pkt)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    KIRQL oldIrql;
    ULONG newNumPkts;
    
    ASSERT(!Pkt->SlistEntry.Next);

    InterlockedPushEntrySList(&fdoData->FreeTransferPacketsList, &Pkt->SlistEntry);
    newNumPkts = InterlockedIncrement(&fdoData->NumFreeTransferPackets);
    ASSERT(newNumPkts <= fdoData->NumTotalTransferPackets);

    /*
     *  If the total number of packets is larger than MinWorkingSetTransferPackets,
     *  that means that we've been in stress.  If all those packets are now
     *  free, then we are now out of stress and can free the extra packets.
     *  Free down to MaxWorkingSetTransferPackets immediately, and
     *  down to MinWorkingSetTransferPackets lazily (one at a time).
     */
    if (fdoData->NumFreeTransferPackets >= fdoData->NumTotalTransferPackets){

        /*
         *  1.  Immediately snap down to our UPPER threshold.
         */
        if (fdoData->NumTotalTransferPackets > MaxWorkingSetTransferPackets){
            SINGLE_LIST_ENTRY pktList;
            PSINGLE_LIST_ENTRY slistEntry;
            PTRANSFER_PACKET pktToDelete;

            DBGTRACE(ClassDebugTrace, ("Exiting stress, block freeing (%d-%d) packets.", fdoData->NumTotalTransferPackets, MaxWorkingSetTransferPackets));

            /*
             *  Check the counter again with lock held.  This eliminates a race condition
             *  while still allowing us to not grab the spinlock in the common codepath.
             *
             *  Note that the spinlock does not synchronize with threads dequeuing free
             *  packets to send (DequeueFreeTransferPacket does that with a lightweight
             *  interlocked exchange); the spinlock prevents multiple threads in this function
             *  from deciding to free too many extra packets at once.
             */
            SimpleInitSlistHdr(&pktList);
            KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);
            while ((fdoData->NumFreeTransferPackets >= fdoData->NumTotalTransferPackets) && 
                   (fdoData->NumTotalTransferPackets > MaxWorkingSetTransferPackets)){
                   
                pktToDelete = DequeueFreeTransferPacket(Fdo, FALSE);   
                if (pktToDelete){
                    SimplePushSlist(&pktList, &pktToDelete->SlistEntry);
                    InterlockedDecrement(&fdoData->NumTotalTransferPackets);    
                }
                else {
                    DBGTRACE(ClassDebugTrace, ("Extremely unlikely condition (non-fatal): %d packets dequeued at once for Fdo %p. NumTotalTransferPackets=%d (1).", MaxWorkingSetTransferPackets, Fdo, fdoData->NumTotalTransferPackets));
                    break;
                }
            }
            KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);

            while (slistEntry = SimplePopSlist(&pktList)){
                pktToDelete = CONTAINING_RECORD(slistEntry, TRANSFER_PACKET, SlistEntry);
                DestroyTransferPacket(pktToDelete);
            }

        }

        /*
         *  2.  Lazily work down to our LOWER threshold (by only freeing one packet at a time).
         */
        if (fdoData->NumTotalTransferPackets > MinWorkingSetTransferPackets){
            /*
             *  Check the counter again with lock held.  This eliminates a race condition
             *  while still allowing us to not grab the spinlock in the common codepath.
             *
             *  Note that the spinlock does not synchronize with threads dequeuing free
             *  packets to send (DequeueFreeTransferPacket does that with a lightweight
             *  interlocked exchange); the spinlock prevents multiple threads in this function
             *  from deciding to free too many extra packets at once.
             */
            PTRANSFER_PACKET pktToDelete = NULL; 

            DBGTRACE(ClassDebugTrace, ("Exiting stress, lazily freeing one of %d/%d packets.", fdoData->NumTotalTransferPackets, MinWorkingSetTransferPackets));
            
            KeAcquireSpinLock(&fdoData->SpinLock, &oldIrql);
            if ((fdoData->NumFreeTransferPackets >= fdoData->NumTotalTransferPackets) &&
                (fdoData->NumTotalTransferPackets > MinWorkingSetTransferPackets)){
                
                pktToDelete = DequeueFreeTransferPacket(Fdo, FALSE);
                if (pktToDelete){
                    InterlockedDecrement(&fdoData->NumTotalTransferPackets);    
                }
                else {
                    DBGTRACE(ClassDebugTrace, ("Extremely unlikely condition (non-fatal): %d packets dequeued at once for Fdo %p. NumTotalTransferPackets=%d (2).", MinWorkingSetTransferPackets, Fdo, fdoData->NumTotalTransferPackets));
                }
            }
            KeReleaseSpinLock(&fdoData->SpinLock, oldIrql);

            if (pktToDelete){
                DestroyTransferPacket(pktToDelete);
            }
        }

    }
  
}


PTRANSFER_PACKET DequeueFreeTransferPacket(PDEVICE_OBJECT Fdo, BOOLEAN AllocIfNeeded)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PTRANSFER_PACKET pkt;
    PSINGLE_LIST_ENTRY slistEntry;
    KIRQL oldIrql;

    slistEntry = InterlockedPopEntrySList(&fdoData->FreeTransferPacketsList);
    if (slistEntry){
        slistEntry->Next = NULL;
        pkt = CONTAINING_RECORD(slistEntry, TRANSFER_PACKET, SlistEntry);
        ASSERT(fdoData->NumFreeTransferPackets > 0);
        InterlockedDecrement(&fdoData->NumFreeTransferPackets);
    }
    else {
        if (AllocIfNeeded){
            /*
             *  We are in stress and have run out of lookaside packets.
             *  In order to service the current transfer, 
             *  allocate an extra packet.  
             *  We will free it lazily when we are out of stress.
             */
            pkt = NewTransferPacket(Fdo);
            if (pkt){
                InterlockedIncrement(&fdoData->NumTotalTransferPackets);
                fdoData->DbgPeakNumTransferPackets = max(fdoData->DbgPeakNumTransferPackets, fdoData->NumTotalTransferPackets);
            }
            else {
                DBGWARN(("DequeueFreeTransferPacket: packet allocation failed"));
            }
        }
        else {
            pkt = NULL;
        }
    }
    
    return pkt;
}



/*
 *  SetupReadWriteTransferPacket
 *
 *        This function is called once to set up the first attempt to send a packet.
 *        It is not called before a retry, as SRB fields may be modified for the retry.
 *
 *      Set up the Srb of the TRANSFER_PACKET for the transfer.
 *        The Irp is set up in SubmitTransferPacket because it must be reset
 *        for each packet submission.
 */
VOID SetupReadWriteTransferPacket(  PTRANSFER_PACKET Pkt, 
                                            PVOID Buf, 
                                            ULONG Len, 
                                            LARGE_INTEGER DiskLocation,
                                            PIRP OriginalIrp)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Pkt->Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PIO_STACK_LOCATION origCurSp = IoGetCurrentIrpStackLocation(OriginalIrp);
    UCHAR majorFunc = origCurSp->MajorFunction;
    ULONG logicalBlockAddr;
    ULONG numTransferBlocks;
    PCDB pCdb;
  
    logicalBlockAddr = (ULONG)Int64ShrlMod32(DiskLocation.QuadPart, fdoExt->SectorShift);
    numTransferBlocks = Len >> fdoExt->SectorShift;

    /*
     *  Slap the constant SRB fields in from our pre-initialized template.
     *  We'll then only have to fill in the unique fields for this transfer.
     *  Tell lower drivers to sort the SRBs by the logical block address 
     *  so that disk seeks are minimized.
     */
    Pkt->Srb = fdoData->SrbTemplate;    // copies _contents_ of SRB blocks
    Pkt->Srb.DataBuffer = Buf;
    Pkt->Srb.DataTransferLength = Len;
    Pkt->Srb.QueueSortKey = logicalBlockAddr;  
    Pkt->Srb.OriginalRequest = Pkt->Irp;
    Pkt->Srb.SenseInfoBuffer = &Pkt->SrbErrorSenseData;
    Pkt->Srb.TimeOutValue = (Len/0x10000) + ((Len%0x10000) ? 1 : 0);
    Pkt->Srb.TimeOutValue *= fdoExt->TimeOutValue;

    /*
     *  Arrange values in CDB in big-endian format.
     */
    pCdb = (PCDB)Pkt->Srb.Cdb;
    pCdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&logicalBlockAddr)->Byte3;
    pCdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&logicalBlockAddr)->Byte2;
    pCdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&logicalBlockAddr)->Byte1;
    pCdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&logicalBlockAddr)->Byte0;
    pCdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&numTransferBlocks)->Byte1;
    pCdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&numTransferBlocks)->Byte0;
    pCdb->CDB10.OperationCode = (majorFunc==IRP_MJ_READ) ? SCSIOP_READ : SCSIOP_WRITE;

    /*
     *  Set SRB and IRP flags    
     */
    Pkt->Srb.SrbFlags = fdoExt->SrbFlags;
    if (TEST_FLAG(OriginalIrp->Flags, IRP_PAGING_IO) ||
        TEST_FLAG(OriginalIrp->Flags, IRP_SYNCHRONOUS_PAGING_IO)){
        SET_FLAG(Pkt->Srb.SrbFlags, SRB_CLASS_FLAGS_PAGING);
    }
    SET_FLAG(Pkt->Srb.SrbFlags, (majorFunc==IRP_MJ_READ) ? SRB_FLAGS_DATA_IN : SRB_FLAGS_DATA_OUT);

    /*
     *  Allow caching only if this is not a write-through request.
     *  If write-through and caching is enabled on the device, force
     *  media access.
     */
    if (TEST_FLAG(origCurSp->Flags, SL_WRITE_THROUGH)){
        if (TEST_FLAG(fdoExt->DeviceFlags, DEV_WRITE_CACHE)){
            pCdb->CDB10.ForceUnitAccess = TRUE;
        }
    }
    else {
        SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_ADAPTER_CACHE_ENABLE);
    } 

    /*
     *  Remember the buf and len in the SRB because miniports
     *  can overwrite SRB.DataTransferLength and we may need it again
     *  for the retry.
     */
    Pkt->BufPtrCopy = Buf;
    Pkt->BufLenCopy = Len;
    Pkt->TargetLocationCopy = DiskLocation;
    
    Pkt->OriginalIrp = OriginalIrp;
    Pkt->NumRetries = MAXIMUM_RETRIES;    
    Pkt->SyncEventPtr = NULL;
    Pkt->CompleteOriginalIrpWhenLastPacketCompletes = TRUE;
}


/*
 *  SubmitTransferPacket
 *
 *        Set up the IRP for the TRANSFER_PACKET submission and send it down.
 */
VOID SubmitTransferPacket(PTRANSFER_PACKET Pkt)
{
    PCOMMON_DEVICE_EXTENSION commonExtension = Pkt->Fdo->DeviceExtension;
    PDEVICE_OBJECT nextDevObj = commonExtension->LowerDeviceObject;
    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Pkt->Irp);
    
    ASSERT(Pkt->Irp->CurrentLocation == Pkt->Irp->StackCount+1);

    /*
     *  Attach the SRB to the IRP.
     *  The reused IRP's stack location has to be rewritten for each retry
     *  call because IoCompleteRequest clears the stack locations.
     */
    IoReuseIrp(Pkt->Irp, STATUS_NOT_SUPPORTED);
    nextSp->MajorFunction = IRP_MJ_SCSI;
    nextSp->Parameters.Scsi.Srb = &Pkt->Srb;
    Pkt->Srb.ScsiStatus = Pkt->Srb.SrbStatus = 0;
    if (Pkt->CompleteOriginalIrpWhenLastPacketCompletes){
        /*
         *  Only dereference the "original IRP"'s stack location
         *  if its a real client irp (as opposed to a static irp 
         *  we're using just for result status for one of the non-IO scsi commands).
         *
         *  For read/write, propagate the storage-specific IRP stack location flags
         *  (e.g. SL_OVERRIDE_VERIFY_VOLUME, SL_WRITE_THROUGH).
         */
        PIO_STACK_LOCATION origCurSp = IoGetCurrentIrpStackLocation(Pkt->OriginalIrp);
        nextSp->Flags = origCurSp->Flags;
    }

    /*
     *  Write MDL address to new IRP. In the port driver the SRB DataBuffer
     *  field is used as the actual buffer pointer within the MDL, 
     *  so the same MDL can be used for each partial transfer. 
     *  This saves having to build a new MDL for each partial transfer.
     */
    Pkt->Irp->MdlAddress = Pkt->OriginalIrp->MdlAddress;
    
    IoSetCompletionRoutine(Pkt->Irp, TransferPktComplete, Pkt, TRUE, TRUE, TRUE);
    IoCallDriver(nextDevObj, Pkt->Irp);
}


NTSTATUS TransferPktComplete(IN PDEVICE_OBJECT NullFdo, IN PIRP Irp, IN PVOID Context)
{
    PTRANSFER_PACKET pkt = (PTRANSFER_PACKET)Context;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = pkt->Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PIO_STACK_LOCATION origCurrentSp = IoGetCurrentIrpStackLocation(pkt->OriginalIrp);
    BOOLEAN packetDone = FALSE;

    /*
     *  Put all the assertions and spew in here so we don't have to look at them.
     */
    DBGCHECKRETURNEDPKT(pkt);    
    
    if (SRB_STATUS(pkt->Srb.SrbStatus) == SRB_STATUS_SUCCESS){
        
        fdoData->LoggedTURFailureSinceLastIO = FALSE;
        
        /*
         *  The port driver should not have allocated a sense buffer
         *  if the SRB succeeded.
         */
        ASSERT(!PORT_ALLOCATED_SENSE(fdoExt, &pkt->Srb));

        /*
         *  Add this packet's transferred length to the original IRP's.
         */
        InterlockedExchangeAdd((PLONG)&pkt->OriginalIrp->IoStatus.Information, 
                              (LONG)pkt->Srb.DataTransferLength);

        if (pkt->InLowMemRetry){
            packetDone = StepLowMemRetry(pkt);
        }
        else {
            packetDone = TRUE;
        }
        
    }
    else {
        /*
         *  The packet failed.  We may retry it if possible.
         */
        BOOLEAN shouldRetry;
        
        /*
         *  Make sure IRP status matches SRB error status (since we propagate it).
         */
        if (NT_SUCCESS(Irp->IoStatus.Status)){
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }

        /*
         *  Interpret the SRB error (to a meaningful IRP status)
         *  and determine if we should retry this packet.
         *  This call looks at the returned SENSE info to figure out what to do.
         */
        shouldRetry = InterpretTransferPacketError(pkt);

        /*
         *  Sometimes the port driver can allocates a new 'sense' buffer
         *  to report transfer errors, e.g. when the default sense buffer
         *  is too small.  If so, it is up to us to free it.
         *  Now that we're done interpreting the sense info, free it if appropriate.
         */
        if (PORT_ALLOCATED_SENSE(fdoExt, &pkt->Srb)) {
            DBGTRACE(ClassDebugSenseInfo, ("Freeing port-allocated sense buffer for pkt %ph.", pkt));
            FREE_PORT_ALLOCATED_SENSE_BUFFER(fdoExt, &pkt->Srb);
            pkt->Srb.SenseInfoBuffer = &pkt->SrbErrorSenseData;
            pkt->Srb.SenseInfoBufferLength = sizeof(SENSE_DATA);
        }

        /*
         *  If the SRB queue is locked-up, release it.
         *  Do this after calling the error handler.
         */
        if (pkt->Srb.SrbStatus & SRB_STATUS_QUEUE_FROZEN){
            ClassReleaseQueue(pkt->Fdo);
        }
        
        if (shouldRetry && (pkt->NumRetries > 0)){           
            packetDone = RetryTransferPacket(pkt);
        }
        else {
            packetDone = TRUE;
        }
        
    }

    /*
     *  If the packet is completed, put it back in the free list.
     *  If it is the last packet servicing the original request, complete the original irp.
     */
    if (packetDone){
        LONG numPacketsRemaining;
        PIRP deferredIrp;
        PDEVICE_OBJECT Fdo = pkt->Fdo;
        UCHAR uniqueAddr;
        
        /*
         *  In case a remove is pending, bump the lock count so we don't get freed
         *  right after we complete the original irp.
         */
        ClassAcquireRemoveLock(Fdo, (PIRP)&uniqueAddr);        

        /*
         *  The original IRP should get an error code
         *  if any one of the packets failed.
         */
        if (!NT_SUCCESS(Irp->IoStatus.Status)){
            pkt->OriginalIrp->IoStatus.Status = Irp->IoStatus.Status;

            /*
             *  If the original I/O originated in user space (i.e. it is thread-queued), 
             *  and the error is user-correctable (e.g. media is missing, for removable media),
             *  alert the user.
             *  Since this is only one of possibly several packets completing for the original IRP,
             *  we may do this more than once for a single request.  That's ok; this allows
             *  us to test each returned status with IoIsErrorUserInduced().
             */
            if (IoIsErrorUserInduced(Irp->IoStatus.Status) &&
                pkt->CompleteOriginalIrpWhenLastPacketCompletes &&
                pkt->OriginalIrp->Tail.Overlay.Thread){

                IoSetHardErrorOrVerifyDevice(pkt->OriginalIrp, pkt->Fdo);
            }
        }

        /*
         *  We use a field in the original IRP to count
         *  down the transfer pieces as they complete.
         */
        numPacketsRemaining = InterlockedDecrement(
            (PLONG)&pkt->OriginalIrp->Tail.Overlay.DriverContext[0]);
            
        if (numPacketsRemaining > 0){
            /*
             *  More transfer pieces remain for the original request.
             *  Wait for them to complete before completing the original irp.
             */
        }
        else {

            /*
             *  All the transfer pieces are done.
             *  Complete the original irp if appropriate.
             */
            ASSERT(numPacketsRemaining == 0);
            if (pkt->CompleteOriginalIrpWhenLastPacketCompletes){  
                if (NT_SUCCESS(pkt->OriginalIrp->IoStatus.Status)){
                    ASSERT((ULONG)pkt->OriginalIrp->IoStatus.Information == origCurrentSp->Parameters.Read.Length);
                    ClasspPerfIncrementSuccessfulIo(fdoExt);
                }
                ClassReleaseRemoveLock(pkt->Fdo, pkt->OriginalIrp);

                ClassCompleteRequest(pkt->Fdo, pkt->OriginalIrp, IO_DISK_INCREMENT);

                /*
                 *  We may have been called by one of the class drivers (e.g. cdrom)
                 *  via the legacy API ClassSplitRequest.  
                 *  This is the only case for which the packet engine is called for an FDO
                 *  with a StartIo routine; in that case, we have to call IoStartNextPacket
                 *  now that the original irp has been completed.
                 */
                if (fdoExt->CommonExtension.DriverExtension->InitData.ClassStartIo) {
                    if (TEST_FLAG(pkt->Srb.SrbFlags, SRB_FLAGS_DONT_START_NEXT_PACKET)){
                        DBGTRAP(("SRB_FLAGS_DONT_START_NEXT_PACKET should never be set here (??)"));
                    }
                    else {
                        KIRQL oldIrql;
                        KeRaiseIrql(DISPATCH_LEVEL, &oldIrql);
                        IoStartNextPacket(pkt->Fdo, FALSE);
                        KeLowerIrql(oldIrql);
                    }
                }              
            }            
        }

        /*
         *  If the packet was synchronous, write the final
         *  result back to the issuer's status buffer and
         *  signal his event.
         */
        if (pkt->SyncEventPtr){
            KeSetEvent(pkt->SyncEventPtr, 0, FALSE);
            pkt->SyncEventPtr = NULL;
        }

        /*
         *  Free the completed packet.
         */
        pkt->OriginalIrp = NULL;
        pkt->InLowMemRetry = FALSE;
        EnqueueFreeTransferPacket(pkt->Fdo, pkt);

        /*
         *  Now that we have freed some resources,
         *  try again to send one of the previously deferred irps.
         */
        deferredIrp = DequeueDeferredClientIrp(fdoData);
        if (deferredIrp){
            DBGWARN(("... retrying deferred irp %xh.", deferredIrp)); 
            ServiceTransferRequest(pkt->Fdo, deferredIrp);
        }

        ClassReleaseRemoveLock(Fdo, (PIRP)&uniqueAddr);        
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}


/*
 *  SetupEjectionTransferPacket
 *
 *      Set up a transferPacket for a synchronous Ejection Control transfer.
 */
VOID SetupEjectionTransferPacket(   TRANSFER_PACKET *Pkt,
                                        BOOLEAN PreventMediaRemoval,
                                        PKEVENT SyncEventPtr,
                                        PIRP OriginalIrp)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Pkt->Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PCDB pCdb;

    PAGED_CODE();

    RtlZeroMemory(&Pkt->Srb, sizeof(SCSI_REQUEST_BLOCK));
    
    Pkt->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
    Pkt->Srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    Pkt->Srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;   
    Pkt->Srb.CdbLength = 6;
    Pkt->Srb.OriginalRequest = Pkt->Irp;
    Pkt->Srb.SenseInfoBuffer = &Pkt->SrbErrorSenseData;
    Pkt->Srb.SenseInfoBufferLength = sizeof(SENSE_DATA);
    Pkt->Srb.TimeOutValue = fdoExt->TimeOutValue;

    Pkt->Srb.SrbFlags = fdoExt->SrbFlags;
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);

    pCdb = (PCDB)Pkt->Srb.Cdb;
    pCdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
    pCdb->MEDIA_REMOVAL.Prevent = PreventMediaRemoval;

    Pkt->BufPtrCopy = NULL;
    Pkt->BufLenCopy = 0;

    Pkt->OriginalIrp = OriginalIrp;
    Pkt->NumRetries = NUM_LOCKMEDIAREMOVAL_RETRIES;          
    Pkt->SyncEventPtr = SyncEventPtr;
    Pkt->CompleteOriginalIrpWhenLastPacketCompletes = FALSE;
}
                                

/*
 *  SetupModeSenseTransferPacket
 *
 *      Set up a transferPacket for a synchronous Mode Sense transfer.
 */
VOID SetupModeSenseTransferPacket(   TRANSFER_PACKET *Pkt,
                                        PKEVENT SyncEventPtr,
                                        PVOID ModeSenseBuffer,
                                        UCHAR ModeSenseBufferLen,
                                        UCHAR PageMode,
                                        PIRP OriginalIrp)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Pkt->Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PCDB pCdb;

    PAGED_CODE();

    RtlZeroMemory(&Pkt->Srb, sizeof(SCSI_REQUEST_BLOCK));
    
    Pkt->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
    Pkt->Srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    Pkt->Srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;   
    Pkt->Srb.CdbLength = 6;
    Pkt->Srb.OriginalRequest = Pkt->Irp;
    Pkt->Srb.SenseInfoBuffer = &Pkt->SrbErrorSenseData;
    Pkt->Srb.SenseInfoBufferLength = sizeof(SENSE_DATA);
    Pkt->Srb.TimeOutValue = fdoExt->TimeOutValue;
    Pkt->Srb.DataBuffer = ModeSenseBuffer;
    Pkt->Srb.DataTransferLength = ModeSenseBufferLen;

    Pkt->Srb.SrbFlags = fdoExt->SrbFlags;
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DATA_IN);    
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);

    pCdb = (PCDB)Pkt->Srb.Cdb;
    pCdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    pCdb->MODE_SENSE.PageCode = PageMode;
    pCdb->MODE_SENSE.AllocationLength = (UCHAR)ModeSenseBufferLen;

    Pkt->BufPtrCopy = ModeSenseBuffer;
    Pkt->BufLenCopy = ModeSenseBufferLen;
        
    Pkt->OriginalIrp = OriginalIrp;
    Pkt->NumRetries = NUM_MODESENSE_RETRIES;          
    Pkt->SyncEventPtr = SyncEventPtr;
    Pkt->CompleteOriginalIrpWhenLastPacketCompletes = FALSE;
}


/*
 *  SetupDriveCapacityTransferPacket
 *
 *      Set up a transferPacket for a synchronous Drive Capacity transfer.
 */
VOID SetupDriveCapacityTransferPacket(   TRANSFER_PACKET *Pkt,
                                        PVOID ReadCapacityBuffer,
                                        ULONG ReadCapacityBufferLen,
                                        PKEVENT SyncEventPtr,
                                        PIRP OriginalIrp)
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Pkt->Fdo->DeviceExtension;
    PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
    PCDB pCdb;

    RtlZeroMemory(&Pkt->Srb, sizeof(SCSI_REQUEST_BLOCK));
    
    Pkt->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
    Pkt->Srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    Pkt->Srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;   
    Pkt->Srb.CdbLength = 10;
    Pkt->Srb.OriginalRequest = Pkt->Irp;
    Pkt->Srb.SenseInfoBuffer = &Pkt->SrbErrorSenseData;
    Pkt->Srb.SenseInfoBufferLength = sizeof(SENSE_DATA);
    Pkt->Srb.TimeOutValue = fdoExt->TimeOutValue;
    Pkt->Srb.DataBuffer = ReadCapacityBuffer;
    Pkt->Srb.DataTransferLength = ReadCapacityBufferLen;

    Pkt->Srb.SrbFlags = fdoExt->SrbFlags;
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DATA_IN);    
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
    SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);

    pCdb = (PCDB)Pkt->Srb.Cdb;
    pCdb->CDB10.OperationCode = SCSIOP_READ_CAPACITY;

    Pkt->BufPtrCopy = ReadCapacityBuffer;
    Pkt->BufLenCopy = ReadCapacityBufferLen;

    Pkt->OriginalIrp = OriginalIrp;
    Pkt->NumRetries = NUM_DRIVECAPACITY_RETRIES;          
    Pkt->SyncEventPtr = SyncEventPtr;
    Pkt->CompleteOriginalIrpWhenLastPacketCompletes = FALSE;
}


#if 0
    /*
     *  SetupSendStartUnitTransferPacket
     *
     *      Set up a transferPacket for a synchronous Send Start Unit transfer.
     */
    VOID SetupSendStartUnitTransferPacket(   TRANSFER_PACKET *Pkt,
                                                    PIRP OriginalIrp)
    {
        PFUNCTIONAL_DEVICE_EXTENSION fdoExt = Pkt->Fdo->DeviceExtension;
        PCLASS_PRIVATE_FDO_DATA fdoData = fdoExt->PrivateFdoData;
        PCDB pCdb;

        PAGED_CODE();

        RtlZeroMemory(&Pkt->Srb, sizeof(SCSI_REQUEST_BLOCK));

        /*
         *  Initialize the SRB.
         *  Use a very long timeout value to give the drive time to spin up.
         */
        Pkt->Srb.Length = sizeof(SCSI_REQUEST_BLOCK);
        Pkt->Srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
        Pkt->Srb.TimeOutValue = START_UNIT_TIMEOUT;
        Pkt->Srb.CdbLength = 6;
        Pkt->Srb.OriginalRequest = Pkt->Irp;
        Pkt->Srb.SenseInfoBuffer = &Pkt->SrbErrorSenseData;
        Pkt->Srb.SenseInfoBufferLength = sizeof(SENSE_DATA);
        Pkt->Srb.Lun = 0;
        
        SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_NO_DATA_TRANSFER);    
        SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DISABLE_AUTOSENSE);
        SET_FLAG(Pkt->Srb.SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

        pCdb = (PCDB)Pkt->Srb.Cdb;
        pCdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
        pCdb->START_STOP.Start = 1;
        pCdb->START_STOP.Immediate = 0;
        pCdb->START_STOP.LogicalUnitNumber = 0;

        Pkt->OriginalIrp = OriginalIrp;
        Pkt->NumRetries = 0;          
        Pkt->SyncEventPtr = NULL;
        Pkt->CompleteOriginalIrpWhenLastPacketCompletes = FALSE;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\part.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    disk.c

Abstract:

    SCSI disk class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "disk.h"

#define PtCache ClassDebugExternal1

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, DiskReadPartitionTableEx)
#pragma alloc_text(PAGE, DiskWritePartitionTableEx)
#pragma alloc_text(PAGE, DiskSetPartitionInformationEx)
#endif

ULONG DiskBreakOnPtInval = FALSE;

//
// By default, 64-bit systems can see GPT disks and 32-bit systems
// cannot. This will likely change in the future.
//

#if defined(_WIN64)
ULONG DiskDisableGpt = FALSE;
#else
ULONG DiskDisableGpt = TRUE;
#endif

NTSTATUS
DiskReadPartitionTableEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN BOOLEAN BypassCache,
    OUT PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    )
/*++

Routine Description:

    This routine will return the current layout information for the disk.
    If the cached information is still valid then it will be returned, 
    otherwise the layout will be retreived from the kernel and cached for 
    future use.
    
    This routine must be called with the partitioning lock held.  The 
    partition list which is returned is not guaranteed to remain valid 
    once the lock has been released.
    
Arguments:

    Fdo - a pointer to the FDO for the disk.
    
    DriveLayout - a location to store a pointer to the drive layout information.    

Return Value:

    STATUS_SUCCESS if successful or an error status indicating what failed.
    
--*/        
    
{
    PDISK_DATA diskData = Fdo->CommonExtension.DriverData;
    NTSTATUS status;
    PDRIVE_LAYOUT_INFORMATION_EX layoutEx;

    layoutEx = NULL;

    if(BypassCache) {
        diskData->CachedPartitionTableValid = FALSE;
        DebugPrint((PtCache, "DiskRPTEx: cache bypassed and invalidated for "
                             "FDO %#p\n", Fdo));
    }

    //
    // If the cached partition table is present then return a copy of it.
    //

    if(diskData->CachedPartitionTableValid == TRUE) {

        ULONG partitionNumber;
        PDRIVE_LAYOUT_INFORMATION_EX layout = diskData->CachedPartitionTable;

        //
        // Clear the partition numbers from the list entries
        //

        for(partitionNumber = 0;
            partitionNumber < layout->PartitionCount;
            partitionNumber++) {
            layout->PartitionEntry[partitionNumber].PartitionNumber = 0;
        }

        *DriveLayout = diskData->CachedPartitionTable;

        DebugPrint((PtCache, "DiskRPTEx: cached PT returned (%#p) for "
                             "FDO %#p\n", 
                    *DriveLayout, Fdo));
                    
        return STATUS_SUCCESS;
    }

    ASSERTMSG("DiskReadPartitionTableEx is not using cached partition table",
              (DiskBreakOnPtInval == FALSE));

    //
    // If there's a cached partition table still around then free it.
    //

    if(diskData->CachedPartitionTable) {
        DebugPrint((PtCache, "DiskRPTEx: cached PT (%#p) freed for FDO %#p\n",
                    diskData->CachedPartitionTable, Fdo));

        ExFreePool(diskData->CachedPartitionTable);
        diskData->CachedPartitionTable = NULL;
    }

    //
    // By default, X86 disables recognition of GPT disks. Instead we
    // return the protective MBR partition. Use IoReadPartitionTable
    // to get this.
    //
    
    status = IoReadPartitionTableEx(Fdo->DeviceObject, &layoutEx);

    if (DiskDisableGpt) {
        PDRIVE_LAYOUT_INFORMATION layout;

        if (NT_SUCCESS (status) &&
            layoutEx->PartitionStyle == PARTITION_STYLE_GPT) {

            //
            // ISSUE - 2000/29/08 - math: Remove from final product.
            // Leave this debug print in for a while until everybody
            // has had a chance to convert their GPT disks to MBR.
            //
            
            DbgPrint ("DISK: Disk %p recognized as a GPT disk on a system without GPT support.\n"
                      "      Disk will appear as RAW.\n",
                      Fdo->DeviceObject);

            ExFreePool (layoutEx);
            status = IoReadPartitionTable(Fdo->DeviceObject,
                                          Fdo->DiskGeometry.BytesPerSector,
                                          FALSE,
                                          &layout);
            if (NT_SUCCESS (status)) {
                layoutEx = DiskConvertLayoutToExtended(layout);
                ExFreePool (layout);
            }
        }
    }

    diskData->CachedPartitionTable = layoutEx;

    //
    // If the routine fails make sure we don't have a stale partition table 
    // pointer.  Otherwise indicate that the table is now valid.
    //

    if(!NT_SUCCESS(status)) {
        diskData->CachedPartitionTable = NULL;
    } else {
        diskData->CachedPartitionTableValid = TRUE;
    }

    *DriveLayout = diskData->CachedPartitionTable;

    DebugPrint((PtCache, "DiskRPTEx: returning PT %#p for FDO %#p with status "
                         "%#08lx.  PT is %scached\n",
                *DriveLayout,
                Fdo,
                status,
                (diskData->CachedPartitionTableValid ? "" : "not ")));


    return status;
}


NTSTATUS
DiskWritePartitionTableEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    )
/*++

Routine Description:

    This routine will invalidate the cached partition table.  It will then 
    write the new drive layout to disk.  
    
Arguments:

    Fdo - the FDO for the disk getting the new partition table.
    
    DriveLayout - the new drive layout.
    
Return Value:
    
    status
    
--*/        
{
    PDISK_DATA diskData = Fdo->CommonExtension.DriverData;

    //
    // Invalidate the cached partition table.  Do not free it as it may be 
    // the very drive layout that was passed in to us.
    //

    diskData->CachedPartitionTableValid = FALSE;

    DebugPrint((PtCache, "DiskWPTEx: Invalidating PT cache for FDO %#p\n",
                Fdo));

    if (DiskDisableGpt) {
        if (DriveLayout->PartitionStyle == PARTITION_STYLE_GPT) {
            return STATUS_NOT_SUPPORTED;
        }
    }
        
    return IoWritePartitionTableEx(Fdo->DeviceObject, DriveLayout);
}

NTSTATUS
DiskSetPartitionInformationEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN ULONG PartitionNumber,
    IN struct _SET_PARTITION_INFORMATION_EX* PartitionInfo
    )
{
    PDISK_DATA diskData = Fdo->CommonExtension.DriverData;

    diskData->CachedPartitionTableValid = FALSE;
    DebugPrint((PtCache, "DiskSPIEx: Invalidating PT cache for FDO %#p\n",
                Fdo));

    if (DiskDisableGpt) {
        if (PartitionInfo->PartitionStyle == PARTITION_STYLE_GPT) {
            return STATUS_NOT_SUPPORTED;
        }
    }
        
    return IoSetPartitionInformationEx(Fdo->DeviceObject, 
                                       PartitionNumber, 
                                       PartitionInfo);
}

NTSTATUS
DiskSetPartitionInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    )
{
    PDISK_DATA diskData = Fdo->CommonExtension.DriverData;

    diskData->CachedPartitionTableValid = FALSE;
    DebugPrint((PtCache, "DiskSPI: Invalidating PT cache for FDO %#p\n",
                Fdo));

    return IoSetPartitionInformation(Fdo->DeviceObject, 
                                     SectorSize,
                                     PartitionNumber, 
                                     PartitionType);
}

BOOLEAN
DiskInvalidatePartitionTable(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN BOOLEAN PartitionLockHeld
    )
{
    PDISK_DATA diskData = Fdo->CommonExtension.DriverData;
    BOOLEAN wasValid;

    wasValid = (BOOLEAN) (diskData->CachedPartitionTableValid ? TRUE : FALSE);
    diskData->CachedPartitionTableValid = FALSE;

    DebugPrint((PtCache, "DiskIPT: Invalidating PT cache for FDO %#p\n",
                Fdo));

    if((PartitionLockHeld) && (diskData->CachedPartitionTable != NULL)) {
        DebugPrint((PtCache, "DiskIPT: Freeing PT cache (%#p) for FDO %#p\n",
                    diskData->CachedPartitionTable, Fdo));
        ExFreePool(diskData->CachedPartitionTable);
        diskData->CachedPartitionTable = NULL;
    }

    return wasValid;
}

NTSTATUS
DiskVerifyPartitionTable(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN BOOLEAN FixErrors
    )
{
    PDISK_DATA diskData = Fdo->CommonExtension.DriverData;

    if(FixErrors) {
        diskData->CachedPartitionTableValid = FALSE;
        DebugPrint((PtCache, "DiskWPTEx: Invalidating PT cache for FDO %#p\n",
                    Fdo));
    }

    return IoVerifyPartitionTable(Fdo->DeviceObject, FixErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\diskwmi.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    diskwmi.c

Abstract:

    SCSI disk class driver - WMI support routines

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "disk.h"

NTSTATUS
DiskSendFailurePredictIoctl(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_PREDICT_FAILURE checkFailure
    );

NTSTATUS
DiskGetIdentifyInfo(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PBOOLEAN SupportSmart
    );

NTSTATUS
DiskDetectFailurePrediction(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PFAILURE_PREDICTION_METHOD FailurePredictCapability
    );

NTSTATUS
DiskReadFailurePredictThresholds(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_FAILURE_PREDICT_THRESHOLDS DiskSmartThresholds
    );

NTSTATUS
DiskReadSmartLog(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN UCHAR SectorCount,
    IN UCHAR LogAddress,
    OUT PUCHAR Buffer
    );

NTSTATUS
DiskWriteSmartLog(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN UCHAR SectorCount,
    IN UCHAR LogAddress,
    IN PUCHAR Buffer
    );

void DiskReregWorker(
    IN PVOID Context
    );

//
// WMI reregistration globals
//
// Since it will take too long to do a mode sense on some drive, we
// need a good way to effect the mode sense for the info exceptions
// mode page so that we can determine if SMART is supported and enabled
// for the drive. So the strategy is to do an asynchronous mode sense
// when the device starts and then look at the info exceptions mode
// page within the completion routine. Now within the completion
// routine we cannot call IoWMIRegistrationControl since we are at DPC
// level, so we create a stack of device objects that will be processed
// by a single work item that is fired off only when the stack
// transitions from empty to non empty.
//
WORK_QUEUE_ITEM DiskReregWorkItem;
SINGLE_LIST_ENTRY DiskReregHead;
KSPIN_LOCK DiskReregSpinlock;
LONG DiskReregWorkItems;

GUIDREGINFO DiskWmiFdoGuidList[] =
{
    {
        WMI_DISK_GEOMETRY_GUID,
        1,
        0
    },

    {
        WMI_STORAGE_FAILURE_PREDICT_STATUS_GUID,
        1,
        WMIREG_FLAG_EXPENSIVE
    },
    
    {
        WMI_STORAGE_FAILURE_PREDICT_DATA_GUID,
        1,
        WMIREG_FLAG_EXPENSIVE
    },

    {
        WMI_STORAGE_FAILURE_PREDICT_FUNCTION_GUID,
        1,
        WMIREG_FLAG_EXPENSIVE
    },

    {
        WMI_STORAGE_PREDICT_FAILURE_EVENT_GUID,
        1,
        WMIREG_FLAG_EVENT_ONLY_GUID
    },

    {
        WMI_STORAGE_FAILURE_PREDICT_THRESHOLDS_GUID,
        1,
        WMIREG_FLAG_EXPENSIVE
    },

    {
        WMI_STORAGE_SCSI_INFO_EXCEPTIONS_GUID,
        1,
        0
    },

    
};


GUID DiskPredictFailureEventGuid = WMI_STORAGE_PREDICT_FAILURE_EVENT_GUID;

#define DiskGeometryGuid           0
#define SmartStatusGuid            1
#define SmartDataGuid              2
#define SmartPerformFunction       3
    #define AllowDisallowPerformanceHit                 1
    #define EnableDisableHardwareFailurePrediction      2
    #define EnableDisableFailurePredictionPolling       3
    #define GetFailurePredictionCapability              4
    #define EnableOfflineDiags                          5

#define SmartEventGuid             4
#define SmartThresholdsGuid        5
#define ScsiInfoExceptionsGuid     6

#if 0
    //
    // Enable this to add WMI support for PDOs
GUIDREGINFO DiskWmiPdoGuidList[] =
{
    {
        // {25007F51-57C2-11d1-A528-00A0C9062910}
        { 0x25007f52, 0x57c2, 0x11d1,
                       { 0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } },
        0
    },

};

ULONG DiskDummyData[4] = { 1, 2, 3, 4};
#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, DiskWmiFunctionControl)
#pragma alloc_text(PAGE, DiskFdoQueryWmiRegInfo)
#pragma alloc_text(PAGE, DiskFdoQueryWmiDataBlock)
#pragma alloc_text(PAGE, DiskFdoSetWmiDataBlock)
#pragma alloc_text(PAGE, DiskFdoSetWmiDataItem)
#pragma alloc_text(PAGE, DiskFdoExecuteWmiMethod)

#pragma alloc_text(PAGE, DiskDetectFailurePrediction)
#pragma alloc_text(PAGE, DiskEnableDisableFailurePrediction)
#pragma alloc_text(PAGE, DiskEnableDisableFailurePredictPolling)
#pragma alloc_text(PAGE, DiskReadFailurePredictStatus)
#pragma alloc_text(PAGE, DiskReadFailurePredictData)
#pragma alloc_text(PAGE, DiskReadFailurePredictThresholds)
#pragma alloc_text(PAGE, DiskGetIdentifyInfo)
#pragma alloc_text(PAGE, DiskReadSmartLog)
#pragma alloc_text(PAGE, DiskWriteSmartLog)

#pragma alloc_text(PAGE, DiskPerformSmartCommand)

#pragma alloc_text(PAGE, DiskSendFailurePredictIoctl)

#pragma alloc_text(PAGE, DiskReregWorker)
#pragma alloc_text(PAGE, DiskInitializeReregistration)

#endif


//
// SMART/IDE specific routines

//
// Read SMART data attributes.
// SrbControl should be sizeof(SRB_IO_CONTROL) +
//                      (sizeof(SENDCMDINPARAMS)-1) +
//                      READ_ATTRIBUTE_BUFFER_SIZE
// Attribute data returned at &SendCmdOutParams->bBuffer[0]
//
#define DiskReadSmartData(FdoExtension, \
                          SrbControl, \
                          BufferSize) \
    DiskPerformSmartCommand(FdoExtension, \
                            IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS,  \
                            SMART_CMD, \
                            READ_ATTRIBUTES, \
                            0, \
                            0, \
                            (SrbControl), \
                            (BufferSize))


//
// Read SMART data thresholds.
// SrbControl should be sizeof(SRB_IO_CONTROL) +
//                      (sizeof(SENDCMDINPARAMS)-1) +
//                      READ_THRESHOLD_BUFFER_SIZE
// Attribute data returned at &SendCmdOutParams->bBuffer[0]
//
#define DiskReadSmartThresholds(FdoExtension, \
                          SrbControl, \
                          BufferSize) \
    DiskPerformSmartCommand(FdoExtension, \
                            IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS, \
                            SMART_CMD, \
                            READ_THRESHOLDS, \
                            0, \
                            0, \
                            (SrbControl), \
                            (BufferSize))


//
// Read SMART status
// SrbControl should be sizeof(SRB_IO_CONTROL) +
//                      (sizeof(SENDCMDINPARAMS)-1) +
//                      sizeof(IDEREGS)
// Failure predicted if cmdOutParameters[3] == 0xf4 and [4] == 0x2c
//
#define DiskReadSmartStatus(FdoExtension, \
                          SrbControl, \
                          BufferSize) \
    DiskPerformSmartCommand(FdoExtension, \
                            IOCTL_SCSI_MINIPORT_RETURN_STATUS, \
                            SMART_CMD, \
                            RETURN_SMART_STATUS, \
                            0, \
                            0, \
                            (SrbControl), \
                            (BufferSize))


//
// Read disks IDENTIFY data
// SrbControl should be sizeof(SRB_IO_CONTROL) +
//                      (sizeof(SENDCMDINPARAMS)-1) +
//                      sizeof(IDENTIFY_BUFFER_SIZE)
// Identify data returned at &cmdOutParams.bBuffer[0]
//
#define DiskGetIdentifyData(FdoExtension, \
                          SrbControl, \
                          BufferSize) \
    DiskPerformSmartCommand(FdoExtension, \
                            IOCTL_SCSI_MINIPORT_IDENTIFY, \
                            ID_CMD, \
                            0, \
                            0, \
                            0, \
                            (SrbControl), \
                            (BufferSize))


//
// Enable SMART
//
_inline NTSTATUS
DiskEnableSmart(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    UCHAR srbControl[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS)];
    ULONG bufferSize = sizeof(srbControl);

    return DiskPerformSmartCommand(FdoExtension,
                                   IOCTL_SCSI_MINIPORT_ENABLE_SMART,
                                   SMART_CMD,
                                   ENABLE_SMART,
                                   0,
                                   0,
                                   (PSRB_IO_CONTROL)srbControl,
                                   &bufferSize);
}

//
// Disable SMART
//
_inline NTSTATUS
DiskDisableSmart(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    UCHAR srbControl[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS)];
    ULONG bufferSize = sizeof(srbControl);
    return DiskPerformSmartCommand(FdoExtension,
                                   IOCTL_SCSI_MINIPORT_DISABLE_SMART,
                                   SMART_CMD,
                                   DISABLE_SMART,
                                   0,
                                   0,
                                   (PSRB_IO_CONTROL)srbControl,
                                   &bufferSize);
}

//
// Enable Attribute Autosave
//
_inline NTSTATUS
DiskEnableSmartAttributeAutosave(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    UCHAR srbControl[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS)];
    ULONG bufferSize = sizeof(srbControl);
    return DiskPerformSmartCommand(FdoExtension,
                                   IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE,
                                   SMART_CMD,
                                   ENABLE_DISABLE_AUTOSAVE,
                                   0xf1,
                                   0,
                                   (PSRB_IO_CONTROL)srbControl,
                                   &bufferSize);
}

//
// Disable Attribute Autosave
//
_inline NTSTATUS
DiskDisableSmartAttributeAutosave(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    UCHAR srbControl[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS)];
    ULONG bufferSize = sizeof(srbControl);
    return DiskPerformSmartCommand(FdoExtension,
                                   IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE,
                                   SMART_CMD,
                                   ENABLE_DISABLE_AUTOSAVE,
                                   0x00,
                                   0,
                                   (PSRB_IO_CONTROL)srbControl,
                                   &bufferSize);
}

//
// Initialize execution of SMART online diagnostics
//
_inline NTSTATUS
DiskExecuteSmartDiagnostics(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    UCHAR Subcommand
    )
{
    UCHAR srbControl[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS)];
    ULONG bufferSize = sizeof(srbControl);
    return DiskPerformSmartCommand(FdoExtension,
                                   IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS,
                                   SMART_CMD,
                                   EXECUTE_OFFLINE_DIAGS,
                                   0,
                                   Subcommand,
                                   (PSRB_IO_CONTROL)srbControl,
                                   &bufferSize);
}


NTSTATUS
DiskReadSmartLog(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN UCHAR SectorCount,
    IN UCHAR LogAddress,
    OUT PUCHAR Buffer
    )
{
    PSRB_IO_CONTROL srbControl;
    NTSTATUS status;
    PSENDCMDOUTPARAMS sendCmdOutParams;
    ULONG logSize, bufferSize;

    PAGED_CODE();

    logSize = SectorCount * SMART_LOG_SECTOR_SIZE;
    bufferSize = sizeof(SRB_IO_CONTROL) +  sizeof(SENDCMDINPARAMS) - 1 +
                 logSize;

    srbControl = ExAllocatePoolWithTag(NonPagedPool,
                                       bufferSize,
                                       DISK_TAG_SMART);
    
    if (srbControl != NULL)
    {
        status = DiskPerformSmartCommand(FdoExtension,
                                         IOCTL_SCSI_MINIPORT_READ_SMART_LOG,
                                         SMART_CMD,
                                         SMART_READ_LOG,
                                         SectorCount,
                                         LogAddress,
                                         srbControl,
                                         &bufferSize);

        if (NT_SUCCESS(status))
        {
            sendCmdOutParams = (PSENDCMDOUTPARAMS)((PUCHAR)srbControl +
                                                   sizeof(SRB_IO_CONTROL));
            RtlCopyMemory(Buffer,
                          &sendCmdOutParams->bBuffer[0],
                          logSize);
        }
        
        ExFreePool(srbControl);
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(status);
}


NTSTATUS
DiskWriteSmartLog(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN UCHAR SectorCount,
    IN UCHAR LogAddress,
    IN PUCHAR Buffer
    )
{
    PSRB_IO_CONTROL srbControl;
    NTSTATUS status;
    PSENDCMDINPARAMS sendCmdInParams;
    ULONG logSize, bufferSize;

    PAGED_CODE();

    logSize = SectorCount * SMART_LOG_SECTOR_SIZE;
    bufferSize = sizeof(SRB_IO_CONTROL) +  sizeof(SENDCMDINPARAMS) - 1 +
                 logSize;

    srbControl = ExAllocatePoolWithTag(NonPagedPool,
                                       bufferSize,
                                       DISK_TAG_SMART);
    
    if (srbControl != NULL)
    {
        sendCmdInParams = (PSENDCMDINPARAMS)((PUCHAR)srbControl +
                                               sizeof(SRB_IO_CONTROL));
        RtlCopyMemory(&sendCmdInParams->bBuffer[0],
                      Buffer,
                      logSize);
        status = DiskPerformSmartCommand(FdoExtension,
                                         IOCTL_SCSI_MINIPORT_WRITE_SMART_LOG,
                                         SMART_CMD,
                                         SMART_WRITE_LOG,
                                         SectorCount,
                                         LogAddress,
                                         srbControl,
                                         &bufferSize);

        ExFreePool(srbControl);
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return(status);
}
                  
NTSTATUS
DiskPerformSmartCommand(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG SrbControlCode,
    IN UCHAR Command,
    IN UCHAR Feature,
    IN UCHAR SectorCount,
    IN UCHAR SectorNumber,
    IN OUT PSRB_IO_CONTROL SrbControl,
    OUT PULONG BufferSize
    )
/*++

Routine Description:

    This routine will perform some SMART command

Arguments:

    FdoExtension is the FDO device extension

    SrbControlCode is the SRB control code to use for the request

    Command is the SMART command to be executed. It may be SMART_CMD or
        ID_CMD.

    Feature is the value to place in the IDE feature register.

    SectorCount is the value to place in the IDE SectorCount register

    SrbControl is the buffer used to build the SRB_IO_CONTROL and pass
        any input parameters. It also returns the output parameters.

    *BufferSize on entry has total size of SrbControl and on return has
        the size used in SrbControl.



Return Value:

    status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION)FdoExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    PUCHAR buffer;
    PSENDCMDINPARAMS cmdInParameters;
    PSENDCMDOUTPARAMS cmdOutParameters;
    ULONG outBufferSize;
    NTSTATUS status;
    ULONG availableBufferSize;
    KEVENT event;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    SCSI_REQUEST_BLOCK      srb;
    LARGE_INTEGER           startingOffset;
    ULONG length;
    PIO_STACK_LOCATION      irpStack;

    PAGED_CODE();

    //
    // Point to the 'buffer' portion of the SRB_CONTROL and compute how
    // much room we have left in the srb control
    //

    buffer = (PUCHAR)SrbControl;
    (ULONG_PTR)buffer +=  sizeof(SRB_IO_CONTROL);

    cmdInParameters = (PSENDCMDINPARAMS)buffer;
    cmdOutParameters = (PSENDCMDOUTPARAMS)buffer;

    availableBufferSize = *BufferSize - sizeof(SRB_IO_CONTROL);

#if DBG
    //
    // Ensure control codes and buffer lengths passed are correct
    //
    {
        ULONG controlCode;
        ULONG lengthNeeded = sizeof(SENDCMDINPARAMS) - 1;

        if (Command == SMART_CMD)
        {
            switch (Feature)
            {

                case ENABLE_SMART:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_ENABLE_SMART;

                    break;
                }

                case DISABLE_SMART:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_DISABLE_SMART;
                    break;
                }

                case  RETURN_SMART_STATUS:
                {
                     //
                    // Ensure bBuffer is at least 2 bytes (to hold the values of
                    // cylinderLow and cylinderHigh).
                    //

                    lengthNeeded = sizeof(SENDCMDINPARAMS) - 1 + sizeof(IDEREGS);

                    controlCode = IOCTL_SCSI_MINIPORT_RETURN_STATUS;
                    break;
                }

                case ENABLE_DISABLE_AUTOSAVE:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE;
                    break;
                }

                case SAVE_ATTRIBUTE_VALUES:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES;
                    break;
                }


                case EXECUTE_OFFLINE_DIAGS:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS;
                    break;
                }

                case READ_ATTRIBUTES:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS;
                    lengthNeeded = READ_ATTRIBUTE_BUFFER_SIZE + sizeof(SENDCMDOUTPARAMS) - 1;
                    break;
                }

                case READ_THRESHOLDS:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS;
                    lengthNeeded = READ_THRESHOLD_BUFFER_SIZE + sizeof(SENDCMDOUTPARAMS) - 1;
                    break;
                }

                case SMART_READ_LOG:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_READ_SMART_LOG;
                    lengthNeeded = (SectorCount * SMART_LOG_SECTOR_SIZE) +
                                   sizeof(SENDCMDINPARAMS) - 1;
                    break;
                }

                case SMART_WRITE_LOG:
                {
                    controlCode = IOCTL_SCSI_MINIPORT_WRITE_SMART_LOG;
                    lengthNeeded = (SectorCount * SMART_LOG_SECTOR_SIZE) +
                                   sizeof(SENDCMDINPARAMS) - 1;
                    break;
                }
                
            }
        } else if (Command == ID_CMD) {
            controlCode = IOCTL_SCSI_MINIPORT_IDENTIFY;
            lengthNeeded = IDENTIFY_BUFFER_SIZE + sizeof(SENDCMDOUTPARAMS) -1;
        } else {
            ASSERT(FALSE);
        }

        ASSERT(controlCode == SrbControlCode);
        ASSERT(availableBufferSize >= lengthNeeded);
    }
#endif

    //
    // Build SrbControl and input to SMART command
    //

    SrbControl->HeaderLength = sizeof(SRB_IO_CONTROL);
    RtlMoveMemory (SrbControl->Signature, "SCSIDISK", 8);
    SrbControl->Timeout = FdoExtension->TimeOutValue;
    SrbControl->Length = availableBufferSize;

    SrbControl->ControlCode = SrbControlCode;

    cmdInParameters->cBufferSize = sizeof(SENDCMDINPARAMS);
    cmdInParameters->bDriveNumber = diskData->ScsiAddress.TargetId;
    cmdInParameters->irDriveRegs.bFeaturesReg = Feature;
    cmdInParameters->irDriveRegs.bSectorCountReg = SectorCount;
    cmdInParameters->irDriveRegs.bSectorNumberReg = SectorNumber;
    cmdInParameters->irDriveRegs.bCylLowReg = SMART_CYL_LOW;
    cmdInParameters->irDriveRegs.bCylHighReg = SMART_CYL_HI;
    cmdInParameters->irDriveRegs.bCommandReg = Command;


    //
    // Create and send irp
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    startingOffset.QuadPart = (LONGLONG) 1;

    length = SrbControl->HeaderLength + SrbControl->Length;

    irp = IoBuildSynchronousFsdRequest(
                IRP_MJ_SCSI,
                commonExtension->LowerDeviceObject,
                SrbControl,
                length,
                &startingOffset,
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major and minor codes.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.PathId = diskData->ScsiAddress.PathId;
    srb.TargetId = diskData->ScsiAddress.TargetId;
    srb.Lun = diskData->ScsiAddress.Lun;

    srb.Function = SRB_FUNCTION_IO_CONTROL;
    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    srb.SrbFlags = FdoExtension->SrbFlags;
    SET_FLAG(srb.SrbFlags, SRB_FLAGS_DATA_IN);
    SET_FLAG(srb.SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);
    SET_FLAG(srb.SrbFlags, SRB_FLAGS_NO_KEEP_AWAKE);

    srb.QueueAction = SRB_SIMPLE_TAG_REQUEST;
    srb.QueueTag = SP_UNTAGGED;

    srb.OriginalRequest = irp;

    //
    // Set timeout to requested value.
    //

    srb.TimeOutValue = SrbControl->Timeout;

    //
    // Set the data buffer.
    //

    srb.DataBuffer = SrbControl;
    srb.DataTransferLength = length;

    //
    // Flush the data buffer for output. This will insure that the data is
    // written back to memory.  Since the data-in flag is the the port driver
    // will flush the data again for input which will ensure the data is not
    // in the cache.
    //

    KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    //
    // Call port driver to handle this request.
    //

    status = IoCallDriver(commonExtension->LowerDeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    return status;
}


NTSTATUS
DiskGetIdentifyInfo(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PBOOLEAN SupportSmart
    )
{
    UCHAR outBuffer[sizeof(SRB_IO_CONTROL) + (sizeof(SENDCMDINPARAMS)-1) + IDENTIFY_BUFFER_SIZE];
    ULONG outBufferSize = sizeof(outBuffer);
    NTSTATUS status;

    PAGED_CODE();

    status = DiskGetIdentifyData(FdoExtension,
                                 (PSRB_IO_CONTROL)outBuffer,
                                 &outBufferSize);

    if (NT_SUCCESS(status))
    {
        PUSHORT identifyData = (PUSHORT)&(outBuffer[sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDOUTPARAMS)-1]);
        USHORT commandSetSupported = identifyData[82];

        *SupportSmart = ((commandSetSupported != 0xffff) &&
                         (commandSetSupported != 0) &&
                         ((commandSetSupported & 1) == 1));
    } else {
        *SupportSmart = FALSE;
    }

    DebugPrint((3, "DiskGetIdentifyInfo: SMART %s supported for device %p, status %lx\n",
                   *SupportSmart ? "is" : "is not",
                   FdoExtension->DeviceObject,
                   status));

    return status;
}


//
// FP Ioctl specific routines
//

NTSTATUS
DiskSendFailurePredictIoctl(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_PREDICT_FAILURE checkFailure
    )
{
    KEVENT event;
    PDEVICE_OBJECT deviceObject;
    IO_STATUS_BLOCK ioStatus;
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    deviceObject = IoGetAttachedDeviceReference(FdoExtension->DeviceObject);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_STORAGE_PREDICT_FAILURE,
                    deviceObject,
                    NULL,
                    0,
                    checkFailure,
                    sizeof(STORAGE_PREDICT_FAILURE),
                    FALSE,
                    &event,
                    &ioStatus);

    if (irp != NULL)
    {
        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING)
        {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ObDereferenceObject(deviceObject);

    return status;
}


//
// FP type independent routines
//

NTSTATUS
DiskEnableDisableFailurePrediction(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    BOOLEAN Enable
    )
/*++

Routine Description:

    Enable or disable failure prediction at the hardware level

Arguments:

    FdoExtension

    Enable

Return Value:

    NT Status

--*/
{
    NTSTATUS status;
    PCOMMON_DEVICE_EXTENSION commonExtension = &(FdoExtension->CommonExtension);
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);

    PAGED_CODE();

    switch(diskData->FailurePredictionCapability)
    {
        case FailurePredictionSmart:
        {

            if (Enable)
            {
                status = DiskEnableSmart(FdoExtension);
            } else {
                status = DiskDisableSmart(FdoExtension);
            }

            break;
        }

        case  FailurePredictionSense:
        case  FailurePredictionIoctl:
        {
            //
            // We assume that the drive is already setup properly for
            // failure prediction
            //
            status = STATUS_SUCCESS;
            break;
        }

        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }
    return status;
}

NTSTATUS
DiskEnableDisableFailurePredictPolling(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    BOOLEAN Enable,
    ULONG PollTimeInSeconds
    )
/*++

Routine Description:

    Enable or disable polling for hardware failure detection

Arguments:

    FdoExtension

    Enable

    PollTimeInSeconds - if 0 then no change to current polling timer

Return Value:

    NT Status

--*/
{
    NTSTATUS status;
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION)FdoExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);

    PAGED_CODE();

    if (Enable)
    {
        status = DiskEnableDisableFailurePrediction(FdoExtension,
                                           Enable);
    } else {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status))
    {
        status = ClassSetFailurePredictionPoll(FdoExtension,
                        Enable ? diskData->FailurePredictionCapability :
                                 FailurePredictionNone,
                                     PollTimeInSeconds);

        //
        // Even if this failed we do not want to disable FP on the
        // hardware. FP is only ever disabled on the hardware by
        // specific command of the user.
        //
    }

    return status;
}


NTSTATUS
DiskReadFailurePredictStatus(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_FAILURE_PREDICT_STATUS DiskSmartStatus
    )
/*++

Routine Description:

    Obtains current failure prediction status

Arguments:

    FdoExtension

    DiskSmartStatus

Return Value:

    NT Status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION)FdoExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    NTSTATUS status;

    PAGED_CODE();

    DiskSmartStatus->PredictFailure = FALSE;

    switch(diskData->FailurePredictionCapability)
    {
        case FailurePredictionSmart:
        {
            UCHAR outBuffer[sizeof(SRB_IO_CONTROL) + (sizeof(SENDCMDINPARAMS) - 1 + sizeof(IDEREGS))];
            ULONG outBufferSize = sizeof(outBuffer);
            PSENDCMDOUTPARAMS cmdOutParameters;

            status = DiskReadSmartStatus(FdoExtension,
                                     (PSRB_IO_CONTROL)outBuffer,
                                     &outBufferSize);

            if (NT_SUCCESS(status))
            {
                cmdOutParameters = (PSENDCMDOUTPARAMS)(outBuffer +
                                               sizeof(SRB_IO_CONTROL));

                DiskSmartStatus->Reason = 0; // Unknown;
                DiskSmartStatus->PredictFailure = ((cmdOutParameters->bBuffer[3] == 0xf4) &&
                                                   (cmdOutParameters->bBuffer[4] == 0x2c));
            }
            break;
        }

        case FailurePredictionSense:
        {
            DiskSmartStatus->Reason = FdoExtension->FailureReason;
            DiskSmartStatus->PredictFailure = FdoExtension->FailurePredicted;
            status = STATUS_SUCCESS;
            break;
        }

        case FailurePredictionIoctl:
        case FailurePredictionNone:
        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    return status;
}

NTSTATUS
DiskReadFailurePredictData(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_FAILURE_PREDICT_DATA DiskSmartData
    )
/*++

Routine Description:

    Obtains current failure prediction data. Not available for
    FAILURE_PREDICT_SENSE types.

Arguments:

    FdoExtension

    DiskSmartData

Return Value:

    NT Status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION)FdoExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    NTSTATUS status;

    PAGED_CODE();

    switch(diskData->FailurePredictionCapability)
    {
        case FailurePredictionSmart:
        {
            PUCHAR outBuffer;
            ULONG outBufferSize;
            PSENDCMDOUTPARAMS cmdOutParameters;

            outBufferSize = sizeof(SRB_IO_CONTROL) +
                            (sizeof(SENDCMDOUTPARAMS)-1) +
                            READ_ATTRIBUTE_BUFFER_SIZE;

            outBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                              outBufferSize,
                                              DISK_TAG_SMART);

            if (outBuffer != NULL)
            {
                status = DiskReadSmartData(FdoExtension,
                                           (PSRB_IO_CONTROL)outBuffer,
                                           &outBufferSize);

                if (NT_SUCCESS(status))
                {
                    cmdOutParameters = (PSENDCMDOUTPARAMS)(outBuffer +
                                                    sizeof(SRB_IO_CONTROL));

                    DiskSmartData->Length = READ_ATTRIBUTE_BUFFER_SIZE;
                    RtlCopyMemory(DiskSmartData->VendorSpecific,
                                  cmdOutParameters->bBuffer,
                                  READ_ATTRIBUTE_BUFFER_SIZE);
                }
                ExFreePool(outBuffer);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            break;
        }

        case FailurePredictionSense:
        {
            DiskSmartData->Length = sizeof(ULONG);
            *((PULONG)DiskSmartData->VendorSpecific) = FdoExtension->FailureReason;

            status = STATUS_SUCCESS;
            break;
        }

        case FailurePredictionIoctl:
        case FailurePredictionNone:
        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    return status;
}

NTSTATUS
DiskReadFailurePredictThresholds(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_FAILURE_PREDICT_THRESHOLDS DiskSmartThresholds
    )
/*++

Routine Description:

    Obtains current failure prediction thresholds. Not available for
    FAILURE_PREDICT_SENSE types.

Arguments:

    FdoExtension

    DiskSmartData

Return Value:

    NT Status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION)FdoExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    NTSTATUS status;

    PAGED_CODE();

    switch(diskData->FailurePredictionCapability)
    {
        case FailurePredictionSmart:
        {
            PUCHAR outBuffer;
            PSENDCMDOUTPARAMS cmdOutParameters;
            ULONG outBufferSize;

            outBufferSize = sizeof(SRB_IO_CONTROL) +
                            (sizeof(SENDCMDOUTPARAMS)-1) +
                            READ_THRESHOLD_BUFFER_SIZE;
            
            outBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                              outBufferSize,
                                              DISK_TAG_SMART);

            if (outBuffer != NULL)
            {
                status = DiskReadSmartThresholds(FdoExtension,
                                                (PSRB_IO_CONTROL)outBuffer,
                                                &outBufferSize);

                if (NT_SUCCESS(status))
                {
                    cmdOutParameters = (PSENDCMDOUTPARAMS)(outBuffer +
                                           sizeof(SRB_IO_CONTROL));

                    RtlCopyMemory(DiskSmartThresholds->VendorSpecific,
                                  cmdOutParameters->bBuffer,
                                  READ_THRESHOLD_BUFFER_SIZE);
                }
                ExFreePool(outBuffer);
            } else {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            break;
        }

        case FailurePredictionSense:
        case FailurePredictionIoctl:
        case FailurePredictionNone:
        default:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    return status;
}

void DiskReregWorker(
    IN PVOID Context
    )
{
    PDISKREREGREQUEST reregRequest;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PIRP irp;

    PAGED_CODE();
    
    do
    {
        reregRequest = (PDISKREREGREQUEST)ExInterlockedPopEntryList(
            &DiskReregHead,
            &DiskReregSpinlock);

        deviceObject = reregRequest->DeviceObject;
        irp = reregRequest->Irp;
        
        status = IoWMIRegistrationControl(deviceObject,
                                          WMIREG_ACTION_UPDATE_GUIDS);

        if (! NT_SUCCESS(status))
        {
            DebugPrint((1, "DiskReregWorker: Reregistration failed %x\n",
                        status));
        }

        //
        // Release remove lock and free irp, now that we are done
        // processing this
        //
        ClassReleaseRemoveLock(deviceObject, irp);

        IoFreeMdl(irp->MdlAddress);
        IoFreeIrp(irp);
        
        ExFreePool(reregRequest);
        
    } while (InterlockedDecrement(&DiskReregWorkItems));

    
}

NTSTATUS DiskInitializeReregistration(
    void
    )
{
    PAGED_CODE();
    
    //
    // Initialize the global work item and spinlock used to manage the
    // list of disks reregistering their guids
    //
    ExInitializeWorkItem( &DiskReregWorkItem,
                          DiskReregWorker,
                          NULL );

    KeInitializeSpinLock(&DiskReregSpinlock);

    return(STATUS_SUCCESS);
}

NTSTATUS DiskPostReregisterRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
{
    PDISKREREGREQUEST reregRequest;
    NTSTATUS status;
    
    reregRequest = ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(DISKREREGREQUEST),
                                         DISK_TAG_SMART);

    if (reregRequest != NULL)
    {
        //
        // add the disk that needs reregistration to the stack of disks
        // to reregister. If the list is transitioning from empty to
        // non empty then also kick off the work item so that the
        // reregistration worker can do the reregister.
        //
        reregRequest->DeviceObject = DeviceObject;
        reregRequest->Irp = Irp;
        ExInterlockedPushEntryList(
                                   &DiskReregHead,
                                   &reregRequest->Next,
                                   &DiskReregSpinlock);
    
        if (InterlockedIncrement(&DiskReregWorkItems) == 1)
        {
            ExQueueWorkItem( &DiskReregWorkItem, DelayedWorkQueue );
        }
        status = STATUS_SUCCESS;
    } else {
        DebugPrint((1, "DiskPostReregisterRequest: could not allocate reregRequest for %p\n",
                    DeviceObject));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return(status);
}

NTSTATUS DiskInfoExceptionComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = Context;
    NTSTATUS status;
    BOOLEAN retry;
    ULONG retryInterval;
    ULONG srbStatus;
    BOOLEAN freeLockAndIrp = TRUE;
    KIRQL oldIrql;

    ASSERT(fdoExtension->CommonExtension.IsFdo);

    srbStatus = SRB_STATUS(srb->SrbStatus);

    //
    // Check SRB status for success of completing request.
    // SRB_STATUS_DATA_OVERRUN also indicates success.
    //
    if ((srbStatus != SRB_STATUS_SUCCESS) &&
        (srbStatus != SRB_STATUS_DATA_OVERRUN))
    {    
        DebugPrint((2, "DiskInfoExceptionComplete: IRP %p, SRB %p\n", Irp, srb));

        retry = ClassInterpretSenseInfo(
                    DeviceObject,
                    srb,
                    irpStack->MajorFunction,
                     0,
                    MAXIMUM_RETRIES -
                        ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4),
                    &status,
                    &retryInterval);

        //
        // If the status is verified required and the this request
        // should bypass verify required then retry the request.
        //

        if (TEST_FLAG(irpStack->Flags, SL_OVERRIDE_VERIFY_VOLUME) &&
            status == STATUS_VERIFY_REQUIRED)
        {
            status = STATUS_IO_DEVICE_ERROR;
            retry = TRUE;
        }

        if (retry && ((ULONG)(ULONG_PTR)irpStack->Parameters.Others.Argument4)--)
        {

            //
            // Retry request.
            //

            DebugPrint((1, "DiskInfoExceptionComplete: Retry request %p\n", Irp));
            
            ASSERT(srb->DataBuffer == MmGetMdlVirtualAddress(Irp->MdlAddress));
            
            //
            // Reset byte count of transfer in SRB Extension.
            //
            srb->DataTransferLength = Irp->MdlAddress->ByteCount;
            
            //
            // Zero SRB statuses.
            //

            srb->SrbStatus = srb->ScsiStatus = 0;

            //
            // Set the no disconnect flag, disable synchronous data transfers and
            // disable tagged queuing. This fixes some errors.
            //

            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_DISCONNECT);
            SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);
            CLEAR_FLAG(srb->SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE);

            srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
            srb->QueueTag = SP_UNTAGGED;

            //
            // Set up major SCSI function.
            //

            nextIrpStack->MajorFunction = IRP_MJ_SCSI;

            //
            // Save SRB address in next stack for port driver.
            //

            nextIrpStack->Parameters.Scsi.Srb = srb;


            IoSetCompletionRoutine(Irp,
                                   DiskInfoExceptionComplete,
                                   srb,
                                   TRUE, TRUE, TRUE);
            
            (VOID)IoCallDriver(commonExtension->LowerDeviceObject, Irp);
        
            return STATUS_MORE_PROCESSING_REQUIRED;
        }
    
    } else {

        //
        // Get the results from the mode sense
        //
        PMODE_INFO_EXCEPTIONS pageData;
        PMODE_PARAMETER_HEADER modeData;
        ULONG modeDataLength;

        modeData = srb->DataBuffer;
        modeDataLength = srb->DataTransferLength;
        
        pageData = ClassFindModePage((PUCHAR) modeData,
                                     modeDataLength,
                                     MODE_PAGE_FAULT_REPORTING,
                                     TRUE);
        if (pageData != NULL)
        {
            DebugPrint((1, "DiskInfoExceptionComplete: %p supports SMART\n",
                        DeviceObject));

            if (pageData->Dexcpt == 0)
            {
                diskData->FailurePredictionCapability = FailurePredictionSense;
                status = DiskPostReregisterRequest(DeviceObject, Irp);

                if (NT_SUCCESS(status))
                {
                    //
                    // Make sure we won't free the remove lock and the irp
                    // since we need to keep these until after the work
                    // item has completed running
                    //
                    freeLockAndIrp = FALSE;
                }
            } else {
                DebugPrint((1, "DiskInfoExceptionComplete: %p is not enabled for SMART\n",
                        DeviceObject));
            
            }
            
        } else {
            DebugPrint((1, "DiskInfoExceptionComplete: %p does not supports SMART\n",
                        DeviceObject));
            
        }
        
        //
        // Set status for successful request
        //

        status = STATUS_SUCCESS;

    } // end if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS)

    //
    // Free the srb
    //
    ExFreePool(srb->SenseInfoBuffer);
    ExFreePool(srb->DataBuffer);
    ExFreePool(srb);
        
    if (freeLockAndIrp)
    {
        //
        // Set status in completing IRP.
        //

        Irp->IoStatus.Status = status;

        //
        // If pending has be returned for this irp then mark the current stack as
        // pending.
        //

        if (Irp->PendingReturned) {
            IoMarkIrpPending(Irp);
        }

        ClassReleaseRemoveLock(DeviceObject, Irp);
        IoFreeMdl(Irp->MdlAddress);
        IoFreeIrp(Irp);
    }
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
    
}

NTSTATUS DiskInfoExceptionCheck(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PUCHAR modeData;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PVOID senseInfoBuffer;
    ULONG isRemoved;
    
    modeData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     MODE_DATA_SIZE,
                                     DISK_TAG_INFO_EXCEPTION);
    if (modeData == NULL)
    {
        DebugPrint((1, "DiskInfoExceptionCheck: Can't allocate mode data "
                        "buffer\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
        
    srb = ExAllocatePoolWithTag(NonPagedPool,
                                SCSI_REQUEST_BLOCK_SIZE,
                                DISK_TAG_SRB);
    if (srb == NULL)
    {
        ExFreePool(modeData);
        DebugPrint((1, "DiskInfoExceptionCheck: Can't allocate srb "
                        "buffer\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);      
    }
    
    //
    // Build the MODE SENSE CDB.
    //
    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);
    
    cdb = (PCDB)srb->Cdb;
    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;
    
    //
    // Set timeout value from device extension.
    //
    srb->TimeOutValue = FdoExtension->TimeOutValue;

    cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
    cdb->MODE_SENSE.PageCode = MODE_PAGE_FAULT_REPORTING;
    cdb->MODE_SENSE.AllocationLength = MODE_DATA_SIZE;
    
    //
    // Write length to SRB.
    //
    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set SCSI bus address.
    //

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;

    //
    // Enable auto request sense.
    //  
    
    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    //
    // Sense buffer is in aligned nonpaged pool.
    //

    senseInfoBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     SENSE_BUFFER_SIZE,
                                     '7CcS');

    if (senseInfoBuffer == NULL)
    {
        ExFreePool(srb);
        ExFreePool(modeData);
        DebugPrint((1, "DiskInfoExceptionCheck: Can't allocate request sense "
                        "buffer\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    srb->SenseInfoBuffer = senseInfoBuffer;
    srb->DataBuffer = modeData;
    
    srb->SrbFlags = FdoExtension->SrbFlags;


    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DATA_IN);
    
    //
    // Disable synchronous transfer for these requests.
    //
    SET_FLAG(srb->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

    //
    // Don't freeze the queue on an error
    //  
    SET_FLAG(srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);

    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
    srb->QueueTag = SP_UNTAGGED;

        
    //
    // Build device I/O control request with METHOD_NEITHER data transfer.
    // We'll queue a completion routine to cleanup the MDL's and such ourself.
    //

    irp = IoAllocateIrp(
            (CCHAR) (FdoExtension->CommonExtension.LowerDeviceObject->StackSize + 1),
            FALSE);

    if (irp == NULL)
    {
        ExFreePool(senseInfoBuffer);
        ExFreePool(srb);
        ExFreePool(modeData);
        DebugPrint((1, "DiskInfoExceptionCheck: Can't allocate Irp\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    isRemoved = ClassAcquireRemoveLock(FdoExtension->DeviceObject, irp);

    if (isRemoved)
    {
        ClassReleaseRemoveLock(FdoExtension->DeviceObject, irp);
        IoFreeIrp(irp);
        ExFreePool(senseInfoBuffer);
        ExFreePool(srb);
        ExFreePool(modeData);
        DebugPrint((1, "DiskInfoExceptionCheck: RemoveLock says isRemoved\n"));
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    }
    
    //
    // Get next stack location.
    //

    IoSetNextIrpStackLocation(irp);
    irpStack = IoGetCurrentIrpStackLocation(irp);
    irpStack->DeviceObject = FdoExtension->DeviceObject;

    //
    // Save retry count in current Irp stack.
    //
    irpStack->Parameters.Others.Argument4 = (PVOID)MAXIMUM_RETRIES;
    
    
    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set up SRB for execute scsi request. Save SRB address in next stack
    // for the port driver.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->Parameters.Scsi.Srb = srb;

    IoSetCompletionRoutine(irp,
                           DiskInfoExceptionComplete,
                           srb,
                           TRUE,
                           TRUE,
                           TRUE);

    irp->MdlAddress = IoAllocateMdl( modeData,
                                     MODE_DATA_SIZE,
                                     FALSE,
                                     FALSE,
                                     irp );
    if (irp->MdlAddress == NULL)
    {
        ClassReleaseRemoveLock(FdoExtension->DeviceObject, irp);
        ExFreePool(srb);
        ExFreePool(modeData);
        ExFreePool(senseInfoBuffer);
        IoFreeIrp( irp );
        DebugPrint((1, "DiskINfoExceptionCheck: Can't allocate MDL\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool(irp->MdlAddress);
        
    //
    // Set the transfer length.
    //
    srb->DataTransferLength = MODE_DATA_SIZE;

    //
    // Zero out status.
    //
    srb->ScsiStatus = srb->SrbStatus = 0;
    srb->NextSrb = 0;

    //
    // Set up IRP Address.
    //
    srb->OriginalRequest = irp;
    
    //
    // Call the port driver with the request and wait for it to complete.
    //

    IoMarkIrpPending(irp);
    IoCallDriver(FdoExtension->CommonExtension.LowerDeviceObject,
                          irp);

    return(STATUS_PENDING);
}

NTSTATUS
DiskDetectFailurePrediction(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PFAILURE_PREDICTION_METHOD FailurePredictCapability
    )
/*++

Routine Description:

    Detect if device has any failure prediction capabilities. First we
    check for IDE SMART capability. This is done by sending the drive an
    IDENTIFY command and checking if the SMART command set bit is set.

    Next we check if SCSI SMART (aka Information Exception Control Page,
    X3T10/94-190 Rev 4). This is done by querying for the Information
    Exception mode page.

    Lastly we check if the device has IOCTL failure prediction. This mechanism
    a filter driver implements IOCTL_STORAGE_PREDICT_FAILURE and will respond
    with the information in the IOCTL. We do this by sending the ioctl and
    if the status returned is STATUS_SUCCESS we assume that it is supported.

Arguments:

    FdoExtension

    *FailurePredictCapability

Return Value:

    NT Status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = (PCOMMON_DEVICE_EXTENSION)FdoExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    BOOLEAN supportFP;
    NTSTATUS status;
    STORAGE_PREDICT_FAILURE checkFailure;
    STORAGE_FAILURE_PREDICT_STATUS diskSmartStatus;
    BOOLEAN logErr;

    PAGED_CODE();

    //
    // Assume no failure predict mechanisms
    //
    *FailurePredictCapability = FailurePredictionNone;

    //
    // See if this is an IDE drive that supports SMART. If so enable SMART
    // and then ensure that it suports the SMART READ STATUS command
    //
    status = DiskGetIdentifyInfo(FdoExtension,
                                 &supportFP);

    if (supportFP)
    {
        status = DiskEnableSmart(FdoExtension);
        if (NT_SUCCESS(status))
        {
            *FailurePredictCapability = FailurePredictionSmart;

            status = DiskReadFailurePredictStatus(FdoExtension,
                                                  &diskSmartStatus);

            DebugPrint((1, "Disk: Device %p %s IDE SMART\n",
                       FdoExtension->DeviceObject,
                       NT_SUCCESS(status) ? "does" : "does not"));

            if (! NT_SUCCESS(status))
            {
                *FailurePredictCapability = FailurePredictionNone;
            }
        }
        return(status);
    }

    //
    // See if there is a a filter driver to intercept
    // IOCTL_STORAGE_PREDICT_FAILURE
    //
    status = DiskSendFailurePredictIoctl(FdoExtension,
                                         &checkFailure);

    DebugPrint((1, "Disk: Device %p %s IOCTL_STORAGE_FAILURE_PREDICT\n",
                       FdoExtension->DeviceObject,
                       NT_SUCCESS(status) ? "does" : "does not"));

    if (NT_SUCCESS(status))
    {
        *FailurePredictCapability = FailurePredictionIoctl;
        if (checkFailure.PredictFailure)
        {
            checkFailure.PredictFailure = 512;
            ClassNotifyFailurePredicted(FdoExtension,
                                            (PUCHAR)&checkFailure,
                                            sizeof(checkFailure),
                                            (BOOLEAN)(FdoExtension->FailurePredicted == FALSE),
                                            0x11,
                                            diskData->ScsiAddress.PathId,
                                            diskData->ScsiAddress.TargetId,
                                            diskData->ScsiAddress.Lun);

            FdoExtension->FailurePredicted = TRUE;
        }
        return(status);
    }
    
    //
    // Finally we assume it will not be a scsi smart drive. but
    // we'll also send off an asynchronous mode sense so that if
    // it is SMART we'll reregister the device object
    //

    DiskInfoExceptionCheck(FdoExtension);
    
    *FailurePredictCapability = FailurePredictionNone;

    return(STATUS_SUCCESS);
}


NTSTATUS
DiskWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.


    When NT boots, failure prediction is not automatically enabled, although
    it may have been persistantly enabled on a previous boot. Polling is also
    not automatically enabled. When the first data block that accesses SMART
    such as SmartStatusGuid, SmartDataGuid, SmartPerformFunction, or
    SmartEventGuid is accessed then SMART is automatically enabled in the
    hardware. Polling is enabled when SmartEventGuid is enabled and disabled
    when it is disabled. Hardware SMART is only disabled when the DisableSmart
    method is called. Polling is also disabled when this is called regardless
    of the status of the other guids or events.

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    ULONG enableCount;

    PAGED_CODE();

    if ((Function == DataBlockCollection) && Enable)
    {
        if ((GuidIndex == SmartStatusGuid) ||
            (GuidIndex == SmartDataGuid) ||
            (GuidIndex == SmartThresholdsGuid) ||
            (GuidIndex == SmartPerformFunction))
        {
            status = DiskEnableDisableFailurePrediction(fdoExtension,
                                                        TRUE);
            DebugPrint((3, "Disk: DeviceObject %p, Irp %p Enable -> %lx\n",
                       DeviceObject,
                       Irp,
                       status));

        } else {
            DebugPrint((3, "Disk: DeviceObject %p, Irp %p, GuidIndex %d %s for Collection\n",
                      DeviceObject, Irp,
                      GuidIndex,
                      Enable ? "Enabled" : "Disabled"));        }
    } else if (Function == EventGeneration) {
        DebugPrint((3, "Disk: DeviceObject %p, Irp %p, GuidIndex %d %s for Event Generation\n",
                  DeviceObject, Irp,
                  GuidIndex,
                  Enable ? "Enabled" : "Disabled"));


        if ((GuidIndex == SmartEventGuid) && Enable)
        {
            status = DiskEnableDisableFailurePredictPolling(fdoExtension,
                                                   Enable,
                                                   0);
            DebugPrint((3, "Disk: DeviceObject %p, Irp %p %s -> %lx\n",
                       DeviceObject,
                       Irp,
                       Enable ? "DiskEnableSmartPolling" : "DiskDisableSmartPolling",
                       status));
        }

#if DBG
    } else {
        DebugPrint((3, "Disk: DeviceObject %p, Irp %p, GuidIndex %d %s for function %d\n",
                  DeviceObject, Irp,
                  GuidIndex,
                  Enable ? "Enabled" : "Disabled",
                  Function));
#endif
    }

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);
    return status;
}



NTSTATUS
DiskFdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.


Return Value:

    status

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    NTSTATUS status;

    PAGED_CODE();

    SET_FLAG(DiskWmiFdoGuidList[SmartThresholdsGuid].Flags,  WMIREG_FLAG_REMOVE_GUID);
    SET_FLAG(DiskWmiFdoGuidList[ScsiInfoExceptionsGuid].Flags,  WMIREG_FLAG_REMOVE_GUID);
    
    switch (diskData->FailurePredictionCapability)
    {
        case FailurePredictionSmart:
        {
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartThresholdsGuid].Flags,  WMIREG_FLAG_REMOVE_GUID);
            //
            // Fall Through
            //
        }
        case FailurePredictionIoctl:
        {
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartStatusGuid].Flags,      WMIREG_FLAG_REMOVE_GUID);
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartDataGuid].Flags,        WMIREG_FLAG_REMOVE_GUID);
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartEventGuid].Flags,       WMIREG_FLAG_REMOVE_GUID);
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartPerformFunction].Flags, WMIREG_FLAG_REMOVE_GUID);
                  
            break;
        }

        case FailurePredictionSense:
        {
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartStatusGuid].Flags,      WMIREG_FLAG_REMOVE_GUID);
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartEventGuid].Flags,       WMIREG_FLAG_REMOVE_GUID);
            CLEAR_FLAG(DiskWmiFdoGuidList[SmartPerformFunction].Flags, WMIREG_FLAG_REMOVE_GUID);
            CLEAR_FLAG(DiskWmiFdoGuidList[ScsiInfoExceptionsGuid].Flags,  WMIREG_FLAG_REMOVE_GUID);
            SET_FLAG  (DiskWmiFdoGuidList[SmartDataGuid].Flags,        WMIREG_FLAG_REMOVE_GUID);
            break;
        }


        default:
        {
            SET_FLAG  (DiskWmiFdoGuidList[SmartStatusGuid].Flags,      WMIREG_FLAG_REMOVE_GUID);
            SET_FLAG  (DiskWmiFdoGuidList[SmartDataGuid].Flags,        WMIREG_FLAG_REMOVE_GUID);
            SET_FLAG  (DiskWmiFdoGuidList[SmartEventGuid].Flags,       WMIREG_FLAG_REMOVE_GUID);
            SET_FLAG  (DiskWmiFdoGuidList[SmartPerformFunction].Flags, WMIREG_FLAG_REMOVE_GUID);
            break;
        }
    }

    //
    // Use devnode for FDOs
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;

    return STATUS_SUCCESS;
}

NTSTATUS
DiskFdoQueryWmiRegInfoEx(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING MofName                      
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    MofName returns initialized with the mof resource name for the
        binary mof resource attached to the driver's image file. If the
        driver does not have a mof resource then it should leave this
        parameter untouched.

Return Value:

    status

--*/
{
    NTSTATUS status;
    
    status = DiskFdoQueryWmiRegInfo(DeviceObject,
                                    RegFlags,
                                    InstanceName);

    //
    // Leave MofName alone since disk doesn't have one
    //
    return(status);
}


NTSTATUS
DiskFdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    ULONG sizeNeeded;

    PAGED_CODE();

    DebugPrint((3, "Disk: DiskQueryWmiDataBlock, Device %p, Irp %p, GuiIndex %d\n"
             "      BufferAvail %lx Buffer %lx\n",
             DeviceObject, Irp,
             GuidIndex, BufferAvail, Buffer));

    switch (GuidIndex)
    {
        case DiskGeometryGuid:
        {
            sizeNeeded = sizeof(DISK_GEOMETRY);
            if (BufferAvail >= sizeNeeded)
            {
                if (DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)
                {
                    //
                    // Issue ReadCapacity to update device extension
                    // with information for current media.
                    status = DiskReadDriveCapacity(commonExtension->PartitionZeroExtension->DeviceObject);

                    //
                    // Note whether the drive is ready.
                    diskData->ReadyStatus = status;

                    if (!NT_SUCCESS(status))
                    {
                        break;
                    }
                }

                //
                // Copy drive geometry information from device extension.
                RtlMoveMemory(Buffer,
                              &(fdoExtension->DiskGeometry),
                              sizeof(DISK_GEOMETRY));

                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case SmartStatusGuid:
        {
            PSTORAGE_FAILURE_PREDICT_STATUS diskSmartStatus;

            ASSERT(diskData->FailurePredictionCapability != FailurePredictionNone);


            sizeNeeded = sizeof(STORAGE_FAILURE_PREDICT_STATUS);
            if (BufferAvail >= sizeNeeded)
            {
                STORAGE_PREDICT_FAILURE checkFailure;

                diskSmartStatus = (PSTORAGE_FAILURE_PREDICT_STATUS)Buffer;

                status = DiskSendFailurePredictIoctl(fdoExtension,
                                                     &checkFailure);

                if (NT_SUCCESS(status))
                {
                    if (diskData->FailurePredictionCapability ==
                                                      FailurePredictionSense)
                    {
                        diskSmartStatus->Reason =  *((PULONG)checkFailure.VendorSpecific);
                    } else {
                        diskSmartStatus->Reason =  0; // unknown
                    }

                    diskSmartStatus->PredictFailure = (checkFailure.PredictFailure != 0);
                }
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case SmartDataGuid:
        {
            PSTORAGE_FAILURE_PREDICT_DATA diskSmartData;

            ASSERT((diskData->FailurePredictionCapability ==
                                                  FailurePredictionSmart) ||
                   (diskData->FailurePredictionCapability ==
                                                  FailurePredictionIoctl));

            sizeNeeded = sizeof(STORAGE_FAILURE_PREDICT_DATA);
            if (BufferAvail >= sizeNeeded)
            {
                PSTORAGE_PREDICT_FAILURE checkFailure = (PSTORAGE_PREDICT_FAILURE)Buffer;

                diskSmartData = (PSTORAGE_FAILURE_PREDICT_DATA)Buffer;

                status = DiskSendFailurePredictIoctl(fdoExtension,
                                                     checkFailure);

                if (NT_SUCCESS(status))
                {
                    diskSmartData->Length = 512;
                }
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }
        
        case SmartThresholdsGuid:
        {
            PSTORAGE_FAILURE_PREDICT_THRESHOLDS diskSmartThresholds;

            ASSERT((diskData->FailurePredictionCapability ==
                                                  FailurePredictionSmart));

            sizeNeeded = sizeof(STORAGE_FAILURE_PREDICT_THRESHOLDS);
            if (BufferAvail >= sizeNeeded)
            {
                diskSmartThresholds = (PSTORAGE_FAILURE_PREDICT_THRESHOLDS)Buffer;
                status = DiskReadFailurePredictThresholds(fdoExtension,
                                                          diskSmartThresholds);
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

        case SmartPerformFunction:
        {
            sizeNeeded = 0;
            status = STATUS_SUCCESS;
            break;
        }

        case ScsiInfoExceptionsGuid:
        {
            PSTORAGE_SCSI_INFO_EXCEPTIONS infoExceptions;
            MODE_INFO_EXCEPTIONS modeInfo;

            ASSERT((diskData->FailurePredictionCapability ==
                                                  FailurePredictionSense));
            
            sizeNeeded = sizeof(STORAGE_SCSI_INFO_EXCEPTIONS);
            if (BufferAvail >= sizeNeeded)
            {
                infoExceptions = (PSTORAGE_SCSI_INFO_EXCEPTIONS)Buffer;
                status = DiskGetInfoExceptionInformation(fdoExtension,
                                                         &modeInfo);

                if (NT_SUCCESS(status))
                {
                    infoExceptions->PageSavable = modeInfo.PSBit;
                    infoExceptions->Flags = modeInfo.Flags;
                    infoExceptions->MRIE = modeInfo.ReportMethod;
                    infoExceptions->Padding = 0;
                    REVERSE_BYTES(&infoExceptions->IntervalTimer,
                                  &modeInfo.IntervalTimer);
                    REVERSE_BYTES(&infoExceptions->ReportCount,
                                  &modeInfo.ReportCount)
                }
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

        default:
        {
            sizeNeeded = 0;
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }
    DebugPrint((3, "Disk: DiskQueryWmiDataBlock Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return status;
}

NTSTATUS
DiskFdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);

    PAGED_CODE();

    DebugPrint((3, "Disk: DiskSetWmiDataBlock, Device %p, Irp %p, GuiIndex %d\n"
             "      BufferSize %#x Buffer %p\n",
             DeviceObject, Irp,
             GuidIndex, BufferSize, Buffer));

    if (GuidIndex == ScsiInfoExceptionsGuid)
    {
        PSTORAGE_SCSI_INFO_EXCEPTIONS infoExceptions;
        MODE_INFO_EXCEPTIONS modeInfo;

        if (BufferSize >= sizeof(STORAGE_SCSI_INFO_EXCEPTIONS))
        {
            infoExceptions = (PSTORAGE_SCSI_INFO_EXCEPTIONS)Buffer;

            modeInfo.PageCode = MODE_PAGE_FAULT_REPORTING;
            modeInfo.PageLength = sizeof(MODE_INFO_EXCEPTIONS) - 2;

            modeInfo.PSBit = 0;
            modeInfo.Flags = infoExceptions->Flags;
            
            modeInfo.ReportMethod = infoExceptions->MRIE;

            REVERSE_BYTES(&modeInfo.IntervalTimer[0],
                          &infoExceptions->IntervalTimer);
            
            REVERSE_BYTES(&modeInfo.ReportCount[0],
                          &infoExceptions->ReportCount);

            if (modeInfo.Perf == 1)
            {
                diskData->AllowFPPerfHit = FALSE;
            } else {
                diskData->AllowFPPerfHit = TRUE;
            }
            
            status = DiskSetInfoExceptionInformation(fdoExtension,
                                                     &modeInfo);
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        
    } else if (GuidIndex <= SmartEventGuid)
    {
        status = STATUS_WMI_READ_ONLY;
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    DebugPrint((3, "Disk: DiskSetWmiDataBlock Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return status;
}

NTSTATUS
DiskFdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((3, "Disk: DiskSetWmiDataItem, Device %p, Irp %p, GuiIndex %d, DataId %d\n"
             "      BufferSize %#x Buffer %p\n",
             DeviceObject, Irp,
             GuidIndex, DataItemId, BufferSize, Buffer));

    if (GuidIndex <= SmartEventGuid)
    {
        status = STATUS_WMI_READ_ONLY;
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    DebugPrint((3, "Disk: DiskSetWmiDataItem Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return status;
}


NTSTATUS
DiskFdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    ULONG sizeNeeded;
    NTSTATUS status;

    PAGED_CODE();

    DebugPrint((3, "Disk: DiskExecuteWmiMethod, DeviceObject %p, Irp %p, Guid Id %d, MethodId %d\n"
             "      InBufferSize %#x, OutBufferSize %#x, Buffer %p\n",
             DeviceObject, Irp,
             GuidIndex, MethodId, InBufferSize, OutBufferSize, Buffer));

    switch(GuidIndex)
    {
        case SmartPerformFunction:
        {

            ASSERT((diskData->FailurePredictionCapability ==
                                                  FailurePredictionSmart) ||
                   (diskData->FailurePredictionCapability ==
                                                  FailurePredictionIoctl) ||
                   (diskData->FailurePredictionCapability ==
                                                  FailurePredictionSense));


            switch(MethodId)
            {
                //
                // void AllowPerformanceHit([in] boolean Allow)
                //
                case AllowDisallowPerformanceHit:
                {
                    BOOLEAN allowPerfHit;

                    sizeNeeded = 0;
                    if (InBufferSize >= sizeof(BOOLEAN))
                    {
                        status = STATUS_SUCCESS;

                        allowPerfHit = *((PBOOLEAN)Buffer);
                        if (diskData->AllowFPPerfHit !=  allowPerfHit)
                        {
                            diskData->AllowFPPerfHit = allowPerfHit;
                            if (diskData->FailurePredictionCapability ==
                                FailurePredictionSense)
                            {
                                MODE_INFO_EXCEPTIONS modeInfo;

                                status = DiskGetInfoExceptionInformation(fdoExtension,
                                                                         &modeInfo);
                                if (NT_SUCCESS(status))
                                {
                                    modeInfo.Perf = allowPerfHit ? 0 : 1;
                                    status = DiskSetInfoExceptionInformation(fdoExtension,
                                                                             &modeInfo);
                                }
                            }
                        }

                        DebugPrint((3, "DiskFdoWmiExecuteMethod: AllowPerformanceHit %x for device %p --> %lx\n",
                                    allowPerfHit,
                                    fdoExtension->DeviceObject,
                                    status));
                    } else {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    break;
                }

                //
                // void EnableDisableHardwareFailurePrediction([in] boolean Enable)
                //
                case EnableDisableHardwareFailurePrediction:
                {
                    BOOLEAN enable;

                    sizeNeeded = 0;
                    if (InBufferSize >= sizeof(BOOLEAN))
                    {
                        status = STATUS_SUCCESS;
                        enable = *((PBOOLEAN)Buffer);
                        if (! enable)
                        {
                            //
                            // If we are disabling we need to also disable
                            // polling
                            //
                            DiskEnableDisableFailurePredictPolling(
                                                               fdoExtension,
                                                               enable,
                                                               0);
                        }

                        status = DiskEnableDisableFailurePrediction(
                                                           fdoExtension,
                                                           enable);

                        DebugPrint((3, "DiskFdoWmiExecuteMethod: EnableDisableHardwareFailurePrediction: %x for device %p --> %lx\n",
                                    enable,
                                    fdoExtension->DeviceObject,
                                    status));
                    } else {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    break;
                }

                //
                // void EnableDisableFailurePredictionPolling(
                //                               [in] uint32 Period,
                //                               [in] boolean Enable)
                //
                case EnableDisableFailurePredictionPolling:
                {
                    BOOLEAN enable;
                    ULONG period;

                    sizeNeeded = 0;
                    if (InBufferSize >= (sizeof(ULONG) + sizeof(BOOLEAN)))
                    {
                        period = *((PULONG)Buffer);
                        Buffer += sizeof(ULONG);
                        enable = *((PBOOLEAN)Buffer);

                           status = DiskEnableDisableFailurePredictPolling(
                                                               fdoExtension,
                                                               enable,
                                                               period);

                        DebugPrint((3, "DiskFdoWmiExecuteMethod: EnableDisableFailurePredictionPolling: %x %x for device %p --> %lx\n",
                                    enable,
                                    period,
                                    fdoExtension->DeviceObject,
                                    status));
                    } else {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    break;
                }

                //
                // void GetFailurePredictionCapability([out] uint32 Capability)
                //
                case GetFailurePredictionCapability:
                {
                    sizeNeeded = sizeof(ULONG);
                    if (OutBufferSize >= sizeNeeded)
                    {
                        status = STATUS_SUCCESS;
                        *((PFAILURE_PREDICTION_METHOD)Buffer) = diskData->FailurePredictionCapability;
                        DebugPrint((3, "DiskFdoWmiExecuteMethod: GetFailurePredictionCapability: %x for device %p --> %lx\n",
                                    *((PFAILURE_PREDICTION_METHOD)Buffer),
                                    fdoExtension->DeviceObject,
                                    status));
                    } else {
                        status = STATUS_BUFFER_TOO_SMALL;
                    }
                    break;
                }

                //
                // void EnableOfflineDiags([out] boolean Success);
                //
                case EnableOfflineDiags:
                {
                    sizeNeeded = sizeof(BOOLEAN);
                    if (OutBufferSize >= sizeNeeded)
                    {
                        if (diskData->FailurePredictionCapability ==
                                  FailurePredictionSmart)
                        {
                            //
                            // Initiate or resume offline diagnostics.
                            // This may cause a loss of performance
                            // to the disk, but mayincrease the amount
                            // of disk checking.
                            //
                            status = DiskExecuteSmartDiagnostics(fdoExtension,
                                                                0);

                        } else {
                            status = STATUS_INVALID_DEVICE_REQUEST;
                        }

                        *((PBOOLEAN)Buffer) = NT_SUCCESS(status);

                        DebugPrint((3, "DiskFdoWmiExecuteMethod: EnableOfflineDiags for device %p --> %lx\n",
                                    fdoExtension->DeviceObject,
                                    status));
                    } else {
                        status = STATUS_BUFFER_TOO_SMALL;
                    }
                    break;
                }

                //
                //    void ReadLogSectors([in] uint8 LogAddress,
                //        [in] uint8 SectorCount,
                //        [out] uint32 Length,
                //        [out, WmiSizeIs("Length")] uint8 LogSectors[]
                //       );
                //
                case ReadLogSectors:
                {
                    if (diskData->FailurePredictionCapability ==
                                  FailurePredictionSmart)
                    {
                        if (InBufferSize >= sizeof(READ_LOG_SECTORS_IN))
                        {
                            PREAD_LOG_SECTORS_IN inParams;
                            PREAD_LOG_SECTORS_OUT outParams;
                            ULONG readSize;

                            inParams = (PREAD_LOG_SECTORS_IN)Buffer;
                            readSize = inParams->SectorCount * SMART_LOG_SECTOR_SIZE;
                            sizeNeeded = FIELD_OFFSET(READ_LOG_SECTORS_OUT,
                                                  LogSectors) + readSize;
                                                  
                            if (OutBufferSize >= sizeNeeded)
                            {
                                outParams = (PREAD_LOG_SECTORS_OUT)Buffer;
                                status = DiskReadSmartLog(fdoExtension,
                                                        inParams->SectorCount,
                                                        inParams->LogAddress,
                                                        outParams->LogSectors);

                                if (NT_SUCCESS(status))
                                {
                                    outParams->Length = readSize;
                                } else {
                                    //
                                    // SMART command failure is
                                    // indicated by successful
                                    // execution, but no data returned
                                    //
                                    outParams->Length = 0;
                                    status = STATUS_SUCCESS;
                                }
                            } else {
                                status = STATUS_BUFFER_TOO_SMALL;
                            }
                            
                        } else {
                            status = STATUS_INVALID_PARAMETER;
                        }
                    } else {
                        status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;
                }

                //    void WriteLogSectors([in] uint8 LogAddress,
                //        [in] uint8 SectorCount,
                //        [in] uint32 Length,
                //        [in, WmiSizeIs("Length")] uint8 LogSectors[],
                //        [out] boolean Success
                //       );
                case WriteLogSectors:
                {
                    if (diskData->FailurePredictionCapability ==
                                  FailurePredictionSmart)
                    {
                        if (InBufferSize >= FIELD_OFFSET(WRITE_LOG_SECTORS_IN,
                                                        LogSectors))
                        {
                            PWRITE_LOG_SECTORS_IN inParams;
                            PWRITE_LOG_SECTORS_OUT outParams;
                            ULONG writeSize;

                            inParams = (PWRITE_LOG_SECTORS_IN)Buffer;
                            writeSize = inParams->SectorCount * SMART_LOG_SECTOR_SIZE;
                            if (InBufferSize >= (FIELD_OFFSET(WRITE_LOG_SECTORS_IN,
                                                             LogSectors) +
                                                 writeSize))
                            {
                                sizeNeeded = sizeof(WRITE_LOG_SECTORS_OUT);
                                                  
                                if (OutBufferSize >= sizeNeeded)
                                {
                                    outParams = (PWRITE_LOG_SECTORS_OUT)Buffer;
                                    status = DiskWriteSmartLog(fdoExtension,
                                                        inParams->SectorCount,
                                                        inParams->LogAddress,
                                                        inParams->LogSectors);

                                    if (NT_SUCCESS(status))
                                    {
                                        outParams->Success = TRUE;
                                    } else {
                                        outParams->Success = FALSE;
                                        status = STATUS_SUCCESS;
                                    }                                   
                                } else {
                                    status = STATUS_BUFFER_TOO_SMALL;
                                }
                            } else {
                                status = STATUS_INVALID_PARAMETER;
                            }                           
                        } else {
                            status = STATUS_INVALID_PARAMETER;
                        }
                    } else {
                        status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;
                }

                //    void ExecuteSelfTest([in] uint8 Subcommand,
                //         [out, 
                //          Values{"0", "1", "2"},
                //          ValueMap{"Successful Completion",
                //                   "Captive Mode Required",
                //                   "Unsuccessful Completion"}
                //         ]
                //         uint32 ReturnCode);
                case ExecuteSelfTest:
                {
                    if (diskData->FailurePredictionCapability ==
                              FailurePredictionSmart)
                    {
                        if (InBufferSize >= sizeof(EXECUTE_SELF_TEST_IN))
                        {
                            sizeNeeded = sizeof(EXECUTE_SELF_TEST_OUT);
                            if (OutBufferSize >= sizeNeeded)
                            {
                                PEXECUTE_SELF_TEST_IN inParam;
                                PEXECUTE_SELF_TEST_OUT outParam;

                                inParam = (PEXECUTE_SELF_TEST_IN)Buffer;
                                outParam = (PEXECUTE_SELF_TEST_OUT)Buffer;

                                if (DiskIsValidSmartSelfTest(inParam->Subcommand))
                                {
                                   status = DiskExecuteSmartDiagnostics(fdoExtension,
                                                            inParam->Subcommand);
                                   if (NT_SUCCESS(status))
                                   {
                                       //
                                       // Return self test executed
                                       // without a problem
                                       //
                                       outParam->ReturnCode = 0;
                                   } else {
                                       //
                                       // Return Self test execution
                                       // failed status
                                       //
                                       outParam->ReturnCode = 2;
                                       status = STATUS_SUCCESS;
                                   }
                                } else {
                                    //
                                    // If self test subcommand requires
                                    // captive mode then return that
                                    // status
                                    //
                                    outParam->ReturnCode = 1;
                                    status = STATUS_SUCCESS;
                                }

                            } else {
                                status = STATUS_BUFFER_TOO_SMALL;
                            }
                            
                        } else {
                            status = STATUS_INVALID_PARAMETER;
                        }
                    } else {
                        status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                            
                    break;
                }

                default :
                {
                    sizeNeeded = 0;
                    status = STATUS_WMI_ITEMID_NOT_FOUND;
                    break;
                }
            }

            break;
        }

        case DiskGeometryGuid:
        case SmartStatusGuid:
        case SmartDataGuid:
        {

            sizeNeeded = 0;
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        default:
        {
            sizeNeeded = 0;
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }

    DebugPrint((3, "Disk: DiskExecuteMethod Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return status;
}


#if 0
//
// Enable this to add WMI support for PDOs
NTSTATUS
DiskPdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.


Return Value:

    status

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION parentFunctionalExtension;
    ANSI_STRING ansiString;
    CHAR name[256];
    NTSTATUS status;

    //
    // We need to pick a name for PDOs since they do not have a devnode
    parentFunctionalExtension = commonExtension->PartitionZeroExtension;
    sprintf(name,
                "Disk(%d)_Partition(%d)_Start(%#I64x)_Length(%#I64x)",
                parentFunctionalExtension->DeviceNumber,
                commonExtension->PartitionNumber,
                commonExtension->StartingOffset.QuadPart,
                commonExtension->PartitionLength.QuadPart);
    RtlInitAnsiString(&ansiString,
                          name);

    status = RtlAnsiStringToUnicodeString(InstanceName,
                                     &ansiString,
                                     TRUE);

    return status;
}

NTSTATUS
DiskPdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = (PDISK_DATA)(commonExtension->DriverData);
    ULONG sizeNeeded;

    DebugPrint((3, "Disk: DiskQueryWmiDataBlock, Device %p, Irp %p, GuiIndex %d\n"
             "      BufferAvail %#x Buffer %p\n",
             DeviceObject, Irp,
             GuidIndex, BufferAvail, Buffer));

    switch (GuidIndex)
    {
        case 0:
        {
            sizeNeeded = 4 * sizeof(ULONG);
            if (BufferAvail >= sizeNeeded)
            {
                RtlCopyMemory(Buffer, DiskDummyData, sizeNeeded);
                status = STATUS_SUCCESS;
            } else {
                status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }

    DebugPrint((3, "Disk: DiskQueryWmiDataBlock Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return status;
}

NTSTATUS
DiskPdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    ULONG sizeNeeded;

    DebugPrint((3, "Disk: DiskSetWmiDataBlock, Device %p, Irp %p, GuiIndex %d\n"
             "      BufferSize %#x Buffer %p\n",
             DeviceObject, Irp,
             GuidIndex, BufferSize, Buffer));

    switch(GuidIndex)
    {
        case 0:
        {
            sizeNeeded = 4 * sizeof(ULONG);
            if (BufferSize == sizeNeeded)
              {
                RtlCopyMemory(DiskDummyData, Buffer, sizeNeeded);
                status = STATUS_SUCCESS;
               } else {
                status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }

    DebugPrint((3, "Disk: DiskSetWmiDataBlock Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return status;
}

NTSTATUS
DiskPdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    NTSTATUS status;

    DebugPrint((3, "Disk: DiskSetWmiDataItem, Device %p, Irp %p, GuiIndex %d, DataId %d\n"
             "      BufferSize %#x Buffer %p\n",
             DeviceObject, Irp,
             GuidIndex, DataItemId, BufferSize, Buffer));

    switch(GuidIndex)
    {
        case 0:
        {
            if ((BufferSize == sizeof(ULONG)) &&
                (DataItemId <= 3))
              {
                  DiskDummyData[DataItemId] = *((PULONG)Buffer);
                   status = STATUS_SUCCESS;
               } else {
                   status = STATUS_INVALID_DEVICE_REQUEST;
               }
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }


    DebugPrint((3, "Disk: DiskSetWmiDataItem Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return status;
}


NTSTATUS
DiskPdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
{
    ULONG sizeNeeded = 4 * sizeof(ULONG);
    NTSTATUS status;
    ULONG tempData[4];

    DebugPrint((3, "Disk: DiskExecuteWmiMethod, DeviceObject %p, Irp %p, Guid Id %d, MethodId %d\n"
             "      InBufferSize %#x, OutBufferSize %#x, Buffer %p\n",
             DeviceObject, Irp,
             GuidIndex, MethodId, InBufferSize, OutBufferSize, Buffer));

    switch(GuidIndex)
    {
        case 0:
        {
            if (MethodId == 1)
            {
                if (OutBufferSize >= sizeNeeded)
                {

                    if (InBufferSize == sizeNeeded)
                    {
                        RtlCopyMemory(tempData, Buffer, sizeNeeded);
                        RtlCopyMemory(Buffer, DiskDummyData, sizeNeeded);
                        RtlCopyMemory(DiskDummyData, tempData, sizeNeeded);

                        status = STATUS_SUCCESS;
                    } else {
                        status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                } else {
                    status = STATUS_BUFFER_TOO_SMALL;
                }
            } else {
                   status = STATUS_INVALID_DEVICE_REQUEST;
            }
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }

    DebugPrint((3, "Disk: DiskExecuteMethod Device %p, Irp %p returns %lx\n",
             DeviceObject, Irp, status));

    status = ClassWmiCompleteRequest(DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\disk.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    disk.c

Abstract:

    SCSI disk class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "disk.h"

//
// Now instantiate the GUIDs
//

#include "initguid.h"
#include "ntddstor.h"
#include "ntddvol.h"
#include "ioevent.h"


NTSTATUS
DiskDetermineMediaTypes(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP     Irp,
    IN UCHAR    MediumType,
    IN UCHAR    DensityCode,
    IN BOOLEAN  MediaPresent,
    IN BOOLEAN  IsWritable
    );

PPARTITION_INFORMATION_EX
DiskPdoFindPartitionEntry(
    IN PPHYSICAL_DEVICE_EXTENSION Pdo,
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo
    );

PPARTITION_INFORMATION_EX
DiskFindAdjacentPartition(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo,
    IN PPARTITION_INFORMATION_EX BasePartition
    );

PPARTITION_INFORMATION_EX
DiskFindContainingPartition(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo,
    IN PPARTITION_INFORMATION_EX BasePartition,
    IN BOOLEAN SearchTopToBottom
    );

NTSTATUS
DiskIoctlCreateDisk(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlGetDriveLayout(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlGetDriveLayoutEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlSetDriveLayout(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlSetDriveLayoutEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlGetPartitionInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlGetPartitionInfoEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlGetLengthInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlSetPartitionInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlSetPartitionInfoEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlSetPartitionInfoEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskIoctlGetDriveGeometryEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, DiskUnload)
#pragma alloc_text(PAGE, DiskCreateFdo)
#pragma alloc_text(PAGE, DiskDetermineMediaTypes)
#pragma alloc_text(PAGE, DiskModeSelect)
#pragma alloc_text(PAGE, DisableWriteCache)
#pragma alloc_text(PAGE, DiskIoctlVerify)
#pragma alloc_text(PAGE, DiskSetSpecialHacks)
#pragma alloc_text(PAGE, DiskScanRegistryForSpecial)
#pragma alloc_text(PAGE, DiskQueryPnpCapabilities)
#pragma alloc_text(PAGE, DiskGetCacheInformation)
#pragma alloc_text(PAGE, DiskSetCacheInformation)
#pragma alloc_text(PAGE, DiskLogCacheInformation)
#pragma alloc_text(PAGE, DiskSetInfoExceptionInformation)
#pragma alloc_text(PAGE, DiskGetInfoExceptionInformation)

#pragma alloc_text(PAGE, DiskPdoFindPartitionEntry)
#pragma alloc_text(PAGE, DiskFindAdjacentPartition)
#pragma alloc_text(PAGE, DiskFindContainingPartition)

#pragma alloc_text(PAGE, DiskIoctlCreateDisk)
#pragma alloc_text(PAGE, DiskIoctlGetDriveLayout)
#pragma alloc_text(PAGE, DiskIoctlGetDriveLayoutEx)
#pragma alloc_text(PAGE, DiskIoctlSetDriveLayout)
#pragma alloc_text(PAGE, DiskIoctlSetDriveLayoutEx)
#pragma alloc_text(PAGE, DiskIoctlGetPartitionInfo)
#pragma alloc_text(PAGE, DiskIoctlGetPartitionInfoEx)
#pragma alloc_text(PAGE, DiskIoctlGetLengthInfo)
#pragma alloc_text(PAGE, DiskIoctlSetPartitionInfo)
#pragma alloc_text(PAGE, DiskIoctlSetPartitionInfoEx)
#pragma alloc_text(PAGE, DiskIoctlGetDriveGeometryEx)
#endif

extern ULONG DiskDisableGpt;

const GUID GUID_NULL = { 0 };
#define DiskCompareGuid(_First,_Second) \
    (memcmp ((_First),(_Second), sizeof (GUID)))

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN  CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_READ_ACCESS)


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine initializes the SCSI hard disk class driver.

Arguments:

    DriverObject - Pointer to driver object created by system.

    RegistryPath - Pointer to the name of the services node for this driver.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    CLASS_INIT_DATA InitializationData;
    CLASS_QUERY_WMI_REGINFO_EX_LIST classQueryWmiRegInfoExList;
    GUID guidQueryRegInfoEx = GUID_CLASSPNP_QUERY_REGINFOEX;

    NTSTATUS status;

#if defined(_X86_)
    //
    // Read the information NtDetect squirreled away about the disks in this
    // system.
    //

    status = DiskSaveDetectInfo(DriverObject);

    if(!NT_SUCCESS(status)) {
        DebugPrint((1, "Disk: couldn't save NtDetect information (%#08lx)\n",
                    status));
    }
#endif

    //
    // Zero InitData
    //

    RtlZeroMemory (&InitializationData, sizeof(CLASS_INIT_DATA));

    InitializationData.InitializationDataSize = sizeof(CLASS_INIT_DATA);

    //
    // Setup sizes and entry points for functional device objects
    //

    InitializationData.FdoData.DeviceExtensionSize = FUNCTIONAL_EXTENSION_SIZE;
    InitializationData.FdoData.DeviceType = FILE_DEVICE_DISK;
    InitializationData.FdoData.DeviceCharacteristics = FILE_DEVICE_SECURE_OPEN;

    InitializationData.FdoData.ClassInitDevice = DiskInitFdo;
    InitializationData.FdoData.ClassStartDevice = DiskStartFdo;
    InitializationData.FdoData.ClassStopDevice = DiskStopDevice;
    InitializationData.FdoData.ClassRemoveDevice = DiskRemoveDevice;
    InitializationData.FdoData.ClassPowerDevice = ClassSpinDownPowerHandler;

    InitializationData.FdoData.ClassError = DiskFdoProcessError;
    InitializationData.FdoData.ClassReadWriteVerification = DiskReadWriteVerification;
    InitializationData.FdoData.ClassDeviceControl = DiskDeviceControl;
    InitializationData.FdoData.ClassShutdownFlush = DiskShutdownFlush;
    InitializationData.FdoData.ClassCreateClose = NULL;

    //
    // Setup sizes and entry points for physical device objects
    //

    InitializationData.PdoData.DeviceExtensionSize = PHYSICAL_EXTENSION_SIZE;
    InitializationData.PdoData.DeviceType = FILE_DEVICE_DISK;
    InitializationData.PdoData.DeviceCharacteristics = FILE_DEVICE_SECURE_OPEN;

    InitializationData.PdoData.ClassInitDevice = DiskInitPdo;
    InitializationData.PdoData.ClassStartDevice = DiskStartPdo;
    InitializationData.PdoData.ClassStopDevice = DiskStopDevice;
    InitializationData.PdoData.ClassRemoveDevice = DiskRemoveDevice;

    //
    // Use default power routine for PDOs
    //

    InitializationData.PdoData.ClassPowerDevice = NULL;

    InitializationData.PdoData.ClassError = NULL;
    InitializationData.PdoData.ClassReadWriteVerification = DiskReadWriteVerification;
    InitializationData.PdoData.ClassDeviceControl = DiskDeviceControl;
    InitializationData.PdoData.ClassShutdownFlush = DiskShutdownFlush;
    InitializationData.PdoData.ClassCreateClose = NULL;

    InitializationData.PdoData.ClassDeviceControl = DiskDeviceControl;

    InitializationData.PdoData.ClassQueryPnpCapabilities = DiskQueryPnpCapabilities;

    InitializationData.ClassAddDevice = DiskAddDevice;
    InitializationData.ClassEnumerateDevice = DiskEnumerateDevice;

    InitializationData.ClassQueryId = DiskQueryId;


    InitializationData.FdoData.ClassWmiInfo.GuidCount = 7;
    InitializationData.FdoData.ClassWmiInfo.GuidRegInfo = DiskWmiFdoGuidList;
    InitializationData.FdoData.ClassWmiInfo.ClassQueryWmiRegInfo = DiskFdoQueryWmiRegInfo;
    InitializationData.FdoData.ClassWmiInfo.ClassQueryWmiDataBlock = DiskFdoQueryWmiDataBlock;
    InitializationData.FdoData.ClassWmiInfo.ClassSetWmiDataBlock = DiskFdoSetWmiDataBlock;
    InitializationData.FdoData.ClassWmiInfo.ClassSetWmiDataItem = DiskFdoSetWmiDataItem;
    InitializationData.FdoData.ClassWmiInfo.ClassExecuteWmiMethod = DiskFdoExecuteWmiMethod;
    InitializationData.FdoData.ClassWmiInfo.ClassWmiFunctionControl = DiskWmiFunctionControl;


#if 0
    //
    // Enable this to add WMI support for PDOs
    InitializationData.PdoData.ClassWmiInfo.GuidCount = 1;
    InitializationData.PdoData.ClassWmiInfo.GuidRegInfo = DiskWmiPdoGuidList;
    InitializationData.PdoData.ClassWmiInfo.ClassQueryWmiRegInfo = DiskPdoQueryWmiRegInfo;
    InitializationData.PdoData.ClassWmiInfo.ClassQueryWmiDataBlock = DiskPdoQueryWmiDataBlock;
    InitializationData.PdoData.ClassWmiInfo.ClassSetWmiDataBlock = DiskPdoSetWmiDataBlock;
    InitializationData.PdoData.ClassWmiInfo.ClassSetWmiDataItem = DiskPdoSetWmiDataItem;
    InitializationData.PdoData.ClassWmiInfo.ClassExecuteWmiMethod = DiskPdoExecuteWmiMethod;
    InitializationData.PdoData.ClassWmiInfo.ClassWmiFunctionControl = DiskWmiFunctionControl;
#endif

    InitializationData.ClassUnload = DiskUnload;

    //
    // Initialize regregistration data structures
    //

    DiskInitializeReregistration();

    //
    // Call the class init routine
    //

    status = ClassInitialize( DriverObject, RegistryPath, &InitializationData);

#if defined(_X86_)
    if(NT_SUCCESS(status)) {
        IoRegisterBootDriverReinitialization(DriverObject,
                                             DiskDriverReinitialization,
                                             NULL);
    }
#endif

    //
    // Call class init Ex routine to register a
    // PCLASS_QUERY_WMI_REGINFO_EX routine
    //
    RtlZeroMemory(&classQueryWmiRegInfoExList, sizeof(CLASS_QUERY_WMI_REGINFO_EX_LIST));
    classQueryWmiRegInfoExList.Size = sizeof(CLASS_QUERY_WMI_REGINFO_EX_LIST);
    classQueryWmiRegInfoExList.ClassFdoQueryWmiRegInfoEx = DiskFdoQueryWmiRegInfoEx;

    ClassInitializeEx(DriverObject,
                      &guidQueryRegInfoEx,
                      &classQueryWmiRegInfoExList);

    return status;

} // end DriverEntry()


VOID
DiskUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();

#if defined(_X86_)
    DiskCleanupDetectInfo(DriverObject);
#endif
    return;
}


NTSTATUS
DiskCreateFdo(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PULONG DeviceCount,
    IN BOOLEAN DasdAccessOnly
    )

/*++

Routine Description:

    This routine creates an object for the functional device

Arguments:

    DriverObject - Pointer to driver object created by system.

    PhysicalDeviceObject - Lower level driver we should attach to

    DeviceCount  - Number of previously installed devices.

    DasdAccessOnly - indicates whether or not a file system is allowed to mount
                     on this device object.  Used to avoid double-mounting of
                     file systems on super-floppies (which can unfortunately be
                     fixed disks).  If set the i/o system will only allow rawfs
                     to be mounted.

Return Value:

    NTSTATUS

--*/

{
    CCHAR          ntNameBuffer[MAXIMUM_FILENAME_LENGTH];
    STRING         ntNameString;
    UNICODE_STRING ntUnicodeString;

    PUCHAR         deviceName = NULL;

    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE         handle;

    NTSTATUS       status;

    PDEVICE_OBJECT lowerDevice = NULL;
    PDEVICE_OBJECT deviceObject = NULL;

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    STORAGE_PROPERTY_ID propertyId;
    PSTORAGE_DEVICE_DESCRIPTOR deviceDescriptor;

    PAGED_CODE();

    *DeviceCount = 0;

    //
    // Set up an object directory to contain the objects for this
    // device and all its partitions.
    //

    do {

        WCHAR buffer[64];
        UNICODE_STRING unicodeDirectoryName;

        swprintf(buffer, L"\\Device\\Harddisk%d", *DeviceCount);

        RtlInitUnicodeString(&unicodeDirectoryName, buffer);

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeDirectoryName,
                                   OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                                   NULL,
                                   NULL);

        status = ZwCreateDirectoryObject(&handle,
                                         DIRECTORY_ALL_ACCESS,
                                         &objectAttributes);

        (*DeviceCount)++;

    } while((status == STATUS_OBJECT_NAME_COLLISION) ||
            (status == STATUS_OBJECT_NAME_EXISTS));

    if (!NT_SUCCESS(status)) {

        DebugPrint((1, "DiskCreateFdo: Could not create directory - %lx\n",
                    status));

        return(status);
    }

    //
    // When this loop exits the count is inflated by one - fix that.
    //

    (*DeviceCount)--;

    //
    // Claim the device.
    //

    lowerDevice = IoGetAttachedDeviceReference(PhysicalDeviceObject);

    status = ClassClaimDevice(lowerDevice, FALSE);

    if (!NT_SUCCESS(status)) {
        ZwMakeTemporaryObject(handle);
        ZwClose(handle);
        ObDereferenceObject(lowerDevice);
        return status;
    }

    //
    // Create a device object for this device. Each physical disk will
    // have at least one device object. The required device object
    // describes the entire device. Its directory path is
    // \Device\HarddiskN\Partition0, where N = device number.
    //

    status = DiskGenerateDeviceName(TRUE,
                                    *DeviceCount,
                                    0,
                                    NULL,
                                    NULL,
                                    &deviceName);

    if(!NT_SUCCESS(status)) {
        DebugPrint((1, "DiskCreateFdo - couldn't create name %lx\n",
                       status));

        goto DiskCreateFdoExit;

    }

    status = ClassCreateDeviceObject(DriverObject,
                                     deviceName,
                                     PhysicalDeviceObject,
                                     TRUE,
                                     &deviceObject);

    if (!NT_SUCCESS(status)) {

        DebugPrint((1,
                    "DiskCreateFdo: Can not create device object %s\n",
                    ntNameBuffer));

        goto DiskCreateFdoExit;
    }

    //
    // Indicate that IRPs should include MDLs for data transfers.
    //

    SET_FLAG(deviceObject->Flags, DO_DIRECT_IO);

    fdoExtension = deviceObject->DeviceExtension;

    if(DasdAccessOnly) {

        //
        // Inidicate that only RAW should be allowed to mount on the root
        // partition object.  This ensures that a file system can't doubly
        // mount on a super-floppy by mounting once on P0 and once on P1.
        //

        SET_FLAG(deviceObject->Vpb->Flags, VPB_RAW_MOUNT);
    }

    //
    // Initialize lock count to zero. The lock count is used to
    // disable the ejection mechanism on devices that support
    // removable media. Only the lock count in the physical
    // device extension is used.
    //

    fdoExtension->LockCount = 0;

    //
    // Save system disk number.
    //

    fdoExtension->DeviceNumber = *DeviceCount;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (lowerDevice->AlignmentRequirement > deviceObject->AlignmentRequirement) {
        deviceObject->AlignmentRequirement = lowerDevice->AlignmentRequirement;
    }

    //
    // Finally, attach to the pdo
    //

    fdoExtension->LowerPdo = PhysicalDeviceObject;

    fdoExtension->CommonExtension.LowerDeviceObject =
        IoAttachDeviceToDeviceStack(
            deviceObject,
            PhysicalDeviceObject);

    if(fdoExtension->CommonExtension.LowerDeviceObject == NULL) {

        //
        // Uh - oh, we couldn't attach
        // cleanup and return
        //

        status = STATUS_UNSUCCESSFUL;
        goto DiskCreateFdoExit;
    }

    {
        PDISK_DATA diskData = fdoExtension->CommonExtension.DriverData;

        //
        // Initialize the partitioning lock as it may be used in the remove
        // code.
        //

        KeInitializeEvent(&(diskData->PartitioningEvent),
                          SynchronizationEvent,
                          TRUE);
    }


    //
    // Clear the init flag.
    //

    CLEAR_FLAG(deviceObject->Flags, DO_DEVICE_INITIALIZING);

    //
    // Store a handle to the device object directory for this disk
    //

    fdoExtension->DeviceDirectory = handle;

    ObDereferenceObject(lowerDevice);

    return STATUS_SUCCESS;

DiskCreateFdoExit:

    //
    // Release the device since an error occurred.
    //

    if (deviceObject != NULL) {
        IoDeleteDevice(deviceObject);
    }

    //
    // Delete directory and return.
    //

    if (!NT_SUCCESS(status)) {
        ZwMakeTemporaryObject(handle);
        ZwClose(handle);
    }

    ObDereferenceObject(lowerDevice);

    return(status);
}


NTSTATUS
DiskReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    I/O System entry for read and write requests to SCSI disks.

Arguments:

    DeviceObject - Pointer to driver object created by system.
    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    ULONG transferByteCount = currentIrpStack->Parameters.Read.Length;
    LARGE_INTEGER startingOffset;

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
        commonExtension->PartitionZeroExtension;

    ULONG residualBytes;
    NTSTATUS status;

    //
    // Verify parameters of this request.
    // Check that ending sector is within partition and
    // that number of bytes to transfer is a multiple of
    // the sector size.
    //

    startingOffset.QuadPart =
        (currentIrpStack->Parameters.Read.ByteOffset.QuadPart +
         transferByteCount);

    residualBytes = transferByteCount &
                    (fdoExtension->DiskGeometry.BytesPerSector - 1);


    if ((startingOffset.QuadPart > commonExtension->PartitionLength.QuadPart) ||
        (residualBytes != 0)) {

        //
        // This error may be caused by the fact that the drive is not ready.
        //

        status = ((PDISK_DATA) commonExtension->DriverData)->ReadyStatus;

        if (!NT_SUCCESS(status)) {

            //
            // Flag this as a user errror so that a popup is generated.
            //

            DebugPrint((1, "DiskReadWriteVerification: ReadyStatus is %lx\n",
                        status));

            IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);

            //
            // status will keep the current error
            //

            ASSERT( status != STATUS_INSUFFICIENT_RESOURCES );

        } else if((commonExtension->IsFdo == TRUE) && (residualBytes == 0)) {

            //
            // This failed because we think the physical disk is too small.
            // Send it down to the drive and let the hardware decide for
            // itself.
            //

            status = STATUS_SUCCESS;

        } else {

            //
            // Note fastfat depends on this parameter to determine when to
            // remount due to a sector size change.
            //

            status = STATUS_INVALID_PARAMETER;

        }

    } else {

        //
        // the drive is ready, so ok the read/write
        //

        status = STATUS_SUCCESS;

    }

    Irp->IoStatus.Status = status;
    return status;

} // end DiskReadWrite()



NTSTATUS
DiskDetermineMediaTypes(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP     Irp,
    IN UCHAR    MediumType,
    IN UCHAR    DensityCode,
    IN BOOLEAN  MediaPresent,
    IN BOOLEAN  IsWritable
    )

/*++

Routine Description:

    Determines number of types based on the physical device, validates the user buffer
    and builds the MEDIA_TYPE information.

Arguments:

    DeviceObject - Pointer to functional device object created by system.
    Irp - IOCTL_STORAGE_GET_MEDIA_TYPES_EX Irp.
    MediumType - byte returned in mode data header.
    DensityCode - byte returned in mode data block descriptor.
    NumberOfTypes - pointer to be updated based on actual device.

Return Value:

    Status is returned.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION   commonExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION         irpStack = IoGetCurrentIrpStackLocation(Irp);

    PGET_MEDIA_TYPES  mediaTypes = Irp->AssociatedIrp.SystemBuffer;
    PDEVICE_MEDIA_INFO mediaInfo = &mediaTypes->MediaInfo[0];
    BOOLEAN deviceMatched = FALSE;

    PAGED_CODE();

    //
    // this should be checked prior to calling into this routine
    // as we use the buffer as mediaTypes
    //
    ASSERT(irpStack->Parameters.DeviceIoControl.OutputBufferLength >=
           sizeof(GET_MEDIA_TYPES));


    //
    // Determine if this device is removable or fixed.
    //

    if (!TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)) {

        //
        // Fixed disk.
        //

        mediaTypes->DeviceType = FILE_DEVICE_DISK;
        mediaTypes->MediaInfoCount = 1;

        mediaInfo->DeviceSpecific.DiskInfo.Cylinders.QuadPart = fdoExtension->DiskGeometry.Cylinders.QuadPart;
        mediaInfo->DeviceSpecific.DiskInfo.TracksPerCylinder = fdoExtension->DiskGeometry.TracksPerCylinder;
        mediaInfo->DeviceSpecific.DiskInfo.SectorsPerTrack = fdoExtension->DiskGeometry.SectorsPerTrack;
        mediaInfo->DeviceSpecific.DiskInfo.BytesPerSector = fdoExtension->DiskGeometry.BytesPerSector;
        mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;

        mediaInfo->DeviceSpecific.DiskInfo.MediaCharacteristics = (MEDIA_CURRENTLY_MOUNTED | MEDIA_READ_WRITE);

        if (!IsWritable) {
            SET_FLAG(mediaInfo->DeviceSpecific.DiskInfo.MediaCharacteristics,
                     MEDIA_WRITE_PROTECTED);
        }

        mediaInfo->DeviceSpecific.DiskInfo.MediaType = FixedMedia;


    } else {

        PUCHAR vendorId = (PUCHAR) fdoExtension->DeviceDescriptor + fdoExtension->DeviceDescriptor->VendorIdOffset;
        PUCHAR productId = (PUCHAR) fdoExtension->DeviceDescriptor + fdoExtension->DeviceDescriptor->ProductIdOffset;
        PUCHAR productRevision = (PUCHAR) fdoExtension->DeviceDescriptor + fdoExtension->DeviceDescriptor->ProductRevisionOffset;
        DISK_MEDIA_TYPES_LIST const *mediaListEntry;
        ULONG  currentMedia;
        ULONG  i;
        ULONG  j;
        ULONG  sizeNeeded;

        DebugPrint((1,
                   "DiskDetermineMediaTypes: Vendor %s, Product %s\n",
                   vendorId,
                   productId));

        //
        // Run through the list until we find the entry with a NULL Vendor Id.
        //

        for (i = 0; DiskMediaTypes[i].VendorId != NULL; i++) {

            mediaListEntry = &DiskMediaTypes[i];

            if (strncmp(mediaListEntry->VendorId,vendorId,strlen(mediaListEntry->VendorId))) {
                continue;
            }

            if ((mediaListEntry->ProductId != NULL) &&
                 strncmp(mediaListEntry->ProductId, productId, strlen(mediaListEntry->ProductId))) {
                continue;
            }

            if ((mediaListEntry->Revision != NULL) &&
                 strncmp(mediaListEntry->Revision, productRevision, strlen(mediaListEntry->Revision))) {
                continue;
            }

            deviceMatched = TRUE;

            mediaTypes->DeviceType = FILE_DEVICE_DISK;
            mediaTypes->MediaInfoCount = mediaListEntry->NumberOfTypes;

            //
            // Ensure that buffer is large enough.
            //

            sizeNeeded = FIELD_OFFSET(GET_MEDIA_TYPES, MediaInfo[0]) +
                         (mediaListEntry->NumberOfTypes *
                          sizeof(DEVICE_MEDIA_INFO)
                          );

            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeNeeded) {

                //
                // Buffer too small
                //

                Irp->IoStatus.Information = sizeNeeded;
                Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
                return STATUS_BUFFER_TOO_SMALL;
            }

            for (j = 0; j < mediaListEntry->NumberOfTypes; j++) {

                mediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = fdoExtension->DiskGeometry.Cylinders.QuadPart;
                mediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = fdoExtension->DiskGeometry.TracksPerCylinder;
                mediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = fdoExtension->DiskGeometry.SectorsPerTrack;
                mediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = fdoExtension->DiskGeometry.BytesPerSector;
                mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = mediaListEntry->NumberOfSides;

                //
                // Set the type.
                //

                mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = mediaListEntry->MediaTypes[j];

                if (mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType == MO_5_WO) {
                    mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_WRITE_ONCE;
                } else {
                    mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_READ_WRITE;
                }

                //
                // Status will either be success, if media is present, or no media.
                // It would be optimal to base from density code and medium type, but not all devices
                // have values for these fields.
                //

                if (MediaPresent) {

                    //
                    // The usage of MediumType and DensityCode is device specific, so this may need
                    // to be extended to further key off of product/vendor ids.
                    // Currently, the MO units are the only devices that return this information.
                    //

                    if (MediumType == 2) {
                        currentMedia = MO_5_WO;
                    } else if (MediumType == 3) {
                        currentMedia = MO_5_RW;

                        if (DensityCode == 0x87) {

                            //
                            // Indicate that the pinnacle 4.6 G media
                            // is present. Other density codes will default to normal
                            // RW MO media.
                            //

                            currentMedia = PINNACLE_APEX_5_RW;
                        }
                    } else {
                        currentMedia = 0;
                    }

                    if (currentMedia) {
                        if (mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType == (STORAGE_MEDIA_TYPE)currentMedia) {
                            SET_FLAG(mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics, MEDIA_CURRENTLY_MOUNTED);
                        }

                    } else {
                        SET_FLAG(mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics, MEDIA_CURRENTLY_MOUNTED);
                    }
                }

                if (!IsWritable) {
                    SET_FLAG(mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics, MEDIA_WRITE_PROTECTED);
                }

                //
                // Advance to next entry.
                //

                mediaInfo++;
            }
        }

        if (!deviceMatched) {

            DebugPrint((1,
                       "DiskDetermineMediaTypes: Unknown device. Vendor: %s Product: %s Revision: %s\n",
                                   vendorId,
                                   productId,
                                   productRevision));
            //
            // Build an entry for unknown.
            //

            mediaInfo->DeviceSpecific.RemovableDiskInfo.Cylinders.QuadPart = fdoExtension->DiskGeometry.Cylinders.QuadPart;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.TracksPerCylinder = fdoExtension->DiskGeometry.TracksPerCylinder;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.SectorsPerTrack = fdoExtension->DiskGeometry.SectorsPerTrack;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.BytesPerSector = fdoExtension->DiskGeometry.BytesPerSector;

            //
            // Set the type.
            //

            mediaTypes->DeviceType = FILE_DEVICE_DISK;
            mediaTypes->MediaInfoCount = 1;

            mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaType = RemovableMedia;
            mediaInfo->DeviceSpecific.RemovableDiskInfo.NumberMediaSides = 1;

            mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics = MEDIA_READ_WRITE;
            if (MediaPresent) {
                SET_FLAG(mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics, MEDIA_CURRENTLY_MOUNTED);
            }

            if (!IsWritable) {
                SET_FLAG(mediaInfo->DeviceSpecific.RemovableDiskInfo.MediaCharacteristics, MEDIA_WRITE_PROTECTED);
            }
        }
    }

    Irp->IoStatus.Information =
        FIELD_OFFSET(GET_MEDIA_TYPES, MediaInfo[0]) +
        (mediaTypes->MediaInfoCount * sizeof(DEVICE_MEDIA_INFO));

    return STATUS_SUCCESS;

}


NTSTATUS
DiskDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    I/O system entry for device controls to SCSI disks.

Arguments:

    Fdo - Pointer to functional device object created by system.
    Irp - IRP involved.

Return Value:

    Status is returned.

--*/

#define SendToFdo(Dev, Irp, Rval)   {                       \
    PCOMMON_DEVICE_EXTENSION ce = Dev->DeviceExtension;     \
    ASSERT_PDO(Dev);                                        \
    IoCopyCurrentIrpStackLocationToNext(Irp);               \
    Rval = IoCallDriver(ce->LowerDeviceObject, Irp);        \
    }

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDISK_DATA             diskData = (PDISK_DATA)(commonExtension->DriverData);
    PSCSI_REQUEST_BLOCK    srb;
    PCDB                   cdb;
    PMODE_PARAMETER_HEADER modeData;
    PIRP                   irp2;
    ULONG                  length;
    NTSTATUS               status;
    KEVENT                 event;
    IO_STATUS_BLOCK        ioStatus;

    BOOLEAN                b = FALSE;

    srb = ExAllocatePoolWithTag(NonPagedPool,
                                SCSI_REQUEST_BLOCK_SIZE,
                                DISK_TAG_SRB);
    Irp->IoStatus.Information = 0;

    if (srb == NULL) {

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Write zeros to Srb.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    cdb = (PCDB)srb->Cdb;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_DISK_GET_CACHE_INFORMATION:
        b = TRUE;
    case IOCTL_DISK_SET_CACHE_INFORMATION: {

        BOOLEAN getCaching = b;
        PDISK_CACHE_INFORMATION cacheInfo = Irp->AssociatedIrp.SystemBuffer;

        if(!commonExtension->IsFdo) {

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        //
        // Validate the request.
        //

        if((getCaching) &&
           (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DISK_CACHE_INFORMATION))
           ) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(DISK_CACHE_INFORMATION);
            break;
        }

        if ((!getCaching) &&
            (irpStack->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(DISK_CACHE_INFORMATION))
           ) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        ASSERT(Irp->AssociatedIrp.SystemBuffer != NULL);

        if (getCaching) {

            status = DiskGetCacheInformation(fdoExtension, cacheInfo);

            if (NT_SUCCESS(status)) {
                Irp->IoStatus.Information = sizeof(DISK_CACHE_INFORMATION);
            }

        } else {

            if (!cacheInfo->WriteCacheEnabled)
            {
                if (TEST_FLAG(fdoExtension->ScanForSpecialFlags,
                              CLASS_SPECIAL_DISABLE_WRITE_CACHE_NOT_SUPPORTED))
                {
                    //
                    // This request wants to disable write cache, which is
                    // not supported on this device. Instead of sending it
                    // down only to see it fail, return the error code now
                    //
                    status = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }
            }
            else
            {
                if (TEST_FLAG(fdoExtension->ScanForSpecialFlags,
                               CLASS_SPECIAL_DISABLE_WRITE_CACHE))
                {
                    //
                    // This request wants to enable write cache, which
                    // has been disabled to protect data integrity. So
                    // fail this request with access denied
                    //
                    status = STATUS_ACCESS_DENIED;
                    break;
                }
            }

            status = DiskSetCacheInformation(fdoExtension, cacheInfo);

            if (NT_SUCCESS(status))
            {
                //
                // Store the user-defined override in the registry
                //
                ClassSetDeviceParameter(fdoExtension,
                                        DiskDeviceParameterSubkey,
                                        DiskDeviceUserWriteCacheSetting,
                                        (cacheInfo->WriteCacheEnabled) ? DiskWriteCacheEnable : DiskWriteCacheDisable);
            }
            else if (status == STATUS_INVALID_DEVICE_REQUEST)
            {
                if (cacheInfo->WriteCacheEnabled == FALSE)
                {
                    //
                    // This device does not allow for
                    // the write cache to be disabled
                    //
                    ULONG specialFlags = 0;

                    ClassGetDeviceParameter(fdoExtension,
                                            DiskDeviceParameterSubkey,
                                            DiskDeviceSpecialFlags,
                                            &specialFlags);

                    SET_FLAG(specialFlags, HackDisableWriteCacheNotSupported);

                    SET_FLAG(fdoExtension->ScanForSpecialFlags,
                             CLASS_SPECIAL_DISABLE_WRITE_CACHE_NOT_SUPPORTED);

                    ClassSetDeviceParameter(fdoExtension,
                                            DiskDeviceParameterSubkey,
                                            DiskDeviceSpecialFlags,
                                            specialFlags);
                }
            }

            DiskLogCacheInformation(fdoExtension, cacheInfo, status);
        }

        break;
    }

    case IOCTL_DISK_GET_WRITE_CACHE_STATE: {

        PDISK_WRITE_CACHE_STATE writeCacheState = (PDISK_WRITE_CACHE_STATE)Irp->AssociatedIrp.SystemBuffer;

        if(!commonExtension->IsFdo) {

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        //
        // Validate the request.
        //

        if(irpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(DISK_WRITE_CACHE_STATE)) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(DISK_WRITE_CACHE_STATE);
            break;
        }

        *writeCacheState = DiskWriteCacheNormal;

        //
        // Determine whether it is possible to disable the write cache
        //

        if (TEST_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_WRITE_CACHE_NOT_SUPPORTED))
        {
            *writeCacheState = DiskWriteCacheDisableNotSupported;
        }

        //
        // Determine whether it is safe to toggle the write cache
        //

        if (TEST_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_WRITE_CACHE))
        {
            *writeCacheState = DiskWriteCacheForceDisable;
        }

        Irp->IoStatus.Information = sizeof(DISK_WRITE_CACHE_STATE);
        status = STATUS_SUCCESS;
        break;
    }

    case SMART_GET_VERSION: {

        PUCHAR buffer;
        PSRB_IO_CONTROL  srbControl;
        PGETVERSIONINPARAMS versionParams;

        if(!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(GETVERSIONINPARAMS)) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(GETVERSIONINPARAMS);
                break;
        }

        //
        // Create notification event object to be used to signal the
        // request completion.
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        srbControl = ExAllocatePoolWithTag(NonPagedPool,
                                           sizeof(SRB_IO_CONTROL) +
                                           sizeof(GETVERSIONINPARAMS),
                                           DISK_TAG_SMART);

        if (!srbControl) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(srbControl,
                      sizeof(SRB_IO_CONTROL) + sizeof(GETVERSIONINPARAMS)
                      );

        //
        // fill in srbControl fields
        //

        srbControl->HeaderLength = sizeof(SRB_IO_CONTROL);
        RtlMoveMemory (srbControl->Signature, "SCSIDISK", 8);
        srbControl->Timeout = fdoExtension->TimeOutValue;
        srbControl->Length = sizeof(GETVERSIONINPARAMS);
        srbControl->ControlCode = IOCTL_SCSI_MINIPORT_SMART_VERSION;

        //
        // Point to the 'buffer' portion of the SRB_CONTROL
        //

        buffer = (PUCHAR)srbControl;
        (ULONG_PTR)buffer += srbControl->HeaderLength;

        //
        // Ensure correct target is set in the cmd parameters.
        //

        versionParams = (PGETVERSIONINPARAMS)buffer;
        versionParams->bIDEDeviceMap = diskData->ScsiAddress.TargetId;

        //
        // Copy the IOCTL parameters to the srb control buffer area.
        //

        RtlMoveMemory(buffer,
                      Irp->AssociatedIrp.SystemBuffer,
                      sizeof(GETVERSIONINPARAMS));

        ClassSendDeviceIoControlSynchronous(
            IOCTL_SCSI_MINIPORT,
            commonExtension->LowerDeviceObject,
            srbControl,
            sizeof(SRB_IO_CONTROL) + sizeof(GETVERSIONINPARAMS),
            sizeof(SRB_IO_CONTROL) + sizeof(GETVERSIONINPARAMS),
            FALSE,
            &ioStatus);

        status = ioStatus.Status;

        //
        // If successful, copy the data received into the output buffer.
        // This should only fail in the event that the IDE driver is older
        // than this driver.
        //

        if (NT_SUCCESS(status)) {

            buffer = (PUCHAR)srbControl;
            (ULONG_PTR)buffer += srbControl->HeaderLength;

            RtlMoveMemory (Irp->AssociatedIrp.SystemBuffer, buffer,
                           sizeof(GETVERSIONINPARAMS));
            Irp->IoStatus.Information = sizeof(GETVERSIONINPARAMS);
        }

        ExFreePool(srbControl);
        break;
    }

    case SMART_RCV_DRIVE_DATA: {

        PSENDCMDINPARAMS cmdInParameters = ((PSENDCMDINPARAMS)Irp->AssociatedIrp.SystemBuffer);
        ULONG            controlCode = 0;
        PSRB_IO_CONTROL  srbControl;
        PUCHAR           buffer;

        if(!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            (sizeof(SENDCMDINPARAMS) - 1)) {
                status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Information = 0;
                break;

        } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            (sizeof(SENDCMDOUTPARAMS) + 512 - 1)) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(SENDCMDOUTPARAMS) + 512 - 1;
                break;
        }

        //
        // Create notification event object to be used to signal the
        // request completion.
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        //
        // use controlCode as a sort of 'STATUS_SUCCESS' to see if it's
        // a valid request type
        //

        if (cmdInParameters->irDriveRegs.bCommandReg == ID_CMD) {

            length = IDENTIFY_BUFFER_SIZE + sizeof(SENDCMDOUTPARAMS);
            controlCode = IOCTL_SCSI_MINIPORT_IDENTIFY;

        } else if (cmdInParameters->irDriveRegs.bCommandReg == SMART_CMD) {
            switch (cmdInParameters->irDriveRegs.bFeaturesReg) {
                case READ_ATTRIBUTES:
                    controlCode = IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS;
                    length = READ_ATTRIBUTE_BUFFER_SIZE + sizeof(SENDCMDOUTPARAMS);
                    break;
                case READ_THRESHOLDS:
                    controlCode = IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS;
                    length = READ_THRESHOLD_BUFFER_SIZE + sizeof(SENDCMDOUTPARAMS);
                    break;
                default:
                    status = STATUS_INVALID_PARAMETER;
                    break;
            }
        } else {

            status = STATUS_INVALID_PARAMETER;
        }

        if (controlCode == 0) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        srbControl = ExAllocatePoolWithTag(NonPagedPool,
                                           sizeof(SRB_IO_CONTROL) + length,
                                           DISK_TAG_SMART);

        if (!srbControl) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // fill in srbControl fields
        //

        srbControl->HeaderLength = sizeof(SRB_IO_CONTROL);
        RtlMoveMemory (srbControl->Signature, "SCSIDISK", 8);
        srbControl->Timeout = fdoExtension->TimeOutValue;
        srbControl->Length = length;
        srbControl->ControlCode = controlCode;

        //
        // Point to the 'buffer' portion of the SRB_CONTROL
        //

        buffer = (PUCHAR)srbControl;
        (ULONG_PTR)buffer += srbControl->HeaderLength;

        //
        // Ensure correct target is set in the cmd parameters.
        //

        cmdInParameters->bDriveNumber = diskData->ScsiAddress.TargetId;

        //
        // Copy the IOCTL parameters to the srb control buffer area.
        //

        RtlMoveMemory(buffer,
                      Irp->AssociatedIrp.SystemBuffer,
                      sizeof(SENDCMDINPARAMS) - 1);

        irp2 = IoBuildDeviceIoControlRequest(IOCTL_SCSI_MINIPORT,
                                            commonExtension->LowerDeviceObject,
                                            srbControl,
                                            sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS) - 1,
                                            srbControl,
                                            sizeof(SRB_IO_CONTROL) + length,
                                            FALSE,
                                            &event,
                                            &ioStatus);

        if (irp2 == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ExFreePool(srbControl);
            break;
        }

        //
        // Call the port driver with the request and wait for it to complete.
        //

        status = IoCallDriver(commonExtension->LowerDeviceObject, irp2);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        //
        // Copy the data received into the output buffer. Since the status buffer
        // contains error information also, always perform this copy. IO will will
        // either pass this back to the app, or zero it, in case of error.
        //

        buffer = (PUCHAR)srbControl;
        (ULONG_PTR)buffer += srbControl->HeaderLength;

        if (NT_SUCCESS(status)) {

            RtlMoveMemory ( Irp->AssociatedIrp.SystemBuffer, buffer, length - 1);
            Irp->IoStatus.Information = length - 1;

        } else {

            RtlMoveMemory ( Irp->AssociatedIrp.SystemBuffer, buffer, (sizeof(SENDCMDOUTPARAMS) - 1));
            Irp->IoStatus.Information = sizeof(SENDCMDOUTPARAMS) - 1;

        }

        ExFreePool(srbControl);
        break;

    }

    case SMART_SEND_DRIVE_COMMAND: {

        PSENDCMDINPARAMS cmdInParameters = ((PSENDCMDINPARAMS)Irp->AssociatedIrp.SystemBuffer);
        PSRB_IO_CONTROL  srbControl;
        ULONG            controlCode = 0;
        PUCHAR           buffer;

        if(!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
               (sizeof(SENDCMDINPARAMS) - 1)) {
                status = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Information = 0;
                break;

        } else if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                      (sizeof(SENDCMDOUTPARAMS) - 1)) {
                status = STATUS_BUFFER_TOO_SMALL;
                Irp->IoStatus.Information = sizeof(SENDCMDOUTPARAMS) - 1;
                break;
        }

        //
        // Create notification event object to be used to signal the
        // request completion.
        //

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        length = 0;

        if (cmdInParameters->irDriveRegs.bCommandReg == SMART_CMD) {
            switch (cmdInParameters->irDriveRegs.bFeaturesReg) {

                case ENABLE_SMART:
                    controlCode = IOCTL_SCSI_MINIPORT_ENABLE_SMART;
                    break;

                case DISABLE_SMART:
                    controlCode = IOCTL_SCSI_MINIPORT_DISABLE_SMART;
                    break;

                case  RETURN_SMART_STATUS:

                    //
                    // Ensure bBuffer is at least 2 bytes (to hold the values of
                    // cylinderLow and cylinderHigh).
                    //

                    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
                        (sizeof(SENDCMDOUTPARAMS) - 1 + sizeof(IDEREGS))) {

                        status = STATUS_BUFFER_TOO_SMALL;
                        Irp->IoStatus.Information =
                            sizeof(SENDCMDOUTPARAMS) - 1 + sizeof(IDEREGS);
                        break;
                    }

                    controlCode = IOCTL_SCSI_MINIPORT_RETURN_STATUS;
                    length = sizeof(IDEREGS);
                    break;

                case ENABLE_DISABLE_AUTOSAVE:
                    controlCode = IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE;
                    break;

                case SAVE_ATTRIBUTE_VALUES:
                    controlCode = IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES;
                    break;

                case EXECUTE_OFFLINE_DIAGS:
                    //
                    // Validate that this is an ok self test command
                    //
                    if (DiskIsValidSmartSelfTest(cmdInParameters->irDriveRegs.bSectorNumberReg))
                    {
                        controlCode = IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS;
                    }
                    break;

                case ENABLE_DISABLE_AUTO_OFFLINE:
                    controlCode = IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE;
                    break;

                default:
                    status = STATUS_INVALID_PARAMETER;
                    break;
            }
        } else {

            status = STATUS_INVALID_PARAMETER;
        }

        if (controlCode == 0) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        length += (sizeof(SENDCMDOUTPARAMS) > sizeof(SENDCMDINPARAMS)) ? sizeof(SENDCMDOUTPARAMS) : sizeof(SENDCMDINPARAMS);;
        srbControl = ExAllocatePoolWithTag(NonPagedPool,
                                           sizeof(SRB_IO_CONTROL) + length,
                                           DISK_TAG_SMART);

        if (!srbControl) {
            status =  STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // fill in srbControl fields
        //

        srbControl->HeaderLength = sizeof(SRB_IO_CONTROL);
        RtlMoveMemory (srbControl->Signature, "SCSIDISK", 8);
        srbControl->Timeout = fdoExtension->TimeOutValue;
        srbControl->Length = length;

        //
        // Point to the 'buffer' portion of the SRB_CONTROL
        //

        buffer = (PUCHAR)srbControl;
        (ULONG_PTR)buffer += srbControl->HeaderLength;

        //
        // Ensure correct target is set in the cmd parameters.
        //

        cmdInParameters->bDriveNumber = diskData->ScsiAddress.TargetId;

        //
        // Copy the IOCTL parameters to the srb control buffer area.
        //

        RtlMoveMemory(buffer, Irp->AssociatedIrp.SystemBuffer, sizeof(SENDCMDINPARAMS) - 1);

        srbControl->ControlCode = controlCode;

        irp2 = IoBuildDeviceIoControlRequest(IOCTL_SCSI_MINIPORT,
                                            commonExtension->LowerDeviceObject,
                                            srbControl,
                                            sizeof(SRB_IO_CONTROL) + sizeof(SENDCMDINPARAMS) - 1,
                                            srbControl,
                                            sizeof(SRB_IO_CONTROL) + length,
                                            FALSE,
                                            &event,
                                            &ioStatus);

        if (irp2 == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            ExFreePool(srbControl);
            break;
        }

        //
        // Call the port driver with the request and wait for it to complete.
        //

        status = IoCallDriver(commonExtension->LowerDeviceObject, irp2);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        //
        // Copy the data received into the output buffer. Since the status buffer
        // contains error information also, always perform this copy. IO will will
        // either pass this back to the app, or zero it, in case of error.
        //

        buffer = (PUCHAR)srbControl;
        (ULONG_PTR)buffer += srbControl->HeaderLength;

        //
        // Update the return buffer size based on the sub-command.
        //

        if (cmdInParameters->irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) {
            length = sizeof(SENDCMDOUTPARAMS) - 1 + sizeof(IDEREGS);
        } else {
            length = sizeof(SENDCMDOUTPARAMS) - 1;
        }

        RtlMoveMemory ( Irp->AssociatedIrp.SystemBuffer, buffer, length);
        Irp->IoStatus.Information = length;

        ExFreePool(srbControl);
        break;

    }

    case IOCTL_STORAGE_GET_MEDIA_TYPES_EX: {

        PMODE_PARAMETER_BLOCK blockDescriptor;
        ULONG modeLength;
        ULONG retries = 4;
        BOOLEAN writable = FALSE;
        BOOLEAN mediaPresent = FALSE;

        DebugPrint((3,
                   "Disk.DiskDeviceControl: GetMediaTypes\n"));

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(GET_MEDIA_TYPES)) {
            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(GET_MEDIA_TYPES);
            break;
        }

        if(!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        //
        // Send a TUR to determine if media is present.
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;
        cdb->CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

        //
        // Set timeout value.
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         FALSE);


        if (NT_SUCCESS(status)) {
            mediaPresent = TRUE;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Allocate memory for mode header and block descriptor.
        //

        modeLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK);
        modeData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                         modeLength,
                                         DISK_TAG_MODE_DATA);

        if (modeData == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(modeData, modeLength);

        //
        // Build the MODE SENSE CDB.
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;

        //
        // Set timeout value from device extension.
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        //
        // Page code of 0 will return header and block descriptor only.
        //

        cdb->MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode = 0;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)modeLength;

Retry:
        status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         modeData,
                                         modeLength,
                                         FALSE);


        if (status == STATUS_VERIFY_REQUIRED) {

            if (retries--) {

                //
                // Retry request.
                //

                goto Retry;
            }
        } else if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
            status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(status) || (status == STATUS_NO_MEDIA_IN_DEVICE)) {

            //
            // Get the block descriptor.
            //

            blockDescriptor = (PMODE_PARAMETER_BLOCK)modeData;
            (ULONG_PTR)blockDescriptor += sizeof(MODE_PARAMETER_HEADER);

            //
            // Do some validation.
            //

            if (modeData->BlockDescriptorLength != sizeof(MODE_PARAMETER_BLOCK)) {

                DebugPrint((1,
                           "DiskDeviceControl: BlockDescriptor length - "
                           "Expected %x, actual %x\n",
                           modeData->BlockDescriptorLength,
                           sizeof(MODE_PARAMETER_BLOCK)));
            }

            DebugPrint((1,
                       "DiskDeviceControl: DensityCode %x, MediumType %x\n",
                       blockDescriptor->DensityCode,
                       modeData->MediumType));

            if (TEST_FLAG(modeData->DeviceSpecificParameter,
                          MODE_DSP_WRITE_PROTECT)) {
                writable = FALSE;
            } else {
                writable = TRUE;
            }

            status = DiskDetermineMediaTypes(DeviceObject,
                                             Irp,
                                             modeData->MediumType,
                                             blockDescriptor->DensityCode,
                                             mediaPresent,
                                             writable);

            //
            // If the buffer was too small, DetermineMediaTypes updated the status and information and the request will fail.
            //

        } else {
            DebugPrint((1,
                       "DiskDeviceControl: Mode sense for header/bd failed. %lx\n",
                       status));
        }

        ExFreePool(modeData);
        break;
    }

    case IOCTL_DISK_GET_DRIVE_GEOMETRY: {

        DebugPrint((2, "IOCTL_DISK_GET_DRIVE_GEOMETRY to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((2, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DISK_GEOMETRY)) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
            break;
        }

        if(!commonExtension->IsFdo) {

            //
            // Pdo should issue this request to the lower device object
            //

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        // DiskAcquirePartitioningLock(fdoExtension);

        if (TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA)) {

            //
            // Issue ReadCapacity to update device extension
            // with information for current media.
            //

            status = DiskReadDriveCapacity(
                        commonExtension->PartitionZeroExtension->DeviceObject);

            //
            // Note whether the drive is ready.
            //

            diskData->ReadyStatus = status;

            if (!NT_SUCCESS(status)) {
                // DiskReleasePartitioningLock(fdoExtension);
                break;
            }
        }

        //
        // Copy drive geometry information from device extension.
        //

        RtlMoveMemory(Irp->AssociatedIrp.SystemBuffer,
                      &(fdoExtension->DiskGeometry),
                      sizeof(DISK_GEOMETRY));

        status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
        // DiskReleasePartitioningLock(fdoExtension);
        break;
    }

    case IOCTL_DISK_GET_DRIVE_GEOMETRY_EX: {
        DebugPrint((1, "IOCTL_DISK_GET_DRIVE_GEOMETRY_EX to device %p through irp %p\n",
                DeviceObject, Irp));
        DebugPrint((1, "Device Is a%s.\n",
                commonExtension->IsFdo ? "n fdo" : " pdo"));


        if (!commonExtension->IsFdo) {

            //
            // Pdo should issue this request to the lower device object
            //

            ClassReleaseRemoveLock (DeviceObject, Irp);
            ExFreePool (srb);
            SendToFdo (DeviceObject, Irp, status);
            return status;

        } else {

            status = DiskIoctlGetDriveGeometryEx( DeviceObject, Irp );
        }

        break;
    }

    case IOCTL_STORAGE_PREDICT_FAILURE : {

        PSTORAGE_PREDICT_FAILURE checkFailure;
        STORAGE_FAILURE_PREDICT_STATUS diskSmartStatus;

        DebugPrint((2, "IOCTL_STORAGE_PREDICT_FAILURE to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((2, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        checkFailure = (PSTORAGE_PREDICT_FAILURE)Irp->AssociatedIrp.SystemBuffer;

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(STORAGE_PREDICT_FAILURE)) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(STORAGE_PREDICT_FAILURE);
            break;
        }

        if(!commonExtension->IsFdo) {

            //
            // Pdo should issue this request to the lower device object
            //

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        //
        // See if the disk is predicting failure
        //

        if (diskData->FailurePredictionCapability == FailurePredictionSense) {
            ULONG readBufferSize;
            PUCHAR readBuffer;
            PIRP readIrp;
            IO_STATUS_BLOCK ioStatus;
            PDEVICE_OBJECT topOfStack;

            checkFailure->PredictFailure = 0;

            KeInitializeEvent(&event, SynchronizationEvent, FALSE);

            topOfStack = IoGetAttachedDeviceReference(DeviceObject);

            //
            // SCSI disks need to have a read sent down to provoke any
            // failures to be reported.
            //
            // Issue a normal read operation.  The error-handling code in
            // classpnp will take care of a failure prediction by logging the
            // correct event.
            //

            readBufferSize = fdoExtension->DiskGeometry.BytesPerSector;
            readBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                               readBufferSize,
                                               DISK_TAG_SMART);

            if (readBuffer != NULL) {
                LARGE_INTEGER offset;

                offset.QuadPart = 0;
                readIrp = IoBuildSynchronousFsdRequest(
                        IRP_MJ_READ,
                        topOfStack,
                        readBuffer,
                        readBufferSize,
                        &offset,
                        &event,
                        &ioStatus);


                if (readIrp != NULL) {
                    status = IoCallDriver(topOfStack, readIrp);
                    if (status == STATUS_PENDING) {
                        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
                        status = ioStatus.Status;
                    }
                }

                ExFreePool(readBuffer);
            }
            ObDereferenceObject(topOfStack);
        }

        if ((diskData->FailurePredictionCapability == FailurePredictionSmart) ||
            (diskData->FailurePredictionCapability == FailurePredictionSense))
        {
            status = DiskReadFailurePredictStatus(fdoExtension,
                                                  &diskSmartStatus);

            if (NT_SUCCESS(status))
            {
                status = DiskReadFailurePredictData(fdoExtension,
                                           Irp->AssociatedIrp.SystemBuffer);

                if (diskSmartStatus.PredictFailure)
                {
                    checkFailure->PredictFailure = 1;
                } else {
                    checkFailure->PredictFailure = 0;
                }

                Irp->IoStatus.Information = sizeof(STORAGE_PREDICT_FAILURE);
            }
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        break;
    }

    case IOCTL_DISK_VERIFY: {

        PVERIFY_INFORMATION verifyInfo = Irp->AssociatedIrp.SystemBuffer;
        LARGE_INTEGER byteOffset;

        DebugPrint((2, "IOCTL_DISK_VERIFY to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((2, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        //
        // Validate buffer length.
        //

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(VERIFY_INFORMATION)) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        //
        // Add disk offset to starting sector.
        //

        byteOffset.QuadPart = commonExtension->StartingOffset.QuadPart +
                              verifyInfo->StartingOffset.QuadPart;

        if(!commonExtension->IsFdo) {

            //
            // Adjust the request and forward it down
            //

            verifyInfo->StartingOffset.QuadPart = byteOffset.QuadPart;

            ClassReleaseRemoveLock(DeviceObject, Irp);
            SendToFdo(DeviceObject, Irp, status);
            ExFreePool(srb);
            return status;
        }

        //
        // Perform a bounds check on the sector range
        //

        if ((verifyInfo->StartingOffset.QuadPart > commonExtension->PartitionLength.QuadPart) ||
            (verifyInfo->StartingOffset.QuadPart < 0))
        {
            status = STATUS_NONEXISTENT_SECTOR;
            break;
        }
        else
        {
            ULONGLONG bytesRemaining = commonExtension->PartitionLength.QuadPart - verifyInfo->StartingOffset.QuadPart;

            if ((ULONGLONG)verifyInfo->Length > bytesRemaining)
            {
                status = STATUS_NONEXISTENT_SECTOR;
                break;
            }
        }

        {
            PDISK_VERIFY_WORKITEM_CONTEXT Context = NULL;

            Context = ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(DISK_VERIFY_WORKITEM_CONTEXT),
                                            DISK_TAG_WI_CONTEXT);

            if (Context)
            {
                Context->Irp = Irp;
                Context->Srb = srb;
                Context->WorkItem = IoAllocateWorkItem(DeviceObject);

                if (Context->WorkItem)
                {
                    IoMarkIrpPending(Irp);

                    IoQueueWorkItem(Context->WorkItem,
                                    DiskIoctlVerify,
                                    DelayedWorkQueue,
                                    Context);

                    return STATUS_PENDING;
                }

                ExFreePool(Context);
            }

            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;
    }

    case IOCTL_DISK_CREATE_DISK: {

        if (!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        status = DiskIoctlCreateDisk (
                        DeviceObject,
                        Irp
                        );
        break;
    }

    case IOCTL_DISK_GET_DRIVE_LAYOUT: {

        DebugPrint((1, "IOCTL_DISK_GET_DRIVE_LAYOUT to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if (!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        status = DiskIoctlGetDriveLayout(
                        DeviceObject,
                        Irp);
        break;
    }

    case IOCTL_DISK_GET_DRIVE_LAYOUT_EX: {

        DebugPrint((1, "IOCTL_DISK_GET_DRIVE_LAYOUT_EX to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if (!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        status = DiskIoctlGetDriveLayoutEx(
                        DeviceObject,
                        Irp);
        break;

    }

    case IOCTL_DISK_SET_DRIVE_LAYOUT: {

        DebugPrint((1, "IOCTL_DISK_SET_DRIVE_LAYOUT to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if(!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        status = DiskIoctlSetDriveLayout(DeviceObject, Irp);

        //
        // Notify everyone that the disk layout has changed
        //
        {
            TARGET_DEVICE_CUSTOM_NOTIFICATION Notification;

            Notification.Event   = GUID_IO_DISK_LAYOUT_CHANGE;
            Notification.Version = 1;
            Notification.Size    = (USHORT)FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);
            Notification.FileObject = NULL;
            Notification.NameBufferOffset = -1;

            IoReportTargetDeviceChangeAsynchronous(fdoExtension->LowerPdo,
                                                   &Notification,
                                                   NULL,
                                                   NULL);
        }

        break;
    }

    case IOCTL_DISK_SET_DRIVE_LAYOUT_EX: {

        DebugPrint((1, "IOCTL_DISK_SET_DRIVE_LAYOUT_EX to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if (!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);

            return status;
        }

        status = DiskIoctlSetDriveLayoutEx(
                        DeviceObject,
                        Irp);

        //
        // Notify everyone that the disk layout has changed
        //
        {
            TARGET_DEVICE_CUSTOM_NOTIFICATION Notification;

            Notification.Event   = GUID_IO_DISK_LAYOUT_CHANGE;
            Notification.Version = 1;
            Notification.Size    = (USHORT)FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);
            Notification.FileObject = NULL;
            Notification.NameBufferOffset = -1;

            IoReportTargetDeviceChangeAsynchronous(fdoExtension->LowerPdo,
                                                   &Notification,
                                                   NULL,
                                                   NULL);
        }

        break;
    }

    case IOCTL_DISK_GET_PARTITION_INFO: {

        DebugPrint((1, "IOCTL_DISK_GET_PARTITION_INFO to device %p through irp %p\n",
                DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                commonExtension->IsFdo ? "n fdo" : " pdo"));

        status = DiskIoctlGetPartitionInfo(
                        DeviceObject,
                        Irp);
        break;
    }

    case IOCTL_DISK_GET_PARTITION_INFO_EX: {

        DebugPrint((1, "IOCTL_DISK_GET_PARTITION_INFO to device %p through irp %p\n",
                DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                commonExtension->IsFdo ? "n fdo" : " pdo"));

        status = DiskIoctlGetPartitionInfoEx(
                        DeviceObject,
                        Irp);
        break;
    }

    case IOCTL_DISK_GET_LENGTH_INFO: {
        DebugPrint((1, "IOCTL_DISK_GET_LENGTH_INFO to device %p through irp %p\n",
                DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                commonExtension->IsFdo ? "n fdo" : " pdo"));

        status = DiskIoctlGetLengthInfo(
                        DeviceObject,
                        Irp);
        break;
    }

    case IOCTL_DISK_SET_PARTITION_INFO: {

        DebugPrint((1, "IOCTL_DISK_SET_PARTITION_INFO to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));


        status = DiskIoctlSetPartitionInfo (
                        DeviceObject,
                        Irp);
        break;
    }


    case IOCTL_DISK_SET_PARTITION_INFO_EX: {

        DebugPrint((1, "IOCTL_DISK_SET_PARTITION_INFO_EX to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        status = DiskIoctlSetPartitionInfoEx(
                        DeviceObject,
                        Irp);
        break;
    }

    case IOCTL_DISK_DELETE_DRIVE_LAYOUT: {

        CREATE_DISK CreateDiskInfo;

        //
        // Update the disk with new partition information.
        //

        DebugPrint((1, "IOCTL_DISK_DELETE_DRIVE_LAYOUT to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((1, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if(!commonExtension->IsFdo) {

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        DiskAcquirePartitioningLock(fdoExtension);

        DiskInvalidatePartitionTable(fdoExtension, TRUE);

        //
        // IoCreateDisk called with a partition style of raw
        // will remove any partition tables from the disk.
        //

        RtlZeroMemory (&CreateDiskInfo, sizeof (CreateDiskInfo));
        CreateDiskInfo.PartitionStyle = PARTITION_STYLE_RAW;

        status = IoCreateDisk(
                    DeviceObject,
                    &CreateDiskInfo);


        DiskReleasePartitioningLock(fdoExtension);
        ClassInvalidateBusRelations(DeviceObject);

        Irp->IoStatus.Status = status;

        break;
    }

    case IOCTL_DISK_REASSIGN_BLOCKS: {

        //
        // Map defective blocks to new location on disk.
        //

        PREASSIGN_BLOCKS badBlocks = Irp->AssociatedIrp.SystemBuffer;
        ULONG bufferSize;
        ULONG blockNumber;
        ULONG blockCount;

        DebugPrint((2, "IOCTL_DISK_REASSIGN_BLOCKS to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((2, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        //
        // Validate buffer length.
        //

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(REASSIGN_BLOCKS)) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        //
        // Send to FDO
        //

        if(!commonExtension->IsFdo) {

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        bufferSize = sizeof(REASSIGN_BLOCKS) +
            ((badBlocks->Count - 1) * sizeof(ULONG));

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            bufferSize) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            break;
        }

        //
        // Build the data buffer to be transferred in the input buffer.
        // The format of the data to the device is:
        //
        //      2 bytes Reserved
        //      2 bytes Length
        //      x * 4 btyes Block Address
        //
        // All values are big endian.
        //

        badBlocks->Reserved = 0;
        blockCount = badBlocks->Count;

        //
        // Convert # of entries to # of bytes.
        //

        blockCount *= 4;
        badBlocks->Count = (USHORT) ((blockCount >> 8) & 0XFF);
        badBlocks->Count |= (USHORT) ((blockCount << 8) & 0XFF00);

        //
        // Convert back to number of entries.
        //

        blockCount /= 4;

        for (; blockCount > 0; blockCount--) {

            blockNumber = badBlocks->BlockNumber[blockCount-1];

            REVERSE_BYTES((PFOUR_BYTE) &badBlocks->BlockNumber[blockCount-1],
                          (PFOUR_BYTE) &blockNumber);
        }

        srb->CdbLength = 6;

        cdb->CDB6GENERIC.OperationCode = SCSIOP_REASSIGN_BLOCKS;

        //
        // Set timeout value.
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         badBlocks,
                                         bufferSize,
                                         TRUE);

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        ExFreePool(srb);
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);

        return(status);
    }

    case IOCTL_DISK_IS_WRITABLE: {

        //
        // This routine mimics IOCTL_STORAGE_GET_MEDIA_TYPES_EX
        //

        ULONG modeLength;
        ULONG retries = 4;

        DebugPrint((3, "Disk.DiskDeviceControl: IOCTL_DISK_IS_WRITABLE\n"));

        if (!commonExtension->IsFdo)
        {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

        //
        // Allocate memory for a mode header and then some
        // for port drivers that need to convert to MODE10
        // or always return the MODE_PARAMETER_BLOCK (even
        // when memory was not allocated for this purpose)
        //

        modeLength = sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK);
        modeData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                         modeLength,
                                         DISK_TAG_MODE_DATA);

        if (modeData == NULL)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(modeData, modeLength);

        //
        // Build the MODE SENSE CDB
        //

        srb->CdbLength = 6;
        cdb = (PCDB)srb->Cdb;

        //
        // Set the timeout value from the device extension
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;

        cdb->MODE_SENSE.OperationCode    = SCSIOP_MODE_SENSE;
        cdb->MODE_SENSE.PageCode         = MODE_SENSE_RETURN_ALL;
        cdb->MODE_SENSE.AllocationLength = (UCHAR)modeLength;

        while (retries != 0)
        {
            status = ClassSendSrbSynchronous(DeviceObject,
                                             srb,
                                             modeData,
                                             modeLength,
                                             FALSE);

            if (status != STATUS_VERIFY_REQUIRED)
            {
                if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)
                {
                    status = STATUS_SUCCESS;
                }

                break;
            }

            retries--;
        }

        if (NT_SUCCESS(status))
        {
            if (TEST_FLAG(modeData->DeviceSpecificParameter, MODE_DSP_WRITE_PROTECT))
            {
                status = STATUS_MEDIA_WRITE_PROTECTED;
            }
        }

        ExFreePool(modeData);
        break;
    }

    case IOCTL_DISK_INTERNAL_SET_VERIFY: {

        //
        // If the caller is kernel mode, set the verify bit.
        //

        if (Irp->RequestorMode == KernelMode) {

            SET_FLAG(DeviceObject->Flags, DO_VERIFY_VOLUME);

            if(commonExtension->IsFdo) {

                Irp->IoStatus.Information = 0;
            }
        }

        DiskInvalidatePartitionTable(fdoExtension, FALSE);

        status = STATUS_SUCCESS;
        break;
    }

    case IOCTL_DISK_INTERNAL_CLEAR_VERIFY: {

        //
        // If the caller is kernel mode, clear the verify bit.
        //

        if (Irp->RequestorMode == KernelMode) {
            CLEAR_FLAG(DeviceObject->Flags, DO_VERIFY_VOLUME);
        }
        status = STATUS_SUCCESS;
        break;
    }

    case IOCTL_DISK_UPDATE_DRIVE_SIZE: {

        DebugPrint((2, "IOCTL_DISK_UPDATE_DRIVE_SIZE to device %p "
                       "through irp %p\n",
                    DeviceObject, Irp));

        DebugPrint((2, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
            sizeof(DISK_GEOMETRY)) {

            status = STATUS_BUFFER_TOO_SMALL;
            Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
            break;
        }

        if(!commonExtension->IsFdo) {

            //
            // Pdo should issue this request to the lower device object.
            //

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        DiskAcquirePartitioningLock(fdoExtension);

        //
        // Invalidate the cached partition table.
        //

        DiskInvalidatePartitionTable(fdoExtension, TRUE);

        //
        // At this point, commonExtension *is* the FDO extension.  This
        // should be the same as PartitionZeroExtension.
        //

        ASSERT(commonExtension ==
               &(commonExtension->PartitionZeroExtension->CommonExtension));

        //
        // Issue ReadCapacity to update device extension with information
        // for current media.
        //

        status = DiskReadDriveCapacity(DeviceObject);

        //
        // Note whether the drive is ready.
        //

        diskData->ReadyStatus = status;

        //
        // The disk's partition tables may be invalid after the drive geometry
        // has been updated. The call to IoValidatePartitionTable (below) will
        // fix it if this is the case.
        //

        if (NT_SUCCESS(status)) {

            status = DiskVerifyPartitionTable (fdoExtension, TRUE);
        }


        if (NT_SUCCESS(status)) {

            //
            // Copy drive geometry information from the device extension.
            //

            RtlMoveMemory(Irp->AssociatedIrp.SystemBuffer,
                          &(fdoExtension->DiskGeometry),
                          sizeof(DISK_GEOMETRY));

            Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
            status = STATUS_SUCCESS;

        }

        DiskReleasePartitioningLock(fdoExtension);

        break;
    }

    case IOCTL_DISK_GROW_PARTITION: {

        PDISK_GROW_PARTITION inputBuffer;

        // PDEVICE_OBJECT pdo;
        PCOMMON_DEVICE_EXTENSION pdoExtension;

        LARGE_INTEGER bytesPerCylinder;
        LARGE_INTEGER newStoppingOffset;
        LARGE_INTEGER newPartitionLength;

        PPHYSICAL_DEVICE_EXTENSION sibling;

        PDRIVE_LAYOUT_INFORMATION_EX layoutInfo;
        PPARTITION_INFORMATION_EX pdoPartition;
        PPARTITION_INFORMATION_EX containerPartition;
        ULONG partitionIndex;

        DebugPrint((2, "IOCTL_DISK_GROW_PARTITION to device %p through "
                       "irp %p\n",
                    DeviceObject, Irp));

        DebugPrint((2, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        Irp->IoStatus.Information = 0;

        if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
            sizeof(DISK_GROW_PARTITION)) {

            status = STATUS_INFO_LENGTH_MISMATCH;
            Irp->IoStatus.Information = sizeof(DISK_GROW_PARTITION);
            break;
        }

        if(!commonExtension->IsFdo) {

            //
            // Pdo should issue this request to the lower device object
            //

            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject, Irp, status);
            return status;
        }

        DiskAcquirePartitioningLock(fdoExtension);
        ClassAcquireChildLock(fdoExtension);

        //
        // At this point, commonExtension *is* the FDO extension.  This should
        // be the same as PartitionZeroExtension.
        //

        ASSERT(commonExtension ==
               &(commonExtension->PartitionZeroExtension->CommonExtension));

        //
        // Get the input parameters
        //

        inputBuffer = (PDISK_GROW_PARTITION) Irp->AssociatedIrp.SystemBuffer;

        ASSERT(inputBuffer);

        //
        // Make sure that we are actually being asked to grow the partition.
        //

        if(inputBuffer->BytesToGrow.QuadPart == 0) {

            status = STATUS_INVALID_PARAMETER;
            ClassReleaseChildLock(fdoExtension);
            DiskReleasePartitioningLock(fdoExtension);
            break;
        }

        //
        // Find the partition that matches the supplied number
        //

        pdoExtension = &commonExtension->ChildList->CommonExtension;

        while(pdoExtension != NULL) {

            //
            // Is this the partition we are searching for?
            //

            if(inputBuffer->PartitionNumber == pdoExtension->PartitionNumber) {
                break;
            }

            pdoExtension = &pdoExtension->ChildList->CommonExtension;
        }

        // Did we find the partition?

        if(pdoExtension == NULL) {
            status = STATUS_INVALID_PARAMETER;
            ClassReleaseChildLock(fdoExtension);
            DiskReleasePartitioningLock(fdoExtension);
            break;
        }

        ASSERT(pdoExtension);

        //
        // Compute the new values for the partition to grow.
        //

        newPartitionLength.QuadPart =
            (pdoExtension->PartitionLength.QuadPart +
             inputBuffer->BytesToGrow.QuadPart);

        newStoppingOffset.QuadPart =
            (pdoExtension->StartingOffset.QuadPart +
             newPartitionLength.QuadPart - 1);

        //
        // Test the partition alignment before getting to involved.
        //
        // NOTE:
        //     All partition stopping offsets should be one byte less
        //     than a cylinder boundary offset. Also, all first partitions
        //     (within partition0 and within an extended partition) start
        //     on the second track while all other partitions start on a
        //     cylinder boundary.
        //
        bytesPerCylinder.QuadPart =
            ((LONGLONG) fdoExtension->DiskGeometry.TracksPerCylinder *
             (LONGLONG) fdoExtension->DiskGeometry.SectorsPerTrack *
             (LONGLONG) fdoExtension->DiskGeometry.BytesPerSector);

        // Temporarily adjust up to cylinder boundary.

        newStoppingOffset.QuadPart += 1;

        if(newStoppingOffset.QuadPart % bytesPerCylinder.QuadPart) {

            // Adjust the length first...
            newPartitionLength.QuadPart -=
                (newStoppingOffset.QuadPart % bytesPerCylinder.QuadPart);

            // ...and then the stopping offset.
            newStoppingOffset.QuadPart -=
                (newStoppingOffset.QuadPart % bytesPerCylinder.QuadPart);

            DebugPrint((2, "IOCTL_DISK_GROW_PARTITION: "
                           "Adjusted the requested partition size to cylinder boundary"));
        }

        // Restore to one byte less than a cylinder boundary.
        newStoppingOffset.QuadPart -= 1;

        //
        // Will the new partition fit within Partition0?
        // Remember: commonExtension == &PartitionZeroExtension->CommonExtension
        //

        if(newStoppingOffset.QuadPart >
            (commonExtension->StartingOffset.QuadPart +
             commonExtension->PartitionLength.QuadPart - 1)) {

            //
            // The new partition falls outside Partition0
            //

            status = STATUS_UNSUCCESSFUL;
            ClassReleaseChildLock(fdoExtension);
            DiskReleasePartitioningLock(fdoExtension);
            break;
        }

        //
        // Search for any partition that will conflict with the new partition.
        // This is done before testing for any containing partitions to
        // simplify the container handling.
        //

        sibling = commonExtension->ChildList;

        while(sibling != NULL) {
            LARGE_INTEGER sibStoppingOffset;
            PCOMMON_DEVICE_EXTENSION siblingExtension;

            siblingExtension = &(sibling->CommonExtension);

            ASSERT( siblingExtension );

            sibStoppingOffset.QuadPart =
                (siblingExtension->StartingOffset.QuadPart +
                 siblingExtension->PartitionLength.QuadPart - 1);

            //
            // Only check the siblings that start beyond the new partition
            // starting offset.  Also, assume that since the starting offset
            // has not changed, it will not be in conflict with any other
            // partitions; only the new stopping offset needs to be tested.
            //

            if((inputBuffer->PartitionNumber !=
                siblingExtension->PartitionNumber) &&

               (siblingExtension->StartingOffset.QuadPart >
                pdoExtension->StartingOffset.QuadPart) &&

               (newStoppingOffset.QuadPart >=
                siblingExtension->StartingOffset.QuadPart)) {

                //
                // We have a conflict; bail out leaving pdoSibling set.
                //

                break;
            }
            sibling = siblingExtension->ChildList;
        }


        //
        // If there is a sibling that conflicts, it will be in pdoSibling; there
        // could be more than one, but this is the first one detected.
        //

        if(sibling != NULL) {
            //
            // Report the conflict and abort the grow request.
            //

            status = STATUS_UNSUCCESSFUL;
            ClassReleaseChildLock(fdoExtension);
            DiskReleasePartitioningLock(fdoExtension);
            break;
        }

        //
        // Read the partition table.  Since we're planning on modifying it
        // we should bypass the cache.
        //

        status = DiskReadPartitionTableEx(fdoExtension, TRUE, &layoutInfo );

        if( !NT_SUCCESS(status) ) {
            ClassReleaseChildLock(fdoExtension);
            DiskReleasePartitioningLock(fdoExtension);
            break;
        }

        ASSERT( layoutInfo );

        //
        // Search the layout for the partition that matches the
        // PDO in hand.
        //

        pdoPartition =
            DiskPdoFindPartitionEntry(
                (PPHYSICAL_DEVICE_EXTENSION) pdoExtension,
                layoutInfo);

        if(pdoPartition == NULL) {
            // Looks like something is wrong interally-- error ok?
            status = STATUS_DRIVER_INTERNAL_ERROR;
            layoutInfo = NULL;
            ClassReleaseChildLock(fdoExtension);
            DiskReleasePartitioningLock(fdoExtension);
            break;
        }

        //
        // Search the on-disk partition information to find the root containing
        // partition (top-to-bottom).
        //
        // Remember: commonExtension == &PartitionZeroExtension->CommonExtension
        //

        //
        // All affected containers will have a new stopping offset
        // that is equal to the new partition (logical drive)
        // stopping offset.  Walk the layout information from
        // bottom-to-top searching for logical drive containers and
        // propagating the change.
        //

        containerPartition =
            DiskFindContainingPartition(
                layoutInfo,
                pdoPartition,
                FALSE);

        //
        // This loop should only execute at most 2 times; once for
        // the logical drive container, and once for the root
        // extended partition container.  If the growing partition
        // is not contained, the loop does not run.
        //

        while(containerPartition != NULL) {
            LARGE_INTEGER containerStoppingOffset;
            PPARTITION_INFORMATION_EX nextContainerPartition;

            //
            // Plan ahead and get the container's container before
            // modifing the current size.
            //

            nextContainerPartition =
                DiskFindContainingPartition(
                    layoutInfo,
                    containerPartition,
                    FALSE);

            //
            // Figure out where the current container ends and test
            // to see if it already encompasses the containee.
            //

            containerStoppingOffset.QuadPart =
                (containerPartition->StartingOffset.QuadPart +
                 containerPartition->PartitionLength.QuadPart - 1);

            if(newStoppingOffset.QuadPart <=
               containerStoppingOffset.QuadPart) {

                //
                // No need to continue since this container fits
                //
                break;
            }

            //
            // Adjust the container to have a stopping offset that
            // matches the grown partition stopping offset.
            //

            containerPartition->PartitionLength.QuadPart =
                newStoppingOffset.QuadPart + 1 -
                containerPartition->StartingOffset.QuadPart;

            containerPartition->RewritePartition = TRUE;

            // Continue with the next container
            containerPartition = nextContainerPartition;
        }

        //
        // Wait until after searching the containers to update the
        // partition size.
        //

        pdoPartition->PartitionLength.QuadPart =
            newPartitionLength.QuadPart;

        pdoPartition->RewritePartition = TRUE;

        //
        // Commit the changes to disk
        //

        status = DiskWritePartitionTableEx(fdoExtension, layoutInfo );

        if( NT_SUCCESS(status) ) {

            //
            // Everything looks good so commit the new length to the
            // PDO.  This has to be done carefully.  We may potentially
            // grow the partition in three steps:
            //  * increase the high-word of the partition length
            //    to be just below the new size - the high word should
            //    be greater than or equal to the current length.
            //
            //  * change the low-word of the partition length to the
            //    new value - this value may potentially be lower than
            //    the current value (if the high part was changed which
            //    is why we changed that first)
            //
            //  * change the high part to the correct value.
            //

            if(newPartitionLength.HighPart >
               pdoExtension->PartitionLength.HighPart) {

                //
                // Swap in one less than the high word.
                //

                InterlockedExchange(
                    &(pdoExtension->PartitionLength.HighPart),
                    (newPartitionLength.HighPart - 1));
            }

            //
            // Swap in the low part.
            //

            InterlockedExchange(
                &(pdoExtension->PartitionLength.LowPart),
                newPartitionLength.LowPart);

            if(newPartitionLength.HighPart !=
               pdoExtension->PartitionLength.HighPart) {

                //
                // Swap in one less than the high word.
                //

                InterlockedExchange(
                    &(pdoExtension->PartitionLength.HighPart),
                    newPartitionLength.HighPart);
            }
        }

        //
        // Invalidate and free the cached partition table.
        //

        DiskInvalidatePartitionTable(fdoExtension, TRUE);

        //
        // Free the partition buffer regardless of the status
        //

        ClassReleaseChildLock(fdoExtension);
        DiskReleasePartitioningLock(fdoExtension);

        break;
    }

    case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS:
    case IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS_ADMIN:
    {
        if (TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA))
        {
            if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < sizeof(VOLUME_DISK_EXTENTS))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            status = DiskReadDriveCapacity(commonExtension->PartitionZeroExtension->DeviceObject);

            //
            // Note whether the drive is ready.
            //

            diskData->ReadyStatus = status;

            if (NT_SUCCESS(status))
            {
                PVOLUME_DISK_EXTENTS pVolExt = (PVOLUME_DISK_EXTENTS)Irp->AssociatedIrp.SystemBuffer;

                pVolExt->NumberOfDiskExtents = 1;
                pVolExt->Extents[0].DiskNumber     = commonExtension->PartitionZeroExtension->DeviceNumber;
                pVolExt->Extents[0].StartingOffset = commonExtension->StartingOffset;
                pVolExt->Extents[0].ExtentLength   = commonExtension->PartitionLength;

                Irp->IoStatus.Information = sizeof(VOLUME_DISK_EXTENTS);
            }
        }
        else
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        break;
    }

    case IOCTL_DISK_UPDATE_PROPERTIES: {

        //
        // Invalidate the partition table and re-enumerate the device.
        //

        if(DiskInvalidatePartitionTable(fdoExtension, FALSE)) {
            IoInvalidateDeviceRelations(fdoExtension->LowerPdo, BusRelations);
        }
        status = STATUS_SUCCESS;

        break;
    }

    case IOCTL_DISK_MEDIA_REMOVAL: {

        //
        // If the disk is not removable then don't allow this command.
        //

        DebugPrint((2, "IOCTL_DISK_MEDIA_REMOVAL to device %p through irp %p\n",
                    DeviceObject, Irp));
        DebugPrint((2, "Device is a%s.\n",
                    commonExtension->IsFdo ? "n fdo" : " pdo"));

        if(!commonExtension->IsFdo) {
            ClassReleaseRemoveLock(DeviceObject, Irp);
            ExFreePool(srb);
            SendToFdo(DeviceObject,Irp,status);
            return status;
        }

        if (!TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA)) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        // Fall through and let the class driver process the request.
        //
        goto defaultHandler;

    }



defaultHandler:
    default: {

        //
        // Free the Srb, since it is not needed.
        //

        ExFreePool(srb);

        //
        // Pass the request to the common device control routine.
        //

        return(ClassDeviceControl(DeviceObject, Irp));

        break;
    }

    } // end switch

    Irp->IoStatus.Status = status;

    if (!NT_SUCCESS(status) && IoIsErrorUserInduced(status)) {

        IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
    }

    ClassReleaseRemoveLock(DeviceObject, Irp);
    ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
    ExFreePool(srb);
    return(status);

} // end DiskDeviceControl()


NTSTATUS
DiskShutdownFlush (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for a shutdown and flush IRPs.  These are sent by the
    system before it actually shuts down or when the file system does a flush.
    A synchronize cache command is sent to the device if it is write caching.
    If the device is removable an unlock command will be sent. This routine
    will sent a shutdown or flush Srb to the port driver.

Arguments:

    DriverObject - Pointer to device object to being shutdown by system.

    Irp - IRP involved.

Return Value:

    NT Status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = commonExtension->PartitionZeroExtension;

    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;
    PCDB cdb;

    //
    // Send partition flush requests to the FDO
    //

    if(!commonExtension->IsFdo) {

        PDEVICE_OBJECT lowerDevice = commonExtension->LowerDeviceObject;

        ClassReleaseRemoveLock(DeviceObject, Irp);
        IoMarkIrpPending(Irp);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoCallDriver(lowerDevice, Irp);
        return STATUS_PENDING;
    }

    //
    // Allocate SCSI request block.
    //

    srb = ExAllocatePoolWithTag(NonPagedPool,
                                sizeof(SCSI_REQUEST_BLOCK),
                                DISK_TAG_SRB);

    if (srb == NULL) {

        //
        // Set the status and complete the request.
        //

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        ClassReleaseRemoveLock(DeviceObject, Irp);
        ClassCompleteRequest(DeviceObject, Irp, IO_NO_INCREMENT);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set timeout value and mark the request as not being a tagged request.
    //

    srb->TimeOutValue = fdoExtension->TimeOutValue * 4;
    srb->QueueTag = SP_UNTAGGED;
    srb->QueueAction = SRB_SIMPLE_TAG_REQUEST;
    srb->SrbFlags = fdoExtension->SrbFlags;

    //
    // If the write cache is enabled then send a synchronize cache request.
    //

    if (TEST_FLAG(fdoExtension->DeviceFlags, DEV_WRITE_CACHE)) {

        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->CdbLength = 10;

        srb->Cdb[0] = SCSIOP_SYNCHRONIZE_CACHE;

        status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

        DebugPrint((1, "DiskShutdownFlush: Synchonize cache sent. Status = %lx\n", status ));
    }

    //
    // Unlock the device if it is removable and this is a shutdown.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    if (TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA) &&
        irpStack->MajorFunction == IRP_MJ_SHUTDOWN) {

        srb->CdbLength = 6;
        cdb = (PVOID) srb->Cdb;
        cdb->MEDIA_REMOVAL.OperationCode = SCSIOP_MEDIUM_REMOVAL;
        cdb->MEDIA_REMOVAL.Prevent = FALSE;

        //
        // Set timeout value.
        //

        srb->TimeOutValue = fdoExtension->TimeOutValue;
        status = ClassSendSrbSynchronous(DeviceObject,
                                         srb,
                                         NULL,
                                         0,
                                         TRUE);

        DebugPrint((1, "DiskShutdownFlush: Unlock device request sent. Status = %lx\n", status ));
    }

    srb->CdbLength = 0;

    //
    // Save a few parameters in the current stack location.
    //

    srb->Function = irpStack->MajorFunction == IRP_MJ_SHUTDOWN ?
        SRB_FUNCTION_SHUTDOWN : SRB_FUNCTION_FLUSH;

    //
    // Set the retry count to zero.
    //

    irpStack->Parameters.Others.Argument4 = (PVOID) 0;

    //
    // Set up IoCompletion routine address.
    //

    IoSetCompletionRoutine(Irp, ClassIoComplete, srb, TRUE, TRUE, TRUE);

    //
    // Get next stack location and
    // set major function code.
    //

    irpStack = IoGetNextIrpStackLocation(Irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Set up SRB for execute scsi request.
    // Save SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = srb;

    //
    // Set up Irp Address.
    //

    srb->OriginalRequest = Irp;

    //
    // Call the port driver to process the request.
    //

    IoMarkIrpPending(Irp);
    IoCallDriver(commonExtension->LowerDeviceObject, Irp);
    return STATUS_PENDING;
} // end DiskShutdown()


NTSTATUS
DiskModeSelect(
    IN PDEVICE_OBJECT Fdo,
    IN PCHAR ModeSelectBuffer,
    IN ULONG Length,
    IN BOOLEAN SavePage
    )

/*++

Routine Description:

    This routine sends a mode select command.

Arguments:

    DeviceObject - Supplies the device object associated with this request.

    ModeSelectBuffer - Supplies a buffer containing the page data.

    Length - Supplies the length in bytes of the mode select buffer.

    SavePage - Indicates that parameters should be written to disk.

Return Value:

    Length of the transferred data is returned.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCDB cdb;
    SCSI_REQUEST_BLOCK srb;
    ULONG retries = 1;
    ULONG length2;
    NTSTATUS status;
    PULONG buffer;
    PMODE_PARAMETER_BLOCK blockDescriptor;

    PAGED_CODE();

    ASSERT_FDO(Fdo);

    length2 = Length + sizeof(MODE_PARAMETER_HEADER) + sizeof(MODE_PARAMETER_BLOCK);

    //
    // Allocate buffer for mode select header, block descriptor, and mode page.
    //

    buffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                   length2,
                                   DISK_TAG_MODE_DATA);

    if(buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(buffer, length2);

    //
    // Set length in header to size of mode page.
    //

    ((PMODE_PARAMETER_HEADER)buffer)->BlockDescriptorLength = sizeof(MODE_PARAMETER_BLOCK);

    (PULONG)blockDescriptor = (buffer + 1);

    //
    // Set size
    //

    blockDescriptor->BlockLength[1]=0x02;

    //
    // Copy mode page to buffer.
    //

    RtlCopyMemory(buffer + 3, ModeSelectBuffer, Length);

    //
    // Zero SRB.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Build the MODE SELECT CDB.
    //

    srb.CdbLength = 6;
    cdb = (PCDB)srb.Cdb;

    //
    // Set timeout value from device extension.
    //

    srb.TimeOutValue = fdoExtension->TimeOutValue * 2;

    cdb->MODE_SELECT.OperationCode = SCSIOP_MODE_SELECT;
    cdb->MODE_SELECT.SPBit = SavePage;
    cdb->MODE_SELECT.PFBit = 1;
    cdb->MODE_SELECT.ParameterListLength = (UCHAR)(length2);

Retry:

    status = ClassSendSrbSynchronous(Fdo,
                                     &srb,
                                     buffer,
                                     length2,
                                     TRUE);

    if (status == STATUS_VERIFY_REQUIRED) {

        //
        // Routine ClassSendSrbSynchronous does not retry requests returned with
        // this status.
        //

        if (retries--) {

            //
            // Retry request.
            //

            goto Retry;
        }

    } else if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        status = STATUS_SUCCESS;
    }

    ExFreePool(buffer);

    return status;
} // end DiskModeSelect()


//
// This routine is structured as a work-item routine
//
VOID
DisableWriteCache(
    IN PDEVICE_OBJECT Fdo,
    IN PIO_WORKITEM WorkItem
    )

{
    ULONG specialFlags = 0;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    DISK_CACHE_INFORMATION cacheInfo;
    NTSTATUS status;

    PAGED_CODE();

    fdoExtension = Fdo->DeviceExtension;

    ASSERT(fdoExtension->CommonExtension.IsFdo);

    DebugPrint((1, "Disk.DisableWriteCache: Disabling Write Cache\n"));

    ClassGetDeviceParameter(fdoExtension,
                            DiskDeviceParameterSubkey,
                            DiskDeviceSpecialFlags,
                            &specialFlags);

    RtlZeroMemory(&cacheInfo, sizeof(DISK_CACHE_INFORMATION));

    status = DiskGetCacheInformation(fdoExtension, &cacheInfo);

    if (NT_SUCCESS(status) && (cacheInfo.WriteCacheEnabled == TRUE)) {

        cacheInfo.WriteCacheEnabled = FALSE;

        status = DiskSetCacheInformation(fdoExtension, &cacheInfo);

        if (status == STATUS_INVALID_DEVICE_REQUEST)
        {
            //
            // This device does not allow for
            // the write cache to be disabled
            //
            SET_FLAG(specialFlags, HackDisableWriteCacheNotSupported);

            SET_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_WRITE_CACHE_NOT_SUPPORTED);
        }

        CLEAR_FLAG(fdoExtension->DeviceFlags, DEV_WRITE_CACHE);
    }

    //
    // Set a flag in the registry to help
    // identify this device  across boots
    //
    SET_FLAG(specialFlags, HackDisableWriteCache);

    SET_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_WRITE_CACHE);

    ClassSetDeviceParameter(fdoExtension,
                            DiskDeviceParameterSubkey,
                            DiskDeviceSpecialFlags,
                            specialFlags);

    IoFreeWorkItem(WorkItem);
}


//
// This routine is structured as a work-item routine
//
VOID
DiskIoctlVerify(
    IN PDEVICE_OBJECT Fdo,
    IN PDISK_VERIFY_WORKITEM_CONTEXT Context
    )

{
    PIRP Irp = Context->Irp;
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension = Fdo->DeviceExtension;
    PDISK_DATA DiskData = (PDISK_DATA)FdoExtension->CommonExtension.DriverData;
    PVERIFY_INFORMATION verifyInfo = Irp->AssociatedIrp.SystemBuffer;
    PSCSI_REQUEST_BLOCK Srb = Context->Srb;
    PCDB Cdb = (PCDB)Srb->Cdb;
    LARGE_INTEGER byteOffset;
    ULONG sectorOffset;
    USHORT sectorCount;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(FdoExtension->CommonExtension.IsFdo);

    //
    // We don't need to hold on to this memory as
    // the following operation may take some time
    //

    IoFreeWorkItem(Context->WorkItem);

    DebugPrint((1, "Disk.DiskIoctlVerify: Spliting up the request\n"));

    //
    // Add disk offset to starting the sector
    //

    byteOffset.QuadPart = FdoExtension->CommonExtension.StartingOffset.QuadPart +
                          verifyInfo->StartingOffset.QuadPart;

    //
    // Convert byte offset to the sector offset
    //

    sectorOffset = (ULONG)(byteOffset.QuadPart >> FdoExtension->SectorShift);

    //
    // Convert ULONG byte count to USHORT sector count.
    //

    sectorCount = (USHORT)(verifyInfo->Length >> FdoExtension->SectorShift);

    //
    // Make sure  that all previous verify requests have indeed completed
    // This greatly reduces the possibility of a Denial-of-Service attack
    //

    KeWaitForMutexObject(&DiskData->VerifyMutex,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL);

    while (NT_SUCCESS(status) && (sectorCount != 0))
    {
        USHORT numSectors = min(sectorCount, MAX_SECTORS_PER_VERIFY);

        RtlZeroMemory(Srb, SCSI_REQUEST_BLOCK_SIZE);

        Srb->CdbLength = 10;

        Cdb->CDB10.OperationCode = SCSIOP_VERIFY;

        //
        // Move little endian values into CDB in big endian format
        //

        Cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&sectorOffset)->Byte3;
        Cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&sectorOffset)->Byte2;
        Cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&sectorOffset)->Byte1;
        Cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&sectorOffset)->Byte0;

        Cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&numSectors)->Byte1;
        Cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&numSectors)->Byte0;

        //
        // Calculate the request timeout value based
        // on  the number of sectors  being verified
        //

        Srb->TimeOutValue = ((numSectors + 0x7F) >> 7) * FdoExtension->TimeOutValue;

        status = ClassSendSrbSynchronous(Fdo,
                                         Srb,
                                         NULL,
                                         0,
                                         FALSE);

        ASSERT(status != STATUS_NONEXISTENT_SECTOR);

        sectorCount  -= numSectors;
        sectorOffset += numSectors;
    }

    KeReleaseMutex(&DiskData->VerifyMutex, FALSE);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    ClassReleaseRemoveLock(Fdo, Irp);
    ClassCompleteRequest(Fdo, Irp, IO_NO_INCREMENT);

    ExFreePool(Srb);
    ExFreePool(Context);
}



VOID
DiskFdoProcessError(
    PDEVICE_OBJECT Fdo,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    )

/*++

Routine Description:

   This routine checks the type of error.  If the error indicates an underrun
   then indicate the request should be retried.

Arguments:

    Fdo - Supplies a pointer to the functional device object.

    Srb - Supplies a pointer to the failing Srb.

    Status - Status with which the IRP will be completed.

    Retry - Indication of whether the request will be retried.

Return Value:

    None.

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCDB cdb = (PCDB)(Srb->Cdb);

    ASSERT(fdoExtension->CommonExtension.IsFdo);

    if (*Status == STATUS_DATA_OVERRUN &&
        ( cdb->CDB10.OperationCode == SCSIOP_WRITE ||
          cdb->CDB10.OperationCode == SCSIOP_READ)) {

            *Retry = TRUE;

            //
            // Update the error count for the device.
            //

            fdoExtension->ErrorCount++;

    } else if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_ERROR &&
               Srb->ScsiStatus == SCSISTAT_BUSY) {

        //
        // a disk drive should never be busy this long. Reset the scsi bus
        // maybe this will clear the condition.
        //

        ResetBus(Fdo);

        //
        // Update the error count for the device.
        //

        fdoExtension->ErrorCount++;

    } else {

        BOOLEAN invalidatePartitionTable = FALSE;

        //
        // See if this might indicate that something on the drive has changed.
        //

        if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
            (Srb->SenseInfoBufferLength >=
                FIELD_OFFSET(SENSE_DATA, CommandSpecificInformation))) {

            PSENSE_DATA       senseBuffer = Srb->SenseInfoBuffer;
            ULONG senseKey = senseBuffer->SenseKey & 0xf;
            ULONG asc = senseBuffer->AdditionalSenseCode;
            ULONG ascq = senseBuffer->AdditionalSenseCodeQualifier;

            switch (senseKey) {

            case SCSI_SENSE_ILLEGAL_REQUEST: {

                switch (asc) {

                    case SCSI_ADSENSE_INVALID_CDB: {

                        if (((cdb->CDB10.OperationCode == SCSIOP_READ) ||
                             (cdb->CDB10.OperationCode == SCSIOP_WRITE)) &&
                            (cdb->CDB10.ForceUnitAccess) &&
                            TEST_FLAG(fdoExtension->DeviceFlags, DEV_WRITE_CACHE)) {

                            //
                            // This device does not permit FUA while
                            // the DEV_WRITE_CACHE flag is turned on
                            //

                            PIO_WORKITEM workItem = IoAllocateWorkItem(Fdo);
                            if (workItem) {

                                IoQueueWorkItem(workItem,
                                                DisableWriteCache,
                                                CriticalWorkQueue,
                                                workItem);
                            }

                            cdb->CDB10.ForceUnitAccess = FALSE;
                            *Retry = TRUE;
                        }

                        break;
                    }
                } // end switch(asc)
                break;
            }

            case SCSI_SENSE_NOT_READY: {

                switch (asc) {
                case SCSI_ADSENSE_LUN_NOT_READY: {
                    switch (ascq) {
                    case SCSI_SENSEQ_BECOMING_READY:
                    case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED:
                    case SCSI_SENSEQ_CAUSE_NOT_REPORTABLE: {
                        invalidatePartitionTable = TRUE;
                        break;
                    }
                    } // end switch(ascq)
                    break;
                }

                case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE: {
                    invalidatePartitionTable = TRUE;
                    break;
                }
                } // end switch(asc)
                break;
            }

            case SCSI_SENSE_MEDIUM_ERROR: {
                invalidatePartitionTable = TRUE;
                break;
            }

            case SCSI_SENSE_HARDWARE_ERROR: {
                invalidatePartitionTable = TRUE;
                break;
            }

            case SCSI_SENSE_UNIT_ATTENTION: {
                switch (senseBuffer->AdditionalSenseCode) {
                    case SCSI_ADSENSE_MEDIUM_CHANGED: {
                        invalidatePartitionTable = TRUE;
                        break;
                    }
                }
                break;
            }

            case SCSI_SENSE_RECOVERED_ERROR: {
                invalidatePartitionTable = TRUE;
                break;
            }

            } // end switch(senseKey)
        } else {

            //
            // On any exceptional scsi condition which might indicate that the
            // device was changed we will flush out the state of the partition
            // table.
            //

            switch (SRB_STATUS(Srb->SrbStatus)) {
            case SRB_STATUS_INVALID_LUN:
            case SRB_STATUS_INVALID_TARGET_ID:
            case SRB_STATUS_NO_DEVICE:
            case SRB_STATUS_NO_HBA:
            case SRB_STATUS_INVALID_PATH_ID:
            case SRB_STATUS_COMMAND_TIMEOUT:
            case SRB_STATUS_TIMEOUT:
            case SRB_STATUS_SELECTION_TIMEOUT:
            case SRB_STATUS_REQUEST_FLUSHED:
            case SRB_STATUS_UNEXPECTED_BUS_FREE:
            case SRB_STATUS_PARITY_ERROR:
            case SRB_STATUS_ERROR: {
                invalidatePartitionTable = TRUE;
                break;
            }
            } // end switch(Srb->SrbStatus)
        }

        if(invalidatePartitionTable) {
            if(DiskInvalidatePartitionTable(fdoExtension, FALSE)) {
                IoInvalidateDeviceRelations(fdoExtension->LowerPdo,
                                            BusRelations);
            }
        }
    }
    return;
}


VOID
DiskSetSpecialHacks(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG_PTR Data
    )

/*++

Routine Description:

    This function checks to see if an SCSI logical unit requires speical
    flags to be set.

Arguments:

    Fdo - Supplies the device object to be tested.

    InquiryData - Supplies the inquiry data returned by the device of interest.

    AdapterDescriptor - Supplies the capabilities of the device object.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT fdo = FdoExtension->DeviceObject;

    PAGED_CODE();

    DebugPrint((1, "Disk SetSpecialHacks, Setting Hacks %p\n", Data));

    //
    // Found a listed controller.  Determine what must be done.
    //

    if (TEST_FLAG(Data, HackDisableTaggedQueuing)) {

        //
        // Disable tagged queuing.
        //

        CLEAR_FLAG(FdoExtension->SrbFlags, SRB_FLAGS_QUEUE_ACTION_ENABLE);
    }

    if (TEST_FLAG(Data, HackDisableSynchronousTransfers)) {

        //
        // Disable synchronous data transfers.
        //

        SET_FLAG(FdoExtension->SrbFlags, SRB_FLAGS_DISABLE_SYNCH_TRANSFER);

    }

    if (TEST_FLAG(Data, HackDisableSpinDown)) {

        //
        // Disable spinning down of drives.
        //

        SET_FLAG(FdoExtension->ScanForSpecialFlags,
                 CLASS_SPECIAL_DISABLE_SPIN_DOWN);

    }

    if (TEST_FLAG(Data, HackDisableWriteCache)) {

        //
        // Disable the drive's write cache
        //

        SET_FLAG(FdoExtension->ScanForSpecialFlags,
                 CLASS_SPECIAL_DISABLE_WRITE_CACHE);

    }

    if (TEST_FLAG(Data, HackCauseNotReportableHack)) {

        SET_FLAG(FdoExtension->ScanForSpecialFlags,
                 CLASS_SPECIAL_CAUSE_NOT_REPORTABLE_HACK);
    }

    if (TEST_FLAG(fdo->Characteristics, FILE_REMOVABLE_MEDIA) &&
        TEST_FLAG(Data, HackRequiresStartUnitCommand)
        ) {

        //
        // this is a list of vendors who require the START_UNIT command
        //

        DebugPrint((1, "DiskScanForSpecial (%p) => This unit requires "
                    " START_UNITS\n", fdo));
        SET_FLAG(FdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);

    }

    return;
}


VOID
DiskScanRegistryForSpecial(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This function checks the registry to see if the SCSI logical unit
    requires special attention.

Arguments:

    Fdo - Supplies the device object to be tested.

Return Value:

    None.

--*/

{
    ULONG specialFlags = 0;

    PAGED_CODE();

    ClassGetDeviceParameter(FdoExtension, DiskDeviceParameterSubkey, DiskDeviceSpecialFlags, &specialFlags);

    if (TEST_FLAG(specialFlags, HackDisableWriteCache))
    {
        //
        // This device had previously failed to perform an FUA with  the DEV_WRITE_CACHE
        // flag turned on. Set a bit to inform DiskStartFdo() to disable the write cache
        //

        SET_FLAG(FdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_WRITE_CACHE);
    }

    if (TEST_FLAG(specialFlags, HackDisableWriteCacheNotSupported))
    {
        //
        // This device does not permit disabling of the write cache
        //

        SET_FLAG(FdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_WRITE_CACHE_NOT_SUPPORTED);
    }
}


VOID
ResetBus(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This command sends a reset bus command to the SCSI port driver.

Arguments:

    Fdo - The functional device object for the logical unit with hardware problem.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpStack;
    PIRP irp;

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PSCSI_REQUEST_BLOCK srb;
    PCOMPLETION_CONTEXT context;

    DebugPrint((1, "Disk ResetBus: Sending reset bus request to port driver.\n"));

    //
    // Allocate Srb from nonpaged pool.
    //

    context = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(COMPLETION_CONTEXT),
                                    DISK_TAG_CCONTEXT);

    if(context == NULL) {
        return;
    }

    //
    // Save the device object in the context for use by the completion
    // routine.
    //

    context->DeviceObject = Fdo;
    srb = &context->Srb;

    //
    // Zero out srb.
    //

    RtlZeroMemory(srb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Write length to SRB.
    //

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;

    srb->Function = SRB_FUNCTION_RESET_BUS;

    //
    // Build the asynchronous request to be sent to the port driver.
    // Since this routine is called from a DPC the IRP should always be
    // available.
    //

    irp = IoAllocateIrp(Fdo->StackSize, FALSE);

    if(irp == NULL) {
        ExFreePool(context);
        return;
    }

    ClassAcquireRemoveLock(Fdo, irp);

    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE)ClassAsynchronousCompletion,
                           context,
                           TRUE,
                           TRUE,
                           TRUE);

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    srb->OriginalRequest = irp;

    //
    // Store the SRB address in next stack for port driver.
    //

    irpStack->Parameters.Scsi.Srb = srb;

    //
    // Call the port driver with the IRP.
    //

    IoCallDriver(fdoExtension->CommonExtension.LowerDeviceObject, irp);

    return;

} // end ResetBus()


NTSTATUS
DiskQueryPnpCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    )

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = commonExtension->DriverData;

    PAGED_CODE();

    ASSERT(DeviceObject);
    ASSERT(Capabilities);

    if(commonExtension->IsFdo) {
        return STATUS_NOT_IMPLEMENTED;
    } else {

        PPHYSICAL_DEVICE_EXTENSION physicalExtension =
            DeviceObject->DeviceExtension;

        Capabilities->SilentInstall = 1;
        Capabilities->RawDeviceOK = 1;
        Capabilities->Address = commonExtension->PartitionNumber;

        if(!TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA)) {

            //
            // Media's not removable, deviceId/DeviceInstance should be
            // globally unique.
            //

            Capabilities->UniqueID = 1;
        } else {
            Capabilities->UniqueID = 0;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DiskGetCacheInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PDISK_CACHE_INFORMATION CacheInfo
    )

{
    PMODE_PARAMETER_HEADER modeData;
    PMODE_CACHING_PAGE pageData;

    ULONG length;

    NTSTATUS status;

    PAGED_CODE();

    modeData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     MODE_DATA_SIZE,
                                     DISK_TAG_DISABLE_CACHE);

    if (modeData == NULL) {

        DebugPrint((1, "DiskGetSetCacheInformation: Unable to allocate mode "
                       "data buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(FdoExtension->DeviceObject,
                            (PUCHAR) modeData,
                            MODE_DATA_SIZE,
                            MODE_SENSE_RETURN_ALL);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {

        //
        // Retry the request in case of a check condition.
        //

        length = ClassModeSense(FdoExtension->DeviceObject,
                                (PUCHAR) modeData,
                                MODE_DATA_SIZE,
                                MODE_SENSE_RETURN_ALL);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {


            DebugPrint((1, "Disk.DisableWriteCache: Mode Sense failed\n"));

            ExFreePool(modeData);
            return STATUS_IO_DEVICE_ERROR;
        }
    }

    //
    // If the length is greater than length indicated by the mode data reset
    // the data to the mode data.
    //

    if (length > (ULONG) (modeData->ModeDataLength + 1)) {
        length = modeData->ModeDataLength + 1;
    }

    //
    // Check to see if the write cache is enabled.
    //

    pageData = ClassFindModePage((PUCHAR) modeData,
                                 length,
                                 MODE_PAGE_CACHING,
                                 TRUE);

    //
    // Check if valid caching page exists.
    //

    if (pageData == NULL) {
        ExFreePool(modeData);
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Copy the parameters over.
    //

    RtlZeroMemory(CacheInfo, sizeof(DISK_CACHE_INFORMATION));

    CacheInfo->ParametersSavable = pageData->PageSavable;

    CacheInfo->ReadCacheEnabled = !(pageData->ReadDisableCache);
    CacheInfo->WriteCacheEnabled = pageData->WriteCacheEnable;

    CacheInfo->ReadRetentionPriority = pageData->ReadRetensionPriority;
    CacheInfo->WriteRetentionPriority = pageData->WriteRetensionPriority;

    CacheInfo->DisablePrefetchTransferLength =
        ((pageData->DisablePrefetchTransfer[0] << 8) +
         pageData->DisablePrefetchTransfer[1]);

    CacheInfo->ScalarPrefetch.Minimum =
        ((pageData->MinimumPrefetch[0] << 8) + pageData->MinimumPrefetch[1]);

    CacheInfo->ScalarPrefetch.Maximum =
        ((pageData->MaximumPrefetch[0] << 8) + pageData->MaximumPrefetch[1]);

    if(pageData->MultiplicationFactor) {
        CacheInfo->PrefetchScalar = TRUE;
        CacheInfo->ScalarPrefetch.MaximumBlocks =
            ((pageData->MaximumPrefetchCeiling[0] << 8) +
             pageData->MaximumPrefetchCeiling[1]);
    }

    ExFreePool(modeData);
    return STATUS_SUCCESS;
}


NTSTATUS
DiskSetCacheInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PDISK_CACHE_INFORMATION CacheInfo
    )

{
    PMODE_PARAMETER_HEADER modeData;
    ULONG length;

    PMODE_CACHING_PAGE pageData;

    ULONG i;

    NTSTATUS status;

    PAGED_CODE();

    modeData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     MODE_DATA_SIZE,
                                     DISK_TAG_DISABLE_CACHE);

    if (modeData == NULL) {

        DebugPrint((1, "DiskSetCacheInformation: Unable to allocate mode "
                       "data buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(FdoExtension->DeviceObject,
                            (PUCHAR) modeData,
                            MODE_DATA_SIZE,
                            MODE_PAGE_CACHING);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {

        //
        // Retry the request in case of a check condition.
        //

        length = ClassModeSense(FdoExtension->DeviceObject,
                                (PUCHAR) modeData,
                                MODE_DATA_SIZE,
                                MODE_PAGE_CACHING);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {


            DebugPrint((1, "Disk.DisableWriteCache: Mode Sense failed\n"));

            ExFreePool(modeData);
            return STATUS_IO_DEVICE_ERROR;
        }
    }

    //
    // If the length is greater than length indicated by the mode data reset
    // the data to the mode data.
    //

    if (length > (ULONG) (modeData->ModeDataLength + 1)) {
        length = modeData->ModeDataLength + 1;
    }

    //
    // Check to see if the write cache is enabled.
    //

    pageData = ClassFindModePage((PUCHAR) modeData,
                                 length,
                                 MODE_PAGE_CACHING,
                                 TRUE);

    //
    // Check if valid caching page exists.
    //

    if (pageData == NULL) {
        ExFreePool(modeData);
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Don't touch any of the normal parameters - not all drives actually
    // use the correct size of caching mode page.  Just change the things
    // which the user could have modified.
    //

    pageData->PageSavable = FALSE;

    pageData->ReadDisableCache = !(CacheInfo->ReadCacheEnabled);
    pageData->MultiplicationFactor = CacheInfo->PrefetchScalar;
    pageData->WriteCacheEnable = CacheInfo->WriteCacheEnabled;

    pageData->WriteRetensionPriority = (UCHAR) CacheInfo->WriteRetentionPriority;
    pageData->ReadRetensionPriority = (UCHAR) CacheInfo->ReadRetentionPriority;

    pageData->DisablePrefetchTransfer[0] =
        (UCHAR) (CacheInfo->DisablePrefetchTransferLength >> 8);
    pageData->DisablePrefetchTransfer[1] =
        (UCHAR) (CacheInfo->DisablePrefetchTransferLength & 0x00ff);

    pageData->MinimumPrefetch[0] =
        (UCHAR) (CacheInfo->ScalarPrefetch.Minimum >> 8);
    pageData->MinimumPrefetch[1] =
        (UCHAR) (CacheInfo->ScalarPrefetch.Minimum & 0x00ff);

    pageData->MaximumPrefetch[0] =
        (UCHAR) (CacheInfo->ScalarPrefetch.Maximum >> 8);
    pageData->MaximumPrefetch[1] =
        (UCHAR) (CacheInfo->ScalarPrefetch.Maximum & 0x00ff);

    if(pageData->MultiplicationFactor) {

        pageData->MaximumPrefetchCeiling[0] =
            (UCHAR) (CacheInfo->ScalarPrefetch.MaximumBlocks >> 8);
        pageData->MaximumPrefetchCeiling[1] =
            (UCHAR) (CacheInfo->ScalarPrefetch.MaximumBlocks & 0x00ff);
    }

    //
    // We will attempt (twice) to issue the mode select with the page.
    //

    for (i = 0; i < 2; i++) {

        status = DiskModeSelect(FdoExtension->DeviceObject,
                                (PUCHAR) pageData,
                                (pageData->PageLength + 2),
                                CacheInfo->ParametersSavable);

        if (NT_SUCCESS(status)) {

            if (CacheInfo->WriteCacheEnabled)
            {
                SET_FLAG(FdoExtension->DeviceFlags, DEV_WRITE_CACHE);
            }
            else
            {
                CLEAR_FLAG(FdoExtension->DeviceFlags, DEV_WRITE_CACHE);
            }

            break;
        }
    }

    ExFreePool(modeData);
    return status;
}


VOID
DiskLogCacheInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PDISK_CACHE_INFORMATION CacheInfo,
    IN NTSTATUS Status
    )
{
    PIO_ERROR_LOG_PACKET logEntry = NULL;

    PAGED_CODE();

    logEntry = IoAllocateErrorLogEntry(FdoExtension->DeviceObject, sizeof(IO_ERROR_LOG_PACKET) + (4 * sizeof(ULONG)));

    if (logEntry != NULL)
    {
        PDISK_DATA diskData = FdoExtension->CommonExtension.DriverData;
        BOOLEAN bIsEnabled  = TEST_FLAG(FdoExtension->DeviceFlags, DEV_WRITE_CACHE);

        logEntry->FinalStatus       = Status;
        logEntry->ErrorCode         = (bIsEnabled) ? IO_WRITE_CACHE_ENABLED : IO_WRITE_CACHE_DISABLED;
        logEntry->SequenceNumber    = 0;
        logEntry->MajorFunctionCode = IRP_MJ_SCSI;
        logEntry->IoControlCode     = 0;
        logEntry->RetryCount        = 0;
        logEntry->UniqueErrorValue  = 0x1;
        logEntry->DumpDataSize      = 4;

        logEntry->DumpData[0] = diskData->ScsiAddress.PathId;
        logEntry->DumpData[1] = diskData->ScsiAddress.TargetId;
        logEntry->DumpData[2] = diskData->ScsiAddress.Lun;
        logEntry->DumpData[3] = CacheInfo->WriteCacheEnabled;

        //
        // Write the error log packet.
        //

        IoWriteErrorLogEntry(logEntry);
    }
}



PPARTITION_INFORMATION_EX
DiskPdoFindPartitionEntry(
    IN PPHYSICAL_DEVICE_EXTENSION Pdo,
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo
    )

{
    PCOMMON_DEVICE_EXTENSION commonExtension= &(Pdo->CommonExtension);
    ULONG partitionIndex;

    PAGED_CODE();


    DebugPrint((1, "DiskPdoFindPartitionEntry: Searching layout for "
                   "matching partition.\n"));

    for(partitionIndex = 0;
        partitionIndex < LayoutInfo->PartitionCount;
        partitionIndex++) {

        PPARTITION_INFORMATION_EX partitionInfo;

        //
        // Get the partition entry
        //

        partitionInfo = &LayoutInfo->PartitionEntry[partitionIndex];

        //
        // See if it is the one we are looking for...
        //

        if( LayoutInfo->PartitionStyle == PARTITION_STYLE_MBR &&
            (partitionInfo->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
             IsContainerPartition(partitionInfo->Mbr.PartitionType)) ) {

            continue;
        }

        if( LayoutInfo->PartitionStyle == PARTITION_STYLE_GPT &&
            DiskCompareGuid (&partitionInfo->Gpt.PartitionType, &GUID_NULL) == 00) {

            continue;
        }

        if( (commonExtension->StartingOffset.QuadPart ==
             partitionInfo->StartingOffset.QuadPart) &&
            (commonExtension->PartitionLength.QuadPart ==
             partitionInfo->PartitionLength.QuadPart)) {

            //
            // Found it!
            //

            DebugPrint((1, "DiskPdoFindPartitionEntry: Found matching "
                           "partition.\n"));
            return partitionInfo;
        }
    }

    return NULL;
}


PPARTITION_INFORMATION_EX
DiskFindAdjacentPartition(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo,
    IN PPARTITION_INFORMATION_EX BasePartition
    )
{
    ULONG partitionIndex;
    LONGLONG baseStoppingOffset;
    LONGLONG adjacentStartingOffset;
    PPARTITION_INFORMATION_EX adjacentPartition = 0;

    ASSERT(LayoutInfo && BasePartition);

    PAGED_CODE();

    DebugPrint((1, "DiskPdoFindAdjacentPartition: Searching layout for adjacent partition.\n"));

    //
    // Construct the base stopping offset for comparison
    //

    baseStoppingOffset = (BasePartition->StartingOffset.QuadPart +
                          BasePartition->PartitionLength.QuadPart -
                          1);

    adjacentStartingOffset = MAXLONGLONG;

    for(partitionIndex = 0;
        partitionIndex < LayoutInfo->PartitionCount;
        partitionIndex++) {

        PPARTITION_INFORMATION_EX partitionInfo;

        //
        // Get the partition entry
        //

        partitionInfo = &LayoutInfo->PartitionEntry[partitionIndex];

        //
        // See if it is the one we are looking for...
        //

        if( LayoutInfo->PartitionStyle == PARTITION_STYLE_MBR &&
            partitionInfo->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ) {

            continue;
        }

        if( LayoutInfo->PartitionStyle == PARTITION_STYLE_GPT &&
            DiskCompareGuid (&partitionInfo->Gpt.PartitionType, &GUID_NULL) == 00 ) {

            continue;
        }


        if((partitionInfo->StartingOffset.QuadPart > baseStoppingOffset) &&
           (partitionInfo->StartingOffset.QuadPart < adjacentStartingOffset)) {

            // Found a closer neighbor...update and remember.
            adjacentPartition = partitionInfo;

            adjacentStartingOffset = adjacentPartition->StartingOffset.QuadPart;

            DebugPrint((1, "DiskPdoFindAdjacentPartition: Found adjacent "
                           "partition.\n"));
        }
    }
    return adjacentPartition;
}


PPARTITION_INFORMATION_EX
DiskFindContainingPartition(
    IN PDRIVE_LAYOUT_INFORMATION_EX LayoutInfo,
    IN PPARTITION_INFORMATION_EX BasePartition,
    IN BOOLEAN SearchTopToBottom
    )

{

    LONG partitionIndex;
    LONG startIndex;
    LONG stopIndex;
    LONG stepIndex;

    LONGLONG baseStoppingOffset;
    LONGLONG containerStoppingOffset;

    PPARTITION_INFORMATION_EX partitionInfo = 0;
    PPARTITION_INFORMATION_EX containerPartition = 0;

    PAGED_CODE();

    ASSERT( LayoutInfo && BasePartition);

    DebugPrint((1, "DiskFindContainingPartition: Searching for extended partition.\n"));

    if( LayoutInfo->PartitionCount != 0) {

        baseStoppingOffset = (BasePartition->StartingOffset.QuadPart +
                              BasePartition->PartitionLength.QuadPart - 1);

        //
        // Determine the search direction and setup the loop
        //
        if(SearchTopToBottom == TRUE) {

            startIndex = 0;
            stopIndex = LayoutInfo->PartitionCount;
            stepIndex = +1;
        } else {
            startIndex = LayoutInfo->PartitionCount - 1;
            stopIndex = -1;
            stepIndex = -1;
        }

        //
        // Using the loop parameters, walk the layout information and
        // return the first containing partition.
        //

        for(partitionIndex = startIndex;
            partitionIndex != stopIndex;
            partitionIndex += stepIndex) {

            //
            // Get the next partition entry
            //

            partitionInfo = &LayoutInfo->PartitionEntry[partitionIndex];

            containerStoppingOffset = (partitionInfo->StartingOffset.QuadPart +
                                       partitionInfo->PartitionLength.QuadPart -
                                       1);

            //
            // Search for a containing partition without detecting the
            // same partition as a container of itself.  The starting
            // offset of a partition and its container should never be
            // the same; however, the stopping offset can be the same.
            //

            //
            // NOTE: Container partitions are MBR only.
            //

            if((LayoutInfo->PartitionStyle == PARTITION_STYLE_MBR) &&
                (IsContainerPartition(partitionInfo->Mbr.PartitionType)) &&
               (BasePartition->StartingOffset.QuadPart >
                partitionInfo->StartingOffset.QuadPart) &&
               (baseStoppingOffset <= containerStoppingOffset)) {

                containerPartition = partitionInfo;

                DebugPrint((1, "DiskFindContainingPartition: Found a "
                               "containing extended partition.\n"));

                break;
            }
        }
    }

    return containerPartition;
}


NTSTATUS
DiskGetInfoExceptionInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMODE_INFO_EXCEPTIONS ReturnPageData
    )
{
    PMODE_PARAMETER_HEADER modeData;
    PMODE_INFO_EXCEPTIONS pageData;
    ULONG length;

    NTSTATUS status;

    PAGED_CODE();

    //
    // ReturnPageData is allocated by the caller
    //

    modeData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                     MODE_DATA_SIZE,
                                     DISK_TAG_INFO_EXCEPTION);

    if (modeData == NULL) {

        DebugPrint((1, "DiskGetInfoExceptionInformation: Unable to allocate mode "
                       "data buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modeData, MODE_DATA_SIZE);

    length = ClassModeSense(FdoExtension->DeviceObject,
                            (PUCHAR) modeData,
                            MODE_DATA_SIZE,
                            MODE_PAGE_FAULT_REPORTING);

    if (length < sizeof(MODE_PARAMETER_HEADER)) {

        //
        // Retry the request in case of a check condition.
        //

        length = ClassModeSense(FdoExtension->DeviceObject,
                                (PUCHAR) modeData,
                                MODE_DATA_SIZE,
                                MODE_PAGE_FAULT_REPORTING);

        if (length < sizeof(MODE_PARAMETER_HEADER)) {


            DebugPrint((1, "Disk.DisableWriteCache: Mode Sense failed\n"));

            ExFreePool(modeData);
            return STATUS_IO_DEVICE_ERROR;
        }
    }

    //
    // If the length is greater than length indicated by the mode data reset
    // the data to the mode data.
    //

    if (length > (ULONG) (modeData->ModeDataLength + 1)) {
        length = modeData->ModeDataLength + 1;
    }

    //
    // Find the mode page for info exceptions
    //

    pageData = ClassFindModePage((PUCHAR) modeData,
                                 length,
                                 MODE_PAGE_FAULT_REPORTING,
                                 TRUE);

    if (pageData != NULL) {
        RtlCopyMemory(ReturnPageData, pageData, sizeof(MODE_INFO_EXCEPTIONS));
        status =  STATUS_SUCCESS;
    } else {
        status = STATUS_NOT_SUPPORTED;
    }

    DebugPrint((3, "DiskGetInfoExceptionInformation: %s support SMART for device %x\n",
                  NT_SUCCESS(status) ? "does" : "does not",
                  FdoExtension->DeviceObject));


    ExFreePool(modeData);
    return(status);
}


NTSTATUS
DiskSetInfoExceptionInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMODE_INFO_EXCEPTIONS PageData
    )

{
    ULONG i;
    NTSTATUS status;

    PAGED_CODE();

    //
    // We will attempt (twice) to issue the mode select with the page.
    // Make the setting persistant so that we don't have to turn it back
    // on after a bus reset.
    //

    for (i = 0; i < 2; i++)
    {
        status = DiskModeSelect(FdoExtension->DeviceObject,
                                (PUCHAR) PageData,
                                sizeof(MODE_INFO_EXCEPTIONS),
                                TRUE);

    }

    DebugPrint((3, "DiskSetInfoExceptionInformation: %s for device %p\n",
                        NT_SUCCESS(status) ? "succeeded" : "failed",
                        FdoExtension->DeviceObject));

    return status;
}


#if 0
#if defined(_X86_)

NTSTATUS
DiskQuerySuggestedLinkName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    The routine try to find a suggested link name from registry for Removable
    using device object names of NT4 and NT3.51.

Arguments:

    DeviceObject - Pointer to driver object created by system.
    Irp - IRP involved.

Return Value:

    NTSTATUS

--*/

{
    PMOUNTDEV_SUGGESTED_LINK_NAME   suggestedName;
    WCHAR                           driveLetterNameBuffer[10];
    RTL_QUERY_REGISTRY_TABLE        queryTable[2];
    PWSTR                           valueName;
    UNICODE_STRING                  driveLetterName;
    NTSTATUS                        status;
    PIO_STACK_LOCATION              irpStack = IoGetCurrentIrpStackLocation(Irp);
    PCOMMON_DEVICE_EXTENSION        commonExtension = DeviceObject->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION    p0Extension     = commonExtension->PartitionZeroExtension;
    ULONG                           i, diskCount;
    PCONFIGURATION_INFORMATION      configurationInformation;

    PAGED_CODE();

    DebugPrint((1, "DISK: IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME to device %#08lx"
                " through irp %#08lx\n",
                DeviceObject, Irp));

    DebugPrint((1, "      - DeviceNumber %d, - PartitionNumber %d\n",
                p0Extension->DeviceNumber,
                commonExtension->PartitionNumber));

    if (!TEST_FLAG(DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA)) {

        status = STATUS_NOT_FOUND;
        return status;
    }

    if (commonExtension->PartitionNumber == 0) {

        status = STATUS_NOT_FOUND;
        return status;
    }

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(MOUNTDEV_SUGGESTED_LINK_NAME)) {

        status = STATUS_INVALID_PARAMETER;
        return status;
    }

    valueName = ExAllocatePoolWithTag(PagedPool,
                               sizeof(WCHAR) * 64,
                               DISK_TAG_NEC_98);

    if (!valueName) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Look for a device object name of NT4.
    //
    swprintf(valueName, L"\\Device\\Harddisk%d\\Partition%d",
                                p0Extension->DeviceNumber,
                                commonExtension->PartitionNumber);

    driveLetterName.Buffer = driveLetterNameBuffer;
    driveLetterName.MaximumLength = 20;
    driveLetterName.Length = 0;

    RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
    queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                          RTL_QUERY_REGISTRY_DIRECT;
    queryTable[0].Name = valueName;
    queryTable[0].EntryContext = &driveLetterName;

    status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                    L"\\Registry\\Machine\\System\\DISK",
                                    queryTable, NULL, NULL);

    if (!NT_SUCCESS(status)) {

        //
        // Look for a device object name of NT3.51.
        // scsimo.sys on NT3.51 created it as \Device\OpticalDiskX.
        // The number X were a serial number from zero on only Removable,
        // so we look for it serially without above DeviceNumber and PartitionNumber.
        //

        configurationInformation = IoGetConfigurationInformation();
        diskCount = configurationInformation->DiskCount;

        for (i = 0; i < diskCount; i++) {
            swprintf(valueName, L"\\Device\\OpticalDisk%d",i);

            driveLetterName.Buffer = driveLetterNameBuffer;
            driveLetterName.MaximumLength = 20;
            driveLetterName.Length = 0;

            RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
            queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                                  RTL_QUERY_REGISTRY_DIRECT;
            queryTable[0].Name = valueName;
            queryTable[0].EntryContext = &driveLetterName;

            status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                            L"\\Registry\\Machine\\System\\DISK",
                                            queryTable, NULL, NULL);

            if (NT_SUCCESS(status)) {
                break;
            }
        }

        if (!NT_SUCCESS(status)) {
            ExFreePool(valueName);
            return status;
        }
    }

    if (driveLetterName.Length != 4 ||
        driveLetterName.Buffer[0] < 'A' ||
        driveLetterName.Buffer[0] > 'Z' ||
        driveLetterName.Buffer[1] != ':') {

        status = STATUS_NOT_FOUND;
        ExFreePool(valueName);
        return status;
    }

    suggestedName = Irp->AssociatedIrp.SystemBuffer;
    suggestedName->UseOnlyIfThereAreNoOtherLinks = TRUE;
    suggestedName->NameLength = 28;

    Irp->IoStatus.Information =
            FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME, Name) + 28;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
        Irp->IoStatus.Information) {

        Irp->IoStatus.Information =
                sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
        status = STATUS_BUFFER_OVERFLOW;
        ExFreePool(valueName);
        return status;
    }

    RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                           L"\\Registry\\Machine\\System\\DISK",
                           valueName);

    ExFreePool(valueName);

    RtlCopyMemory(suggestedName->Name, L"\\DosDevices\\", 24);
    suggestedName->Name[12] = driveLetterName.Buffer[0];
    suggestedName->Name[13] = ':';

    return status;
}
#endif
#endif


NTSTATUS
DiskIoctlCreateDisk(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Handler for IOCTL_DISK_CREATE_DISK ioctl.

Arguments:

    DeviceObject - Device object representing a disk that will be created or
            erased.

    Irp - The IRP for this request.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    PCREATE_DISK createDiskInfo;


    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( Irp != NULL );

    //
    // Initialization
    //

    commonExtension = DeviceObject->DeviceExtension;
    fdoExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);


    ASSERT (commonExtension->IsFdo);

    //
    // Check the input buffer size.
    //

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
        sizeof (CREATE_DISK) ) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // If we are being asked to create a GPT disk on a system that doesn't
    // support GPT, fail.
    //

    createDiskInfo = (PCREATE_DISK)Irp->AssociatedIrp.SystemBuffer;

    if (DiskDisableGpt &&
        createDiskInfo->PartitionStyle == PARTITION_STYLE_GPT) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Call the lower level Io routine to do the dirty work of writing a
    // new partition table.
    //

    DiskAcquirePartitioningLock(fdoExtension);

    DiskInvalidatePartitionTable(fdoExtension, TRUE);

    status = IoCreateDisk (
                    commonExtension->PartitionZeroExtension->CommonExtension.DeviceObject,
                    Irp->AssociatedIrp.SystemBuffer
                    );
    DiskReleasePartitioningLock(fdoExtension);
    ClassInvalidateBusRelations(DeviceObject);

    Irp->IoStatus.Status = status;

    return status;
}



NTSTATUS
DiskIoctlGetDriveLayout(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Handler for IOCTL_DISK_GET_DRIVE_LAYOUT ioctl.

    This ioctl has been replace by IOCTL_DISK_GET_DRIVE_LAYOUT_EX.

Arguments:

    DeviceObject - Device object representing a disk the layout information
            will be obtained for.

    Irp - The IRP for this request.


Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    ULONG size;
    PDRIVE_LAYOUT_INFORMATION partitionList;
    PDRIVE_LAYOUT_INFORMATION_EX partitionListEx;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    BOOLEAN invalidateBusRelations;


    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Irp );

    //
    // Initialization
    //

    partitionListEx = NULL;
    partitionList = NULL;
    fdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);

    //
    // Issue a read capacity to update the apparent size of the disk.
    //

    DiskReadDriveCapacity(fdoExtension->DeviceObject);

    DiskAcquirePartitioningLock(fdoExtension);

    status = DiskReadPartitionTableEx(fdoExtension, FALSE, &partitionListEx);

    if (!NT_SUCCESS(status)) {
        DiskReleasePartitioningLock(fdoExtension);
        return status;
    }

    //
    // This ioctl is only supported on MBR partitioned disks. Fail the
    // call otherwise.
    //

    if (partitionListEx->PartitionStyle != PARTITION_STYLE_MBR) {
        DiskReleasePartitioningLock(fdoExtension);
        return STATUS_INVALID_DEVICE_REQUEST;
    }


    //
    // The disk layout has been returned in the partitionListEx
    // buffer.  Determine its size and, if the data will fit
    // into the intermediate buffer, return it.
    //

    size = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]);
    size += partitionListEx->PartitionCount * sizeof(PARTITION_INFORMATION);

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
        size) {

        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = size;

        DiskReleasePartitioningLock(fdoExtension);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Update the partition device objects and set valid partition
    // numbers
    //

    ASSERT(diskData->UpdatePartitionRoutine != NULL);
    diskData->UpdatePartitionRoutine(DeviceObject, partitionListEx);

    //
    // Convert the extended drive layout structure to a regular drive layout
    // structure to return. DiskConvertExtendedToLayout() allocates pool
    // that we must free.
    //

    partitionList = DiskConvertExtendedToLayout(partitionListEx);

    if (partitionList == NULL) {
        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        DiskReleasePartitioningLock (fdoExtension);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // We're done with the extended partition list now.
    //

    partitionListEx = NULL;

    //
    // Copy partition information to system buffer.
    //

    RtlMoveMemory(Irp->AssociatedIrp.SystemBuffer,
                  partitionList,
                  size);

    Irp->IoStatus.Information = size;
    Irp->IoStatus.Status = status;

    //
    // Finally, free the buffer allocated by reading the
    // partition table.
    //

    ExFreePool(partitionList);
    DiskReleasePartitioningLock(fdoExtension);
    ClassInvalidateBusRelations(DeviceObject);

    return status;
}



NTSTATUS
DiskIoctlGetDriveLayoutEx(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Handler for IOCTL_DISK_GET_DRIVE_LAYOUT_EX ioctl.

    This ioctl replaces IOCTL_DISK_GET_DRIVE_LAYOUT.

Arguments:

    DeviceObject - Device object representing a disk the layout information
            will be obtained for.

    Irp - The IRP for this request.


Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    ULONG size;
    PDRIVE_LAYOUT_INFORMATION_EX partitionList;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    BOOLEAN invalidateBusRelations;


    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Irp );

    //
    // Initialization
    //

    fdoExtension = DeviceObject->DeviceExtension;
    pdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);

    //
    // Issue a read capacity to update the apparent size of the disk.
    //

    DiskReadDriveCapacity(fdoExtension->DeviceObject);

    //
    // Get the drive layout information.
    //

    DiskAcquirePartitioningLock (fdoExtension);

    status = DiskReadPartitionTableEx (fdoExtension, FALSE, &partitionList);

    if ( !NT_SUCCESS (status) ) {
        DiskReleasePartitioningLock (fdoExtension);
        return status;
    }

    //
    // Update the partition device objects and set valid partition
    // numbers.
    //

    ASSERT(diskData->UpdatePartitionRoutine != NULL);
    diskData->UpdatePartitionRoutine(DeviceObject, partitionList);


    size = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]) +
           partitionList->PartitionCount * sizeof (PARTITION_INFORMATION_EX);


    //
    // If the output buffer is large enough, copy data to the output buffer,
    // otherwise, fail.
    //

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength >=
        size ) {

        RtlCopyMemory (Irp->AssociatedIrp.SystemBuffer,
                       partitionList,
                       size
                       );

        Irp->IoStatus.Information = size;
        Irp->IoStatus.Status = status;
        invalidateBusRelations = TRUE;

    } else {

        Irp->IoStatus.Information = size;
        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        status = STATUS_BUFFER_TOO_SMALL;
        invalidateBusRelations = FALSE;
    }

    DiskReleasePartitioningLock(fdoExtension);

    if ( invalidateBusRelations ) {
        ClassInvalidateBusRelations(DeviceObject);
    }

    return status;
}


NTSTATUS
DiskIoctlSetDriveLayout(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Handler for IOCTL_DISK_SET_DRIVE_LAYOUT ioctl.

    This ioctl has been replaced by IOCTL_DISK_SET_DRIVE_LAYOUT_EX.

Arguments:

    DeviceObject - Device object for which partition table should be written.

    Irp - IRP involved.

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    PDRIVE_LAYOUT_INFORMATION partitionList;
    PDRIVE_LAYOUT_INFORMATION_EX partitionListEx;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    BOOLEAN invalidateBusRelations;
    SIZE_T listSize;
    SIZE_T inputBufferLength;
    SIZE_T outputBufferLength;

    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Irp );

    //
    // Initialization
    //

    partitionListEx = NULL;
    partitionList = NULL;
    fdoExtension = DeviceObject->DeviceExtension;
    pdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    partitionList = Irp->AssociatedIrp.SystemBuffer;

    inputBufferLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Update the partition table.
    //

    if (inputBufferLength < sizeof (DRIVE_LAYOUT_INFORMATION)) {

        status = STATUS_INFO_LENGTH_MISMATCH;
        Irp->IoStatus.Information = sizeof (DRIVE_LAYOUT_INFORMATION);
        return status;
    }

    DiskAcquirePartitioningLock(fdoExtension);

    listSize = (partitionList->PartitionCount - 1);
    listSize *= sizeof(PARTITION_INFORMATION);
    listSize += sizeof(DRIVE_LAYOUT_INFORMATION);

    if (inputBufferLength < listSize) {

        //
        // The remaning size of the input buffer not big enough to
        // hold the additional partition entries
        //

        status = STATUS_INFO_LENGTH_MISMATCH;
        Irp->IoStatus.Information = listSize;
        DiskReleasePartitioningLock(fdoExtension);
        return status;
    }

    //
    // Convert the parititon information structure into an extended
    // structure.
    //

    partitionListEx = DiskConvertLayoutToExtended (partitionList);

    if ( partitionListEx == NULL ) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        Irp->IoStatus.Status = status;
        DiskReleasePartitioningLock(fdoExtension);
        return status;
    }

    //
    // Redo all the partition numbers in the partition information
    //

    ASSERT(diskData->UpdatePartitionRoutine != NULL);
    diskData->UpdatePartitionRoutine(DeviceObject, partitionListEx);

    //
    // Write changes to disk.
    //

    status = DiskWritePartitionTableEx(fdoExtension, partitionListEx);

    //
    // Update IRP with bytes returned.  Make sure we don't claim to be
    // returning more bytes than the caller is expecting to get back.
    //

    if (NT_SUCCESS (status)) {
        if (outputBufferLength < listSize) {
            Irp->IoStatus.Information = outputBufferLength;
        } else {
            ULONG i;

            Irp->IoStatus.Information = listSize;

            //
            // Also update the partition numbers.
            //

            for (i = 0; i < partitionList->PartitionCount; i++) {

                PPARTITION_INFORMATION partition;
                PPARTITION_INFORMATION_EX partitionEx;

                partition = &partitionList->PartitionEntry[i];
                partitionEx = &partitionListEx->PartitionEntry[i];
                partition->PartitionNumber = partitionEx->PartitionNumber;

            }
        }
    }

    ExFreePool (partitionListEx);
    DiskReleasePartitioningLock(fdoExtension);
    ClassInvalidateBusRelations(DeviceObject);

    Irp->IoStatus.Status = status;
    return status;
}



NTSTATUS
DiskIoctlSetDriveLayoutEx(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Handler for IOCTL_DISK_SET_DRIVE_LAYOUT_EX ioctl.

    This ioctl replaces IOCTL_DISK_SET_DRIVE_LAYOUT.

Arguments:

    DeviceObject - Device object for which partition table should be written.

    Irp - IRP involved.

Return Values:

    NTSTATUS code.

--*/

{

    NTSTATUS status;
    PDRIVE_LAYOUT_INFORMATION_EX partitionListEx;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension;

    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    BOOLEAN invalidateBusRelations;
    SIZE_T listSize;
    SIZE_T inputBufferLength;
    SIZE_T outputBufferLength;

    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Irp );

    //
    // Initialization
    //

    partitionListEx = NULL;
    fdoExtension = DeviceObject->DeviceExtension;
    commonExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    partitionListEx = Irp->AssociatedIrp.SystemBuffer;

    inputBufferLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Update the partition table.
    //

    if (inputBufferLength <
        FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry)) {
        status = STATUS_INFO_LENGTH_MISMATCH;
        Irp->IoStatus.Information =
            FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry);
        return status;
    }

    DiskAcquirePartitioningLock(fdoExtension);

    listSize = partitionListEx->PartitionCount;
    listSize *= sizeof(PARTITION_INFORMATION_EX);
    listSize += FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry);

    if (inputBufferLength < listSize) {

        //
        // The remaning size of the input buffer not big enough to
        // hold the additional partition entries
        //

        status = STATUS_INFO_LENGTH_MISMATCH;
        Irp->IoStatus.Information = listSize;
        DiskReleasePartitioningLock(fdoExtension);
        return status;
    }


    //
    // If the partition count is zero, this is a request to clear
    // the partition table.
    //

    if (partitionListEx->PartitionCount == 0) {

        CREATE_DISK CreateDiskInfo;

        RtlZeroMemory (&CreateDiskInfo, sizeof (CreateDiskInfo));
        CreateDiskInfo.PartitionStyle = diskData->PartitionStyle;
        if (diskData->PartitionStyle == PARTITION_STYLE_MBR) {
            CreateDiskInfo.Mbr.Signature = partitionListEx->Mbr.Signature;
        } else {
            ASSERT (diskData->PartitionStyle == PARTITION_STYLE_GPT);
            CreateDiskInfo.Gpt.DiskId = partitionListEx->Gpt.DiskId;
            //
            // NB: Setting MaxPartitionCount to zero will
            // force the GPT partition table writing code
            // to use the default minimum for this value.
            //
            CreateDiskInfo.Gpt.MaxPartitionCount = 0;
        }
        DiskInvalidatePartitionTable(fdoExtension, TRUE);


        status = IoCreateDisk(DeviceObject, &CreateDiskInfo);

    } else {

        //
        // Redo all the partition numbers in the partition information
        //

        ASSERT(diskData->UpdatePartitionRoutine != NULL);
        diskData->UpdatePartitionRoutine(DeviceObject, partitionListEx);

        //
        // Write changes to disk.
        //

        status = DiskWritePartitionTableEx(fdoExtension, partitionListEx);
    }

    //
    // Update IRP with bytes returned.  Make sure we don't claim to be
    // returning more bytes than the caller is expecting to get back.
    //

    if (NT_SUCCESS(status)) {
        if (outputBufferLength < listSize) {
            Irp->IoStatus.Information = outputBufferLength;
        } else {
            Irp->IoStatus.Information = listSize;
        }
    }

    DiskReleasePartitioningLock(fdoExtension);
    ClassInvalidateBusRelations(DeviceObject);

    Irp->IoStatus.Status = status;
    return status;
}


NTSTATUS
DiskIoctlGetPartitionInfo(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Handle the IOCTL_DISK_GET_PARTITION_INFO ioctl. Return the information
    about the partition specified by the device object.  Note that no
    information is ever returned about the size or partition type of the
    physical disk, as this doesn't make any sense.

    This ioctl has been replaced by IOCTL_DISK_GET_PARTITION_INFO_EX.

Arguments:

    DeviceObject -

    Irp -

Return Values:

    NTSTATUS code.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    PPARTITION_INFORMATION partitionInfo;
    PFUNCTIONAL_DEVICE_EXTENSION p0Extension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PDISK_DATA partitionZeroData;
    NTSTATUS oldReadyStatus;


    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Irp );


    //
    // Initialization
    //

    commonExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    p0Extension = commonExtension->PartitionZeroExtension;
    partitionZeroData = ((PDISK_DATA) p0Extension->CommonExtension.DriverData);


    //
    // Check that the buffer is large enough.
    //

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTITION_INFORMATION)) {

        status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        return status;
    }

    //
    // Update the geometry in case it has changed
    //

    status = DiskReadDriveCapacity(p0Extension->DeviceObject);

    //
    // Note whether the drive is ready.  If the status has changed then
    // notify pnp.
    //

    oldReadyStatus = InterlockedExchange(
                        &(partitionZeroData->ReadyStatus),
                        status);

    if(partitionZeroData->ReadyStatus != oldReadyStatus) {
        IoInvalidateDeviceRelations(p0Extension->LowerPdo,
                                    BusRelations);
    }

    if(!NT_SUCCESS(status)) {
        return status;
    }


    //
    // Partition zero, the partition representing the entire disk, is
    // special cased. The logic below allows for sending this ioctl to
    // a GPT disk only for partition zero. This allows us to obtain
    // the size of a GPT disk using Win2k compatible IOCTLs.
    //

    if (commonExtension->PartitionNumber == 0) {

        partitionInfo = (PPARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

        partitionInfo->PartitionType = PARTITION_ENTRY_UNUSED;
        partitionInfo->StartingOffset = commonExtension->StartingOffset;
        partitionInfo->PartitionLength = commonExtension->PartitionLength;
        partitionInfo->HiddenSectors = 0;
        partitionInfo->PartitionNumber = commonExtension->PartitionNumber;
        partitionInfo->BootIndicator = FALSE;
        partitionInfo->RewritePartition = FALSE;
        partitionInfo->RecognizedPartition = FALSE;

    } else {

        //
        // We do not support this IOCTL on an EFI partitioned disk
        // for any partition other than partition zero.
        //

        if (diskData->PartitionStyle != PARTITION_STYLE_MBR) {
            status = STATUS_INVALID_DEVICE_REQUEST;
            Irp->IoStatus.Status = status;
            return status;
        }

        DiskEnumerateDevice(p0Extension->DeviceObject);
        DiskAcquirePartitioningLock(p0Extension);


        partitionInfo = (PPARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

        partitionInfo->PartitionType = diskData->Mbr.PartitionType;
        partitionInfo->StartingOffset = commonExtension->StartingOffset;
        partitionInfo->PartitionLength = commonExtension->PartitionLength;
        partitionInfo->HiddenSectors = diskData->Mbr.HiddenSectors;
        partitionInfo->PartitionNumber = commonExtension->PartitionNumber;
        partitionInfo->BootIndicator = diskData->Mbr.BootIndicator;
        partitionInfo->RewritePartition = FALSE;
        partitionInfo->RecognizedPartition =
                IsRecognizedPartition(diskData->Mbr.PartitionType);

        DiskReleasePartitioningLock(p0Extension);
    }

    status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);

    return status;
}


NTSTATUS
DiskIoctlGetPartitionInfoEx(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    PPARTITION_INFORMATION_EX partitionInfo;
    PFUNCTIONAL_DEVICE_EXTENSION p0Extension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PDISK_DATA partitionZeroData;
    NTSTATUS oldReadyStatus;


    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Irp );


    //
    // Initialization
    //

    commonExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    p0Extension = commonExtension->PartitionZeroExtension;
    partitionZeroData = ((PDISK_DATA) p0Extension->CommonExtension.DriverData);


    //
    // Check that the buffer is large enough.
    //

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTITION_INFORMATION_EX)) {

        status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        return status;
    }

    //
    // Update the geometry in case it has changed
    //

    status = DiskReadDriveCapacity(p0Extension->DeviceObject);

    //
    // Note whether the drive is ready.  If the status has changed then
    // notify pnp.
    //

    oldReadyStatus = InterlockedExchange(
                        &(partitionZeroData->ReadyStatus),
                        status);

    if(partitionZeroData->ReadyStatus != oldReadyStatus) {
        IoInvalidateDeviceRelations(p0Extension->LowerPdo,
                                    BusRelations);
    }

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If this is something other than partition 0 then do a
    // re-enumeration to make sure we've got up-to-date information.
    //

    if(commonExtension->PartitionNumber != 0) {
        DiskEnumerateDevice(p0Extension->DeviceObject);
        DiskAcquirePartitioningLock(p0Extension);
    }

    partitionInfo = (PPARTITION_INFORMATION_EX) Irp->AssociatedIrp.SystemBuffer;

    partitionInfo->StartingOffset = commonExtension->StartingOffset;
    partitionInfo->PartitionLength = commonExtension->PartitionLength;
    partitionInfo->RewritePartition = FALSE;
    partitionInfo->PartitionNumber = commonExtension->PartitionNumber;
    partitionInfo->PartitionStyle = diskData->PartitionStyle;

    if ( diskData->PartitionStyle == PARTITION_STYLE_MBR ) {

        partitionInfo->Mbr.PartitionType = diskData->Mbr.PartitionType;
        partitionInfo->Mbr.HiddenSectors = diskData->Mbr.HiddenSectors;
        partitionInfo->Mbr.BootIndicator = diskData->Mbr.BootIndicator;
        partitionInfo->Mbr.RecognizedPartition =
                IsRecognizedPartition(diskData->Mbr.PartitionType);

    } else {

        //
        // ISSUE - 2000/02/09 - math: Review for Partition0.
        // Is this correct for Partition0?
        //

        partitionInfo->Gpt.PartitionType = diskData->Efi.PartitionType;
        partitionInfo->Gpt.PartitionId = diskData->Efi.PartitionId;
        partitionInfo->Gpt.Attributes = diskData->Efi.Attributes;
        RtlCopyMemory (
                partitionInfo->Gpt.Name,
                diskData->Efi.PartitionName,
                sizeof (partitionInfo->Gpt.Name)
                );
    }

    status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION_EX);

    if(commonExtension->PartitionNumber != 0) {
        DiskReleasePartitioningLock(p0Extension);
    }

    return status;
}



NTSTATUS
DiskIoctlGetLengthInfo(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PDISK_DATA diskData;
    PGET_LENGTH_INFORMATION lengthInfo;
    PFUNCTIONAL_DEVICE_EXTENSION p0Extension;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PDISK_DATA partitionZeroData;
    NTSTATUS oldReadyStatus;


    PAGED_CODE ();

    ASSERT ( DeviceObject );
    ASSERT ( Irp );


    //
    // Initialization
    //

    commonExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    p0Extension = commonExtension->PartitionZeroExtension;
    partitionZeroData = ((PDISK_DATA) p0Extension->CommonExtension.DriverData);


    //
    // Check that the buffer is large enough.
    //

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(GET_LENGTH_INFORMATION)) {

        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = sizeof(GET_LENGTH_INFORMATION);
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Update the geometry in case it has changed
    //

    status = DiskReadDriveCapacity(p0Extension->DeviceObject);

    //
    // Note whether the drive is ready.  If the status has changed then
    // notify pnp.
    //

    oldReadyStatus = InterlockedExchange(
                        &(partitionZeroData->ReadyStatus),
                        status);

    if(partitionZeroData->ReadyStatus != oldReadyStatus) {
        IoInvalidateDeviceRelations(p0Extension->LowerPdo,
                                    BusRelations);
    }

    if(!NT_SUCCESS(status)) {
        return status;
    }

    //
    // If this is something other than partition 0 then do a
    // re-enumeration to make sure we've got up-to-date information.
    //

    if(commonExtension->PartitionNumber != 0) {
        DiskEnumerateDevice(p0Extension->DeviceObject);
        DiskAcquirePartitioningLock(p0Extension);
    }

    lengthInfo = (PGET_LENGTH_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    lengthInfo->Length = commonExtension->PartitionLength;

    status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof(GET_LENGTH_INFORMATION);

    if(commonExtension->PartitionNumber != 0) {
        DiskReleasePartitioningLock(p0Extension);
    }

    return status;
}



NTSTATUS
DiskIoctlSetPartitionInfo(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PSET_PARTITION_INFORMATION inputBuffer;
    PDISK_DATA diskData;
    PIO_STACK_LOCATION irpStack;
    PCOMMON_DEVICE_EXTENSION commonExtension;


    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( Irp != NULL );


    //
    // Initialization
    //

    commonExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    inputBuffer = (PSET_PARTITION_INFORMATION)Irp->AssociatedIrp.SystemBuffer;

    if(commonExtension->IsFdo) {

        return STATUS_UNSUCCESSFUL;
    }


    if (diskData->PartitionStyle != PARTITION_STYLE_MBR) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Validate buffer length
    //

    if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
       sizeof(SET_PARTITION_INFORMATION)) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    DiskAcquirePartitioningLock(commonExtension->PartitionZeroExtension);

    //
    // The HAL routines IoGet- and IoSetPartitionInformation were
    // developed before support of dynamic partitioning and therefore
    // don't distinguish between partition ordinal (that is the order
    // of a paritition on a disk) and the partition number.  (The
    // partition number is assigned to a partition to identify it to
    // the system.) Use partition ordinals for these legacy calls.
    //

    status = DiskSetPartitionInformation(
                commonExtension->PartitionZeroExtension,
                commonExtension->PartitionZeroExtension->DiskGeometry.BytesPerSector,
                diskData->PartitionOrdinal,
                inputBuffer->PartitionType);

    if(NT_SUCCESS(status)) {

        diskData->Mbr.PartitionType = inputBuffer->PartitionType;
    }

    DiskReleasePartitioningLock(commonExtension->PartitionZeroExtension);

    return status;
}


NTSTATUS
DiskIoctlSetPartitionInfoEx(
    IN OUT PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PSET_PARTITION_INFORMATION_EX inputBuffer;
    PDISK_DATA diskData;
    PIO_STACK_LOCATION irpStack;
    PCOMMON_DEVICE_EXTENSION commonExtension;


    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( Irp != NULL );


    //
    // Initialization
    //

    commonExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    inputBuffer = (PSET_PARTITION_INFORMATION_EX)Irp->AssociatedIrp.SystemBuffer;

    if(commonExtension->IsFdo) {

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Validate buffer length
    //

    if(irpStack->Parameters.DeviceIoControl.InputBufferLength <
       sizeof(SET_PARTITION_INFORMATION_EX)) {

        return STATUS_INFO_LENGTH_MISMATCH;
    }

    DiskAcquirePartitioningLock(commonExtension->PartitionZeroExtension);

    //
    // The HAL routines IoGet- and IoSetPartitionInformation were
    // developed before support of dynamic partitioning and therefore
    // don't distinguish between partition ordinal (that is the order
    // of a paritition on a disk) and the partition number.  (The
    // partition number is assigned to a partition to identify it to
    // the system.) Use partition ordinals for these legacy calls.
    //

    status = DiskSetPartitionInformationEx(
                commonExtension->PartitionZeroExtension,
                diskData->PartitionOrdinal,
                inputBuffer
                );

    if(NT_SUCCESS(status)) {

        if (diskData->PartitionStyle == PARTITION_STYLE_MBR) {

            diskData->Mbr.PartitionType = inputBuffer->Mbr.PartitionType;

        } else {

            ASSERT ( diskData->PartitionStyle == PARTITION_STYLE_MBR );

            diskData->Efi.PartitionType = inputBuffer->Gpt.PartitionType;
            diskData->Efi.PartitionId = inputBuffer->Gpt.PartitionId;
            diskData->Efi.Attributes = inputBuffer->Gpt.Attributes;

            RtlCopyMemory (
                    diskData->Efi.PartitionName,
                    inputBuffer->Gpt.Name,
                    sizeof (diskData->Efi.PartitionName)
                    );
        }
    }

    DiskReleasePartitioningLock(commonExtension->PartitionZeroExtension);

    return status;
}

typedef struct _DISK_GEOMETRY_EX_INTERNAL {
    DISK_GEOMETRY Geometry;
    LARGE_INTEGER DiskSize;
    DISK_PARTITION_INFO Partition;
    DISK_DETECTION_INFO Detection;
} DISK_GEOMETRY_EX_INTERNAL, *PDISK_GEOMETRY_EX_INTERNAL;




NTSTATUS
DiskIoctlGetDriveGeometryEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    Obtain the extended geometry information for the drive.

Arguments:

    DeviceObject - The device object to obtain the geometry for.

    Irp - IRP with a return buffer large enough to receive the
            extended geometry information.

Return Value:

    NTSTATUS code

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PCOMMON_DEVICE_EXTENSION commonExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PDISK_DATA diskData;
    PDISK_GEOMETRY_EX_INTERNAL geometryEx;
    ULONG OutputBufferLength;

    //
    // Verification
    //

    PAGED_CODE ();

    ASSERT ( DeviceObject != NULL );
    ASSERT ( Irp != NULL );

    //
    // Setup parameters
    //

    commonExtension = DeviceObject->DeviceExtension;
    fdoExtension = DeviceObject->DeviceExtension;
    diskData = (PDISK_DATA)(commonExtension->DriverData);
    irpStack = IoGetCurrentIrpStackLocation ( Irp );
    geometryEx = NULL;
    OutputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // This is only valid for the FDO.
    //

    ASSERT ( commonExtension->IsFdo );

    //
    // Check that the buffer is large enough. It must be large enough
    // to hold at lest the Geometry and DiskSize fields of of the
    // DISK_GEOMETRY_EX structure.
    //

    if ( OutputBufferLength < FIELD_OFFSET (DISK_GEOMETRY_EX, Data) ) {

        //
        // Buffer too small. Bail out, telling the caller the required
        // size.
        //

        status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Status = FIELD_OFFSET (DISK_GEOMETRY_EX, Data);
        return status;
    }

    if (TEST_FLAG (DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA)) {

        //
        // Issue a ReadCapacity to update device extension
        // with information for the current media.
        //

        status = DiskReadDriveCapacity (
                    commonExtension->PartitionZeroExtension->DeviceObject);

        diskData->ReadyStatus = status;

        if (!NT_SUCCESS (status)) {
            return status;
        }
    }

    //
    // Copy drive geometry.
    //

    geometryEx = (PDISK_GEOMETRY_EX_INTERNAL)Irp->AssociatedIrp.SystemBuffer;
    geometryEx->Geometry = fdoExtension->DiskGeometry;
    geometryEx->DiskSize = commonExtension->PartitionZeroExtension->CommonExtension.PartitionLength;

    //
    // If the user buffer is large enough to hold the partition information
    // then add that as well.
    //

    if (OutputBufferLength >=  FIELD_OFFSET (DISK_GEOMETRY_EX_INTERNAL, Detection)) {

        geometryEx->Partition.SizeOfPartitionInfo = sizeof (geometryEx->Partition);
        geometryEx->Partition.PartitionStyle = diskData->PartitionStyle;

        switch ( diskData->PartitionStyle ) {

            case PARTITION_STYLE_GPT:

                //
                // Copy GPT signature.
                //

                geometryEx->Partition.Gpt.DiskId = diskData->Efi.DiskId;
                break;

            case PARTITION_STYLE_MBR:

                //
                // Copy MBR signature and checksum.
                //

                geometryEx->Partition.Mbr.Signature = diskData->Mbr.Signature;
                geometryEx->Partition.Mbr.CheckSum = diskData->Mbr.MbrCheckSum;
                break;

            default:

                //
                // This is a raw disk. Zero out the signature area so
                // nobody gets confused.
                //

                RtlZeroMemory (
                    &geometryEx->Partition,
                    sizeof (geometryEx->Partition));
        }
    }

    //
    // If the buffer is large enough to hold the detection information,
    // then also add that.
    //

    if (OutputBufferLength >= sizeof (DISK_GEOMETRY_EX_INTERNAL)) {

        geometryEx->Detection.SizeOfDetectInfo =
            sizeof (geometryEx->Detection);

        status = DiskGetDetectInfo (
                    fdoExtension,
                    &geometryEx->Detection);

        //
        // Failed to obtain detection information, set to none.
        //

        if (!NT_SUCCESS (status)) {
            geometryEx->Detection.DetectionType = DetectNone;
        }
    }


    status = STATUS_SUCCESS;
    Irp->IoStatus.Information = min (OutputBufferLength,
                                     sizeof (DISK_GEOMETRY_EX_INTERNAL));

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\geometry.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    geometry.c

Abstract:

    SCSI disk class driver - this module contains all the code for generating 
    disk geometries.

Environment:

    kernel mode only

Notes:

Revision History:

--*/


#include "disk.h"
#include "ntddstor.h"

#if defined (_X86_)

DISK_GEOMETRY_SOURCE
DiskUpdateGeometry(
    IN PFUNCTIONAL_DEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
DiskUpdateRemovableGeometry (
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

VOID
DiskScanBusDetectInfo(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE BusKey
    );

NTSTATUS
DiskSaveBusDetectInfo(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE TargetKey,
    IN ULONG DiskNumber
    );

NTSTATUS
DiskSaveGeometryDetectInfo(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE HardwareKey
    );

NTSTATUS
DiskGetPortGeometry(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    OUT PDISK_GEOMETRY Geometry
    );

typedef struct _DISK_DETECT_INFO {
    BOOLEAN Initialized;
    ULONG Style;
    ULONG Signature;
    ULONG MbrCheckSum;
    PDEVICE_OBJECT Device;
    CM_INT13_DRIVE_PARAMETER DriveParameters;
} DISK_DETECT_INFO, *PDISK_DETECT_INFO;

//
// Information about the disk geometries collected and saved into the registry 
// by NTDETECT.COM or the system firmware.
//

PDISK_DETECT_INFO DetectInfoList = NULL;
ULONG DetectInfoCount = 0;
ULONG DetectInfoUsedCount = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DiskSaveDetectInfo)
#pragma alloc_text(INIT, DiskScanBusDetectInfo)
#pragma alloc_text(INIT, DiskSaveBusDetectInfo)
#pragma alloc_text(INIT, DiskSaveGeometryDetectInfo)

#pragma alloc_text(PAGE, DiskUpdateGeometry)
#pragma alloc_text(PAGE, DiskUpdateRemovableGeometry)
#pragma alloc_text(PAGE, DiskGetPortGeometry)
#pragma alloc_text(PAGE, DiskGetDetectInfo)
#pragma alloc_text(PAGE, DiskReadSignature)
#endif



NTSTATUS
DiskSaveDetectInfo(
    PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine saves away the firmware information about the disks which has 
    been saved in the registry.  It generates a list (DetectInfoList) which 
    contains the disk geometries, signatures & checksums of all drives which 
    were examined by NtDetect.  This list is later used to assign geometries 
    to disks as they are initialized.

Arguments:

    DriverObject - the driver being initialized.  This is used to get to the 
                   hardware database.
    
Return Value:

    status.
    
--*/        
    
{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hardwareKey;

    UNICODE_STRING unicodeString;
    HANDLE busKey;

    NTSTATUS status;

    PAGED_CODE();

    InitializeObjectAttributes(
        &objectAttributes,
        DriverObject->HardwareDatabase,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    //
    // Create the hardware base key.
    //

    status = ZwOpenKey(&hardwareKey, KEY_READ, &objectAttributes);

    if(!NT_SUCCESS(status)) {
        DebugPrint((1, "DiskSaveDetectInfo: Cannot open hardware data. "
                       "Name: %wZ\n", 
                    DriverObject->HardwareDatabase));
        return status;
    }

    status = DiskSaveGeometryDetectInfo(DriverObject, hardwareKey);

    if(!NT_SUCCESS(status)) {
        DebugPrint((1, "DiskSaveDetectInfo: Can't query configuration data "
                       "(%#08lx)\n",
                    status));
        ZwClose(hardwareKey);
        return status;
    }

    //
    // Open EISA bus key.
    //

    RtlInitUnicodeString(&unicodeString, L"EisaAdapter");
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               hardwareKey,
                               NULL);

    status = ZwOpenKey(&busKey,
                       KEY_READ,
                       &objectAttributes);

    if(NT_SUCCESS(status)) {
        DebugPrint((1, "DiskSaveDetectInfo: Opened EisaAdapter key\n"));
        DiskScanBusDetectInfo(DriverObject, busKey);
        ZwClose(busKey);
    }

    //
    // Open MultiFunction bus key.
    // 

    RtlInitUnicodeString(&unicodeString, L"MultifunctionAdapter");
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeString,
                               OBJ_CASE_INSENSITIVE,
                               hardwareKey,
                               NULL);

    status = ZwOpenKey(&busKey,
                       KEY_READ,
                       &objectAttributes);

    if(NT_SUCCESS(status)) {
        DebugPrint((1, "DiskSaveDetectInfo: Opened MultifunctionAdapter key\n"));
        DiskScanBusDetectInfo(DriverObject, busKey);
        ZwClose(busKey);
    }

    ZwClose(hardwareKey);

    return STATUS_SUCCESS;
}


VOID
DiskCleanupDetectInfo(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:
    
    This routine will cleanup the data structure built by DiskSaveDetectInfo.
    
Arguments:

    DriverObject - a pointer to the kernel object for this driver.
    
Return Value:

    none
    
--*/            

{
    if(DetectInfoList != NULL) {
        ExFreePool(DetectInfoList);
        DetectInfoList = NULL;
    }
    return;
}


NTSTATUS
DiskSaveGeometryDetectInfo(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE HardwareKey
    )
{
    UNICODE_STRING unicodeString;
    PKEY_VALUE_FULL_INFORMATION keyData;
    ULONG length;

    PCM_FULL_RESOURCE_DESCRIPTOR fullDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptor;

    PCM_INT13_DRIVE_PARAMETER driveParameters;
    ULONG numberOfDrives;

    ULONG i;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Get disk BIOS geometry information.
    //

    RtlInitUnicodeString(&unicodeString, L"Configuration Data");

    keyData = ExAllocatePoolWithTag(PagedPool,
                                    VALUE_BUFFER_SIZE,
                                    DISK_TAG_UPDATE_GEOM);
                                   
    if(keyData == NULL) {
        DebugPrint((1, "DiskSaveGeometryDetectInfo: Can't allocate config "
                       "data buffer\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = ZwQueryValueKey(HardwareKey,
                             &unicodeString,
                             KeyValueFullInformation,
                             keyData,
                             VALUE_BUFFER_SIZE,
                             &length);

    if(!NT_SUCCESS(status)) {
        DebugPrint((1, "DiskSaveGeometryDetectInfo: Can't query configuration "
                       "data (%#08lx)\n",
                    status));
        ExFreePool(keyData);
        return status;
    }

    //
    // Extract the resource list out of the key data.
    // 

    fullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)
                      (((PUCHAR) keyData) + keyData->DataOffset);
    partialDescriptor = 
        fullDescriptor->PartialResourceList.PartialDescriptors;
    length = partialDescriptor->u.DeviceSpecificData.DataSize;

    if((keyData->DataLength < sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) ||
       (fullDescriptor->PartialResourceList.Count == 0) ||
       (partialDescriptor->Type != CmResourceTypeDeviceSpecific) ||
       (length < sizeof(ULONG))) {

        DebugPrint((1, "DiskSaveGeometryDetectInfo: BIOS header data too small "
                       "or invalid\n"));
        ExFreePool(keyData);
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Point to the BIOS data.  THe BIOS data is located after the first 
    // partial Resource list which should be device specific data.
    //

    {
        PUCHAR buffer = (PUCHAR) keyData;
        buffer += keyData->DataOffset;
        buffer += sizeof(CM_FULL_RESOURCE_DESCRIPTOR);
        driveParameters = (PCM_INT13_DRIVE_PARAMETER) buffer;
    }

    numberOfDrives = length / sizeof(CM_INT13_DRIVE_PARAMETER);

    //
    // Allocate our detect info list now that we know how many entries there 
    // are going to be.  No other routine allocates detect info and this is 
    // done out of DriverEntry so we don't need to synchronize it's creation.
    //

    length = sizeof(DISK_DETECT_INFO) * numberOfDrives;
    DetectInfoList = ExAllocatePoolWithTag(PagedPool,
                                           length,
                                           DISK_TAG_UPDATE_GEOM);

    if(DetectInfoList == NULL) {
        DebugPrint((1, "DiskSaveGeometryDetectInfo: Couldn't allocate %x bytes "
                       "for DetectInfoList\n", 
                    length));

        ExFreePool(keyData);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    DetectInfoCount = numberOfDrives;

    RtlZeroMemory(DetectInfoList, length);

    //
    // Copy the information out of the key data and into the list we've 
    // allocated.
    //

    for(i = 0; i < numberOfDrives; i++) {
        DetectInfoList[i].DriveParameters = driveParameters[i];
    }

    ExFreePool(keyData);
    return STATUS_SUCCESS;
}


VOID
DiskScanBusDetectInfo(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE BusKey
    )
/*++

Routine Description:

    The routine queries the registry to determine which disks are visible to
    the BIOS.  If a disk is visable to the BIOS then the geometry information
    is updated with the disk's signature and MBR checksum.

Arguments:

    DriverObject - the object for this driver.
    BusKey - handle to the bus key to be enumerated.

Return Value:

    status
    
--*/
{
    ULONG busNumber;

    NTSTATUS status;

    for(busNumber = 0; ; busNumber++) {

        WCHAR buffer[32];
        UNICODE_STRING unicodeString;

        OBJECT_ATTRIBUTES objectAttributes;

        HANDLE spareKey;
        HANDLE adapterKey;

        ULONG adapterNumber;

        DebugPrint((1, "DiskScanBusDetectInfo: Scanning bus %d\n", busNumber));

        //
        // Open controller name key.
        //

        swprintf(buffer, L"%d", busNumber);
        RtlInitUnicodeString(&unicodeString, buffer);

        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   BusKey,
                                   NULL);

        status = ZwOpenKey(&spareKey, KEY_READ, &objectAttributes);

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskScanBusDetectInfo: Error %#08lx opening bus "
                           "key %#x\n", 
                        status, busNumber));
            break;
        }

        //
        // Open up a controller ordinal key.
        //

        RtlInitUnicodeString(&unicodeString, L"DiskController");
        InitializeObjectAttributes(&objectAttributes,
                                   &unicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   spareKey,
                                   NULL);

        status = ZwOpenKey(&adapterKey, KEY_READ, &objectAttributes);
        ZwClose(spareKey);

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskScanBusDetectInfo: Error %#08lx opening "
                           "DiskController key\n", 
                           status));
            continue;
        }

        for(adapterNumber = 0; ; adapterNumber++) {

            HANDLE diskKey;
            ULONG diskNumber;
            
            //
            // Open disk key.
            //

            DebugPrint((1, "DiskScanBusDetectInfo: Scanning disk key "
                           "%d\\DiskController\\%d\\DiskPeripheral\n",
                           busNumber, adapterNumber));

            swprintf(buffer, L"%d\\DiskPeripheral", adapterNumber);
            RtlInitUnicodeString(&unicodeString, buffer);

            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       adapterKey,
                                       NULL);

            status = ZwOpenKey(&diskKey, KEY_READ, &objectAttributes);

            if(!NT_SUCCESS(status)) {
                DebugPrint((1, "DiskScanBusDetectInfo: Error %#08lx opening "
                               "disk key\n",
                               status));
                break;
            }

            for(diskNumber = 0; ; diskNumber++) {

                HANDLE targetKey;

                DebugPrint((1, "DiskScanBusDetectInfo: Scanning target key "
                               "%d\\DiskController\\%d\\DiskPeripheral\\%d\n",
                               busNumber, adapterNumber, diskNumber));

                swprintf(buffer, L"%d", diskNumber);
                RtlInitUnicodeString(&unicodeString, buffer);

                InitializeObjectAttributes(&objectAttributes,
                                           &unicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           diskKey,
                                           NULL);

                status = ZwOpenKey(&targetKey, KEY_READ, &objectAttributes);

                if(!NT_SUCCESS(status)) {
                    DebugPrint((1, "DiskScanBusDetectInfo: Error %#08lx "
                                   "opening target key\n", 
                                status));
                    break;
                }

                status = DiskSaveBusDetectInfo(DriverObject, 
                                               targetKey,
                                               diskNumber);

                ZwClose(targetKey);
            }

            ZwClose(diskKey);
        }
        ZwClose(adapterKey);
    }
    return;
}


NTSTATUS
DiskSaveBusDetectInfo(
    IN PDRIVER_OBJECT DriverObject,
    IN HANDLE TargetKey,
    IN ULONG DiskNumber
    )
/*++

Routine Description:

    This routine will transfer the firmware/ntdetect reported information 
    in the specified target key into the appropriate entry in the 
    DetectInfoList.

Arguments:

    DriverObject - the object for this driver.
    
    TargetKey - the key for the disk being saved.    

    DiskNumber - the ordinal of the entry in the DiskPeripheral tree for this 
                 entry

Return Value:

    status    

--*/
{
    PDISK_DETECT_INFO diskInfo;

    UNICODE_STRING unicodeString;

    PKEY_VALUE_FULL_INFORMATION keyData;
    ULONG length;

    NTSTATUS status;

    PAGED_CODE();

    diskInfo = &(DetectInfoList[DiskNumber]);

    if(diskInfo->Initialized) {

        ASSERT(FALSE);
        DebugPrint((1, "DiskSaveBusDetectInfo: disk entry %#x already has a "
                        "signature of %#08lx and mbr checksum of %#08lx\n", 
                        DiskNumber,
                        diskInfo->Signature,
                        diskInfo->MbrCheckSum));
        return STATUS_UNSUCCESSFUL;
    }

    RtlInitUnicodeString(&unicodeString, L"Identifier");

    keyData = ExAllocatePoolWithTag(PagedPool,
                                    VALUE_BUFFER_SIZE,
                                    DISK_TAG_UPDATE_GEOM);

    if(keyData == NULL) {
        DebugPrint((1, "DiskSaveBusDetectInfo: Couldn't allocate space for "
                       "registry data\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Get disk peripheral identifier.
    //

    status = ZwQueryValueKey(TargetKey,
                             &unicodeString,
                             KeyValueFullInformation,
                             keyData,
                             VALUE_BUFFER_SIZE,
                             &length);

    if(!NT_SUCCESS(status)) {
        DebugPrint((1, "DiskSaveBusDetectInfo: Error %#08lx getting "
                       "Identifier\n",
                    status));
        ExFreePool(keyData);
        return status;

    } else if (keyData->DataLength < 9*sizeof(WCHAR)) {

        //
        // the data is too short to use (we subtract 9 chars in normal path)
        //
        DebugPrint((1, "DiskSaveBusDetectInfo: Saved data was invalid, "
                    "not enough data in registry!\n"));
        ExFreePool(keyData);
        return STATUS_UNSUCCESSFUL;
        
    } else {

        UNICODE_STRING identifier;
        ULONG value;

        //
        // Complete unicode string.
        //
    
        identifier.Buffer = (PWSTR) ((PUCHAR)keyData + keyData->DataOffset);
        identifier.Length = (USHORT) keyData->DataLength;
        identifier.MaximumLength = (USHORT) keyData->DataLength;
    
        //
        // Get the first value out of the identifier - this will be the MBR 
        // checksum.
        //
    
        status = RtlUnicodeStringToInteger(&identifier, 16, &value);
    
        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskSaveBusDetectInfo: Error %#08lx converting "
                           "identifier %wZ into MBR xsum\n", 
                           status,
                           &identifier));
            ExFreePool(keyData);
            return status;
        }
    
        diskInfo->MbrCheckSum = value;
    
        //
        // Shift the string over to get the disk signature
        //
    
        identifier.Buffer += 9;
        identifier.Length -= 9 * sizeof(WCHAR);
        identifier.MaximumLength -= 9 * sizeof(WCHAR);
    
        status = RtlUnicodeStringToInteger(&identifier, 16, &value);
    
        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskSaveBusDetectInfo: Error %#08lx converting "
                           "identifier %wZ into disk signature\n", 
                           status,
                           &identifier));
            ExFreePool(keyData);
            value = 0;
        }

        diskInfo->Signature = value;
    }

    //
    // Here is where we would save away the extended int13 data.
    //

    //
    // Mark this entry as initialized so we can make sure not to do it again.
    //

    diskInfo->Initialized = TRUE;


    return STATUS_SUCCESS;
}


DISK_GEOMETRY_SOURCE
DiskUpdateGeometry(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine checks the DetectInfoList saved away during disk driver init
    to see if any geometry information was reported for this drive.  If the 
    geometry data exists (determined by matching non-zero signatures or 
    non-zero MBR checksums) then it will be saved in the RealGeometry member
    of the disk data block.

    ClassReadDriveCapacity MUST be called after calling this routine to update
    the cylinder count based on the size of the disk and the presence of any 
    disk management software.

Arguments:

    DeviceExtension - Supplies a pointer to the device information for disk.

Return Value:

    Inidicates whether the "RealGeometry" in the data block is now valid.

--*/

{
    PDISK_DATA diskData = FdoExtension->CommonExtension.DriverData;

    ULONG i;
    PDISK_DETECT_INFO diskInfo;

    BOOLEAN found = FALSE;

    NTSTATUS status;

    PAGED_CODE();


    ASSERT(FdoExtension->CommonExtension.IsFdo);
    ASSERT((FdoExtension->DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA) == 0);

    //
    // If we've already set a non-default geometry for this drive then there's 
    // no need to try and update again.
    //

    if(diskData->GeometrySource != DiskGeometryUnknown) {
        return diskData->GeometrySource;
    }

    //
    // Scan through the saved detect info to see if we can find a match 
    // for this device.
    //

    for(i = 0; i < DetectInfoCount; i++) {

        ASSERT(DetectInfoList != NULL);

        diskInfo = &(DetectInfoList[i]);

        if((diskData->Mbr.Signature != 0) && 
           (diskData->Mbr.Signature == diskInfo->Signature)) { 
            DebugPrint((1, "DiskUpdateGeometry: found match for signature "
                           "%#08lx\n",
                        diskData->Mbr.Signature));
            found = TRUE;
            break;
        } else if((diskData->Mbr.Signature == 0) && 
                  (diskData->Mbr.MbrCheckSum != 0) &&
                  (diskData->Mbr.MbrCheckSum == diskInfo->MbrCheckSum)) {
            DebugPrint((1, "DiskUpdateGeometry: found match for xsum %#08lx\n",
                        diskData->Mbr.MbrCheckSum));
            found = TRUE;
            break;
        }
    }

    if(found) {

        ULONG cylinders;
        ULONG sectorsPerTrack;
        ULONG tracksPerCylinder;

        ULONG sectors;
        ULONG length;

        //
        // Point to the array of drive parameters.
        //
        
        cylinders = diskInfo->DriveParameters.MaxCylinders + 1;
        sectorsPerTrack = diskInfo->DriveParameters.SectorsPerTrack;
        tracksPerCylinder = diskInfo->DriveParameters.MaxHeads + 1;

        //
        // Since the BIOS may not report the full drive, recalculate the drive
        // size based on the volume size and the BIOS values for tracks per
        // cylinder and sectors per track..
        //
    
        length = tracksPerCylinder * sectorsPerTrack;
    
        if (length == 0) {
    
            //
            // The BIOS information is bogus.
            //
    
            DebugPrint((1, "DiskUpdateGeometry: H (%d) or S(%d) is zero\n",
                        tracksPerCylinder, sectorsPerTrack));
            return FALSE;
        }
    
        //
        // since we are copying the structure RealGeometry here, we should
        // really initialize all the fields, especially since a zero'd
        // BytesPerSector field would cause a trap in xHalReadPartitionTable()
        //

        diskData->RealGeometry = FdoExtension->DiskGeometry;
        
        //
        // Save the geometry information away in the disk data block and 
        // set the bit indicating that we found a valid one.
        //

        diskData->RealGeometry.SectorsPerTrack = sectorsPerTrack;
        diskData->RealGeometry.TracksPerCylinder = tracksPerCylinder;
        diskData->RealGeometry.Cylinders.QuadPart = (LONGLONG)cylinders;

        DebugPrint((1, "DiskUpdateGeometry: BIOS spt %#x, #heads %#x, "
                       "#cylinders %#x\n",
                   sectorsPerTrack, tracksPerCylinder, cylinders));

        diskData->GeometrySource = DiskGeometryFromBios;
        diskInfo->Device = FdoExtension->DeviceObject;

    } else {
    
       DebugPrint((1, "DiskUpdateGeometry: no match found for signature %#08lx\n", diskData->Mbr.Signature));
    }

    if(diskData->GeometrySource == DiskGeometryUnknown) {

        //
        // We couldn't find a geometry from the BIOS.  Check with the port 
        // driver and see if it can provide one.
        //

        status = DiskGetPortGeometry(FdoExtension, &(diskData->RealGeometry));

        if(NT_SUCCESS(status)) {

            //
            // Check the geometry to make sure it's valid.
            //

            if((diskData->RealGeometry.TracksPerCylinder * 
                diskData->RealGeometry.SectorsPerTrack) != 0) {

                diskData->GeometrySource = DiskGeometryFromPort;
                DebugPrint((1, "DiskUpdateGeometry: using Port geometry for disk %#p\n", FdoExtension));
                
                if (diskData->RealGeometry.BytesPerSector == 0) {
                    
                    DebugPrint((0, "DiskDriverReinit: Port driver failed to "
                                "set BytesPerSector in the RealGeometry\n"));
                    diskData->RealGeometry.BytesPerSector =
                        FdoExtension->DiskGeometry.BytesPerSector;
                    if (diskData->RealGeometry.BytesPerSector == 0) {
                        ASSERT(!"BytesPerSector is still zero!");
                    }

                }
            }
        }
    }

    //
    // If we came up with a "real" geometry for this drive then set it in the 
    // device extension.
    //

    if(diskData->GeometrySource != DiskGeometryUnknown) {
        FdoExtension->DiskGeometry = diskData->RealGeometry;

        //
        // Increment the count of used geometry entries.
        //

        InterlockedIncrement(&DetectInfoUsedCount);
    }

    return diskData->GeometrySource;
}


NTSTATUS
DiskUpdateRemovableGeometry (
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine updates the geometry of the disk.  It will query the port 
    driver to see if it can provide any geometry info.  If not it will use 
    the current head & sector count.
    
    Based on these values & the capacity of the drive as reported by 
    ClassReadDriveCapacity it will determine a new cylinder count for the 
    device.

Arguments:

    Fdo - Supplies the functional device object whos size needs to be updated.

Return Value:

    Returns the status of the opertion.

--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = &(FdoExtension->CommonExtension);
    PDISK_DATA diskData = commonExtension->DriverData;
    PDISK_GEOMETRY geometry = &(diskData->RealGeometry);

    NTSTATUS status;

    PAGED_CODE();

    ASSERT_FDO(commonExtension->DeviceObject);
    if (FdoExtension->DeviceDescriptor) {
        ASSERT(FdoExtension->DeviceDescriptor->RemovableMedia);
    }
    ASSERT(TEST_FLAG(FdoExtension->DeviceObject->Characteristics,
                     FILE_REMOVABLE_MEDIA));

    //
    // Attempt to determine the disk geometry.  First we'll check with the 
    // port driver to see what it suggests for a value.
    //

    status = DiskGetPortGeometry(FdoExtension, geometry);

    if(NT_SUCCESS(status) && 
       ((geometry->TracksPerCylinder * geometry->SectorsPerTrack) != 0)) {

        FdoExtension->DiskGeometry = (*geometry);
    }

    return status;
}


NTSTATUS
DiskGetPortGeometry(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    OUT PDISK_GEOMETRY Geometry
    )
/*++

Routine Description:

    This routine will query the port driver for disk geometry.  Some port 
    drivers (in particular IDEPORT) may be able to provide geometry for the 
    device.
    
Arguments:

    FdoExtension - the device object for the disk.
    
    Geometry - a structure to save the geometry information into (if any is 
               available)
               
Return Value:
    
    STATUS_SUCCESS if geometry information can be provided or 
    error status indicating why it can't.
    
--*/
{
    PCOMMON_DEVICE_EXTENSION commonExtension = &(FdoExtension->CommonExtension);
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT event;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Build an irp to send IOCTL_DISK_GET_DRIVE_GEOMETRY to the lower driver.
    //

    irp = IoAllocateIrp(commonExtension->LowerDeviceObject->StackSize, FALSE);

    if(irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_DEVICE_CONTROL;

    irpStack->Parameters.DeviceIoControl.IoControlCode = 
        IOCTL_DISK_GET_DRIVE_GEOMETRY;
    irpStack->Parameters.DeviceIoControl.OutputBufferLength = 
        sizeof(DISK_GEOMETRY);

    irp->AssociatedIrp.SystemBuffer = Geometry;

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoSetCompletionRoutine(irp, 
                           ClassSignalCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(commonExtension->LowerDeviceObject, irp);
    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    ASSERT((status == STATUS_PENDING) || (status == irp->IoStatus.Status));
    status = irp->IoStatus.Status;

    IoFreeIrp(irp);

    return status;
}



NTSTATUS
DiskReadDriveCapacity(
    IN PDEVICE_OBJECT Fdo
    )
/*++

Routine Description:

    This routine is used by disk.sys as a wrapper for the classpnp API 
    ClassReadDriveCapacity.  It will perform some additional operations to 
    attempt to determine drive geometry before it calls the classpnp version 
    of the routine.
    
    For fixed disks this involves calling DiskUpdateGeometry which will check 
    various sources (the BIOS, the port driver) for geometry information.
    
Arguments:

    Fdo - a pointer to the device object to be checked.    

Return Value:

    status of ClassReadDriveCapacity.
    
--*/        

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PDISK_DATA diskData = fdoExtension->CommonExtension.DriverData;
    DISK_GEOMETRY_SOURCE diskGeometrySource = DiskGeometryUnknown;
    NTSTATUS status;

    ASSERT_FDO(Fdo);

    if (TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)) {
        DiskUpdateRemovableGeometry(fdoExtension);
    } else {
        diskGeometrySource = DiskUpdateGeometry(fdoExtension);
    }

    status = ClassReadDriveCapacity(Fdo);

    return status;
}



VOID
DiskDriverReinitialization(
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Nothing,
    IN ULONG Count
    )
/*++

Routine Description:

    This routine will scan through the current list of disks and attempt to 
    match them to any remaining geometry information.  This will only be done 
    on the first call to the routine.

    Note: This routine assumes that the system will not be adding or removing
          devices during this phase of the init process.  This is very likely
          a bad assumption but it greatly simplifies the code.

Arguments:

    DriverObject - a pointer to the object for the disk driver.
    
    Nothing - unused
    
    Count - an indication of how many times this routine has been called.
    
Return Value:

    none

--*/

{
    PDEVICE_OBJECT deviceObject;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension;
    PDISK_DATA diskData;

    ULONG unmatchedDiskCount;
    PDEVICE_OBJECT unmatchedDisk = NULL;

    ULONG i;
    PDISK_DETECT_INFO diskInfo = NULL;

    if(Count != 1) {
        DebugPrint((1, "DiskDriverReinitialization: ignoring call %d\n", 
                    Count));
        return;
    }

    //
    // Check to see how many entries in the detect info list have been matched.
    // If there's only one remaining we'll see if we can find a disk to go with
    // it.
    //

    if(DetectInfoCount == 0) {
        DebugPrint((1, "DiskDriverReinitialization: no detect info saved\n"));
        return;
    }

    if((DetectInfoCount - DetectInfoUsedCount) != 1) {
        DebugPrint((1, "DiskDriverReinitialization: %d of %d geometry entries "
                       "used - will not attempt match\n"));
        return;
    }

    //
    // Scan through the list of disks and see if any of them are missing
    // geometry information.  If there is only one such disk we'll try to 
    // match it to the unmatched geometry.
    //
    
    
    //
    // ISSUE-2000/5/24-henrygab - figure out if there's a way to keep
    //                            removals from happening while doing this.
    //

    for(deviceObject = DriverObject->DeviceObject, unmatchedDiskCount = 0;
        deviceObject != NULL;
        deviceObject = deviceObject->NextDevice) {

        //
        // Make sure this is a disk and not a partition.
        //

        fdoExtension = deviceObject->DeviceExtension;
        if(fdoExtension->CommonExtension.IsFdo == FALSE) {
            DebugPrint((1, "DiskDriverReinit: DO %#p is not an FDO\n", 
                           deviceObject));
            continue;
        }

        //
        // If the geometry for this one is already known then skip it.
        //

        diskData = fdoExtension->CommonExtension.DriverData;
        if(diskData->GeometrySource != DiskGeometryUnknown) {
            DebugPrint((1, "DiskDriverReinit: FDO %#p has a geometry\n", 
                           deviceObject));
            continue;
        }

        DebugPrint((1, "DiskDriverReinit: FDO %#p has no geometry\n",
                       deviceObject));

        //
        // Mark this one as using the default.  It's past the time when disk
        // might blunder across the geometry info.  If we set the geometry 
        // from the bios we'll reset this field down below.
        //

        diskData->GeometrySource = DiskGeometryFromDefault;

        //
        // As long as we've only got one unmatched disk we're fine.
        //

        unmatchedDiskCount++;
        if(unmatchedDiskCount > 1) {
            ASSERT(unmatchedDisk != NULL);
            DebugPrint((1, "DiskDriverReinit: FDO %#p also has no geometry\n",
                           unmatchedDisk));
            unmatchedDisk = NULL;
            break;
        }

        unmatchedDisk = deviceObject;
    }

    //
    // If there's more or less than one ungeometried disk then we can't do 
    // anything about the geometry.
    //

    if(unmatchedDiskCount != 1) {
        DebugPrint((1, "DiskDriverReinit: Unable to match geometry\n"));
        return;

    }

    fdoExtension = unmatchedDisk->DeviceExtension;
    diskData = fdoExtension->CommonExtension.DriverData;

    DebugPrint((1, "DiskDriverReinit: Found possible match\n"));

    //
    // Find the geometry which wasn't assigned.
    //

    for(i = 0; i < DetectInfoCount; i++) {
        if(DetectInfoList[i].Device == NULL) {
            diskInfo = &(DetectInfoList[i]);
            break;
        }
    }

    ASSERT(diskInfo != NULL);

    {
        //
        // Save the geometry information away in the disk data block and 
        // set the bit indicating that we found a valid one.
        //

        ULONG cylinders;
        ULONG sectorsPerTrack;
        ULONG tracksPerCylinder;

        ULONG sectors;
        ULONG length;

        //
        // Point to the array of drive parameters.
        //
        
        cylinders = diskInfo->DriveParameters.MaxCylinders + 1;
        sectorsPerTrack = diskInfo->DriveParameters.SectorsPerTrack;
        tracksPerCylinder = diskInfo->DriveParameters.MaxHeads + 1;

        //
        // Since the BIOS may not report the full drive, recalculate the drive
        // size based on the volume size and the BIOS values for tracks per
        // cylinder and sectors per track..
        //
    
        length = tracksPerCylinder * sectorsPerTrack;
    
        if (length == 0) {
    
            //
            // The BIOS information is bogus.
            //
    
            DebugPrint((1, "DiskDriverReinit: H (%d) or S(%d) is zero\n",
                        tracksPerCylinder, sectorsPerTrack));
            return;
        }
    
        //
        // since we are copying the structure RealGeometry here, we should
        // really initialize all the fields, especially since a zero'd
        // BytesPerSector field would cause a trap in xHalReadPartitionTable()
        //
        
        diskData->RealGeometry = fdoExtension->DiskGeometry;
        
        //
        // Save the geometry information away in the disk data block and 
        // set the bit indicating that we found a valid one.
        //
    
        diskData->RealGeometry.SectorsPerTrack = sectorsPerTrack;
        diskData->RealGeometry.TracksPerCylinder = tracksPerCylinder;
        diskData->RealGeometry.Cylinders.QuadPart = (LONGLONG)cylinders;

        DebugPrint((1, "DiskDriverReinit: BIOS spt %#x, #heads %#x, "
                       "#cylinders %#x\n",
                   sectorsPerTrack, tracksPerCylinder, cylinders));

        diskData->GeometrySource = DiskGeometryGuessedFromBios;
        diskInfo->Device = unmatchedDisk;

        //
        // Now copy the geometry over to the fdo extension and call 
        // classpnp to redetermine the disk size and cylinder count.
        //

        fdoExtension->DiskGeometry = diskData->RealGeometry;
        
        //
        // BUGBUG - why not call DiskReadDriveCapacity()?
        //

        ClassReadDriveCapacity(unmatchedDisk);

        if (diskData->RealGeometry.BytesPerSector == 0) {

            //
            // if the BytesPerSector field is set to zero for a disk
            // listed in the bios, then the system will bugcheck in
            // xHalReadPartitionTable().  assert here since it is
            // easier to determine what is happening this way.
            //

            ASSERT(!"RealGeometry not set to non-zero bps\n");
        }
    }

    return;
}


NTSTATUS
DiskGetDetectInfo(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    OUT PDISK_DETECTION_INFO DetectInfo
    )
/*++

Routine Description:

    Get the Int13 information from the BIOS DetectInfoList.

Arguments:

    FdoExtension - Supplies a pointer to the FDO extension that we want to
            obtain the detect information for.

    DetectInfo - A buffer where the detect information will be copied to.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    BOOLEAN found;
    PDISK_DETECT_INFO diskInfo;
    PDISK_DATA diskData = FdoExtension->CommonExtension.DriverData;

    PAGED_CODE ();

    ASSERT(FdoExtension->CommonExtension.IsFdo);

    //
    // Fail for non-fixed drives.
    //
    
    if (TEST_FLAG (FdoExtension->DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA)) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // There is no GPT detection info, so fail this.
    //
    
    if (diskData->PartitionStyle == PARTITION_STYLE_GPT) {
        return STATUS_NOT_SUPPORTED;
    }

    for(i = 0; i < DetectInfoCount; i++) {

        
        ASSERT(DetectInfoList != NULL);

        diskInfo = &(DetectInfoList[i]);

        if((diskData->Mbr.Signature != 0) && 
           (diskData->Mbr.Signature == diskInfo->Signature)) { 
            DebugPrint((1, "DiskGetDetectInfo: found match for signature "
                           "%#08lx\n",
                        diskData->Mbr.Signature));
            found = TRUE;
            break;
        } else if((diskData->Mbr.Signature == 0) && 
                  (diskData->Mbr.MbrCheckSum != 0) &&
                  (diskData->Mbr.MbrCheckSum == diskInfo->MbrCheckSum)) {
            DebugPrint((1, "DiskGetDetectInfo: found match for xsum %#08lx\n",
                        diskData->Mbr.MbrCheckSum));
            found = TRUE;
            break;
        }
    }

    if ( found ) {
        DetectInfo->DetectionType = DetectInt13;
        DetectInfo->Int13.DriveSelect = diskInfo->DriveParameters.DriveSelect;
        DetectInfo->Int13.MaxCylinders = diskInfo->DriveParameters.MaxCylinders;
        DetectInfo->Int13.SectorsPerTrack = diskInfo->DriveParameters.SectorsPerTrack;
        DetectInfo->Int13.MaxHeads = diskInfo->DriveParameters.MaxHeads;
        DetectInfo->Int13.NumberDrives = diskInfo->DriveParameters.NumberDrives;
        RtlZeroMemory (&DetectInfo->ExInt13, sizeof (DetectInfo->ExInt13));
    }

    return (found ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL);
}


NTSTATUS
DiskReadSignature(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    Read the disks signature from the drive. The signature can be either
    a MBR signature or a GPT/EFI signature.

    The low-level signature reading is done by IoReadDiskSignature().

Arguments:

    Fdo - Pointer to the FDO of a disk to read the signature for.
    
Return Value:

    NTSTATUS code.

--*/


{
    NTSTATUS Status;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PDISK_DATA diskData = fdoExtension->CommonExtension.DriverData;
    DISK_SIGNATURE Signature;

    PAGED_CODE ();
    
    Status = IoReadDiskSignature (Fdo,
                                  fdoExtension->DiskGeometry.BytesPerSector,
                                  &Signature);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }
    
    if (Signature.PartitionStyle == PARTITION_STYLE_GPT) {
        diskData->PartitionStyle = PARTITION_STYLE_GPT;
        diskData->Efi.DiskId = Signature.Gpt.DiskId;
    } else if (Signature.PartitionStyle == PARTITION_STYLE_MBR) {
        diskData->PartitionStyle = PARTITION_STYLE_MBR;
        diskData->Mbr.Signature = Signature.Mbr.Signature;
        diskData->Mbr.MbrCheckSum = Signature.Mbr.CheckSum;
    } else {
        ASSERT (FALSE);
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

#endif // defined(_X86_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\enum.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    pnp.c

Abstract:

    SCSI disk class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "disk.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, DiskConvertExtendedToLayout)
#pragma alloc_text(PAGE, DiskConvertPartitionToExtended)
#pragma alloc_text(PAGE, DiskConvertLayoutToExtended)
#pragma alloc_text(PAGE, DiskCreatePdo)
#pragma alloc_text(PAGE, DiskEnumerateDevice)
#pragma alloc_text(PAGE, DiskUpdateRemovablePartitions)
#pragma alloc_text(PAGE, DiskUpdatePartitions)
#pragma alloc_text(PAGE, DiskCreatePdo)

#endif

PDRIVE_LAYOUT_INFORMATION
DiskConvertExtendedToLayout(
    IN CONST PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    )
{
    ULONG i;
    ULONG LayoutSize;
    PDRIVE_LAYOUT_INFORMATION Layout;
    PPARTITION_INFORMATION Partition;
    PPARTITION_INFORMATION_EX PartitionEx;

    PAGED_CODE ();

    ASSERT ( LayoutEx );


    //
    // The only valid conversion is from an MBR extended layout structure to
    // the old structure.
    //
    
    if (LayoutEx->PartitionStyle != PARTITION_STYLE_MBR) {
        ASSERT ( FALSE );
        return NULL;
    }

    LayoutSize = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]) +
                 LayoutEx->PartitionCount * sizeof (PARTITION_INFORMATION);
    
    Layout = ExAllocatePoolWithTag (
                    NonPagedPool,
                    LayoutSize,
                    DISK_TAG_PART_LIST
                    );

    if ( Layout == NULL ) {
        return NULL;
    }
    
    Layout->Signature = LayoutEx->Mbr.Signature;
    Layout->PartitionCount = LayoutEx->PartitionCount;

    for (i = 0; i < LayoutEx->PartitionCount; i++) {

        Partition = &Layout->PartitionEntry[i];
        PartitionEx = &LayoutEx->PartitionEntry[i];

        Partition->StartingOffset = PartitionEx->StartingOffset;
        Partition->PartitionLength = PartitionEx->PartitionLength;
        Partition->RewritePartition = PartitionEx->RewritePartition;
        Partition->PartitionNumber = PartitionEx->PartitionNumber;

        Partition->PartitionType = PartitionEx->Mbr.PartitionType;
        Partition->BootIndicator = PartitionEx->Mbr.BootIndicator;
        Partition->RecognizedPartition = PartitionEx->Mbr.RecognizedPartition;
        Partition->HiddenSectors = PartitionEx->Mbr.HiddenSectors;
    }

    return Layout;
}

VOID
DiskConvertPartitionToExtended(
    IN PPARTITION_INFORMATION Partition,
    OUT PPARTITION_INFORMATION_EX PartitionEx
    )

/*++

Routine Description:

    Convert a PARTITION_INFORMATION structure to a PARTITION_INFORMATION_EX
    structure. 

Arguments:

    Partition - A pointer to the PARTITION_INFORMATION structure to convert.

    PartitionEx - A pointer to a buffer where the converted
        PARTITION_INFORMATION_EX structure is to be stored.

Return Values:

    None.

--*/

{
    PAGED_CODE ();

    ASSERT ( PartitionEx != NULL );
    ASSERT ( Partition != NULL );

    PartitionEx->PartitionStyle = PARTITION_STYLE_MBR;
    PartitionEx->StartingOffset = Partition->StartingOffset;
    PartitionEx->PartitionLength = Partition->PartitionLength;
    PartitionEx->RewritePartition = Partition->RewritePartition;
    PartitionEx->PartitionNumber = Partition->PartitionNumber;

    PartitionEx->Mbr.PartitionType = Partition->PartitionType;
    PartitionEx->Mbr.BootIndicator = Partition->BootIndicator;
    PartitionEx->Mbr.RecognizedPartition = Partition->RecognizedPartition;
    PartitionEx->Mbr.HiddenSectors = Partition->HiddenSectors;
}


PDRIVE_LAYOUT_INFORMATION_EX 
DiskConvertLayoutToExtended(
    IN CONST PDRIVE_LAYOUT_INFORMATION Layout
    )

/*++

Routine Description:

    Convert a DRIVE_LAYOUT_INFORMATION structure into a
    DRIVE_LAYOUT_INFORMATION_EX structure.

Arguments:

    Layout - The source DRIVE_LAYOUT_INFORMATION structure.

Return Values:

    The resultant DRIVE_LAYOUT_INFORMATION_EX structure. This buffer must
    be freed by the callee using ExFreePool.

--*/
    
{
    ULONG i;
    ULONG size;
    PDRIVE_LAYOUT_INFORMATION_EX layoutEx;

    PAGED_CODE ();

    ASSERT ( Layout != NULL );
    

    //
    // Allocate enough space for a DRIVE_LAYOUT_INFORMATION_EX structure
    // plus as many PARTITION_INFORMATION_EX structures as are in the
    // source array.
    //
    
    size = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]) +
            Layout->PartitionCount * sizeof ( PARTITION_INFORMATION_EX );
            
    layoutEx = ExAllocatePoolWithTag(
                            NonPagedPool,
                            size,
                            DISK_TAG_PART_LIST
                            );

    if ( layoutEx == NULL ) {
        return NULL;
    }
    
    //
    // Convert the disk information.
    //
    
    layoutEx->PartitionStyle = PARTITION_STYLE_MBR;
    layoutEx->PartitionCount = Layout->PartitionCount;
    layoutEx->Mbr.Signature = Layout->Signature;
    
    for (i = 0; i < Layout->PartitionCount; i++) {

        //
        // Convert each entry.
        //
        
        DiskConvertPartitionToExtended (
                &Layout->PartitionEntry[i],
                &layoutEx->PartitionEntry[i]
                );
    }

    return layoutEx;
}



NTSTATUS
DiskEnumerateDevice(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called by the class driver to update the PDO list off
    of this FDO.  The disk driver also calls it internally to re-create
    device objects.

    This routine will read the partition table and create new PDO objects as
    necessary.  PDO's that no longer exist will be pulled out of the PDO list
    so that pnp will destroy them.

Arguments:

    Fdo - a pointer to the FDO being re-enumerated

Return Value:

    status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = Fdo->DeviceExtension;
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;

    PDISK_DATA diskData = (PDISK_DATA) commonExtension->DriverData;

    PDEVICE_OBJECT pdo = NULL;

    ULONG numberListElements = 0;

    PDRIVE_LAYOUT_INFORMATION_EX partitionList;

    NTSTATUS status;

    ASSERT(commonExtension->IsFdo);

    PAGED_CODE();

    //
    // Update our image of the size of the drive.  This may be necessary if
    // the drive size is extended or we just released a reservation to 
    // ensure the kernel doesn't reject the partition table.
    //

    DiskReadDriveCapacity(Fdo);

    //
    // Lock out anyone else trying to repartition the disk.
    //

    DiskAcquirePartitioningLock(fdoExtension);

    //
    // Create objects for all the partitions on the device.
    //

    status = DiskReadPartitionTableEx(fdoExtension, FALSE, &partitionList);

    //
    // If the I/O read partition table failed and this is a removable device,
    // then fix up the partition list to make it look like there is one
    // zero length partition.
    //

    if ((!NT_SUCCESS(status) || partitionList->PartitionCount == 0) &&
         Fdo->Characteristics & FILE_REMOVABLE_MEDIA) {

        SIZE_T partitionListSize;

        //
        // Remember whether the drive is ready.
        //

        diskData->ReadyStatus = status;

        //
        // Allocate and zero a partition list.
        //

        partitionListSize = 
            FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[1]);
                            
        partitionList = ExAllocatePoolWithTag(NonPagedPool,
                                              partitionListSize,
                                              DISK_TAG_PART_LIST);

        if (partitionList != NULL) {

            RtlZeroMemory( partitionList, partitionListSize );

            //
            // Set the partition count to one and the status to success
            // so one device object will be created. Set the partition type
            // to a bogus value.
            //

            partitionList->PartitionStyle = PARTITION_STYLE_MBR;
            partitionList->PartitionCount = 1;

            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(status)) {

        diskData->UpdatePartitionRoutine(Fdo, partitionList);
        
        //
        // Record disk signature.  
        //

        if (partitionList->PartitionStyle == PARTITION_STYLE_MBR) {

            diskData->PartitionStyle = PARTITION_STYLE_MBR;
            diskData->Mbr.Signature = partitionList->Mbr.Signature;

        } else {

            diskData->PartitionStyle = PARTITION_STYLE_GPT;
            diskData->Efi.DiskId = partitionList->Gpt.DiskId;
        }
    }

    DiskReleasePartitioningLock(fdoExtension);

    return(STATUS_SUCCESS);

} // end DiskEnumerateDevice()


VOID
DiskUpdateRemovablePartitions(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PDRIVE_LAYOUT_INFORMATION_EX PartitionList
    )

/*++

Routine Description:

    This routine is called by the class DLL to update the PDO list off of this
    FDO.  The disk driver also calls it internally to re-create device objects.

    This routine will read the partition table and update the size of the
    single partition device object which always exists for removable devices.

Arguments:

    Fdo - a pointer to the FDO being reenumerated.

Return Value:

    status

--*/

{

    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;

    ULONG partitionCount;

    ULONG partitionNumber;
    ULONG partitionOrdinal = 0;
    ULONG newPartitionNumber;

    PDISK_DATA pdoData;
    NTSTATUS status;

    PPARTITION_INFORMATION_EX partitionEntry;
    PARTITION_STYLE partitionStyle;

    PAGED_CODE();

    ASSERT(Fdo->Characteristics & FILE_REMOVABLE_MEDIA);

    partitionStyle = PartitionList->PartitionStyle;
    partitionCount = PartitionList->PartitionCount;

    for(partitionNumber = 0;
        partitionNumber < partitionCount;
        partitionNumber++) {

        partitionEntry = &(PartitionList->PartitionEntry[partitionNumber]);

        partitionEntry->PartitionNumber = 0;
    }

    //
    // Get exclusive access to the child list while repartitioning.
    //

    ClassAcquireChildLock(fdoExtension);

    //
    // Removable media should never have more than one PDO.
    //

    pdoExtension = fdoExtension->CommonExtension.ChildList;

    if(pdoExtension == NULL) {

        PARTITION_INFORMATION_EX tmpPartitionEntry;
        PDEVICE_OBJECT pdo;

        //
        // There is no PDO currently.  Create one and pre-initialize it with
        // a zero length.
        //

        RtlZeroMemory(&tmpPartitionEntry, sizeof(tmpPartitionEntry));

        tmpPartitionEntry.PartitionNumber = 1;

        DebugPrint((1, "DiskUpdateRemovablePartitions: Creating RM partition\n"));

        status = DiskCreatePdo(Fdo,
                               0,
                               &tmpPartitionEntry,
                               partitionStyle,
                               &pdo);

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "DiskUpdateRemovablePartitions: error %lx creating "
                           "new PDO for RM partition\n",
                           status));

            ClassReleaseChildLock(fdoExtension);
            return;
        }

        //
        // mark the new device as enumerated
        //

        pdoExtension = pdo->DeviceExtension;
        pdoExtension->IsMissing = FALSE;

    }

    pdoData = pdoExtension->CommonExtension.DriverData;

    //
    // Search the partition list for a valid entry.  We're looking for a
    // primary partition since we only support the one.
    //

    for(partitionNumber = 0;
        partitionNumber < partitionCount;
        partitionNumber++) {

        partitionEntry = &(PartitionList->PartitionEntry[partitionNumber]);


        //
        // Is this partition interesting?
        //
        
        if (partitionStyle == PARTITION_STYLE_MBR) {

            if(partitionEntry->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
               IsContainerPartition(partitionEntry->Mbr.PartitionType)) {
               
                continue;
            }
        }

        partitionOrdinal++;

        //
        // We have found the first and thus only partition allowed on
        // this disk.  Update the information in the PDO to match the new
        // partition.
        //
        DebugPrint((1, "DiskUpdateRemovablePartitions: Matched %wZ to #%d, "
                       "ordinal %d\n",
                       &pdoExtension->CommonExtension.DeviceName,
                       partitionEntry->PartitionNumber,
                       partitionOrdinal));


        partitionEntry->PartitionNumber = 1;

        pdoData->PartitionStyle = partitionStyle;
        pdoData->PartitionOrdinal = partitionOrdinal;
        ASSERT(partitionEntry->PartitionLength.LowPart != 0x23456789);

        pdoExtension->CommonExtension.StartingOffset =
            partitionEntry->StartingOffset;

        pdoExtension->CommonExtension.PartitionLength =
            partitionEntry->PartitionLength;


        if (partitionStyle == PARTITION_STYLE_MBR) {

            pdoData->Mbr.HiddenSectors = partitionEntry->Mbr.HiddenSectors;
            pdoData->Mbr.BootIndicator = partitionEntry->Mbr.BootIndicator;
            

            //
            // If this partition is being re-written then update the type
            // information as well
            //

            if (partitionEntry->RewritePartition) {
                pdoData->Mbr.PartitionType = partitionEntry->Mbr.PartitionType;
            }

        } else {

            pdoData->Efi.PartitionType = partitionEntry->Gpt.PartitionType;
            pdoData->Efi.PartitionId = partitionEntry->Gpt.PartitionId;
            pdoData->Efi.Attributes = partitionEntry->Gpt.Attributes;

            RtlCopyMemory(
                    pdoData->Efi.PartitionName,
                    partitionEntry->Gpt.Name,
                    sizeof (pdoData->Efi.PartitionName)
                    );
        }

        //
        // Mark this one as found
        //

        pdoExtension->IsMissing = FALSE;
        ClassReleaseChildLock(fdoExtension);
        return;
    }

    //
    // No interesting partition was found. 
    //

    if (partitionStyle == PARTITION_STYLE_MBR) {

        pdoData->Mbr.HiddenSectors = 0;
        pdoData->Mbr.PartitionType = PARTITION_ENTRY_UNUSED;

    } else {

        RtlZeroMemory (&pdoData->Efi,
                       sizeof (pdoData->Efi)
                       );
    }
    
    pdoExtension->CommonExtension.StartingOffset.QuadPart = 0;
    pdoExtension->CommonExtension.PartitionLength.QuadPart = 0;

    ClassReleaseChildLock(fdoExtension);
    return;
}


VOID
DiskUpdatePartitions(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PDRIVE_LAYOUT_INFORMATION_EX PartitionList
    )

/*++

Routine Description:

    This routine will synchronize the information held in the partition list
    with the device objects hanging off this Fdo.  Any new partition objects
    will be created, any non-existant ones will be marked as un-enumerated.

    This will be done in several stages:

        * Clear state (partition number) from every entry in the partition
          list

        * Set IsMissing flag on every child of this FDO

        * For each child of the FDO:
            if a matching partition exists in the partition list,
            update the partition number in the table, update the
            ordinal in the object and mark the object as enumerated

        * For each un-enumerated device object
            zero out the partition information to invalidate the device
            delete the symbolic link if any

        * For each un-matched entry in the partition list:
            create a new partition object
            update the partition number in the list entry
            create a new symbolic link if necessary

Arguments:

    Fdo - a pointer to the functional device object this partition list is for

    PartitionList - a pointer to the partition list being updated

Return Value:

    none

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PPHYSICAL_DEVICE_EXTENSION oldChildList = NULL;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;

    ULONG partitionCount;

    ULONG partitionNumber;
    ULONG partitionOrdinal;
    ULONG newPartitionNumber;

    PPARTITION_INFORMATION_EX partitionEntry;
    PDISK_DATA pdoData;
    PARTITION_STYLE partitionStyle;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Get exclusive access to the child list.
    //

    ClassAcquireChildLock(fdoExtension);

    partitionStyle = PartitionList->PartitionStyle;

    partitionCount = PartitionList->PartitionCount;

    //
    // Pull all the child device objects off the children list.  We'll
    // add them back later.
    //

    oldChildList = fdoExtension->CommonExtension.ChildList;
    fdoExtension->CommonExtension.ChildList = NULL;

    //
    // Clear the partition numbers from the list entries
    //

    for(partitionNumber = 0;
        partitionNumber < partitionCount;
        partitionNumber++) {

        partitionEntry = &(PartitionList->PartitionEntry[partitionNumber]);
        partitionEntry->PartitionNumber = 0;
    }

    //
    // Now match each child partition to it's entry (if any) in the partition
    // list.
    //

    while(oldChildList != NULL) {

        pdoExtension = oldChildList;
        pdoData = pdoExtension->CommonExtension.DriverData;

        //
        // Check all partition entries for a match on offset and length
        //

        partitionOrdinal = 0;

        for(partitionNumber = 0;
            partitionNumber < partitionCount;
            partitionNumber++) {

            partitionEntry = &(PartitionList->PartitionEntry[partitionNumber]);

            //
            // Is this an interesting partition entry?
            //

            if (partitionStyle == PARTITION_STYLE_MBR) {

                if((partitionEntry->Mbr.PartitionType == PARTITION_ENTRY_UNUSED) ||
                   (IsContainerPartition(partitionEntry->Mbr.PartitionType))) {

                    continue;
                }
            }

            partitionOrdinal++;

            if(partitionEntry->PartitionNumber) {

                //
                // This partition has already been found - skip it
                //

                continue;
            }

            //
            // Let's see if the partition information matches
            //

            if(partitionEntry->StartingOffset.QuadPart !=
               pdoExtension->CommonExtension.StartingOffset.QuadPart) {
                continue;
            }

            if(partitionEntry->PartitionLength.QuadPart !=
               pdoExtension->CommonExtension.PartitionLength.QuadPart) {
                continue;
            }

            //
            // Yep - it matches.  Update the information in the entry
            //

            partitionEntry->PartitionNumber = pdoExtension->CommonExtension.PartitionNumber;

            if (partitionStyle == PARTITION_STYLE_MBR) {

                pdoData->Mbr.HiddenSectors = partitionEntry->Mbr.HiddenSectors;

            }

            break;
        }

        if(partitionNumber != partitionCount) {

            DebugPrint((1, "DiskUpdatePartitions: Matched %wZ to #%d, ordinal "
                           "%d\n",
                           &pdoExtension->CommonExtension.DeviceName,
                           partitionEntry->PartitionNumber,
                           partitionOrdinal));

            ASSERT(partitionEntry->PartitionLength.LowPart != 0x23456789);
            // ASSERT(pdoExtension->CommonExtension.PartitionLength.QuadPart != 0);

            pdoData->PartitionStyle = partitionStyle;
            
            //
            // we found a match - update the information in the device object
            // extension and driverdata
            //

            pdoData->PartitionOrdinal = partitionOrdinal;

            //
            // If this partition is being re-written then update the type
            // information as well
            //


            if (partitionStyle == PARTITION_STYLE_MBR) {

                if(partitionEntry->RewritePartition) {
                    pdoData->Mbr.PartitionType = partitionEntry->Mbr.PartitionType;
                }

            } else {

                DebugPrint((1, "DiskUpdatePartitions: EFI Partition %ws\n",
                          pdoData->Efi.PartitionName
                          ));
                          
                pdoData->Efi.PartitionType = partitionEntry->Gpt.PartitionType;
                pdoData->Efi.PartitionId = partitionEntry->Gpt.PartitionId;
                pdoData->Efi.Attributes = partitionEntry->Gpt.Attributes;

                RtlCopyMemory(
                    pdoData->Efi.PartitionName,
                    partitionEntry->Gpt.Name,
                    sizeof (pdoData->Efi.PartitionName)
                    );
            }

            //
            // Mark this one as found.
            //

            pdoExtension->IsMissing = FALSE;

            //
            // Pull it out of the old child list and add it into the
            // real one.
            //

            oldChildList = pdoExtension->CommonExtension.ChildList;

            pdoExtension->CommonExtension.ChildList =
                fdoExtension->CommonExtension.ChildList;

            fdoExtension->CommonExtension.ChildList = pdoExtension;

        } else {

            PDEVICE_OBJECT nextPdo;

            DebugPrint ((1, "DiskUpdatePartitions: Deleting %wZ\n",
                            &pdoExtension->CommonExtension.DeviceName));

            if (partitionStyle == PARTITION_STYLE_GPT) {

                DebugPrint ((1, "DiskUpdatePartitions: EFI Partition %ws\n",
                      pdoData->Efi.PartitionName
                      ));
            }
            //
            // no matching entry in the partition list - throw this partition
            // object away
            //

            pdoExtension->CommonExtension.PartitionLength.QuadPart = 0;

            //
            // grab a pointer to the next child before we mark this one as
            // missing since missing devices could vanish at any time.
            //

            oldChildList = pdoExtension->CommonExtension.ChildList;
            pdoExtension->CommonExtension.ChildList = (PVOID) -1;

            //
            // Now tell the class driver that this child is "missing" - this
            // will cause it to be deleted.
            //


            ClassMarkChildMissing(pdoExtension, FALSE);
        }
    }

    //
    // At this point the old child list had best be empty.
    //

    ASSERT(oldChildList == NULL);

    //
    // Iterate through the partition entries and create any partition
    // objects that don't already exist
    //

    partitionOrdinal = 0;
    newPartitionNumber = 0;

    for(partitionNumber = 0;
        partitionNumber < partitionCount;
        partitionNumber++) {

        PDEVICE_OBJECT pdo;

        partitionEntry = &(PartitionList->PartitionEntry[partitionNumber]);

        //
        // Is this partition interesting
        //

        if (partitionStyle == PARTITION_STYLE_MBR) {

            if((partitionEntry->Mbr.PartitionType == PARTITION_ENTRY_UNUSED) ||
               (IsContainerPartition(partitionEntry->Mbr.PartitionType))) {

                continue;
            }
        }

        //
        // Increment the count of interesting partitions
        //

        partitionOrdinal++;
        newPartitionNumber++;

        //
        // Has this already been matched
        //

        if(partitionEntry->PartitionNumber == 0) {

            LONG i;

            //
            // find the first safe partition number for this device
            //

            for(i = 0; i < (LONG) partitionCount; i++) {


                PPARTITION_INFORMATION_EX tmp = &(PartitionList->PartitionEntry[i]);

                if (partitionStyle == PARTITION_STYLE_MBR) {
                    if (tmp->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
                        IsContainerPartition(tmp->Mbr.PartitionType)) {
                        continue;
                    }
                } 

                if(tmp->PartitionNumber == newPartitionNumber) {

                    //
                    // Found a matching partition number - increment the count
                    // and restart the scan.
                    //

                    newPartitionNumber++;
                    i = -1;
                    continue;
                }
            }

            //
            // Assign this partition a partition number
            //

            partitionEntry->PartitionNumber = newPartitionNumber;

            DebugPrint((1, "DiskUpdatePartitions: Found new partition #%d, ord %d "
                           "starting at %#016I64x and running for %#016I64x\n",
                           partitionEntry->PartitionNumber,
                           partitionOrdinal,
                           partitionEntry->StartingOffset.QuadPart,
                           partitionEntry->PartitionLength.QuadPart));

            ClassReleaseChildLock(fdoExtension);

            status = DiskCreatePdo(Fdo,
                                   partitionOrdinal,
                                   partitionEntry,
                                   partitionStyle,
                                   &pdo);

            ClassAcquireChildLock(fdoExtension);

            if(!NT_SUCCESS(status)) {

                DebugPrint((1, "DiskUpdatePartitions: error %lx creating "
                               "new PDO for partition ordinal %d, number %d\n",
                               status,
                               partitionOrdinal,
                               partitionEntry->PartitionNumber));

                //
                // don't increment the partition number - we'll try to reuse
                // it for the next child.
                //

                partitionEntry->PartitionNumber = 0;
                newPartitionNumber--;

                continue;
            }

            //
            // mark the new device as enumerated
            //

            pdoExtension = pdo->DeviceExtension;
            pdoExtension->IsMissing = FALSE;

            //
            // This number's taken already - try to scanning the partition
            // table more than once for a new number.
            //

        }
    }

    //
    // ISSUE - 2000/02/09 - math: Review.
    // Is PartitionStyle the only field that needs updating?
    //

    {
        PCOMMON_DEVICE_EXTENSION commonExtension;
        PDISK_DATA diskData;

        commonExtension = Fdo->DeviceExtension;
        diskData = (PDISK_DATA)(commonExtension->DriverData);

        diskData->PartitionStyle = partitionStyle;
    }
        
    ClassReleaseChildLock(fdoExtension);
    return;
}


NTSTATUS
DiskCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    IN ULONG PartitionOrdinal,
    IN PPARTITION_INFORMATION_EX PartitionEntry,
    IN PARTITION_STYLE PartitionStyle,
    OUT PDEVICE_OBJECT *Pdo
    )

/*++

Routine Description:

    This routine will create and initialize a new partition device object
    (PDO) and insert it into the FDO partition list.

Arguments:

    Fdo - a pointer to the functional device object this PDO will be a child
          of

    PartitionOrdinal - the partition ordinal for this PDO

    PartitionEntry - the partition information for this device object

    PartitionStyle - what style of partition table entry PartitionEntry is;
            currently either MBR or EFI

    Pdo - a location to store the pdo pointer upon successful completion

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PDEVICE_OBJECT pdo = NULL;
    PPHYSICAL_DEVICE_EXTENSION pdoExtension = NULL;

    PUCHAR deviceName = NULL;

    PDISK_DATA diskData = fdoExtension->CommonExtension.DriverData;

    ULONG numberListElements;

    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    // Create partition object and set up partition parameters.
    //

    status = DiskGenerateDeviceName(FALSE,
                                    fdoExtension->DeviceNumber,
                                    PartitionEntry->PartitionNumber,
                                    &PartitionEntry->StartingOffset,
                                    &PartitionEntry->PartitionLength,
                                    &deviceName);

    if(!NT_SUCCESS(status)) {

        DebugPrint((1, "DiskCreatePdo - Can't generate name %lx\n", status));
        return status;
    }

    DebugPrint((2, "DiskCreatePdo: Create device object %s\n", deviceName));

    status = ClassCreateDeviceObject(Fdo->DriverObject,
                                     deviceName,
                                     Fdo,
                                     FALSE,
                                     &pdo);

    if (!NT_SUCCESS(status)) {

        DebugPrint((1, "DiskEnumerateDevice: Can't create device object for %s\n", deviceName));

        return status;
    }

    //
    // Set up device extension fields.
    //

    pdoExtension = pdo->DeviceExtension;

    //
    // Set up device object fields.
    //

    SET_FLAG(pdo->Flags, DO_DIRECT_IO);

    pdo->StackSize = (CCHAR)
        pdoExtension->CommonExtension.LowerDeviceObject->StackSize + 1;

    //
    // Get pointer to new disk data.
    //

    diskData = (PDISK_DATA) pdoExtension->CommonExtension.DriverData;

    //
    // Set the alignment requirements for the device based on the
    // host adapter requirements
    //

    if (Fdo->AlignmentRequirement > pdo->AlignmentRequirement) {
        pdo->AlignmentRequirement = Fdo->AlignmentRequirement;
    }

    if (fdoExtension->SrbFlags & SRB_FLAGS_QUEUE_ACTION_ENABLE) {
        numberListElements = 30;
    } else {
        numberListElements = 8;
    }

    //
    // Build the lookaside list for srb's for this partition based on
    // whether the adapter and disk can do tagged queueing.  Don't bother to 
    // check the status - this can't fail when called for a PDO.
    //

    ClassInitializeSrbLookasideList((PCOMMON_DEVICE_EXTENSION) pdoExtension,
                                    numberListElements);

    //
    // Set the sense-data pointer in the device extension.
    //

    diskData->PartitionOrdinal = PartitionOrdinal;
    pdoExtension->CommonExtension.PartitionNumber = PartitionEntry->PartitionNumber;

    //
    // Initialize relevant data.
    //
    
    if (PartitionStyle == PARTITION_STYLE_MBR) {
    
        diskData->Mbr.PartitionType = PartitionEntry->Mbr.PartitionType;
        diskData->Mbr.BootIndicator = PartitionEntry->Mbr.BootIndicator;
        diskData->Mbr.HiddenSectors = PartitionEntry->Mbr.HiddenSectors;

    } else {

        diskData->Efi.PartitionType = PartitionEntry->Gpt.PartitionType;
        diskData->Efi.PartitionId = PartitionEntry->Gpt.PartitionType;
        diskData->Efi.Attributes = PartitionEntry->Gpt.Attributes;
        RtlCopyMemory (diskData->Efi.PartitionName,
                       PartitionEntry->Gpt.Name,
                       sizeof (diskData->Efi.PartitionName)
                       );
    }

    DebugPrint((2, "DiskEnumerateDevice: Partition type is %x\n",
        diskData->Mbr.PartitionType));

    pdoExtension->CommonExtension.StartingOffset  =
        PartitionEntry->StartingOffset;

    pdoExtension->CommonExtension.PartitionLength =
        PartitionEntry->PartitionLength;


    DebugPrint((1, "DiskCreatePdo: hidden sectors value for pdo %#p set to %#x\n",
                pdo,
                diskData->Mbr.HiddenSectors));

    //
    // Check for removable media support.
    //

    if (fdoExtension->DeviceDescriptor->RemovableMedia) {
        SET_FLAG(pdo->Characteristics, FILE_REMOVABLE_MEDIA);
    }

    pdoExtension->CommonExtension.DeviceObject = pdo;

    CLEAR_FLAG(pdo->Flags, DO_DEVICE_INITIALIZING);

    *Pdo = pdo;

    return status;
}





VOID
DiskAcquirePartitioningLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PDISK_DATA diskData = FdoExtension->CommonExtension.DriverData;

    PAGED_CODE();

    ASSERT_FDO(FdoExtension->DeviceObject);

    KeWaitForSingleObject(&(diskData->PartitioningEvent),
                          UserRequest,
                          UserMode,
                          FALSE,
                          NULL);
    return;
}


VOID
DiskReleasePartitioningLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    )
{
    PDISK_DATA diskData = FdoExtension->CommonExtension.DriverData;

    PAGED_CODE();

    ASSERT_FDO(FdoExtension->DeviceObject);

    KeSetEvent(&(diskData->PartitioningEvent), IO_NO_INCREMENT, FALSE);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\pnp.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    pnp.c

Abstract:

    SCSI disk class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "disk.h"

extern PULONG InitSafeBootMode;

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, DiskAddDevice)
#pragma alloc_text(PAGE, DiskInitFdo)
#pragma alloc_text(PAGE, DiskInitPdo)
#pragma alloc_text(PAGE, DiskStartFdo)
#pragma alloc_text(PAGE, DiskStartPdo)
#pragma alloc_text(PAGE, DiskQueryId)
#pragma alloc_text(PAGE, DiskGenerateDeviceName)
#pragma alloc_text(PAGE, DiskCreateSymbolicLinks)
#pragma alloc_text(PAGE, DiskDeleteSymbolicLinks)
#pragma alloc_text(PAGE, DiskRemoveDevice)

#endif


NTSTATUS
DiskAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine gets a port drivers capabilities, obtains the
    inquiry data, searches the SCSI bus for the port driver and creates
    the device objects for the disks found.

Arguments:

    DriverObject - Pointer to driver object created by system.

    Pdo - Device object use to send requests to port driver.

Return Value:

    True is returned if one disk was found and successfully created.

--*/

{
    ULONG rootPartitionMountable = FALSE;

    PCONFIGURATION_INFORMATION configurationInformation;
    ULONG diskCount;

    NTSTATUS status;

    PAGED_CODE();

    //
    // See if we should be allowing file systems to mount on partition zero.
    //

    TRY {
        HANDLE deviceKey;

        UNICODE_STRING diskKeyName;
        OBJECT_ATTRIBUTES objectAttributes;
        HANDLE diskKey;

        RTL_QUERY_REGISTRY_TABLE queryTable[2];

        status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                         PLUGPLAY_REGKEY_DEVICE,
                                         KEY_READ,
                                         &deviceKey);

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskAddDevice: Error %#08lx opening device key "
                           "for pdo %#08lx\n",
                        status, PhysicalDeviceObject));
            LEAVE;
        }

        RtlInitUnicodeString(&diskKeyName, L"Disk");
        InitializeObjectAttributes(&objectAttributes,
                                   &diskKeyName,
                                   OBJ_CASE_INSENSITIVE,
                                   deviceKey,
                                   NULL);

        status = ZwOpenKey(&diskKey, KEY_READ, &objectAttributes);
        ZwClose(deviceKey);

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskAddDevice: Error %#08lx opening disk key "
                           "for pdo %#08lx device key %#x\n",
                        status, PhysicalDeviceObject, deviceKey));
            LEAVE;
        }

        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        queryTable[0].Name = L"RootPartitionMountable";
        queryTable[0].EntryContext = &(rootPartitionMountable);

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        diskKey,
                                        queryTable,
                                        NULL,
                                        NULL);

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskAddDevice: Error %#08lx reading value from "
                           "disk key %#x for pdo %#08lx\n",
                        status, diskKey, PhysicalDeviceObject));
        }

        ZwClose(diskKey);

    } FINALLY {

        //
        // Do nothing.
        //

        if(!NT_SUCCESS(status)) {
            DebugPrint((1, "DiskAddDevice: Will %sallow file system to mount on "
                           "partition zero of disk %#08lx\n",
                        (rootPartitionMountable ? "" : "not "),
                        PhysicalDeviceObject));
        }
    }

    //
    // Create device objects for disk
    //

    diskCount = 0;

    status = DiskCreateFdo(
                 DriverObject,
                 PhysicalDeviceObject,
                 &diskCount,
                 (BOOLEAN) !rootPartitionMountable
                 );

    //
    // Get the number of disks already initialized.
    //

    configurationInformation = IoGetConfigurationInformation();

    if (NT_SUCCESS(status)) {

        //
        // Increment system disk device count.
        //

        configurationInformation->DiskCount++;

    }

    return status;

} // end DiskAddDevice()



NTSTATUS
DiskInitFdo(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine is called to do one-time initialization of new device objects


Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PDISK_DATA diskData = (PDISK_DATA) fdoExtension->CommonExtension.DriverData;

    ULONG srbFlags = 0;

    ULONG timeOut = 0;

    ULONG bytesPerSector;
    UCHAR sectorShift;

    BOOLEAN dmActive = FALSE;
    PULONG dmSkew;
    ULONG dmByteSkew;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Build the lookaside list for srb's for the physical disk. Should only
    // need a couple.  If this fails then we don't have an emergency SRB so
    // fail the call to initialize.
    //

    ClassInitializeSrbLookasideList((PCOMMON_DEVICE_EXTENSION) fdoExtension,
                                    PARTITION0_LIST_SIZE);

    //
    // Because all requests share a common sense buffer, it is possible
    // for the buffer to be overwritten if the port driver completes
    // multiple failed requests that require a request sense before the
    // class driver's completion routine can consume the data in the buffer.
    // To prevent this, we allow the port driver to allocate a unique sense
    // buffer each time it needs one.  We are responsible for freeing this
    // buffer.  This also allows the adapter to be configured to support
    // additional sense data beyond the minimum 18 bytes.
    //

    fdoExtension->SrbFlags = SRB_FLAGS_PORT_DRIVER_ALLOCSENSE;

    //
    // Initialize the srb flags.
    //

    if (fdoExtension->DeviceDescriptor->CommandQueueing &&
        fdoExtension->AdapterDescriptor->CommandQueueing) {

        fdoExtension->SrbFlags = SRB_FLAGS_QUEUE_ACTION_ENABLE;

    }

    if (!TEST_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA)) {
        SET_FLAG(fdoExtension->DeviceFlags, DEV_SAFE_START_UNIT);
    }

    //
    // Look for controllers that require special flags.
    //

    ClassScanForSpecial(fdoExtension, DiskBadControllers, DiskSetSpecialHacks);

    //
    // Look into the registry to see if this device
    // requires special attention - [ like a hack ]
    //

    DiskScanRegistryForSpecial(fdoExtension);

    srbFlags = fdoExtension->SrbFlags;

    //
    // Clear buffer for drive geometry.
    //

    RtlZeroMemory(&(fdoExtension->DiskGeometry),
                  sizeof(DISK_GEOMETRY));

    //
    // Allocate request sense buffer.
    //

    fdoExtension->SenseData = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                                    SENSE_BUFFER_SIZE,
                                                    DISK_TAG_START);

    if (fdoExtension->SenseData == NULL) {

        //
        // The buffer can not be allocated.
        //

        DebugPrint((1, "DiskInitFdo: Can not allocate request sense buffer\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
        return status;
    }

    //
    // Physical device object will describe the entire
    // device, starting at byte offset 0.
    //

    fdoExtension->CommonExtension.StartingOffset.QuadPart = (LONGLONG)(0);

    //
    // Set timeout value in seconds.
    //

    timeOut = ClassQueryTimeOutRegistryValue(Fdo);
    if (timeOut) {
        fdoExtension->TimeOutValue = timeOut;
    } else {
        fdoExtension->TimeOutValue = SCSI_DISK_TIMEOUT;
    }

    //
    // If this is a removable drive, build an entry in devicemap\scsi
    // indicating it's physicaldriveN name, set up the appropriate
    // update partitions routine and set the flags correctly.
    // note: only do this after the timeout value is set, above.
    //

    if (fdoExtension->DeviceDescriptor->RemovableMedia) {
        ClassUpdateInformationInRegistry( Fdo,
                                          "PhysicalDrive",
                                          fdoExtension->DeviceNumber,
                                          NULL,
                                          0);
        //
        // Enable media change notification for removable disks
        //
        ClassInitializeMediaChangeDetection(fdoExtension,
                                            "Disk");

        SET_FLAG(Fdo->Characteristics, FILE_REMOVABLE_MEDIA);
        diskData->UpdatePartitionRoutine = DiskUpdateRemovablePartitions;

    } else {

        SET_FLAG(fdoExtension->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE);
        diskData->UpdatePartitionRoutine = DiskUpdatePartitions;

    }

    //
    // Read the drive capacity.  Don't use the disk version of the routine here
    // since we don't know the disk signature yet - the disk version will
    // attempt to determine the BIOS reported geometry.
    //

    status = ClassReadDriveCapacity(Fdo);

    //
    // If the read capcity failed then just return, unless this is a
    // removable disk where a device object partition needs to be created.
    //

    if (!NT_SUCCESS(status) &&
        !(Fdo->Characteristics & FILE_REMOVABLE_MEDIA)) {

        DebugPrint((1,
            "DiskInitFdo: Can't read capacity for device %p\n",
            Fdo));

        if (fdoExtension->DeviceDescriptor->RemovableMedia) {
            fdoExtension->DiskGeometry.MediaType = RemovableMedia;
            Fdo->Flags &= ~DO_VERIFY_VOLUME;
        } else {
            fdoExtension->DiskGeometry.MediaType = FixedMedia;
        }

        status = STATUS_SUCCESS;
    }

    //
    // Set up sector size fields.
    //
    // Stack variables will be used to update
    // the partition device extensions.
    //
    // The device extension field SectorShift is
    // used to calculate sectors in I/O transfers.
    //
    // The DiskGeometry structure is used to service
    // IOCTls used by the format utility.
    //

    bytesPerSector = fdoExtension->DiskGeometry.BytesPerSector;

    //
    // Make sure sector size is not zero.
    //

    if (bytesPerSector == 0) {

        //
        // Default sector size for disk is 512.
        //

        bytesPerSector = fdoExtension->DiskGeometry.BytesPerSector = 512;
    }

    sectorShift = fdoExtension->SectorShift;

    //
    // Determine is DM Driver is loaded on an IDE drive that is
    // under control of Atapi - this could be either a crashdump or
    // an Atapi device is sharing the controller with an IDE disk.
    //

    HalExamineMBR(fdoExtension->CommonExtension.DeviceObject,
                  fdoExtension->DiskGeometry.BytesPerSector,
                  (ULONG)0x54,
                  &dmSkew);

    if (dmSkew) {

        //
        // Update the device extension, so that the call to IoReadPartitionTable
        // will get the correct information. Any I/O to this disk will have
        // to be skewed by *dmSkew sectors aka DMByteSkew.
        //

        fdoExtension->DMSkew = *dmSkew;
        fdoExtension->DMActive = TRUE;
        fdoExtension->DMByteSkew = fdoExtension->DMSkew * bytesPerSector;

        //
        // Save away the infomation that we need, since this deviceExtension will soon be
        // blown away.
        //

        dmActive = TRUE;
        dmByteSkew = fdoExtension->DMByteSkew;

    }

#if defined(_X86_)
    //
    // Try to read the signature off the disk and determine the correct drive
    // geometry based on that.  This requires rereading the disk size to get
    // the cylinder count updated correctly.
    //

    if(fdoExtension->DeviceDescriptor->RemovableMedia == FALSE) {
        DiskReadSignature(Fdo);
        DiskReadDriveCapacity(Fdo);
    }
#endif

    //
    // Register interfaces for this device
    //
    {
        UNICODE_STRING interfaceName;

        RtlInitUnicodeString(&interfaceName, NULL);

        status = IoRegisterDeviceInterface(fdoExtension->LowerPdo,
                                           (LPGUID) &DiskClassGuid,
                                           NULL,
                                           &interfaceName);

        if(NT_SUCCESS(status)) {

            diskData->DiskInterfaceString = interfaceName;
            status = IoSetDeviceInterfaceState(&interfaceName, TRUE);

        } else {
            interfaceName.Buffer = NULL;
        }

        if(!NT_SUCCESS(status)) {

            DebugPrint((1, "DiskInitFdo: Unable to register or set disk DCA "
                           "for fdo %p [%lx]\n", Fdo, status));

            RtlFreeUnicodeString(&interfaceName);
            RtlInitUnicodeString(&(diskData->DiskInterfaceString), NULL);
        }
    }

    DiskCreateSymbolicLinks(Fdo);

    //
    // Determine the type of disk and enable failure preiction in the hardware
    // and enable failure prediction polling.
    //

    if (*InitSafeBootMode == 0)
    {
        DiskDetectFailurePrediction(fdoExtension,
                                  &diskData->FailurePredictionCapability);

        if (diskData->FailurePredictionCapability != FailurePredictionNone)
        {
            //
            // Cool, we've got some sort of failure prediction, enable it
            // at the hardware and then enable polling for it
            //

            //
            // By default we allow performance to be degradeded if failure
            // prediction is enabled.
            //
            // TODO: Make a registry entry ?
            //

            diskData->AllowFPPerfHit = TRUE;

            //
            // Enable polling only after Atapi and SBP2 add support for the new
            // SRB flag that indicates that the request should not reset the
            // drive spin down idle timer.
            //

            status = DiskEnableDisableFailurePredictPolling(fdoExtension,
                                          TRUE,
                                          DISK_DEFAULT_FAILURE_POLLING_PERIOD);

            DebugPrint((3, "DiskInitFdo: Failure Prediction Poll enabled as "
                           "%d for device %p\n",
                     diskData->FailurePredictionCapability,
                     Fdo));
        }
    } else {

        //
        // In safe boot mode we do not enable failure prediction, as perhaps
        // it is the reason why normal boot does not work
        //

        diskData->FailurePredictionCapability = FailurePredictionNone;

    }

    //
    // Initialize the verify mutex
    //

    KeInitializeMutex(&diskData->VerifyMutex, MAX_SECTORS_PER_VERIFY);

    return(STATUS_SUCCESS);

} // end DiskInitFdo()


NTSTATUS
DiskInitPdo(
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine will create the well known names for a PDO and register
    it's device interfaces.

--*/

{
    PCOMMON_DEVICE_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PDISK_DATA diskData = pdoExtension->DriverData;

    UNICODE_STRING interfaceName;

    NTSTATUS status;

    PAGED_CODE();

    DiskCreateSymbolicLinks(Pdo);

    //
    // Register interfaces for this device
    //

    RtlInitUnicodeString(&interfaceName, NULL);

    status = IoRegisterDeviceInterface(Pdo,
                                       (LPGUID) &PartitionClassGuid,
                                       NULL,
                                       &interfaceName);

    if(NT_SUCCESS(status)) {

        diskData->PartitionInterfaceString = interfaceName;
        status = IoSetDeviceInterfaceState(&interfaceName, TRUE);

    } else {
        interfaceName.Buffer = NULL;
    }

    if(!NT_SUCCESS(status)) {
        DebugPrint((1, "DiskInitPdo: Unable to register partition DCA for "
                    "pdo %p [%lx]\n", Pdo, status));

        RtlFreeUnicodeString(&interfaceName);
        RtlInitUnicodeString(&(diskData->PartitionInterfaceString), NULL);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DiskStartPdo(
    IN PDEVICE_OBJECT Pdo
    )

/*++

Routine Description:

    This routine will create the well known names for a PDO and register
    it's device interfaces.

--*/

{
    PAGED_CODE();

    return STATUS_SUCCESS;
}

NTSTATUS
DiskStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

{
    PFUNCTIONAL_DEVICE_EXTENSION fdo = DeviceObject->DeviceExtension;

    if(fdo->CommonExtension.IsFdo) {
        DiskAcquirePartitioningLock(fdo);
        DiskInvalidatePartitionTable(fdo, TRUE);
        DiskReleasePartitioningLock(fdo);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DiskQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING UnicodeIdString
    )

/*++

Routine Description:

    This routine generates the PNP id's for the disk's "children".  If the
    specified ID isn't one that the routine can generate it must return
    STATUS_NOT_IMPLEMENTED so classpnp will know not to do anything with the
    PNP request's status.

    This routine allocates the buffer for the UnicodeIdString.  It is the
    caller's responsibility to free the buffer when it's done.

Arguments:

    Pdo - a pointer to the PDO we are to generate an ID for

    IdType - the type of ID to be generated

    UnicodeIdString - a string to put the results into.

Return Value:

    STATUS_SUCCCESS if successful

    STATUS_NOT_IMPLEMENTED if the IdType is not one supported by this routine

    error status otherwise.

--*/

{
    ANSI_STRING ansiIdString;

    NTSTATUS status;

    PAGED_CODE();
    ASSERT_PDO(Pdo);

    if(IdType == BusQueryDeviceID) {

        if((Pdo->Characteristics & FILE_REMOVABLE_MEDIA) == 0) {
            RtlInitAnsiString(&ansiIdString, "STORAGE\\Partition");
            return RtlAnsiStringToUnicodeString(UnicodeIdString, &ansiIdString, TRUE);
        }

        RtlInitAnsiString(&ansiIdString,
                          "STORAGE\\RemovableMedia");

        return RtlAnsiStringToUnicodeString(UnicodeIdString, &ansiIdString, TRUE);
    }

    if(IdType == BusQueryInstanceID) {

        PPHYSICAL_DEVICE_EXTENSION pdoExtension = Pdo->DeviceExtension;
        PCOMMON_DEVICE_EXTENSION commonExtension = Pdo->DeviceExtension;
        PDISK_DATA diskData = commonExtension->PartitionZeroExtension->CommonExtension.DriverData;

        UCHAR string[64];

        if((Pdo->Characteristics & FILE_REMOVABLE_MEDIA) == 0) {

            if (diskData->PartitionStyle == PARTITION_STYLE_MBR) {
                sprintf(string, "S%08lx_O%I64lx_L%I64lx",
                        diskData->Mbr.Signature,
                        commonExtension->StartingOffset,
                        commonExtension->PartitionLength);
            } else {
                sprintf(string,
                        "S%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02xS_O%I64lx_L%I64lx",
                        diskData->Efi.DiskId.Data1,
                        diskData->Efi.DiskId.Data2,
                        diskData->Efi.DiskId.Data3,
                        diskData->Efi.DiskId.Data4[0],
                        diskData->Efi.DiskId.Data4[1],
                        diskData->Efi.DiskId.Data4[2],
                        diskData->Efi.DiskId.Data4[3],
                        diskData->Efi.DiskId.Data4[4],
                        diskData->Efi.DiskId.Data4[5],
                        diskData->Efi.DiskId.Data4[6],
                        diskData->Efi.DiskId.Data4[7],
                        commonExtension->StartingOffset,
                        commonExtension->PartitionLength);
            }
        } else {
            sprintf(string, "RM");
        }

        RtlInitAnsiString(&ansiIdString, string);

        return RtlAnsiStringToUnicodeString(UnicodeIdString, &ansiIdString, TRUE);
    }

    if((IdType == BusQueryHardwareIDs) || (IdType == BusQueryCompatibleIDs)) {

        RtlInitAnsiString(&ansiIdString, "STORAGE\\Volume");

        UnicodeIdString->MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(&ansiIdString) + sizeof(UNICODE_NULL);

        UnicodeIdString->Buffer = ExAllocatePoolWithTag(PagedPool,
                                                        UnicodeIdString->MaximumLength,
                                                        DISK_TAG_PNP_ID);

        if(UnicodeIdString->Buffer == NULL) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(UnicodeIdString->Buffer, UnicodeIdString->MaximumLength);

        return RtlAnsiStringToUnicodeString(UnicodeIdString,
                                            &ansiIdString,
                                            FALSE);
    }

    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
DiskGenerateDeviceName(
    IN BOOLEAN IsFdo,
    IN ULONG DeviceNumber,
    IN OPTIONAL ULONG PartitionNumber,
    IN OPTIONAL PLARGE_INTEGER StartingOffset,
    IN OPTIONAL PLARGE_INTEGER PartitionLength,
    OUT PUCHAR *RawName
    )

/*++

Routine Description:

    This routine will allocate a unicode string buffer and then fill it in
    with a generated name for the specified device object.

    It is the responsibility of the user to allocate a UNICODE_STRING structure
    to pass in and to free UnicodeName->Buffer when done with it.

Arguments:

    DeviceObject - a pointer to the device object

    UnicodeName - a unicode string to put the name buffer into

Return Value:

    status

--*/

//#define PDO_NAME_FORMAT "\\Device\\Harddisk%d\\DP(%d)%d"
#define PDO_NAME_FORMAT "\\Device\\Harddisk%d\\DP(%d)%#I64x-%#I64x+%lx"
#define FDO_NAME_FORMAT "\\Device\\Harddisk%d\\DR%d"

//#define PDO_NAME_FORMAT (PDO_BASE_NAME "+%#I64x+%#I64x+%#lx")

{
    UCHAR rawName[64];
    static ULONG diskDeviceSequenceNumber = 0;

    PAGED_CODE();

    if(!IsFdo) {

        ASSERT(ARGUMENT_PRESENT((PVOID)(ULONG_PTR) PartitionNumber));
        ASSERT(ARGUMENT_PRESENT(PartitionLength));
        ASSERT(ARGUMENT_PRESENT(StartingOffset));

        sprintf(rawName, PDO_NAME_FORMAT, DeviceNumber, PartitionNumber,
                                          StartingOffset->QuadPart,
                                          PartitionLength->QuadPart,
                                          diskDeviceSequenceNumber++);
    } else {

        ASSERT(!ARGUMENT_PRESENT((PVOID)(ULONG_PTR) PartitionNumber));
        ASSERT(!ARGUMENT_PRESENT(PartitionLength));
        ASSERT(!ARGUMENT_PRESENT(StartingOffset));

        sprintf(rawName, FDO_NAME_FORMAT, DeviceNumber,
                                          diskDeviceSequenceNumber++);

    }

    *RawName = ExAllocatePoolWithTag(PagedPool,
                                     strlen(rawName) + 1,
                                     DISK_TAG_NAME);

    if(*RawName == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    strcpy(*RawName, rawName);

    DebugPrint((2, "DiskGenerateDeviceName: generated \"%s\"\n", rawName));

    return STATUS_SUCCESS;
}


VOID
DiskCreateSymbolicLinks(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine will generate a symbolic link for the specified device object
    using the well known form \\Device\HarddiskX\PartitionY, where X and Y are
    filled in using the partition information in the device object's extension.

    This routine will not try to delete any previous symbolic link for the
    same generated name - the caller must make sure the symbolic link has
    been broken before calling this routine.

Arguments:

    DeviceObject - the device object to make a well known name for

Return Value:

    STATUS

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;

    PDISK_DATA diskData = commonExtension->DriverData;

    WCHAR wideSourceName[64];
    UNICODE_STRING unicodeSourceName;

    NTSTATUS status;

    PAGED_CODE();

    //
    // Build the destination for the link first using the device name
    // stored in the device object
    //

    ASSERT(commonExtension->DeviceName.Buffer);

    if(!diskData->LinkStatus.WellKnownNameCreated) {
        //
        // Put together the source name using the partition and device number
        // in the device extension and disk data segment
        //

        swprintf(wideSourceName, L"\\Device\\Harddisk%d\\Partition%d",
                 commonExtension->PartitionZeroExtension->DeviceNumber,
                 (commonExtension->IsFdo ?
                    0 :
                    commonExtension->PartitionNumber));

        RtlInitUnicodeString(&unicodeSourceName, wideSourceName);

        DebugPrint((1, "DiskCreateSymbolicLink: Linking %wZ to %wZ\n",
                   &unicodeSourceName,
                   &commonExtension->DeviceName));

        status = IoCreateSymbolicLink(&unicodeSourceName,
                                      &commonExtension->DeviceName);

    #if DBG

        if((status == STATUS_OBJECT_NAME_EXISTS) ||
           (status == STATUS_OBJECT_NAME_COLLISION)) {

            DebugPrint((1, "DiskCreateSymbolicLink: name %wZ already exists\n",
                        &unicodeSourceName));
        }
    #endif

        if(NT_SUCCESS(status)){
            diskData->LinkStatus.WellKnownNameCreated = TRUE;
        }
    }

    if((!diskData->LinkStatus.PhysicalDriveLinkCreated) &&
       (commonExtension->IsFdo)) {

        //
        // Create a physical drive N link using the device number we saved
        // away during AddDevice.
        //

        swprintf(wideSourceName,
                 L"\\DosDevices\\PhysicalDrive%d",
                 commonExtension->PartitionZeroExtension->DeviceNumber);

        RtlInitUnicodeString(&unicodeSourceName, wideSourceName);

        DebugPrint((1, "DiskCreateSymbolicLink: Linking %wZ to %wZ\n",
                    &unicodeSourceName,
                    &(commonExtension->DeviceName)));

        status = IoCreateSymbolicLink(&unicodeSourceName,
                                      &(commonExtension->DeviceName));

#if DBG

        if((status == STATUS_OBJECT_NAME_EXISTS) ||
           (status == STATUS_OBJECT_NAME_COLLISION)) {

            DebugPrint((1, "DiskCreateSymbolicLink: name %wZ already exists\n",
                        &unicodeSourceName));
        }
#endif

        if(NT_SUCCESS(status)) {
            diskData->LinkStatus.PhysicalDriveLinkCreated = TRUE;
        }
    } else if(commonExtension->IsFdo == FALSE) {
        diskData->LinkStatus.PhysicalDriveLinkCreated = FALSE;
    }

    return;
}


VOID
DiskDeleteSymbolicLinks(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine will delete the well known name (symlink) for the specified
    device.  It generates the link name using information stored in the
    device extension

Arguments:

    DeviceObject - the device object we are unlinking

Return Value:

    status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = commonExtension->DriverData;

    WCHAR wideLinkName[64];
    UNICODE_STRING unicodeLinkName;

    PAGED_CODE();

    if(diskData->LinkStatus.WellKnownNameCreated) {

        swprintf(wideLinkName,
                 L"\\Device\\Harddisk%d\\Partition%d",
                 commonExtension->PartitionZeroExtension->DeviceNumber,
                 (commonExtension->IsFdo ? 0 :
                                           commonExtension->PartitionNumber));

        RtlInitUnicodeString(&unicodeLinkName, wideLinkName);

        IoDeleteSymbolicLink(&unicodeLinkName);

        diskData->LinkStatus.WellKnownNameCreated = FALSE;
    }

    if(diskData->LinkStatus.PhysicalDriveLinkCreated) {

        ASSERT_FDO(DeviceObject);

        swprintf(wideLinkName,
                 L"\\DosDevices\\PhysicalDrive%d",
                 commonExtension->PartitionZeroExtension->DeviceNumber);

        RtlInitUnicodeString(&unicodeLinkName, wideLinkName);

        IoDeleteSymbolicLink(&unicodeLinkName);

        diskData->LinkStatus.PhysicalDriveLinkCreated = FALSE;
    }

    return;
}


NTSTATUS
DiskRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    )

/*++

Routine Description:

    This routine will release any resources the device may have allocated for
    this device object and return.

Arguments:

    DeviceObject - the device object being removed

Return Value:

    status

--*/

{
    PCOMMON_DEVICE_EXTENSION commonExtension = DeviceObject->DeviceExtension;
    PDISK_DATA diskData = commonExtension->DriverData;

    PAGED_CODE();

    //
    // Handle query and cancel
    //

    if((Type == IRP_MN_QUERY_REMOVE_DEVICE) ||
       (Type == IRP_MN_CANCEL_REMOVE_DEVICE))  {
        return STATUS_SUCCESS;
    }

    if(commonExtension->IsFdo) {

        PFUNCTIONAL_DEVICE_EXTENSION fdoExtension =
            DeviceObject->DeviceExtension;

        //
        // Purge the cached partition table (if any).
        //

        DiskAcquirePartitioningLock(fdoExtension);
        DiskInvalidatePartitionTable(fdoExtension, TRUE);
        DiskReleasePartitioningLock(fdoExtension);

        //
        // Delete our object directory.
        //

        if(fdoExtension->AdapterDescriptor) {
            ExFreePool(fdoExtension->AdapterDescriptor);
            fdoExtension->AdapterDescriptor = NULL;
        }

        if(fdoExtension->DeviceDescriptor) {
            ExFreePool(fdoExtension->DeviceDescriptor);
            fdoExtension->DeviceDescriptor = NULL;
        }

        if(fdoExtension->SenseData) {
            ExFreePool(fdoExtension->SenseData);
            fdoExtension->SenseData = NULL;
        }

        if(fdoExtension->DeviceDirectory != NULL) {
            ZwMakeTemporaryObject(fdoExtension->DeviceDirectory);
            ZwClose(fdoExtension->DeviceDirectory);
            fdoExtension->DeviceDirectory = NULL;
        }

        if(Type == IRP_MN_REMOVE_DEVICE) {
            IoGetConfigurationInformation()->DiskCount--;
        }

    } else {

        PPHYSICAL_DEVICE_EXTENSION pdoExtension = DeviceObject->DeviceExtension;

    }

    DiskDeleteSymbolicLinks(DeviceObject);

    //
    // Release the mounted device interface if we've set it.
    //

    if(diskData->PartitionInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(&(diskData->PartitionInterfaceString), FALSE);
        RtlFreeUnicodeString(&(diskData->PartitionInterfaceString));
        RtlInitUnicodeString(&(diskData->PartitionInterfaceString), NULL);
    }
    if(diskData->DiskInterfaceString.Buffer != NULL) {
        IoSetDeviceInterfaceState(&(diskData->DiskInterfaceString), FALSE);
        RtlFreeUnicodeString(&(diskData->DiskInterfaceString));
        RtlInitUnicodeString(&(diskData->DiskInterfaceString), NULL);
    }

    ClassDeleteSrbLookasideList(commonExtension);
    return STATUS_SUCCESS;
}


NTSTATUS
DiskStartFdo(
    IN PDEVICE_OBJECT Fdo
    )

/*++

Routine Description:

    This routine will query the underlying device for any information necessary
    to complete initialization of the device.  This will include physical
    disk geometry, mode sense information and such.

    This routine does not perform partition enumeration - that is left to the
    re-enumeration routine

    If this routine fails it will return an error value.  It does not clean up
    any resources - that is left for the Stop/Remove routine.

Arguments:

    Fdo - a pointer to the functional device object for this device

Return Value:

    status

--*/

{
    PFUNCTIONAL_DEVICE_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PCOMMON_DEVICE_EXTENSION commonExtension = &(fdoExtension->CommonExtension);
    PDISK_DATA diskData = commonExtension->DriverData;
    STORAGE_HOTPLUG_INFO hotplugInfo;
    ULONG writeCacheOverride = DiskWriteCacheDefault;
    DISK_CACHE_INFORMATION cacheInfo;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Get the hotplug information, so we can turn off write cache if needed
    //
    // NOTE: Capabilities info is not good enough to determine hotplugedness
    //       as  we cannot determine device relations  information and other
    //       dependencies. Get the hotplug info instead
    //

    {
        PIRP irp;
        KEVENT event;
        IO_STATUS_BLOCK statusBlock;

        KeInitializeEvent(&event, SynchronizationEvent, FALSE);
        RtlZeroMemory(&hotplugInfo, sizeof(STORAGE_HOTPLUG_INFO));

        irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_GET_HOTPLUG_INFO,
                                            Fdo,
                                            NULL,
                                            0L,
                                            &hotplugInfo,
                                            sizeof(STORAGE_HOTPLUG_INFO),
                                            FALSE,
                                            &event,
                                            &statusBlock);

        if (irp != NULL) {

            // send to self -- classpnp handles this
            status = IoCallDriver(Fdo, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                status = statusBlock.Status;
            }
        }
    }

    //
    // Clear the DEV_WRITE_CACHE flag now  and set
    // it below only if we read that from the disk
    //

    CLEAR_FLAG(fdoExtension->DeviceFlags, DEV_WRITE_CACHE);

    if (TEST_FLAG(fdoExtension->ScanForSpecialFlags, CLASS_SPECIAL_DISABLE_WRITE_CACHE))
    {
        //
        // This flag overrides the user's  setting, because  faulty firmware
        // may cause the filesystem to refuse to format media on this device
        //
        DebugPrint((1,
                    "DiskStartFdo: Shutting off write cache for %p due to %s\n",
                    Fdo,
                    "Possible Firmware Issue"));

        writeCacheOverride = DiskWriteCacheDisable;
    }
    else
    {
        //
        // Look into the registry to  see if the user
        // has chosen to override the default setting
        //
        ClassGetDeviceParameter(fdoExtension,
                                DiskDeviceParameterSubkey,
                                DiskDeviceUserWriteCacheSetting,
                                &writeCacheOverride);

        if (writeCacheOverride == DiskWriteCacheDefault)
        {
            //
            // The user has not overridden the default settings
            //
            if (hotplugInfo.DeviceHotplug && !hotplugInfo.WriteCacheEnableOverride)
            {
                DebugPrint((1,
                            "DiskStartFdo: Shutting off write cache for %p due to %s\n",
                            Fdo,
                            "Hotplug Device"));

                writeCacheOverride = DiskWriteCacheDisable;
            }
            else if (hotplugInfo.MediaHotplug)
            {
                DebugPrint((1,
                            "DiskStartFdo: Shutting off write cache for %p due to %s\n",
                            Fdo,
                            "Hotplug (unlockable) Media"));

                writeCacheOverride = DiskWriteCacheDisable;
            }
            else
            {
                //
                // We enable write cache if this device has no specific issues
                //
                writeCacheOverride = DiskWriteCacheEnable;
            }
        }
    }

    //
    // Query the disk to see if write cache is enabled
    // and  set the DEV_WRITE_CACHE flag appropriately
    //

    RtlZeroMemory(&cacheInfo, sizeof(DISK_CACHE_INFORMATION));

    status = DiskGetCacheInformation(fdoExtension, &cacheInfo);

    if (NT_SUCCESS(status))
    {
        if (cacheInfo.WriteCacheEnabled == TRUE)
        {
            SET_FLAG(fdoExtension->DeviceFlags, DEV_WRITE_CACHE);

            if (writeCacheOverride == DiskWriteCacheDisable)
            {
                //
                // Write cache is currently enabled on this
                // device, but we would like to turn it off
                //
                cacheInfo.WriteCacheEnabled = FALSE;

                status = DiskSetCacheInformation(fdoExtension, &cacheInfo);
            }
        }
        else
        {
            if (writeCacheOverride == DiskWriteCacheEnable)
            {
                //
                // Write cache is currently disabled on this
                // device, but we  would  like to turn it on
                //
                cacheInfo.WriteCacheEnabled = TRUE;

                status = DiskSetCacheInformation(fdoExtension, &cacheInfo);
            }
        }
    }

    //
    // In the event that there's a cached partition table flush it now.
    //

    DiskAcquirePartitioningLock(fdoExtension);
    DiskInvalidatePartitionTable(fdoExtension, TRUE);
    DiskReleasePartitioningLock(fdoExtension);

    //
    // Get the SCSI address if it's available for use with SMART ioctls.
    //

    {
        PIRP irp;
        KEVENT event;
        IO_STATUS_BLOCK statusBlock;

        KeInitializeEvent(&event, SynchronizationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_GET_ADDRESS,
                                            commonExtension->LowerDeviceObject,
                                            NULL,
                                            0L,
                                            &(diskData->ScsiAddress),
                                            sizeof(SCSI_ADDRESS),
                                            FALSE,
                                            &event,
                                            &statusBlock);

        if(irp != NULL) {


            status = IoCallDriver(commonExtension->LowerDeviceObject, irp);

            if(status == STATUS_PENDING) {
                KeWaitForSingleObject(&event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);
                status = statusBlock.Status;
            }
        }
    }

    return STATUS_SUCCESS;

} // end DiskStartFdo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\disk\disk.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    disk.c

Abstract:

    SCSI disk class driver

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ntddk.h"
#include "scsi.h"
#include <wmidata.h>
#include "classpnp.h"
#if defined(JAPAN) && defined(_X86_)
#include "machine.h"
#endif

#include <wmistr.h>

#if defined(_X86_)
#include "mountdev.h"
#endif

#ifdef ExAllocatePool
#undef ExAllocatePool
#define ExAllocatePool #assert(FALSE)
#endif

#define DISK_TAG_GENERAL        ' DcS'  // "ScD " - generic tag
#define DISK_TAG_SMART          'aDcS'  // "ScDa" - SMART allocations
#define DISK_TAG_INFO_EXCEPTION 'ADcS'  // "ScDA" - Info Exceptions
#define DISK_TAG_DISABLE_CACHE  'CDcS'  // "ScDC" - disable cache paths
#define DISK_TAG_CCONTEXT       'cDcS'  // "ScDc" - disk allocated completion context
#define DISK_TAG_DISK_GEOM      'GDcS'  // "ScDG" - disk geometry buffer
#define DISK_TAG_UPDATE_GEOM    'gDcS'  // "ScDg" - update disk geometry paths
#define DISK_TAG_SENSE_INFO     'IDcS'  // "ScDI" - sense info buffers
#define DISK_TAG_PNP_ID         'iDcS'  // "ScDp" - pnp ids
#define DISK_TAG_MODE_DATA      'MDcS'  // "ScDM" - mode data buffer
#define DISK_CACHE_MBR_CHECK    'mDcS'  // "ScDM" - mbr checksum code
#define DISK_TAG_NAME           'NDcS'  // "ScDN" - disk name code
#define DISK_TAG_READ_CAP       'PDcS'  // "ScDP" - read capacity buffer
#define DISK_TAG_PART_LIST      'pDcS'  // "ScDp" - disk partition lists
#define DISK_TAG_SRB            'SDcS'  // "ScDS" - srb allocation
#define DISK_TAG_START          'sDcS'  // "ScDs" - start device paths
#define DISK_TAG_UPDATE_CAP     'UDcS'  // "ScDU" - update capacity path
#define DISK_TAG_WI_CONTEXT     'WDcS'  // "ScDW" - work-item context

typedef
VOID
(*PDISK_UPDATE_PARTITIONS) (
    IN PDEVICE_OBJECT Fdo,
    IN OUT PDRIVE_LAYOUT_INFORMATION_EX PartitionList
    );

#if defined(_X86_)

//
// Disk device data
//

typedef enum _DISK_GEOMETRY_SOURCE {
    DiskGeometryUnknown,
    DiskGeometryFromBios,
    DiskGeometryFromPort,
    DiskGeometryFromNec98,
    DiskGeometryGuessedFromBios,
    DiskGeometryFromDefault
} DISK_GEOMETRY_SOURCE, *PDISK_GEOMETRY_SOURCE;
#endif

//

typedef struct _DISK_DATA {

    //
    // This field is the ordinal of a partition as it appears on a disk.
    //

    ULONG PartitionOrdinal;

    //
    // How has this disk been partitioned? Either EFI or MBR.
    //

    PARTITION_STYLE PartitionStyle;

    union {

        struct {

            //
            // Disk signature (from MBR)
            //

            ULONG Signature;

            //
            // MBR checksum
            //

            ULONG MbrCheckSum;

            //
            // Number of hidden sectors for BPB.
            //

            ULONG HiddenSectors;

            //
            // Partition type of this device object
            //
            // This field is set by:
            //
            //     1. Initially set according to the partition list entry
            //        partition type returned by IoReadPartitionTable.
            //
            //     2. Subsequently set by the
            //        IOCTL_DISK_SET_PARTITION_INFORMATION I/O control
            //        function when IoSetPartitionInformation function
            //        successfully updates the partition type on the disk.
            //

            UCHAR PartitionType;

            //
            // Boot indicator - indicates whether this partition is a
            // bootable (active) partition for this device
            //
            // This field is set according to the partition list entry boot
            // indicator returned by IoReadPartitionTable.
            //

            BOOLEAN BootIndicator;

        } Mbr;

        struct {

            //
            // The DiskGUID field from the EFI partition header.
            //

            GUID DiskId;

            //
            // Partition type of this device object.
            //

            GUID PartitionType;

            //
            // Unique partition identifier for this partition.
            //

            GUID PartitionId;

            //
            // EFI partition attributes for this partition.
            //

            ULONG64 Attributes;

            //
            // EFI partition name of this partition.
            //

            WCHAR PartitionName[36];

        } Efi;

    };  // unnamed union

    struct {
        //
        // This flag is set when the well known name is created (through
        // DiskCreateSymbolicLinks) and cleared when destroying it
        // (by calling DiskDeleteSymbolicLinks).
        //

        BOOLEAN WellKnownNameCreated : 1;

        //
        // This flag is set when the PhysicalDriveN link is created (through
        // DiskCreateSymbolicLinks) and is cleared when destroying it (through
        // DiskDeleteSymbolicLinks)
        //

        BOOLEAN PhysicalDriveLinkCreated : 1;

    } LinkStatus;

    //
    // ReadyStatus - STATUS_SUCCESS indicates that the drive is ready for
    // use.  Any error status is to be returned as an explaination for why
    // a request is failed.
    //
    // This was done solely for the zero-length partition case of having no
    // media in a removable disk drive.  When that occurs, and a read is sent
    // to the zero-length non-partition-zero PDO that was created, we had to
    // be able to fail the request with a reasonable value.  This may not have
    // been the best way to do this, but it works.
    //

    NTSTATUS ReadyStatus;

    //
    // Routine to be called when updating the disk partitions.  This routine
    // is different for removable and non-removable media and is called by
    // (among other things) DiskEnumerateDevice
    //

    PDISK_UPDATE_PARTITIONS UpdatePartitionRoutine;

    //
    // SCSI address used for SMART operations.
    //

    SCSI_ADDRESS ScsiAddress;

    //
    // Event used to synchronize partitioning operations and enumerations.
    //

    KEVENT PartitioningEvent;

    //
    // These unicode strings hold the disk and volume interface strings.  If
    // the interfaces were not registered or could not be set then the string
    // buffer will be NULL.
    //

    UNICODE_STRING DiskInterfaceString;
    UNICODE_STRING PartitionInterfaceString;

    //
    // What type of failure prediction mechanism is available
    //

    FAILURE_PREDICTION_METHOD FailurePredictionCapability;
    BOOLEAN AllowFPPerfHit;

#if defined(_X86_)
    //
    // This flag indiciates that a non-default geometry for this drive has
    // already been determined by the disk driver.  This field is ignored
    // for removable media drives.
    //

    DISK_GEOMETRY_SOURCE GeometrySource;

    //
    // If GeometryDetermined is TRUE this will contain the geometry which was
    // reported by the firmware or by the BIOS.  For removable media drives
    // this will contain the last geometry used when media was present.
    //

    DISK_GEOMETRY RealGeometry;
#endif

    //
    // Indicates that the cached partition table is valid when set.
    //

    ULONG CachedPartitionTableValid;

    //
    // The cached partition table - this is only valid if the previous
    // flag is set.  When invalidated the cached partition table will be
    // freed and replaced the next time one of the partitioning functions is
    // called.  This allows the error handling routines to invalidate it by
    // setting the flag and doesn't require that they obtain a lock.
    //

    PDRIVE_LAYOUT_INFORMATION_EX CachedPartitionTable;

    //
    // This mutex prevents more than one IOCTL_DISK_VERIFY from being
    // sent down to the disk. This greatly reduces the possibility of
    // a Denial-of-Service attack
    //

    KMUTEX VerifyMutex;

} DISK_DATA, *PDISK_DATA;

// Define a general structure of identfing disk controllers with bad
// hardware.
//

#define HackDisableTaggedQueuing            (0x01)
#define HackDisableSynchronousTransfers     (0x02)
#define HackDisableSpinDown                 (0x04)
#define HackDisableWriteCache               (0x08)
#define HackCauseNotReportableHack          (0x10)
#define HackRequiresStartUnitCommand        (0x20)
#define HackDisableWriteCacheNotSupported   (0x40)


#define DiskDeviceParameterSubkey           L"Disk"
#define DiskDeviceSpecialFlags              L"SpecialFlags"
#define DiskDeviceUserWriteCacheSetting     L"UserWriteCacheSetting"


#define FUNCTIONAL_EXTENSION_SIZE sizeof(FUNCTIONAL_DEVICE_EXTENSION) + sizeof(DISK_DATA)
#define PHYSICAL_EXTENSION_SIZE sizeof(PHYSICAL_DEVICE_EXTENSION) + sizeof(DISK_DATA)

#define MODE_DATA_SIZE      192
#define VALUE_BUFFER_SIZE  2048
#define SCSI_DISK_TIMEOUT    10
#define PARTITION0_LIST_SIZE  4

#define MAX_MEDIA_TYPES 4
typedef struct _DISK_MEDIA_TYPES_LIST {
    PCHAR VendorId;
    PCHAR ProductId;
    PCHAR Revision;
    const ULONG NumberOfTypes;
    const ULONG NumberOfSides;
    const STORAGE_MEDIA_TYPE MediaTypes[MAX_MEDIA_TYPES];
} DISK_MEDIA_TYPES_LIST, *PDISK_MEDIA_TYPES_LIST;

//
// WMI reregistration structures used for reregister work item
//
typedef struct
{
    SINGLE_LIST_ENTRY Next;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
} DISKREREGREQUEST, *PDISKREREGREQUEST;

//
// Write cache setting as defined by the user
//
typedef enum _DISK_USER_WRITE_CACHE_SETTING
{
    DiskWriteCacheDisable =  0,
    DiskWriteCacheEnable  =  1,
    DiskWriteCacheDefault = -1

} DISK_USER_WRITE_CACHE_SETTING, *PDISK_USER_WRITE_CACHE_SETTING;

#define MAX_SECTORS_PER_VERIFY              0x200

//
// This is based off 100ns units
//
#define ONE_MILLI_SECOND   ((ULONGLONG)10 * 1000)

//
// Context for the work-item
//
typedef struct _DISK_VERIFY_WORKITEM_CONTEXT
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PIO_WORKITEM WorkItem;

} DISK_VERIFY_WORKITEM_CONTEXT, *PDISK_VERIFY_WORKITEM_CONTEXT;

//
// Poll for Failure Prediction every hour
//
#define DISK_DEFAULT_FAILURE_POLLING_PERIOD 1 * 60 * 60

//
// Static global lookup tables.
//

extern CLASSPNP_SCAN_FOR_SPECIAL_INFO DiskBadControllers[];
extern const DISK_MEDIA_TYPES_LIST DiskMediaTypes[];

//
// Macros
//

//
// Routine prototypes.
//


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
DiskUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DiskAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
DiskInitFdo(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
DiskInitPdo(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
DiskStartFdo(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
DiskStartPdo(
    IN PDEVICE_OBJECT Pdo
    );

NTSTATUS
DiskStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
DiskRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );

NTSTATUS
DiskReadWriteVerification(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DiskFdoProcessError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
DiskShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskGetCacheInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PDISK_CACHE_INFORMATION CacheInfo
    );

NTSTATUS
DiskSetCacheInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PDISK_CACHE_INFORMATION CacheInfo
    );

VOID
DiskLogCacheInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PDISK_CACHE_INFORMATION CacheInfo,
    IN NTSTATUS Status
    );

VOID
DisableWriteCache(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    );

VOID
DiskIoctlVerify(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDISK_VERIFY_WORKITEM_CONTEXT Context
    );

NTSTATUS
DiskModeSelect(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCHAR ModeSelectBuffer,
    IN ULONG Length,
    IN BOOLEAN SavePage
    );

//
// We need to validate that the self test subcommand is valid and
// appropriate. Right now we allow subcommands 0, 1 and 2 which are non
// captive mode tests. Once we figure out a way to know if it is safe to
// run a captive test then we can allow captive mode tests. Also if the
// atapi 5 spec is ever updated to denote that bit 7 is the captive
// mode bit, we can allow any request that does not have bit 7 set. Until
// that is done we want to be sure
//
#define DiskIsValidSmartSelfTest(Subcommand) \
    ( ((Subcommand) == SMART_OFFLINE_ROUTINE_OFFLINE) || \
      ((Subcommand) == SMART_SHORT_SELFTEST_OFFLINE) || \
      ((Subcommand) == SMART_EXTENDED_SELFTEST_OFFLINE) )


NTSTATUS
DiskPerformSmartCommand(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG SrbControlCode,
    IN UCHAR Command,
    IN UCHAR Feature,
    IN UCHAR SectorCount,
    IN UCHAR SectorNumber,
    IN OUT PSRB_IO_CONTROL SrbControl,
    OUT PULONG BufferSize
    );

NTSTATUS
DiskGetInfoExceptionInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    OUT PMODE_INFO_EXCEPTIONS ReturnPageData
    );

NTSTATUS
DiskSetInfoExceptionInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PMODE_INFO_EXCEPTIONS PageData
    );

NTSTATUS
DiskDetectFailurePrediction(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PFAILURE_PREDICTION_METHOD FailurePredictCapability
    );

BOOLEAN
EnumerateBusKey(
    IN PFUNCTIONAL_DEVICE_EXTENSION DeviceExtension,
    HANDLE BusKey,
    PULONG DiskNumber
    );

NTSTATUS
DiskCreateFdo(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN PULONG DeviceCount,
    IN BOOLEAN DasdAccessOnly
    );

VOID
UpdateDeviceObjects(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DiskSetSpecialHacks(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG_PTR Data
    );

VOID
DiskScanRegistryForSpecial(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

VOID
ResetBus(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DiskEnumerateDevice(
    IN PDEVICE_OBJECT Fdo
    );

NTSTATUS
DiskQueryId(
    IN PDEVICE_OBJECT Pdo,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING UnicodeIdString
    );

NTSTATUS
DiskQueryPnpCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
DiskGenerateDeviceName(
    IN BOOLEAN IsFdo,
    IN ULONG DeviceNumber,
    IN OPTIONAL ULONG PartitionNumber,
    IN OPTIONAL PLARGE_INTEGER StartingOffset,
    IN OPTIONAL PLARGE_INTEGER PartitionLength,
    OUT PUCHAR *RawName
    );

VOID
DiskCreateSymbolicLinks(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
DiskUpdatePartitions(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PDRIVE_LAYOUT_INFORMATION_EX PartitionList
    );

VOID
DiskUpdateRemovablePartitions(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PDRIVE_LAYOUT_INFORMATION_EX PartitionList
    );

NTSTATUS
DiskCreatePdo(
    IN PDEVICE_OBJECT Fdo,
    IN ULONG PartitionOrdinal,
    IN PPARTITION_INFORMATION_EX PartitionEntry,
    IN PARTITION_STYLE PartitionStyle,
    OUT PDEVICE_OBJECT *Pdo
    );

VOID
DiskDeleteSymbolicLinks(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DiskPdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS
DiskPdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
DiskPdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
DiskPdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
DiskPdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
DiskFdoQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName
    );

NTSTATUS
DiskFdoQueryWmiRegInfoEx(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING MofName
    );

NTSTATUS
DiskFdoQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
DiskFdoSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
DiskFdoSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
DiskFdoExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
DiskWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );

NTSTATUS
DiskReadFailurePredictStatus(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_FAILURE_PREDICT_STATUS DiskSmartStatus
    );

NTSTATUS
DiskReadFailurePredictData(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PSTORAGE_FAILURE_PREDICT_DATA DiskSmartData
    );

NTSTATUS
DiskEnableDisableFailurePrediction(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    BOOLEAN Enable
    );

NTSTATUS
DiskEnableDisableFailurePredictPolling(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    BOOLEAN Enable,
    ULONG PollTimeInSeconds
    );

VOID
DiskAcquirePartitioningLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

VOID
DiskReleasePartitioningLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );

NTSTATUS DiskInitializeReregistration(
    void
    );

extern GUIDREGINFO DiskWmiFdoGuidList[];
extern GUIDREGINFO DiskWmiPdoGuidList[];

#if defined(_X86_)
NTSTATUS
DiskReadDriveCapacity(
    IN PDEVICE_OBJECT Fdo
    );
#else
#define DiskReadDriveCapacity(Fdo)  ClassReadDriveCapacity(Fdo)
#endif


#if defined(_X86_)

#if 0
NTSTATUS
DiskQuerySuggestedLinkName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
#endif

NTSTATUS
DiskSaveDetectInfo(
    PDRIVER_OBJECT DriverObject
    );

VOID
DiskCleanupDetectInfo(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
DiskDriverReinitialization (
    IN PDRIVER_OBJECT DriverObject,
    IN PVOID Nothing,
    IN ULONG Count
    );

#endif

VOID
DiskConvertPartitionToExtended(
    IN PPARTITION_INFORMATION Partition,
    OUT PPARTITION_INFORMATION_EX PartitionEx
    );

PDRIVE_LAYOUT_INFORMATION_EX
DiskConvertLayoutToExtended(
    IN CONST PDRIVE_LAYOUT_INFORMATION Layout
    );

PDRIVE_LAYOUT_INFORMATION
DiskConvertExtendedToLayout(
    IN CONST PDRIVE_LAYOUT_INFORMATION_EX LayoutEx
    );

NTSTATUS
DiskReadPartitionTableEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN BOOLEAN BypassCache,
    OUT PDRIVE_LAYOUT_INFORMATION_EX* DriveLayout
    );

NTSTATUS
DiskWritePartitionTableEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN PDRIVE_LAYOUT_INFORMATION_EX DriveLayout
    );

NTSTATUS
DiskSetPartitionInformationEx(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN ULONG PartitionNumber,
    IN struct _SET_PARTITION_INFORMATION_EX* PartitionInfo
    );

NTSTATUS
DiskSetPartitionInformation(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

NTSTATUS
DiskVerifyPartitionTable(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN BOOLEAN FixErrors
    );

BOOLEAN
DiskInvalidatePartitionTable(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo,
    IN BOOLEAN PartitionLockHeld
    );

#if defined (_X86_)
NTSTATUS
DiskGetDetectInfo(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    OUT PDISK_DETECTION_INFO DetectInfo
    );

NTSTATUS
DiskReadSignature(
    IN PDEVICE_OBJECT Fdo
    );

#else
#define DiskGetDetectInfo(FdoExtension, DetectInfo) (STATUS_UNSUCCESSFUL)
#endif


#define DiskHashGuid(Guid) (((PULONG) &Guid)[0] ^ ((PULONG) &Guid)[0] ^ ((PULONG) &Guid)[0] ^ ((PULONG) &Guid)[0])
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\diskperf\diskperf.c ===
/*++
Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    diskperf.c

Abstract:

    This driver monitors disk accesses capturing performance data.

Environment:

    kernel mode only

Notes:

--*/


#define INITGUID

#include "ntddk.h"
#include "ntdddisk.h"
#include "stdarg.h"
#include "stdio.h"
#include <ntddvol.h>

#include <mountdev.h>
#include "wmistr.h"
#include "wmidata.h"
#include "wmiguid.h"
// @@BEGIN_DDKSPLIT
#include "wmikm.h"
// @@END_DDKSPLIT
#include "wmilib.h"


#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'frPD')
#endif

#define DISKPERF_MAXSTR         64

// @@BEGIN_DDKSPLIT
//
// Disk notification or callout
//

typedef
VOID
(*PPHYSICAL_DISK_IO_NOTIFY_ROUTINE)(
    IN ULONG DiskNumber,
    IN PIRP Irp,
    IN PDISK_PERFORMANCE PerfCounters
    );
// @@END_DDKSPLIT

//
// Device Extension
//

typedef struct _DEVICE_EXTENSION {

    //
    // Back pointer to device object
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Target Device Object
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    // Physical device object
    //
    PDEVICE_OBJECT PhysicalDeviceObject;

    //
    // Disk number for reference in WMI
    //

    ULONG       DiskNumber;

    //
    // Use to keep track of Volume info from ntddvol.h
    //

    WCHAR StorageManagerName[8];

    //
    // Disk performance counters
    // and locals used to compute counters
    //

    ULONG   Processors;
    PDISK_PERFORMANCE DiskCounters;    // per processor counters
    LARGE_INTEGER LastIdleClock;
    LONG QueueDepth;
    LONG CountersEnabled;

    //
    // must synchronize paging path notifications
    //
    KEVENT PagingPathCountEvent;
    ULONG  PagingPathCount;

    //
    // Physical Device name or WMI Instance Name
    //

    UNICODE_STRING PhysicalDeviceName;
    WCHAR PhysicalDeviceNameBuffer[DISKPERF_MAXSTR];

// @@BEGIN_DDKSPLIT
    //
    // Notification routine for tracing
    //
    PPHYSICAL_DISK_IO_NOTIFY_ROUTINE PhysicalDiskIoNotifyRoutine;

// @@END_DDKSPLIT
    //
    // Private context for using WmiLib
    //
    WMILIB_CONTEXT WmilibContext;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)
#define PROCESSOR_COUNTERS_SIZE FIELD_OFFSET(DISK_PERFORMANCE, QueryTime)

/*
Layout of Per Processor Counters is a contiguous block of memory:
    Processor 1
+-----------------------+     +-----------------------+
|PROCESSOR_COUNTERS_SIZE| ... |PROCESSOR_COUNTERS_SIZE|
+-----------------------+     +-----------------------+
where PROCESSOR_COUNTERS_SIZE is less than sizeof(DISK_PERFORMANCE) since
we only put those we actually use for counting.
*/

UNICODE_STRING DiskPerfRegistryPath;


//
// Function declarations
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
DiskPerfForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );


NTSTATUS
DiskPerfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
DiskPerfCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DiskPerfDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
DiskPerfShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DiskPerfUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS DiskPerfWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DiskPerfLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG UniqueId,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS Status
    );

NTSTATUS
DiskPerfRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
DiskPerfIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DiskperfQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
DiskperfQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

VOID
DiskPerfSyncFilterWithTarget(
    IN PDEVICE_OBJECT FilterDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

NTSTATUS
DiskperfWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

VOID
DiskPerfAddCounters(
    IN OUT PDISK_PERFORMANCE TotalCounters,
    IN PDISK_PERFORMANCE NewCounters,
    IN LARGE_INTEGER Frequency
    );

#if DBG

#define DEBUG_BUFFER_LENGTH 256

ULONG DiskPerfDebug = 0;
UCHAR DiskPerfDebugBuffer[DEBUG_BUFFER_LENGTH];

VOID
DiskPerfDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define DebugPrint(x)   DiskPerfDebugPrint x

#else

#define DebugPrint(x)

#endif

//
// Define the sections that allow for discarding (i.e. paging) some of
// the code.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#pragma alloc_text (PAGE, DiskPerfAddDevice)
#pragma alloc_text (PAGE, DiskPerfDispatchPnp)
#pragma alloc_text (PAGE, DiskPerfStartDevice)
#pragma alloc_text (PAGE, DiskPerfRemoveDevice)
#pragma alloc_text (PAGE, DiskPerfUnload)
#pragma alloc_text (PAGE, DiskPerfWmi)
#pragma alloc_text (PAGE, DiskperfQueryWmiRegInfo)
#pragma alloc_text (PAGE, DiskPerfRegisterDevice)
#pragma alloc_text (PAGE, DiskPerfSyncFilterWithTarget)
#endif

WMIGUIDREGINFO DiskperfGuidList[] =
{
    { &DiskPerfGuid,
      1,
      0
    }
};

#define DiskperfGuidCount (sizeof(DiskperfGuidList) / sizeof(WMIGUIDREGINFO))

#define USE_PERF_CTR

#ifdef USE_PERF_CTR
#define DiskPerfGetClock(a, b) (a) = KeQueryPerformanceCounter((b))
#else
#define DiskPerfGetClock(a, b) KeQuerySystemTime(&(a))
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O manager to set up the disk
    performance driver. The driver object is set up and then the Pnp manager
    calls DiskPerfAddDevice to attach to the boot devices.

Arguments:

    DriverObject - The disk performance driver object.

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful

--*/

{

    ULONG               ulIndex;
    PDRIVER_DISPATCH  * dispatch;

    //
    // Remember registry path
    //

    DiskPerfRegistryPath.MaximumLength = RegistryPath->Length
                                            + sizeof(UNICODE_NULL);
    DiskPerfRegistryPath.Buffer = ExAllocatePool(
                                    PagedPool,
                                    DiskPerfRegistryPath.MaximumLength);
    if (DiskPerfRegistryPath.Buffer != NULL)
    {
        RtlCopyUnicodeString(&DiskPerfRegistryPath, RegistryPath);
    } else {
        DiskPerfRegistryPath.Length = 0;
        DiskPerfRegistryPath.MaximumLength = 0;
    }

    //
    // Create dispatch points
    //
    for (ulIndex = 0, dispatch = DriverObject->MajorFunction;
         ulIndex <= IRP_MJ_MAXIMUM_FUNCTION;
         ulIndex++, dispatch++) {

        *dispatch = DiskPerfSendToNextDriver;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]          = DiskPerfCreate;
    DriverObject->MajorFunction[IRP_MJ_READ]            = DiskPerfReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = DiskPerfReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = DiskPerfDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = DiskPerfWmi;

    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]        = DiskPerfShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]   = DiskPerfShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = DiskPerfDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = DiskPerfDispatchPower;

    DriverObject->DriverExtension->AddDevice            = DiskPerfAddDevice;
    DriverObject->DriverUnload                          = DiskPerfUnload;

    return(STATUS_SUCCESS);

} // end DriverEntry()

#define FILTER_DEVICE_PROPOGATE_FLAGS            0
#define FILTER_DEVICE_PROPOGATE_CHARACTERISTICS (FILE_REMOVABLE_MEDIA |  \
                                                 FILE_READ_ONLY_DEVICE | \
                                                 FILE_FLOPPY_DISKETTE    \
                                                 )

VOID
DiskPerfSyncFilterWithTarget(
    IN PDEVICE_OBJECT FilterDevice,
    IN PDEVICE_OBJECT TargetDevice
    )
{
    ULONG                   propFlags;

    PAGED_CODE();

    //
    // Propogate all useful flags from target to diskperf. MountMgr will look
    // at the diskperf object capabilities to figure out if the disk is
    // a removable and perhaps other things.
    //
    propFlags = TargetDevice->Flags & FILTER_DEVICE_PROPOGATE_FLAGS;
    FilterDevice->Flags |= propFlags;

    propFlags = TargetDevice->Characteristics & FILTER_DEVICE_PROPOGATE_CHARACTERISTICS;
    FilterDevice->Characteristics |= propFlags;


}

NTSTATUS
DiskPerfAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:

    Creates and initializes a new filter device object FiDO for the
    corresponding PDO.  Then it attaches the device object to the device
    stack of the drivers for the device.

Arguments:

    DriverObject - Disk performance driver object.
    PhysicalDeviceObject - Physical Device Object from the underlying layered driver

Return Value:

    NTSTATUS
--*/

{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;
    PDEVICE_OBJECT          filterDeviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    CCHAR                   ntNameBuffer[DISKPERF_MAXSTR];
    STRING                  ntNameString;
    UNICODE_STRING          ntUnicodeString;
    PIRP                    irp;
    STORAGE_DEVICE_NUMBER   number;
    ULONG                   registrationFlag = 0;
    PWMILIB_CONTEXT         wmilibContext;
    PCHAR                   buffer;
    ULONG                   buffersize;

    PAGED_CODE();

    //
    // Create a filter device object for this device (partition).
    //

    DebugPrint((2, "DiskPerfAddDevice: Driver %X Device %X\n",
            DriverObject, PhysicalDeviceObject));

    status = IoCreateDevice(DriverObject,
                            DEVICE_EXTENSION_SIZE,
                            NULL,
                            FILE_DEVICE_DISK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &filterDeviceObject);

    if (!NT_SUCCESS(status)) {
       DebugPrint((1, "DiskPerfAddDevice: Cannot create filterDeviceObject\n"));
       return status;
    }

    filterDeviceObject->Flags |= DO_DIRECT_IO;

    deviceExtension = (PDEVICE_EXTENSION) filterDeviceObject->DeviceExtension;

    RtlZeroMemory(deviceExtension, DEVICE_EXTENSION_SIZE);
    DiskPerfGetClock(deviceExtension->LastIdleClock, NULL);
    DebugPrint((10, "DiskPerfAddDevice: LIC=%I64u\n",
                    deviceExtension->LastIdleClock));

    //
    // Allocate per processor counters. NOTE: To save some memory, it does
    // allocate memory beyond QueryTime. Remember to expand size if there
    // is a need to use anything beyond this
    //
    deviceExtension->Processors = KeNumberProcessors;
    buffersize= PROCESSOR_COUNTERS_SIZE * deviceExtension->Processors;
    buffer = (PCHAR) ExAllocatePool(NonPagedPool, buffersize);
    if (buffer != NULL) {
        RtlZeroMemory(buffer, buffersize);
        deviceExtension->DiskCounters = (PDISK_PERFORMANCE) buffer;
    }
    else {
        DiskPerfLogError(
            filterDeviceObject,
            513,
            STATUS_SUCCESS,
            IO_ERR_INSUFFICIENT_RESOURCES);
    }

    //
    // Attaches the device object to the highest device object in the chain and
    // return the previously highest device object, which is passed to
    // IoCallDriver when pass IRPs down the device stack
    //

    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    deviceExtension->TargetDeviceObject =
        IoAttachDeviceToDeviceStack(filterDeviceObject, PhysicalDeviceObject);

    if (deviceExtension->TargetDeviceObject == NULL) {
        IoDeleteDevice(filterDeviceObject);
        DebugPrint((1, "DiskPerfAddDevice: Unable to attach %X to target %X\n",
            filterDeviceObject, PhysicalDeviceObject));
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Save the filter device object in the device extension
    //
    deviceExtension->DeviceObject = filterDeviceObject;

// @@BEGIN_DDKSPLIT
    deviceExtension->PhysicalDiskIoNotifyRoutine = NULL;
// @@END_DDKSPLIT
    deviceExtension->PhysicalDeviceName.Buffer
            = deviceExtension->PhysicalDeviceNameBuffer;

    KeInitializeEvent(&deviceExtension->PagingPathCountEvent,
                      NotificationEvent, TRUE);


    //
    // Initialize WMI library context
    //
    wmilibContext = &deviceExtension->WmilibContext;
    RtlZeroMemory(wmilibContext, sizeof(WMILIB_CONTEXT));
    wmilibContext->GuidCount = DiskperfGuidCount;
    wmilibContext->GuidList = DiskperfGuidList;
    wmilibContext->QueryWmiRegInfo = DiskperfQueryWmiRegInfo;
    wmilibContext->QueryWmiDataBlock = DiskperfQueryWmiDataBlock;
    wmilibContext->WmiFunctionControl = DiskperfWmiFunctionControl;

    //
    // default to DO_POWER_PAGABLE
    //

    filterDeviceObject->Flags |=  DO_POWER_PAGABLE;

    //
    // Clear the DO_DEVICE_INITIALIZING flag
    //

    filterDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;

} // end DiskPerfAddDevice()


NTSTATUS
DiskPerfDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch for PNP

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;

    PAGED_CODE();

    DebugPrint((2, "DiskPerfDispatchPnp: Device %X Irp %X\n",
        DeviceObject, Irp));

    switch(irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:
            //
            // Call the Start Routine handler to schedule a completion routine
            //
            DebugPrint((3,
               "DiskPerfDispatchPnp: Schedule completion for START_DEVICE"));
            status = DiskPerfStartDevice(DeviceObject, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
        {
            //
            // Call the Remove Routine handler to schedule a completion routine
            //
            DebugPrint((3,
               "DiskPerfDispatchPnp: Schedule completion for REMOVE_DEVICE"));
            status = DiskPerfRemoveDevice(DeviceObject, Irp);
            break;
        }
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        {
            PIO_STACK_LOCATION irpStack;
            ULONG count;
            BOOLEAN setPagable;

            DebugPrint((3,
               "DiskPerfDispatchPnp: Processing DEVICE_USAGE_NOTIFICATION"));
            irpStack = IoGetCurrentIrpStackLocation(Irp);

            if (irpStack->Parameters.UsageNotification.Type != DeviceUsageTypePaging) {
                status = DiskPerfSendToNextDriver(DeviceObject, Irp);
                break; // out of case statement
            }

            deviceExtension = DeviceObject->DeviceExtension;

            //
            // wait on the paging path event
            //

            status = KeWaitForSingleObject(&deviceExtension->PagingPathCountEvent,
                                           Executive, KernelMode,
                                           FALSE, NULL);

            //
            // if removing last paging device, need to set DO_POWER_PAGABLE
            // bit here, and possible re-set it below on failure.
            //

            setPagable = FALSE;
            if (!irpStack->Parameters.UsageNotification.InPath &&
                deviceExtension->PagingPathCount == 1 ) {

                //
                // removing the last paging file
                // must have DO_POWER_PAGABLE bits set
                //

                if (DeviceObject->Flags & DO_POWER_INRUSH) {
                    DebugPrint((3, "DiskPerfDispatchPnp: last paging file "
                                "removed but DO_POWER_INRUSH set, so not "
                                "setting PAGABLE bit "
                                "for DO %p\n", DeviceObject));
                } else {
                    DebugPrint((2, "DiskPerfDispatchPnp: Setting  PAGABLE "
                                "bit for DO %p\n", DeviceObject));
                    DeviceObject->Flags |= DO_POWER_PAGABLE;
                    setPagable = TRUE;
                }

            }

            //
            // send the irp synchronously
            //

            status = DiskPerfForwardIrpSynchronous(DeviceObject, Irp);

            //
            // now deal with the failure and success cases.
            // note that we are not allowed to fail the irp
            // once it is sent to the lower drivers.
            //

            if (NT_SUCCESS(status)) {

                IoAdjustPagingPathCount(
                    &deviceExtension->PagingPathCount,
                    irpStack->Parameters.UsageNotification.InPath);

                if (irpStack->Parameters.UsageNotification.InPath) {
                    if (deviceExtension->PagingPathCount == 1) {

                        //
                        // first paging file addition
                        //

                        DebugPrint((3, "DiskPerfDispatchPnp: Clearing PAGABLE bit "
                                    "for DO %p\n", DeviceObject));
                        DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                    }
                }

            } else {

                //
                // cleanup the changes done above
                //

                if (setPagable == TRUE) {
                    DeviceObject->Flags &= ~DO_POWER_PAGABLE;
                    setPagable = FALSE;
                }

            }

            //
            // set the event so the next one can occur.
            //

            KeSetEvent(&deviceExtension->PagingPathCountEvent,
                       IO_NO_INCREMENT, FALSE);

            //
            // and complete the irp
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return status;
            break;

        }

        default:
            DebugPrint((3,
               "DiskPerfDispatchPnp: Forwarding irp"));
            //
            // Simply forward all other Irps
            //
            return DiskPerfSendToNextDriver(DeviceObject, Irp);

    }

    return status;

} // end DiskPerfDispatchPnp()


NTSTATUS
DiskPerfIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:

    DeviceObject is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT Event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(DeviceObject);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // end DiskPerfIrpCompletion()


NTSTATUS
DiskPerfStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when a Pnp Start Irp is received.
    It will schedule a completion routine to initialize and register with WMI.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of processing the Start Irp

--*/
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              event;
    NTSTATUS            status;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    status = DiskPerfForwardIrpSynchronous(DeviceObject, Irp);

    DiskPerfSyncFilterWithTarget(DeviceObject,
                                 deviceExtension->TargetDeviceObject);

    //
    // Complete WMI registration
    //
    DiskPerfRegisterDevice(DeviceObject);

    //
    // Complete the Irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
DiskPerfRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called when the device is to be removed.
    It will de-register itself from WMI first, detach itself from the
    stack before deleting itself.

Arguments:

    DeviceObject - a pointer to the device object

    Irp - a pointer to the irp


Return Value:

    Status of removing the device

--*/
{
    NTSTATUS            status;
    PDEVICE_EXTENSION   deviceExtension;
    PWMILIB_CONTEXT     wmilibContext;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Remove registration with WMI first
    //
    IoWMIRegistrationControl(DeviceObject, WMIREG_ACTION_DEREGISTER);

    //
    // quickly zero out the count first to invalid the structure
    //
    wmilibContext = &deviceExtension->WmilibContext;
    InterlockedExchange(
        (PLONG) &(wmilibContext->GuidCount),
        (LONG) 0);
    RtlZeroMemory(wmilibContext, sizeof(WMILIB_CONTEXT));

    status = DiskPerfForwardIrpSynchronous(DeviceObject, Irp);

    IoDetachDevice(deviceExtension->TargetDeviceObject);
    IoDeleteDevice(DeviceObject);

    //
    // Complete the Irp
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
DiskPerfSendToNextDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // end DiskPerfSendToNextDriver()

NTSTATUS
DiskPerfDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension;

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    return PoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // end DiskPerfDispatchPower

NTSTATUS
DiskPerfForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // copy the irpstack for the next device
    //

    IoCopyCurrentIrpStackLocationToNext(Irp);

    //
    // set a completion routine
    //

    IoSetCompletionRoutine(Irp, DiskPerfIrpCompletion,
                            &event, TRUE, TRUE, TRUE);

    //
    // call the next lower device
    //

    status = IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    //
    // wait for the actual completion
    //

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;

} // end DiskPerfForwardIrpSynchronous()


NTSTATUS
DiskPerfCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine services open commands. It establishes
    the driver's existance by returning status success.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    NT Status

--*/

{
    UNREFERENCED_PARAMETER(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;

} // end DiskPerfCreate()


NTSTATUS
DiskPerfReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry point for read and write requests
    to disks to which the diskperf driver has attached.
    This driver collects statistics and then sets a completion
    routine so that it can collect additional information when
    the request completes. Then it calls the next driver below
    it.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextIrpStack = IoGetNextIrpStackLocation(Irp);
    ULONG              processor = (ULONG) KeGetCurrentProcessorNumber();
    PDISK_PERFORMANCE  partitionCounters = NULL;
    LONG               queueLen;
    PLARGE_INTEGER     timeStamp;

    if (deviceExtension->DiskCounters != NULL) {
        partitionCounters = (PDISK_PERFORMANCE)
                            ((PCHAR) deviceExtension->DiskCounters
                                + (processor*PROCESSOR_COUNTERS_SIZE));
    }


    //
    // Device is not initialized properly. Blindly pass the irp along
    //
    if (deviceExtension->CountersEnabled <= 0 ||
        deviceExtension->PhysicalDeviceNameBuffer[0] == 0 ||
        partitionCounters == NULL) {
        return DiskPerfSendToNextDriver(DeviceObject, Irp);
    }

    //
    // Increment queue depth counter.
    //

    queueLen = InterlockedIncrement(&deviceExtension->QueueDepth);

    //
    // Copy current stack to next stack.
    //

    *nextIrpStack = *currentIrpStack;

    //
    // Time stamp current request start.
    //

    timeStamp = (PLARGE_INTEGER) &currentIrpStack->Parameters.Read;
    DiskPerfGetClock(*timeStamp, NULL);
    DebugPrint((10, "DiskPerfReadWrite: TS=%I64u\n", *timeStamp));

    if (queueLen == 1) {
        partitionCounters->IdleTime.QuadPart
            += timeStamp->QuadPart -
                deviceExtension->LastIdleClock.QuadPart;
        deviceExtension->LastIdleClock.QuadPart = timeStamp->QuadPart;
    }

    //
    // Set completion routine callback.
    //

    IoSetCompletionRoutine(Irp,
                           DiskPerfIoCompletion,
                           DeviceObject,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Return the results of the call to the disk driver.
    //

    return IoCallDriver(deviceExtension->TargetDeviceObject,
                        Irp);

} // end DiskPerfReadWrite()


NTSTATUS
DiskPerfIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This routine will get control from the system at the completion of an IRP.
    It will calculate the difference between the time the IRP was started
    and the current time, and decrement the queue depth.

Arguments:

    DeviceObject - for the IRP.
    Irp          - The I/O request that just completed.
    Context      - Not used.

Return Value:

    The IRP status.

--*/

{
    PDEVICE_EXTENSION  deviceExtension   = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack          = IoGetCurrentIrpStackLocation(Irp);
    PDISK_PERFORMANCE  partitionCounters;
    LARGE_INTEGER      timeStampComplete;
    PLARGE_INTEGER     difference;
    KIRQL              currentIrql;
// @@BEGIN_DDKSPLIT
    PPHYSICAL_DISK_IO_NOTIFY_ROUTINE notifyRoutine;
// @@END_DDKSPLIT
    LONG               queueLen;

    UNREFERENCED_PARAMETER(Context);

    //
    // Get the per processor partition counters
    // NOTE: DiskPerfReadWrite already check to see if this buffer is NON
    // NULL before scheduling this completion routine, so we assume that it
    // is always non-NULL when we get here
    //

    partitionCounters = (PDISK_PERFORMANCE)
                        ((PCHAR) deviceExtension->DiskCounters
                             + ((ULONG)KeGetCurrentProcessorNumber()
                                * PROCESSOR_COUNTERS_SIZE));
    //
    // Time stamp current request complete.
    //

    if (partitionCounters == NULL) {    // just in case
        return STATUS_SUCCESS;
    };
    difference = (PLARGE_INTEGER) &irpStack->Parameters.Read;
    DiskPerfGetClock(timeStampComplete, NULL);
    difference->QuadPart = timeStampComplete.QuadPart - difference->QuadPart;
    DebugPrint((10, "DiskPerfIoCompletion: TS=%I64u diff %I64u\n",
                     timeStampComplete, difference->QuadPart));

    //
    // Decrement the queue depth counters for the volume.  This is
    // done without the spinlock using the Interlocked functions.
    // This is the only
    // legal way to do this.
    //

    queueLen = InterlockedDecrement(&deviceExtension->QueueDepth);

    if (queueLen < 0) { // do not over-decrement. Only happens at start
        queueLen = InterlockedIncrement(&deviceExtension->QueueDepth);
    }
    if (queueLen == 0) {
        deviceExtension->LastIdleClock = timeStampComplete;
    }

    //
    // Update counters
    //

    if (irpStack->MajorFunction == IRP_MJ_READ) {

        //
        // Add bytes in this request to bytes read counters.
        //

        partitionCounters->BytesRead.QuadPart += Irp->IoStatus.Information;

        //
        // Increment read requests processed counters.
        //

        partitionCounters->ReadCount++;

        //
        // Calculate request processing time.
        //

        partitionCounters->ReadTime.QuadPart += difference->QuadPart;
        DebugPrint((11, "Added RT delta %I64u total %I64u qlen=%d\n",
            difference->QuadPart, partitionCounters->ReadTime.QuadPart,
            queueLen));
    }

    else {

        //
        // Add bytes in this request to bytes write counters.
        //

        partitionCounters->BytesWritten.QuadPart += Irp->IoStatus.Information;

        //
        // Increment write requests processed counters.
        //

        partitionCounters->WriteCount++;

        //
        // Calculate request processing time.
        //

        partitionCounters->WriteTime.QuadPart += difference->QuadPart;
        DebugPrint((11, "Added WT delta %I64u total %I64u qlen=%d\n",
            difference->QuadPart, partitionCounters->WriteTime.QuadPart,
            queueLen));
    }

    if (Irp->Flags & IRP_ASSOCIATED_IRP) {
        partitionCounters->SplitCount++;
    }

// @@BEGIN_DDKSPLIT
    notifyRoutine = deviceExtension->PhysicalDiskIoNotifyRoutine;
    if (notifyRoutine) {
        (*notifyRoutine) (deviceExtension->DiskNumber, Irp, partitionCounters);
    }
// @@END_DDKSPLIT

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    return STATUS_SUCCESS;

} // DiskPerfIoCompletion


NTSTATUS
DiskPerfDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the disk performance
    device control. All others are passed down to the disk drivers.
    The disk performane device control returns a current snapshot of
    the performance data.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

    DebugPrint((2, "DiskPerfDeviceControl: DeviceObject %X Irp %X\n",
                    DeviceObject, Irp));

    if (currentIrpStack->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_DISK_PERFORMANCE) {

        NTSTATUS        status;
        KIRQL     currentIrql;

        //
        // Verify user buffer is large enough for the performance data.
        //

        if (currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(DISK_PERFORMANCE)) {

        //
        // Indicate unsuccessful status and no data transferred.
        //

        status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = 0;

        }

        else {
            ULONG i;
            PDISK_PERFORMANCE totalCounters;
            PDISK_PERFORMANCE diskCounters = deviceExtension->DiskCounters;
            LARGE_INTEGER frequency, perfctr;

            if (diskCounters == NULL) {
                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return STATUS_UNSUCCESSFUL;
            }

            totalCounters = (PDISK_PERFORMANCE) Irp->AssociatedIrp.SystemBuffer;
            RtlZeroMemory(totalCounters, sizeof(DISK_PERFORMANCE));
#ifdef USE_PERF_CTR
            perfctr = KeQueryPerformanceCounter(&frequency);
#endif
            KeQuerySystemTime(&totalCounters->QueryTime);

            for (i=0; i<deviceExtension->Processors; i++) {
                DiskPerfAddCounters(totalCounters, diskCounters, frequency);
                diskCounters = (PDISK_PERFORMANCE)
                               ((PCHAR) diskCounters + PROCESSOR_COUNTERS_SIZE);
            }
            totalCounters->QueueDepth = deviceExtension->QueueDepth;

            if (totalCounters->QueueDepth == 0) {
                LARGE_INTEGER difference;

                difference.QuadPart =
#ifdef USE_PERF_CTR
                    perfctr.QuadPart
#else
                   totalCounters->QueryTime.QuadPart
#endif
                        - deviceExtension->LastIdleClock.QuadPart;
                if (difference.QuadPart > 0) {
                    totalCounters->IdleTime.QuadPart +=
#ifdef USE_PERF_CTR
                        10000000 * difference.QuadPart / frequency.QuadPart;
#else
                        difference.QuadPart;
#endif
                }
            }
            totalCounters->StorageDeviceNumber
                = deviceExtension->DiskNumber;
            RtlCopyMemory(
                &totalCounters->StorageManagerName[0],
                &deviceExtension->StorageManagerName[0],
                8 * sizeof(WCHAR));
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(DISK_PERFORMANCE);
        }

        //
        // Complete request.
        //

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;

    }

    else {

        //
        // Set current stack back one.
        //

        Irp->CurrentLocation++,
        Irp->Tail.Overlay.CurrentStackLocation++;

        //
        // Pass unrecognized device control requests
        // down to next driver layer.
        //

        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
    }
} // end DiskPerfDeviceControl()



NTSTATUS DiskPerfWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine handles any WMI requests for information. Since the disk
    information is read-only, is always collected and does not have any
    events only QueryAllData, QuerySingleInstance and GetRegInfo requests
    are supported.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS status;
    PWMILIB_CONTEXT wmilibContext;
    SYSCTL_IRP_DISPOSITION disposition;
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    DebugPrint((2, "DiskPerfWmi: DeviceObject %X Irp %X\n",
                    DeviceObject, Irp));
    wmilibContext = &deviceExtension->WmilibContext;
    if (wmilibContext->GuidCount == 0)  // wmilibContext is not valid
    {
        DebugPrint((3, "DiskPerfWmi: WmilibContext invalid"));
        return DiskPerfSendToNextDriver(DeviceObject, Irp);
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

// @@BEGIN_DDKSPLIT
    if (irpSp->MinorFunction == IRP_MN_SET_TRACE_NOTIFY)
    {
        PVOID buffer = irpSp->Parameters.WMI.Buffer;
        ULONG bufferSize = irpSp->Parameters.WMI.BufferSize;

        if (bufferSize < sizeof(PPHYSICAL_DISK_IO_NOTIFY_ROUTINE))
        {
            status = STATUS_BUFFER_TOO_SMALL;
        } else {
            //
            // First we need to turn on counters if we are doing tracing
            //
            PVOID current, notifyRoutine;
            ULONG i;

            current = (PVOID) deviceExtension->PhysicalDiskIoNotifyRoutine;
            notifyRoutine = *((PVOID *)buffer);
            if (current == NULL && notifyRoutine != NULL) {
                if (InterlockedIncrement(&deviceExtension->CountersEnabled)
                        == 1) {
                    //
                    // reset per processor counters only
                    //
                    if (deviceExtension->DiskCounters != NULL) {
                        RtlZeroMemory(
                            deviceExtension->DiskCounters,
                            PROCESSOR_COUNTERS_SIZE
                                * deviceExtension->Processors);
                    }
                    DiskPerfGetClock(deviceExtension->LastIdleClock, NULL);
                    DebugPrint((10, "DiskPerfWmi: LIC=%I64u\n",
                        deviceExtension->LastIdleClock));
                    deviceExtension->QueueDepth = 0;
                }
                DebugPrint((3, "DiskPerfWmi: Counters enabled %d\n",
                                deviceExtension->CountersEnabled));
            }
            else if (current != NULL && notifyRoutine == NULL) {
                InterlockedDecrement(&deviceExtension->CountersEnabled);
                deviceExtension->QueueDepth = 0;
                DebugPrint((3, "DiskPerfWmi: Counters disabled %d\n",
                                deviceExtension->CountersEnabled));
            }
            deviceExtension->PhysicalDiskIoNotifyRoutine
                = (PPHYSICAL_DISK_IO_NOTIFY_ROUTINE)
                    *((PVOID *)buffer);

            DebugPrint((3,
                "DiskPerfWmi: SET_TRACE_NOTIFY to %X",
                deviceExtension->PhysicalDiskIoNotifyRoutine));
            status = STATUS_SUCCESS;
        }

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    } else {
// @@END_DDKSPLIT
        DebugPrint((3, "DiskPerfWmi: Calling WmiSystemControl\n"));
        status = WmiSystemControl(wmilibContext,
                                    DeviceObject,
                                    Irp,
                                    &disposition);
        switch (disposition)
        {
            case IrpProcessed:
            {
                break;
            }

            case IrpNotCompleted:
            {
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
            }

//          case IrpForward:
//          case IrpNotWmi:
            default:
            {
                status = DiskPerfSendToNextDriver(DeviceObject, Irp);
                break;
            }
        }
// @@BEGIN_DDKSPLIT
    }
// @@END_DDKSPLIT
    return(status);

}


NTSTATUS
DiskPerfShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for a shutdown and flush IRPs.  These are sent by the
    system before it actually shuts down or when the file system does a flush.

Arguments:

    DriverObject - Pointer to device object to being shutdown by system.
    Irp          - IRP involved.

Return Value:

    NT Status

--*/

{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

    //
    // Set current stack back one.
    //

    DebugPrint((2, "DiskPerfShutdownFlush: DeviceObject %X Irp %X\n",
                    DeviceObject, Irp));
    Irp->CurrentLocation++,
    Irp->Tail.Overlay.CurrentStackLocation++;

    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // end DiskPerfShutdownFlush()


VOID
DiskPerfUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{
    PAGED_CODE();

    return;
}


NTSTATUS
DiskPerfRegisterDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Routine to initialize a proper name for the device object, and
    register it with WMI

Arguments:

    DeviceObject - pointer to a device object to be initialized.

Return Value:

    Status of the initialization. NOTE: If the registration fails,
    the device name in the DeviceExtension will be left as empty.

--*/

{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatus;
    KEVENT                  event;
    PDEVICE_EXTENSION       deviceExtension;
    PIRP                    irp;
    STORAGE_DEVICE_NUMBER   number;
    ULONG                   registrationFlag = 0;
    WCHAR                   ntNameBuffer[DISKPERF_MAXSTR];
    STRING                  ntNameString;
    UNICODE_STRING          ntUnicodeString;

    PAGED_CODE();

    DebugPrint((2, "DiskPerfRegisterDevice: DeviceObject %X\n",
                    DeviceObject));
    deviceExtension = DeviceObject->DeviceExtension;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    //
    // Request for the device number
    //
    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_STORAGE_GET_DEVICE_NUMBER,
                    deviceExtension->TargetDeviceObject,
                    NULL,
                    0,
                    &number,
                    sizeof(number),
                    FALSE,
                    &event,
                    &ioStatus);
    if (!irp) {
        DiskPerfLogError(
            DeviceObject,
            256,
            STATUS_SUCCESS,
            IO_ERR_INSUFFICIENT_RESOURCES);
        DebugPrint((3, "DiskPerfRegisterDevice: Fail to build irp\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceExtension->TargetDeviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    if (NT_SUCCESS(status)) {

        //
        // Remember the disk number for use as parameter in DiskIoNotifyRoutine
        //
        deviceExtension->DiskNumber = number.DeviceNumber;

        //
        // Create device name for each partition
        //

        swprintf(
            deviceExtension->PhysicalDeviceNameBuffer,
            L"\\Device\\Harddisk%d\\Partition%d",
            number.DeviceNumber, number.PartitionNumber);
        RtlInitUnicodeString(
            &deviceExtension->PhysicalDeviceName,
            &deviceExtension->PhysicalDeviceNameBuffer[0]);

// @@BEGIN_DDKSPLIT
        if (number.PartitionNumber == 0) {
            registrationFlag = WMIREG_FLAG_TRACE_PROVIDER
                                | WMIREG_NOTIFY_DISK_IO;
        }
// @@END_DDKSPLIT
        //
        // Set default name for physical disk
        //
        RtlCopyMemory(
            &(deviceExtension->StorageManagerName[0]),
            L"PhysDisk",
            8 * sizeof(WCHAR));
        DebugPrint((3, "DiskPerfRegisterDevice: Device name %ws\n",
                       deviceExtension->PhysicalDeviceNameBuffer));
    }
    else {

        // request for partition's information failed, try volume

        ULONG           outputSize = sizeof(MOUNTDEV_NAME);
        PMOUNTDEV_NAME  output;
        VOLUME_NUMBER   volumeNumber;

        output = ExAllocatePool(PagedPool, outputSize);
        if (!output) {
            DiskPerfLogError(
                DeviceObject,
                257,
                STATUS_SUCCESS,
                IO_ERR_INSUFFICIENT_RESOURCES);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
                    IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                    deviceExtension->TargetDeviceObject, NULL, 0,
                    output, outputSize, FALSE, &event, &ioStatus);
        if (!irp) {
            ExFreePool(output);
            DiskPerfLogError(
                DeviceObject,
                258,
                STATUS_SUCCESS,
                IO_ERR_INSUFFICIENT_RESOURCES);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(deviceExtension->TargetDeviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }

        if (status == STATUS_BUFFER_OVERFLOW) {
            outputSize = sizeof(MOUNTDEV_NAME) + output->NameLength;
            ExFreePool(output);
            output = ExAllocatePool(PagedPool, outputSize);

            if (!output) {
                DiskPerfLogError(
                    DeviceObject,
                    258,
                    STATUS_SUCCESS,
                    IO_ERR_INSUFFICIENT_RESOURCES);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            KeInitializeEvent(&event, NotificationEvent, FALSE);
            irp = IoBuildDeviceIoControlRequest(
                        IOCTL_MOUNTDEV_QUERY_DEVICE_NAME,
                        deviceExtension->TargetDeviceObject, NULL, 0,
                        output, outputSize, FALSE, &event, &ioStatus);
            if (!irp) {
                ExFreePool(output);
                DiskPerfLogError(
                    DeviceObject, 259,
                    STATUS_SUCCESS,
                    IO_ERR_INSUFFICIENT_RESOURCES);
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            status = IoCallDriver(deviceExtension->TargetDeviceObject, irp);
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(
                    &event,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL
                    );
                status = ioStatus.Status;
            }
        }
        if (!NT_SUCCESS(status)) {
            ExFreePool(output);
            DiskPerfLogError(
                DeviceObject,
                260,
                STATUS_SUCCESS,
                IO_ERR_CONFIGURATION_ERROR);
            return status;
        }

        //
        // Since we get the volume name instead of the disk number,
        // set it to a dummy value
        // Todo: Instead of passing the disk number back to the user app.
        // for tracing, pass the STORAGE_DEVICE_NUMBER structure instead.

        deviceExtension->DiskNumber = -1;

        deviceExtension->PhysicalDeviceName.Length = output->NameLength;
        deviceExtension->PhysicalDeviceName.MaximumLength
                = output->NameLength + sizeof(WCHAR);

        RtlCopyMemory(
            deviceExtension->PhysicalDeviceName.Buffer,
            output->Name,
            output->NameLength);
        deviceExtension->PhysicalDeviceName.Buffer
            [deviceExtension->PhysicalDeviceName.Length/sizeof(WCHAR)] = 0;
        ExFreePool(output);

        //
        // Now, get the VOLUME_NUMBER information
        //
        outputSize = sizeof(VOLUME_NUMBER);
        RtlZeroMemory(&volumeNumber, sizeof(VOLUME_NUMBER));

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(
                 IOCTL_VOLUME_QUERY_VOLUME_NUMBER,
                 deviceExtension->TargetDeviceObject, NULL, 0,
                 &volumeNumber,
                 sizeof(VOLUME_NUMBER),
                 FALSE, &event, &ioStatus);
        if (!irp) {
            DiskPerfLogError(
                DeviceObject,
                265,
                STATUS_SUCCESS,
                IO_ERR_INSUFFICIENT_RESOURCES);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        status = IoCallDriver(deviceExtension->TargetDeviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive,
                                  KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        }
        if (!NT_SUCCESS(status) ||
            volumeNumber.VolumeManagerName[0] == (WCHAR) UNICODE_NULL) {

            RtlCopyMemory(
                &deviceExtension->StorageManagerName[0],
                L"LogiDisk",
                8 * sizeof(WCHAR));
            if (NT_SUCCESS(status))
                deviceExtension->DiskNumber = volumeNumber.VolumeNumber;
        }
        else {
            RtlCopyMemory(
                &deviceExtension->StorageManagerName[0],
                &volumeNumber.VolumeManagerName[0],
                8 * sizeof(WCHAR));
            deviceExtension->DiskNumber = volumeNumber.VolumeNumber;
        }
        DebugPrint((3, "DiskPerfRegisterDevice: Device name %ws\n",
                       deviceExtension->PhysicalDeviceNameBuffer));
    }

    status = IoWMIRegistrationControl(DeviceObject,
                     WMIREG_ACTION_REGISTER | registrationFlag );
    if (! NT_SUCCESS(status)) {
        DiskPerfLogError(
            DeviceObject,
            261,
            STATUS_SUCCESS,
            IO_ERR_INTERNAL_ERROR);
    }
    return status;
}


VOID
DiskPerfLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG UniqueId,
    IN NTSTATUS ErrorCode,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    Routine to log an error with the Error Logger

Arguments:

    DeviceObject - the device object responsible for the error
    UniqueId     - an id for the error
    Status       - the status of the error

Return Value:

    None

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = (PIO_ERROR_LOG_PACKET)
                    IoAllocateErrorLogEntry(
                        DeviceObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + sizeof(DEVICE_OBJECT))
                        );

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode = ErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueId;
        errorLogEntry->FinalStatus = Status;
        //
        // The following is necessary because DumpData is of type ULONG
        // and DeviceObject can be more than that
        //
        RtlCopyMemory(
            &errorLogEntry->DumpData[0],
            &DeviceObject,
            sizeof(DEVICE_OBJECT));
        errorLogEntry->DumpDataSize = sizeof(DEVICE_OBJECT);
        IoWriteErrorLogEntry(errorLogEntry);
    }
}

NTSTATUS
DiskperfQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

    Implementations of this routine may be in paged memory

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe all of the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device. These flags are ORed into the flags specified
        by the GUIDREGINFO for each guid.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. This is
        required

    MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned unmodified. If a value is returned then
        it is NOT freed.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    USHORT size;
    NTSTATUS status;
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    size = deviceExtension->PhysicalDeviceName.Length + sizeof(UNICODE_NULL);

    InstanceName->Buffer = ExAllocatePool(PagedPool,
                                         size);
    if (InstanceName->Buffer != NULL)
    {
        *RegistryPath = &DiskPerfRegistryPath;

        *RegFlags = WMIREG_FLAG_INSTANCE_PDO | WMIREG_FLAG_EXPENSIVE;
        *Pdo = deviceExtension->PhysicalDeviceObject;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);
}


NTSTATUS
DiskperfQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. When the driver has finished filling the
    data block it must call WmiCompleteRequest to complete the irp. The
    driver can return STATUS_PENDING if the irp cannot be completed
    immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG sizeNeeded;
    KIRQL        currentIrql;
    PDISK_PERFORMANCE totalCounters;
    PDISK_PERFORMANCE diskCounters;
    PWMI_DISK_PERFORMANCE diskPerformance;
    ULONG deviceNameSize;
    PWCHAR diskNamePtr;

    deviceExtension = DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        deviceNameSize = deviceExtension->PhysicalDeviceName.Length +
                         sizeof(USHORT);
        sizeNeeded = ((sizeof(WMI_DISK_PERFORMANCE) + 1) & ~1) +
                                         deviceNameSize;
        diskCounters = deviceExtension->DiskCounters;
        if (diskCounters == NULL)
        {
            status = STATUS_UNSUCCESSFUL;
        }
        else if (BufferAvail >= sizeNeeded)
        {
            //
            // Update idle time if disk has been idle
            //
            ULONG i;
            LARGE_INTEGER perfctr, frequency;

            RtlZeroMemory(Buffer, sizeof(WMI_DISK_PERFORMANCE));
            diskPerformance = (PWMI_DISK_PERFORMANCE)Buffer;

            totalCounters = (PDISK_PERFORMANCE)diskPerformance;
            KeQuerySystemTime(&totalCounters->QueryTime);

#ifdef USE_PERF_CTR
            perfctr = KeQueryPerformanceCounter(&frequency);
#endif
            for (i=0; i<deviceExtension->Processors; i++) {
                DiskPerfAddCounters( totalCounters, diskCounters, frequency);
                DebugPrint((11,
                    "DiskPerfQueryWmiDataBlock: R%d %I64u W%d%I64u ", i,
                    diskCounters->ReadTime, diskCounters->WriteTime));
                diskCounters = (PDISK_PERFORMANCE)
                               ((PCHAR)diskCounters + PROCESSOR_COUNTERS_SIZE);
            }
            DebugPrint((11, "\n"));
            totalCounters->QueueDepth = deviceExtension->QueueDepth;

            DebugPrint((9,
                "QueryWmiDataBlock: Dev %X RT %I64u WT %I64u Rds %d Wts %d freq %I64u\n",
                totalCounters,
                totalCounters->ReadTime, totalCounters->WriteTime,
                totalCounters->ReadCount, totalCounters->WriteCount,
                frequency));

            if (totalCounters->QueueDepth == 0) {
                LARGE_INTEGER difference;

                difference.QuadPart
#ifdef USE_PERF_CTR
                    = perfctr.QuadPart -
#else
                    = totalCounters->QueryTime.QuadPart -
#endif
                           deviceExtension->LastIdleClock.QuadPart;
                if (frequency.QuadPart > 0) {
                    totalCounters->IdleTime.QuadPart +=
#ifdef USE_PERF_CTR
                        10000000 * difference.QuadPart / frequency.QuadPart;
#else
                        difference.QuadPart;
#endif
                }
            }

            totalCounters->StorageDeviceNumber
                = deviceExtension->DiskNumber;
            RtlCopyMemory(
                &totalCounters->StorageManagerName[0],
                &deviceExtension->StorageManagerName[0],
                8 * sizeof(WCHAR));

            diskNamePtr = (PWCHAR)(Buffer +
                          ((sizeof(DISK_PERFORMANCE) + 1) & ~1));
            *diskNamePtr++ = deviceExtension->PhysicalDeviceName.Length;
            RtlCopyMemory(diskNamePtr,
                          deviceExtension->PhysicalDeviceName.Buffer,
                          deviceExtension->PhysicalDeviceName.Length);
            *InstanceLengthArray = sizeNeeded;

            status = STATUS_SUCCESS;
        } else {
            status = STATUS_BUFFER_TOO_SMALL;
        }

    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
        sizeNeeded = 0;
    }

    status = WmiCompleteRequest(
                                 DeviceObject,
                                 Irp,
                                 status,
                                 sizeNeeded,
                                 IO_NO_INCREMENT);
    return(status);
}


NTSTATUS
DiskperfWmiFunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for enabling or
    disabling events and data collection.  When the driver has finished it
    must call WmiCompleteRequest to complete the irp. The driver can return
    STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose events or data collection are being
        enabled or disabled

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function differentiates between event and data collection operations

    Enable indicates whether to enable or disable


Return Value:

    status

--*/
{
    NTSTATUS status;
    PDEVICE_EXTENSION deviceExtension;
    ULONG i;

    deviceExtension = DeviceObject->DeviceExtension;

    if (GuidIndex == 0)
    {
        if (Function == WmiDataBlockControl) {
          if (Enable) {
             if (InterlockedIncrement(&deviceExtension->CountersEnabled) == 1) {
                //
                // Reset per processor counters to 0
                //
                if (deviceExtension->DiskCounters != NULL) {
                    RtlZeroMemory(
                        deviceExtension->DiskCounters,
                        PROCESSOR_COUNTERS_SIZE * deviceExtension->Processors);
                }
                DiskPerfGetClock(deviceExtension->LastIdleClock, NULL);
                DebugPrint((10,
                    "DiskPerfWmiFunctionControl: LIC=%I64u\n",
                    deviceExtension->LastIdleClock));
                deviceExtension->QueueDepth = 0;
                DebugPrint((3, "DiskPerfWmi: Counters enabled %d\n",
                                deviceExtension->CountersEnabled));
             }
          } else {
             if (InterlockedDecrement(&deviceExtension->CountersEnabled)
                  <= 0) {
                deviceExtension->CountersEnabled = 0;
                deviceExtension->QueueDepth = 0;
                DebugPrint((3, "DiskPerfWmi: Counters disabled %d\n",
                                deviceExtension->CountersEnabled));
            }
          }
        }
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_WMI_GUID_NOT_FOUND;
    }

    status = WmiCompleteRequest(
                                 DeviceObject,
                                 Irp,
                                 status,
                                 0,
                                 IO_NO_INCREMENT);
    return(status);
}


VOID
DiskPerfAddCounters(
    IN OUT PDISK_PERFORMANCE TotalCounters,
    IN PDISK_PERFORMANCE NewCounters,
    IN LARGE_INTEGER Frequency
    )
{
    TotalCounters->BytesRead.QuadPart   += NewCounters->BytesRead.QuadPart;
    TotalCounters->BytesWritten.QuadPart+= NewCounters->BytesWritten.QuadPart;
    TotalCounters->ReadCount            += NewCounters->ReadCount;
    TotalCounters->WriteCount           += NewCounters->WriteCount;
    TotalCounters->SplitCount           += NewCounters->SplitCount;
#ifdef USE_PERF_CTR
    if (Frequency.QuadPart > 0) {
        TotalCounters->ReadTime.QuadPart    +=
            NewCounters->ReadTime.QuadPart * 10000000 / Frequency.QuadPart;
        TotalCounters->WriteTime.QuadPart   +=
            NewCounters->WriteTime.QuadPart * 10000000 / Frequency.QuadPart;
        TotalCounters->IdleTime.QuadPart    +=
            NewCounters->IdleTime.QuadPart * 10000000 / Frequency.QuadPart;
    }
    else
#endif
    {
        TotalCounters->ReadTime.QuadPart    += NewCounters->ReadTime.QuadPart;
        TotalCounters->WriteTime.QuadPart   += NewCounters->WriteTime.QuadPart;
        TotalCounters->IdleTime.QuadPart    += NewCounters->IdleTime.QuadPart;
    }
}

#if DBG

VOID
DiskPerfDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all DiskPerf

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (DiskPerfDebug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & DiskPerfDebug)) {

        _vsnprintf(DiskPerfDebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint(DiskPerfDebugBuffer);
    }

    va_end(ap);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\arbiter.c ===
/*
 *  ARBITER.C
 *
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */

#include <stdlib.h>
#include <wtypes.h>

#include <dlmhdr.h>  // BUGBUG - get a common DLM header from Cluster team

#include <drivearb.h>
#include "internal.h"


//
//  Temporary inter-node arbiters
//
#define DRIVEARB_ARBITER_DLM    1
#define DRIVEARB_ARBITER_HACK   2
#define DRIVEARB_ARBITER DRIVEARB_ARBITER_DLM


BOOL InitializeArbitrationService(driveContext *drive)
{
    // nothing to do at service level
    return TRUE;
}


VOID ShutDownArbitrationService(driveContext *drive)
{
    // nothing to do at service level
}



/*
 *  InitializeClientArbitration
 *
 *      Must be called with globalMutex held.
 *
 */
BOOL InitializeClientArbitration(clientSessionContext *session)
{
    BOOL result = FALSE;

    #if DRIVEARB_ARBITER == DRIVEARB_ARBITER_DLM
    {
        int dlmStat;

        dlmStat = InitializeDistributedLockManager(&session->sessionDlmHandle);
        if (dlmStat == DLM_ERROR_SUCCESS){

            dlmStat = InitializeDistributedLock(
                                &session->sessionDlmLockHandle, 
                                NULL, 
                                session->driveViewPtr->driveName, 
                                strlen(session->driveViewPtr->driveName));
            if (dlmStat == DLM_ERROR_SUCCESS){
                result = TRUE;
            }
            else {
                DBGMSG("InitializeClientArbitration: InitializeDistributedLock failed", session->driveIndex); 
            }
        }
        else {
            DBGMSG("InitializeClientArbitration: InitializeDistributedLockManager failed", session->driveIndex); 
        }
    }
    #elif DRIVEARB_ARBITER = DRIVEARB_ARBITER_HACK
        // nothing to do
    #endif

    return result;
}


/*
 *  ShutDownClientArbitration
 *
 *      Must be called with globalMutex held.
 *
 */
VOID ShutDownClientArbitration(clientSessionContext *session)
{

    #if DRIVEARB_ARBITER == DRIVEARB_ARBITER_DLM
        if (session->sessionDlmLockHandle){
            CloseHandle(session->sessionDlmLockHandle);  // BUGBUG - how to close this handle ?
            session->sessionDlmLockHandle = NULL;
            // CloseHandle(session->sessionDlmHandle);  // BUGBUG - how to close this handle ?
        }
    #elif DRIVEARB_ARBITER = DRIVEARB_ARBITER_HACK
        // nothing to do
    #endif

}


/*
 *  AcquireNodeLevelOwnership
 *
 *      Must be called with drive mutex held.
 *
 */
BOOL AcquireNodeLevelOwnership(clientSessionContext *session)
{
    BOOL result = FALSE;

    // DBGMSG("> AcquireNodeLevelOwnership", 0); 

    #if DRIVEARB_ARBITER == DRIVEARB_ARBITER_DLM
    {
        int dlmStat;

        dlmStat = ConvertDistributedLock(   session->sessionDlmLockHandle,
                                            DLM_MODE_EX);

        if (dlmStat == DLM_ERROR_SUCCESS){

            /*
             *  We do not alert others that we have the lock.
             */
            #if 0
                DWORD bmode = 0;
                while (bmode == 0){
                    dlmStat = QueueDistributedLockEvent(
                                        drive->dlmLockHandle, 
                                        NULL, 
                                        0, 
                                        0, 
                                        &ioStat);
                    if (dlmStat == DLM_ERROR_QUEUED){
                        WaitForSingleObject(drive->dlmLockHandle, INFINITE);
                        bmode = ioStat.Information;
                        DBGMSG("QueueDistributedLockEvent returned DLM_ERROR_QUEUED", bmode); 
                    }
                    else if (dlmStat == DLM_ERROR_SUCCESS){
                        bmode = ioStat.Information;
                        // DBGMSG("QueueDistributedLockEvent returned bmode==", bmode); 
                    }
                    else {
                        DBGMSG("QueueDistributedLockEvent failed", dlmStat); 
                        break;
                    }
                }

                if (bmode != 0){
                    result = TRUE;
                }
                else {
                    DBGMSG("QueueDistributedLockEvent returned bmode==zero", 0); 
                }
            #else
                result = TRUE;
            #endif

        }
        else {
            DBGMSG("ConvertDistributedLockEx failed", dlmStat); 
            DBGMSG("drive->dlmLockHandle == ", (ULONG_PTR)session->sessionDlmLockHandle); 
        }
    }
    #elif DRIVEARB_ARBITER = DRIVEARB_ARBITER_HACK
        BUGBUG FINISH
    #endif

    // DBGMSG("< AcquireNodeLevelOwnership", result); 

    return result;
}


/*
 *  ReleaseNodeLevelOwnership
 *
 *      Must be called with drive mutex held.
 *
 */
VOID ReleaseNodeLevelOwnership(clientSessionContext *session)
{

    // DBGMSG("> ReleaseNodeLevelOwnership", 0); 

    #if DRIVEARB_ARBITER == DRIVEARB_ARBITER_DLM
    {
        int dlmStat;


        dlmStat = ConvertDistributedLock( session->sessionDlmLockHandle, 
                                          DLM_MODE_NL);
        ASSERT(dlmStat == DLM_ERROR_SUCCESS);
    }
    #elif DRIVEARB_ARBITER = DRIVEARB_ARBITER_HACK
        BUGBUG FINISH
    #endif

    // DBGMSG("< ReleaseNodeLevelOwnership", 0); 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\filemap.c ===
/*
 *  FILEMAP.C
 *
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */

#include <stdlib.h>
#include <wtypes.h>

#include <dlmhdr.h>  // BUGBUG - get a common DLM header from Cluster team

#include <drivearb.h>
#include "internal.h"


/* 
 *  InitDrivesFileMappingForProcess
 *
 *      Either create or open the drives fileMapping for this process.
 *      Then map a process-local view to it.
 */
BOOL InitDrivesFileMappingForProcess()
{
    BOOL result = FALSE;

    /*
     *  See if the global drives fileMapping has already
     *  been created for some other process by trying to open it.  
     *  If not, allocate it.
     */
    g_allDrivesFileMap = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, DRIVES_FILEMAP_NAME);
    if (!g_allDrivesFileMap){
        g_allDrivesFileMap = 
            CreateFileMapping(
                INVALID_HANDLE_VALUE, // map a portion of the paging file
                NULL, // BUGBUG  security  
                PAGE_READWRITE, 
                0,      
                DRIVES_FILEMAP_INITIAL_SIZE*sizeof(driveContext),   
                DRIVES_FILEMAP_NAME);
    }

    if (g_allDrivesFileMap){
        g_allDrivesViewPtr = MapViewOfFile(
                            g_allDrivesFileMap,
                            FILE_MAP_ALL_ACCESS, 
                            0, 0, 0);
        if (g_allDrivesViewPtr){
            g_numDrivesInFileMap = DRIVES_FILEMAP_INITIAL_SIZE;
            result = TRUE;
        }
        else {
            ASSERT(g_allDrivesViewPtr);
        }
    }
    else {
        ASSERT(g_allDrivesFileMap);
    }

    return result;
}


/* 
 *  DestroyDrivesFileMappingForProcess
 *
 */
VOID DestroyDrivesFileMappingForProcess()
{
    if (g_allDrivesViewPtr){
        UnmapViewOfFile(g_allDrivesViewPtr);
        g_allDrivesViewPtr = NULL;
    }

    if (g_allDrivesFileMap){
        CloseHandle(g_allDrivesFileMap);
        g_allDrivesFileMap = NULL;
    }
}

/* 
 *  GrowDrivesFileMapping
 *
 *      Must be called with globalMutex held.
 *      Should only be called in the service context, not by a client.
 */
BOOL GrowDrivesFileMapping(DWORD newNumDrives)
{
    BOOL result = FALSE;

    if (newNumDrives > g_numDrivesInFileMap){
        HANDLE hNewFileMap;
        driveContext *newAllDrivesViewPtr;
        driveContext *drive;
        DWORD driveIndex;

        /*
         *  Lock down every drive.
         *  We have to do this since the common codepaths 
         *  (e.g. drive AcquireDrive/ReleaseDrive)
         *  don't contend for the global mutex.
         */
        for (driveIndex = 0; driveIndex < g_numDrivesInFileMap; driveIndex++){
            drive = &g_allDrivesViewPtr[driveIndex];
            WaitForSingleObject(drive->mutex, INFINITE);
        }

        /*
         *  Try to create the new, resized file map.
         */
        hNewFileMap = CreateFileMapping(
                        INVALID_HANDLE_VALUE, // map a portion of the paging file
                        NULL, // BUGBUG  security  
                        PAGE_READWRITE, 
                        0,      
                        newNumDrives*sizeof(driveContext),   
                        DRIVES_FILEMAP_NAME);
        if (hNewFileMap){

            newAllDrivesViewPtr = MapViewOfFile(    hNewFileMap, 
                                                    FILE_MAP_ALL_ACCESS, 
                                                    0, 0, 0);
            if (newAllDrivesViewPtr){
                RtlZeroMemory(newAllDrivesViewPtr, newNumDrives*sizeof(driveContext));

                /*
                 *  Copy the existing drive contexts to the new filemap.
                 *  The drive mutex and event handles remain valid as
                 *  they're copied over.
                 */
                RtlCopyMemory(  newAllDrivesViewPtr, 
                                g_allDrivesViewPtr, 
                                g_numDrivesInFileMap*sizeof(driveContext));

                /*
                 *  Mark each drive in the old fileMap as reallocated 
                 *  so sessions know to refresh their handles.
                 *  (the old fileMap will stay in memory until each 
                 *   session closes its old handle)
                 */
                for (driveIndex = 0; driveIndex < g_numDrivesInFileMap; driveIndex++){
                    drive = &g_allDrivesViewPtr[driveIndex];
                    drive->isReallocated = TRUE;
                }

                result = TRUE;
            }
            else {
                DBGMSG("GrowDrivesFileMapping: MapViewOfFile failed", 0); 
                CloseHandle(hNewFileMap);
                hNewFileMap = NULL;
            }
        }
        else {
            DBGMSG("GrowDrivesFileMapping: CreateFileMapping failed", 0); 
            newAllDrivesViewPtr = NULL;
        }

        /*
         *  Unlock all drives 
         */
        for (driveIndex = g_numDrivesInFileMap; driveIndex > 0 ; driveIndex--){
            drive = &g_allDrivesViewPtr[driveIndex-1];
            ReleaseMutex(drive->mutex);
        }

        if (result){
            /*
             *  Delete the old filemap.
             *  The filemap will actually continue to exist until
             *  all client session handles are removed.
             */
            UnmapViewOfFile(g_allDrivesViewPtr);
            CloseHandle(g_allDrivesFileMap);

            /*
             *  Set globals to reflect new filemap
             */
            g_allDrivesFileMap = hNewFileMap;
            g_allDrivesViewPtr = newAllDrivesViewPtr;
            g_numDrivesInFileMap = newNumDrives;
        }
    }
    else {
        ASSERT(newNumDrives > g_numDrivesInFileMap);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\drive.c ===
/*
 *  DRIVE.C
 *
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */

#include <stdlib.h>
#include <wtypes.h>

#include <dlmhdr.h>  // BUGBUG - get a common DLM header from Cluster team

#include <drivearb.h>
#include "internal.h"


/*
 *  NewDriveContext
 *
 *      Must be called with globalMutex held.
 *      Should only be called in the service context, not by a client.
 *
 */
driveContext *NewDriveContext(LPSTR driveName)
{
    driveContext *drive = NULL;
    DWORD driveIndex;

    /*
     *  Find an available drive context
     *
     *  BUGBUG - make this more efficient; e.g. use a free list
     */
    for (driveIndex = 0; driveIndex < g_numDrivesInFileMap; driveIndex++){
        driveContext *d = &g_allDrivesViewPtr[driveIndex];
        if (d->state == DRIVESTATE_NONE){
            drive = d;
            break;
        }
    }

    if (drive){
        char driveMutexName[sizeof(DRIVE_MUTEX_NAME_PREFIX)+8];

        drive->sig = DRIVEARB_SIG;

        wsprintf(driveMutexName, "%s%08x", DRIVE_MUTEX_NAME_PREFIX, driveIndex);
        drive->mutex = CreateMutex(NULL, FALSE, (LPSTR)driveMutexName);
        if (drive->mutex){
            char driveEventName[sizeof(DRIVE_EVENT_NAME_PREFIX)+8];

            wsprintf(driveEventName, "%s%08x", DRIVE_EVENT_NAME_PREFIX, driveIndex);
            drive->event = CreateEvent(NULL, FALSE, FALSE, (LPSTR)driveEventName);
            if (drive->event){

                drive->state = DRIVESTATE_UNAVAILABLE_LOCALLY;

                MyStrNCpy(drive->driveName, driveName, MAX_PATH);

                // DBGMSG("NewDriveContext created drive:", driveIndex); 
                // DBGMSG(drive->driveName, 0); 
            }
            else {
                CloseHandle(drive->mutex);
                drive = NULL;
            }
        }
        else {
            drive = NULL;
        }
    }
    else {
        /*
         *  No more free drive contexts in the current fileMap.
         *  So grow the fileMap and try again.
         */
        BOOL ok = GrowDrivesFileMapping(g_numDrivesInFileMap*2);
        if (ok){
            drive = NewDriveContext(driveName);
        }
    }

    return drive;
}


/*
 *  FreeDriveContext
 *
 *      Must be called with globalMutex held.
 *      Should only be called in the service context, not by a client.
 *
 */
VOID FreeDriveContext(driveContext *drive)
{
    CloseHandle(drive->mutex);
    CloseHandle(drive->event);
    drive->state = DRIVESTATE_NONE;
}


/*
 *  GetDriveIndexByName
 *
 *      Must be called with globalMutex held.
 *
 *      Return drive index if it exists; else return -1.
 */
DWORD GetDriveIndexByName(LPSTR driveName)
{
    HANDLE hDrivesFileMap;
    DWORD driveIndex = -1;

    /*
     *  Create a temporary read-only mapping of the entire drives array
     *  so we can look for the drive.
     */
    hDrivesFileMap = OpenFileMapping(FILE_MAP_READ, FALSE, DRIVES_FILEMAP_NAME);
    if (hDrivesFileMap){

        driveContext *allDrivesViewPtr = MapViewOfFile(hDrivesFileMap, FILE_MAP_READ, 0, 0, 0);
        if (allDrivesViewPtr){
            DWORD i;

            for (i = 0; i < g_numDrivesInFileMap; i++){
                driveContext *d = &allDrivesViewPtr[i];

                if ((d->state != DRIVESTATE_NONE) &&
                    MyCompareStringsI(d->driveName, driveName)){

                    driveIndex = i;
                    break;
                }
            }

            UnmapViewOfFile(allDrivesViewPtr);
        }
        else {
            ASSERT(allDrivesViewPtr);
        }

        CloseHandle(hDrivesFileMap);
    }
    else {
        ASSERT(hDrivesFileMap);
    }

    ASSERT(driveIndex != -1);
    return driveIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\service.c ===
/*
 *  SERVICE.C
 *
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <dlmhdr.h>  // BUGBUG - get a common DLM header from Cluster team

#include <drivearb.h>
#include "internal.h"



HANDLE __stdcall RegisterSharedDrive(LPSTR driveName)
{
    driveContext *drive;

    WaitForSingleObject(g_hSharedGlobalMutex, INFINITE);

    drive = NewDriveContext(driveName);
    if (drive){

        drive->state = DRIVESTATE_UNAVAILABLE_LOCALLY;
    }

    ReleaseMutex(g_hSharedGlobalMutex);

    return (HANDLE)drive;
}


BOOL __stdcall UnRegisterSharedDrive(HANDLE hDrive)
{
    driveContext *drive = (driveContext *)hDrive;
    BOOL ok = FALSE;


    WaitForSingleObject(g_hSharedGlobalMutex, INFINITE);

    if (drive->sig == DRIVEARB_SIG){   // sanity check
        if (drive->sessionReferenceCount == 0){
            FreeDriveContext(drive);    
            ok = TRUE;
        }
        else {
            // BUGBUG FINISH - forcefully invalidate handles, etc.
            ASSERT(drive->sessionReferenceCount == 0);
        }
    }
    else {
        ASSERT(drive->sig == DRIVEARB_SIG);
    }

    ReleaseMutex(g_hSharedGlobalMutex);

    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\drivearb.c ===
/*
 *  DRIVEARB.C
 *
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */

#include <windows.h>
#include <stdlib.h>
#include <wtypes.h>

#include <dlmhdr.h>  // BUGBUG - get a common DLM header from Cluster team

#include <drivearb.h>
#include "internal.h"


/*
 *  SHARED DATA Section
 *
 *      Note:   in order for global data items to be placed
 *              in a non-default section, they must be
 *              explicitly initialized!
 */
#pragma data_seg("DRIVEARB_SharedDataSection")
    DWORD g_initializingGlobals = 0;
    DWORD g_numDrivesInFileMap = 0;
#pragma data_seg()
#pragma comment(linker, "/section:DRIVEARB_SharedDataSection,rws")



/*
 *  These are the process-local handles to the inter-process SHARED global:
 *      mutex
 *      fileMapping for the drives array
 *      view pointer into that fileMapping
 */
HANDLE g_hSharedGlobalMutex = NULL;
HANDLE g_allDrivesFileMap = NULL;
driveContext *g_allDrivesViewPtr = NULL;


STDAPI_(BOOL) DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
	BOOL result = FALSE;

	switch (dwReason){

        case DLL_PROCESS_ATTACH:
            /*
             *  DllMain calls are synchronized on a per-process basis,
             *  but not between processes, so we need some synchronization
             *  here while creating our globalMutex handle.
             *  Since we don't even have our global mutex yet, 
             *  use InterlockedIncrement on a shared-data counter here 
             *  to synchronize multiple DLL_PROCESS_ATTACH calls.
             */
            while (InterlockedIncrement(&g_initializingGlobals) != 1){ 
                InterlockedDecrement(&g_initializingGlobals);
                Sleep(1);
            }

            /*
             *  See if the global mutex is already allocated 
             *  for some other process by trying to open it.  
             *  If not, allocate it.
             */
            g_hSharedGlobalMutex = OpenMutex(SYNCHRONIZE, FALSE, GLOBAL_MUTEX_NAME);
            if (!g_hSharedGlobalMutex){
                g_hSharedGlobalMutex = CreateMutex(NULL, FALSE, GLOBAL_MUTEX_NAME);
            }

            if (g_hSharedGlobalMutex){
                result = InitDrivesFileMappingForProcess();
            }

            InterlockedDecrement(&g_initializingGlobals);

            break;

        case DLL_PROCESS_DETACH:

            /*
             *  Don't need to synchronize with other processes here
             *  because we're only closing our process-local handles.
             */

            DestroyDrivesFileMappingForProcess();

            if (g_hSharedGlobalMutex){
                CloseHandle(g_hSharedGlobalMutex);
                g_hSharedGlobalMutex = NULL;
            }

            result = TRUE;
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
		default: 
            result = TRUE;
			break;
	}

	return result;
}




HANDLE __stdcall OpenDriveSession(LPSTR driveName, INVALIDATE_DRIVE_HANDLE_PROC invalidateHandleProc)
{
    clientSessionContext *session;

    if (lstrlen(driveName) > 0){

        if (invalidateHandleProc){

            session = NewClientSession(driveName);
            if (session){
                BOOL ok;

                WaitForSingleObject(g_hSharedGlobalMutex, INFINITE);
                
                ok = InitializeClientArbitration(session);
                if (ok){
                    session->driveViewPtr->sessionReferenceCount++;
                }

                ReleaseMutex(g_hSharedGlobalMutex);

                if (!ok){
                    FreeClientSession(session);
                    session = NULL;
                }
            }
            else {
                ASSERT(session);
            }
        }
        else {
            ASSERT(invalidateHandleProc);
            session = NULL;
        }
    }
    else {
        ASSERT(lstrlen(driveName) > 0);
        session = NULL;
    }

    return (HANDLE)session;
}


VOID __stdcall CloseDriveSession(HANDLE hSession)
{
    clientSessionContext *session = (clientSessionContext *)hSession;

    if (session->sig == DRIVEARB_SIG){   // sanity check

        WaitForSingleObject(g_hSharedGlobalMutex, INFINITE);

        /*
         *  Need to lock drive to make sure driveViewPtr is valid.
         */
        if (LOCKDriveForSession(session)){

            ASSERT(session->driveViewPtr->sessionReferenceCount > 0);
            session->driveViewPtr->sessionReferenceCount--;

            UNLOCKDriveForSession(session);
        }

        ShutDownClientArbitration(session);

        ReleaseMutex(g_hSharedGlobalMutex);

        FreeClientSession(session);
    }
    else {
        ASSERT(session->sig == DRIVEARB_SIG);
    }


}


BOOL __stdcall AcquireDrive(HANDLE hDriveSession, DWORD flags)
{
    clientSessionContext *session = (clientSessionContext *)hDriveSession;
    BOOL result = FALSE;

    if (session->sig == DRIVEARB_SIG){      // sanity check

        if (LOCKDriveForSession(session)){
            driveContext *drive = session->driveViewPtr;
            BOOL gotAppOwnership = FALSE;
            BOOL unlockedAbort = FALSE;

            if (drive->state == DRIVESTATE_UNAVAILABLE_LOCALLY){
                /*
                 *  Attempt to get ownership of the drive
                 *  for this node synchronously.
                 *  This should not fail.
                 *
                 *  BUGBUG - need to implement DRIVEARB_NOWAIT flag in arbiter, too
                 */
                BOOL gotNodeOwnership;
                gotNodeOwnership = AcquireNodeLevelOwnership(session);
                if (gotNodeOwnership){
                    drive->state = DRIVESTATE_AVAILABLE_LOCALLY;
                }
                else {
                    ASSERT(gotNodeOwnership);
                }
            }

            if (drive->state == DRIVESTATE_AVAILABLE_LOCALLY){
                gotAppOwnership = TRUE;
            }
            else if (drive->state == DRIVESTATE_INUSE_LOCALLY){

                /*
                 *  The drive is owned by the local node,
                 *  but some other app is using it.  
                 *  Wait to get ownership by the calling app.
                 */
                while (TRUE){
                    BOOL availableNow;

                    if (drive->state == DRIVESTATE_UNAVAILABLE_LOCALLY){
                        /*
                         *  This is not possible now, but may become possible
                         *  if we implement some sort of fairness (such that
                         *  we may release node-level ownership in ReleaseDrive
                         *  even though local clients are waiting).
                         */
                        availableNow = FALSE;
                    }
                    else if (drive->state == DRIVESTATE_AVAILABLE_LOCALLY){
                        availableNow = TRUE;
                    }
                    else if ((flags & DRIVEARB_REQUEST_READ) && drive->denyRead){
                        availableNow = FALSE;
                    }
                    else if ((flags & DRIVEARB_REQUEST_WRITE) && drive->denyWrite){
                        availableNow = FALSE;
                    }
                    else if ((drive->numCurrentReaders > 0) &&
                             !(flags & DRIVEARB_INTRANODE_SHARE_READ)){
                        availableNow = FALSE;
                    }
                    else if ((drive->numCurrentWriters > 0) &&
                             !(flags & DRIVEARB_INTRANODE_SHARE_WRITE)){
                        availableNow = FALSE;
                    }
                    else {
                        availableNow = TRUE;
                    }

                    if (availableNow){
                        gotAppOwnership = TRUE;
                        break;
                    }
                    else if (flags & DRIVEARB_NOWAIT){
                        break;
                    }
                    else {
                        /*
                         *  We need to wait for the drive to become available.
                         */
                        DWORD waitRes;

                        // DBGMSG("AcquireDrive waiting ...", (ULONG_PTR)session->sessionDriveEvent); 

                        session->state = CLIENTSTATE_WAITING;
                        drive->numWaitingSessions++;

                        /*
                         *  Unlock the drive while waiting for the event.
                         */
                        UNLOCKDriveForSession(session);

                        waitRes = WaitForSingleObject(session->sessionDriveEvent, INFINITE);

                        // DBGMSG(" ... AcquireDrive done waiting.", waitRes); 
                        if (waitRes == WAIT_FAILED){
                            DWORD errCode = GetLastError();
                            DBGMSG("WaitForSingleObject failed with:", errCode); 
                        }

                        if (LOCKDriveForSession(session)){
                            drive->numWaitingSessions--;
                        }
                        else {
                            /*
                             *  Couldn't re-lock, abort.
                             *
                             *  BUGBUG - numWaitingSessions is wrong now, 
                             *           but can't correct it because can't lock the drive
                             */
                            unlockedAbort = TRUE;
                            break;
                        }

                    }

                }
            }

            if (gotAppOwnership){

                drive->state = DRIVESTATE_INUSE_LOCALLY;

                if (flags & DRIVEARB_REQUEST_READ){
                    drive->numCurrentReaders++;
                }
                if (flags & DRIVEARB_REQUEST_WRITE){
                    drive->numCurrentWriters++;
                }

                if (!(flags & DRIVEARB_INTRANODE_SHARE_READ)){
                    drive->denyRead = TRUE;
                }
                if (!(flags & DRIVEARB_INTRANODE_SHARE_WRITE)){
                    drive->denyWrite = TRUE;
                }

                session->shareFlags = flags;
                session->state = CLIENTSTATE_ACTIVE;

                result = TRUE;
            }

            if (!unlockedAbort){
                UNLOCKDriveForSession(session);
            }
        }

    }
    else {
        ASSERT(session->sig == DRIVEARB_SIG);
    }

    return result;
}


VOID __stdcall ReleaseDrive(HANDLE hDriveSession)
{
    clientSessionContext *session = (clientSessionContext *)hDriveSession;

    // DBGMSG("> ReleaseDrive", 0); 

    if (session->sig == DRIVEARB_SIG){      // sanity check
        driveContext *drive;

        if (LOCKDriveForSession(session)){
            BOOL eventSetOk;

            drive = session->driveViewPtr;

            if (session->shareFlags & DRIVEARB_REQUEST_READ){
                ASSERT(drive->numCurrentReaders > 0);
                drive->numCurrentReaders--;
            }
            if (session->shareFlags & DRIVEARB_REQUEST_WRITE){
                ASSERT(drive->numCurrentWriters > 0);
                drive->numCurrentWriters--;
            }

            if (!(session->shareFlags & DRIVEARB_INTRANODE_SHARE_READ)){
                ASSERT(drive->denyRead);
                drive->denyRead = FALSE;
            }
            if (!(session->shareFlags & DRIVEARB_INTRANODE_SHARE_WRITE)){
                ASSERT(drive->denyWrite);
                drive->denyWrite = FALSE;
            }

            session->state = CLIENTSTATE_INACTIVE;

            /*
             *  Only release the drive to other machines if there are 
             *  no clients waiting for it on this machine.
             * 
             *  BUGBUG - implement some fairness to apps on other nodes
             */
            ASSERT(drive->state == DRIVESTATE_INUSE_LOCALLY);
            if (drive->numWaitingSessions == 0){
                ReleaseNodeLevelOwnership(session);
                drive->state = DRIVESTATE_UNAVAILABLE_LOCALLY;
            }
            else {
                drive->state = DRIVESTATE_AVAILABLE_LOCALLY;
            }

            UNLOCKDriveForSession(session);

            // DBGMSG("ReleaseDrive setting event:", (ULONG_PTR)session->sessionDriveEvent); 
            eventSetOk = PulseEvent(session->sessionDriveEvent);
            if (!eventSetOk){
                DWORD errCode = GetLastError();
                DBGMSG("PulseEvent failed with:", errCode);
            }
        }

    }
    else {
        ASSERT(session->sig == DRIVEARB_SIG);
    }

    // DBGMSG("< ReleaseDrive", 0); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\internal.h ===
/*
 *  INTERNAL.H
 *
 *      Internal header
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */


#define DRIVEARB_SIG 'AvrD'

enum driveStates {
    
                /*
                 *  Note:  this value designates that the driveContext block 
                 *         within the file mapping is FREE
                 */
                DRIVESTATE_NONE = 0,

                // local node owns drive and no app is using it
                DRIVESTATE_AVAILABLE_LOCALLY,

                // local node owns drive and some local app is using it
                DRIVESTATE_INUSE_LOCALLY,

                // local node does NOT own the drive
                DRIVESTATE_UNAVAILABLE_LOCALLY,

};

enum clientStates {
    
                CLIENTSTATE_NONE = 0,
                CLIENTSTATE_INACTIVE,   // client session not using nor waiting for drive
                CLIENTSTATE_WAITING,    // client session waiting for drive
                CLIENTSTATE_ACTIVE,     // client session owns the drive
};


/*
 *  This is our internal context for a drive
 */
typedef struct {

                DWORD   sig;

                enum driveStates state;

                DWORD   numCurrentReaders;
                DWORD   numCurrentWriters;

                BOOL    denyRead;
                BOOL    denyWrite;

                /*
                 *  Drive mutex, mapped to by clients' sessionDriveMutex
                 */
                HANDLE mutex;

                /*
                 *  Drive event, mapped to by clients' sessionDriveEvent
                 */
                HANDLE event;

                /*
                 *  The number of open sessions on this drive
                 */
                DWORD sessionReferenceCount;    

                /*
                 *  The number of sessions waiting on this drive
                 */
                DWORD numWaitingSessions;

                /*
                 *  The drives filemap has been reallocated.
                 *  We mark this flag in each driveContext so that
                 *  each session can see it.
                 *  Client needs to reopen a handle to its drive when
                 *  this is set.
                 */
                BOOL isReallocated;


                char driveName[MAX_PATH+1];


                // BUGBUG - pad the end of this struct for alignment

} driveContext;


/*
 *  This is our internal context for a single client session's
 *  use of a particular drive.
 */
typedef struct {

                DWORD sig;

                enum clientStates state;        

                DWORD shareFlags;   

                /*
                 *  This process' local handle for the
                 *  shared drives file mapping.
                 */
                HANDLE hDrivesFileMap;  

                /*
                 *  This process' local pointer for its view
                 *  of its drive's portion of the shared drives file mapping.
                 */
                driveContext *driveViewPtr;

                /*
                 *  Index into the shared drives fileMap of this
                 *  session's drive context
                 */
                DWORD driveIndex;

                /*
                 *  Process-local handles to shared synchronization objects
                 */
                HANDLE sessionDriveMutex;
                HANDLE sessionDriveEvent;

                /*
                 *  Callback to forcibly invalidate the client's handle.
                 *  Used only in case of error.
                 */
                INVALIDATE_DRIVE_HANDLE_PROC invalidateHandleProc;

                /*
                 *  Process-local Distributed Lock Manager handles
                 */
                dlm_nodeid_t sessionDlmHandle;
                dlm_lockid_t sessionDlmLockHandle;

} clientSessionContext;


     
#define DRIVES_FILEMAP_NAME         "DRIVEARB_DrivesFileMap"
#define GLOBAL_MUTEX_NAME           "DRIVEARB_GlobalMutex"
#define DRIVE_MUTEX_NAME_PREFIX     "DRIVEARB_DriveMutex_"
#define DRIVE_EVENT_NAME_PREFIX     "DRIVEARB_DriveEvent_"

#define DRIVES_FILEMAP_INITIAL_SIZE     4


// BUGBUG REMOVE - debug only
#define DBGMSG(msg, arg) \
{ \
     char _dbgMsg[100]; \
     wsprintf(_dbgMsg, "%s: %xh=%d.", msg, (arg), (arg)); \
     MessageBox(NULL, (LPSTR)_dbgMsg, "DriveArb debug message", MB_OK); \
}

#define ASSERT(fact) if (!(fact)){ MessageBox(NULL, (LPSTR)#fact, (LPSTR)"DriveArb assertion failed", MB_OK); }


BOOL InitDrivesFileMappingForProcess();
VOID DestroyDrivesFileMappingForProcess();
BOOL GrowDrivesFileMapping(DWORD newNumDrives);

driveContext *NewDriveContext(LPSTR driveName);
VOID FreeDriveContext(driveContext *drive);
DWORD GetDriveIndexByName(LPSTR driveName);

clientSessionContext *NewClientSession(LPSTR driveName);
VOID FreeClientSession(clientSessionContext *session);
BOOL LOCKDriveForSession(clientSessionContext *session);
VOID UNLOCKDriveForSession(clientSessionContext *session);

BOOL InitializeClientArbitration(clientSessionContext *session);
VOID ShutDownClientArbitration(clientSessionContext *session);

BOOL AcquireNodeLevelOwnership(clientSessionContext *session);
VOID ReleaseNodeLevelOwnership(clientSessionContext *session);

DWORD MyStrNCpy(LPSTR destStr, LPSTR srcStr, DWORD maxChars);
BOOL MyCompareStringsI(LPSTR s, LPSTR p);




extern HANDLE g_hSharedGlobalMutex;
extern HANDLE g_allDrivesFileMap;
extern driveContext *g_allDrivesViewPtr;
extern DWORD g_numDrivesInFileMap;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\util.c ===
/*
 *  UTIL.C
 *
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */

#include <stdlib.h>
#include <wtypes.h>

#include <dlmhdr.h>  // BUGBUG - get a common DLM header from Cluster team

#include <drivearb.h>
#include "internal.h"



DWORD MyStrNCpy(LPSTR destStr, LPSTR srcStr, DWORD maxChars)
{
    DWORD charsCopied = 0;

    while ((maxChars == (DWORD)-1) || maxChars-- > 0){
        *destStr = *srcStr;
        charsCopied++;
        if (*srcStr == '\0'){
            break;
        }
        else {
            destStr++, srcStr++;
        }
    }

    return charsCopied;
}


BOOL MyCompareStringsI(LPSTR s, LPSTR p)
{
    BOOL result;

    while (*s && *p){
        if ((*s|0x20) != (*p|0x20)){
            break;
        }
        else {
            s++, p++;
        }
    }

    // careful, NULL|0x20 == space|0x20 !
    if (!*s && !*p){
        result = TRUE;
    }
    else if (!*s || !*p){
        result = FALSE;
    }
    else if ((*s|0x20) == (*p|0x20)){
        result = TRUE;
    }
    else {
        result = FALSE;
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\dll\session.c ===
/*
 *  SESSION.C
 *
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */

#include <stdlib.h>
#include <wtypes.h>

#include <dlmhdr.h>  // BUGBUG - get a common DLM header from Cluster team

#include <drivearb.h>
#include "internal.h"


clientSessionContext *NewClientSession(LPSTR driveName)
{
	clientSessionContext *session;

	session = (clientSessionContext *)GlobalAlloc(
                                        GMEM_FIXED|GMEM_ZEROINIT, 
                                        sizeof(clientSessionContext));
    if (session){
        BOOL success = FALSE;

        session->sig = DRIVEARB_SIG;


        WaitForSingleObject(g_hSharedGlobalMutex, INFINITE);

        session->driveIndex = GetDriveIndexByName(driveName);
        if (session->driveIndex != -1){

            /*
             *  Map just this one drive context into this process' address space.
             */
            session->hDrivesFileMap = OpenFileMapping(
                                            FILE_MAP_ALL_ACCESS, 
                                            FALSE, 
                                            DRIVES_FILEMAP_NAME); 
            if (session->hDrivesFileMap){

                session->driveViewPtr = MapViewOfFile(  
                                            session->hDrivesFileMap,
                                            FILE_MAP_ALL_ACCESS, 
                                            0, 
                                            session->driveIndex*sizeof(driveContext), 
                                            sizeof(driveContext));
                if (session->driveViewPtr){

                    /*
                     *  Map the drive mutex into this process' address space
                     */
                    char driveMutexName[sizeof(DRIVE_MUTEX_NAME_PREFIX)+8];
                    wsprintf(driveMutexName, "%s%08x", DRIVE_MUTEX_NAME_PREFIX, session->driveIndex);
                    session->sessionDriveMutex = OpenMutex(SYNCHRONIZE, FALSE, (LPSTR)driveMutexName);
                    if (session->sessionDriveMutex){

                        /*
                         *  Map the drive event into this process' address space
                         */
                        char driveEventName[sizeof(DRIVE_EVENT_NAME_PREFIX)+8];
                        wsprintf(driveEventName, "%s%08x", DRIVE_EVENT_NAME_PREFIX, session->driveIndex);
                        session->sessionDriveEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, (LPSTR)driveEventName);
                        if (session->sessionDriveEvent){

                            session->state = CLIENTSTATE_INACTIVE;
                            success = TRUE;
                        }
                        else {
                            ASSERT(session->sessionDriveEvent);
                        }
                    }
                    else {
                        ASSERT(session->sessionDriveMutex);
                    }
                }
                else {
                    ASSERT(session->driveViewPtr);
                }
            }
            else {
                ASSERT(session->hDrivesFileMap);
            }
        }
        else {
            ASSERT(session->driveIndex != -1);
        }

        ReleaseMutex(g_hSharedGlobalMutex);

        if (!success){
            FreeClientSession(session);
            session = NULL;
        }
    }
    else {
        ASSERT(session);
    }

    ASSERT(session);
    return session;
}


VOID FreeClientSession(clientSessionContext *session)
{
    /*
     *  This function is also called for error cases in NewClientSession,
     *  so check each object before freeing it.
     */

    if (session->driveViewPtr){
        UnmapViewOfFile(session->driveViewPtr);
    }
    if (session->hDrivesFileMap){
        CloseHandle(session->hDrivesFileMap);
    }
    if (session->sessionDriveMutex){
        CloseHandle(session->sessionDriveMutex);
    }
    if (session->sessionDriveEvent){
        CloseHandle(session->sessionDriveEvent);
    }

    GlobalFree(session);
}


BOOL LOCKDriveForSession(clientSessionContext *session)
{
    BOOL result;

    WaitForSingleObject(session->sessionDriveMutex, INFINITE);

    if (session->driveViewPtr->isReallocated){
        /*
         *  The drive filemap was reallocated.
         *  Refresh this sessions's filemap.
         */

        UnmapViewOfFile(session->driveViewPtr);
        CloseHandle(session->hDrivesFileMap);

        session->hDrivesFileMap = OpenFileMapping(
                                        FILE_MAP_ALL_ACCESS, 
                                        FALSE, 
                                        DRIVES_FILEMAP_NAME); 
        if (session->hDrivesFileMap){
            session->driveViewPtr = MapViewOfFile(  
                                        session->hDrivesFileMap,
                                        FILE_MAP_READ, 
                                        0, 
                                        session->driveIndex*sizeof(driveContext), 
                                        sizeof(driveContext));
            if (session->driveViewPtr){
                /*
                 *  No need to set isReallocated = FALSE
                 *  since driveViewPtr is now pointing to a fresh context.
                 */
                result = TRUE;
            }
            else {
                ASSERT(session->driveViewPtr);
                CloseHandle(session->hDrivesFileMap);
                session->hDrivesFileMap = NULL;
                result = FALSE;
            }
        }
        else {
            ASSERT(session->hDrivesFileMap);
            session->driveViewPtr = NULL;
            result = FALSE;
        }

        if (!result){
            ReleaseMutex(session->sessionDriveMutex);

            /*
             *  Call the client's invalidateHandleProc callback to let them
             *  know that the session is now invalid.
             *  Must call this with sessionDriveMutex released because
             *  the client will call CloseDriveSession inside this call.
             *  There is no race condition wrt not holding the mutex
             *  because we're still inside a client's call on this session
             *  (client must synchronize calls on a session).
             */
            ASSERT(session->invalidateHandleProc);
            session->invalidateHandleProc(session);
        }
    }
    else {
        result = TRUE;
    }

    return result;
}


VOID UNLOCKDriveForSession(clientSessionContext *session)
{
    ReleaseMutex(session->sessionDriveMutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\inc\dlmhdr.h ===
#ifndef _DLM_H
#define _DLM_H

#define	DLM_VERSION	1
#define DLM_VBLK_SZ     32

typedef	   HANDLE      dlm_lockid_t;
typedef    UCHAR       dlm_nodeid_t;
typedef    CHAR        dlm_mode_t;
typedef    HANDLE      dlm_lockval_t;
typedef    HANDLE      dlm_cevent_t;
typedef    HANDLE      dlm_bevent_t;
typedef    char        dlm_vblk[DLM_VBLK_SZ];
typedef    dlm_vblk   *dlm_vblk_t;

typedef enum {
	DLM_MODE_INVAL     =  	-1,
	DLM_MODE_NL	   =	0,
	DLM_MODE_CR	   =	1,
	DLM_MODE_CW	   =	2,
	DLM_MODE_PR	   =	3,
	DLM_MODE_PW	   =	4,
	DLM_MODE_EX	   =	5
}dlm_mode_type_t;



#define DLM_ERROR_SUCCESS	0
#define DLM_ERROR_GRANTED	0
#define	DLM_ERROR_QUEUED	1
#define	DLM_ERROR_CANCELED	2

#define DLM_ERROR_BADID		11
#define DLM_ERROR_NOMEM		12
#define	DLM_ERROR_BADMODE	13

#define DLM_ERROR_NOOP		15
#define DLM_ERROR_WOULDBLOCK	16
#define DLM_ERROR_INVAL		17
#define DLM_ERROR_INVALOP	18
#define	DLM_ERROR_LOCKWAIT	19
#define	DLM_ERROR_BUSY		20
#define	DLM_ERROR_NOTOWNER	21


// List of DLM supported Flags
#define DLM_FLAGS_FASTLOCK	0x0001	// issue convert without fairness
#define	DLM_FLAGS_TRYLOCK	0x0002	// if can't get it, don't bother
#define	DLM_FLAGS_ASYNC		0x0004	// don't block
#define	DLM_FLAGS_EVBLOCK	0x0008	// register callback/event on this lock

#define	DLM_FLAGS_VBIO		0x0010	// rw value block
#define	DLM_FLAGS_VBIV		0x0020	// invalidate value block


// *** from WDM.H  (apps can't be expected to have this defined) ***
typedef ULONG NTSTATUS;
typedef struct _IO_STATUS_BLOCK {
    union {
       NTSTATUS Status;
       PVOID Pointer;
    };
    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
typedef
VOID
(NTAPI *PIO_APC_ROUTINE) (
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved);
// *****************************************************************




int InitializeDistributedLockManager(dlm_nodeid_t *nodeid);

int InitializeDistributedLock(dlm_lockid_t *lock, dlm_lockid_t parent, char *name, int sz);

int ConvertDistributedLock(dlm_lockid_t lock, dlm_mode_t mode);

int ConvertDistributedLockEx(dlm_lockid_t lock, dlm_mode_t mode, int flags, dlm_vblk_t vblk,
			 PIO_APC_ROUTINE callback, PVOID arg,
			 HANDLE event, PIO_STATUS_BLOCK iostatus);

int QueueDistributedLockEvent(dlm_lockid_t lock, PIO_APC_ROUTINE callback, PVOID arg,
			  HANDLE event, PIO_STATUS_BLOCK iostatus);
int DestroyDistributedLock(dlm_lockid_t lock);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\test\arbtest1\arbtest1.c ===
#include <wtypes.h>
#include <stdio.h>

#include <drivearb.h>


VOID TestInvalidateHandleProc(HANDLE session)
{
    printf("\n ******* TestInvalidateHandleProc CALLED !!!! ******** \n");
}


int __cdecl main()
{
    HANDLE hSession;
    
    hSession = OpenDriveSession("DRIVEARB_disk0", TestInvalidateHandleProc);
    if (hSession){
        BOOL ok;
        DWORD flags = DRIVEARB_REQUEST_READ; // BUGBUG | DRIVEARB_INTRANODE_SHARE_READ;

        ok = AcquireDrive(hSession, flags);
        if (ok){
            char s[20];

            // BUGBUG FINISH
            printf("\n - acquired drive\n");

            printf("\n - holding drive ...");
            gets(s);
            printf("  ... done holding drive \n");

            ReleaseDrive(hSession);
        }
        else {
            printf("\n AcquireDrive failed\n");
        }

        CloseDriveSession(hSession);
    }
    else {
        printf("\n OpenDriveSession failed\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\test\rsmtest\rsmtest.c ===
#define _UNICODE
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <ntmsapi.h>


#define ADD_ACE_MASK_BITS 1
#define REMOVE_ACE_MASK_BITS 2
#define DELETE_ACE 3

NTMS_GUID RsmNullGuid = { 0 };


DbgShowGuid(NTMS_GUID *g)
{
    int i;

    printf("\n { ");
    for (i = 0; i < sizeof(NTMS_GUID); i++){
        printf("%x ", (unsigned int)(((unsigned char *)g)[i]));
    }
    printf("}\n");

}


DWORD SetPoolDACL(  HANDLE hSession, 
                    NTMS_GUID gMediaPool,	
                    DWORD dwSubAuthority, 
			        DWORD dwAction, 
                    DWORD dwMask)
{
	PSID psidAccount;
	PSECURITY_DESCRIPTOR psdRePoolSd;
	SID_IDENTIFIER_AUTHORITY ntauth = SECURITY_NT_AUTHORITY;
	DWORD dwRetCode, dwSizeTry;
	BOOL OK;
	DWORD i, result = ERROR_INVALID_SID;
	ACCESS_ALLOWED_ACE *pAce;


	// Get a SID for the well known, domain-relative account or group
	if (AllocateAndInitializeSid(
						&ntauth,
						2,
						SECURITY_BUILTIN_DOMAIN_RID,
						dwSubAuthority,
						0,
						0,
						0,
						0,
						0,
						0,
						&psidAccount
                        ) == 0){
		result = GetLastError();
    }
    else {

	    // Get the security descriptor for the pool
	    dwSizeTry = 5;
        OK = FALSE;
	    for(;;)
	    {
		    psdRePoolSd = (PSID)malloc(dwSizeTry);
            if (psdRePoolSd){

		        dwRetCode = GetNtmsObjectSecurity(  hSession, 
                                                    &gMediaPool, 
                                                    NTMS_MEDIA_POOL, 
                                                    DACL_SECURITY_INFORMATION, 
			                                        psdRePoolSd, 
                                                    dwSizeTry, 
                                                    &dwSizeTry);
                if (dwRetCode == ERROR_SUCCESS){
                    OK = TRUE;
                    break;
                }
                else {
  			        free(psdRePoolSd);
                    if (dwRetCode == ERROR_INSUFFICIENT_BUFFER){
                        // loop and try again with new buffer size
		            }
                    else {
                        break;
                    }
                }
            }
            else {
                break;
            }
	    }

        if (OK){
    	    PACL paclDis;
    	    BOOL bDaclPresent, bDaclDefaulted;

	        //Get a pointer to the DACL
	        OK = GetSecurityDescriptorDacl(psdRePoolSd, &bDaclPresent, &paclDis, &bDaclDefaulted);

            if (OK){
	            // Go through the DACL and change the mask of the ACE that matches the SID
	            for (i = 0; i < paclDis->AceCount; i++){
		            OK = GetAce(paclDis, i, (LPVOID *)&pAce);
                    if (OK){
                        if (EqualSid(psidAccount, &pAce->SidStart)){
                            printf("\n SetPoolDACL: found SID, current mask = %xh \n", pAce->Mask);
                            if (dwAction == ADD_ACE_MASK_BITS){
				                pAce->Mask |= dwMask;
                                printf("\n SetPoolDACL: added mask bits %xh to create mask %xh \n", dwMask, pAce->Mask);
                            }
                            else if (dwAction == REMOVE_ACE_MASK_BITS){
				                pAce->Mask &= ~dwMask;
                                printf("\n SetPoolDACL: removed mask bits %xh to create mask %xh \n", dwMask, pAce->Mask);
                            }
                            else if (dwAction == DELETE_ACE){
				                DeleteAce(paclDis, i);
                            }
                        }
                    }
	            }

                if (OK){
	                dwRetCode = SetNtmsObjectSecurity(  hSession, 
                                                        &gMediaPool, 
                                                        NTMS_MEDIA_POOL, 
                                                        DACL_SECURITY_INFORMATION, 
			                                            psdRePoolSd);

    	            result = ERROR_SUCCESS;
                }
            }
        }

        FreeSid(psidAccount);
    }

	return result;
}


BOOL SetupMediaPool(HANDLE hSession, NTMS_GUID gMediaPoolId)
{
    DWORD dwStatus;
    BOOL result = FALSE;
  	NTMS_OBJECTINFORMATION oiInfoBuffer;

	oiInfoBuffer.dwSize = sizeof(oiInfoBuffer);
	oiInfoBuffer.dwType = NTMS_MEDIA_POOL;
	dwStatus = GetNtmsObjectInformation(hSession, &gMediaPoolId, &oiInfoBuffer);
    if (dwStatus == ERROR_SUCCESS){

	    oiInfoBuffer.Info.MediaPool.AllocationPolicy =  NTMS_ALLOCATE_FROMSCRATCH;

	    dwStatus = SetNtmsObjectInformation(hSession, &gMediaPoolId, &oiInfoBuffer);
        if (dwStatus == ERROR_SUCCESS){
            DWORD errNum;

	        // Change the permissions on the pool
	        errNum = SetPoolDACL(   hSession, 
                                    gMediaPoolId, 
                                    DOMAIN_ALIAS_RID_USERS, 
		                            REMOVE_ACE_MASK_BITS, 
                                    NTMS_MODIFY_ACCESS | NTMS_CONTROL_ACCESS);
            if (errNum == ERROR_SUCCESS){
                result = TRUE;
            }
            else {
                printf("\n SetupMediaPool: SetPoolDACL failed with %d=%xh.\n", dwStatus, dwStatus);
            }
        }
        else {
            printf("\n SetupMediaPool: SetNtmsObjectInformation failed with %d=%xh.\n", dwStatus, dwStatus);
        }
    }
    else {
        printf("\n SetupMediaPool: GetNtmsObjectInformation failed with %d=%xh.\n", dwStatus, dwStatus);
    }

    return result;
}


BOOL EnumerateObjectType(   HANDLE hSession, 
                            LPNTMS_GUID gContainer, 
				            DWORD dwType, 
                            LPNTMS_GUID *gList, 
                            DWORD *dwCount)
{
	DWORD dwRetCode;
    BOOL result = FALSE;

	// Enumerate the libraries
	*dwCount = 5;
	while (TRUE){

		*gList = (LPNTMS_GUID)malloc((*dwCount)*sizeof(NTMS_GUID));
        if (*gList){
		    dwRetCode = EnumerateNtmsObject(hSession,
			    gContainer,
			    *gList,
			    dwCount,
			    dwType,
			    0);

            if (dwRetCode == ERROR_INSUFFICIENT_BUFFER){
                // retry with new size in *dwCount
			    free(*gList);
                continue;
            }
            else if (dwRetCode == ERROR_SUCCESS){
			    result = TRUE;
                break;
            }
            else {
			    free(*gList);
			    break;;
		    }
        }
        else {
            printf("\n malloc failed \n");
            break;
        }
	}

    return result;
}



// Find the first online library
BOOL MyFindLibrary(HANDLE hSession, NTMS_GUID *gLibID, DWORD *dwRetCode)
{
	DWORD dwSize, i;
	NTMS_GUID *gLibList = NULL;
	NTMS_OBJECTINFORMATION oiLibraryInfo;
    BOOL result = FALSE;

	// Enumerate the libraries
    if (EnumerateObjectType(hSession, NULL, NTMS_LIBRARY, &gLibList, &dwSize)){

	    // Find the first online library 
	    oiLibraryInfo.dwSize = sizeof(oiLibraryInfo);
	    oiLibraryInfo.dwType = NTMS_LIBRARY;
	    for (i = 0; i < dwSize; i++){
            DWORD errCode;

		    errCode = GetNtmsObjectInformation( hSession,
			                                    &gLibList[i],
			                                    &oiLibraryInfo);
            if (errCode == ERROR_SUCCESS){
		        if (oiLibraryInfo.Info.Library.LibraryType == NTMS_LIBRARYTYPE_ONLINE){
		            *gLibID = gLibList[i];
			        result = TRUE;
                    break;
		        }
                else if (oiLibraryInfo.Info.Library.LibraryType == NTMS_LIBRARYTYPE_STANDALONE){
                    /*
                     *  This may be a 'standalone' changer drive or a CD/DVD-ROM drive.
                     *  We only want to deal with it if it's a changer drive.
                     *
                     *      BUGBUG - what's the right check for this ??
                     */
                    if (oiLibraryInfo.Info.Library.LibrarySupportsDriveCleaning){
		                *gLibID = gLibList[i];
			            result = TRUE;
                        break;
                    }
                }
            }
            else {
                printf("\n MyFindLibrary: GetNtmsObjectInformation failed with %xh.\n", errCode);
                break;
            }
	    }

        free(gLibList);
    }
    else {
        printf("\n MyFindLibrary: EnumerateObjectType failed\n");
    }

    *dwRetCode = result ? ERROR_SUCCESS : ERROR_NOT_FOUND;

	return result;
}



BOOL MyFindMediaType(HANDLE hSession, NTMS_GUID *gMediaID, DWORD *dwRetCode)
{
	NTMS_GUID gLibrary;
    BOOL result = FALSE;

	// Get the GUID for the library
    if (MyFindLibrary(hSession, &gLibrary, dwRetCode)){
    	NTMS_GUID *gTypeList = NULL;
    	NTMS_OBJECTINFORMATION oiMediaTypeInfo;
    	DWORD dwSize, i;

	    // Get the list of media type GUIDS in the library
        if (EnumerateObjectType(hSession, &gLibrary, NTMS_MEDIA_TYPE, &gTypeList, &dwSize)){
        
	        // Go through the guid list and find a rewritable media type
	        oiMediaTypeInfo.dwSize = sizeof(oiMediaTypeInfo);
	        oiMediaTypeInfo.dwType = NTMS_MEDIA_TYPE;
	        for (i = 0; i < dwSize; i++){
                DWORD errCode;

		        errCode = GetNtmsObjectInformation( hSession,
			                                        &gTypeList[i],
			                                        &oiMediaTypeInfo);
                if (errCode == ERROR_SUCCESS){

		            if ((oiMediaTypeInfo.Info.MediaType.ReadWriteCharacteristics == NTMS_MEDIARW_REWRITABLE) ||
                        (oiMediaTypeInfo.Info.MediaType.ReadWriteCharacteristics == NTMS_MEDIARW_WRITEONCE) ||
                        (oiMediaTypeInfo.Info.MediaType.ReadWriteCharacteristics == NTMS_MEDIARW_READONLY)){

			            *gMediaID = gTypeList[i];
			            result = TRUE;
                        break;
		            }
                }
                else {
                    printf("\n GetNtmsObjectInformation failed in MyFindMediaType with status %xh.\n", errCode);
                }
	        }

            free(gTypeList);
        }
        else {
            printf("\n MyFindMediaType: EnumerateObjectType failed\n");
        }
    }

    *dwRetCode = result ? ERROR_SUCCESS : ERROR_NOT_FOUND;

	return result;
}


int __cdecl main()
{
    HANDLE hSession;

    hSession = OpenNtmsSession(L"", L"DemoApp", 0); 
    if (hSession == INVALID_HANDLE_VALUE){
        printf("\n OpenNtmsSession failed\n");
    }
    else {
    	NTMS_GUID gMediaType;
        DWORD tmpRet;

        if (MyFindMediaType(hSession, &gMediaType, &tmpRet)){
            NTMS_GUID gMediaPool = RsmNullGuid;
            DWORD dwStatus;

            printf("\n OpenNtmsSession succeeded\n");

            dwStatus = CreateNtmsMediaPool(           
                                            hSession, 
                                            L"API_Sample_Pool", 
                                            &gMediaType, 
                                            NTMS_OPEN_ALWAYS, 
                                            NULL,
                                            &gMediaPool);
            if (dwStatus == ERROR_SUCCESS){

                if (SetupMediaPool(hSession, gMediaPool)){
                    NTMS_GUID gMediaID = RsmNullGuid;
                    DWORD dwTimeout = INFINITE;

                    printf("\n CreateNtmsMediaPool succeeded\n");
                    DbgShowGuid(&gMediaPool);

                    dwStatus = AllocateNtmsMedia(
                                          hSession,       
                                          &gMediaPool,
                                          NULL,     
                                          &gMediaID,  
                                          NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE, // BUGBUG NTMS_ALLOCATE_NEW,     
                                          0, // don't wait
                                          NULL);
                    if (dwStatus == ERROR_SUCCESS){
                        NTMS_GUID gDriveID;

                        printf("\n AllocateNtmsMedia succeeded\n");

                        printf("\n MOUNTING drive ... ");
                        dwStatus = MountNtmsMedia(
                                        hSession,
		                                &gMediaID,
		                                &gDriveID,  // BUGBUG - want specific drive - how to get guid ?
		                                1,
		                                NTMS_MOUNT_ERROR_NOT_AVAILABLE,
		                                NTMS_PRIORITY_NORMAL,
		                                INFINITE,
		                                NULL);
                        if (dwStatus == ERROR_SUCCESS){
	                        NTMS_OBJECTINFORMATION oiDriveInfo;

	                        oiDriveInfo.dwSize = sizeof(oiDriveInfo);
	                        oiDriveInfo.dwType = NTMS_DRIVE;
	                        dwStatus = GetNtmsObjectInformation(
                                            hSession,
		                                    &gDriveID,
		                                    &oiDriveInfo);
                            if (dwStatus == ERROR_SUCCESS){
                                HANDLE hDrive;

                                printf("\n drive name is '%s'\n", oiDriveInfo.Info.Drive.szDeviceName);

	                            hDrive = CreateFile(oiDriveInfo.Info.Drive.szDeviceName,
                                                GENERIC_READ | GENERIC_WRITE,
                                                0,
                                                NULL,
                                                OPEN_EXISTING,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL);
                                if (hDrive == INVALID_HANDLE_VALUE){
                                    int errNum = GetLastError();
                                    printf("\n CreateFile failed with %d=%xh. \n", errNum, errNum);
                                }
                                else {
                                    char s[20];

                                    /*
                                     *  PAUSE until user hits key
                                     */
                                    printf("\n DRIVE '%s' mounted and opened, hit any key to continue ...", oiDriveInfo.Info.Drive.szDeviceName);
                                    gets(s);
                                    printf("  ... closing drive ... \n");

                                    CloseHandle(hDrive);
                                }

                            }
                            else {
                                printf("\n GetNtmsObjectInformation failed with %d=%xh. \n", dwStatus, dwStatus);
                            }

	                        dwStatus = DismountNtmsMedia( 
                                            hSession,
		                                    &gMediaID,
		                                    1,
		                                    0);
                            if (dwStatus == ERROR_SUCCESS){
                                printf("\n DismountNtmsMedia succeeded\n");
                            }
                            else {
                                printf("\n DismountNtmsMedia failed with %d=%xh. \n", dwStatus, dwStatus);
                            }
                        }
                        else {
                            printf("\n MountNtmsMedia failed with %d=%xh. \n", dwStatus, dwStatus);
                        }

                        DeallocateNtmsMedia(    hSession, 
                                                (LPNTMS_GUID)&gMediaID,
                                                0);
                    }
                    else {
                        printf("\n AllocateNtmsMedia failed with %d=%xh. \n", dwStatus, dwStatus);
                    }
                }

                DeleteNtmsMediaPool(hSession, &gMediaPool);
            }
            else {
                printf("\n CreateNtmsMediaPool failed with %d=%xh\n", dwStatus, dwStatus);
            }
        }
        else {
            printf("\n MyFindMediaType failed \n");
        }

        CloseNtmsSession(hSession);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\inc\drivearb.h ===
/*
 *  DRIVEARB.H
 *
 *      External header
 *
 *      DRIVEARB.DLL - Shared Drive Aribiter for shared disks and libraries
 *          - inter-machine sharing client
 *          - inter-app sharing service
 *
 *      Author:  ErvinP
 *
 *      (c) 2000 Microsoft Corporation
 *
 */


/*
 *  AcquireDrive flags
 */
#define DRIVEARB_REQUEST_READ           (1 << 0)
#define DRIVEARB_REQUEST_WRITE          (1 << 1)
#define DRIVEARB_INTRANODE_SHARE_READ   (1 << 2)
#define DRIVEARB_INTRANODE_SHARE_WRITE  (1 << 3)

#define DRIVEARB_NOWAIT                 (1 << 15)



#ifdef __cplusplus
    extern "C"{
#endif

    typedef VOID (CALLBACK* INVALIDATE_DRIVE_HANDLE_PROC)(HANDLE);


    /*
     *  API for drive arbiter SERVICE
     */
    HANDLE  __stdcall RegisterSharedDrive(LPSTR driveName);
    BOOL    __stdcall UnRegisterSharedDrive(HANDLE hDrive);


    /*
     *  API for drive arbiter CLIENT
     */
    HANDLE  __stdcall OpenDriveSession(LPSTR driveName, INVALIDATE_DRIVE_HANDLE_PROC invalidateHandleProc);
    VOID    __stdcall CloseDriveSession(HANDLE hDrive);
    BOOL    __stdcall AcquireDrive(HANDLE hDriveSession, DWORD flags);
    VOID    __stdcall ReleaseDrive(HANDLE hDriveSession);

#ifdef __cplusplus
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\fdc\acpi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1996  Colorado Software Architects

Module Name:

    acpi.c

Abstract:

    This module contains the routines to negotiate with ACPI concerning
    floppy device state.

Environment:

    Kernel mode only.

Revision History:

    09-Oct-1998 module creation

--*/
#include "ntddk.h"
#include "wdmguid.h"
#include "acpiioct.h"

typedef struct _SYNC_ACPI_EXEC_METHOD_CONTEXT {
    NTSTATUS IrpStatus ;
    PACPI_EVAL_OUTPUT_BUFFER cmOutputData ;
    KEVENT Event;
} SYNC_ACPI_EXEC_METHOD_CONTEXT, *PSYNC_ACPI_EXEC_METHOD_CONTEXT ;

typedef VOID ( *PACPI_EXEC_METHOD_COMPLETION_ROUTINE)(
        PDEVICE_OBJECT,
        NTSTATUS,
        PACPI_EVAL_OUTPUT_BUFFER,
        PVOID
        ) ;

typedef struct _ASYNC_ACPI_EXEC_METHOD_CONTEXT {
    PACPI_EXEC_METHOD_COMPLETION_ROUTINE CallerCompletionRoutine;
    PVOID          CallerContext;
    KEVENT         Event;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT TargetDeviceObject;
} ASYNC_ACPI_EXEC_METHOD_CONTEXT, *PASYNC_ACPI_EXEC_METHOD_CONTEXT ;

NTSTATUS
DeviceQueryACPI_AsyncExecMethod (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ControlMethodName,
    IN ULONG ArgumentCount,
    IN PUSHORT ArgumentTypeArray,
    IN PUSHORT ArgumentSizeArray,
    IN PVOID *ArgumentArray,
    IN ULONG ReturnBufferMaxSize,
    IN PACPI_EXEC_METHOD_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    );

NTSTATUS
DeviceQueryACPI_SyncExecMethod (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ControlMethodName,
    IN ULONG ArgumentCount,
    IN PUSHORT ArgumentTypeArray,
    IN PUSHORT ArgumentSizeArray,
    IN PVOID *ArgumentArray,
    IN ULONG ExpectedReturnType,
    IN ULONG ReturnBufferMaxSize,
    OUT PULONG IntegerReturn OPTIONAL,
    OUT PULONG ReturnBufferFinalSize OPTIONAL,
    OUT PVOID *ReturnBuffer OPTIONAL
    );

NTSTATUS
DeviceQueryACPI_AsyncExecMethod_CompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
DeviceQueryACPI_SyncExecMethod_CompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PACPI_EVAL_OUTPUT_BUFFER cmOutputData,
    IN PVOID Context
    );


#ifdef ALLOC_PRAGMA

// Code pages are by default in non-page memory

//#pragma alloc_text(NONPAGE, DeviceQueryACPI_AsyncExecMethod)
//#pragma alloc_text(NONPAGE, DeviceQueryACPI_AsyncExecMethod_CompletionRoutine)
//#pragma alloc_text(NONPAGE, DeviceQueryACPI_SyncExecMethod_CompletionRoutine)
#pragma alloc_text(PAGE,    DeviceQueryACPI_SyncExecMethod)
#endif




NTSTATUS
DeviceQueryACPI_SyncExecMethod (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ControlMethodName,
    IN ULONG ArgumentCount,
    IN PUSHORT ArgumentTypeArray,
    IN PUSHORT ArgumentSizeArray,
    IN PVOID *ArgumentArray,
    IN ULONG ExpectedReturnType,
    IN ULONG ReturnBufferMaxSize,
    OUT PULONG IntegerReturn OPTIONAL,
    OUT PULONG ReturnBufferFinalSize OPTIONAL,
    OUT PVOID *ReturnBuffer OPTIONAL
    )
/*--
        Example usage:

        methodName = (ULONG) 'SMD_' ;

        argCount = 3 ;

        argType[0] = ACPI_METHOD_ARGUMENT_INTEGER ;
        argType[1] = ACPI_METHOD_ARGUMENT_BUFFER ;
        argType[2] = ACPI_METHOD_ARGUMENT_BUFFER ;

        argSize[0] = 0 ; // Don't need to set, assumed to be sizeof(ULONG)
        argSize[1] = sizeof(whatever)
        argSize[2] = sizeof(whatever)

        param = 5 ;
        argData[0] = &param ;
        argData[1] = NULL ; // Assumed to be all zero's.
        argData[2] = pDataBlock ;

        returnBufferMaxSize = 0; //Integer return, no need to set.

        status = DeviceQueryACPI_SyncExecMethod (
                DeviceObject,
                methodName,
                argCount,
                argType,
                argSize,
                argData,
                ACPI_METHOD_ARGUMENT_INTEGER, // We expect an integer returned
                returnBufferMaxSize,
                &result,
                NULL,
                NULL
                ) ;

        if (NT_SUCCESS(status)) {
                // result is valid

                // If we were reading buffers back (ie, expected type is
                // ACPI_METHOD_ARGUMENT_BUFFER or ACPI_METHOD_ARGUMENT_STRING)
                // you must free the buffer if you passed in a pointer for
                // it.
                // N.B. : The buffer is allocated from the paged pool.
        }

    OUT PVOID *ReturnBuffer OPTIONAL
    )

--*/
{
    SYNC_ACPI_EXEC_METHOD_CONTEXT context;
    PACPI_METHOD_ARGUMENT argument;
    NTSTATUS status;

    PAGED_CODE();

    if (ARGUMENT_PRESENT(IntegerReturn)) {
        *IntegerReturn = (ULONG) -1 ;
    }
    if (ARGUMENT_PRESENT(ReturnBufferFinalSize)) {
        *ReturnBufferFinalSize = 0 ;
    }
    if (ARGUMENT_PRESENT(ReturnBuffer)) {
        *ReturnBuffer = NULL ;
    }

    if (ExpectedReturnType == ACPI_METHOD_ARGUMENT_INTEGER) {

        ReturnBufferMaxSize = sizeof(ULONG);
    }

    KeInitializeEvent(&context.Event,
                      NotificationEvent,
                      FALSE);

    context.cmOutputData = NULL;

    status = DeviceQueryACPI_AsyncExecMethod (
                 DeviceObject,
                 ControlMethodName,
                 ArgumentCount,
                 ArgumentTypeArray,
                 ArgumentSizeArray,
                 ArgumentArray,
                 ReturnBufferMaxSize+sizeof(ACPI_METHOD_ARGUMENT)-sizeof(ULONG),
                 DeviceQueryACPI_SyncExecMethod_CompletionRoutine,
                 &context
                 );

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    } else {
       context.IrpStatus = status;
    }

    status = context.IrpStatus ;

    if (!NT_ERROR(status)) {

        argument = context.cmOutputData->Argument ;
        if (ARGUMENT_PRESENT(ReturnBuffer)) {
            *ReturnBufferFinalSize = argument->DataLength ;
        }
    } 

    if (NT_SUCCESS(status)) {
        //
        // This API does not allow for the case where we are returning
        // an array of something...
        //
        // Currently we handle only one arguement. If need be, we can add
        // support for an array of size greater than one in the future
        //
        //
        if (context.cmOutputData->Count != 1) {

            status = STATUS_UNSUCCESSFUL ;
        } else if (ExpectedReturnType != argument->Type) {

            status = STATUS_UNSUCCESSFUL ;
        } else {

            switch(argument->Type) {

                case ACPI_METHOD_ARGUMENT_BUFFER:
                case ACPI_METHOD_ARGUMENT_STRING:
                    if (argument->DataLength == 0) {

                        break ;
                    }

                    if (ARGUMENT_PRESENT(ReturnBuffer)) {

                        *ReturnBuffer = ExAllocatePool(
                            PagedPoolCacheAligned,
                            argument->DataLength
                            ) ;

                        if (*ReturnBuffer == NULL) {

                            status = STATUS_NO_MEMORY ;

                        } else {

                            RtlCopyMemory (
                                *ReturnBuffer,
                                argument->Data,
                                argument->DataLength
                                );
                        }
                    }
                    break ;

                case ACPI_METHOD_ARGUMENT_INTEGER:

                    ASSERT(argument->DataLength == sizeof(ULONG)) ;
                    if (ARGUMENT_PRESENT(IntegerReturn)) {

                        *IntegerReturn = *((PULONG) argument->Data) ;
                    }
                    break ;

                default:
                    status = STATUS_UNSUCCESSFUL ;
                    break ;
            }
        }
    }

    if (context.cmOutputData) {

        ExFreePool(context.cmOutputData) ;
    }
    return status ;
}

NTSTATUS
DeviceQueryACPI_SyncExecMethodForPackage (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ControlMethodName,
    IN ULONG ArgumentCount,
    IN PUSHORT ArgumentTypeArray,
    IN PUSHORT ArgumentSizeArray,
    IN PVOID *ArgumentArray,
    IN ULONG ExpectedElementCount,
    IN ULONG ReturnBufferExpectedSize,
    IN PUSHORT ExpectedTypeArray,
    IN PUSHORT ExpectedSizeArray,
    OUT PVOID *ReturnBuffer
    )
/*

   This function casts the package into a buffer.

*/
{
   SYNC_ACPI_EXEC_METHOD_CONTEXT context;
   PACPI_METHOD_ARGUMENT argument;
   NTSTATUS status;
   ULONG i, argumentSize, totalSize;

   PAGED_CODE();

   *ReturnBuffer = NULL ;

   context.cmOutputData = NULL;
   KeInitializeEvent(&context.Event,
                     NotificationEvent,
                     FALSE);

   status = DeviceQueryACPI_AsyncExecMethod (
                DeviceObject,
                ControlMethodName,
                ArgumentCount,
                ArgumentTypeArray,
                ArgumentSizeArray,
                ArgumentArray,
                (ReturnBufferExpectedSize+
                 ExpectedElementCount*sizeof(ACPI_METHOD_ARGUMENT)-
                 sizeof(ULONG)),
                DeviceQueryACPI_SyncExecMethod_CompletionRoutine,
                &context
                );

   if (status == STATUS_PENDING) {

       KeWaitForSingleObject(&context.Event,
                             Executive,
                             KernelMode,
                             FALSE,
                             NULL);
   } else {
      context.IrpStatus = status;
   }

   status = context.IrpStatus ;

   if (!NT_SUCCESS(status)) {

       goto DeviceQueryACPI_SyncExecMethodForPackageExit;
   }

   if (context.cmOutputData->Count != ExpectedElementCount) {

       status = STATUS_UNSUCCESSFUL ;
       goto DeviceQueryACPI_SyncExecMethodForPackageExit;
   }

   //
   // Tally size
   //

   argument = context.cmOutputData->Argument ;
   totalSize = 0;
   for(i=0; i<ExpectedElementCount; i++) {

       if (argument->Type != ExpectedTypeArray[i]) {

           status = STATUS_UNSUCCESSFUL ;
           goto DeviceQueryACPI_SyncExecMethodForPackageExit;
       }

       switch(argument->Type) {

           case ACPI_METHOD_ARGUMENT_BUFFER:
           case ACPI_METHOD_ARGUMENT_STRING:
               argumentSize = argument->DataLength;
               break ;

           case ACPI_METHOD_ARGUMENT_INTEGER:

               argumentSize = sizeof(ULONG);
               ASSERT(argument->DataLength == sizeof(ULONG)) ;
               break ;

           default:
               status = STATUS_UNSUCCESSFUL ;
               goto DeviceQueryACPI_SyncExecMethodForPackageExit;
       }

       if (argumentSize != ExpectedSizeArray[i]) {

           status = STATUS_UNSUCCESSFUL ;
           goto DeviceQueryACPI_SyncExecMethodForPackageExit;
       }

       argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
       totalSize += argumentSize;
   }

   if (totalSize != ReturnBufferExpectedSize) {

       status = STATUS_UNSUCCESSFUL ;
       goto DeviceQueryACPI_SyncExecMethodForPackageExit;
   }

   *ReturnBuffer = ExAllocatePool(
       PagedPoolCacheAligned,
       totalSize
       ) ;

   if (*ReturnBuffer == NULL) {

       status = STATUS_NO_MEMORY ;
       goto DeviceQueryACPI_SyncExecMethodForPackageExit;
   }

   argument = context.cmOutputData->Argument ;
   totalSize = 0;
   for(i=0; i<ExpectedElementCount; i++) {

       switch(argument->Type) {

           case ACPI_METHOD_ARGUMENT_BUFFER:
           case ACPI_METHOD_ARGUMENT_STRING:

               RtlCopyMemory (
                   ((PUCHAR) (*ReturnBuffer)) + totalSize,
                   argument->Data,
                   argument->DataLength
                   );

               totalSize += argument->DataLength;
               break ;

           case ACPI_METHOD_ARGUMENT_INTEGER:

               RtlCopyMemory(
                   ((PUCHAR) (*ReturnBuffer)) + totalSize,
                   argument->Data,
                   sizeof(ULONG)
                   );

               totalSize += sizeof(ULONG);
               ASSERT(argument->DataLength == sizeof(ULONG)) ;
               break ;

           default:
               status = STATUS_UNSUCCESSFUL ;
               goto DeviceQueryACPI_SyncExecMethodForPackageExit;
       }
       argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
   }

DeviceQueryACPI_SyncExecMethodForPackageExit:

   if (context.cmOutputData) {
       ExFreePool(context.cmOutputData) ;
   }
   return status ;
}

VOID
DeviceQueryACPI_SyncExecMethod_CompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PACPI_EVAL_OUTPUT_BUFFER cmOutputData,
    IN PVOID Context
    )
{
    PSYNC_ACPI_EXEC_METHOD_CONTEXT context = Context;

    context->cmOutputData = cmOutputData ;
    context->IrpStatus = Status;

    KeSetEvent(
        &context->Event,
        EVENT_INCREMENT,
        FALSE
        );

}

NTSTATUS
DeviceQueryACPI_AsyncExecMethod (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ControlMethodName,
    IN ULONG ArgumentCount,
    IN PUSHORT ArgumentTypeArray,
    IN PUSHORT ArgumentSizeArray,
    IN PVOID *ArgumentArray,
    IN ULONG ReturnBufferMaxSize,
    IN PACPI_EXEC_METHOD_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    )
{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT targetDeviceObject;
    PACPI_EVAL_INPUT_BUFFER_COMPLEX cmInputData;
    PACPI_EVAL_OUTPUT_BUFFER cmOutputData ;
    ULONG cmInputDataSize, argumentSize,cmOutputDataSize,i,systemBufferLength;
    PACPI_METHOD_ARGUMENT argument;
    PASYNC_ACPI_EXEC_METHOD_CONTEXT context;
    PIO_STACK_LOCATION irpSp;

    cmInputData = NULL;
    irp = NULL;
    targetDeviceObject = NULL;

    //
    // Set the output buffers size.
    //
    cmOutputDataSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER) -
                       sizeof(ACPI_METHOD_ARGUMENT) +
                       ReturnBufferMaxSize;

    if (cmOutputDataSize < sizeof(ACPI_EVAL_OUTPUT_BUFFER)) {

        cmOutputDataSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER);
    }


    cmOutputData = ExAllocatePool(
                      NonPagedPoolCacheAligned,
                      cmOutputDataSize
                      );

    if (cmOutputData == NULL) {
        status = STATUS_NO_MEMORY;
        goto getout;
    }

    //
    // get the memory we need
    //
    cmInputDataSize = sizeof (ACPI_EVAL_INPUT_BUFFER_COMPLEX) ;
    for(i=0; i<ArgumentCount; i++) {

        switch(ArgumentTypeArray[i]) {

            case ACPI_METHOD_ARGUMENT_BUFFER:
                argumentSize = ACPI_METHOD_ARGUMENT_LENGTH( ArgumentSizeArray[i] );
                break ;

            case ACPI_METHOD_ARGUMENT_STRING:
                argumentSize = ACPI_METHOD_ARGUMENT_LENGTH( ArgumentSizeArray[i] );
                break ;

            case ACPI_METHOD_ARGUMENT_INTEGER:
                argumentSize = ACPI_METHOD_ARGUMENT_LENGTH( sizeof(ULONG) );
                break ;

            default:
                status = STATUS_INVALID_PARAMETER ;
                goto getout;
        }

        cmInputDataSize += argumentSize ;
    }

    //
    // Compute our buffer size
    //
    if (cmInputDataSize > cmOutputDataSize) {
        systemBufferLength = cmInputDataSize;
    } else {
        systemBufferLength = cmOutputDataSize;
    }

    systemBufferLength =
        (ULONG)((systemBufferLength + sizeof(PVOID) - 1) & ~((ULONG_PTR)sizeof(PVOID) - 1));

    cmInputData = ExAllocatePool (
                      NonPagedPoolCacheAligned,
                      systemBufferLength +
                      sizeof (ASYNC_ACPI_EXEC_METHOD_CONTEXT)
                      );

    if (cmInputData == NULL) {
        status = STATUS_NO_MEMORY;
        goto getout;
    }


    RtlZeroMemory (
        cmInputData,
        systemBufferLength +
        sizeof (ASYNC_ACPI_EXEC_METHOD_CONTEXT)
        );

    context = (PASYNC_ACPI_EXEC_METHOD_CONTEXT) (((PUCHAR) cmInputData) + systemBufferLength);
    context->CallerCompletionRoutine = CallerCompletionRoutine;
    context->CallerContext = CallerContext;

    cmInputData->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    cmInputData->MethodNameAsUlong = ControlMethodName ;
    cmInputData->Size = cmInputDataSize;
    cmInputData->ArgumentCount = ArgumentCount ;

    //
    // Setup the arguments...
    //
    argument = cmInputData->Argument;

    for(i=0; i<ArgumentCount; i++) {

        argument->Type = ArgumentTypeArray[i] ;
        argument->DataLength = ArgumentSizeArray[i] ;

        switch(argument->Type) {

            case ACPI_METHOD_ARGUMENT_BUFFER:
            case ACPI_METHOD_ARGUMENT_STRING:
                argumentSize = ArgumentSizeArray[i] ;
                if (ArgumentArray[i]) {

                    RtlCopyMemory (
                        argument->Data,
                        ArgumentArray[i],
                        argumentSize
                        );

                } else {

                    RtlZeroMemory (
                        argument->Data,
                        argumentSize
                        );
                }
                break ;

            case ACPI_METHOD_ARGUMENT_INTEGER:
                argument->Argument = *((PULONG) (ArgumentArray[i]));
                break ;

            default:
                ASSERT(0) ;
        }

        argument = ACPI_METHOD_NEXT_ARGUMENT( argument );
    }

    //
    // get the top of our device stack
    //
    targetDeviceObject = IoGetAttachedDeviceReference(
                             DeviceObject
                             );

    irp = IoAllocateIrp(targetDeviceObject->StackSize, FALSE);
    if (irp == NULL) {
        status = STATUS_NO_MEMORY;
        goto getout;
    }

    irp->AssociatedIrp.SystemBuffer = cmInputData;

    ASSERT ((IOCTL_ACPI_ASYNC_EVAL_METHOD & 0x3) == METHOD_BUFFERED);
    irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = cmOutputDataSize;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = cmInputDataSize;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;

    irp->UserBuffer = cmOutputData ;

    context->DeviceObject       = DeviceObject;
    context->TargetDeviceObject = targetDeviceObject;

    IoSetCompletionRoutine(
        irp,
        DeviceQueryACPI_AsyncExecMethod_CompletionRoutine,
        context,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(targetDeviceObject, irp);

    return STATUS_PENDING;

getout:
    //
    // Clean up
    //
    if (targetDeviceObject) {

        ObDereferenceObject (targetDeviceObject);
    }

    if (!NT_SUCCESS(status)) {
        if (irp) {
            IoFreeIrp(irp);
        }

        if (cmInputData) {
            ExFreePool (cmInputData);
        }

        if (cmOutputData) {
            ExFreePool (cmOutputData);
        }

    }

    //
    // returning
    //
    return status;

} // DeviceQueryACPI_AsyncExecMethod

NTSTATUS
DeviceQueryACPI_AsyncExecMethod_CompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PASYNC_ACPI_EXEC_METHOD_CONTEXT context = Context;
    PACPI_EVAL_OUTPUT_BUFFER cmOutputData = NULL ;

    //
    // Remember, our DeviceObject is NULL because we *initiated* the IRP. We
    // don't even get a valid current stack location!
    //

    if (!NT_ERROR(Irp->IoStatus.Status)) {

        //
        // Copy the information from the system
        // buffer to the caller's buffer.
        //
        RtlCopyMemory(
            Irp->UserBuffer,
            Irp->AssociatedIrp.SystemBuffer,
            Irp->IoStatus.Information
            );

        cmOutputData = Irp->UserBuffer ;
        //
        // should get what we are expecting too...
        //
        ASSERT (
            cmOutputData->Signature ==
            ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE
        );
        if (cmOutputData->Signature !=
            ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {

            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }

    } else {
        ExFreePool (Irp->UserBuffer);
    }

    (*context->CallerCompletionRoutine) (
        context->DeviceObject,
        Irp->IoStatus.Status,
        cmOutputData,
        context->CallerContext
        );

    ObDereferenceObject(context->TargetDeviceObject);

    ExFreePool (Irp->AssociatedIrp.SystemBuffer);
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



/*
ULONG
QueryACPIFtypeChannels(PDEVICE_OBJECT DeviceObject)
{
    NTSTATUS Status;

    ULONG method,result,argCount=1;
    USHORT argType,argSize,argData;

    method = 'GMD_';
    argType=ACPI_METHOD_ARGUMENT_INTEGER;
    argSize = 0;

    argData= 0;

    Status = DeviceQueryACPI_SyncExecMethod (DeviceObject,
                                    method,
                                    argCount,
                                    &argType,
                                    &argSize,
                                    (PVOID *)&argData,
                                    ACPI_METHOD_ARGUMENT_INTEGER,
                                    &result,
                                    NULL,
                                    NULL );

    if (!NT_SUCCESS (Status)) {
        result =0;
    }

    return result;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\drivearb\test\svctest\svctest.c ===
#include <wtypes.h>
#include <stdio.h>

#include <drivearb.h>




int __cdecl main()
{

        HANDLE hDrive;

        hDrive = RegisterSharedDrive("DRIVEARB_disk0");
        if (hDrive){
            char s[20];
            BOOL ok;

            printf("\n - registered  drive\n");

            printf("\n - service started ...");
            gets(s);
            printf("  ... service stopped \n");


            ok = UnRegisterSharedDrive(hDrive);
            if (ok){
                printf("\n ok \n");
            }
            else {
                printf("\n UnRegisterSharedDrive failed\n");
            }
        }
        else {
            printf("\n RegisterSharedDrive failed\n");
        }

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\fdc\fdc_data.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    fdc_data.h

Abstract:

    This file includes data and hardware declarations for the NEC PD765
    (aka AT, ISA, and ix86) and Intel 82077 (aka MIPS) floppy driver for
    NT.

Author:


Environment:

    Kernel mode only.

Notes:


--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// FdcDebug is normally 0.  At compile-time or at run-time, it can be
// set to some bit pattern for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//
#define FDCDBGP              ((ULONG)0x00000001)
#define FDCWARN              ((ULONG)0x00000002)
#define FDCINFO              ((ULONG)0x00000004)
#define FDCSHOW              ((ULONG)0x00000008)
#define FDCIRPPATH           ((ULONG)0x00000010)
#define FDCFORMAT            ((ULONG)0x00000020)
#define FDCSTATUS            ((ULONG)0x00000040)
#define FDCPNP               ((ULONG)0x00000080)
#define FDCPOWER             ((ULONG)0x00000100)

extern ULONG FdcDebugLevel;
#define FdcDump(LEVEL,STRING) \
        do { \
            if (FdcDebugLevel & (LEVEL)) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define FdcDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


//
// Macros to access the controller.  Note that the *_PORT_UCHAR macros
// work on all machines, whether the I/O ports are separate or in
// memory space.
//

#define READ_CONTROLLER( Address )                         \
    READ_PORT_UCHAR( ( PUCHAR )Address )

#define WRITE_CONTROLLER( Address, Value )                 \
    WRITE_PORT_UCHAR( ( PUCHAR )Address, ( UCHAR )Value )


//
// Retry counts -
//
// When moving a byte to/from the FIFO, we sit in a tight loop for a while
// waiting for the controller to become ready.  The number of times through
// the loop is controlled by FIFO_TIGHTLOOP_RETRY_COUNT.  When that count
// expires, we'll wait in 10ms increments.  FIFO_DELAY_RETRY_COUNT controls
// how many times we wait.
//
// The ISR_SENSE_RETRY_COUNT is the maximum number of 1 microsecond
// stalls that the ISR will do waiting for the controller to accept
// a SENSE INTERRUPT command.  We do this because there is a hardware
// quirk in at least the NCR 8 processor machine where it can take
// up to 50 microseconds to accept the command.
//
// When attempting I/O, we may run into many different errors.  The
// hardware retries things 8 times invisibly.  If the hardware reports
// any type of error, we will recalibrate and retry the operation
// up to RECALIBRATE_RETRY_COUNT times.  When this expires, we check to
// see if there's an overrun - if so, the DMA is probably being hogged
// by a higher priority device, so we repeat the earlier loop up to
// OVERRUN_RETRY_COUNT times.
//
// Any packet that is about to be returned with an error caused by an
// unexpected hardware error or state will be restarted from the very
// beginning after resetting the hardware HARDWARE_RESET_RETRY_COUNT
// times.
//

#define FIFO_TIGHTLOOP_RETRY_COUNT         500
#define FIFO_ISR_TIGHTLOOP_RETRY_COUNT     25
#define ISR_SENSE_RETRY_COUNT              50
#define FIFO_DELAY_RETRY_COUNT             5
#define RECALIBRATE_RETRY_COUNT            3
#define OVERRUN_RETRY_COUNT                1
#define HARDWARE_RESET_RETRY_COUNT         2
#define FLOPPY_RESET_ISR_THRESHOLD         20
#define RQM_READY_RETRY_COUNT              100

#define ONE_SECOND                         (10 * 1000 * 1000) // 100ns increments
#define CANCEL_TIMER                       -1
#define START_TIMER                        (IsNEC_98 ? 15 : 9)
#define EXPIRED_TIMER                      0

#define RESET_NOT_RESETTING                 0
#define RESET_DRIVE_RESETTING               1

//
// Need some maximum size values so that we can appropriately set up the DMA
// channels
//

#define MAX_BYTES_PER_SECTOR              (IsNEC_98 ? 1024 : 512)
#define MAX_SECTORS_PER_TRACK             36


//
// Boot Configuration Information
//

//
// Define the maximum number of controllers and floppies per controller
// that this driver will support.
//
// The number of floppies per controller is fixed at 4, since the
// controllers don't have enough bits to select more than that (and
// actually, many controllers will only support 2).  The number of
// controllers per machine is arbitrary; 3 should be more than enough.
//

#define MAXIMUM_CONTROLLERS_PER_MACHINE    3
#define MAXIMUM_DISKETTES_PER_CONTROLLER   4

//
// Floppy register structure.  The base address of the controller is
// passed in by configuration management.  Note that this is the 82077
// structure, which is a superset of the PD765 structure.  Not all of
// the registers are used.
//

typedef union _CONTROLLER {

    struct {
        PUCHAR StatusA;
        PUCHAR StatusB;
        PUCHAR DriveControl;
        PUCHAR Tape;
        PUCHAR Status;
        PUCHAR Fifo;
        PUCHAR Reserved;
        union {
            PUCHAR DataRate;
            PUCHAR DiskChange;
        } DRDC;
        PUCHAR ModeChange;   // for NEC98 : 0xbe
        PUCHAR ModeChangeEx; // for NEC98 : 0x4be
    };

    PUCHAR Address[8];

} CONTROLLER, *PCONTROLLER;

//
//  Io Port address information structure.  This structure is used to save
//  information about ioport addresses as it is collected from a resource
//  requirements list.
//
typedef struct _IO_PORT_INFO {
    LARGE_INTEGER BaseAddress;
    UCHAR Map;
    LIST_ENTRY ListEntry;
} IO_PORT_INFO, *PIO_PORT_INFO;


//
// Parameter fields passed to the CONFIGURE command.
//

#define COMMND_CONFIGURE_IMPLIED_SEEKS     0x40
#define COMMND_CONFIGURE_FIFO_THRESHOLD    0x0F
#define COMMND_CONFIGURE_DISABLE_FIFO      0x20
#define COMMND_CONFIGURE_DISABLE_POLLING   0x10

//
// Write Enable bit for PERPENDICULAR MODE command.
//

#define COMMND_PERPENDICULAR_MODE_OW       0x80

//
// The command table is used by FlIssueCommand() to determine how many
// bytes to get and receive, and whether or not to wait for an interrupt.
// Some commands have extra bits; COMMAND_MASK takes these off.
// FirstResultByte indicates whether the command has a result stage
// or not; if so, it's 1 because the ISR read the 1st byte, and
// NumberOfResultBytes is 1 less than expected.  If not, it's 0 and
// NumberOfResultBytes is 2, since the ISR will have issued a SENSE
// INTERRUPT STATUS command.
//

#define COMMAND_MASK        0x1f
#define FDC_NO_DATA         0x00
#define FDC_READ_DATA       0x01
#define FDC_WRITE_DATA      0x02

typedef struct _COMMAND_TABLE {
    UCHAR   OpCode;
    UCHAR   NumberOfParameters;
    UCHAR   FirstResultByte;
    UCHAR   NumberOfResultBytes;
    BOOLEAN InterruptExpected;
    BOOLEAN AlwaysImplemented;
    UCHAR    DataTransfer;
} COMMAND_TABLE;

//
// Bits in the DRIVE_CONTROL register.
//

#define DRVCTL_RESET                       0x00
#define DRVCTL_ENABLE_CONTROLLER           (IsNEC_98 ? 0x80 : 0x04)
#define DRVCTL_ENABLE_DMA_AND_INTERRUPTS   (IsNEC_98 ? 0x10 : 0x08)
#define DRVCTL_DRIVE_0                     0x10
#define DRVCTL_DRIVE_1                     0x21
#define DRVCTL_DRIVE_2                     0x42
#define DRVCTL_DRIVE_3                     0x83
#define DRVCTL_DRIVE_MASK                  0x03
#define DRVCTL_MOTOR_MASK                  (IsNEC_98 ? 0x08 : 0xf0)
#define DRVCTL_HD_BIT                      0x20 // for NEC98
#define DRVCTL_AI_ENABLE                   0x20 // for NEC98. Indicate AI enable bit.

//
// Bits in the STATUS register.
//

#define STATUS_DRIVE_0_BUSY                0x01
#define STATUS_DRIVE_1_BUSY                0x02
#define STATUS_DRIVE_2_BUSY                0x04
#define STATUS_DRIVE_3_BUSY                0x08
#define STATUS_CONTROLLER_BUSY             0x10
#define STATUS_DMA_UNUSED                  0x20
#define STATUS_DIRECTION_READ              0x40
#define STATUS_DATA_REQUEST                0x80

#define STATUS_IO_READY_MASK               0xc0
#define STATUS_READ_READY                  0xc0
#define STATUS_WRITE_READY                 0x80
#define STATUS_IO_READY_MASK1              0x80 // for NEC98.
#define STATUS_RQM_READY                   0x80 // for NEC98.

//
// Bits in the DATA_RATE register.
//

#define DATART_0125                        0x03
#define DATART_0250                        0x02
#define DATART_0300                        0x01
#define DATART_0500                        0x00
#define DATART_1000                        0x03
#define DATART_RESERVED                    0xfc

//
// Bits in the DISK_CHANGE register.
//

#define DSKCHG_RESERVED                    0x7f
#define DSKCHG_DISKETTE_REMOVED            0x80

//
// Bits in status register 0.
//

#define STREG0_DRIVE_0                     0x00
#define STREG0_DRIVE_1                     0x01
#define STREG0_DRIVE_2                     0x02
#define STREG0_DRIVE_3                     0x03
#define STREG0_HEAD                        0x04
#define STREG0_DRIVE_NOT_READY             0x08
#define STREG0_DRIVE_FAULT                 0x10
#define STREG0_SEEK_COMPLETE               0x20
#define STREG0_END_NORMAL                  0x00
#define STREG0_END_ERROR                   0x40
#define STREG0_END_INVALID_COMMAND         0x80
#define STREG0_END_DRIVE_NOT_READY         0xC0
#define STREG0_END_MASK                    0xC0

//
// Bits in status register 1.
//

#define STREG1_ID_NOT_FOUND                0x01
#define STREG1_WRITE_PROTECTED             0x02
#define STREG1_SECTOR_NOT_FOUND            0x04
#define STREG1_RESERVED1                   0x08
#define STREG1_DATA_OVERRUN                0x10
#define STREG1_CRC_ERROR                   0x20
#define STREG1_RESERVED2                   0x40
#define STREG1_END_OF_DISKETTE             0x80

//
// Bits in status register 2.
//

#define STREG2_SUCCESS                     0x00
#define STREG2_DATA_NOT_FOUND              0x01
#define STREG2_BAD_CYLINDER                0x02
#define STREG2_SCAN_FAIL                   0x04
#define STREG2_SCAN_EQUAL                  0x08
#define STREG2_WRONG_CYLINDER              0x10
#define STREG2_CRC_ERROR                   0x20
#define STREG2_DELETED_DATA                0x40
#define STREG2_RESERVED                    0x80

//
// Bits in status register 3.
//

#define STREG3_DRIVE_0                     0x00
#define STREG3_DRIVE_1                     0x01
#define STREG3_DRIVE_2                     0x02
#define STREG3_DRIVE_3                     0x03
#define STREG3_HEAD                        0x04
#define STREG3_TWO_SIDED                   0x08
#define STREG3_TRACK_0                     0x10
#define STREG3_DRIVE_READY                 0x20
#define STREG3_WRITE_PROTECTED             0x40
#define STREG3_DRIVE_FAULT                 0x80

#define VALID_NEC_FDC                      0x90    // version number
#define NSC_PRIMARY_VERSION                0x70    // National 8477 verion number
#define NSC_MASK                           0xF0    // mask for National version number
#define INTEL_MASK                         0xe0
#define INTEL_44_PIN_VERSION               0x40
#define INTEL_64_PIN_VERSION               0x00

#define DMA_DIR_UNKNOWN    0xff   /* The DMA direction is not currently known */
#define DMA_WRITE          0   /* Program the DMA to write (FDC->DMA->RAM) */
#define DMA_READ           1   /* Program the DMA to read (RAM->DMA->FDC) */

//
//  Strings for PnP Identification.
//
#define FDC_FLOPPY_HARDWARE_IDS              L"FDC\\GENERIC_FLOPPY_DRIVE\0\0"
#define FDC_FLOPPY_HARDWARE_IDS_LENGTH       26 * sizeof(WCHAR)

#define FDC_TAPE_HARDWARE_IDS                L"FDC\\QIC0000\0\0"
#define FDC_TAPE_HARDWARE_IDS_LENGTH         13 * sizeof(WCHAR)

#define FDC_TAPE_GENERIC_HARDWARE_IDS        L"FDC\\QICLEGACY\0\0"
#define FDC_TAPE_GENERIC_HARDWARE_IDS_LENGTH 15 * sizeof(WCHAR)

#define FDC_CONTROLLER_HARDWARE_IDS          L"PNP0700\0*PNP0700\0\0"
#define FDC_CONTROLLER_HARDWARE_IDS_LENGTH   18 * sizeof(WCHAR)

#define FDC_FLOPPY_COMPATIBLE_IDS            L"GenFloppyDisk\0\0"
#define FDC_FLOPPY_COMPATIBLE_IDS_LENGTH     15 * sizeof(WCHAR)

#define FDC_TAPE_COMPATIBLE_IDS              L"QICPNP\0\0"
#define FDC_TAPE_COMPATIBLE_IDS_LENGTH       8 * sizeof(WCHAR)

#define FDC_CONTROLLER_COMPATIBLE_IDS        L"*PNP0700\0\0"
#define FDC_CONTROLLER_COMPATIBLE_IDS_LENGTH 10 * sizeof(WCHAR)



//
// Runtime device structures
//

//
// There is one FDC_EXTENSION attached to the device object of each
// floppy drive.  Only data directly related to that drive (and the media
// in it) is stored here; common data is in CONTROLLER_DATA.  So the
// FDC_EXTENSION has a pointer to the CONTROLLER_DATA.
//

typedef struct _FDC_EXTENSION_HEADER {

    //
    //  A flag to indicate whether this is a FDO or a PDO
    //
    BOOLEAN             IsFDO;

    //
    //  A pointer to our own device object.
    //
    PDEVICE_OBJECT      Self;

} FDC_EXTENSION_HEADER, *PFDC_EXTENSION_HEADER;

typedef enum _FDC_DEVICE_TYPE {

    FloppyControllerDevice,
    FloppyDiskDevice,
    FloppyTapeDevice

} FDC_DEVICE_TYPE;

typedef struct _FDC_PDO_EXTENSION {

    FDC_EXTENSION_HEADER;

    //
    //  A pointer to the FDO that created us.
    //
    PDEVICE_OBJECT  ParentFdo;

    //
    //  The type of device this PDO supports.  Currently disk or tape.
    //
    FDC_DEVICE_TYPE DeviceType;

    SHORT           TapeVendorId;

    //
    //  A flag that indicates whether this PDO is pending removal.
    //
    BOOLEAN         Removed;

    //
    //  This PDO's entry in its parent's list of related PDOs.
    //
    LIST_ENTRY      PdoLink;

    //
    //  The enumerated  number of this specific device, as returned from
    //  IoQueryDeviceDescription.
    //
    ULONG           PeripheralNumber;

    PDEVICE_OBJECT  TargetObject;

    BOOLEAN         ReportedMissing;

} FDC_PDO_EXTENSION, *PFDC_PDO_EXTENSION;

typedef enum _FDC_ACPI_TAPE {

    TapeNotPresent,
    TapePresent,
    TapeDontKnow

} FDC_ACPI_TAPE;

typedef struct _ACPI_FDE_ENUM_TABLE {

    ULONG DrivePresent[4];
    FDC_ACPI_TAPE ACPI_Tape;

} ACPI_FDE_ENUM_TABLE, *PACPI_FDE_ENUM_TABLE;

typedef struct _FDC_FDO_EXTENSION {

    FDC_EXTENSION_HEADER;

    //
    //  A kernel resource for controlling access to the FDC.
    //
    ERESOURCE Resource;
    //
    //  A pointer to the PDO to which this FDO is attached.
    //
    PDEVICE_OBJECT      UnderlyingPDO;

    //
    //  The top of the object stack to which this FDO is attached.
    //
    PDEVICE_OBJECT      TargetObject;

    //
    //  A list and count of PDOs that were created by this FDO.
    //
    BOOLEAN             ACPI_BIOS;
    BOOLEAN             ACPI_FDE_Valid;
    ACPI_FDE_ENUM_TABLE ACPI_FDE_Data;
    BOOLEAN             ProbeFloppyDevices;
    BOOLEAN             FloppyDeviceNotPresent[4];
    LIST_ENTRY          PDOs;
    ULONG               NumPDOs;
    BOOLEAN             Removed;
    ULONG               OutstandingRequests;
    KEVENT              RemoveEvent;
    BOOLEAN             TapeEnumerationPending;
    KEVENT              TapeEnumerationEvent;

    //
    //  Some stuff for power management
    //
    LIST_ENTRY          PowerQueue;
    KSPIN_LOCK          PowerQueueSpinLock;
    KEVENT              PowerEvent;
    DEVICE_POWER_STATE  CurrentPowerState;
    LARGE_INTEGER       LastMotorSettleTime;
    BOOLEAN             WakeUp;
    BOOLEAN             Paused;

    //
    //  The bus number on which this physical device lives.
    //
    INTERFACE_TYPE      BusType;
    ULONG               BusNumber;
    ULONG               ControllerNumber;

    BOOLEAN             DeviceObjectInitialized;
    LARGE_INTEGER       InterruptDelay;
    LARGE_INTEGER       Minimum10msDelay;
    KEVENT              InterruptEvent;
    LONG                InterruptTimer;
    CCHAR               ResettingController;
    KEVENT              AllocateAdapterChannelEvent;
    LONG                AdapterChannelRefCount;
    KEVENT              AcquireEvent;
    KDPC                LogErrorDpc;

    HANDLE              BufferThreadHandle;
    KSPIN_LOCK          BufferThreadSpinLock;
    BOOLEAN             TerminateBufferThread;
    KTIMER              BufferTimer;
    KDPC                BufferTimerDpc;

    PKINTERRUPT         InterruptObject;
    PVOID               MapRegisterBase;
    PADAPTER_OBJECT     AdapterObject;
    PDEVICE_OBJECT      CurrentDeviceObject;
    PDRIVER_OBJECT      DriverObject;
    CONTROLLER          ControllerAddress;
    ULONG               SpanOfControllerAddress;
    ULONG               NumberOfMapRegisters;
    ULONG               BuffersRequested;
    ULONG               BufferCount;
    ULONG               BufferSize;
    PTRANSFER_BUFFER    TransferBuffers;
    ULONG               IsrReentered;
    ULONG               ControllerVector;
    KIRQL               ControllerIrql;
    KINTERRUPT_MODE     InterruptMode;
    KAFFINITY           ProcessorMask;
    UCHAR               FifoBuffer[10];
    BOOLEAN             AllowInterruptProcessing;
    BOOLEAN             SharableVector;
    BOOLEAN             SaveFloatState;
    BOOLEAN             HardwareFailed;
    BOOLEAN             CommandHasResultPhase;
    BOOLEAN             ControllerConfigurable;
    BOOLEAN             MappedControllerAddress;
    BOOLEAN             CurrentInterrupt;
    BOOLEAN             Model30;
    UCHAR               PerpendicularDrives;
    UCHAR               NumberOfDrives;
    UCHAR               DriveControlImage;
    UCHAR               HardwareFailCount;
    BOOLEAN             ControllerInUse;
    UCHAR               FdcType;
    UCHAR               FdcSpeeds;
    PIRP                CurrentIrp;
    UCHAR               DriveOnValue;
    PDEVICE_OBJECT      LastDeviceObject;
    BOOLEAN             Clock48MHz;
    BOOLEAN             FdcEnablerSupported;
    PDEVICE_OBJECT      FdcEnablerDeviceObject;
    PFILE_OBJECT        FdcEnablerFileObject;
    LARGE_INTEGER       FdcFailedTime;
    BOOLEAN             ResetFlag;              // for NEC98
    BOOLEAN             FloppyEquip;            // for NEC98
    UCHAR               MotorRunning;           // for NEC98
    UCHAR               ResultStatus0[4];       // for NEC98

} FDC_FDO_EXTENSION, *PFDC_FDO_EXTENSION;

//
// NEC98: Registory path of MultifunctionAdapter.
//
#define ISA_BUS_NODE \
        L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter\\%d"

//
// Macro
//

//
// Enable/Disable Controller
//

#define DISABLE_CONTROLLER_IMAGE(FdoExtension) \
{ \
    if (IsNEC_98) { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_DMA_AND_INTERRUPTS; \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_CONTROLLER; \
        FdoExtension->ResetFlag          = FALSE; \
    } else { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_DMA_AND_INTERRUPTS; \
        FdoExtension->DriveControlImage &= ~( DRVCTL_ENABLE_CONTROLLER ); \
    } \
}

#define ENABLE_CONTROLLER_IMAGE(FdoExtension) \
{ \
    if (IsNEC_98) { \
        FdoExtension->DriveControlImage &= ~( DRVCTL_ENABLE_CONTROLLER ); \
        FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE; \
    } else { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_CONTROLLER; \
    } \
}

//
// Dma speed
//
#define DEFAULT_DMA_SPEED      (IsNEC_98 ? Compatible : TypeA)

//
// Paging Driver with Mutex
//
#define FDC_PAGE_INITIALIZE_DRIVER_WITH_MUTEX                           \
{                                                                       \
    if (!IsNEC_98) {                                                    \
        PagingMutex = ExAllocatePool(NonPagedPool, sizeof(FAST_MUTEX)); \
        if (!PagingMutex) {                                             \
            return STATUS_INSUFFICIENT_RESOURCES;                       \
        }                                                               \
        ExInitializeFastMutex(PagingMutex);                             \
        MmPageEntireDriver(DriverEntry);                                \
    }                                                                   \
}

#define FDC_PAGE_UNINITIALIZE_DRIVER_WITH_MUTEX \
{                                               \
    if ( !IsNEC_98 ) {                          \
        ExFreePool( PagingMutex );              \
    }                                           \
}

#define FDC_PAGE_RESET_DRIVER_WITH_MUTEX        \
{                                               \
    if (!IsNEC_98) {                            \
        ExAcquireFastMutex( PagingMutex );      \
        if ( ++PagingReferenceCount == 1 ) {    \
            MmResetDriverPaging( DriverEntry ); \
        }                                       \
        ExReleaseFastMutex( PagingMutex );      \
    }                                           \
}

#define FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX       \
{                                               \
    if (!IsNEC_98) {                            \
        ExAcquireFastMutex(PagingMutex);        \
        if (--PagingReferenceCount == 0) {      \
            MmPageEntireDriver(DriverEntry);    \
        }                                       \
        ExReleaseFastMutex(PagingMutex);        \
    }                                           \
}


//
// Prototypes of driver routines.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
FdcUnload(
    IN PDRIVER_OBJECT DriverObject
    );

VOID
FcAllocateCommonBuffers(
    IN PFDC_FDO_EXTENSION FdoExtension
    );

NTSTATUS
FcInitializeControllerHardware(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FdcCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcDeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
FdcInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FdcSystemPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
FdcAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    );

BOOLEAN
FdcInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID
FdcDeferredProcedure(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
FcAcquireFdc(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PLARGE_INTEGER  TimeOut
    );

NTSTATUS
FcReleaseFdc(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FcReportFdcInformation(
    IN      PFDC_PDO_EXTENSION PdoExtension,
    IN      PFDC_FDO_EXTENSION FdcExtension,
    IN OUT  PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FcTurnOnMotor(
    IN      PFDC_FDO_EXTENSION  FdcExtension,
    IN OUT  PFDC_ENABLE_PARMS   FdcEnableParms
    );

NTSTATUS
FcTurnOffMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    );

VOID
FcAllocateAdapterChannel(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FcFreeAdapterChannel(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

IO_ALLOCATION_ACTION
FdcAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

NTSTATUS
FcSendByte(
    IN UCHAR ByteToSend,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    );

NTSTATUS
FcGetByte(
    OUT PUCHAR ByteToGet,
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    );

NTSTATUS
FcIssueCommand(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes
    );

VOID
FcLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
FcClearIsrReentered(
    IN PVOID Context
    );

NTSTATUS
FcGetFdcInformation(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcCheckTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Context
    );

BOOLEAN
FdcTimerSync(
    IN OUT PVOID Context
    );

VOID
FdcStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FcStartCommand(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    );

NTSTATUS
FcFinishCommand(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    );

NTSTATUS
FcFinishReset(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcBufferThread(
    IN PVOID Context
    );

NTSTATUS
FcFdcEnabler(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    );

NTSTATUS
FcSynchronizeQueue(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN PIRP Irp
    );

NTSTATUS
FdcPnpComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
FdcStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcInitializeDeviceObject(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FdcFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcEnumerateAcpiBios(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
FdcCreateFloppyPdo(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN UCHAR PeripheralNumber
    );

NTSTATUS
FdcConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcBusConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcFdoConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcEnumerateQ117(
    IN PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcGetEnablerDevice(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

NTSTATUS
FdcPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
FdcGetControllerBase(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    );

PWCHAR
FdcBuildIdString(
    IN PWCHAR IdString,
    IN USHORT Length
    );

//
// For NEC98
//

NTSTATUS
FdcHdbit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN PSET_HD_BIT_PARMS   SetHdBitParams
    );

ULONG
FdcGet0Seg(
    IN PUCHAR   ConfigrationData1,
    IN ULONG   Offset
    );

ULONG
FdcFindIsaBusNode(
    IN OUT VOID
    );

UCHAR
FdcRqmReadyWait(
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN ULONG               IssueSenseInterrupt
    );

NTSTATUS
FdcTerminateBufferThread(
    IN PFDC_FDO_EXTENSION  FdoExtension
    );

NTSTATUS
FdcProbeFloppyDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR DeviceSelect
    );

NTSTATUS
FdcSystemControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\fdc\fdc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1996  Colorado Software Architects

Module Name:

    fdc.c

Abstract:

    This is the NEC PD756 (aka AT, aka IS1A, aka ix86) and Intel 82077
    (aka MIPS) floppy diskette driver for NT.

Environment:

    Kernel mode only.

Revision History:

    02-Aug-1991 (chads)     Made driver work on MIPS as well as ix86.
    20-Dec-1996 (John Moore - Colorado Software Architects)
                            Split the floppy.sys driver into 2 drivers, this
                            driver (fdc.sys) and the higher level floppy.sys.
                            fdc.sys is a 'port' driver that can be used by
                            either floppy.sys or qic117.sys or any other driver
                            that needs to make use of the floppy controller.

#if defined(DBCS) && defined(_MIPS_)
    N001        1994.07.29      N.Johno

        - Modify for R96(MIPS/R4400)

#endif // defined(DBCS) && defined(_MIPS_)

--*/

//
// Include files.
//

#include "stdio.h"
#include "ntddk.h"
#include "ntdddisk.h"                    // disk device driver I/O control codes
#include "ntddfdc.h"
#include <mountdev.h>

#include "wdmguid.h"
#include "acpiioct.h"

#include <fdc_data.h>                    // this driver's data declarations
#include <flpyenbl.h>
#include <q117_dat.h>

NTSTATUS
DeviceQueryACPI_SyncExecMethod (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ControlMethodName,
    IN ULONG ArgumentCount,
    IN PUSHORT ArgumentTypeArray,
    IN PUSHORT ArgumentSizeArray,
    IN PVOID *ArgumentArray,
    IN ULONG ExpectedReturnType,
    IN ULONG ReturnBufferMaxSize,
    OUT PULONG IntegerReturn OPTIONAL,
    OUT PULONG ReturnBufferFinalSize OPTIONAL,
    OUT PVOID *ReturnBuffer OPTIONAL
    );

NTSTATUS
DeviceQueryACPI_SyncExecMethodForPackage (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG ControlMethodName,
    IN ULONG ArgumentCount,
    IN PUSHORT ArgumentTypeArray,
    IN PUSHORT ArgumentSizeArray,
    IN PVOID *ArgumentArray,
    IN ULONG ExpectedElementCount,
    IN ULONG ReturnBufferExpectedSize,
    IN PUSHORT ExpectedTypeArray,
    IN PUSHORT ExpectedSizeArray,
    OUT PVOID *ReturnBuffer
    );

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) > (b) ? (b) : (a))

COMMAND_TABLE CommandTable[] = {
    { 0x06, 8, 1, 7,  TRUE,  TRUE,  FDC_READ_DATA  },   // Read Data
    { 0x0C, 0, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Not Implemented (MIPS)
    { 0x05, 8, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA },   // Write Data
    { 0x09, 0, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Not Implemented
    { 0x02, 8, 1, 7,  TRUE,  TRUE,  FDC_READ_DATA  },   // Read Track
    { 0x16, 8, 1, 7,  TRUE,  FALSE, FDC_NO_DATA    },   // Verify
    { 0x10, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Version
    { 0x0D, 5, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA },   // Format Track
    { 0x11, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan Equal
    { 0x19, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan Low Or Equal
    { 0x1D, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan High Or Equal
    { 0x07, 1, 0, 2,  TRUE,  TRUE,  FDC_NO_DATA    },   // Recalibrate
    { 0x08, 0, 0, 2,  FALSE, TRUE,  FDC_NO_DATA    },   // Sense Interrupt Status
    { 0x03, 2, 0, 0,  FALSE, TRUE,  FDC_NO_DATA    },   // Specify
    { 0x04, 1, 0, 1,  FALSE, TRUE,  FDC_NO_DATA    },   // Sense Drive Status
    { 0x8E, 6, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Drive Specification Command
    { 0x0F, 2, 0, 2,  TRUE,  TRUE,  FDC_NO_DATA    },   // Seek
    { 0x13, 3, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Configure
    { 0x8F, 2, 0, 2,  TRUE,  FALSE, FDC_NO_DATA    },   // Relative Seek
    { 0x0E, 0, 0, 10, FALSE, FALSE, FDC_NO_DATA    },   // Dumpreg
    { 0x0A, 1, 1, 7,  TRUE,  TRUE,  FDC_NO_DATA    },   // Read ID
    { 0x12, 1, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Perpendicular Mode
    { 0x14, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Lock
    { 0x18, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Part ID
    { 0x17, 1, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Powerdown Mode
    { 0x33, 1, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Option
    { 0x2E, 0, 0, 16, FALSE, FALSE, FDC_NO_DATA    },   // Save
    { 0x4E, 16, 0, 0, FALSE, FALSE, FDC_NO_DATA    },   // Restore
    { 0xAD, 5, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA }    // Format And Write
};

//
// This is the actual definition of FdcDebugLevel.
// Note that it is only defined if this is a "debug"
// build.
//
#if DBG
extern ULONG FdcDebugLevel = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'polF')
#endif

BOOLEAN FdcInSetupMode;
USHORT FdcDefaultControllerNumber = 0;

//
// Used for paging the driver.
//
ULONG PagingReferenceCount = 0;
PFAST_MUTEX PagingMutex = NULL;

ULONG NumberOfBuffers = 0;
ULONG BufferSize = 0;
ULONG Model30 = 0;
ULONG NotConfigurable = 0;
BOOLEAN ProbeFloppyDevices;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  This routine can be called any number of times,
    as long as the IO system and the configuration manager conspire to
    give it an unmanaged controller to support at each call.  It could
    also be called a single time and given all of the controllers at
    once.

    It initializes the passed-in driver object, calls the configuration
    manager to learn about the devices that it is to support, and for
    each controller to be supported it calls a routine to initialize the
    controller (and all drives attached to it).

Arguments:

    DriverObject - a pointer to the object that represents this device
    driver.

Return Value:

    If we successfully initialize at least one drive, STATUS_SUCCESS is
    returned.

    If we don't (because the configuration manager returns an error, or
    the configuration manager says that there are no controllers or
    drives to support, or no controllers or drives can be successfully
    initialized), then the last error encountered is propogated.

--*/

{
    NTSTATUS ntStatus;

    //
    // We use this to query into the registry as to whether we
    // should break at driver entry.
    //
    RTL_QUERY_REGISTRY_TABLE paramTable[7];
    ULONG zero = 0;
    ULONG one = 1;
    ULONG debugLevel = 0;
    ULONG shouldBreak = 0;
    ULONG setupMode;
    PWCHAR path;
    UNICODE_STRING parameters;
    UNICODE_STRING systemPath;
    UNICODE_STRING identifier;
    UNICODE_STRING thinkpad, ps2e;
    ULONG pathLength;

    RtlInitUnicodeString(&parameters, L"\\Parameters");
    RtlInitUnicodeString(&systemPath,
        L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\System");
    RtlInitUnicodeString(&thinkpad, L"IBM THINKPAD 750");
    RtlInitUnicodeString(&ps2e, L"IBM PS2E");

    pathLength = RegistryPath->Length + parameters.Length + sizeof(WCHAR);
    if (pathLength < systemPath.Length + sizeof(WCHAR)) {
        pathLength = systemPath.Length + sizeof(WCHAR);
    }

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //
    NumberOfBuffers = 3;
    BufferSize = 0x8000;

    if (path = ExAllocatePool(PagedPool | POOL_COLD_ALLOCATION, pathLength)) {

        RtlZeroMemory(&paramTable[0],
                      sizeof(paramTable));
        RtlZeroMemory(path, pathLength);
        RtlMoveMemory(path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);

        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"BreakOnEntry";
        paramTable[0].EntryContext = &shouldBreak;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"DebugLevel";
        paramTable[1].EntryContext = &debugLevel;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);
        paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name = L"NumberOfBuffers";
        paramTable[2].EntryContext = &NumberOfBuffers;
        paramTable[2].DefaultType = REG_DWORD;
        paramTable[2].DefaultData = &NumberOfBuffers;
        paramTable[2].DefaultLength = sizeof(ULONG);
        paramTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name = L"BufferSize";
        paramTable[3].EntryContext = &BufferSize;
        paramTable[3].DefaultType = REG_DWORD;
        paramTable[3].DefaultData = &BufferSize;
        paramTable[3].DefaultLength = sizeof(ULONG);
        paramTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[4].Name = L"SetupDone";
        paramTable[4].EntryContext = &setupMode;
        paramTable[4].DefaultType = REG_DWORD;
        paramTable[4].DefaultData = &zero;
        paramTable[4].DefaultLength = sizeof(ULONG);
        paramTable[5].Name = L"ProbeFloppyDevices";
        paramTable[5].EntryContext = &ProbeFloppyDevices;
        paramTable[5].DefaultType = REG_DWORD;
        //
        //  Default for probing is on for checked builds and off for free builds
        //
#if DBG
        paramTable[5].DefaultData = &one;
#else
        paramTable[5].DefaultData = &zero;
#endif
        paramTable[5].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                path,
                                &paramTable[0],
                                NULL,
                                NULL))) {

            shouldBreak = 0;
            debugLevel = 0;

        }

        FdcInSetupMode = !(BOOLEAN)setupMode;

        FdcDump( FDCSHOW, ("FdcDriverEntry: FdcInSetupMode = %x\n",FdcInSetupMode) );

        if ( FdcInSetupMode ) {

            OBJECT_ATTRIBUTES keyAttributes;
            HANDLE keyHandle;
            UNICODE_STRING value;

            RtlInitUnicodeString( &value, L"SetupDone" );
            setupMode = 1;

            InitializeObjectAttributes( &keyAttributes,
                                        RegistryPath,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );

            ntStatus = ZwOpenKey( &keyHandle,
                                  KEY_ALL_ACCESS,
                                  &keyAttributes );

            if ( NT_SUCCESS(ntStatus) ) {

                FdcDump( FDCSHOW, ("FdcDriverEntry: Set SetupMode Value in Registry\n") );

                ZwSetValueKey( keyHandle,
                               &value,
                               0,
                               REG_DWORD,
                               &setupMode,
                               sizeof(ULONG) );

                ZwClose( keyHandle);
            }
        }

        //
        // Determine whether or not this type of system has a
        // model 30 floppy controller.
        //

        RtlZeroMemory(paramTable, sizeof(paramTable));
        RtlZeroMemory(path, pathLength);
        RtlMoveMemory(path,
                      systemPath.Buffer,
                      systemPath.Length);


        RtlZeroMemory(&identifier, sizeof(UNICODE_STRING));
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT |
                              RTL_QUERY_REGISTRY_REQUIRED;
        paramTable[0].Name = L"Identifier";
        paramTable[0].EntryContext = &identifier;

        if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                              path,
                                              paramTable,
                                              NULL,
                                              NULL))) {


            if (identifier.Length == thinkpad.Length &&
                RtlCompareMemory(identifier.Buffer, thinkpad.Buffer,
                                 thinkpad.Length) == thinkpad.Length) {

                Model30 = 1;

            } else if (identifier.Length == ps2e.Length &&
                       RtlCompareMemory(identifier.Buffer, ps2e.Buffer,
                                        ps2e.Length) == ps2e.Length) {

                Model30 = 1;
            } else {
                Model30 = 0;
            }
        } else {
            Model30 = 0;
        }

        //
        // This part gets from the parameters part of the registry
        // to see if the controller configuration needs to be disabled.
        // Doing this lets SMC 661, and 662 work.  On hardware that
        // works normally, this change will show a slowdown of up
        // to 40%.  So defining this variable is not recommended
        // unless things don't work without it.
        //
        //
        // Also check the model30 value in the parameters section
        // that is used to override the decision above.
        //
        RtlZeroMemory( &paramTable[0], sizeof(paramTable) );
        RtlZeroMemory( path, RegistryPath->Length+parameters.Length+sizeof(WCHAR) );
        RtlMoveMemory( path, RegistryPath->Buffer, RegistryPath->Length );
        RtlMoveMemory( (PCHAR) path + RegistryPath->Length,
                       parameters.Buffer,
                       parameters.Length );

        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"NotConfigurable";
        paramTable[0].EntryContext = &NotConfigurable;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"Model30";
        paramTable[1].EntryContext = &Model30;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = Model30 ? &one : &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                path,
                                &paramTable[0],
                                NULL,
                                NULL))) {

            NotConfigurable = 0;
        }

        ExFreePool(path);
    }

#if DBG
    FdcDebugLevel = debugLevel;
#endif
    if ( shouldBreak ) {
        DbgBreakPoint();
    }

    FdcDump( FDCSHOW, ("Fdc: DriverEntry\n") );

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE] =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = FdcCreateClose;
    DriverObject->MajorFunction[IRP_MJ_POWER]  = FdcPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]    = FdcPnp;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                 FdcInternalDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
                                                 FdcDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
                                                 FdcSystemControl;

    DriverObject->DriverStartIo = FdcStartIo;
    DriverObject->DriverUnload = FdcUnload;
    DriverObject->DriverExtension->AddDevice = FdcAddDevice;

    FDC_PAGE_INITIALIZE_DRIVER_WITH_MUTEX;

    return STATUS_SUCCESS;
}

VOID
FdcUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Unload the driver from the system.  The paging mutex is freed before
    final unload.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

Return Value:

    none

--*/

{
    FdcDump( FDCSHOW, ("FdcUnload:\n"));

    //
    //  The device object(s) should all be gone by now.
    //
    ASSERT( DriverObject->DeviceObject == NULL );

    FDC_PAGE_UNINITIALIZE_DRIVER_WITH_MUTEX;

    return;
}

NTSTATUS
FdcAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.

    A floppy controller device has been enumerated by the root/firmware
    enumerator.  Create an FDO and attach it to this PDO.

Arguments:

    BusDeviceObject - Device object representing the floppy controller.  That
    to which we attach a new FDO.

    DriverObject - This driver.

Return Value:

    STATUS_SUCCESS if the device is successfully created.

--*/
{

    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject;
    PFDC_FDO_EXTENSION  fdoExtension;
    UNICODE_STRING      deviceName;

    FdcDump( FDCSHOW, ("FdcAddDevice:  CreateDeviceObject\n"));

    //
    //  Create the FDO device.
    //
    ntStatus = IoCreateDevice( DriverObject,
                               sizeof( FDC_FDO_EXTENSION ),
                               NULL,
                               FILE_DEVICE_CONTROLLER,
                               FILE_DEVICE_SECURE_OPEN,
                               TRUE,
                               &deviceObject );

    if ( NT_SUCCESS(ntStatus) ) {

        //
        //  Initialize the fdoExtension for this device.
        //
        fdoExtension = deviceObject->DeviceExtension;

        fdoExtension->IsFDO        = TRUE;
        fdoExtension->DriverObject = DriverObject;
        fdoExtension->Self         = deviceObject;
        fdoExtension->OutstandingRequests = 1;
        fdoExtension->TapeEnumerationPending = FALSE;
        fdoExtension->Paused = FALSE;
        //
        //  ACPI machines will use this default counter to identify
        //  controller numbers.  Non-ACPI machines will replace the
        //  ControllerNumber in the FDO extension with the appropraite
        //  value from the registry hardware tree.
        //
        fdoExtension->ControllerNumber = FdcDefaultControllerNumber++;

        KeInitializeEvent( &fdoExtension->TapeEnumerationEvent,
                           SynchronizationEvent,
                           TRUE );

        KeInitializeEvent( &fdoExtension->RemoveEvent,
                           SynchronizationEvent,
                           FALSE );

        InitializeListHead( &fdoExtension->PDOs );

        //
        // initialize the timer we'll be using to delay free our tape buffers.
        //

        KeInitializeTimer( &fdoExtension->BufferTimer );

        //
        // Initialize the spinlock we'll be using to set it and stop the
        // thread.
        //

        KeInitializeSpinLock(&(fdoExtension->BufferThreadSpinLock));

        //
        // Make sure the thread doesn't just terminate the first time it runs.
        //

        fdoExtension->TerminateBufferThread = FALSE;

        //
        //  Initialize a queue for power management.
        //
        InitializeListHead( &fdoExtension->PowerQueue );
        KeInitializeSpinLock( &fdoExtension->PowerQueueSpinLock );

        //
        //  Initialize a variable to hold the last motor settle
        //  time that we have seen.  We will use this when we turn
        //  the floppy motor back on after a power event.
        //
        fdoExtension->LastMotorSettleTime.QuadPart = 0;

        //
        // Set the PDO for use with PlugPlay functions
        //
        fdoExtension->UnderlyingPDO = BusPhysicalDeviceObject;

        //
        //  Now attach to the PDO so that we have a target for PnP and
        //  Power irps that we need to pass on.
        //
        FdcDump( FDCPNP, ("AddDevice: Attaching %p to %p\n",
                          deviceObject,
                          BusPhysicalDeviceObject));

        fdoExtension->TargetObject = IoAttachDeviceToDeviceStack( deviceObject,
                                                                  BusPhysicalDeviceObject );
        if ((fdoExtension->TargetObject) == NULL) {
            FdcDump(FDCDBGP, 
                    ("FDC AddDevice : IoAttachDeviceToDeviceStack failed\n"));
            --FdcDefaultControllerNumber;
            fdoExtension->Removed = FALSE;
            IoDeleteDevice(deviceObject);
            return STATUS_UNSUCCESSFUL;
        }

        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags |= DO_POWER_PAGABLE;

        if ( deviceObject->AlignmentRequirement < FILE_WORD_ALIGNMENT ) {

            deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
        }

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    return ntStatus;
}

NTSTATUS
FdcPnp(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this Pnp request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_EXTENSION_HEADER extensionHeader;
    KIRQL oldIrq;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    //
    // Lock down the driver code in memory if it is not already.
    //

    FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

    if ( extensionHeader->IsFDO ) {

        ntStatus = FdcFdoPnp( DeviceObject, Irp );

    } else {

        ntStatus = FdcPdoPnp( DeviceObject, Irp );
    }

    //
    //  Page out the driver if it is not busy elsewhere.
    //

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    return ntStatus;
}

NTSTATUS
FdcFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Plug-and-Play
    functions.  This routine handles messages to the FDO which is part
    of the bus DevNode.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    //
    //  Incerement our queued request counter.
    //
    InterlockedIncrement( &fdoExtension->OutstandingRequests );

    if ( fdoExtension->Removed ) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        if ( InterlockedDecrement( &fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        return STATUS_DELETE_PENDING;
    }

    switch (irpSp->MinorFunction) {

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:

        ntStatus = FdcFilterResourceRequirements( DeviceObject, Irp );

        break;

    case IRP_MN_START_DEVICE:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_START_DEVICE - Irp: %p\n", Irp) );

        fdoExtension->Paused = FALSE;

        //
        // First we must pass this Irp on to the underlying PDO.
        //
        KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine( Irp,
                                FdcPnpComplete,
                                &doneEvent,
                                TRUE,
                                TRUE,
                                TRUE );


        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        if ( ntStatus == STATUS_PENDING ) {

            ntStatus = KeWaitForSingleObject( &doneEvent,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL );

            ASSERT( ntStatus == STATUS_SUCCESS );

            ntStatus = Irp->IoStatus.Status;
        }

        //
        //  Try to start the floppy disk controller.
        //
        if ( NT_SUCCESS(ntStatus) ) {

            ntStatus = FdcStartDevice( DeviceObject, Irp );
        }

        if ( !NT_SUCCESS(ntStatus) ) {

            fdoExtension->TapeEnumerationPending = FALSE;
        }

        Irp->IoStatus.Status = ntStatus;

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_START_DEVICE %lx %lx\n", Irp->IoStatus.Status, Irp->IoStatus.Information) );

        IoCompleteRequest( Irp, IO_NO_INCREMENT );


        //
        // Process any request that was queued during "Paused" state
        //
        FdcFdoInternalDeviceControl(DeviceObject, NULL);
    
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_QUERY_REMOVE_DEVICE - Irp: %p\n", Irp) );

        //
        //  If the device is currently in use, or if we are enumerating floppy tape
        //  devices (which happens in a worker thread) we will not allow device
        //  removal.
        //
        if ( fdoExtension->ControllerInUse ||
             fdoExtension->TapeEnumerationPending ) {

            ntStatus = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            //
            //  If the controller was not in use we will set it so now
            //  so that any other attempted accesses to the fdc will have
            //
            fdoExtension->Paused = TRUE;

            IoSkipCurrentIrpStackLocation( Irp );

            Irp->IoStatus.Status = STATUS_SUCCESS;

            ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Irp: %p\n", Irp) );

        if (IsNEC_98) {
            //
            // Call IoDisconnectInterrupt() here for PnP function.
            // Because we don't call IoDisconnectInterrupt() in FcReleaseFdc()/FdcStartDevice()
            // for Attention Interrupt which is NEC98 specific H/W.
            //
            if (fdoExtension->InterruptObject) {
                IoDisconnectInterrupt(fdoExtension->InterruptObject);
                fdoExtension->InterruptObject = 0;
            }
        }
        //
        // If we have a tape enumeration thread running we'll need to terminate
        // it.
        //
        if(fdoExtension->BufferThreadHandle) {
            FdcTerminateBufferThread(fdoExtension);
        }

        IoSkipCurrentIrpStackLocation( Irp );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        if ( fdoExtension->FdcEnablerFileObject != NULL ) {
            ObDereferenceObject( fdoExtension->FdcEnablerFileObject );
        }

        //
        //  Delete the children PDO(s).
        //
        {
            PLIST_ENTRY entry ;
            PFDC_PDO_EXTENSION pdoExtension;

            entry = fdoExtension->PDOs.Flink;
            while(entry != &fdoExtension->PDOs) {

                pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );
                entry = entry->Flink ;
                pdoExtension->Removed = TRUE;

                if ( pdoExtension->DeviceType == FloppyDiskDevice ) {
                    // IoGetConfigurationInformation()->FloppyCount--;
                }

                IoDeleteDevice( pdoExtension->Self );
            }
        }

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Detach from device %p\n", fdoExtension->TargetObject) );

        IoDetachDevice( fdoExtension->TargetObject );

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Delete device %p\n", fdoExtension->Self) );

        //
        //  Mark the device as having been removed and nuke it.
        //
        --FdcDefaultControllerNumber;
        fdoExtension->Removed = TRUE;
        IoDeleteDevice( fdoExtension->Self );

        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_CANCEL_REMOVE_DEVICE - Irp: %p\n", Irp) );

        fdoExtension->Paused = FALSE;

        IoSkipCurrentIrpStackLocation( Irp );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        //
        // Process any request that was queued during "Paused" state
        //
        FdcFdoInternalDeviceControl(DeviceObject, NULL);
    
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_QUERY_STOP_DEVICE - Irp: %p\n", Irp) );

        if ( fdoExtension->ControllerInUse ||
             fdoExtension->TapeEnumerationPending ) {

            ntStatus = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            fdoExtension->Paused = TRUE;
            IoSkipCurrentIrpStackLocation( Irp );
            Irp->IoStatus.Status = STATUS_SUCCESS;
            ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );
        }

        break;

    case IRP_MN_STOP_DEVICE:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_STOP_DEVICE - Irp: %p\n", Irp) );

        if (IsNEC_98) {
            //
            // Call IoDisconnectInterrupt() here for PnP function.
            // Because we don't call IoDisconnectInterrupt() in FcReleaseFdc()/FdcStartDevice()
            // for Attention Interrupt which is NEC98 specific H/W.
            //
            if (fdoExtension->InterruptObject) {
                IoDisconnectInterrupt(fdoExtension->InterruptObject);
                fdoExtension->InterruptObject = 0;
            }
        }
        IoSkipCurrentIrpStackLocation( Irp );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_CANCEL_STOP_DEVICE - Irp: %p\n", Irp) );

        fdoExtension->Paused = FALSE;
        IoSkipCurrentIrpStackLocation( Irp );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        //
        // Process any request that was queued during "Paused" state
        //
        FdcFdoInternalDeviceControl(DeviceObject, NULL);
    
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        FdcDump( FDCPNP, ("FdcFdoPnp: IRP_MN_QUERY_DEVICE_RELATIONS - Irp: %p\n", Irp) );

        ntStatus = FdcQueryDeviceRelations( DeviceObject, Irp );

        break;

    default:

        FdcDump( FDCPNP, ("FdcFdoPnp: Unsupported PNP Request %x\n", irpSp->MinorFunction) );

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;
    }

    if ( InterlockedDecrement( &fdoExtension->OutstandingRequests ) == 0 ) {
        KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
    }

    return ntStatus;
}

NTSTATUS
FdcPnpComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.  We use this completion routine when
    we must post-process the irp after we are sure that the PDO is done
    with it.

Arguments:

    DeviceObject - a pointer to our FDO
    Irp - a pointer to the completed Irp
    Context - an event that we will set indicating the irp is completed.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED so that control will be returned to
    our calling routine.

--*/
{

    KeSetEvent( (PKEVENT)Context, 1, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
FdcPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Plug-and-Play
    functions.  This routine handles messages to the PDO which is part
    of the bus DevNode.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PFDC_PDO_EXTENSION pdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;

    pdoExtension = DeviceObject->DeviceExtension;

    if (pdoExtension->Removed) {

        //
        // Protect ourselves from the case where we've been deleted but someone
        // still has our number, and a reference, and is sending us IRPs.
        //
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = Irp->IoStatus.Status;

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        if ( irpSp->Parameters.QueryDeviceRelations.Type == TargetDeviceRelation ) {

            //
            // Return a reference to this PDO (self)
            //
            PDEVICE_RELATIONS devRel;

            devRel = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, sizeof(DEVICE_RELATIONS) );

            if ( devRel != NULL ){
                //
                //  Add a reference to the PDO, since CONFIGMG will free it.
                //
                ObReferenceObject( pdoExtension->Self );//???????????????????????????
                devRel->Objects[0] = pdoExtension->Self;
                devRel->Count = 1;
                Irp->IoStatus.Information = (ULONG_PTR)devRel;
                ntStatus = STATUS_SUCCESS;
            } else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        break;

    case IRP_MN_QUERY_CAPABILITIES: {

        PDEVICE_CAPABILITIES deviceCapabilities;

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_QUERY_CAPABILITIES - Irp: %p\n", Irp) );

        deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;

        //
        //  Fill in the device capabilities structure and return it.  The
        //  capabilities structure is in irpSp->Parameters.DeviceCapabilities.Capabilities;
        //
        //  The size and Version should already be set appropraitely.
        //
        ASSERT( deviceCapabilities->Version == 1 );
        ASSERT( deviceCapabilities->Size == sizeof(DEVICE_CAPABILITIES) );

        //
        //  Address is zero based.
        //
        deviceCapabilities->Address = pdoExtension->PeripheralNumber;
        deviceCapabilities->UniqueID = FALSE;

        ntStatus = STATUS_SUCCESS;
        break;
        }

    case IRP_MN_QUERY_ID:

        //
        // Query the IDs of the device
        //
        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_QUERY_ID - Irp: %p\n", Irp) );
        FdcDump( FDCPNP, ("FdcPdoPnp:   IdType %x\n", irpSp->Parameters.QueryId.IdType) );

        ntStatus = STATUS_SUCCESS;

        switch ( irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID: {

            UCHAR idString[25];
            ANSI_STRING ansiId;
            UNICODE_STRING uniId;
            PWCHAR buffer;
            ULONG length;

            RtlZeroMemory( idString, 25 );

            switch ( pdoExtension->DeviceType ) {

            case FloppyDiskDevice:

                sprintf( idString, "FDC\\GENERIC_FLOPPY_DRIVE" );
                break;

            case FloppyTapeDevice:
                //
                //  Examine the tape vendor id and build the id string
                //  appropriately.
                //
                if ( pdoExtension->TapeVendorId == -1 ) {

                    strcpy( idString, "FDC\\QICLEGACY" );

                } else {

                    sprintf( idString, "FDC\\QIC%04X", (USHORT)pdoExtension->TapeVendorId );
                }

                break;

            case FloppyControllerDevice:

                sprintf( idString, "FDC\\ENABLER" );

                break;
            }

            //
            //  Allocate enough memory for the string and 2 null characters since
            //  this is a multisz type.
            //
            length = strlen( idString ) * sizeof (WCHAR) + sizeof(WCHAR);

            buffer = ExAllocatePool (PagedPool | POOL_COLD_ALLOCATION, length);

            if ( buffer == NULL ) {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlZeroMemory( buffer, length );

            RtlInitAnsiString( &ansiId, idString );

            uniId.Length = 0;
            uniId.MaximumLength = (USHORT)length;
            uniId.Buffer = buffer;

            RtlAnsiStringToUnicodeString( &uniId, &ansiId, FALSE );

            Irp->IoStatus.Information = (UINT_PTR) buffer;

            break;
        }

        case BusQueryHardwareIDs: {

            PWCHAR buffer = NULL;

            switch ( pdoExtension->DeviceType ) {

            case FloppyDiskDevice:

                buffer = FdcBuildIdString( FDC_FLOPPY_HARDWARE_IDS,
                                           FDC_FLOPPY_HARDWARE_IDS_LENGTH );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;

            case FloppyTapeDevice:
                //
                //  Examine the tape vendor id and build the id string
                //  appropriately.
                //
                if ( pdoExtension->TapeVendorId == -1 ) {

                    buffer = FdcBuildIdString( FDC_TAPE_GENERIC_HARDWARE_IDS,
                                               FDC_TAPE_GENERIC_HARDWARE_IDS_LENGTH );

                } else {

                    buffer = FdcBuildIdString( FDC_TAPE_HARDWARE_IDS,
                                               FDC_TAPE_HARDWARE_IDS_LENGTH );

                    //
                    //  This is kind of gross but we will add the tape drive vendor
                    //  id to the hardware id so it looks like FDC\QICnnnn
                    //
                    swprintf( &buffer[7], L"%4X", (USHORT)pdoExtension->TapeVendorId );
                }

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;

            case FloppyControllerDevice:

                buffer = FdcBuildIdString( FDC_CONTROLLER_HARDWARE_IDS,
                                           FDC_CONTROLLER_HARDWARE_IDS_LENGTH );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }

            Irp->IoStatus.Information = (UINT_PTR)buffer;
            break;
        }

        case BusQueryCompatibleIDs:{

            PWCHAR buffer = NULL;

            //
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.
            //
            switch ( pdoExtension->DeviceType ) {

            case FloppyDiskDevice:

                buffer = FdcBuildIdString( FDC_FLOPPY_COMPATIBLE_IDS,
                                           FDC_FLOPPY_COMPATIBLE_IDS_LENGTH );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;

            case FloppyTapeDevice:

                if ( pdoExtension->TapeVendorId != -1 ) {

                    buffer = FdcBuildIdString( FDC_TAPE_COMPATIBLE_IDS,
                                               FDC_TAPE_COMPATIBLE_IDS_LENGTH );

                    if ( buffer == NULL ) {

                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                break;

            case FloppyControllerDevice:

                buffer = FdcBuildIdString( FDC_CONTROLLER_COMPATIBLE_IDS,
                                           FDC_CONTROLLER_COMPATIBLE_IDS_LENGTH );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }

            Irp->IoStatus.Information = (UINT_PTR)buffer;
            break;
        }

        case BusQueryInstanceID: {

            PWCHAR buffer;

            //
            // Go build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.
            //
            buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, 4 );

            if ( buffer == NULL ) {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                buffer[0] = L'0' + (USHORT)pdoExtension->PeripheralNumber;
                buffer[1] = 0;
            }

            Irp->IoStatus.Information = (UINT_PTR)buffer;
            break;
        }

                default: {
                   //
                   // Unknown Query IdType. Just return the
                   // status set in Irp.IoStatus.Status. It's
                   // initialized to STATUS_NOT_SUPPORTED by
                   // system
                   //
                   ASSERT((Irp->IoStatus.Status) == STATUS_NOT_SUPPORTED);
                   ntStatus = Irp->IoStatus.Status;
                   break;
                }
        } // switch ( irpSp->Parameters.QueryId.IdType)

        break;

    case IRP_MN_START_DEVICE:

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_START_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_QUERY_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_CANCEL_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_QUERY_REMOVE_DEVICE - Irp: %p\n", Irp) );

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_REMOVE_DEVICE:

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_REMOVE_DEVICE - Irp: %p\n", Irp) );

        if ( pdoExtension->ReportedMissing ) {

            pdoExtension->Removed = TRUE;
            RemoveEntryList( &pdoExtension->PdoLink );
            ((PFDC_FDO_EXTENSION)pdoExtension->ParentFdo->DeviceExtension)->NumPDOs--;

            if ( pdoExtension->DeviceType == FloppyDiskDevice ) {
                // IoGetConfigurationInformation()->FloppyCount--;
            }

            IoDeleteDevice( DeviceObject );
        }
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        FdcDump( FDCPNP, ("FdcPdoPnp: IRP_MN_CANCEL_REMOVE_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    default:

        FdcDump( FDCPNP, ("FdcPdoPnp: Unsupported PNP Request %x\n", irpSp->MinorFunction) );

        // this is a leaf node
        // status = STATUS_NOT_IMPLEMENTED
        // For PnP requests to the PDO that we do not understand we should
        // return the IRP WITHOUT setting the status or information fields.
        // They may have already been set by a filter (eg acpi).

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    FdcDump( FDCPNP, ("FdcPdoPnp: Return Status - %08x\n", ntStatus) );
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

PWCHAR
FdcBuildIdString(
    IN PWCHAR IdString,
    IN USHORT Length
    )
{
    PVOID buffer;

    buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, Length );

    if ( buffer != NULL ) {

        RtlCopyMemory( buffer, IdString, Length );
    }

    return buffer;
}

NTSTATUS
FdcPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Power functions

Arguments:

    DeviceObject - a pointer to the object that represents the device.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;
    KEVENT doneEvent;
    POWER_STATE newState;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    FdcDump( FDCPOWER, ("FdcPower:\n"));
    
    //
    //  We only process power irps (other that completing them) if we are the
    //  FDO.
    //
    if ( fdoExtension->IsFDO ) {

        if ( fdoExtension->Removed ) {

            FdcDump( FDCPOWER, ("FdcPower: Device Removed - return STATUS_DELETE_PENDING\n"));

            ntStatus = STATUS_DELETE_PENDING;
            PoStartNextPowerIrp( Irp );
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            //
            //  We are only interested in SET_POWER irps.  All others require
            //  no processing so we just forward them.
            //
            switch ( irpSp->MinorFunction ) {

            case IRP_MN_SET_POWER: {

                //
                // Lock down the driver code in memory if it is not already.
                //
                FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

                if ( irpSp->Parameters.Power.Type == SystemPowerState ) {

                    //
                    //  For system power irps we will ignore them if they do
                    //  not change device power state.  Otherwise we request a
                    //  device power irp to do the work.
                    //
                    FdcDump( FDCPOWER, ("FdcPower: SystemPowerIrp, State = %x\n",
                                        irpSp->Parameters.Power.State.SystemState));

                    newState.DeviceState =
                        irpSp->Parameters.Power.State.SystemState == PowerSystemWorking ?
                        PowerDeviceD0 : PowerDeviceD3;

                    if ( fdoExtension->CurrentPowerState == newState.DeviceState ) {

                        FdcDump( FDCPOWER, ("FdcPower: SystemPowerIrp - not changing state\n"));

                        IoMarkIrpPending(Irp);
                        PoStartNextPowerIrp( Irp );
                        IoSkipCurrentIrpStackLocation( Irp );
                        PoCallDriver(fdoExtension->TargetObject, Irp );
                        ntStatus = STATUS_PENDING;

                    } else {

                        FdcDump( FDCPOWER, ("FdcPower: Request Device Power Irp, State = %x\n", newState));

                        //
                        //  send the device power irp
                        //

                        IoMarkIrpPending(Irp);
                        PoRequestPowerIrp( DeviceObject,
                                           IRP_MN_SET_POWER,
                                           newState,
                                           FdcSystemPowerCompletionRoutine,
                                           Irp,
                                           NULL );
                        ntStatus = STATUS_PENDING;
                    }

                } else {

                    newState.DeviceState =
                        irpSp->Parameters.Power.State.DeviceState == PowerDeviceD0 ?
                        PowerDeviceD0 : PowerDeviceD3;

                    FdcDump( FDCPOWER, ("FdcPower: DevicePowerIrp, State = %x\n", newState));

                    if ( fdoExtension->CurrentPowerState == newState.DeviceState ) {

                        //
                        //  No change - do nothing
                        //  SHOULD NEVER GET HERE.
                        //
                        FdcDump( FDCPOWER, ("FdcPower: DevicePowerIrp, NOT CHANGING STATE!!!\n"));
                        IoMarkIrpPending(Irp);
                        PoStartNextPowerIrp( Irp );
                        IoSkipCurrentIrpStackLocation( Irp );
                        PoCallDriver(fdoExtension->TargetObject, Irp );
                        ntStatus = STATUS_PENDING;

                    //
                    //  If we are transitioning to a 'sleep' state start queueing
                    //  irps.
                    //
                    } else if ( newState.DeviceState == PowerDeviceD3 ) {

                        FdcDump( FDCPOWER, ("FdcPower: DevicePowerIrp, Go to sleep\n"));

                        fdoExtension->CurrentPowerState = newState.DeviceState;

                        //
                        //  Make sure that the motors are turned off
                        //
                        if (!IsNEC_98) {
                            WRITE_CONTROLLER(
                                fdoExtension->ControllerAddress.DriveControl,
                                (UCHAR)(fdoExtension->DriveControlImage & ~DRVCTL_MOTOR_MASK) );
                        } // (!IsNEC_98)

                        //
                        //  Now forward this irp to the underlying PDO.
                        //
                        IoMarkIrpPending(Irp);
                        PoStartNextPowerIrp( Irp );
                        IoSkipCurrentIrpStackLocation( Irp );
                        PoCallDriver(fdoExtension->TargetObject, Irp );
                        ntStatus = STATUS_PENDING;

                    //
                    //  Otherwise, if we are transitioning from a non-working state
                    //  back to a working state turn the motor back on if it was on.
                    //
                    } else {

                        FdcDump( FDCPOWER, ("FdcPower: DevicePowerIrp, Wakeup\n"));

                        //
                        // Pass this irp down to the PDO before proceeding.
                        //
                        KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

                        IoCopyCurrentIrpStackLocationToNext(Irp);

                        IoSetCompletionRoutine( Irp,
                                                FdcPnpComplete,
                                                &doneEvent,
                                                TRUE,
                                                TRUE,
                                                TRUE );

                        ntStatus = PoCallDriver( fdoExtension->TargetObject, Irp );

                        if ( ntStatus == STATUS_PENDING ) {

                            KeWaitForSingleObject( &doneEvent, Executive, KernelMode, FALSE, NULL );
                            ntStatus = Irp->IoStatus.Status;
                        }

                        if ( fdoExtension->DriveControlImage & DRVCTL_MOTOR_MASK ) {

                            WRITE_CONTROLLER(
                                fdoExtension->ControllerAddress.DriveControl,
                                fdoExtension->DriveControlImage );

                            if ( fdoExtension->LastMotorSettleTime.QuadPart > 0) {

                                KeDelayExecutionThread( KernelMode,
                                                        FALSE,
                                                        &fdoExtension->LastMotorSettleTime );
                            }
                        }

                        fdoExtension->CurrentPowerState = newState.DeviceState;

                        //
                        //  Set a flag to simulate a disk change event so that
                        //  we will be sure to touch the floppy drive hardware
                        //  the next time it is accessed in case it was removed.
                        //
                        fdoExtension->WakeUp = TRUE;

                        PoStartNextPowerIrp( Irp );
                        IoCompleteRequest( Irp, IO_NO_INCREMENT );


                        //
                        // Process any requests that were queued in PowerQueue
                        // when the device was in D3 state.
                        //
                        FdcFdoInternalDeviceControl(fdoExtension->Self,
                                                    NULL);

                    }
                }


                //
                //  Page out the driver if it is not busy elsewhere.
                //
                //  FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

                break;
            }

            case IRP_MN_WAIT_WAKE:
            case IRP_MN_POWER_SEQUENCE:
            case IRP_MN_QUERY_POWER: {
                // 
                // Fall through
                //
            }

            default: {
                FdcDump( FDCPOWER, ("FdcPower: non-IRP_MN_SET_POWER %x\n",
                                    irpSp->MinorFunction));

                //
                //  Just forward this irp to the underlying device.
                //
                IoMarkIrpPending(Irp);
                PoStartNextPowerIrp( Irp );
                IoSkipCurrentIrpStackLocation( Irp );
                PoCallDriver(fdoExtension->TargetObject, Irp );

                ntStatus = STATUS_PENDING;

                break;

            }

            }  // switch ( irpSp->MinorFunction ) 
        }

    } else {

        FdcDump( FDCPOWER, ("FdcPower: In PDO - complete request\n"));

        //
        //  We are not yet doing any power management on the floppy controller.
        //
        switch (irpSp->MinorFunction) {
            case IRP_MN_SET_POWER:
            case IRP_MN_QUERY_POWER: {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;
            }

            case IRP_MN_WAIT_WAKE:
            case IRP_MN_POWER_SEQUENCE:
            default: {
                break;
            }
        }

        PoStartNextPowerIrp( Irp );
        ntStatus = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return ntStatus;
}

VOID
FdcSystemPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp = (PIRP) Context;
    NTSTATUS status = IoStatus->Status;
    
    FdcDump( FDCPOWER, ("FdcSystemPowerCompletionRoutine - Irp 0x%x\n",
                        irp));

    fdoExtension = DeviceObject->DeviceExtension;

    irp->IoStatus.Status = status;

    PoStartNextPowerIrp(irp);

    if (NT_SUCCESS(status)) {
        IoSkipCurrentIrpStackLocation(irp);
        PoCallDriver( fdoExtension->TargetObject, irp );
    } else {
        FdcDump( FDCPOWER, ("Device power irp failed. Status 0x%x\n",
                            status));
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

NTSTATUS
FdcStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine attempts to start the floppy controller device.  Starting
    the floppy controller consists primarily of resetting it and configuring
    it, mostly just to make sure that it is there.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;

    BOOLEAN foundPortA = FALSE;
    BOOLEAN foundPortB = FALSE;
    BOOLEAN foundDma = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    ULONG currentBase = 0xFFFFFFFF;

    PCM_RESOURCE_LIST translatedResources;
    PCM_FULL_RESOURCE_DESCRIPTOR fullList;
    PCM_PARTIAL_RESOURCE_LIST partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    ULONG i;
    ULONG startOffset;
    ULONG currentOffset;

    UCHAR ioPortMap;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Ask the PDO if it is a tape enabler device and, if so, what
    //  is the enabler device object.
    //
    FdcGetEnablerDevice( fdoExtension );

    if ( fdoExtension->FdcEnablerSupported ) {
#if defined(NO_LEGACY_DRIVERS)
        ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;
#else


        INTERFACE_TYPE InterfaceType;

        //
        //  This is a tape enabler card so we need to get the resources
        //  'the old-fashinoed way'.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 FdcFdoConfigCallBack,
                                                 fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }

        if ( fdoExtension->FdcEnablerDeviceObject == NULL ) {

            ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        } else {

            ntStatus = STATUS_SUCCESS;
        }
#endif // NO_LEGACY_DRIVERS
    } else {

        //
        //  Now that the PDO is done with the Irp we can have our way with
        //  it.
        //
        FdcDump( FDCPNP, ("AllocatedResources = %p\n", irpSp->Parameters.StartDevice.AllocatedResources) );
        FdcDump( FDCPNP, ("AllocatedResourcesTranslated = %p\n", irpSp->Parameters.StartDevice.AllocatedResourcesTranslated) );

        if ( irpSp->Parameters.StartDevice.AllocatedResources == NULL ||
             irpSp->Parameters.StartDevice.AllocatedResourcesTranslated == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Set up the resource information that we will use to access the
        //  controller hardware.  We always expect only 1 full set of resources.
        //  In that list we expect a DMA channel, an Interrupt vector, and 2 I/O Port
        //  ranges.  If we don't see all the required resources we will woof.
        //
        translatedResources = irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

        ASSERT( translatedResources->Count == 1 );

        fullList = &translatedResources->List[0];
        partialList = &translatedResources->List[0].PartialResourceList;

        //
        //  Enumerate the list of resources, adding them into our context as we go.
        //
        RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );

        for ( i = 0; i < partialList->Count; i++ ) {

            partial = &partialList->PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {

                if (IsNEC_98) {
                    if ( partial->u.Port.Length == 1 ) {
                        if (!fdoExtension->ControllerAddress.Status) {
                            fdoExtension->ControllerAddress.Status
                                        = (PUCHAR)(ULONG_PTR)partial->u.Port.Start.QuadPart;
                        } else if (!fdoExtension->ControllerAddress.Fifo) {
                            fdoExtension->ControllerAddress.Fifo
                                        = (PUCHAR)(ULONG_PTR)partial->u.Port.Start.QuadPart;
                        } else if (!fdoExtension->ControllerAddress.DriveControl) {
                            fdoExtension->ControllerAddress.DriveControl
                                        = (PUCHAR)(ULONG_PTR)partial->u.Port.Start.QuadPart;
                        } else if (!fdoExtension->ControllerAddress.ModeChange) {
                            fdoExtension->ControllerAddress.ModeChange
                                        = (PUCHAR)(ULONG_PTR)partial->u.Port.Start.QuadPart;
                        } else if (!fdoExtension->ControllerAddress.ModeChangeEx) {
                            fdoExtension->ControllerAddress.ModeChangeEx
                                        = (PUCHAR)(ULONG_PTR)partial->u.Port.Start.QuadPart;
                        }
                    }

                    break;
                }

                //
                //  If we get a base address that is lower than anything we have seen
                //  before, we assume that we have been working with aliased addresses
                //  and start over with the new base address.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) < currentBase ) {

                    RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                    currentBase = partial->u.Port.Start.LowPart & 0xFFFFFFF8;
                }

                //
                //  We only use resources that are associated with the current (lowest)
                //  base addressed.  All others are assumed to be aliased and are not
                //  used.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) == currentBase ) {

                    FdcDump( FDCPNP,
                             ("FdcStartDevice: Adding - %04x, Length - %04x\n",
                             partial->u.Port.Start.LowPart,
                             partial->u.Port.Length) );

                    startOffset = partial->u.Port.Start.LowPart & 0x07;

                    if ( (partial->Flags & CM_RESOURCE_PORT_IO) == CM_RESOURCE_PORT_MEMORY ) {

                        fdoExtension->ControllerAddress.Address[startOffset] =
                            MmMapIoSpace( partial->u.Port.Start,
                                          partial->u.Port.Length,
                                          FALSE );

                        FdcDump( FDCPNP, ("FdcStartDevice: Mapped IoPort\n") );

                    } else {

                        fdoExtension->ControllerAddress.Address[startOffset] = (PUCHAR)(ULONG_PTR)partial->u.Port.Start.QuadPart;
                    }

                    currentOffset = 1;
                    while ( currentOffset < partial->u.Port.Length ) {

                        fdoExtension->ControllerAddress.Address[startOffset + currentOffset] =
                            fdoExtension->ControllerAddress.Address[startOffset] + currentOffset;
                        ++currentOffset;
                    }
                }

                break;
            }

            //
            // Handle memory mapped Port I/O
            //
            case CmResourceTypeMemory: {
                //
                //  If we get a base address that is lower than anything we have seen
                //  before, we assume that we have been working with aliased addresses
                //  and start over with the new base address.
                //
                if ( (partial->u.Memory.Start.LowPart & 0xFFFFFFF8) < currentBase ) {

                    RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                    currentBase = partial->u.Memory.Start.LowPart & 0xFFFFFFF8;
                }

                //
                //  We only use resources that are associated with the current (lowest)
                //  base addressed.  All others are assumed to be aliased and are not
                //  used.
                //
                if ( (partial->u.Memory.Start.LowPart & 0xFFFFFFF8) == currentBase ) {

                    FdcDump( FDCPNP,
                             ("FdcStartDevice: Adding - %04x, Length - %04x\n",
                             partial->u.Memory.Start.LowPart,
                             partial->u.Memory.Length) );

                    startOffset = partial->u.Memory.Start.LowPart & 0x07;

                    fdoExtension->ControllerAddress.Address[startOffset] =
                            MmMapIoSpace( partial->u.Memory.Start,
                                          partial->u.Memory.Length,
                                          FALSE );

                    FdcDump( FDCPNP, ("FdcStartDevice: Mapped IoPort\n") );

                    currentOffset = 1;
                    while ( currentOffset < partial->u.Memory.Length ) {

                        fdoExtension->ControllerAddress.Address[startOffset + currentOffset] =
                            fdoExtension->ControllerAddress.Address[startOffset] + currentOffset;
                        ++currentOffset;
                    }
                }

                break;
            }
            
            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                FdcDump( FDCPNP, ("FdcStartDevice: DMA - %04x\n", partial->u.Dma.Channel) );

                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                //
                // Always ask for one more page than maximum transfer size.
                //
                deviceDesc.MaximumLength += PAGE_SIZE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = fullList->InterfaceType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                deviceDesc.AutoInitialize = FALSE;

                ASSERT(fdoExtension->UnderlyingPDO);

                fdoExtension->AdapterObject =
                    (PADAPTER_OBJECT)IoGetDmaAdapter(fdoExtension->UnderlyingPDO,
                                                     &deviceDesc,
                                                     &fdoExtension->NumberOfMapRegisters );

                if (!fdoExtension->AdapterObject) {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                //  Here we can get another adapter object for formatting.  It
                //  should look the same as the previous one except AutoInitialize
                //  will be true.
                //
                break;
            }

            case CmResourceTypeInterrupt: {

                FdcDump( FDCPNP, ("FdcStartDevice: IRQ - %04x\n", partial->u.Interrupt.Vector) );

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;
                }

#if defined(NO_LEGACY_DRIVERS)
                {
#else
                if (IsNEC_98) {

                    //
                    // NOTENOTE: Invalid Interrupt Level and Vector.
                    //

                    partial->u.Interrupt.Level  = 0x0b;
                    partial->u.Interrupt.Vector = 0x13;

                    //
                    // We get the Vector with HalGetInterruptVector().
                    //

                    fdoExtension->ControllerVector =
                        HalGetInterruptVector( fullList->InterfaceType,
                                               fullList->BusNumber,
                                               partial->u.Interrupt.Level,
                                               partial->u.Interrupt.Vector,
                                               &fdoExtension->ControllerIrql,
                                               &fdoExtension->ProcessorMask );

                    FdcDump( FDCPNP,
                             ("Resource Requirements - ControllerVector = 0x%x\n",
                             fdoExtension->ControllerVector) );

                } else {
#endif // NO_LEGACY_DRIVERS
                    fdoExtension->ControllerVector = partial->u.Interrupt.Vector;
                    fdoExtension->ProcessorMask = partial->u.Interrupt.Affinity;
                    fdoExtension->ControllerIrql = (KIRQL)partial->u.Interrupt.Level;
                }
                fdoExtension->SharableVector = TRUE;
                fdoExtension->SaveFloatState = FALSE;

                break;
            }

            default:

                break;
            }
        }

        FdcDump( FDCPNP, ("FdcStartDevice: ControllerAddress.StatusA      = %08x\n"
                          "FdcStartDevice: ControllerAddress.StatusB      = %08x\n"
                          "FdcStartDevice: ControllerAddress.DriveControl = %08x\n"
                          "FdcStartDevice: ControllerAddress.Tape         = %08x\n"
                          "FdcStartDevice: ControllerAddress.Status       = %08x\n"
                          "FdcStartDevice: ControllerAddress.Fifo         = %08x\n"
                          "FdcStartDevice: ControllerAddress.DRDC         = %08x\n",
                          fdoExtension->ControllerAddress.StatusA,
                          fdoExtension->ControllerAddress.StatusB,
                          fdoExtension->ControllerAddress.DriveControl,
                          fdoExtension->ControllerAddress.Tape,
                          fdoExtension->ControllerAddress.Status,
                          fdoExtension->ControllerAddress.Fifo,
                          fdoExtension->ControllerAddress.DRDC) );

        if (IsNEC_98) {
            FdcDump( FDCPNP, ("FdcStartDevice: ControllerAddress.ModeChange   = %08x\n"
                               "FdcStartDevice: ControllerAddress.ModeChangeEx = %08x\n",
                               fdoExtension->ControllerAddress.ModeChange,
                               fdoExtension->ControllerAddress.ModeChangeEx) );
        }

        if ( !foundDma ||
             !foundInterrupt ||
             fdoExtension->ControllerAddress.DriveControl == NULL ||
//             fdoExtension->ControllerAddress.Tape == NULL ||
             fdoExtension->ControllerAddress.Status == NULL ||
             fdoExtension->ControllerAddress.Fifo == NULL ||
             ((!IsNEC_98) ? (fdoExtension->ControllerAddress.DRDC.DataRate == NULL)
                         : ((fdoExtension->ControllerAddress.ModeChange == NULL) ||
                            (fdoExtension->ControllerAddress.ModeChangeEx == NULL)) )
              ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( NT_SUCCESS(ntStatus) ) {
            //
            //  Set up the bus information since we know it now.
            //
            fdoExtension->BusType = fullList->InterfaceType;
            fdoExtension->BusNumber = fullList->BusNumber;
            fdoExtension->ProbeFloppyDevices = ProbeFloppyDevices;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = FdcInitializeDeviceObject( DeviceObject );

        //
        //  Connect the interrupt for the reset operation.
        //
        ntStatus = IoConnectInterrupt( &fdoExtension->InterruptObject,
                                       FdcInterruptService,
                                       fdoExtension,
                                       NULL,
                                       fdoExtension->ControllerVector,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->InterruptMode,
                                       fdoExtension->SharableVector,
                                       fdoExtension->ProcessorMask,
                                       fdoExtension->SaveFloatState );

        FdcDump( FDCPNP, ("FdcStartDevice: IoConnectInterrupt - %08x\n", ntStatus) );

        fdoExtension->CurrentInterrupt = FALSE;

        if ( NT_SUCCESS(ntStatus) ) {

            //
            // Initialize (Reset) the controller hardware.  This will make
            // sure that the controller is really there and leave it in an
            // appropriate state for the rest of the system startup.
            //
            fdoExtension->AllowInterruptProcessing =
                    fdoExtension->CurrentInterrupt = TRUE;

            //
            // Acquire the Fdc Enabler card if there is one
            //
            if (fdoExtension->FdcEnablerSupported) {

                LARGE_INTEGER acquireTimeOut;

                acquireTimeOut.QuadPart = -(ONE_SECOND * 15);

                ntStatus = FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
                                         IOCTL_ACQUIRE_FDC,
                                         &acquireTimeOut);
            }

            if ( NT_SUCCESS(ntStatus) ) {

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );

                FdcDump( FDCPNP, ("FdcStartDevice: FcInitializeControllerHardware - %08x\n", ntStatus) );

                //
                // Free the tape accelerator card if it was used.
                //
                if (fdoExtension->FdcEnablerSupported) {

                    FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
                                  IOCTL_RELEASE_FDC,
                                  NULL);
                }

                fdoExtension->CurrentInterrupt = FALSE;
            }

            if ( NT_SUCCESS( ntStatus ) ) {

                fdoExtension->HardwareFailed = FALSE;
                ntStatus = FcGetFdcInformation ( fdoExtension );

            } else {

                fdoExtension->HardwareFailed = TRUE;
            }

            if (IsNEC_98) {
                //
                // NEC98's FDD driver can't not disconnect interrupt,
                // and can't not page out this driver. Because when a FD is inserted in FDD or
                // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
                //
            } else { // (IsNEC_98)

                IoDisconnectInterrupt(fdoExtension->InterruptObject);

            } // (IsNEC_98)
        }

        if ( NT_SUCCESS(ntStatus) ) {

            //
            //  Preinit our ACPI data. We start out not knowing
            //      1 - is this an ACPI machine.
            //      2 - is the _FDE method supported by this BIOS.
            //      3 - what did _FDE enumerate.
            //
            // We pre-init ACPI data only on the first start irp.
            // We should not reset these fields if they've been set
            // already in FdcQueryDeviceRelations. This is to prevent loss
            // of information during rebalance.
            //
            if (!(fdoExtension->ACPI_BIOS)) {
               FdcDump(FDCSHOW,
                       ("Probably not an ACPI machine.\n"));
            }

            if (!(fdoExtension->ACPI_FDE_Valid)) {
               RtlZeroMemory(&fdoExtension->ACPI_FDE_Data, sizeof(ACPI_FDE_ENUM_TABLE));
            }

            fdoExtension->ACPI_FDE_Data.ACPI_Tape = TapeDontKnow;
        }

        if( NT_SUCCESS( ntStatus ) &&
            (fdoExtension->ACPI_FDE_Data.ACPI_Tape == TapePresent ||
             fdoExtension->ACPI_FDE_Data.ACPI_Tape == TapeDontKnow) ) {

            //
            //  We will only attempt to allocate memory for and enumerate tape
            //  drives if we are not in setup mode and we have the tape mode
            //  register (0x3f3).
            //
#ifdef NOT_NOW
            if ( !FdcInSetupMode &&
                 fdoExtension->ControllerAddress.Tape != NULL ) {

                FcAllocateCommonBuffers( fdoExtension );
            }
#endif
        }
    }

    Irp->IoStatus.Information = 0;

    return ntStatus;
}
NTSTATUS
FdcInitializeDeviceObject(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine initializes the DeviceObject resources.  DeviceObject resources
    only need to be initialized once, regardless of how many times this device
    is started.

Arguments:

    DeviceObject - a pointer to the device object being started.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    USHORT      motorControlData;

    FdcDump( FDCSHOW, ("FdcInitializeDeviceObject:\n") );
    fdoExtension = DeviceObject->DeviceExtension;

    if ( !fdoExtension->DeviceObjectInitialized ) {

        //
        // Set the time to wait for an interrupt before timing out to a
        // few seconds.
        //
        fdoExtension->InterruptDelay.QuadPart = -(ONE_SECOND * 4);

        //
        // Set the minimum time that we can delay (10ms according to system
        // rules).  This will be used when we have to delay to, say, wait
        // for the FIFO - the FIFO should become ready is well under 10ms.
        //
        fdoExtension->Minimum10msDelay.QuadPart = -(10 * 1000 * 10);

        if (IsNEC_98) {
            //
            // Set initialize data to move state
            //
            fdoExtension->ResultStatus0[0] = 0xc0;
            fdoExtension->ResultStatus0[1] = 0xc1;
            fdoExtension->ResultStatus0[2] = 0xc2;
            fdoExtension->ResultStatus0[3] = 0xc3;

            //
            // Reset high
            //
            READ_CONTROLLER(fdoExtension->ControllerAddress.DriveControl);

            //
            // Initialize motor running status.
            //   0 - stop
            //   1 - just run
            //   2 - be running
            //
            fdoExtension->MotorRunning = 0;

            //
            // Get BIOS common area date.
            //
            {
                ULONG                       nodeNumber;
                WCHAR                       pathBuffer[512];
                UNICODE_STRING              registryPath;
                ULONG                       Configuration;

                RTL_QUERY_REGISTRY_TABLE    paramTable[2];
                PUCHAR                      ConfigurationData1;

                ConfigurationData1 = ExAllocatePool(NonPagedPoolCacheAligned, 1192);

                if (ConfigurationData1 == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlZeroMemory(ConfigurationData1, 1192);

                paramTable[0].QueryRoutine      = NULL;
                paramTable[0].Flags             = RTL_QUERY_REGISTRY_DIRECT;
                paramTable[0].Name              = L"Configuration Data";
                paramTable[0].EntryContext      = ConfigurationData1;
                paramTable[0].DefaultType       = REG_DWORD;
                paramTable[0].DefaultData       = (PVOID)&Configuration;
                paramTable[0].DefaultLength     = 0;

                paramTable[1].QueryRoutine      = NULL;
                paramTable[1].Flags             = 0;
                paramTable[1].Name              = NULL;
                paramTable[1].EntryContext      = NULL;
                paramTable[1].DefaultType       = REG_NONE;
                paramTable[1].DefaultData       = NULL;
                paramTable[1].DefaultLength     = 0;

                ((PULONG)ConfigurationData1)[0] = 1192;

                nodeNumber = FdcFindIsaBusNode();

                if ( nodeNumber != -1 ) {

                    //
                    // Build path buffer...
                    //
                    swprintf(pathBuffer,ISA_BUS_NODE,nodeNumber);
                    RtlInitUnicodeString(&registryPath,pathBuffer);

                    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                                      registryPath.Buffer,
                                                      paramTable,
                                                      NULL,
                                                      NULL);

                }

                if (!(NT_SUCCESS(ntStatus))) {

                    ExFreePool(ConfigurationData1);
                    return ntStatus;
                }

                //
                // Set disk dirve existing bit.
                //
                fdoExtension->FloppyEquip = (UCHAR)(FdcGet0Seg(ConfigurationData1, 0x55c) & 0x0F);

                //
                // Reset high
                //
                READ_CONTROLLER(fdoExtension->ControllerAddress.DriveControl);

                motorControlData  = READ_CONTROLLER(fdoExtension->ControllerAddress.ModeChange);
                motorControlData &= 0x03;
                motorControlData |= 0x04;

                //
                // Motor control.
                //
                WRITE_CONTROLLER(fdoExtension->ControllerAddress.ModeChange, motorControlData);

                ExFreePool(ConfigurationData1);
            }
        } // (IsNEC_98)

        //
        // Initialize the DPC structure in the device object, so that
        // the ISR can queue DPCs.
        //
        IoInitializeDpcRequest( fdoExtension->Self, FdcDeferredProcedure );

        //
        // Occasionally during stress we've seen the device lock up.
        // We create a dpc so that we can log that the device lock up
        // occured and that we reset the device.
        //
        KeInitializeDpc( &fdoExtension->LogErrorDpc,
                         FcLogErrorDpc,
                         fdoExtension );

        //
        // Assume there is a CONFIGURE command until found otherwise.
        // Other Booleans were zero-initialized to FALSE.
        //
        fdoExtension->ControllerConfigurable = NotConfigurable ? FALSE : TRUE;
        fdoExtension->Model30 = Model30 ? TRUE : FALSE;

        fdoExtension->AllowInterruptProcessing = TRUE;
        fdoExtension->CurrentInterrupt         = TRUE;
        fdoExtension->ControllerInUse          = FALSE;
        fdoExtension->CurrentIrp               = NULL;

        //
        // Start the timer
        //
        fdoExtension->InterruptTimer = CANCEL_TIMER;

        IoInitializeTimer( DeviceObject, FdcCheckTimer, fdoExtension );

        //
        // Initialize events to signal interrupts and adapter object
        // allocation
        //
        KeInitializeEvent( &fdoExtension->InterruptEvent,
                           SynchronizationEvent,
                           FALSE);

        KeInitializeEvent( &fdoExtension->AllocateAdapterChannelEvent,
                           NotificationEvent,
                           FALSE );

        fdoExtension->AdapterChannelRefCount = 0;

        KeInitializeEvent( &fdoExtension->AcquireEvent,
                           SynchronizationEvent,
                           TRUE );
    }

    fdoExtension->DeviceObjectInitialized = TRUE;

    return ntStatus;
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
FdcFdoConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This routine is used to acquire all of the configuration
    information for a tape enabler if we ever find one.

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG apiSupported;
    WCHAR idstr[200];
    UNICODE_STRING str;
    USHORT i;
    BOOLEAN foundPort = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    BOOLEAN foundDma = FALSE;

    FdcDump( FDCSHOW, ("FdcFdoConfigCallBack:\n") );

    //
    //  The first thing to do is to go out and look for an enabler.  We
    //  know we are dealing with one if there is a registry value called
    //  APISupported.
    //
    str.Length = 0;
    str.MaximumLength = 200;
    str.Buffer = idstr;

    RtlZeroMemory( &paramTable[0], sizeof(paramTable) );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"APISupported";
    paramTable[0].EntryContext = &str;
    paramTable[0].DefaultType = REG_SZ;
    paramTable[0].DefaultData = L"";
    paramTable[0].DefaultLength = sizeof(WCHAR);

    ntStatus = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                       PathName->Buffer,
                                       &paramTable[0],
                                       NULL,
                                       NULL);
    if ( !NT_SUCCESS( ntStatus ) ) {
        str.Buffer[0] = 0;
    }

    if ( str.Buffer[0] != 0 ) {

        FdcDump( FDCINFO,
                 ("FdcFdoConfigCallBack: Got registry setting for EnablerAPI = %s\n",
                 str.Buffer) );

        ntStatus = IoGetDeviceObjectPointer( &str,
                                             FILE_READ_ACCESS,
                                             &fdoExtension->FdcEnablerFileObject,
                                             &fdoExtension->FdcEnablerDeviceObject);
    }

    if ( fdoExtension->FdcEnablerDeviceObject != NULL ) {

        PCM_FULL_RESOURCE_DESCRIPTOR controllerData =
            (PCM_FULL_RESOURCE_DESCRIPTOR)
            (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
            ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

        //
        // We have the pointer.  Save off the interface type and
        // the busnumber for use when we call the Hal and the
        // Io System.
        //
        fdoExtension->BusType = BusType;
        fdoExtension->BusNumber = BusNumber;
        fdoExtension->SharableVector = TRUE;
        fdoExtension->SaveFloatState = FALSE;

        //
        // We need to get the following information out of the partial
        // resource descriptors.
        //
        // The irql and vector.
        //
        // The dma channel.
        //
        // The base address and span covered by the floppy controllers
        // registers.
        //
        // It is not defined how these appear in the partial resource
        // lists, so we will just loop over all of them.  If we find
        // something we don't recognize, we drop that information on
        // the floor.  When we have finished going through all the
        // partial information, we validate that we got the above
        // three.
        //
        for ( i = 0;
              i < controllerData->PartialResourceList.Count;
              i++ ) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
                &controllerData->PartialResourceList.PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {

                foundPort = TRUE;

                //
                // Save of the pointer to the partial so
                // that we can later use it to report resources
                // and we can also use this later in the routine
                // to make sure that we got all of our resources.
                //
                fdoExtension->SpanOfControllerAddress = partial->u.Port.Length;
                fdoExtension->ControllerAddress.StatusA =
                    FdcGetControllerBase(
                        BusType,
                        BusNumber,
                        partial->u.Port.Start,
                        fdoExtension->SpanOfControllerAddress,
                        (BOOLEAN)!!partial->Flags );

                if ( fdoExtension->ControllerAddress.StatusA == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    fdoExtension->ControllerAddress.StatusB       = fdoExtension->ControllerAddress.StatusA + 1;
                    fdoExtension->ControllerAddress.DriveControl  = fdoExtension->ControllerAddress.StatusA + 2;
                    fdoExtension->ControllerAddress.Tape          = fdoExtension->ControllerAddress.StatusA + 3;
                    fdoExtension->ControllerAddress.Status        = fdoExtension->ControllerAddress.StatusA + 4;
                    fdoExtension->ControllerAddress.Fifo          = fdoExtension->ControllerAddress.StatusA + 5;
                    fdoExtension->ControllerAddress.DRDC.DataRate = fdoExtension->ControllerAddress.StatusA + 7;
                }

                break;
            }
            case CmResourceTypeInterrupt: {

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED ) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;

                }

                fdoExtension->ControllerVector =
                    HalGetInterruptVector(
                        BusType,
                        BusNumber,
                        partial->u.Interrupt.Level,
                        partial->u.Interrupt.Vector,
                        &fdoExtension->ControllerIrql,
                        &fdoExtension->ProcessorMask
                        );

                break;
            }
            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                //
                // Use IgnoreCount equal to TRUE to fix PS/1000.
                //
                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = BusType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                fdoExtension->AdapterObject =
                    (PADAPTER_OBJECT)IoGetDmaAdapter(fdoExtension->UnderlyingPDO,
                                                     &deviceDesc,
                                                     &fdoExtension->NumberOfMapRegisters
                                                     );

                if ( fdoExtension->AdapterObject == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }
            default:

                break;
            }
        }
        //
        // If we didn't get all the information then we return
        // insufficient resources.
        //
        if ( !foundPort || !foundInterrupt || !foundDma ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return ntStatus;
}

#endif // NO_LEGACY_DRIVERS

PVOID
FdcGetControllerBase(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )
/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    InIoSpace - indicates an IO address.

Return Value:

    Mapped address

--*/
{
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InIoSpace;
    PVOID Address;

    if ( !HalTranslateBusAddress( BusType,
                                  BusNumber,
                                  IoAddress,
                                  &addressSpace,
                                  &cardAddress ) ){
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if ( !addressSpace ) {

        Address = MmMapIoSpace( cardAddress,
                                NumberOfBytes,
                                FALSE );

    } else {

        Address = (PCONTROLLER)(ULONG_PTR)cardAddress.QuadPart;
    }
    return Address;
}

VOID
FcAllocateCommonBuffers(
    IN PFDC_FDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine allocates buffers for use by a tape drive if
    there is one.  These buffers will later be deallocated if
    no device claims them within a reasonable amount of time.
    This routine starts a thread that will set a timer to
    free up the unclaimed buffers.

Arguments:

    FdoExtension - A pointer to our extension data.

Return Value:

--*/
{
    PTRANSFER_BUFFER transferBuffers;
    PHYSICAL_ADDRESS paddress;
    PVOID address;
    ULONG count = 0;
    HANDLE      threadHandle;
    NTSTATUS ntStatus;
    ULONG i;

    //
    //  The qic117 device requires at least 2 32k buffers.  If the
    //  registry is set up to provide something less, we won't bother
    //  to enumerate the tape drives.
    //
    if ( NumberOfBuffers < 2 || BufferSize < 0x8000 ) {
        return;
    }

    FdoExtension->BufferSize = BufferSize;

    //
    //  Allocate our transfer buffer array.
    //
    transferBuffers = ExAllocatePool( NonPagedPool,
                                      sizeof(TRANSFER_BUFFER) * NumberOfBuffers);

    if ( transferBuffers == NULL) {
        return;
    }

    FdoExtension->TransferBuffers = transferBuffers;

    //
    //  Now, allocate the transfer buffers.  Save both the virtual and
    //  the physical address of the buffer.
    //
    do {
        address = HalAllocateCommonBuffer( FdoExtension->AdapterObject,
                                           BufferSize,
                                           &paddress,
                                           FALSE );


        if (address != NULL) {
            transferBuffers[count].Virtual = address;
            transferBuffers[count].Logical = paddress;
            ++FdoExtension->BufferCount;
        }
    } while ( ++count < NumberOfBuffers && address != NULL );

    //
    //  If we got enough buffers for the tape drive, go ahead and fire
    //  up the thread that will enumerate floppy tape devices.  We do
    //  this in a thread since it is so time consuming.
    //
    if ( FdoExtension->BufferCount >= 2 ) {

        FdoExtension->TapeEnumerationPending = TRUE;

        KeResetEvent( &FdoExtension->TapeEnumerationEvent );

        ntStatus = PsCreateSystemThread( &threadHandle,
                                         (ACCESS_MASK) 0L,
                                         NULL,
                                         NULL,
                                         NULL,
                                         (PKSTART_ROUTINE)FdcBufferThread,
                                         FdoExtension);
    } else {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  If we couldn't get enough buffers or we couldn't start up the
    //  enumeration thread, free whatever resources we have and forget
    //  about tape enumeration.
    //
    if ( NT_SUCCESS(ntStatus) ) {

        FdoExtension->BufferThreadHandle = threadHandle;

    } else {

        for ( i = FdoExtension->BuffersRequested ;
              i < FdoExtension->BufferCount ;
              i++ ) {

            HalFreeCommonBuffer( FdoExtension->AdapterObject,
                                 FdoExtension->BufferSize,
                                 FdoExtension->TransferBuffers[i].Logical,
                                 FdoExtension->TransferBuffers[i].Virtual,
                                 FALSE );

        }
        FdoExtension->BufferCount = 0;

        ExFreePool( FdoExtension->TransferBuffers );
        FdoExtension->TransferBuffers = NULL;

        FdoExtension->TapeEnumerationPending = FALSE;
        KeSetEvent( &FdoExtension->TapeEnumerationEvent, 0, FALSE );
    }
}

VOID
FdcBufferThread(
    IN PVOID Context
    )
/*++

Routine Description:

    This routine starts a timer then, after the timer expires,
    it attempts to enumerate any floppy tape drives that may be
    present on the floppy bus.  If no tape drives are found it frees
    up the tape buffers that were allocated earlier.

Arguments:

    Context - A pointer to our extension data.

Return Value:

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension;
    LARGE_INTEGER bufferTimeout;

    KIRQL oldIrql;
    BOOLEAN terminate = FALSE;

    ULONG i;

    //
    //  Lock down the driver code in memory.
    //
    FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;

    bufferTimeout.QuadPart = -((LONGLONG)ONE_SECOND * (LONGLONG)60); // 10 Minutes

    //
    // Grab the spinlock and make sure we're still supposed to be running.
    //

    KeAcquireSpinLock(&(fdoExtension->BufferThreadSpinLock), &oldIrql);

    if(fdoExtension->TerminateBufferThread) {
        terminate = TRUE;
    } else {

        //
        // We are supposed to run.  Set the timer while holding the spinlock.
        // Otherwise we'll race with the terminating thread to set the timeout
        // to 10 minutes or zero.
        //

        KeSetTimer ( &fdoExtension->BufferTimer,
                     bufferTimeout,
                     NULL );
    }

    KeReleaseSpinLock(&(fdoExtension->BufferThreadSpinLock), oldIrql);

    if(!terminate) {

        //
        // A terminating thread will reset the timer we're waiting on and
        // we'll wake up from here quickly if we're expected to terminate.
        //

        KeWaitForSingleObject( &fdoExtension->BufferTimer,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        //
        // An unsynchronized check here is just as unsafe as grabbing the
        // spinlock again since we can't actually do the enumeration while
        // holding it.
        //

        terminate = fdoExtension->TerminateBufferThread;
    }


    if(!terminate) {
        ntStatus = FdcEnumerateQ117( fdoExtension );
    } else {
        ntStatus = STATUS_NO_SUCH_DEVICE;
    }

    if ( !NT_SUCCESS(ntStatus) ) {

        for ( i = fdoExtension->BuffersRequested ;
              i < fdoExtension->BufferCount ;
              i++) {

            HalFreeCommonBuffer( fdoExtension->AdapterObject,
                                 fdoExtension->BufferSize,
                                 fdoExtension->TransferBuffers[i].Logical,
                                 fdoExtension->TransferBuffers[i].Virtual,
                                 FALSE );

        }
        fdoExtension->BufferCount = 0;
    }

    fdoExtension->TapeEnumerationPending = FALSE;

    //
    //  Page out the driver if it is not busy elsewhere.
    //
    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    PsTerminateSystemThread( STATUS_SUCCESS );
}
NTSTATUS
FdcEnumerateQ117(
    IN PFDC_FDO_EXTENSION FdoExtension
    )
{
    NTSTATUS ntStatus;
    CqdContextPtr qicCqdContext;
    KdiContextPtr qicKdiContext;
    BOOLEAN vendorDetected;

    if (IsNEC_98) {
        //
        // NEC98 have no tape which is controlled by FDC.
        //

        return STATUS_UNSUCCESSFUL;

    } // (IsNEC_98)

    //
    //  Initiate the QIC-117 find sequence to attempt to find any floppy
    //  tape drives attached to this controller.
    //
    //  First allocate and initialize a context for the find operation.
    //
    qicCqdContext = ExAllocatePool( NonPagedPool, sizeof(CqdContext) );

    if ( qicCqdContext == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( qicCqdContext, sizeof(CqdContext) );

    qicKdiContext = ExAllocatePool( NonPagedPool, sizeof(KdiContext) );

    if ( qicKdiContext == NULL ) {
        ExFreePool( qicCqdContext );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( qicKdiContext, sizeof(KdiContext) );

    cqd_InitializeContext( qicCqdContext, qicKdiContext );

    qicKdiContext->controller_data.fdcDeviceObject = FdoExtension->Self;
    qicCqdContext->device_descriptor.fdc_type = FdoExtension->FdcType;

    if ( !FdoExtension->FdcEnablerSupported ) {

        //
        //  If we are not already an enabler FDO, query the registry hardware
        //  tree to find out how many floppy controllers have been registered.
        //  We only ever expect 1 unless a tape enabler card has been
        //  installed.
        //
        INTERFACE_TYPE InterfaceType;

        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 FdcBusConfigCallBack,
                                                 FdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }
    }

    ntStatus = FcAcquireFdc( FdoExtension, NULL );

    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = cqd_LocateDevice( qicCqdContext, &vendorDetected );

        if ( ntStatus != STATUS_SUCCESS ) {
          ntStatus = STATUS_UNSUCCESSFUL;
        }

        FcReleaseFdc( FdoExtension );
    }

    KeSetEvent( &FdoExtension->TapeEnumerationEvent, 0, FALSE );

    if ( NT_SUCCESS(ntStatus) ) {

        UNICODE_STRING pdoName;
        USHORT nameIndex = 0;
        PDEVICE_OBJECT newPdo;
        PFDC_PDO_EXTENSION pdoExtension;
        WCHAR pdoNameBuffer[64];

        do {

            swprintf( pdoNameBuffer, L"\\Device\\q117PDO%d", nameIndex++ );
            RtlInitUnicodeString( &pdoName, pdoNameBuffer );

            ntStatus = IoCreateDevice( FdoExtension->Self->DriverObject,
                                       sizeof(FDC_PDO_EXTENSION),
                                       &pdoName,
                                       FILE_DEVICE_MASS_STORAGE,
                                       FILE_DEVICE_SECURE_OPEN,
                                       FALSE,
                                       &newPdo);

        } while ( ntStatus == STATUS_OBJECT_NAME_COLLISION );

        FdcDump( FDCSHOW, ("FdcBufferThread: Created Device %d\n", nameIndex) );

        if ( NT_SUCCESS(ntStatus) ) {

            pdoExtension = (PFDC_PDO_EXTENSION) newPdo->DeviceExtension;

            pdoExtension->TargetObject = FdoExtension->Self;

            pdoExtension->IsFDO = FALSE;
            pdoExtension->Self = newPdo;
            pdoExtension->DeviceType = FloppyTapeDevice;

            if ( vendorDetected ) {
                pdoExtension->TapeVendorId = (qicCqdContext->device_descriptor.vendor << 6)
                                               + qicCqdContext->device_descriptor.model;
            } else {
                pdoExtension->TapeVendorId = -1;
            }

            pdoExtension->ParentFdo = FdoExtension->Self;

            pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet

            newPdo->StackSize += FdoExtension->Self->StackSize;
            newPdo->Flags &= ~DO_DEVICE_INITIALIZING;
            newPdo->Flags |= DO_POWER_PAGABLE;

            InsertTailList(&FdoExtension->PDOs, &pdoExtension->PdoLink);
            FdoExtension->NumPDOs++;

            IoInvalidateDeviceRelations (FdoExtension->UnderlyingPDO, BusRelations);
        }
    }

    return ntStatus;
}

NTSTATUS
FcInitializeControllerHardware(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called at initialization time by FcInitializeDevice()
    - once for each controller that we have to support.

    When this routine is called, the controller data structures have all
    been allocated.

Arguments:

    ControllerData - the completed data structure associated with the
    controller hardware being initialized.

    DeviceObject - a pointer to a device object; this routine will cause
    an interrupt, and the ISR requires CurrentDeviceObject to be filled
    in.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UCHAR statusRegister0;
    UCHAR cylinder;
    UCHAR driveNumber;
    UCHAR retrycnt;

    FdcDump( FDCSHOW, ("Fdc: FcInitializeControllerHardware...\n") );

    for (retrycnt = 0; ; retrycnt++) {

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //
        DISABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        FdoExtension->CurrentDeviceObject = DeviceObject;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase = FALSE;
        KeResetEvent( &FdoExtension->InterruptEvent );

        ENABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        if (IsNEC_98) {
            //
            // NEC98 don't have to wait for interrupt.
            //

            ntStatus = STATUS_SUCCESS;

        } else { // (IsNEC_98)
            //
            // Wait for an interrupt.  Note that STATUS_TIMEOUT and
            // STATUS_SUCCESS are the only possible return codes, since we
            // aren't alertable and won't get APCs.
            //
            ntStatus = KeWaitForSingleObject( &FdoExtension->InterruptEvent,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              &FdoExtension->InterruptDelay );
        } // (IsNEC_98)

        if (ntStatus == STATUS_TIMEOUT) {

            if (retrycnt >= 1) {
                break;
            }

            // Retry reset after configure command to enable polling
            // interrupt.

            FdoExtension->FifoBuffer[0] = COMMND_CONFIGURE;

            if (FdoExtension->Clock48MHz) {
                FdoExtension->FifoBuffer[0] |= COMMND_OPTION_CLK48;
            }

            FdoExtension->FifoBuffer[1] = 0;
            FdoExtension->FifoBuffer[2] = COMMND_CONFIGURE_FIFO_THRESHOLD;
            FdoExtension->FifoBuffer[3] = 0;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (!NT_SUCCESS(ntStatus)) {
                ntStatus = STATUS_TIMEOUT;
                break;
            }

            KeStallExecutionProcessor( 500 );

        } else {

            break;

        }
    }

    if ( ntStatus == STATUS_TIMEOUT ) {

        //
        // Change info to an error.
        //

        ntStatus = STATUS_IO_TIMEOUT;

        FdoExtension->HardwareFailed = TRUE;
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        FdcDump(FDCDBGP,("Fdc: controller didn't interrupt after reset\n"));

        return ntStatus;
    } 

    if (!IsNEC_98) {

        ntStatus = FcFinishReset( FdoExtension );

    } // (!IsNEC_98)

    return ntStatus;
}

NTSTATUS
FcGetFdcInformation(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine will attempt to identify the type of Floppy Controller

Arguments:

    FdoExtension - a pointer to our data area for the drive being
    accessed (any drive if a controller command is being given).

Return Value:

--*/
{
    NTSTATUS ntStatus;
    FDC_INFORMATION fdcInfo;

    if (FdoExtension->FdcEnablerSupported) {

        fdcInfo.structSize = sizeof(fdcInfo);

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                                 IOCTL_GET_FDC_INFO,
                                 &fdcInfo);

        if ( NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FdcType = (UCHAR)fdcInfo.FloppyControllerType;
            FdoExtension->Clock48MHz =
                            (fdcInfo.ClockRatesSupported == FDC_CLOCK_48MHZ);
            FdoExtension->FdcSpeeds = (UCHAR)fdcInfo.SpeedsAvailable;

        }

    } else {

        //
        // First, assume that we don't know what kind of FDC is attached.
        //

        FdoExtension->FdcType = FDC_TYPE_UNKNOWN;


        // Check for an enhanced type controller by issuing the version command.

        FdoExtension->FifoBuffer[0] = COMMND_VERSION;

        ntStatus = FcIssueCommand( FdoExtension,
                                FdoExtension->FifoBuffer,
                                FdoExtension->FifoBuffer,
                                NULL,
                                0,
                                0 );

        if ( NT_SUCCESS( ntStatus ) ) {

            if (FdoExtension->FifoBuffer[0] == VALID_NEC_FDC) {

                FdoExtension->FdcType = FDC_TYPE_ENHANCED;

            } else {

                FdoExtension->FdcType = FDC_TYPE_NORMAL;

            }
        }

        // Determine if the controller is a National 8477 by issuing the NSC
        // command which is specific to National parts and returns 0x71. (This
        // command happens to be the same as the Intel Part ID command so we
        // will use it instead.) The lower four bits are subject to change by
        // National and will reflect the version of the part in question.  At
        // this point we will only test the high four bits.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ( (FdoExtension->FifoBuffer[0] & NSC_MASK) ==
                     NSC_PRIMARY_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_NATIONAL;

                }
            }
        }

        // Determine if the controller is an 82077 by issuing the perpendicular
        // mode command which at this time is only valid on 82077's.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PERPENDICULAR_MODE;
            FdoExtension->FifoBuffer[1] = COMMND_PERPENDICULAR_MODE_OW;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (ntStatus != STATUS_DEVICE_NOT_READY) {

                FdoExtension->FdcType = FDC_TYPE_82077;

            } else {

                ntStatus = STATUS_SUCCESS;
            }
        }

        // Determine if the controller is an Intel 82078 by issuing the part id
        // command which is specific to Intel 82078 parts.

        if ( FdoExtension->FdcType == FDC_TYPE_82077 &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                    INTEL_64_PIN_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_82078_64;
                } else {
                    if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                        INTEL_44_PIN_VERSION) {

                        FdoExtension->FdcType = FDC_TYPE_82078_44;
                    }
                }
            }
        }

        switch (FdoExtension->FdcType) {

        case FDC_TYPE_UNKNOWN   :
        case FDC_TYPE_NORMAL    :
        case FDC_TYPE_ENHANCED  :
        default:

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB;
            break;

        case FDC_TYPE_82077     :
        case FDC_TYPE_82077AA   :
        case FDC_TYPE_82078_44  :
        case FDC_TYPE_NATIONAL  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;
            break;

        case FDC_TYPE_82078_64  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;

            if ( FdoExtension->Clock48MHz ) {

                FdoExtension->FdcSpeeds |= FDC_SPEED_2MB;
            }

            break;
        }
    }

    FdcDump( FDCINFO, ("Fdc: FdcType - %x\n", FdoExtension->FdcType));

    return ntStatus;
}
#define IO_PORT_REQ_MASK 0xbc

NTSTATUS
FdcFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine examines the supplied resource list and adds resources if
    necessary.  The only resources that it is concerned with adding are io port
    resources.  Adding io port resources is necessary because of different bios
    configurations and specifications.

    The PC97(98) hardware specification defines only 3f2, 3f4, and 3f5 as
    io port resources for standard floppy controllers (based on IBM PC floppy
    controller configurations).  In addition to these resources, fdc.sys
    requires 3f7 for disk change detection and data rate programming and
    optionally 3f3 for floppy tape support.  In addition, some bioses define
    aliased resources (e.g. 3f2 & 7f2, etc.)

    This routine first forwards the irp to the underlying PDO.  Upon return,
    it examines the io resource list to determine if any additional resources
    will be required.  It maintains a linked list of all io port base addresses
    that it encounters, assuming that they define aliased resources.  N.B. - if
    alternative lists are present in the io resource requirements list, only the
    first list is examined.  If additional resources are required a new io
    resource list is created.  The first io resource list in the new resource
    requirements list will contain the original resources as well as the
    additional resources required.  If it was necessary to request the tape mode
    register (3f3), i.e. 3f3 was not in the original list, a second list is
    generated that is identical to the first new list except that 3f3 is excluded.
    This list is for the case where the tape mode register is not available.
    Finally, the original list(s) is(are) copied to the end of the new list and
    are treated as alternative io resource lists.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsIn;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsOut;
    ULONG listSize;
    ULONG i,j;
    PIO_RESOURCE_LIST ioResourceListIn;
    PIO_RESOURCE_LIST ioResourceListOut;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorIn;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorOut;
    LIST_ENTRY ioPortList;
    PLIST_ENTRY links;
    PIO_PORT_INFO ioPortInfo;
    BOOLEAN foundBase;
    ULONG newDescriptors;
    BOOLEAN interruptResource = FALSE;
    BOOLEAN dmaResource = FALSE;
    UCHAR newPortMask;
    BOOLEAN requestTapeModeRegister = FALSE;
    USHORT in,out;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;
    InitializeListHead( &ioPortList );

    FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_FILTER_RESOURCE_REQUIREMENTS - Irp: %p\n", Irp) );

    //
    // Pass this irp down to the PDO before proceeding.
    //
    KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine( Irp,
                            FdcPnpComplete,
                            &doneEvent,
                            TRUE,
                            TRUE,
                            TRUE );

    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    if ( ntStatus == STATUS_PENDING ) {

        KeWaitForSingleObject( &doneEvent, Executive, KernelMode, FALSE, NULL );
    }

    //
    //  Modified resources are returned in Irp-IoStatus.Information, otherwise
    //  just use what's in the parameter list.
    //
    if ( Irp->IoStatus.Information == 0 ) {

        Irp->IoStatus.Information = (UINT_PTR)irpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if ( Irp->IoStatus.Information == (UINT_PTR)NULL ) {
            //
            //  NULL List, the PDO freed the incoming resource list but did not
            //  provide a new list.  Complete the IRP with the PDO's status.
            //
            ntStatus = Irp->IoStatus.Status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return( ntStatus );
        }

    }

    resourceRequirementsIn = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;

    FdcDump( FDCSHOW, ("Resource Requirements List = %08X\n", resourceRequirementsIn) );

    if (IsNEC_98) {
        //
        // It is not necessary to modify the resources.
        //
        ntStatus = STATUS_SUCCESS;

        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return ntStatus;
    }

    //
    //  Make a pass through the resource list and determine what resources are
    //  already there as well as the base address for the io port and any
    //  alias ioports.
    //
    ioResourceListIn  = resourceRequirementsIn->List;
    ioResourceDescriptorIn  = ioResourceListIn->Descriptors;

    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: examining %d resources\n", ioResourceListIn->Count));

    for ( i = 0; i < ioResourceListIn->Count && NT_SUCCESS(ntStatus); i++ ) {

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: IoResourceDescritporIn = %p\n",ioResourceDescriptorIn));

        switch ( ioResourceDescriptorIn->Type ) {

        case CmResourceTypeInterrupt:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Interrupt Resource\n"));
            interruptResource = TRUE;
            break;

        case CmResourceTypeDma:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Dma Resource \n"));
            dmaResource = TRUE;
            break;

        case CmResourceTypePort:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Port Resource\n"));
            //
            //  For the ioPorts we will make a list containing each detected
            //  'base' address as well as the currently allocated addresses
            //  on that base.  Later we will use this to request additional
            //  resources if necessary.
            //
            //  First, if this base isn't already in the list, create a new
            //  list entry for it.
            //

            foundBase = FALSE;

            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Examining %p for match\n",ioPortInfo));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Desc Address = %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8));

                if ( ioPortInfo->BaseAddress.LowPart ==
                     (ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8) ) {

                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found %08x in the ioPortList\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));

                    foundBase = TRUE;
                    //
                    //  Add these resources into the resource map for this base
                    //  address.
                    //
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {

                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    break;
                }
            }

            if ( !foundBase ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Creating new ioPortList entry for %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));
                ioPortInfo = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, sizeof(IO_PORT_INFO) );
                if ( ioPortInfo == NULL ) {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlZeroMemory( ioPortInfo, sizeof(IO_PORT_INFO) );
                    ioPortInfo->BaseAddress = ioResourceDescriptorIn->u.Port.MinimumAddress;
                    ioPortInfo->BaseAddress.LowPart &= 0xfffffff8;
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {
                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    InsertTailList( &ioPortList, &ioPortInfo->ListEntry );
                }
            }
            break;

        default:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found unknown resource\n"));
            break;
        }
        ioResourceDescriptorIn++;
    }

    //
    //  If we didn't see any io port resources, we will just return now
    //  since we can't be sure of what to ask for.  The subsequent start
    //  device will surely fail.  This also goes for the interrupt and
    //  dma resource.
    //
    if ( !NT_SUCCESS(ntStatus) ||
         IsListEmpty( &ioPortList ) ||
         !interruptResource ||
         !dmaResource ) {
        //
        //  Clean up the ioPortInfo list
        //
        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Bad Resources, Go directly to jail\n"));
        while ( !IsListEmpty( &ioPortList ) ) {
            links = RemoveHeadList( &ioPortList );
            ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
            ExFreePool( ioPortInfo );
        }

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return ntStatus;
    }

    //
    //  At this point, we know what resources we are currently assigned so
    //  we can determine what additional resources we need to request.  We
    //  need to know the size of the list we need to create so first count
    //  the number of resource descriptors we will have to add to the current
    //  list.
    //
    newDescriptors = 0;

    for ( links = ioPortList.Flink;
          links != &ioPortList;
          links = links->Flink) {

        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

        newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;

        if ( newPortMask & 0x08 ) {
            requestTapeModeRegister = TRUE;
        }

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Counting bits in %x\n",newPortMask));

        while ( newPortMask > 0 ) {
            if ( newPortMask & 0x01 ) {
                newDescriptors++;
            }
            newPortMask >>= 1;
        }
    }

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Create %d new descriptors\n", newDescriptors) );

    //
    //  If we need resources that were not in the list, we will need to
    //  allocate a new resource requirements list that includes these
    //  new resources.
    //
    if ( newDescriptors > 0 ) {

        //
        //  Allocate and initialize a resource requirements list.  Make it big
        //  enough to hold whatever was in the list to start with along with
        //  the new resource list.
        //
        listSize = resourceRequirementsIn->ListSize +
                   resourceRequirementsIn->ListSize +
                   newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);

        //
        //  If we will be requesting the tape mode register we will need to
        //  make an alternate list without it in case we cannot get it.
        //
        if ( requestTapeModeRegister ) {

            listSize = listSize +
                       resourceRequirementsIn->ListSize +
                       newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);
        }

        resourceRequirementsOut = ExAllocatePool( NonPagedPool, listSize );

        if ( resourceRequirementsOut == NULL ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlZeroMemory( resourceRequirementsOut, listSize);

            //
            //  Initialize the IO_RESOURCE_REQUIREMENTS_LIST header.
            //
            resourceRequirementsOut->ListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                                                 sizeof(IO_RESOURCE_LIST);
            resourceRequirementsOut->InterfaceType = resourceRequirementsIn->InterfaceType;
            resourceRequirementsOut->BusNumber = resourceRequirementsIn->BusNumber;
            resourceRequirementsOut->SlotNumber = resourceRequirementsIn->SlotNumber;
            resourceRequirementsOut->Reserved[0] = resourceRequirementsIn->Reserved[0];
            resourceRequirementsOut->Reserved[1] = resourceRequirementsIn->Reserved[1];
            resourceRequirementsOut->Reserved[2] = resourceRequirementsIn->Reserved[2];
            resourceRequirementsOut->AlternativeLists = resourceRequirementsIn->AlternativeLists + 1;
            if ( requestTapeModeRegister ) {
                ++resourceRequirementsOut->AlternativeLists;
            }

            //
            //  Copy the primary list from the incoming IO_RESOURCE_REQUIREMENTS_LIST
            //  to the new list.
            //
            ioResourceListIn  = resourceRequirementsIn->List;
            ioResourceListOut = resourceRequirementsOut->List;

            listSize = sizeof(IO_RESOURCE_LIST) +
                      (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
            RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

            resourceRequirementsOut->ListSize += listSize;

            //
            //  Add any additional resources that we are requesting.
            //
            ioResourceDescriptorOut = (PIO_RESOURCE_DESCRIPTOR)((ULONG_PTR)resourceRequirementsOut +
                                                                           resourceRequirementsOut->ListSize);
            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource desc for each bit in %x\n",newPortMask));

                i = 0;
                while ( newPortMask != 0 ) {

                    if ( newPortMask & 0x01 ) {

                        ioResourceDescriptorOut->Option = IO_RESOURCE_PREFERRED;
                        ioResourceDescriptorOut->Type = CmResourceTypePort;
                        ioResourceDescriptorOut->ShareDisposition = CmResourceShareDeviceExclusive;
                        ioResourceDescriptorOut->Flags = CM_RESOURCE_PORT_IO;

                        ioResourceDescriptorOut->u.Port.Length = 1;
                        ioResourceDescriptorOut->u.Port.Alignment = 1;
                        ioResourceDescriptorOut->u.Port.MinimumAddress.QuadPart =
                        ioResourceDescriptorOut->u.Port.MaximumAddress.QuadPart =
                        ioPortInfo->BaseAddress.QuadPart + (ULONGLONG)i;

                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource descriptor: %p\n",ioResourceDescriptorOut));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Option           = %x\n",ioResourceDescriptorOut->Option          ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Type             = %x\n",ioResourceDescriptorOut->Type            ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->ShareDisposition = %x\n",ioResourceDescriptorOut->ShareDisposition));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Flags            = %x\n",ioResourceDescriptorOut->Flags           ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Length    = %x\n",ioResourceDescriptorOut->u.Port.Length   ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Alignment = %x\n",ioResourceDescriptorOut->u.Port.Alignment));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart = %08x\n",ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart));

                        ioResourceDescriptorOut++;
                    }
                    newPortMask >>= 1;
                    i++;
                }
            }

            if ( requestTapeModeRegister ) {

                ioResourceListIn = ioResourceListOut;
                ioResourceListOut = (PIO_RESOURCE_LIST)ioResourceDescriptorOut;

                ioResourceListOut->Version  = ioResourceListIn->Version;
                ioResourceListOut->Revision = ioResourceListIn->Revision;
                ioResourceListOut->Count    = 0;

                resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_LIST) -
                                                      sizeof(IO_RESOURCE_DESCRIPTOR);

                in = out = 0;

                do {

                    if ( (ioResourceListIn->Descriptors[in].Type != CmResourceTypePort) ||
                         ((ioResourceListIn->Descriptors[in].u.Port.MinimumAddress.LowPart & 0x07) != 0x03) ) {

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        ioResourceListOut->Descriptors[out++] = ioResourceListIn->Descriptors[in++];
                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);
                    } else {
                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Don't add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        in++;
                    }
                } while ( in < ioResourceListIn->Count );
            }

            //
            //  Copy the original list(s) to the end of our new list.
            //
            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy %d existing resource list(s)\n",resourceRequirementsIn->AlternativeLists));
            ioResourceListIn = resourceRequirementsIn->List;
            ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)resourceRequirementsOut +
                                                           resourceRequirementsOut->ListSize);

            for ( in = 0; in < resourceRequirementsIn->AlternativeLists; in++ ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy list %p\n",ioResourceListIn));

                listSize = sizeof(IO_RESOURCE_LIST) +
                          (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
                RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

                ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListOut + listSize);
                ioResourceListIn = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListIn + listSize);
                resourceRequirementsOut->ListSize += listSize;
            }

            FdcDump( FDCSHOW, ("Resource Requirements List = %p\n", resourceRequirementsOut) );

            Irp->IoStatus.Information = (UINT_PTR)resourceRequirementsOut;

            //
            // Free the caller's list
            //
            ExFreePool( resourceRequirementsIn );
            ntStatus = STATUS_SUCCESS;
        }
    }
    //
    //  Clean up the ioPortInfo list
    //
    while ( !IsListEmpty( &ioPortList ) ) {
        links = RemoveHeadList( &ioPortList );
        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
        ExFreePool( ioPortInfo );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine will report any devices that have been enumerated on the
    floppy controller.  If we don't know of any devices yet we will
    enumerate the registry hardware tree.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    PFDC_PDO_EXTENSION pdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    ULONG relationCount;
    ULONG relationLength;
    PDEVICE_RELATIONS relations;
    PLIST_ENTRY entry;
    ULONG returnSize;
    PACPI_FDE_ENUM_TABLE returnBuffer;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations:\n"));

    if ( irpSp->Parameters.QueryDeviceRelations.Type != BusRelations ) {
        //
        // We don't support this
        //
        FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: Type = %d\n", irpSp->Parameters.QueryDeviceRelations.Type));

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        return ntStatus;
    }

    //
    // Tell the plug and play system about all the PDOs.
    //
    // There might also be device relations below and above this FDO,
    // so, be sure to propagate the relations from the upper drivers.
    //

    //
    //  The current number of PDOs
    //
    relationCount = ( Irp->IoStatus.Information == 0 ) ? 0 :
        ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

    //
    //  *ACPI*  Determine if we are no an ACPI machine and, if so, whether it
    //  supports the _FDE method (Floppy Device Enumerate).
    //
    ntStatus = DeviceQueryACPI_SyncExecMethod( fdoExtension->TargetObject,
                                               'EDF_',
                                               0,
                                               NULL,
                                               NULL,
                                               NULL,
                                               ACPI_METHOD_ARGUMENT_BUFFER,
                                               sizeof(ACPI_FDE_ENUM_TABLE),
                                               NULL,
                                               &returnSize,
                                               &returnBuffer );

    FdcDump( FDCSHOW, ("FDC-ACPI _EDF return size = %d\n", returnSize));

    fdoExtension->ACPI_FDE_Valid = FALSE;

    if (NT_SUCCESS(ntStatus)) {

        if (returnSize == sizeof(ACPI_FDE_ENUM_TABLE)) {

            //
            // It's good!
            //
            RtlCopyMemory(&fdoExtension->ACPI_FDE_Data, returnBuffer, returnSize);
            fdoExtension->ACPI_BIOS = TRUE;
            fdoExtension->ProbeFloppyDevices = FALSE;
            fdoExtension->ACPI_FDE_Valid = TRUE;
        }

        //
        // Free the buffer.
        //
        ExFreePool(returnBuffer);

    } else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // ACPI is out there, the BIOS just didn't implement _FDE.
        //
        fdoExtension->ACPI_BIOS = TRUE;
        fdoExtension->ProbeFloppyDevices = FALSE;

    } else {

        fdoExtension->ACPI_BIOS = FALSE;
    }

    //
    //  If we are on an ACPI machine and either we are probing devices or we
    //  have valid _FDE data enumerate via ACPI methods.  If we are not probing
    //  devices and there is no _FDE method available, we will just rely on Bios
    //  data collected by ntdetect.
    //
    if ( fdoExtension->ACPI_BIOS &&
         (fdoExtension->ACPI_FDE_Valid || fdoExtension->ProbeFloppyDevices) ) {

        ntStatus = FdcEnumerateAcpiBios( DeviceObject );

        if ( !NT_SUCCESS(ntStatus) ) {

            return ntStatus;
        }

    } else {

        INTERFACE_TYPE InterfaceType;
        //
        //  Query the registry hardware tree to find out how many floppy
        //  drives were reported by the firmware.
        //
        //  Notice that we are enumerating ALL floppy devices in the BIOS.  We
        //  will filter out any devices not connected to this controller in the
        //  callback routine.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;
            CONFIGURATION_TYPE Fp = FloppyDiskPeripheral;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 &Fp,
                                                 NULL,
                                                 FdcConfigCallBack,
                                                 fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return ntStatus;
            }
        }
    }

    //
    //  Reset the probe flag so we don't do it again on the next query.
    //
    fdoExtension->ProbeFloppyDevices = FALSE;

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: My relations count - %d\n", fdoExtension->NumPDOs));

    if (!fdoExtension->NumPDOs) {

        //
        // Nothing to add.
        //
        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( fdoExtension->TargetObject, Irp );
    }

    relationLength = sizeof(DEVICE_RELATIONS) +
        (relationCount + fdoExtension->NumPDOs) * sizeof (PDEVICE_OBJECT);

    ASSERT(relationLength);

    relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, relationLength);

    if ( relations == NULL ) {

        if (relationCount) {

            //
            // Don't hide existing children
            //
            IoSkipCurrentIrpStackLocation( Irp );
            return IoCallDriver( fdoExtension->TargetObject, Irp );

        } else {

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Copy in the device objects so far
    //
    if ( relationCount ) {
        RtlCopyMemory( relations->Objects,
                       ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                       relationCount * sizeof (PDEVICE_OBJECT));
                relations->Count = relationCount;
    } else {
           relations->Count = 0;
        }

    //
    // For each PDO on this bus add a pointer to the device relations
    // buffer, being sure to take out a reference to that object.
    // The PlugPlay system will dereference the object when it is done with
    // it and free the device relations buffer.
    //
    for (entry = fdoExtension->PDOs.Flink;
         entry != &fdoExtension->PDOs;
         entry = entry->Flink) {

        pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );
        if (!(pdoExtension->ReportedMissing)) {

            relations->Objects[relationCount++] = pdoExtension->Self;
            ObReferenceObject( pdoExtension->Self );

            //
            // If this fires, we somehow added more children than NumPDOs, and
            // we haven't enough memory!!!
            //
            ASSERT(relationCount <= relations->Count+fdoExtension->NumPDOs);
        }
    }
    relations->Count = relationCount;

    //
    // Set up and pass the IRP further down the stack
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    if ( Irp->IoStatus.Information != 0) {

        ExFreePool ((PVOID) Irp->IoStatus.Information);
    }

    Irp->IoStatus.Information = (UINT_PTR) relations;

    IoSkipCurrentIrpStackLocation( Irp );
    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    return ntStatus;
}

NTSTATUS
FdcEnumerateAcpiBios(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Enumerate floppy devices on an ACPI machine.  If ACPI has provided a _FDE
    method we will use that information to enumerate devices.  We may or not
    verify the _FDE data with a device probe.  If no _FDE method is available
    we will just assume a floppy drive at each address (4) and probe those
    devices.
    NOTE - if we are not probing devices and there is no _FDE method we shouldn't
    get here.  Rather, we will rely on the BIOS data collected by ntdetect to
    enumerate floppy devices.

Arguments:

    DeviceObject - a pointer to the device object being started.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)DeviceObject->DeviceExtension;
    UCHAR peripheralNumber;
    PLIST_ENTRY entry ;
    PFDC_PDO_EXTENSION pdoExtension;
    BOOLEAN alreadyEnumerated;
    BOOLEAN newlyMissing;
    BOOLEAN newlyPresent;

    //
    //  If we got floppy enumeration information from ACPI (via _FDE method)
    //  then probe and create devices as necessary.
    //
    fdoExtension->BusNumber = 0;

    //
    //  For each device, check the ACPI state if we have one.  If ACPI
    //  indicates that a device is present then probe if we should and
    //  create a PDO if we verify that a device is present.
    //
    for ( peripheralNumber = 0; peripheralNumber <= 3; peripheralNumber++ ) {

        //
        //  if we already have a pdo for this device don't create a new device
        //
        alreadyEnumerated = FALSE;
        newlyMissing = FALSE;
        newlyPresent = FALSE;
        entry = fdoExtension->PDOs.Flink;
        while ( entry != &fdoExtension->PDOs && NT_SUCCESS(ntStatus) ) {

            pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );

            //
            // If we found someone already listed as missing, keep going.
            //
            if (( pdoExtension->PeripheralNumber == peripheralNumber )&&
                (!pdoExtension->ReportedMissing)) {

                alreadyEnumerated = TRUE;
                break;
            }
            entry = entry->Flink ;
        }

        if (alreadyEnumerated) {

            if ( fdoExtension->ACPI_FDE_Valid ) {

                if ( !fdoExtension->ACPI_FDE_Data.DrivePresent[peripheralNumber] ) {

                    newlyMissing = TRUE;
                }

            } else if ( fdoExtension->ProbeFloppyDevices ) {

                ntStatus = FdcProbeFloppyDevice( DeviceObject, peripheralNumber );

                if (!NT_SUCCESS(ntStatus)) {

                    newlyMissing = TRUE;
                }
            }

        } else {

            if ( fdoExtension->ACPI_FDE_Valid ) {

                if ( fdoExtension->ACPI_FDE_Data.DrivePresent[peripheralNumber] ) {
                    newlyPresent = TRUE;
                }

            } else if ( fdoExtension->ProbeFloppyDevices ) {

                ntStatus = FdcProbeFloppyDevice( DeviceObject, peripheralNumber );
                if (NT_SUCCESS(ntStatus)) {

                    newlyPresent = TRUE;
                }

            }
        }

        //
        //  If we have a floppy device, create a PDO for it.
        //
        if (newlyPresent) {

            FdcCreateFloppyPdo( fdoExtension, peripheralNumber );

        } else if (newlyMissing) {

            pdoExtension->ReportedMissing = TRUE;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FdcBusConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This routine is used to acquire all of the configuration
    information for a floppy disk controller.

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG apiSupported;
    WCHAR idstr[200];
    UNICODE_STRING str;
    PFILE_OBJECT enablerFileObject;      // file object is not needed,  but returned by API
    PDEVICE_OBJECT enablerDeviceObject;
    BOOLEAN enablerSupported;

    FdcDump( FDCSHOW, ("FdcBusConfigCallBack:\n") );

    //
    //  The first thing to do is to go out and look for an enabler.  We
    //  know we are dealing with one if there is a registry value called
    //  APISupported.
    //
    str.Length = 0;
    str.MaximumLength = 200;
    str.Buffer = idstr;

    RtlZeroMemory( &paramTable[0], sizeof(paramTable) );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"APISupported";
    paramTable[0].EntryContext = &str;
    paramTable[0].DefaultType = REG_SZ;
    paramTable[0].DefaultData = L"";
    paramTable[0].DefaultLength = sizeof(WCHAR);


    ntStatus = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                       PathName->Buffer,
                                       &paramTable[0],
                                       NULL,
                                       NULL);
    if ( !NT_SUCCESS( ntStatus ) ) {
        str.Buffer[0] = 0;
    }

    enablerSupported = FALSE;

    if (str.Buffer[0] != 0) {

        FdcDump(FDCINFO,
               ("FdcBusConfigCallBack: Got registry setting for EnablerAPI = %s\n",
                str.Buffer) );

        ntStatus = IoGetDeviceObjectPointer( &str,
                                             FILE_READ_ACCESS,
                                             &enablerFileObject,
                                             &enablerDeviceObject);

        if ( NT_SUCCESS(ntStatus) ) {

            //
            //  Dereference the object since we don't need it any more.
            //
            ObDereferenceObject( enablerFileObject );
            enablerSupported = TRUE;

        } else {

            FdcDump( FDCDBGP,
                     ("FdcBusConfigCallBack: failed to open channel to device\n",
                     str.Buffer) );
        }
    }

    //
    //  Only create a device here if we found an enabler device.  We assume that
    //  all of the legitimate floppy controllers have been or will be firmware
    //  enumerated.
    //
    if ( enablerSupported ) {

        RtlInitUnicodeString( &pdoName, L"\\Device\\TapeEnabler" );

        ntStatus = IoCreateDevice( fdoExtension->Self->DriverObject,
                                   sizeof(FDC_PDO_EXTENSION),
                                   &pdoName,
                                   FILE_DEVICE_BUS_EXTENDER,
                                   FILE_DEVICE_SECURE_OPEN,
                                   FALSE,
                                   &newPdo);

        FdcDump( FDCSHOW, ("FdcBusConfigCallBack: Created Tape Enabler Device\n") );

        if ( !NT_SUCCESS(ntStatus) ) {

            FdcDump( FDCSHOW, ("FdcBusConfigCallBack: Error - %08x\n", ntStatus) );
            return ntStatus;

        }

        pdoExtension = (PFDC_PDO_EXTENSION) newPdo->DeviceExtension;

        pdoExtension->TargetObject = fdoExtension->Self;

        pdoExtension->IsFDO = FALSE;
        pdoExtension->Self = newPdo;
        pdoExtension->DeviceType = FloppyControllerDevice;

        pdoExtension->ParentFdo = fdoExtension->Self;

        pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet

        newPdo->Flags |= DO_DIRECT_IO;
        newPdo->Flags |= DO_POWER_PAGABLE;
        newPdo->StackSize += fdoExtension->Self->StackSize;
        newPdo->Flags &= ~DO_DEVICE_INITIALIZING;

        InsertTailList(&fdoExtension->PDOs, &pdoExtension->PdoLink);
        fdoExtension->NumPDOs++;

        IoInvalidateDeviceRelations( fdoExtension->UnderlyingPDO, BusRelations );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FdcConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    USHORT resourceCount;
    BOOLEAN thisController;
    PCM_FULL_RESOURCE_DESCRIPTOR controllerData;
    PLIST_ENTRY entry ;
    PFDC_PDO_EXTENSION pdoExtension;
    PCM_FLOPPY_DEVICE_DATA fDeviceData;
    PCM_FULL_RESOURCE_DESCRIPTOR peripheralData;
    USHORT resCount;

    FdcDump( FDCSHOW, ("FdcConfigCallBack:\n") );

    //
    //  Verify that this floppy disk drive is on the current
    //  floppy disk controller.
    //
    thisController = FALSE;
    controllerData = (PCM_FULL_RESOURCE_DESCRIPTOR)
        (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
        ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

    //
    // Check if the information from the registry for this device
    // is valid.
    //

    if (!(((PUCHAR)PeripheralInformation[IoQueryDeviceConfigurationData]) +
        PeripheralInformation[IoQueryDeviceConfigurationData]->DataLength)) {

        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;

    }

    peripheralData = (PCM_FULL_RESOURCE_DESCRIPTOR)
        (((PUCHAR)PeripheralInformation[IoQueryDeviceConfigurationData]) +
        PeripheralInformation[IoQueryDeviceConfigurationData]->DataOffset);

    for ( resourceCount = 0;
          resourceCount < controllerData->PartialResourceList.Count;
          resourceCount++ ) {

        PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
            &controllerData->PartialResourceList.PartialDescriptors[resourceCount];

        FdcDump( FDCSHOW, ("FdcConfigCallBack: resource type = %x\n",partial->Type) );

        switch (partial->Type) {

        case CmResourceTypePort: {

            PUCHAR address;

            address = FdcGetControllerBase( BusType,
                                            BusNumber,
                                            partial->u.Port.Start,
                                            partial->u.Port.Length,
                                            (BOOLEAN)!!partial->Flags );

            FdcDump( FDCSHOW, ("FdcConfigCallBack: DriveControl = %04x %04x\n",fdoExtension->ControllerAddress.DriveControl,address + (IsNEC_98 ? 4 : 2) ));
            if ( fdoExtension->ControllerAddress.DriveControl == address + (IsNEC_98 ? 4 : 2)) {
                thisController = TRUE;
            }
            break;
        }

        default:

            break;
        }
    }

    //
    //  If this floppy device is not on the current controller (based on the
    //  io resources, we will not enumerate it at this time.
    //
    if ( !thisController ) {

        return STATUS_SUCCESS;
    }

    //
    // Verify if this is a super floppy. If so we skip it.
    //
    for (resCount = 0;
         resCount < peripheralData->PartialResourceList.Count;
         resCount++) {

       PCM_PARTIAL_RESOURCE_DESCRIPTOR peripartial =
           &peripheralData->PartialResourceList.PartialDescriptors[resCount];

       PCM_FLOPPY_DEVICE_DATA fDeviceData;

       if (peripartial == NULL) {
          continue;
       } else if ((peripartial->Type) != CmResourceTypeDeviceSpecific) {
          continue;
       }

       fDeviceData = (PCM_FLOPPY_DEVICE_DATA)(peripartial + 1);
       if ((fDeviceData != NULL) && 
           (fDeviceData->MaxDensity & 0x80000000)) {
          return STATUS_SUCCESS;
       }
    }

    //
    //  if we already have a pdo for this device don't enumerate it again.
    //
    entry = fdoExtension->PDOs.Flink;
    while ( entry != &fdoExtension->PDOs ) {

        pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );

        if (( pdoExtension->PeripheralNumber == PeripheralNumber ) &&
            (!pdoExtension->ReportedMissing)) {

            return STATUS_SUCCESS;
        }
        entry = entry->Flink ;
    }

    fdoExtension->BusType = BusType;
    fdoExtension->BusNumber = BusNumber;
    fdoExtension->ControllerNumber = ControllerNumber;

    if ( fdoExtension->ProbeFloppyDevices ) {

        ntStatus = FdcProbeFloppyDevice( fdoExtension->Self, (UCHAR)PeripheralNumber );

    } else {

        ntStatus = STATUS_SUCCESS;
    }

    if ( NT_SUCCESS(ntStatus) ) {

        FdcCreateFloppyPdo( fdoExtension, (UCHAR)PeripheralNumber );
    }

    return STATUS_SUCCESS;
}

VOID
FdcCreateFloppyPdo(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN UCHAR PeripheralNumber
    )
{
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    WCHAR pdoNameBuffer[64];
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    USHORT nameIndex = 0;

    do {

        swprintf( pdoNameBuffer, L"\\Device\\FloppyPDO%x", nameIndex++ );
        RtlInitUnicodeString( &pdoName, pdoNameBuffer );

        ntStatus = IoCreateDevice( FdoExtension->Self->DriverObject,
                                   sizeof(FDC_PDO_EXTENSION),
                                   &pdoName,
                                   FILE_DEVICE_MASS_STORAGE,
                                   FILE_DEVICE_SECURE_OPEN,
                                   FALSE,
                                   &newPdo);

    } while ( ntStatus == STATUS_OBJECT_NAME_COLLISION );

    if ( !NT_SUCCESS(ntStatus) ) {

        FdcDump( FDCSHOW | FDCPNP,
                 ("Fdc: FdcCreateFloppyPdo: Error - %08x\n", ntStatus) );
        return;
    }

    FdcDump( FDCSHOW | FDCPNP,
             ("FdcCreateFloppyPdo: DeviceObject Name - %S\n", pdoNameBuffer) );

    pdoExtension = (PFDC_PDO_EXTENSION)newPdo->DeviceExtension;

    pdoExtension->TargetObject = FdoExtension->Self;

    pdoExtension->IsFDO = FALSE;
    pdoExtension->Self = newPdo;
    pdoExtension->DeviceType = FloppyDiskDevice;

    pdoExtension->ParentFdo = FdoExtension->Self;

    pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet
    pdoExtension->ReportedMissing = FALSE;

    pdoExtension->PeripheralNumber = PeripheralNumber;

    newPdo->Flags |= DO_DIRECT_IO;
    newPdo->Flags |= DO_POWER_PAGABLE;
    newPdo->StackSize += FdoExtension->Self->StackSize;
    newPdo->Flags &= ~DO_DEVICE_INITIALIZING;

    // IoGetConfigurationInformation()->FloppyCount++;

    InsertTailList(&FdoExtension->PDOs, &pdoExtension->PdoLink);
    FdoExtension->NumPDOs++;
}

NTSTATUS
FdcCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    FdcDump(
        FDCSHOW,
        ("FdcCreateClose...\n")
        );

    //
    // Null operation.  Do not give an I/O boost since
    // no I/O was actually done.  IoStatus.Information should be
    // FILE_OPENED for an open; it's undefined for a close.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}


NTSTATUS
FdcSystemControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    IRP_MJ_SYSTEM_CONTROL dispatch routine. Currently, we don't handle
    this. So, if this is FDO just pass it to the lower driver. If this
    is PDO complete the irp with changing the irp status.
    
Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{

    PFDC_EXTENSION_HEADER  extensionHeader;
    PFDC_FDO_EXTENSION     fdoExtension;
    NTSTATUS status;

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        fdoExtension = (PFDC_FDO_EXTENSION) DeviceObject->DeviceExtension;
        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( fdoExtension->TargetObject, Irp );
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
FdcDeviceControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this device IOCTL request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PFDC_EXTENSION_HEADER  extensionHeader;
    PFDC_FDO_EXTENSION     fdoExtension;

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        fdoExtension = (PFDC_FDO_EXTENSION) DeviceObject->DeviceExtension;
        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( fdoExtension->TargetObject, Irp );
    }

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
FdcInternalDeviceControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this Pnp request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_EXTENSION_HEADER extensionHeader;
    KIRQL oldIrq;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        ntStatus = FdcFdoInternalDeviceControl( DeviceObject, Irp );

    } else {

        ntStatus = FdcPdoInternalDeviceControl( DeviceObject, Irp );
    }

    return ntStatus;
}

NTSTATUS
FdcPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    BOOLEAN isFDO;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;

    pdoExtension = (PFDC_PDO_EXTENSION)DeviceObject->DeviceExtension;
    fdoExtension = (PFDC_FDO_EXTENSION)pdoExtension->ParentFdo->DeviceExtension;

    if ( pdoExtension->Removed) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
        return ntStatus;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    FdcDump( FDCSHOW,
             ("FdcPdoInternalDeviceControl: %x\n",
             irpSp->Parameters.DeviceIoControl.IoControlCode) );

    switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

    case IOCTL_DISK_INTERNAL_GET_ENABLER: {

        if ( pdoExtension->DeviceType == FloppyControllerDevice ) {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = TRUE;

        } else {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = FALSE;
        }

        ntStatus = STATUS_SUCCESS;

        break;
        }

    case IOCTL_DISK_INTERNAL_GET_FDC_INFO:

        FcReportFdcInformation( pdoExtension, fdoExtension, irpSp );

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        IoSkipCurrentIrpStackLocation( Irp );

        //
        // Call the driver and request the operation
        //
        return IoCallDriver( pdoExtension->TargetObject, Irp );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;
    BOOLEAN powerQueueClear = FALSE;
    PLIST_ENTRY deferredRequest;
    PIRP currentIrp;
    ULONG ioControlCode;
    PFDC_DISK_CHANGE_PARMS fdcDiskChangeParms;
    PUCHAR dataRate;
    UCHAR tapeMode;
    PUCHAR precomp;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PSET_HD_BIT_PARMS setHdBitParams;

    fdoExtension = (PFDC_FDO_EXTENSION)DeviceObject->DeviceExtension;

    #if DBG
      if (Irp == NULL) {
         FdcDump(FDCSHOW, ("Coming out of sleep state. "));
         FdcDump(FDCSHOW, ("Going to process queued requests.\n"));
      }
    #endif
    
    if (FdcInSetupMode) {
       //
       // We should not stop retries when we are in
       // setup mode. Retries are not attempted too
       // often only during normal boot (non-setup boot).
       //
       fdoExtension->HardwareFailed = FALSE;
    }

    if ( fdoExtension->HardwareFailed ) {
        LARGE_INTEGER currentTime;

        KeQuerySystemTime( &currentTime );
        if ( fdoExtension->FdcFailedTime.QuadPart ) {
            if ( currentTime.QuadPart > (fdoExtension->FdcFailedTime.QuadPart + (10000 * 60)) ) {
                fdoExtension->HardwareFailed = FALSE;
                fdoExtension->FdcFailedTime.QuadPart = 0;
            }
        } else {
            fdoExtension->FdcFailedTime.QuadPart = currentTime.QuadPart;
        }
    }

    if (Irp != NULL) {
       InterlockedIncrement( &fdoExtension->OutstandingRequests );

       if ( fdoExtension->Removed ) {
         //
         // This device has received the PlugPlay remove IRP.  It will no longer
         // respond to external requests.
         //
          if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
             KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
          }
          ntStatus = STATUS_DELETE_PENDING;
          Irp->IoStatus.Status = ntStatus;
          IoCompleteRequest( Irp, IO_NO_INCREMENT );
          return ntStatus;
       }

      //
      //  If we are in a non-working power state then just queue the irp
      //  for later execution.
      //
       if ( fdoExtension->Paused ||
            (fdoExtension->CurrentPowerState == PowerDeviceD3) ) {

          IoMarkIrpPending( Irp );
          ExInterlockedInsertTailList( &fdoExtension->PowerQueue,
                                       &Irp->Tail.Overlay.ListEntry,
                                       &fdoExtension->PowerQueueSpinLock );

          ntStatus = STATUS_PENDING;
          return ntStatus;
       }
    }

    do {

        deferredRequest = ExInterlockedRemoveHeadList( &fdoExtension->PowerQueue,
                                                       &fdoExtension->PowerQueueSpinLock );

        if ( deferredRequest == NULL ) {

            if (Irp == NULL) {
               ntStatus = STATUS_SUCCESS;
               break;
            }
            currentIrp = Irp;
            powerQueueClear = TRUE;

        } else {

            currentIrp = CONTAINING_RECORD( deferredRequest, IRP, Tail.Overlay.ListEntry );
        }

        irpSp = IoGetCurrentIrpStackLocation( currentIrp );

        FdcDump( FDCSHOW,
                 ("FdcFdoInternalDeviceControl: %x\n",
                 irpSp->Parameters.DeviceIoControl.IoControlCode) );

        ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

        //
        //  GET_ENABLER and GET_FDC_INFO are handled in the PDO, not the FDO.
        //
        if ( ioControlCode == IOCTL_DISK_INTERNAL_GET_ENABLER ||
             ioControlCode == IOCTL_DISK_INTERNAL_GET_FDC_INFO ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        //
        //  If the controller is not acquired (in use) then then only
        //  operation that is allowed is to acquire the fdc.
        //
        } else if ( !fdoExtension->ControllerInUse &&
                    ioControlCode != IOCTL_DISK_INTERNAL_ACQUIRE_FDC ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        } else {

            switch ( ioControlCode ) {

            case IOCTL_DISK_INTERNAL_ACQUIRE_FDC:

                //
                // Try to Acquire the Fdc.  If the Fdc is busy, this call will
                // time out.
                //
                ntStatus = FcAcquireFdc(
                                    fdoExtension,
                                    (PLARGE_INTEGER)irpSp->
                                    Parameters.DeviceIoControl.Type3InputBuffer );
                //
                // Return the device object of the last device that called this
                // driver.  This can be used to determine if any other drivers
                // have messed with the fdc since it was last acquired.
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    fdoExtension->LastDeviceObject;

                    //
                    // FDC has been acquired. Set TapeEnumerationPending to
                    // TRUE to indicate FDC is in use.
                    //
                    fdoExtension->TapeEnumerationPending = TRUE;
                }
                break;

            case IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE:

                //
                // Turn the motor on and select a floppy channel
                //
                ntStatus = FcTurnOnMotor( fdoExtension, (PFDC_ENABLE_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer );

                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND:

                issueCommandParms =
                    (PISSUE_FDC_COMMAND_PARMS)
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                ntStatus = FcIssueCommand( fdoExtension,
                                           issueCommandParms->FifoInBuffer,
                                           issueCommandParms->FifoOutBuffer,
                                           issueCommandParms->IoHandle,
                                           issueCommandParms->IoOffset,
                                           issueCommandParms->TransferBytes );


                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

                IoMarkIrpPending( currentIrp );

                IoStartPacket( DeviceObject,
                               currentIrp,
                               NULL,
                               NULL );

                ntStatus = STATUS_PENDING;

                break;

            case IOCTL_DISK_INTERNAL_RESET_FDC:

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );
                break;

            case IOCTL_DISK_INTERNAL_RELEASE_FDC:

                ntStatus = FcReleaseFdc( fdoExtension );
                //
                // Save the DeviceObject of the releasing device.  This is
                // returned with the subsequent acquire fdc request and
                // can be used to determine whether the floppy controller
                // has been messed with between release and acquisition
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    fdoExtension->LastDeviceObject =
                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    //
                    // FDC is no longer in use. Set TapeEnumerationPending
                    // to FALSE.
                    //
                    fdoExtension->TapeEnumerationPending = FALSE;
                }

                break;

            case IOCTL_DISK_INTERNAL_GET_ADAPTER_BUFFER:
                //
                // Allocate an MDL for the passed in buffer.
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                adapterBufferParms->Handle =
                             IoAllocateMdl( adapterBufferParms->IoBuffer,
                                            adapterBufferParms->TransferBytes,
                                            FALSE,
                                            FALSE,
                                            NULL );

                if ( adapterBufferParms->Handle == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    MmBuildMdlForNonPagedPool( adapterBufferParms->Handle );

                    ntStatus = STATUS_SUCCESS;
                }

                break;

            case IOCTL_DISK_INTERNAL_FLUSH_ADAPTER_BUFFER:
                //
                // Free the MDL
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                if ( adapterBufferParms->Handle != NULL ) {

                    IoFreeMdl( adapterBufferParms->Handle );
                }

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_FDC_START_READ:
            case IOCTL_DISK_INTERNAL_FDC_START_WRITE:

                ntStatus = STATUS_SUCCESS;

                if ( fdoExtension->FdcEnablerSupported ) {

                    FDC_MODE_SELECT fdcModeSelect;

                    fdcModeSelect.structSize = sizeof(fdcModeSelect);
                    //
                    // Reading from the media means writing to DMA memory and
                    // visa-versa for writing to the media.
                    //
                    if ( irpSp->Parameters.DeviceIoControl.IoControlCode ==
                         IOCTL_DISK_INTERNAL_FDC_START_READ ) {

                        fdcModeSelect.DmaDirection = FDC_WRITE_TO_MEMORY;

                    } else {

                        fdcModeSelect.DmaDirection = FDC_READ_FROM_MEMORY;
                    }

                    ntStatus = FcFdcEnabler(
                                    fdoExtension->FdcEnablerDeviceObject,
                                    IOCTL_SET_FDC_MODE,
                                    &fdcModeSelect);
                }
                break;

            case IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE:

                ntStatus = FcTurnOffMotor( fdoExtension );

                break;

            case IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE:

                FdcDump(FDCINFO, ("Fdc: Read Disk Change\n") );

                fdcDiskChangeParms =
                    (PFDC_DISK_CHANGE_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                if (IsNEC_98) {
                    if((fdoExtension->ResultStatus0[fdcDiskChangeParms->DriveOnValue] &
                        STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY){

                        fdcDiskChangeParms->DriveStatus = DSKCHG_DISKETTE_REMOVED;
                    } else {

                        fdoExtension->ResultStatus0[fdcDiskChangeParms->DriveOnValue] = 0;
                        fdcDiskChangeParms->DriveStatus = DSKCHG_RESERVED;
                    }
                } else { // (IsNEC_98)
                    fdcDiskChangeParms->DriveStatus = READ_CONTROLLER(
                                                            fdoExtension->ControllerAddress.DRDC.DiskChange );
                    //
                    //  If we just waked up from hibernation, simulate a disk
                    //  change event so the upper levels will be sure to check
                    //  this disk.
                    //
                    if ( fdoExtension->WakeUp ) {

                        fdcDiskChangeParms->DriveStatus |= DSKCHG_DISKETTE_REMOVED;
                        fdoExtension->WakeUp = FALSE;
                    }
                } // (IsNEC_98)

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE:

                if (IsNEC_98) {
                    //
                    // NEC98 have no function and have no DRDC.DataRate register.
                    //
                } else { // (IsNEC_98)
                    dataRate =
                        (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    FdcDump(FDCINFO, ("Fdc: Write Data Rate: %x\n", *dataRate) );

                    WRITE_CONTROLLER( fdoExtension->ControllerAddress.DRDC.DataRate,
                                      *dataRate );

                } // (IsNEC_98)
                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE:

                if (IsNEC_98) {
                    //
                    // NEC98 have no Tape register.
                    //
                } else { // (IsNEC_98)

                    tapeMode = READ_CONTROLLER( fdoExtension->ControllerAddress.Tape );
                    tapeMode &= 0xfc;
                    tapeMode |=
                        *((PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                    FdcDump(FDCINFO,
                            ("Fdc: Write Tape Mode Register: %x\n", tapeMode)
                            );

                    WRITE_CONTROLLER(
                        fdoExtension->ControllerAddress.Tape,
                        tapeMode );

                } // (IsNEC_98)
                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP:

                precomp = (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                FdcDump(FDCINFO,
                        ("Fdc: Write Precomp: %x\n", *precomp)
                        );

                WRITE_CONTROLLER(
                    fdoExtension->ControllerAddress.Status,
                    *precomp );

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_HD_BIT:

                if (IsNEC_98) {

                    FdcDump(FDCINFO,
                            ("Fdc: Set Hd Bit: \n")
                            );
                    setHdBitParams = (PSET_HD_BIT_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    FdcHdbit(DeviceObject, fdoExtension, setHdBitParams);

                    ntStatus = STATUS_SUCCESS;

                    break;
                } // (IsNEC_98)

                //
                // If not NEC98, then pass through to "default:".
                //

            default:
                //
                // Mark the Irp pending and queue it.
                //
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;

                break;
            }
        }

        if ( ntStatus != STATUS_PENDING ) {

            if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
                KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
            }
            currentIrp->IoStatus.Status = ntStatus;
            IoCompleteRequest( currentIrp, IO_DISK_INCREMENT );
        }

    } while ( !powerQueueClear );

    return ntStatus;
}

VOID
FcReportFdcInformation(
    IN      PFDC_PDO_EXTENSION PdoExtension,
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN OUT  PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine reports information about the Floppy Disk Controller
    that a higher level driver might need; primarily information
    regarding the DMA Adapter.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_SUCCESS

--*/

{
    PFDC_INFO fdcInfo;
    PACPI_FDI_DATA fdiData;
    ULONG bufferCount;
    ULONG bufferSize;
    ULONG i;
    NTSTATUS ntStatus;
    USHORT argumentType[16];
    USHORT argumentSize[16];

    FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

    FdcDump( FDCINFO, ("Fdc: Report FDC Information\n") );

    fdcInfo = (PFDC_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // save the requested buffer count and buffer size.
    //
    bufferCount = fdcInfo->BufferCount;
    bufferSize =  fdcInfo->BufferSize;

    //
    // fill in the floppy controller hardware information
    //
    fdcInfo->BusType = FdoExtension->BusType;
    fdcInfo->BusNumber = FdoExtension->BusNumber;
    fdcInfo->ControllerNumber = FdoExtension->ControllerNumber;
    if (IsNEC_98) {
        UCHAR floppyEquip;
        ULONG disketteCount = 0;
        ULONG i;

        floppyEquip = FdoExtension->FloppyEquip;

        //
        // Make PeripheralNumber.
        //
        for (i = 0 ; i < 4 ; i++) {

            if ((floppyEquip & 0x1) != 0) {

                disketteCount++;

                if(disketteCount > PdoExtension->PeripheralNumber){

                    break;
                }
            }
            floppyEquip = floppyEquip >> 1;
        }

        fdcInfo->UnitNumber = (UCHAR)i;
    } else {
        //
        // Only NEC98 is using it now, put Zero into UnitNumber.
        //
        fdcInfo->UnitNumber = 0;
    }
    fdcInfo->PeripheralNumber = PdoExtension->PeripheralNumber;

    fdcInfo->FloppyControllerType = FdoExtension->FdcType;
    fdcInfo->SpeedsAvailable = FdoExtension->FdcSpeeds;

    fdcInfo->MaxTransferSize = FdoExtension->NumberOfMapRegisters * PAGE_SIZE;

    fdcInfo->BufferSize = 0;
    fdcInfo->BufferCount = 0;

    if ( bufferSize <= FdoExtension->BufferSize ) {

        fdcInfo->BufferSize = bufferSize;
        fdcInfo->BufferCount = MIN( bufferCount,
                                    FdoExtension->BufferCount );
        FdoExtension->BuffersRequested = MAX( fdcInfo->BufferCount,
                                              FdoExtension->BuffersRequested );
    }

    for ( i = 0 ; i < fdcInfo->BufferCount ; i++ ) {

        fdcInfo->BufferAddress[i].Logical =
                                    FdoExtension->TransferBuffers[i].Logical;
        fdcInfo->BufferAddress[i].Virtual =
                                    FdoExtension->TransferBuffers[i].Virtual;
    }

    //
    // *ACPI* call _FDI method to get data on this drive. Note that section
    // 6.2.5 says _FDI is a package, and lists BYTE and WORD as size fields for
    // the package. Of course 32bit integer, buffer, and string are the only
    // legal values, so we treat this is a package of 16 integers.
    //
    fdcInfo->AcpiBios = FdoExtension->ACPI_BIOS;

    if ( fdcInfo->AcpiBios ) {

        for(i=0; i<16; i++) {

            argumentType[i] = ACPI_METHOD_ARGUMENT_INTEGER;
            argumentSize[i] = sizeof(ULONG);
        }

        ntStatus = DeviceQueryACPI_SyncExecMethodForPackage( PdoExtension->Self,
                                                             'IDF_',
                                                             0,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             16,
                                                             sizeof(ACPI_FDI_DATA),
                                                             argumentType,
                                                             argumentSize,
                                                             &fdiData );

        if (NT_SUCCESS(ntStatus)) {

            //
            // Got valid data from acpi.
            //
                fdcInfo->AcpiFdiSupported = TRUE;
            fdcInfo->AcpiFdiData = *fdiData;

            //
            // Free the buffer.
            //
            ExFreePool(fdiData);

        } else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // ACPI is out there, the BIOS just didn't implement _FDI for this
            // device (perhaps an add-on controller).
            //
                fdcInfo->AcpiFdiSupported = FALSE;

        } else {

            //
            // No ACPI.
            //
            fdcInfo->AcpiBios = FdoExtension->ACPI_BIOS;
            fdcInfo->AcpiFdiSupported = FALSE;
        }
    }

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;
}

VOID
FdcStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus;
    ULONG formatExParametersSize;
    PUCHAR diskChange;
    PUCHAR dataRate;
    PUCHAR tapeMode;
    PUCHAR precomp;
    PFDC_FDO_EXTENSION fdoExtension;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PKDEVICE_QUEUE_ENTRY request;

    FdcDump( FDCSHOW, ("FdcStartIo...\n") );

    fdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

        case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

            issueCommandParms =
                (PISSUE_FDC_COMMAND_PARMS)
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                fdoExtension->CurrentDeviceObject = DeviceObject;
                fdoExtension->AllowInterruptProcessing = TRUE;
                fdoExtension->CommandHasResultPhase = FALSE;
                fdoExtension->InterruptTimer =
                    issueCommandParms->TimeOut ?
                    issueCommandParms->TimeOut + 1 : START_TIMER;
                fdoExtension->CurrentIrp = Irp;

            }

            ntStatus = FcStartCommand( fdoExtension,
                                       issueCommandParms->FifoInBuffer,
                                       issueCommandParms->FifoOutBuffer,
                                       issueCommandParms->IoHandle,
                                       issueCommandParms->IoOffset,
                                       issueCommandParms->TransferBytes,
                                       FALSE );

            if ( NT_SUCCESS( ntStatus )) {

                if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                    ntStatus = STATUS_PENDING;

                } else {

                    ntStatus = FcFinishCommand(
                                    fdoExtension,
                                    issueCommandParms->FifoInBuffer,
                                    issueCommandParms->FifoOutBuffer,
                                    issueCommandParms->IoHandle,
                                    issueCommandParms->IoOffset,
                                    issueCommandParms->TransferBytes,
                                    FALSE );

                }

            }

            break;

        default: {

            FdcDump(
                FDCDBGP,
                ("Fdc: invalid device request %x\n",
                irpSp->Parameters.DeviceIoControl.IoControlCode)
                );

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }
    }

    if ( ntStatus != STATUS_PENDING ) {
        Irp->IoStatus.Status = ntStatus;
        if (!NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus )) {

            IoSetHardErrorOrVerifyDevice( Irp, DeviceObject );
        }

        IoStartNextPacket( DeviceObject, FALSE );
    }
}

NTSTATUS
FcAcquireFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN      PLARGE_INTEGER  TimeOut
    )

/*++

Routine Description:

    This routine acquires the floppy disk controller.  This includes
    allocating the adapter channel and connecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    DeviceObject    - Device object for the current device

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,
           ("Fdc: Acquire the Floppy Controller\n")
           );

    //
    // Wait for the Fdc, either from the enabler or directly here.  Semaphores
    // are used to synchronize usage of the Fdc hardware.  If somebody else is
    // using the floppy controller now we must wait for them to finish.  If
    // this takes too long we will just let the caller know that the device is
    // busy.
    //
    if (FdoExtension->FdcEnablerSupported) {

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                                 IOCTL_ACQUIRE_FDC,
                                 TimeOut);
    } else {

        ntStatus = KeWaitForSingleObject( &FdoExtension->AcquireEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          TimeOut );

        if ( ntStatus == STATUS_TIMEOUT ) {

            ntStatus = STATUS_DEVICE_BUSY;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        //
        // Lock down the driver code in memory.
        //

        FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

        //
        // Allocate the adapter channel
        //
        FcAllocateAdapterChannel( FdoExtension );

        IoStartTimer(FdoExtension->Self);

        if (IsNEC_98) {
            //
            // NEC98's FDD driver can't not disconnect interrupt,
            // and can't not page out this driver. Because when a FD is inserted in FDD or
            // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
            //
            ntStatus = STATUS_SUCCESS;

        } else { // (IsNEC_98)

            //
            // Connect the Interrupt
            //
            ntStatus = IoConnectInterrupt(&FdoExtension->InterruptObject,
                                        FdcInterruptService,
                                        FdoExtension,
                                        NULL,
                                        FdoExtension->ControllerVector,
                                        FdoExtension->ControllerIrql,
                                        FdoExtension->ControllerIrql,
                                        FdoExtension->InterruptMode,
                                        FdoExtension->SharableVector,
                                        FdoExtension->ProcessorMask,
                                        FdoExtension->SaveFloatState);
        } // (IsNEC_98)

        if ( NT_SUCCESS( ntStatus ) ) {
            FdoExtension->ControllerInUse = TRUE;
        } else {
            FcFreeAdapterChannel( FdoExtension );
            IoStopTimer(FdoExtension->Self);
        }
    } else {

        ntStatus = STATUS_DEVICE_BUSY;
    }

    return ntStatus;
}

NTSTATUS
FcReleaseFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine releaese the floppy disk controller.  This includes
    freeing the adapter channel and disconnecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    FdcDump(FDCINFO, ("Fdc: Release the Floppy Controller\n") );

    //
    // Free the Adapter Channel
    //
    FcFreeAdapterChannel( FdoExtension );

    FdoExtension->AllowInterruptProcessing = FALSE;
    FdoExtension->ControllerInUse = FALSE;

    if (IsNEC_98) {
        //
        // NEC98's FDD driver can't not disconnect interrupt,
        // and can't not page out this driver. Because when a FD is inserted in FDD or
        // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
        //

    } else { // (IsNEC_98)
        //
        // Disconnect the Interrupt
        //
        IoDisconnectInterrupt(FdoExtension->InterruptObject);

    } // (IsNEC_98)

    IoStopTimer(FdoExtension->Self);

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    //
    // Release the Fdc Enabler card if there is one.  Otherwise, set the
    // floppy synchronization event.
    //
    if (FdoExtension->FdcEnablerSupported) {

        FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                      IOCTL_RELEASE_FDC,
                      NULL);
    } else {

        KeSetEvent( &FdoExtension->AcquireEvent,
                    (KPRIORITY) 0,
                    FALSE );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOnMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN OUT  PFDC_ENABLE_PARMS   FdcEnableParms
    )

/*++

Routine Description:

    This routine turns on the motor if it not already running.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    UCHAR driveStatus;
    UCHAR newStatus;
    LARGE_INTEGER motorOnDelay;

    USHORT      lpc;
    UCHAR       resultStatus0Save[4];

    FdcDump(FDCINFO,
           ("Fdc: Turn Motor On: %x\n", FdcEnableParms->DriveOnValue) );

    driveStatus = FdoExtension->DriveControlImage;

    if (IsNEC_98) {

        newStatus = DRVCTL_MOTOR_MASK;

    } else { // (IsNEC_98)

        newStatus = FdcEnableParms->DriveOnValue |
                                    DRVCTL_ENABLE_CONTROLLER |
                                    DRVCTL_ENABLE_DMA_AND_INTERRUPTS;
    } // (IsNEC_98)

    if ( driveStatus != newStatus ) {

        // If the drive is not on then check to see if we have
        // the controller.  Otherwise we assume that we have
        // the controller since we give it up only when we
        // turn off the motor.

        if (IsNEC_98) {
            if(FdoExtension->MotorRunning == 0){

                //
                // save status
                //
                for(lpc=0;lpc<4;lpc++){
                    resultStatus0Save[lpc] = FdoExtension->ResultStatus0[lpc];
                }

                FdcDump(
                    FDCSHOW,
                    ("Floppy: Turn on motor!\n")
                    );

                FdoExtension->DriveControlImage = 0x18;
                FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE;

                WRITE_CONTROLLER(
                     FdoExtension->ControllerAddress.DriveControl,
                     FdoExtension->DriveControlImage );
                FdoExtension->MotorRunning = 1;
            }
        } else { // (IsNEC_98)

            if (!FdoExtension->CurrentInterrupt) {

                FdoExtension->CurrentInterrupt = TRUE;

                driveStatus = FdoExtension->DriveControlImage;
            }

            FdoExtension->AllowInterruptProcessing = TRUE;

            FdoExtension->DriveControlImage = newStatus;

            WRITE_CONTROLLER(
                FdoExtension->ControllerAddress.DriveControl,
                FdoExtension->DriveControlImage );

        } // (IsNEC_98)


        if (FdcEnableParms->TimeToWait > 0) {

            if (IsNEC_98) {

                //
                // check if motor is on or not.
                //
                if(FdoExtension->MotorRunning == 1){
                    FdoExtension->MotorRunning = 2;
                    motorOnDelay.LowPart = (unsigned long)(- ( 10 * 1000 * 1000 ));
                    motorOnDelay.HighPart = -1;
                    FdoExtension->LastMotorSettleTime = motorOnDelay;
                    KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

                    //
                    // after sense, restore status
                    //
                    for(lpc=0;lpc<4;lpc++){
                        FdoExtension->ResultStatus0[lpc] = resultStatus0Save[lpc];
                    }
                }

            } else { // (IsNEC_98)

                motorOnDelay.LowPart =
                    - ( 10 * 1000 * FdcEnableParms->TimeToWait );
                motorOnDelay.HighPart = -1;

                FdoExtension->LastMotorSettleTime = motorOnDelay;

                KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

            } // (IsNEC_98)

        }

        FdcEnableParms->MotorStarted = TRUE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOffMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine turns off all motors.  By default, Drive A is left selected
    by this routine since it is not possible to deselect all drives.  On a
    Power PC, drive D is left selected.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{

    FdcDump(FDCINFO,
           ("Fdc: Turn Motor Off\n")
           );

    if (IsNEC_98) {

        if (FdoExtension->MotorRunning != 0){

            FdoExtension->DriveControlImage
                    = READ_CONTROLLER(FdoExtension->ControllerAddress.DriveControl);

            FdoExtension->DriveControlImage = 0x10;
            FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE;

            WRITE_CONTROLLER(
                    FdoExtension->ControllerAddress.DriveControl,
                    FdoExtension->DriveControlImage );

            if (FdoExtension->CurrentInterrupt) {

                FdoExtension->CurrentInterrupt = FALSE;
            }
            FdoExtension->MotorRunning = 0;
        }
    } else { // (IsNEC_98)

        FdoExtension->DriveControlImage =
            DRVCTL_ENABLE_DMA_AND_INTERRUPTS +
#ifdef _PPC_
            DRVCTL_DRIVE_MASK +
#endif
            DRVCTL_ENABLE_CONTROLLER;

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

    } // (IsNEC_98)

    return STATUS_SUCCESS;
}

VOID
FcAllocateAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine allocates an adapter channel.  The caller of
    IoAllocateAdapterChannel routine must wait for the
    'AllocateAdapterChannelEvent' to be signalled before trying to use the
    adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( (FdoExtension->AdapterChannelRefCount)++ ) {
        return;
    }

    KeResetEvent( &FdoExtension->AllocateAdapterChannelEvent );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoAllocateAdapterChannel( FdoExtension->AdapterObject,
                              FdoExtension->Self,
                              FdoExtension->NumberOfMapRegisters,
                              FdcAllocateAdapterChannel,
                              FdoExtension );

    KeLowerIrql( oldIrql );

    KeWaitForSingleObject( &FdoExtension->AllocateAdapterChannelEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL);
}

VOID
FcFreeAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine frees the previously allocated adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( --(FdoExtension->AdapterChannelRefCount) ) {
        return;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoFreeAdapterChannel( FdoExtension->AdapterObject );

    KeLowerIrql( oldIrql );
}

IO_ALLOCATION_ACTION
FdcAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This DPC is called whenever the fdc.sys driver is trying to allocate
    the adapter channel.  It saves the MapRegisterBase in the controller data
    area, and sets the AllocateAdapterChannelEvent to awaken the thread.

Arguments:

    DeviceObject - unused.

    Irp - unused.

    MapRegisterBase - the base of the map registers that can be used
    for this transfer.

    Context - a pointer to our controller data area.

Return Value:

    Returns Allocation Action 'KeepObject' which means that the adapter
    object will be held for now (to be released explicitly later).

--*/
{
    PFDC_FDO_EXTENSION fdoExtension = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    fdoExtension->MapRegisterBase = MapRegisterBase;

    KeSetEvent( &fdoExtension->AllocateAdapterChannelEvent,
                0L,
                FALSE );

    return KeepObject;
}

VOID
FcLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to log an error that we had to reset the device.

Arguments:

    Dpc - The dpc object.

    DeferredContext - A pointer to the controller data.

    SystemContext1 - Unused.

    SystemContext2 - Unused.

Return Value:

    Mapped address

--*/

{

    PIO_ERROR_LOG_PACKET errorLogEntry;
    PFDC_FDO_EXTENSION fdoExtension = DeferredContext;

    errorLogEntry = IoAllocateErrorLogEntry(
                        fdoExtension->DriverObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET))
                        );

    if ( errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = IO_ERR_RESET;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 0;

        IoWriteErrorLogEntry(errorLogEntry);

    }

}

NTSTATUS
FcIssueCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes
    )

/*++

Routine Description:

    This routine sends the command and all parameters to the controller,
    waits for the command to interrupt if necessary, and reads the result
    bytes from the controller, if any.

    Before calling this routine, the caller should put the parameters for
    the command in ControllerData->FifoBuffer[].  The result bytes will
    be returned in the same place.

    This routine runs off the CommandTable.  For each command, this says
    how many parameters there are, whether or not there is an interrupt
    to wait for, and how many result bytes there are.  Note that commands
    without result bytes actually have two, since the ISR will issue a
    SENSE INTERRUPT STATUS command on their behalf.

Arguments:

    Command - a byte specifying the command to be sent to the controller.

    fdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the command was sent and bytes received properly;
    appropriate error propogated otherwise.

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;

    if ( FdoExtension->HardwareFailed ) {
        return STATUS_DEVICE_NOT_READY;
    }

    #if DBG
    if (TransferBytes) {
       FdcDump(FDCDBGP,
               ("Bytes to transfer is %d\n", TransferBytes));
    }
    #endif // DBG
    
    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcIssueCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );


    if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {

        FdoExtension->CurrentDeviceObject = FdoExtension->Self;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase =
            !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

        KeResetEvent( &FdoExtension->InterruptEvent );
    }

    //
    // Start up the command
    //

    ntStatus = FcStartCommand( FdoExtension,
                               FifoInBuffer,
                               FifoOutBuffer,
                               IoHandle,
                               IoOffset,
                               TransferBytes,
                               TRUE );

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // If there is an interrupt, wait for it.
        //

        if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {
            ntStatus = KeWaitForSingleObject(
                &FdoExtension->InterruptEvent,
                Executive,
                KernelMode,
                FALSE,
                &FdoExtension->InterruptDelay );

            if ( ntStatus == STATUS_TIMEOUT ) {

                //
                // Change info to an error.  We'll just say
                // that the device isn't ready.
                //
                FdcDump(FDCWARN,
                        ("TIME_OUT waiting for interrupt in FcIssueCommand\n")
                        );
                ntStatus = STATUS_DEVICE_NOT_READY;

                FdoExtension->HardwareFailed = TRUE;
            }

        }

        //
        // If successful so far, get the result bytes.
        //

        if ( NT_SUCCESS( ntStatus ) ||
             (ntStatus == STATUS_DEVICE_NOT_READY)) {
            ntStatus = FcFinishCommand( FdoExtension,
                                        FifoInBuffer,
                                        FifoOutBuffer,
                                        IoHandle,
                                        IoOffset,
                                        TransferBytes,
                                        TRUE );

        } 
    }

    return ntStatus;
}

NTSTATUS
FcStartCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i = 0;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;
    PIO_STACK_LOCATION irpSp;
    UCHAR status0;

    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcStartCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );

    FdoExtension->CommandHasResultPhase =
        !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

    // First we will need to set up the data transfer if there is one associated
    // with this request.
    //
    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA ) {
        //
        // Setup Adapter Channel for Read
        //
        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA ) {
       
        //
        // Setup Adapter Channel for Write
        //
        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      TRUE);

    }

    //
    // Send the command to the controller.
    //
    if ( Command == COMMND_CONFIGURE ) {
        if ( FdoExtension->Clock48MHz ) {
            Command |= COMMND_OPTION_CLK48;
        }
    }
    ntStatus = FcSendByte( (UCHAR)(CommandTable[Command & COMMAND_MASK].OpCode |
                                  (Command & ~COMMAND_MASK)),
                           FdoExtension,
                           AllowLongDelay );

    //
    // If the command was successfully sent, we can proceed.
    //

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // Send the parameters as long as we succeed.
        //

        for ( i = 1;
            ( i <= CommandTable[Command & COMMAND_MASK].NumberOfParameters ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcSendByte( FifoInBuffer[i],
                                   FdoExtension,
                                   AllowLongDelay );
            //
            // The Drive Specification is a special case since we don't really know
            // how many bytes to send until we encounter the DONE bit (or we have sent
            // the maximum allowable bytes).
            //
            if ((Command == COMMND_DRIVE_SPECIFICATION) &&
                (FifoInBuffer[i] & COMMND_DRIVE_SPECIFICATION_DONE) ) {
                break;
            }
        }

    }

    //
    // If there was a problem, check to see if it was caused by an
    // unimplemented command.
    //

    if ( !NT_SUCCESS( ntStatus ) ) {

        if ( ( i == 2 ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) {

            //
            // This error is probably caused by a command that's not
            // implemented on this controller.  Read the error from the
            // controller, and we should be in a stable state.
            //

            ntStatus2 = FcGetByte( &status0,
                                   FdoExtension,
                                   AllowLongDelay );

            //
            // If GetByte went as planned, we'll return the original error.
            //

            if ( NT_SUCCESS( ntStatus2 ) ) {

                if ( status0 != STREG0_END_INVALID_COMMAND ) {

                    //
                    // Status isn't as we expect, so return generic error.
                    //

                    ntStatus = STATUS_FLOPPY_BAD_REGISTERS;

                    FdoExtension->HardwareFailed = TRUE;
                    FdcDump( FDCINFO,
                             ("FcStartCommand: unexpected error value %2x\n",
                             status0) );
                } else {
                    FdoExtension->HardwareFailed = FALSE;
                    FdcDump( FDCINFO,
                             ("FcStartCommand: Invalid command error returned\n") );
                }

            } else {

                //
                // GetByte returned an error, so propogate THAT.
                //

                FdcDump( FDCINFO,
                         ("FcStartCommand: FcGetByte returned error %x\n",
                         ntStatus2) );
                ntStatus = ntStatus2;
            }
        }

        //
        // Flush the Adapter Channel if we allocated it.
        //

        if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
            FDC_READ_DATA) {


   
            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   FALSE);

        } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
                   FDC_WRITE_DATA) {

            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   TRUE);
        }
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        //
        // Print an error message unless the command isn't always
        // implemented, ie CONFIGURE.
        //

        if ( !( ( ntStatus == STATUS_DEVICE_NOT_READY ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) ) {

            FdcDump( FDCDBGP,
                     ("Fdc: err %x ------  while giving command %x\n",
                     ntStatus, Command) );
        }
    }

    return ntStatus;
}

NTSTATUS
FcFinishCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

    This function is called to complete a command to the floppy controller.
    At this point the floppy controller has successfully been sent a command
    and has either generated an interrupt or is ready with its result phase.
    This routine will also flush the DMA Adapter Buffers if they have been
    allocated.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

    IssueCommandParms - Floppy controller command parameters.

Return Value:

    STATUS_SUCCESS if the command is successfully completed.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    NTSTATUS ntStatus2;
    UCHAR i;
    UCHAR Command;

    Command = FifoInBuffer[0];

    FdcDump(
        FDCSHOW,
        ("Fdc: FcFinishCommand...\n")
        );

    if (IsNEC_98) {

        if (Command == COMMND_SENSE_DRIVE_STATUS) {

            ntStatus = FcGetByte(
                &FdoExtension->FifoBuffer[0],
                FdoExtension,
                AllowLongDelay );

            if (NT_SUCCESS(ntStatus) && (FdoExtension->FifoBuffer[0] & STREG3_DRIVE_READY)) {

                FdoExtension->ResultStatus0[FifoInBuffer[1]] = 0;
            }

        }

        FifoOutBuffer[0] = FdoExtension->FifoBuffer[0];

        for ( i = 1;
            ( i < CommandTable[Command & COMMAND_MASK].NumberOfResultBytes ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcGetByte(
                &FifoOutBuffer[i],
                FdoExtension,
                AllowLongDelay );
        }

        //
        // If recalibration was not done in time,
        // It should be re-tried with HardwareFailed equal FALSE.
        //
        if (Command == COMMND_RECALIBRATE) FdoExtension->HardwareFailed = FALSE;

        FdcRqmReadyWait(FdoExtension, 0);

    } else { // (IsNEC_98)

        if (CommandTable[Command & COMMAND_MASK].FirstResultByte > 0) {

            FifoOutBuffer[0] = FdoExtension->FifoBuffer[0];

            FdcDump( FDCSHOW, ("FcFinishCommand - Result: %02x", FifoOutBuffer[0]) );
        }

        for ( i = CommandTable[Command & COMMAND_MASK].FirstResultByte;
            ( i < CommandTable[Command & COMMAND_MASK].NumberOfResultBytes ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcGetByte(
                &FifoOutBuffer[i],
                FdoExtension,
                AllowLongDelay );
            FdcDump( FDCSHOW, (" %02x", FifoOutBuffer[i]) );
        }
        FdcDump( FDCSHOW, ("\n") );
    } // (IsNEC_98)

    //
    // Flush the Adapter Channel
    //

    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA) {

       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA) {

        //
        // Setup Adapter Channel for Write
        //
       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             TRUE);

    }

    return ntStatus;
}

NTSTATUS
FcSendByte(
    IN UCHAR ByteToSend,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to send a byte to the controller.  It won't
    send the byte unless the controller is ready to receive a byte; if
    it's not ready after checking FIFO_TIGHTLOOP_RETRY_COUNT times, we
    delay for the minimum possible time (10ms) and then try again.  It
    should always be ready after waiting 10ms.

Arguments:

    ByteToSend - the byte to send to the controller.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the byte was sent to the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteWritten = FALSE;

    if ( FdoExtension->HardwareFailed ) {
        return STATUS_DEVICE_NOT_READY;
    }

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // send the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) {

            WRITE_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo,
                ByteToSend );

            byteWritten = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( (!byteWritten) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have written the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // try it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteWritten ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller write\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_WRITE_READY ) {

                WRITE_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo,
                    ByteToSend );

                byteWritten = TRUE;
            }
        }
    }

    if ( byteWritten ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to write after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }
}

NTSTATUS
FcGetByte(
    OUT PUCHAR ByteToGet,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to get a byte from the controller.  It won't
    read the byte unless the controller is ready to send a byte; if
    it's not ready after checking FIFO_RETRY_COUNT times, we delay for
    the minimum possible time (10ms) and then try again.  It should
    always be ready after waiting 10ms.

Arguments:

    ByteToGet - the address in which the byte read from the controller
    is stored.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if a byte was read from the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteRead = FALSE;

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // read the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            *ByteToGet = READ_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo );

            byteRead = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( ( !byteRead ) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have read the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // trying it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteRead ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller read\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_READ_READY ) {

                *ByteToGet = READ_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo );

                byteRead = TRUE;

            }
        }
    }

    if ( byteRead ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to read after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }

}

VOID
FdcCheckTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL once every second by the
    I/O system.

    If the timer is "set" (greater than 0) this routine will KeSync a
    routine to decrement it.  If it ever reaches 0, the hardware is
    assumed to be in an unknown state, and so we log an error and
    initiate a reset.

    If a timeout occurs while resetting the controller, the KeSync'd
    routine will return an error, and this routine will fail any IRPs
    currently being processed.  Future IRPs will try the hardware again.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.

Arguments:

    DeviceObject - a pointer to the device object associated with this
    timer.

    Fdcxtension - a pointer to the fdc extension data.

Return Value:

    None.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;
    irp = DeviceObject->CurrentIrp;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  If it's on, we'll have to synchronize execution with
    // other routines while we mess with the variables (and, potentially,
    // the hardware).
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return;
    }

    //
    // In the unlikely event that we attempt to reset the controller due
    // to a timeout AND that reset times out, we will need to fail the
    // IRP that was in progress at the first timeout occurred.
    //

    if ( !KeSynchronizeExecution( fdoExtension->InterruptObject,
                                  FdcTimerSync,
                                  fdoExtension ) ) {

        //
        // We're done with the reset.  Return the IRP that was being
        // processed with an error, and release the controller object.
        //

        fdoExtension->ResettingController = RESET_NOT_RESETTING;

        irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

        IoSetHardErrorOrVerifyDevice( irp, DeviceObject );

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_DISK_INCREMENT );

        IoStartNextPacket( DeviceObject, FALSE );

    }
}

BOOLEAN
FdcTimerSync(
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by FdcCheckTimer() when
    InterruptTimer is greater than 0.

    If the timer is "set" (greater than 0) this routine will decrement
    it.  If it ever reaches 0, the hardware is assumed to be in an
    unknown state, and so we log an error and initiate a reset.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So, no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.  The controller object must
    be held.

Arguments:

    Context - a pointer to the controller extension.

Return Value:

    Generally TRUE.

    FALSE is only returned if the controller timed out while resetting
    the drive, so this means that the hardware state is unknown.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  It may have changed since we last checked it in
    // FdcCheckTimer().
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return TRUE;
    }

    //
    // The timer is "on", so decrement it.
    //

    fdoExtension->InterruptTimer--;

    //
    // If we hit zero, the timer has expired and we'll reset the
    // controller.
    //

    if ( fdoExtension->InterruptTimer == EXPIRED_TIMER ) {

        //
        // If we were ALREADY resetting the controller when it timed out,
        // there's something seriously wrong.
        //

        FdcDump( FDCDBGP, ("Fdc: Operation Timed Out.\n") );

        if ( fdoExtension->ResettingController != RESET_NOT_RESETTING ) {

            //
            // Returning FALSE will cause the current IRP to be completed
            // with an error.  Future IRPs will probably get a timeout and
            // attempt to reset the controller again.  This will probably
            // never happen.
            //

            FdcDump( FDCDBGP, ("Fdc: Timeout Reset timed out.\n") );

            fdoExtension->InterruptTimer = CANCEL_TIMER;
            return FALSE;
        }

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //

        fdoExtension->ResettingController = RESET_DRIVE_RESETTING;

        DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
        fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        fdoExtension->CommandHasResultPhase = FALSE;
        fdoExtension->InterruptTimer = START_TIMER;

        ENABLE_CONTROLLER_IMAGE (fdoExtension);

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

    }

    return TRUE;
}

BOOLEAN
FdcInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by the system when the controller
    interrupts.

Arguments:

    Interrupt - a pointer to the interrupt object.

    Context - a pointer to our controller data area for the controller
    that interrupted.  (This was set up by the call to
    IoConnectInterrupt).

Return Value:

    Normally returns TRUE, but will return FALSE if this interrupt was
    not expected.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PDEVICE_OBJECT currentDeviceObject;
    ULONG i;
    UCHAR statusByte;
    BOOLEAN controllerStateError;

    UCHAR resultStatus0;
    UCHAR aiStatus=0;
    UCHAR aiInterrupt=0;
    ULONG rqmReadyRetryCount;
    BOOLEAN Response;

    UNREFERENCED_PARAMETER( Interrupt );

#ifdef KEEP_COUNTERS
    FloppyIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyInterrupts++;
#endif

    FdcDump( FDCSHOW, ("FdcInterruptService: ") );

    fdoExtension = (PFDC_FDO_EXTENSION) Context;

    if (!IsNEC_98) {
        if (!fdoExtension->AllowInterruptProcessing) {
            FdcDump( FDCSHOW, ("processing not allowed\n") );
            return FALSE;
        }
    } // (!IsNEC_98)

    //
    // CurrentDeviceObject is set to the device object that is
    // expecting an interrupt.
    //

    currentDeviceObject = fdoExtension->CurrentDeviceObject;
    fdoExtension->CurrentDeviceObject = NULL;
    controllerStateError = FALSE;
    fdoExtension->InterruptTimer = CANCEL_TIMER;

    KeStallExecutionProcessor(10);

    if (IsNEC_98) {
        do {

            resultStatus0 = READ_CONTROLLER( fdoExtension->ControllerAddress.Status );

            resultStatus0 &= STATUS_DATA_REQUEST;

        } while (resultStatus0 != STATUS_DATA_REQUEST);
    } // (IsNEC_98)

    if ( fdoExtension->CommandHasResultPhase ) {

        //
        // Result phase of previous command.  (Note that we can't trust
        // the CMD_BUSY bit in the status register to tell us whether
        // there's result bytes or not; it's sometimes wrong).
        // By reading the first result byte, we reset the interrupt.
        // The other result bytes will be read by a thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("have result phase\n")
            );

        if (IsNEC_98) {

            rqmReadyRetryCount = 0;

            while ( ( READ_CONTROLLER( fdoExtension->ControllerAddress.Status)
                    & STATUS_IO_READY_MASK1) != STATUS_RQM_READY ) {
                //
                // RQM READY CHECK**
                //

                rqmReadyRetryCount++;

                if( rqmReadyRetryCount > RQM_READY_RETRY_COUNT ) {
                    break;
                }

                KeStallExecutionProcessor( 10 );
            }

            if( rqmReadyRetryCount > ( RQM_READY_RETRY_COUNT - 1 ) ) {
                FdcDump(
                   FDCDBGP,
                   ("Floppy: Int RQM ready wait 1 error! \n")
                    );

                KeStallExecutionProcessor( 10 );
                goto FdcInterruptMidterm;

            }
        } // (IsNEC_98)

        if ( ( READ_CONTROLLER( fdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            fdoExtension->FifoBuffer[0] =
                READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );

            FdcDump( FDCSHOW,
                     ("FdcInterruptService: 1st fifo byte %2x\n",
                     fdoExtension->FifoBuffer[0])
                     );

        } else {

            if (IsNEC_98) {

                FdcRqmReadyWait(fdoExtension, 2);

            } // (IsNEC_98)

            //
            // Should never get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt handle this.
            //

            FdcDump(
               FDCDBGP,
               ("FdcInterruptService: controller not ready to be read in ISR\n")
               );

            controllerStateError = TRUE;
        }

    } else {

        //
        // Previous command doesn't have a result phase. To read how it
        // completed, issue a sense interrupt command.  Don't read
        // the result bytes from the sense interrupt; that is the
        // responsibility of the calling thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("no result phase\n")
            );
        i = 0;

        do {

            KeStallExecutionProcessor( 1 );
            statusByte =
                READ_CONTROLLER(fdoExtension->ControllerAddress.Status);
            i++;

        } while ( ( i < FIFO_ISR_TIGHTLOOP_RETRY_COUNT ) &&
            ( ( statusByte & STATUS_CONTROLLER_BUSY ) ||
            ( ( statusByte & STATUS_IO_READY_MASK ) != STATUS_WRITE_READY ) ) );

        if ( !( statusByte & STATUS_CONTROLLER_BUSY ) &&
            ( ( statusByte & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) ) {

            WRITE_CONTROLLER(
                fdoExtension->ControllerAddress.Fifo,
                0x08 );
//                COMMND_SENSE_INTERRUPT_STATUS );

            //
            // Wait for the controller to ACK the SenseInterrupt command, by
            // showing busy.  On very fast machines we can end up running
            // driver's system-thread before the controller has had time to
            // set the busy bit.
            //

            for (i = ISR_SENSE_RETRY_COUNT; i; i--) {

                statusByte =
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Status );
                if (statusByte & STATUS_CONTROLLER_BUSY) {
                    break;
                }

                KeStallExecutionProcessor( 1 );
            }

            if (!i) {
                FdcDump(
                    FDCSHOW,
                    ("FdcInterruptService: spin loop complete and controller NOT busy\n")
                    );
            }

            if ( currentDeviceObject == NULL ) {

                //
                // This is an unexpected interrupt, so nobody's going to
                // read the result bytes.  Read them now.
                //

                if (IsNEC_98) {

                    resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                    if ((resultStatus0 & STREG0_END_DRIVE_NOT_READY) != STREG0_END_INVALID_COMMAND ) {

                        resultStatus0 = FdcRqmReadyWait(fdoExtension, 1);
                    }
                } else { // (IsNEC_98)

                    FdcDump(
                        FDCSHOW,
                        ("FdcInterruptService: Dumping fifo bytes!\n")
                        );
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
                } // (IsNEC_98)
            }

            if (IsNEC_98) {
                if ( currentDeviceObject != NULL ) {
                    FdcDump(
                            FDCSHOW,
                            ("Floppy: FloppyInt.---Deviceobject!=NULL2\n")
                            );

                    resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                    //
                    // Check move state.
                    //

                    if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY) {

                        if(fdoExtension->ResetFlag){
                            aiStatus=1;
                            fdoExtension->CurrentDeviceObject = currentDeviceObject;
                        }

                    } else {

                        fdoExtension->FifoBuffer[0] = resultStatus0;

                        aiStatus=0;
                        aiInterrupt=1;
                    }


                    if (aiInterrupt == 0){
                        while( ((resultStatus0 & STREG0_END_DRIVE_NOT_READY) != STREG0_END_INVALID_COMMAND) && aiInterrupt==0 ) {

                            resultStatus0 = FdcRqmReadyWait(fdoExtension, 3);

                            do {
                                //
                                // Check move state.
                                //

                                if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY) {

                                     if(fdoExtension->ResetFlag){

                                        aiStatus=1;
                                        fdoExtension->CurrentDeviceObject = currentDeviceObject;
                                     }

                                } else {

                                    aiStatus=0;
                                    aiInterrupt=1;
                                    break;
                                }

                                resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                            } while ( aiInterrupt == 0 );
                        }

                        FdcDump(
                                FDCSHOW,
                                ("Floppy: FloppyInt.---Deviceobject!=NULL_out\n")
                                );
                    }
                }
            } // (IsNEC_98)

        } else {

            //
            // Shouldn't get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt take care of it.
            //

            FdcDump(
                FDCDBGP,
                ("Fdc: no result, but can't write SenseIntr\n")
                );

            controllerStateError = TRUE;
        }
    }

FdcInterruptMidterm:

    //
    // We've written to the controller, and we're about to leave.  On
    // machines with levelsensitive interrupts, we'll get another interrupt
    // if we RETURN before the port is flushed.  To make sure that doesn't
    // happen, we'll do a read here.
    //

    statusByte = READ_CONTROLLER( fdoExtension->ControllerAddress.Status );

    //
    // Let the interrupt settle.
    //

    KeStallExecutionProcessor(10);

#ifdef KEEP_COUNTERS
    FloppyEndIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyIntrDelay.QuadPart = FloppyIntrDelay.QuadPart +
                               (FloppyEndIntrTime.QuadPart -
                                FloppyIntrTime.QuadPart);
#endif

    if (IsNEC_98) {
        if(!(fdoExtension->ResetFlag)){
            fdoExtension->ResetFlag = TRUE;
        }
    } // (IsNEC_98)

    if ( currentDeviceObject == NULL ) {

        //
        // We didn't expect this interrupt.  We've dismissed it just
        // in case, but now return FALSE withOUT waking up the thread.
        //

        FdcDump(FDCDBGP,
                   ("Fdc: unexpected interrupt\n"));

        return FALSE;
    }

    if ( !controllerStateError ) {

        //
        // Request a DPC for execution later to get the remainder of the
        // floppy state.
        //

        fdoExtension->IsrReentered = 0;
        fdoExtension->AllowInterruptProcessing = FALSE;

        if (IsNEC_98) {
            if(aiStatus==0){
                IoRequestDpc(currentDeviceObject,
                             currentDeviceObject->CurrentIrp,
                             (PVOID) NULL );
            }
        } else { // (IsNEC_98)

            IoRequestDpc(currentDeviceObject,
                         currentDeviceObject->CurrentIrp,
                         (PVOID) NULL);

        } // (IsNEC_98)

    } else {

        //
        // Running the floppy (at least on R4000 boxes) we've seen
        // examples where the device interrupts, yet it never says
        // it *ISN'T* busy.  If this ever happens on non-MCA x86 boxes
        // it would be ok since we use latched interrupts.  Even if
        // the device isn't touched so that the line would be pulled
        // down, on the latched machine, this ISR wouldn't be called
        // again.  The normal timeout code for a request would eventually
        // reset the controller and retry the request.
        //
        // On the R4000 boxes and on MCA machines, the floppy is using
        // level sensitive interrupts.  Therefore if we don't do something
        // to lower the interrupt line, we will be called over and over,
        // *forever*.  This makes it look as though the machine is hung.
        // Unless we were lucky enough to be on a multiprocessor, the
        // normal timeout code would NEVER get a chance to run because
        // the timeout code runs at dispatch level, and we will never
        // leave device level.
        //
        // What we will do is keep a counter that is incremented every
        // time we reach this section of code.  When the counter goes
        // over the threshold we will do a hard reset of the device
        // and reset the counter down to zero.  The counter will be
        // initialized when the device is first initialized.  It will
        // be set to zero in the other arm of this if, and it will be
        // reset to zero by the normal timeout logic.
        //

        fdoExtension->CurrentDeviceObject = currentDeviceObject;
        if (fdoExtension->IsrReentered > FLOPPY_RESET_ISR_THRESHOLD) {

            //
            // Reset the controller.  This could cause an interrupt
            //

            fdoExtension->IsrReentered = 0;

            DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
            fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            KeStallExecutionProcessor( 10 );

            ENABLE_CONTROLLER_IMAGE (fdoExtension);

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            if (IsNEC_98) {

                fdoExtension->ResetFlag = TRUE;

            } // (IsNEC_98)

            //
            // Give the device plenty of time to be reset and
            // interrupt again.  Then just do the sense interrupt.
            // this should quiet the device.  We will then let
            // the normal timeout code do its work.
            //

            KeStallExecutionProcessor(500);
            WRITE_CONTROLLER(fdoExtension->ControllerAddress.Fifo,
                             0x08 );
//                           COMMND_SENSE_INTERRUPT_STATUS );
            KeStallExecutionProcessor(500);

            KeInsertQueueDpc(&fdoExtension->LogErrorDpc,
                             NULL,
                             NULL);
        } else {

            fdoExtension->IsrReentered++;
        }

    }
    return TRUE;
}

VOID
FdcDeferredProcedure(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at the
    request of FdcInterruptService().  It simply sets the interrupt
    event, which wakes up the floppy thread.

Arguments:

    Dpc - a pointer to the DPC object used to invoke this routine.

    DeferredContext - a pointer to the device object associated with this
    DPC.

    SystemArgument1 - unused.

    SystemArgument2 - unused.

Return Value:

    None.

--*/

{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
//    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY request;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

#ifdef KEEP_COUNTERS
    FloppyDPCs++;
    FloppyDPCTime = KeQueryPerformanceCounter((PVOID)NULL);

    FloppyDPCDelay.QuadPart = FloppyDPCDelay.QuadPart +
                              (FloppyDPCTime.QuadPart -
                               FloppyIntrTime.QuadPart);
#endif

    deviceObject = (PDEVICE_OBJECT) DeferredContext;
    fdoExtension = deviceObject->DeviceExtension;

    irp = deviceObject->CurrentIrp;

    if ( irp != NULL ) {

        irpSp = IoGetCurrentIrpStackLocation( irp );
    }

    if ( irp != NULL &&
         irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED ) {

        issueCommandParms =
            (PISSUE_FDC_COMMAND_PARMS)
            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        ntStatus = FcFinishCommand(
                        fdoExtension,
                        issueCommandParms->FifoInBuffer,
                        issueCommandParms->FifoOutBuffer,
                        issueCommandParms->IoHandle,
                        issueCommandParms->IoOffset,
                        issueCommandParms->TransferBytes,
                        FALSE );

        irp->IoStatus.Status = ntStatus;

        if ( !NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus ) ) {

            IoSetHardErrorOrVerifyDevice( irp, deviceObject );
        }

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        IoStartNextPacket( deviceObject, FALSE );

    } else {
        FdcDump( FDCSHOW, ("FdcDeferredProcedure: Set Event\n") );
        
        KeSetEvent( &fdoExtension->InterruptEvent, (KPRIORITY) 0, FALSE );
    }
}

NTSTATUS
FcFinishReset(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine is called to complete a reset operation which entails
    reading the interrupt status from each active channel on the floppy
    controller.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    UCHAR       statusRegister0;
    UCHAR       cylinder;
    UCHAR       driveNumber;

    FdcDump(
        FDCSHOW,
        ("Fdc: FcFinishReset\n")
        );

    //
    // Sense interrupt status for all drives.
    //
    for ( driveNumber = 0;
        ( driveNumber < MAXIMUM_DISKETTES_PER_CONTROLLER ) &&
            ( NT_SUCCESS( ntStatus ) );
        driveNumber++ ) {

        if ( driveNumber != 0 ) {

            //
            // Note that the ISR issued first SENSE INTERRUPT for us.
            //

            ntStatus = FcSendByte(
                          CommandTable[COMMND_SENSE_INTERRUPT_STATUS].OpCode,
                          FdoExtension,
                          TRUE );
        }

        if ( NT_SUCCESS( ntStatus ) ) {

            ntStatus = FcGetByte( &statusRegister0, FdoExtension, TRUE );

            if ( NT_SUCCESS( ntStatus ) ) {

                ntStatus = FcGetByte( &cylinder, FdoExtension, TRUE );
            }
        }
    }

    return ntStatus;
}

NTSTATUS
FcFdcEnabler(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    )
/*++

Routine Description:

    Call the floppy enabler driver to execute a command.  This is always a
    synchronous call and, since it includes waiting for an event, should only
    be done at IRQL_PASSIVE_LEVEL.

    All communication with the Floppy Enabler driver is carried out through
    device i/o control requests.  Any data that is to be sent to or received
    from the floppy enabler driver is included in the Type3InputBuffer section
    of the irp.

Arguments:

    DeviceObject - a pointer to the current device object.

    Ioctl - the IoControl code that will be sent to the Floppy Enabler.

    Data - a pointer to data that will be sent to or received from the Floppy
           Enabler.

Return Value:

    STATUS_TIMEOUT if the Floppy Enabler does not respond in a timely manner.
    otherwise IoStatus.Status from the Floppy Enabler is returned.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FcFdcEnabler: Calling fdc enabler with %x\n", Ioctl));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FcFdcEnabler: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver(DeviceObject, irp);

    if ( ntStatus == STATUS_PENDING ) {

        //
        // Now wait for operation to complete (should already be done,  but
        // maybe not)
        //
        KeWaitForSingleObject( &doneEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ntStatus = ioStatus.Status;
    }

    return ntStatus;
}
VOID
FdcGetEnablerDevice(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FdcGetEnablerDevice:\n"));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_INTERNAL_GET_ENABLER,
                                         FdoExtension->TargetObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FdcGetEnablerDevice: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return;
    }

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = &FdoExtension->FdcEnablerSupported;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver( FdoExtension->TargetObject, irp );

    //
    // Now wait for operation to complete (should already be done,  but
    // maybe not)
    //
    if ( ntStatus == STATUS_PENDING ) {

        ntStatus = KeWaitForSingleObject( &doneEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
    }
    return;
}


ULONG
FdcFindIsaBusNode(
    IN OUT VOID
    )

/*++

Routine Description:

    Find Isa bus node in the registry.

Arguments:


Return Value:

    Node number.

--*/

{
    ULONG   NodeNumber = 0;
    BOOLEAN FoundBus = FALSE;

    NTSTATUS Status;

    RTL_QUERY_REGISTRY_TABLE parameters[2];

    UNICODE_STRING invalidBusName;
    UNICODE_STRING targetBusName;
    UNICODE_STRING isaBusName;

    //
    // Initialize invalid bus name.
    //
    RtlInitUnicodeString(&invalidBusName,L"BADBUS");

    //
    // Initialize "ISA" bus name.
    //
    RtlInitUnicodeString(&isaBusName,L"ISA");

    parameters[0].QueryRoutine = NULL;
    parameters[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                          RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = L"Identifier";
    parameters[0].EntryContext = &targetBusName;
    parameters[0].DefaultType = REG_SZ;
    parameters[0].DefaultData = &invalidBusName;
    parameters[0].DefaultLength = 0;

    parameters[1].QueryRoutine = NULL;
    parameters[1].Flags = 0;
    parameters[1].Name = NULL;
    parameters[1].EntryContext = NULL;

    do {
        WCHAR pathBuffer[512];
        UNICODE_STRING registryPath;

        //
        // Build path buffer...
        //
        swprintf(pathBuffer,ISA_BUS_NODE,NodeNumber);
        RtlInitUnicodeString(&registryPath,pathBuffer);
        
        //
        // Initialize recieve buffer.
        //
        targetBusName.Buffer = NULL;

        //
        // Query it.
        //
        Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                        registryPath.Buffer,
                                        parameters,
                                        NULL,
                                        NULL);

        if (!NT_SUCCESS(Status) || (targetBusName.Buffer == NULL)) {
            break;
        }

        //
        // Is this "ISA" node ?
        //
        if (RtlCompareUnicodeString(&targetBusName,&isaBusName,TRUE) == 0) {
            //
            // Found.
            //
            FoundBus = TRUE;
            break;
        }

        //
        // Can we find any node for this ??
        //
        if (RtlCompareUnicodeString(&targetBusName,&invalidBusName,TRUE) == 0) {
            //
            // Not found.
            //
            break;
        }

        RtlFreeUnicodeString(&targetBusName);

        //
        // Next node number..
        //
        NodeNumber++;

    } while (TRUE);

    if (targetBusName.Buffer) {
        RtlFreeUnicodeString(&targetBusName);
    }

    if (!FoundBus) {
        NodeNumber = (ULONG)-1;
    }

    return (NodeNumber);
}


NTSTATUS
FdcHdbit(
    IN PDEVICE_OBJECT      DeviceObject,
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN PSET_HD_BIT_PARMS   SetHdBitParams
    )

/*++

Routine Description:

    Set a Hd bit or a FDD EXC bit.

Arguments:

    fdoExtension - a pointer to our data area for the device extension.


Return Value:

        TRUE : Changed HD bit
        FALSE: No changed HD bit

--*/

{
    NTSTATUS ntStatus;
    USHORT   st;                // State of HD bit
    USHORT   st2;               // Set on/off HD bit
    USHORT   st3;               // When set HD bit, then st3=1
    USHORT   st4;               // 1.44MB bit for 1.44MB media
    SHORT    sel;               // 1.44MB Selector No for 1.44MB media
    SHORT    st5=0;             // 1.44MB on: wait for spin for 1.44MB media
    LARGE_INTEGER motorOnDelay;

    USHORT      lpc;
    UCHAR       resultStatus0Save[4];
    USHORT      resultStatus0;
    ULONG       getStatusRetryCount;
    ULONG       rqmReadyRetryCount;

    BOOLEAN     media144MB;
    BOOLEAN     mediaMore120MB;
    BOOLEAN     supportDrive;

    media144MB      = SetHdBitParams->Media144MB;
    mediaMore120MB  = SetHdBitParams->More120MB;
    sel             = SetHdBitParams->DeviceUnit;
    SetHdBitParams->ChangedHdBit = FALSE;


    ASSERT( FdoExtension->ControllerAddress.ModeChange   == (PUCHAR)0xbe );
    ASSERT( FdoExtension->ControllerAddress.ModeChangeEx == (PUCHAR)0x4be );

    supportDrive    = TRUE;

    st3=0;

    ntStatus=0;

    //
    // Normal mode.
    //

    st = READ_CONTROLLER(FdoExtension->ControllerAddress.ModeChange);
    st2 = st & 0x02;

    //
    // Normal mode.
    // Check dip switch.
    //

    st4 = READ_CONTROLLER(FdoExtension->ControllerAddress.DriveControl);
    st4 = st4 & 0x04;

    if (((FdoExtension->FloppyEquip) & 0x0c) != 0) {
        //
        // Exist out side FDD unit.
        //

        if ( st4 == 0 ) {
            //
            // DIP SW 1-4 on
            //

            sel = sel - 2;

            if( sel < 0 ) {
                sel = sel + 4;
            }
        }
    }

    if ( supportDrive ) {

        for( lpc = 0 ; lpc < 4 ; lpc++ ) {

            resultStatus0Save[lpc]=FdoExtension->ResultStatus0[lpc];
        }

        if ( SetHdBitParams->DriveType144MB ) {
            //
            // 1.44MB drive.
            //

            st4=sel*32;
            WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);

            st4 = READ_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx);
            st4 = st4 & 0x01;

            if ( media144MB ) {

                //
                // 1.44MB media.
                //

                if(st4==0){

                    //
                    // WRE on, IHMD off.
                    //

                    st4=sel*32+0x11;
                    WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);
                    st5=1;
                }

            } else {

                //
                // Not 1.44MB media.
                //

                if(st4!=0){

                    //
                    // WRE on, IHMD off.
                    //

                    st4=sel*32+0x10;
                    WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);
                    st5=1;
                }
            }
        }

        if ( mediaMore120MB ) {
            //
            // Media 1.2MB and More.
            //

            if(st2==0){
                //
                // When FDD exc bit is on,
                // then set  FDD exc bit off,
                // and set emotion bit on.
                //
                st |= 0x02;
                st |= 0x04;

                WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChange,st);
                st3 = 1;

            }
        } else {
            //
            // Media between 160 and 720
            //

            if ( st2 != 0 ) {
                //
                // When FDD exc bit is on,
                // then set  FDD exc bit off,
                // and set emotion bit on.
                //

                st &= 0xfd;
                st |= 0x04;

                WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChange,st);
                st3 = 1;

            }
        }

        if(st5==1){

            //
            // Wait until motor spin up.
            //

            motorOnDelay.LowPart = (unsigned long)(- ( 10 * 1000 * 600 ));   /*500ms*/
            motorOnDelay.HighPart = -1;
            (VOID) KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

            //
            // Sense target drive and get all data at transition of condistion.
            //

            FdoExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
            FdoExtension->FifoBuffer[1] = SetHdBitParams->DeviceUnit;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            resultStatus0 = FdcRqmReadyWait(FdoExtension, 0);

        }

        for(lpc=0;lpc<4;lpc++){
            FdoExtension->ResultStatus0[lpc] = resultStatus0Save[lpc];
        }

        //
        // Change HD bit?
        //

        if(st3==1){
            FcInitializeControllerHardware(FdoExtension,DeviceObject);
            SetHdBitParams->ChangedHdBit = TRUE;
        }

    }

    FdcDump(
            FDCSTATUS,
            ("Floppy : HdBit resultStatus0 = %x \n",
            resultStatus0)
            );

    return ntStatus;
}


ULONG
FdcGet0Seg(
    IN PUCHAR   ConfigurationData1,
    IN ULONG    Offset
    )

/*++

Routine Description:

    This routine get BIOS common area data and return it.
        0x500 :    1MB port or not
        0x501 :    High resolution/Normal, 386/768KB
        0x55c :    1MB drive : [#0,#1] or [#0,#1,#2,#3]

Arguments:

    Offset - Offset value from 0 segment(0:<Offset>).

Return Value:

        BIOS common area data.

--*/

{
        UCHAR           biosCommonAreaData   = 0;

        if ((Offset<0x400) || (Offset>0x5ff)) {

                return (ULONG)0xffff;
        }

        //
        // Get BIOS common area data.
        //

        biosCommonAreaData = ConfigurationData1[40+(Offset-0x400)];

        return (ULONG)biosCommonAreaData;
}

UCHAR
FdcRqmReadyWait(
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN ULONG               IssueSenseInterrupt
    )

/*++

Routine Description:

    RQM Ready wait

Arguments:

    FdoExtension         - a pointer to our data area for the device extension.
    IssueSenseInterrupt  - Indicate issue COMMND_SENSE_INTERRUPT_STATUS.
                            0 - Issue no COMMND_SENSE_INTERRUPT_STATUS.
                            1 - Issue COMMND_SENSE_INTERRUPT_STATUS with RQM Check.
                            2 - Issue COMMND_SENSE_INTERRUPT_STATUS without RQM Check.
                            3 - Issue COMMND_SENSE_INTERRUPT_STATUS for AI Interrupt.


Return Value:

    ntStatus - STATUS_SUCCESS

--*/

{

    ULONG       getStatusRetryCount;
    ULONG       rqmReadyRetryCount;
    ULONG       j;
    UCHAR       resultStatus0;
    UCHAR       statusByte;

    ASSERT(IssueSenseInterrupt < 4);

    do{
        if (IssueSenseInterrupt != 0) {

            //
            // Sense Interrupt status.
            // RQM ready wait.
            //

            if ((IssueSenseInterrupt == 1) || (IssueSenseInterrupt == 3)) {

                rqmReadyRetryCount=0;
                //
                // RQM ready check.
                //
                while ((READ_CONTROLLER( FdoExtension->ControllerAddress.Status)
                        & STATUS_IO_READY_MASK1) != STATUS_RQM_READY){

                    rqmReadyRetryCount++;

                    if(rqmReadyRetryCount > RQM_READY_RETRY_COUNT){
                            break;
                    }
                    KeStallExecutionProcessor( 1 );
                }
                if(rqmReadyRetryCount > (RQM_READY_RETRY_COUNT-1)){
                    FdcDump(
                            FDCDBGP,
                            ("Floppy: Issue RQM ready wait 1 error! \n")
                             );
                    if (IssueSenseInterrupt == 1) {
                        break;
                    }
                }

            }

            //
            // Issue sense interrupt forcibly.
            //

            WRITE_CONTROLLER(
                  FdoExtension->ControllerAddress.Fifo,
                  0x08);
//                  COMMND_SENSE_INTERRUPT_STATUS ); //******C-Phase DATA WRITE*

            //
            // Wait for busy.
            //
            for (rqmReadyRetryCount = ISR_SENSE_RETRY_COUNT; rqmReadyRetryCount; rqmReadyRetryCount--) {
                statusByte = READ_CONTROLLER(
                FdoExtension->ControllerAddress.Status );
                if (statusByte & STATUS_CONTROLLER_BUSY)
                    break;

                KeStallExecutionProcessor( 1 );

            }
        }

        //
        // Get status.
        //

        getStatusRetryCount = 0;

        j = 0;

        do {
            //
            // Check RQM ready.
            //

            rqmReadyRetryCount=0;

            while ((READ_CONTROLLER( FdoExtension->ControllerAddress.Status)
                  & STATUS_IO_READY_MASK1) != STATUS_RQM_READY){

                rqmReadyRetryCount++;

                if(rqmReadyRetryCount > RQM_READY_RETRY_COUNT){
                    break;
                }

                KeStallExecutionProcessor( 1 );
            }

            if(rqmReadyRetryCount > (RQM_READY_RETRY_COUNT-1)){

                FdcDump(
                    FDCDBGP,
                    ("Floppy: Int RQM ready wait \n")
                     );

                KeStallExecutionProcessor( 1 );
                break;
            }

            //
            // Get status even if it is transition of condition.
            //

            statusByte = READ_CONTROLLER(FdoExtension->ControllerAddress.Status);

            if ((statusByte & STATUS_IO_READY_MASK) == STATUS_WRITE_READY) {

                //
                // DIO is 1.
                //

                break;
            }

            if (j == 0) {

                //
                // R-Phase: Data read.
                //

                resultStatus0 = READ_CONTROLLER( FdoExtension->ControllerAddress.Fifo );

                j=1;

                //
                // Check transition of condition.
                //

                if((resultStatus0 & STREG0_END_MASK)==STREG0_END_INVALID_COMMAND){
                    //
                    // Invalid
                    //
                    break;
                }

                if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY){
                    if(FdoExtension->ResetFlag){
                        FdoExtension->ResultStatus0[resultStatus0 & 3] = resultStatus0;
                    }
                }

            } else {

                //
                // R-Phase: Data read.
                //
                READ_CONTROLLER( FdoExtension->ControllerAddress.Fifo );
            }

            getStatusRetryCount++;

        } while (getStatusRetryCount > RQM_READY_RETRY_COUNT);

        if(getStatusRetryCount > RQM_READY_RETRY_COUNT-1){

            KeStallExecutionProcessor( 1 );
            FdcDump(
                FDCDBGP,
                ("Floppy: Issue status overflow error! \n")
                );
        }

    } while ((IssueSenseInterrupt != 0) &&
             ((resultStatus0 & STREG0_END_MASK) != STREG0_END_INVALID_COMMAND));

    return resultStatus0;

}

NTSTATUS
FdcTerminateBufferThread(
    IN PFDC_FDO_EXTENSION  FdoExtension
    )
{
    PVOID bufferThread;
    LARGE_INTEGER timeout;

    NTSTATUS status;

    ASSERT(FdoExtension->BufferThreadHandle != NULL);

    //
    // First check to see if the buffer thread has already terminated.  If
    // so we can just close the handle and be done with it.
    //

    status = ObReferenceObjectByHandle(FdoExtension->BufferThreadHandle,
                                       SYNCHRONIZE,
                                       NULL,
                                       KernelMode,
                                       &bufferThread,
                                       NULL);
    if (!NT_SUCCESS(status)) {
       FdcDump(FDCWARN,
               ("FDC: ObReferenceObjectByHandle failed. Status - %x",
                status));
       return status;
    }

    timeout.QuadPart = 0;

    status = KeWaitForSingleObject(bufferThread,
                                   KernelMode,
                                   Executive,
                                   FALSE,
                                   &timeout);

    if(status == STATUS_TIMEOUT) {

        KIRQL oldIrql;

        //
        // The thread has not yet terminated itself.  Go ahead and give it a
        // helping hand.
        //

        KeAcquireSpinLock(&(FdoExtension->BufferThreadSpinLock), &oldIrql);

        FdoExtension->TerminateBufferThread = TRUE;

        timeout.QuadPart = 0;

        KeSetTimer(&(FdoExtension->BufferTimer),
                   timeout,
                   NULL);

        //
        // Drop the spinlock and wait for the thread to kill itself.
        //

        KeReleaseSpinLock(&(FdoExtension->BufferThreadSpinLock), oldIrql);

        status = KeWaitForSingleObject(bufferThread,
                                       KernelMode,
                                       Executive,
                                       FALSE,
                                       NULL);
    }

    ASSERT(NT_SUCCESS(status));

    //
    // Dereference the thread and close the handle so it can go away.
    //

    ObDereferenceObject(bufferThread);
    ZwClose(FdoExtension->BufferThreadHandle);

    FdoExtension->BufferThreadHandle = NULL;
    FdoExtension->TerminateBufferThread = FALSE;

    return status;
}

NTSTATUS
FdcProbeFloppyDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR DeviceSelect
    )
/*++

Routine Description:

    Probe for a floppy device.  This routine will issue a RECALIBRATE command(s)
    to the specified floppy device which will attempt to move the head to track 0.
    The floppy drive should respond by setting the track 0 line when it gets there.
    No response indicates that there is probably no device out there.
    NOTE - some older 360k, 5.25" floppy devices did not implement the track 0 line
    so this probe will not accurately indicate their presence.

Arguments:

    DeviceObject - a pointer to the device object being started.
    DeviceSelect - the floppy device to probe (0 - 3).

Return Value:

    Returns the status of the probe.

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice\n") );

    ntStatus = FcAcquireFdc( fdoExtension, NULL );

    if ( NT_SUCCESS(ntStatus) ) {

        //
        //  Reset the floppy controller for good measure.
        //
        ntStatus = FcInitializeControllerHardware( fdoExtension, DeviceObject );

        if ( NT_SUCCESS(ntStatus) ) {

            FDC_ENABLE_PARMS fdcEnable;

            fdcEnable.DriveOnValue = DeviceSelect | ( DRVCTL_DRIVE_0 << DeviceSelect );
            fdcEnable.TimeToWait   = 1000;  //Max motor settle time.
            fdcEnable.MotorStarted = FALSE;

            ntStatus = FcTurnOnMotor( fdoExtension, &fdcEnable );
        }

        if ( NT_SUCCESS(ntStatus) ) {

            //
            //  Issue a recalibrate command.
            //
            FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice - issue 1st recalibrate\n") );

            fdoExtension->FifoBuffer[0] = COMMND_RECALIBRATE;
            fdoExtension->FifoBuffer[1] = DeviceSelect;

            ntStatus = FcIssueCommand( fdoExtension,
                                       fdoExtension->FifoBuffer,
                                       fdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            //
            //  If the floppy controller reports a drive fault (Equipment Check) then
            //  we must issue another recalibrate command since we don't know if there is
            //  no drive present or if the drive has more than 80 tracks.
            //
            if ( NT_SUCCESS(ntStatus) &&
                 fdoExtension->FifoBuffer[0] & STREG0_DRIVE_FAULT ) {

                FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice - issue 2nd recalibrate\n") );

                fdoExtension->FifoBuffer[0] = COMMND_RECALIBRATE;
                fdoExtension->FifoBuffer[1] = DeviceSelect;

                ntStatus = FcIssueCommand( fdoExtension,
                                           fdoExtension->FifoBuffer,
                                           fdoExtension->FifoBuffer,
                                           NULL,
                                           0,
                                           0 );

                if ( NT_SUCCESS(ntStatus) &&
                     fdoExtension->FifoBuffer[0] & STREG0_DRIVE_FAULT ) {

                    FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice - failed device probe.\n") );
                    ntStatus = STATUS_NO_SUCH_DEVICE;
                }
            }
        }

        FcTurnOffMotor( fdoExtension );

        FcReleaseFdc( fdoExtension );
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\flpydisk\floppy.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    floppy.c

Abstract:

    This is the NEC PD756 (aka AT, aka ISA, aka ix86) and Intel 82077
    (aka MIPS) floppy diskette driver for NT.

Environment:

    Kernel mode only.

--*/

//
// Include files.
//

#include "stdio.h"

#include "ntddk.h"                       // various NT definitions
#include "ntdddisk.h"                    // disk device driver I/O control codes
#include "ntddfdc.h"                     // fdc I/O control codes and parameters
#include "initguid.h"
#include "mountdev.h"
#include "acpiioct.h"

#include <flo_data.h>                    // this driver's data declarations


//
// This is the actual definition of FloppyDebugLevel.
// Note that it is only defined if this is a "debug"
// build.
//
#if DBG
extern ULONG FloppyDebugLevel = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)

#pragma alloc_text(PAGE,FloppyAddDevice)
#pragma alloc_text(PAGE,FloppyPnp)
#pragma alloc_text(PAGE,FloppyPower)
#pragma alloc_text(PAGE,FlConfigCallBack)
#pragma alloc_text(PAGE,FlInitializeControllerHardware)
#pragma alloc_text(PAGE,FlInterpretError)
#pragma alloc_text(PAGE,FlDatarateSpecifyConfigure)
#pragma alloc_text(PAGE,FlRecalibrateDrive)
#pragma alloc_text(PAGE,FlDetermineMediaType)
#pragma alloc_text(PAGE,FlCheckBootSector)
#pragma alloc_text(PAGE,FlConsolidateMediaTypeWithBootSector)
#pragma alloc_text(PAGE,FlIssueCommand)
#pragma alloc_text(PAGE,FlReadWriteTrack)
#pragma alloc_text(PAGE,FlReadWrite)
#pragma alloc_text(PAGE,FlFormat)
#pragma alloc_text(PAGE,FlFinishOperation)
#pragma alloc_text(PAGE,FlStartDrive)
#pragma alloc_text(PAGE,FloppyThread)
#pragma alloc_text(PAGE,FlAllocateIoBuffer)
#pragma alloc_text(PAGE,FlFreeIoBuffer)
#pragma alloc_text(PAGE,FloppyCreateClose)
#pragma alloc_text(PAGE,FloppyDeviceControl)
#pragma alloc_text(PAGE,FloppyReadWrite)
#pragma alloc_text(PAGE,FlCheckFormatParameters)
#pragma alloc_text(PAGE,FlFdcDeviceIo)
#pragma alloc_text(PAGE,FlHdbit)
#pragma alloc_text(PAGE,FloppySystemControl)
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'polF')
#endif

// #define KEEP_COUNTERS 1

#ifdef KEEP_COUNTERS
ULONG FloppyUsedSeek   = 0;
ULONG FloppyNoSeek     = 0;
#endif

//
// Used for paging the driver.
//

ULONG PagingReferenceCount = 0;
PFAST_MUTEX PagingMutex = NULL;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  The driver's entry points are initialized and
    a mutex to control paging is initialized.

    In DBG mode, this routine also examines the registry for special
    debug parameters.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

    RegistryPath - a pointer to this driver's key in the Services tree.

Return Value:

    STATUS_SUCCESS unless we can't allocate a mutex.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;

#if DBG
    //
    // We use this to query into the registry as to whether we
    // should break at driver entry.
    //
    RTL_QUERY_REGISTRY_TABLE paramTable[3];
    ULONG zero = 0;
    ULONG one = 1;
    ULONG debugLevel = 0;
    ULONG shouldBreak = 0;
    ULONG notConfigurable = 0;
    PWCHAR path;
    ULONG pathLength;

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //
    pathLength = RegistryPath->Length + sizeof(WCHAR);

    if ( path = ExAllocatePool(PagedPool, pathLength) ) {

        RtlZeroMemory( &paramTable[0], sizeof(paramTable) );
        RtlZeroMemory( path, pathLength);
        RtlMoveMemory( path, RegistryPath->Buffer, RegistryPath->Length );

        paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name          = L"BreakOnEntry";
        paramTable[0].EntryContext  = &shouldBreak;
        paramTable[0].DefaultType   = REG_DWORD;
        paramTable[0].DefaultData   = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name          = L"DebugLevel";
        paramTable[1].EntryContext  = &debugLevel;
        paramTable[1].DefaultType   = REG_DWORD;
        paramTable[1].DefaultData   = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                            path,
                            &paramTable[0],
                            NULL,
                            NULL))) {

            shouldBreak = 0;
            debugLevel = 0;

        }

        ExFreePool( path );
    }

    FloppyDebugLevel = debugLevel;

    if ( shouldBreak ) {

        DbgBreakPoint();
    }

#endif

    FloppyDump(FLOPSHOW, ("Floppy: DriverEntry\n") );

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = FloppyCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = FloppyCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ]           = FloppyReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = FloppyReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = FloppyDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = FloppyPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = FloppyPower;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = FloppySystemControl;

    DriverObject->DriverUnload = FloppyUnload;

    DriverObject->DriverExtension->AddDevice = FloppyAddDevice;

    //
    //  Allocate and initialize a mutex for paging the driver.
    //
    PagingMutex = ExAllocatePool( NonPagedPool, sizeof(FAST_MUTEX) );

    if ( PagingMutex == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeFastMutex(PagingMutex);

    //
    //  Now page out the driver and wait for a call to FloppyAddDevice.
    //
    MmPageEntireDriver(DriverEntry);

    DriveMediaLimits =
        (IsNEC_98 ? (PDRIVE_MEDIA_LIMITS)&_DriveMediaLimits_NEC98[0] : &_DriveMediaLimits[0]);

    DriveMediaConstants =
        (IsNEC_98 ? (PDRIVE_MEDIA_CONSTANTS)&_DriveMediaConstants_NEC98[0] : &_DriveMediaConstants[0]);

    return ntStatus;
}

VOID
FloppyUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Unload the driver from the system.  The paging mutex is freed before
    final unload.

Arguments:

    DriverObject - a pointer to the object that represents this device
                   driver.

Return Value:
    
    none

--*/

{
    FloppyDump( FLOPSHOW, ("FloppyUnload:\n"));

    //
    //  The device object(s) should all be gone by now.
    //
    ASSERT( DriverObject->DeviceObject == NULL );

    //
    //  Free the paging mutex that was allocated in DriverEntry.
    //
    ExFreePool( PagingMutex );

    return;
}

NTSTATUS
FloppyAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is the driver's pnp add device entry point.  It is
    called by the pnp manager to initialize the driver.

    Add device creates and initializes a device object for this FDO and 
    attaches to the underlying PDO.

Arguments:

    DriverObject - a pointer to the object that represents this device
    driver.
    PhysicalDeviceObject - a pointer to the underlying PDO to which this
    new device will attach.

Return Value:

    If we successfully create a device object, STATUS_SUCCESS is
    returned.  Otherwise, return the appropriate error code.

--*/

{
    NTSTATUS            ntStatus;
    PDEVICE_OBJECT      deviceObject;
    PDISKETTE_EXTENSION disketteExtension;
    FDC_INFO            fdcInfo;
    UCHAR               arcNameBuffer[256];
    STRING              arcNameString;
    WCHAR               deviceNameBuffer[20];
    UNICODE_STRING      deviceName;


    ntStatus = STATUS_SUCCESS;

    FloppyDump( FLOPSHOW, ("FloppyAddDevice:  CreateDeviceObject\n"));

    //
    //  Get some device information from the underlying PDO.
    //
    fdcInfo.BufferCount = 0;
    fdcInfo.BufferSize = 0;

    ntStatus = FlFdcDeviceIo( PhysicalDeviceObject,
                              IOCTL_DISK_INTERNAL_GET_FDC_INFO,
                              &fdcInfo );

    if ( NT_SUCCESS(ntStatus) ) {

        USHORT i = 0;

        //
        //  Create a device.  We will use the first available device name for 
        //  this device.
        //
        do {

            swprintf( deviceNameBuffer, L"\\Device\\Floppy%d", i++ );
            RtlInitUnicodeString( &deviceName, deviceNameBuffer );
            ntStatus = IoCreateDevice( DriverObject,
                                       sizeof( DISKETTE_EXTENSION ),
                                       &deviceName,
                                       FILE_DEVICE_DISK,
                                       (FILE_REMOVABLE_MEDIA | 
                                        FILE_FLOPPY_DISKETTE |
                                        FILE_DEVICE_SECURE_OPEN),
                                       FALSE,
                                       &deviceObject );

        } while ( ntStatus == STATUS_OBJECT_NAME_COLLISION );

        if ( NT_SUCCESS(ntStatus) ) {

            disketteExtension = (PDISKETTE_EXTENSION)deviceObject->DeviceExtension;

            //
            //  Save the device name.
            //
            FloppyDump( FLOPSHOW | FLOPPNP,
                        ("FloppyAddDevice - Device Object Name - %S\n", deviceNameBuffer) );

            disketteExtension->DeviceName.Buffer = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, deviceName.Length );
            if ( disketteExtension->DeviceName.Buffer == NULL ) {

                IoDeleteDevice( deviceObject );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            disketteExtension->DeviceName.Length = 0;
            disketteExtension->DeviceName.MaximumLength = deviceName.Length;
            RtlCopyUnicodeString( &disketteExtension->DeviceName, &deviceName );

            IoGetConfigurationInformation()->FloppyCount++;

            //
            // Create a symbolic link from the disk name to the corresponding
            // ARC name, to be used if we're booting off the disk.  This will
            // if it's not system initialization time; that's fine.  The ARC
            // name looks something like \ArcName\multi(0)disk(0)rdisk(0).
            //
            sprintf( arcNameBuffer,
                     "%s(%d)disk(%d)fdisk(%d)",
                     "\\ArcName\\multi",
                     fdcInfo.BusNumber,
                     fdcInfo.ControllerNumber,
                     fdcInfo.PeripheralNumber );

            RtlInitString( &arcNameString, arcNameBuffer );

            ntStatus = RtlAnsiStringToUnicodeString( &disketteExtension->ArcName,
                                                     &arcNameString,
                                                     TRUE );

            if ( NT_SUCCESS( ntStatus ) ) {

                IoAssignArcName( &disketteExtension->ArcName, &deviceName );
            }

            deviceObject->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;

            if ( deviceObject->AlignmentRequirement < FILE_WORD_ALIGNMENT ) {

                deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
            }

            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

            disketteExtension->DriverObject = DriverObject;

            // Set the PDO for use with PlugPlay functions
            disketteExtension->UnderlyingPDO = PhysicalDeviceObject;

            FloppyDump( FLOPSHOW, 
                        ("FloppyAddDevice: Attaching %p to %p\n", 
                        deviceObject, 
                        PhysicalDeviceObject));

            disketteExtension->TargetObject = 
                        IoAttachDeviceToDeviceStack( deviceObject,
                                                     PhysicalDeviceObject );

            FloppyDump( FLOPSHOW, 
                        ("FloppyAddDevice: TargetObject = %p\n",
                        disketteExtension->TargetObject) );

            KeInitializeSemaphore( &disketteExtension->RequestSemaphore,
                                   0L,
                                   MAXLONG );

            ExInitializeFastMutex( &disketteExtension->PowerDownMutex );

            KeInitializeSpinLock( &disketteExtension->ListSpinLock );

            ExInitializeFastMutex( &disketteExtension->ThreadReferenceMutex );

            ExInitializeFastMutex( &disketteExtension->HoldNewReqMutex );

            InitializeListHead( &disketteExtension->ListEntry );

            disketteExtension->ThreadReferenceCount = -1;

            disketteExtension->IsStarted = FALSE;
            disketteExtension->IsRemoved = FALSE;
            disketteExtension->HoldNewRequests = FALSE;
            InitializeListHead( &disketteExtension->NewRequestQueue );
            KeInitializeSpinLock( &disketteExtension->NewRequestQueueSpinLock );
            KeInitializeSpinLock( &disketteExtension->FlCancelSpinLock );
            KeInitializeEvent(&disketteExtension->QueryPowerEvent,
                              SynchronizationEvent,
                              FALSE);
            disketteExtension->FloppyControllerAllocated = FALSE;
            disketteExtension->ReleaseFdcWithMotorRunning = FALSE;
            disketteExtension->DeviceObject = deviceObject;

            disketteExtension->IsReadOnly = FALSE;

            disketteExtension->MediaType = Undetermined;

            disketteExtension->ControllerConfigurable = (IsNEC_98) ? FALSE : TRUE;
        }
    }

    return ntStatus;
}


NTSTATUS
FloppySystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*+++

Routine Description ;

    This is the dispatch routine for IRP_MJ_SYSTEM_CONTROL IRPs. 
    Currently we don't handle it. Just pass it down to the lower 
    device.
    
Arguments:

    DeviceObject - a pointer to the object that represents the device

    Irp - a pointer to the I/O Request Packet for this request.

Return Value :

    Status returned by lower device.
--*/
{
    PDISKETTE_EXTENSION disketteExtension = DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    return IoCallDriver(disketteExtension->TargetObject, Irp);
}


NTSTATUS
FlConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )

/*++

Routine Description:

    This routine is used to acquire all of the configuration
    information for each floppy disk controller and the
    peripheral driver attached to that controller.

Arguments:

    Context - Pointer to the confuration information we are building
              up.

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/

{

    //
    // So we don't have to typecast the context.
    //
    PDISKETTE_EXTENSION disketteExtension = Context;

    //
    // Simple iteration variable.
    //
    ULONG i;

    PCM_FULL_RESOURCE_DESCRIPTOR peripheralData;

    NTSTATUS ntStatus;

    ASSERT(ControllerType == DiskController);
    ASSERT(PeripheralType == FloppyDiskPeripheral);

    //
    // Check if the infprmation from the registry for this device
    // is valid.
    //

    if (!(((PUCHAR)PeripheralInformation[IoQueryDeviceConfigurationData]) +
        PeripheralInformation[IoQueryDeviceConfigurationData]->DataLength)) {

        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;

    }

    peripheralData = (PCM_FULL_RESOURCE_DESCRIPTOR)
        (((PUCHAR)PeripheralInformation[IoQueryDeviceConfigurationData]) +
        PeripheralInformation[IoQueryDeviceConfigurationData]->DataOffset);

    //
    // With Version 2.0 or greater for this resource list, we will get
    // the full int13 information for the drive. So get that if available.
    //
    // Otherwise, the only thing that we want out of the peripheral information
    // is the maximum drive capacity.
    //
    // Drop any information on the floor other than the
    // device specfic floppy information.
    //

    for ( i = 0; i < peripheralData->PartialResourceList.Count; i++ ) {

        PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
            &peripheralData->PartialResourceList.PartialDescriptors[i];

        if ( partial->Type == CmResourceTypeDeviceSpecific ) {

            //
            // Point to right after this partial.  This will take
            // us to the beginning of the "real" device specific.
            //

            PCM_FLOPPY_DEVICE_DATA fDeviceData;
            UCHAR driveType;
            PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants =
                &(disketteExtension->BiosDriveMediaConstants);


            fDeviceData = (PCM_FLOPPY_DEVICE_DATA)(partial + 1);

            //
            // Get the driver density
            //

            switch ( fDeviceData->MaxDensity ) {

                case 360:   driveType = DRIVE_TYPE_0360;    break;
                case 1200:  driveType = DRIVE_TYPE_1200;    break;
                case 1185:  driveType = DRIVE_TYPE_1200;    break;
                case 1423:  driveType = DRIVE_TYPE_1440;    break;
                case 1440:  driveType = DRIVE_TYPE_1440;    break;
                case 2880:  driveType = DRIVE_TYPE_2880;    break;
                case 1201:  if (IsNEC_98) {
                                driveType = DRIVE_TYPE_1200_E;  break;
                            } // (IsNEC_98)

                default:

                    FloppyDump( 
                        FLOPDBGP, 
                        ("Floppy: Bad DriveCapacity!\n"
                        "------  density is %d\n",
                        fDeviceData->MaxDensity) 
                        );

                    driveType = DRIVE_TYPE_1200;

                    FloppyDump( 
                        FLOPDBGP,
                        ("Floppy: run a setup program to set the floppy\n"
                        "------  drive type; assuming 1.2mb\n"
                        "------  (type is %x)\n",fDeviceData->MaxDensity) 
                        );

                    break;

            }

            disketteExtension->DriveType = driveType;

            //
            // Pick up all the default from our own table and override
            // with the BIOS information
            //

            *biosDriveMediaConstants = DriveMediaConstants[
                DriveMediaLimits[driveType].HighestDriveMediaType];

            //
            // If the version is high enough, get the rest of the
            // information.  DeviceSpecific information with a version >= 2
            // should have this information
            //

            if ( fDeviceData->Version >= 2 ) {


                // biosDriveMediaConstants->MediaType =

                biosDriveMediaConstants->StepRateHeadUnloadTime =
                    fDeviceData->StepRateHeadUnloadTime;

                biosDriveMediaConstants->HeadLoadTime =
                    fDeviceData->HeadLoadTime;

                biosDriveMediaConstants->MotorOffTime =
                    fDeviceData->MotorOffTime;

                biosDriveMediaConstants->SectorLengthCode =
                    fDeviceData->SectorLengthCode;

                // biosDriveMediaConstants->BytesPerSector =

                if (fDeviceData->SectorPerTrack == 0) {
                    // This is not a valid sector per track value.
                    // We don't recognize this drive.  This bogus
                    // value is often returned by SCSI floppies.
                    return STATUS_SUCCESS;
                }

                if (fDeviceData->MaxDensity == 0 ) {
                    //
                    // This values are returned by the LS-120 atapi drive.
                    // BIOS function 8, in int 13 is returned in bl, which
                    // is mapped to this field. The LS-120 returns 0x10
                    // which is mapped to 0.  Thats why we wont pick it up
                    // as a normal floppy.
                    //
                    return STATUS_SUCCESS;
                }

                biosDriveMediaConstants->SectorsPerTrack =
                    fDeviceData->SectorPerTrack;

                biosDriveMediaConstants->ReadWriteGapLength =
                    fDeviceData->ReadWriteGapLength;

                biosDriveMediaConstants->FormatGapLength =
                    fDeviceData->FormatGapLength;

                biosDriveMediaConstants->FormatFillCharacter =
                    fDeviceData->FormatFillCharacter;

                biosDriveMediaConstants->HeadSettleTime =
                    fDeviceData->HeadSettleTime;

                biosDriveMediaConstants->MotorSettleTimeRead =
                    fDeviceData->MotorSettleTime * 1000 / 8;

                biosDriveMediaConstants->MotorSettleTimeWrite =
                    fDeviceData->MotorSettleTime * 1000 / 8;

                if (fDeviceData->MaximumTrackValue == 0) {
                    // This is not a valid maximum track value.
                    // We don't recognize this drive.  This bogus
                    // value is often returned by SCSI floppies.
                    return STATUS_SUCCESS;
                }

                biosDriveMediaConstants->MaximumTrack =
                    fDeviceData->MaximumTrackValue;

                biosDriveMediaConstants->DataLength =
                    fDeviceData->DataTransferLength;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FlAcpiConfigureFloppy(
    PDISKETTE_EXTENSION DisketteExtension,
    PFDC_INFO FdcInfo
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    UCHAR driveType;

    PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants =
                &(DisketteExtension->BiosDriveMediaConstants);

    if ( !FdcInfo->AcpiFdiSupported ) {

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get the driver density
    //
    //    JB:TBD - review this drive type list.
    //
    switch ( (ACPI_FDI_DEVICE_TYPE)FdcInfo->AcpiFdiData.DeviceType ) {

    case Form525Capacity360:   driveType = DRIVE_TYPE_0360;    break;
    case Form525Capacity1200:  driveType = DRIVE_TYPE_1200;    break;
    case Form35Capacity720:    driveType = DRIVE_TYPE_0720;    break;
    case Form35Capacity1440:   driveType = DRIVE_TYPE_1440;    break;
    case Form35Capacity2880:   driveType = DRIVE_TYPE_2880;    break;

    default:                   driveType = DRIVE_TYPE_1200;    break;

    }

    DisketteExtension->DriveType = driveType;

    //
    // Pick up all the default from our own table and override
    // with the BIOS information
    //

    *biosDriveMediaConstants = DriveMediaConstants[
        DriveMediaLimits[driveType].HighestDriveMediaType];

    biosDriveMediaConstants->StepRateHeadUnloadTime = (UCHAR) FdcInfo->AcpiFdiData.StepRateHeadUnloadTime;
    biosDriveMediaConstants->HeadLoadTime           = (UCHAR) FdcInfo->AcpiFdiData.HeadLoadTime;
    biosDriveMediaConstants->MotorOffTime           = (UCHAR) FdcInfo->AcpiFdiData.MotorOffTime;
    biosDriveMediaConstants->SectorLengthCode       = (UCHAR) FdcInfo->AcpiFdiData.SectorLengthCode;
    biosDriveMediaConstants->SectorsPerTrack        = (UCHAR) FdcInfo->AcpiFdiData.SectorPerTrack;
    biosDriveMediaConstants->ReadWriteGapLength     = (UCHAR) FdcInfo->AcpiFdiData.ReadWriteGapLength;
    biosDriveMediaConstants->FormatGapLength        = (UCHAR) FdcInfo->AcpiFdiData.FormatGapLength;
    biosDriveMediaConstants->FormatFillCharacter    = (UCHAR) FdcInfo->AcpiFdiData.FormatFillCharacter;
    biosDriveMediaConstants->HeadSettleTime         = (UCHAR) FdcInfo->AcpiFdiData.HeadSettleTime;
    biosDriveMediaConstants->MotorSettleTimeRead    = (UCHAR) FdcInfo->AcpiFdiData.MotorSettleTime * 1000 / 8;
    biosDriveMediaConstants->MotorSettleTimeWrite   = (USHORT) FdcInfo->AcpiFdiData.MotorSettleTime * 1000 / 8;
    biosDriveMediaConstants->MaximumTrack           = (UCHAR) FdcInfo->AcpiFdiData.MaxCylinderNumber;
    biosDriveMediaConstants->DataLength             = (UCHAR) FdcInfo->AcpiFdiData.DataTransferLength;

    return STATUS_SUCCESS;
}

NTSTATUS
FlQueueIrpToThread(
    IN OUT  PIRP                Irp,
    IN OUT  PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    This routine queues the given irp to be serviced by the controller's
    thread.  If the thread is down then this routine creates the thread.

Arguments:

    Irp             - Supplies the IRP to queue to the controller's thread.

    ControllerData  - Supplies the controller data.

Return Value:

    May return an error if PsCreateSystemThread fails.
    Otherwise returns STATUS_PENDING and marks the IRP pending.

--*/

{
    KIRQL       oldIrql;
    NTSTATUS    status;
    HANDLE      threadHandle;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );


    //
    // Verify if the system is powering down. If so we fail
    // the irps.
    //
    ExAcquireFastMutex(&DisketteExtension->PowerDownMutex);
    if (DisketteExtension->PoweringDown == TRUE) {
       ExReleaseFastMutex(&DisketteExtension->PowerDownMutex);
       FloppyDump( FLOPDBGP, 
                  ("Queue IRP: Bailing out since power irp is waiting.\n"));

       Irp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
       Irp->IoStatus.Information = 0;
       return STATUS_POWER_STATE_INVALID;
    } 
    ExReleaseFastMutex(&DisketteExtension->PowerDownMutex);
    FloppyDump( FLOPSHOW, ("Queue IRP: No power irp waiting.\n"));

    ExAcquireFastMutex(&DisketteExtension->ThreadReferenceMutex);

    if (++(DisketteExtension->ThreadReferenceCount) == 0) {
       OBJECT_ATTRIBUTES ObjAttributes;

        DisketteExtension->ThreadReferenceCount++;

        FloppyResetDriverPaging();

        //
        //  Create the thread.
        //
        ASSERT(DisketteExtension->FloppyThread == NULL);
        InitializeObjectAttributes(&ObjAttributes, NULL,
                                   OBJ_KERNEL_HANDLE,
                                   NULL,
                                   NULL);

        status = PsCreateSystemThread(&threadHandle,
                                      (ACCESS_MASK) 0L,
                                      &ObjAttributes,
                                      (HANDLE) 0L,
                                      NULL,
                                      FloppyThread,
                                      DisketteExtension);

        if (!NT_SUCCESS(status)) {
            DisketteExtension->ThreadReferenceCount = -1;

            FloppyPageEntireDriver();

            ExReleaseFastMutex(&DisketteExtension->ThreadReferenceMutex);
            return status;
        }

        status = ObReferenceObjectByHandle( threadHandle,
                                            SYNCHRONIZE,
                                            NULL,
                                            KernelMode,
                                            &DisketteExtension->FloppyThread,
                                            NULL );

        ASSERT(NT_SUCCESS(status));

        ZwClose(threadHandle);


        if (!NT_SUCCESS(status)) {
            DisketteExtension->ThreadReferenceCount = -1;

            DisketteExtension->FloppyThread = NULL;

            FloppyPageEntireDriver();

            ExReleaseFastMutex(&DisketteExtension->ThreadReferenceMutex);

            return status;
        }

        ExReleaseFastMutex(&DisketteExtension->ThreadReferenceMutex);

    } else {
        ExReleaseFastMutex(&DisketteExtension->ThreadReferenceMutex);
    }

    IoMarkIrpPending(Irp);

    ExInterlockedInsertTailList(
        &DisketteExtension->ListEntry,
        &Irp->Tail.Overlay.ListEntry,
        &DisketteExtension->ListSpinLock );

    KeReleaseSemaphore(
        &DisketteExtension->RequestSemaphore,
        (KPRIORITY) 0,
        1,
        FALSE );

    return STATUS_PENDING;
}

NTSTATUS
FloppyCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    FloppyDump(
        FLOPSHOW,
        ("FloppyCreateClose...\n")
        );

    //
    // Null operation.  Do not give an I/O boost since
    // no I/O was actually done.  IoStatus.Information should be
    // FILE_OPENED for an open; it's undefined for a close.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}

NTSTATUS
FloppyDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDISKETTE_EXTENSION disketteExtension;
    PDISK_GEOMETRY outputBuffer;
    NTSTATUS ntStatus;
    ULONG outputBufferLength;
    UCHAR i;
    DRIVE_MEDIA_TYPE lowestDriveMediaType;
    DRIVE_MEDIA_TYPE highestDriveMediaType;
    ULONG formatExParametersSize;
    PFORMAT_EX_PARAMETERS formatExParameters;

    FloppyDump( FLOPSHOW, ("FloppyDeviceControl...\n") );

    disketteExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // We need to check if we are currently holding requests.
    //
    ExAcquireFastMutex(&(disketteExtension->HoldNewReqMutex));
    if ( disketteExtension->HoldNewRequests ) {

        //
        // Queue request only if this is not an ACPI exec method.  There is
        // a nasty recursion with ACPI and fdc/flpy that requires that these
        // requests get through in order to avoid a deadlock.
        //
        if ( irpSp->Parameters.DeviceIoControl.IoControlCode != IOCTL_ACPI_ASYNC_EVAL_METHOD ) {

            ntStatus = FloppyQueueRequest( disketteExtension, Irp );
            
            ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));
            return ntStatus;
        }
    }

    //
    //  If the device has been removed we will just fail this request outright.
    //
    if ( disketteExtension->IsRemoved ) {

        ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DELETE_PENDING;
    }

    //
    // If the device hasn't been started we will let the IOCTL through. This
    // is another hack for ACPI.
    //
    if (!disketteExtension->IsStarted) {

        ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));
        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( disketteExtension->TargetObject, Irp );
    }

    switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {
        
        case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME: {

            PMOUNTDEV_NAME mountName;

            FloppyDump( FLOPSHOW, ("FloppyDeviceControl: IOCTL_MOUNTDEV_QUERY_DEVICE_NAME\n") );
            ASSERT(disketteExtension->DeviceName.Buffer);

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(MOUNTDEV_NAME) ) {

                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            mountName = Irp->AssociatedIrp.SystemBuffer;
            mountName->NameLength = disketteExtension->DeviceName.Length;

            if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(USHORT) + mountName->NameLength) {

                ntStatus = STATUS_BUFFER_OVERFLOW;
                Irp->IoStatus.Information = sizeof(MOUNTDEV_NAME);
                break;
            }

            RtlCopyMemory( mountName->Name, disketteExtension->DeviceName.Buffer,
                           mountName->NameLength);

            ntStatus = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(USHORT) + mountName->NameLength;
            break;
            }

        case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID: {

            PMOUNTDEV_UNIQUE_ID uniqueId;

            FloppyDump( FLOPSHOW, ("FloppyDeviceControl: IOCTL_MOUNTDEV_QUERY_UNIQUE_ID\n") );

            if ( !disketteExtension->InterfaceString.Buffer ||
                 irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                  sizeof(MOUNTDEV_UNIQUE_ID)) {

                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            uniqueId = Irp->AssociatedIrp.SystemBuffer;
            uniqueId->UniqueIdLength =
                    disketteExtension->InterfaceString.Length;

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(USHORT) + uniqueId->UniqueIdLength) {

                ntStatus = STATUS_BUFFER_OVERFLOW;
                Irp->IoStatus.Information = sizeof(MOUNTDEV_UNIQUE_ID);
                break;
            }

            RtlCopyMemory( uniqueId->UniqueId,
                           disketteExtension->InterfaceString.Buffer,
                           uniqueId->UniqueIdLength );

            ntStatus = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(USHORT) +
                                        uniqueId->UniqueIdLength;
            break;
            }

        case IOCTL_DISK_FORMAT_TRACKS:
        case IOCTL_DISK_FORMAT_TRACKS_EX:

            //
            // Make sure that we got all the necessary format parameters.
            //

            if ( irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof( FORMAT_PARAMETERS ) ) {

                FloppyDump(
                    FLOPDBGP,
                    ("Floppy: invalid FORMAT buffer length\n")
                    );

                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // Make sure the parameters we got are reasonable.
            //

            if ( !FlCheckFormatParameters(
                disketteExtension,
                (PFORMAT_PARAMETERS) Irp->AssociatedIrp.SystemBuffer ) ) {

                FloppyDump(
                    FLOPDBGP,
                    ("Floppy: invalid FORMAT parameters\n")
                    );

                ntStatus = STATUS_INVALID_PARAMETER;
                break;
            }

            //
            // If this is an EX request then make a couple of extra checks
            //

            if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
                IOCTL_DISK_FORMAT_TRACKS_EX) {

                if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    sizeof(FORMAT_EX_PARAMETERS)) {

                    ntStatus = STATUS_INVALID_PARAMETER;
                    break;
                }

                formatExParameters = (PFORMAT_EX_PARAMETERS)
                                     Irp->AssociatedIrp.SystemBuffer;
                formatExParametersSize =
                        FIELD_OFFSET(FORMAT_EX_PARAMETERS, SectorNumber) +
                        formatExParameters->SectorsPerTrack*sizeof(USHORT);

                if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                    formatExParametersSize ||
                    formatExParameters->FormatGapLength >= 0x100 ||
                    formatExParameters->SectorsPerTrack >= 0x100) {

                    ntStatus = STATUS_INVALID_PARAMETER;
                    break;
                }
            }

            //
            // Fall through to queue the request.
            //

        case IOCTL_DISK_CHECK_VERIFY:
        case IOCTL_STORAGE_CHECK_VERIFY:
        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        case IOCTL_DISK_IS_WRITABLE:

            //
            // The thread must know which diskette to operate on, but the
            // request list only passes the IRP.  So we'll stick a pointer
            // to the diskette extension in Type3InputBuffer, which is
            // a field that isn't used for floppy ioctls.
            //

            //
            // Add the request to the queue, and wake up the thread to
            // process it.
            //

//            irpSp->Parameters.DeviceIoControl.Type3InputBuffer = (PVOID)
//                disketteExtension;

            FloppyDump(
                FLOPIRPPATH,
                ("Floppy: Enqueing  up IRP: %p\n",Irp)
                );

            ntStatus = FlQueueIrpToThread(Irp, disketteExtension);

            break;

        case IOCTL_DISK_GET_MEDIA_TYPES:
        case IOCTL_STORAGE_GET_MEDIA_TYPES: {

            FloppyDump(
                FLOPSHOW,
                ("Floppy: IOCTL_DISK_GET_MEDIA_TYPES called\n")
                );

            lowestDriveMediaType = DriveMediaLimits[
                disketteExtension->DriveType].LowestDriveMediaType;
            highestDriveMediaType = DriveMediaLimits[
                disketteExtension->DriveType].HighestDriveMediaType;

            outputBufferLength =
                irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            //
            // Make sure that the input buffer has enough room to return
            // at least one descriptions of a supported media type.
            //

            if ( outputBufferLength < ( sizeof( DISK_GEOMETRY ) ) ) {

                FloppyDump(
                    FLOPDBGP,
                    ("Floppy: invalid GET_MEDIA_TYPES buffer size\n")
                    );

                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Assume success, although we might modify it to a buffer
            // overflow warning below (if the buffer isn't big enough
            // to hold ALL of the media descriptions).
            //

            ntStatus = STATUS_SUCCESS;

            if ( outputBufferLength < ( sizeof( DISK_GEOMETRY ) *
                ( highestDriveMediaType - lowestDriveMediaType + 1 ) ) ) {

                //
                // The buffer is too small for all of the descriptions;
                // calculate what CAN fit in the buffer.
                //

                FloppyDump(
                    FLOPDBGP,
                    ("Floppy: GET_MEDIA_TYPES buffer size too small\n")
                    );

                ntStatus = STATUS_BUFFER_OVERFLOW;

                highestDriveMediaType =
                    (DRIVE_MEDIA_TYPE)( ( lowestDriveMediaType - 1 ) +
                    ( outputBufferLength /
                    sizeof( DISK_GEOMETRY ) ) );
            }

            outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;

            for (
                i = (UCHAR)lowestDriveMediaType;
                i <= (UCHAR)highestDriveMediaType;
                i++ ) {

                outputBuffer->MediaType = DriveMediaConstants[i].MediaType;
                outputBuffer->Cylinders.LowPart =
                    DriveMediaConstants[i].MaximumTrack + 1;
                outputBuffer->Cylinders.HighPart = 0;
                outputBuffer->TracksPerCylinder =
                    DriveMediaConstants[i].NumberOfHeads;
                outputBuffer->SectorsPerTrack =
                    DriveMediaConstants[i].SectorsPerTrack;
                outputBuffer->BytesPerSector =
                    DriveMediaConstants[i].BytesPerSector;
                FloppyDump(
                    FLOPSHOW,
                    ("Floppy: media types supported [%d]\n"
                     "------- Cylinders low:  0x%x\n"
                     "------- Cylinders high: 0x%x\n"
                     "------- Track/Cyl:      0x%x\n"
                     "------- Sectors/Track:  0x%x\n"
                     "------- Bytes/Sector:   0x%x\n"
                     "------- Media Type:       %d\n",
                     i,
                     outputBuffer->Cylinders.LowPart,
                     outputBuffer->Cylinders.HighPart,
                     outputBuffer->TracksPerCylinder,
                     outputBuffer->SectorsPerTrack,
                     outputBuffer->BytesPerSector,
                     outputBuffer->MediaType)
                     );
                outputBuffer++;

                Irp->IoStatus.Information += sizeof( DISK_GEOMETRY );
            }

            break;
        }

        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME: {

            if (IsNEC_98) {
                PMOUNTDEV_SUGGESTED_LINK_NAME   suggestedName;
                WCHAR                           driveLetterNameBuffer[10];
                RTL_QUERY_REGISTRY_TABLE        queryTable[2];
                PWSTR                           valueName;
                UNICODE_STRING                  driveLetterName;

                FloppyDump(FLOPDBGP,("FLOPPY: IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME to device %#08lx"
                            " through irp %#08lx\n", 
                            DeviceObject, Irp));

                if (!(DeviceObject->Characteristics & FILE_REMOVABLE_MEDIA)) {

                    ntStatus = STATUS_NOT_FOUND;
                    break;
                }

                if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof(MOUNTDEV_SUGGESTED_LINK_NAME)) {

                    ntStatus = STATUS_INVALID_PARAMETER;
                    break;
                }

                valueName = ExAllocatePool(PagedPool, sizeof(WCHAR) * 64);

                if (!valueName) {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlZeroMemory( valueName, sizeof(WCHAR) * 64 );
                RtlCopyMemory( valueName, 
                               disketteExtension->DeviceName.Buffer, 
                               disketteExtension->DeviceName.Length );

                driveLetterName.Buffer = driveLetterNameBuffer;
                driveLetterName.MaximumLength = 20;
                driveLetterName.Length = 0;

                RtlZeroMemory(queryTable, 2*sizeof(RTL_QUERY_REGISTRY_TABLE));
                queryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                                      RTL_QUERY_REGISTRY_DIRECT;
                queryTable[0].Name = valueName;
                queryTable[0].EntryContext = &driveLetterName;

                ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                                L"\\Registry\\Machine\\System\\DISK",
                                                queryTable, NULL, NULL);

                if (!NT_SUCCESS(ntStatus)) {
                    ExFreePool(valueName);
                    break;
                }

                if (driveLetterName.Length != 4 ||
                    driveLetterName.Buffer[0] < 'A' ||
                    driveLetterName.Buffer[0] > 'Z' ||
                    driveLetterName.Buffer[1] != ':') {

                    ntStatus = STATUS_NOT_FOUND;
                    ExFreePool(valueName);
                    break;
                }

                suggestedName = Irp->AssociatedIrp.SystemBuffer;
                suggestedName->UseOnlyIfThereAreNoOtherLinks = TRUE;
                suggestedName->NameLength = 28;

                Irp->IoStatus.Information =
                        FIELD_OFFSET(MOUNTDEV_SUGGESTED_LINK_NAME, Name) + 28;

                if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    Irp->IoStatus.Information) {

                    Irp->IoStatus.Information =
                            sizeof(MOUNTDEV_SUGGESTED_LINK_NAME);
                    ntStatus = STATUS_BUFFER_OVERFLOW;
                    ExFreePool(valueName);
                    break;
                }

                RtlDeleteRegistryValue(RTL_REGISTRY_ABSOLUTE,
                                       L"\\Registry\\Machine\\System\\DISK",
                                       valueName);

                ExFreePool(valueName);

                RtlCopyMemory(suggestedName->Name, L"\\DosDevices\\", 24);
                suggestedName->Name[12] = driveLetterName.Buffer[0];
                suggestedName->Name[13] = ':';

                break;
            } // (IsNEC_98)

            // Pass this to the default.
        }

       case IOCTL_DISK_SENSE_DEVICE: {

            if (IsNEC_98) {
                FloppyDump(
                    FLOPDBGP,
                    ("Floppy: SENSE_DEVISE_STATUS \n")
                    );

                //
                // Make sure that we got all the necessary IOCTL read write parameters.
                //

                if ( irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                    sizeof( SENSE_DEVISE_STATUS_PTOS ) ) {

                    FloppyDump(
                        FLOPDBGP,
                        ("Floppy: invalid SENSE_DEVISE_STATUS buffer length\n")
                      );

                    ntStatus = STATUS_INVALID_PARAMETER;
                    break;
                }


//                irpSp->Parameters.DeviceIoControl.Type3InputBuffer = (PVOID)
//                    disketteExtension;

                FloppyDump(
                    FLOPIRPPATH,
                    ("Floppy: Enqueing  up IRP: %p\n",Irp)
                    );


                ntStatus = FlQueueIrpToThread(Irp, disketteExtension);

                break;
            } // (IsNEC_98)
        }

        default: {

            //
            // We pass down IOCTL's because ACPI uses this as a communications
            // method. ACPI *should* have used a PNP Interface mechanism, but
            // it's too late now.
            //
#if 0
            FloppyDump(
                FLOPDBGP,
                ("Floppy: invalid device request %x\n",
                 irpSp->Parameters.DeviceIoControl.IoControlCode)
                );

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
#endif

            ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));
            IoSkipCurrentIrpStackLocation( Irp );
            ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );
            return ntStatus;
        }
    }

    ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

    if ( ntStatus != STATUS_PENDING ) {

        Irp->IoStatus.Status = ntStatus;
        if (!NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus )) {

            IoSetHardErrorOrVerifyDevice( Irp, DeviceObject );

        }
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return ntStatus;
}

NTSTATUS
FloppyPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDISKETTE_EXTENSION disketteExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG i;


    FloppyDump( FLOPSHOW, ("FloppyPnp:\n") );

    //
    //  Lock down the driver if it is not already locked.
    //
    FloppyResetDriverPaging();


    disketteExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    if ( disketteExtension->IsRemoved ) {

        //
        // Since the device is stopped, but we don't hold IRPs,
        // this is a surprise removal. Just fail it.
        //
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_DELETE_PENDING;
    }

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_START_DEVICE:

        ntStatus = FloppyStartDevice( DeviceObject, Irp );
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:

        if ( irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE ) {
            FloppyDump( FLOPPNP,("FloppyPnp: IRP_MN_QUERY_STOP_DEVICE - Irp: %p\n", Irp) );
        } else {
            FloppyDump( FLOPPNP,("FloppyPnp: IRP_MN_QUERY_REMOVE_DEVICE - Irp: %p\n", Irp) );
        }

        if ( !disketteExtension->IsStarted ) {
            //
            // If we aren't started, we'll just pass the irp down.
            //
            IoSkipCurrentIrpStackLocation (Irp);
            ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );

            return ntStatus;
        }

        //
        //  Hold all new requests.
        //
        ExAcquireFastMutex(&(disketteExtension->HoldNewReqMutex));
        disketteExtension->HoldNewRequests = TRUE;

        //
        //  Queue this irp to the floppy thread, this will shutdown the
        //  floppy thread without waiting for the typical 3 second motor
        //  timeout.
        //
        ntStatus = FlQueueIrpToThread( Irp, disketteExtension );

        ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

        //
        //  Wait for the floppy thread to finish.  This could take a few hundred
        //  milliseconds if the motor needs to be shut down.
        //
        if ( ntStatus == STATUS_PENDING ) {

            ASSERT(disketteExtension->FloppyThread != NULL);

            FlTerminateFloppyThread(disketteExtension);

            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation( Irp );
            IoCallDriver( disketteExtension->TargetObject, Irp );
            ntStatus = STATUS_PENDING;
        
        } else {
            //
            // We failed to either start the thread or get a pointer to the
            // thread object.  Either way veto the Query.
            //
            ntStatus = STATUS_UNSUCCESSFUL;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:

        if ( irpSp->MinorFunction == IRP_MN_CANCEL_STOP_DEVICE ) {
            FloppyDump( FLOPPNP,("FloppyPnp: IRP_MN_CANCEL_STOP_DEVICE - Irp: %p\n", Irp) );
        } else {
            FloppyDump( FLOPPNP,("FloppyPnp: IRP_MN_CANCEL_REMOVE_DEVICE - Irp: %p\n", Irp) );
        }

        if ( !disketteExtension->IsStarted ) {

            //
            // Nothing to do, just pass the irp down:
            // no need to start the device
            //
            // Set Status to SUCCESS before passing the irp down
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoSkipCurrentIrpStackLocation (Irp);
            ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );
            
        } else  {
            
            KEVENT doneEvent;

            //
            // Set the status to STATUS_SUCCESS
            //
            Irp->IoStatus.Status = STATUS_SUCCESS;
            
            //
            // We need to wait for the lower drivers to do their job.
            //
            IoCopyCurrentIrpStackLocationToNext (Irp);
        
            //
            // Clear the event: it will be set in the completion
            // routine.
            //
            KeInitializeEvent( &doneEvent, 
                               SynchronizationEvent, 
                               FALSE);
        
            IoSetCompletionRoutine( Irp,
                                    FloppyPnpComplete,
                                    &doneEvent,
                                    TRUE, TRUE, TRUE );

            ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );
        
            if ( ntStatus == STATUS_PENDING ) {

                KeWaitForSingleObject( &doneEvent,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL );

                ntStatus = Irp->IoStatus.Status;
            }
        
            ExAcquireFastMutex(&(disketteExtension->HoldNewReqMutex));
            disketteExtension->HoldNewRequests = FALSE;
            ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

            //
            // Process the queued requests
            //
            FloppyProcessQueuedRequests( disketteExtension );

            //
            // We must now complete the IRP, since we stopped it in the
            // completetion routine with MORE_PROCESSING_REQUIRED.
            //
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
        }
        break;

    case IRP_MN_STOP_DEVICE:

        FloppyDump( FLOPPNP,("FloppyPnp: IRP_MN_STOP_DEVICE - Irp: %p\n", Irp) );

        disketteExtension->IsStarted = FALSE;

        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );

        break;

    case IRP_MN_REMOVE_DEVICE:

        FloppyDump( FLOPPNP,("FloppyPnp: IRP_MN_REMOVE_DEVICE - Irp: %p\n", Irp) );

        FlTerminateFloppyThread(disketteExtension);

        //
        // We need to mark the fact that we don't hold requests first, since
        // we asserted earlier that we are holding requests only if
        // we're not removed.
        //
        ExAcquireFastMutex(&(disketteExtension->HoldNewReqMutex));
        disketteExtension->HoldNewRequests = FALSE;
        ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

        disketteExtension->IsStarted = FALSE;
        disketteExtension->IsRemoved = TRUE;

        //
        // Here we either have completed all the requests in a personal
        // queue when IRP_MN_QUERY_REMOVE was received, or will have to 
        // fail all of them if this is a surprise removal.
        // Note that fdoData->IsRemoved is TRUE, so pSD_ProcessQueuedRequests
        // will simply flush the queue, completing each IRP with
        // STATUS_DELETE_PENDING
        //
        FloppyProcessQueuedRequests( disketteExtension );

        //
        //  Forward this Irp to the underlying PDO
        //
        IoSkipCurrentIrpStackLocation( Irp );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );


        //
        //  Send notification that we are going away.
        //
        if ( disketteExtension->InterfaceString.Buffer != NULL ) {

            IoSetDeviceInterfaceState( &disketteExtension->InterfaceString,
                                       FALSE);

            RtlFreeUnicodeString( &disketteExtension->InterfaceString );
            RtlInitUnicodeString( &disketteExtension->InterfaceString, NULL );
        }

        RtlFreeUnicodeString( &disketteExtension->DeviceName );
        RtlInitUnicodeString( &disketteExtension->DeviceName, NULL );

        if ( disketteExtension->ArcName.Length != 0 ) {

            IoDeassignArcName( &disketteExtension->ArcName );
            RtlFreeUnicodeString( &disketteExtension->ArcName );
            RtlInitUnicodeString( &disketteExtension->ArcName, NULL );
        }

        //
        //  Detatch from the undelying device.
        //
        IoDetachDevice( disketteExtension->TargetObject );

        //
        //  And delete the device.
        //
        IoDeleteDevice( DeviceObject );

        IoGetConfigurationInformation()->FloppyCount--;

        break;

    default:
        FloppyDump( FLOPPNP, ("FloppyPnp: Unsupported PNP Request %x - Irp: %p\n",irpSp->MinorFunction, Irp) );
        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );
    }

    //
    //  Page out the driver if it is not busy elsewhere.
    //
    FloppyPageEntireDriver();

    return ntStatus;
}

NTSTATUS
FloppyStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    NTSTATUS ntStatus;
    NTSTATUS pnpStatus;
    KEVENT doneEvent;
    FDC_INFO fdcInfo;

    CONFIGURATION_TYPE Dc = DiskController;
    CONFIGURATION_TYPE Fp = FloppyDiskPeripheral;

    PDISKETTE_EXTENSION disketteExtension = (PDISKETTE_EXTENSION)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

    FloppyDump( FLOPSHOW,("FloppyStartDevice: Irp: %p\n", Irp) );
    FloppyDump( FLOPSHOW, ("  AllocatedResources = %08x\n",irpSp->Parameters.StartDevice.AllocatedResources));
    FloppyDump( FLOPSHOW, ("  AllocatedResourcesTranslated = %08x\n",irpSp->Parameters.StartDevice.AllocatedResourcesTranslated));

    //
    // First we must pass this Irp on to the PDO.
    //
    KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext( Irp );

    IoSetCompletionRoutine( Irp,
                            FloppyPnpComplete,
                            &doneEvent,
                            TRUE, TRUE, TRUE );

    ntStatus = IoCallDriver( disketteExtension->TargetObject, Irp );

    if ( ntStatus == STATUS_PENDING ) {

        ntStatus = KeWaitForSingleObject( &doneEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL );

        ASSERT( ntStatus == STATUS_SUCCESS );

        ntStatus = Irp->IoStatus.Status;
    }

    fdcInfo.BufferCount = 0;
    fdcInfo.BufferSize = 0;

    ntStatus = FlFdcDeviceIo( disketteExtension->TargetObject,
                              IOCTL_DISK_INTERNAL_GET_FDC_INFO,
                              &fdcInfo );

    if ( NT_SUCCESS(ntStatus) ) {

        disketteExtension->MaxTransferSize = fdcInfo.MaxTransferSize;

        if ( (fdcInfo.AcpiBios) &&
             (fdcInfo.AcpiFdiSupported) ) {

            ntStatus = FlAcpiConfigureFloppy( disketteExtension, &fdcInfo );

            if ( disketteExtension->DriveType == DRIVE_TYPE_2880 ) {

                disketteExtension->PerpendicularMode |= 1 << fdcInfo.PeripheralNumber;
            }

        } else {

            INTERFACE_TYPE InterfaceType;
    
            if ( disketteExtension->DriveType == DRIVE_TYPE_2880 ) {

                disketteExtension->PerpendicularMode |= 1 << fdcInfo.PeripheralNumber;
            }

            //
            // Query the registry till we find the correct interface type,
            // since we do not know what type of interface we are on.
            //
            for ( InterfaceType = 0;
                  InterfaceType < MaximumInterfaceType;
                  InterfaceType++ ) {
    
                fdcInfo.BusType = InterfaceType;
                ntStatus = IoQueryDeviceDescription( &fdcInfo.BusType,
                                                     &fdcInfo.BusNumber,
                                                     &Dc,
                                                     &fdcInfo.ControllerNumber,
                                                     &Fp,
                                                     &fdcInfo.PeripheralNumber,
                                                     FlConfigCallBack,
                                                     disketteExtension );
    
                if (NT_SUCCESS(ntStatus)) {
                   //
                   // We found the interface we are on.
                   //
                   FloppyDump(FLOPSHOW,
                              ("Interface Type is %x\n", InterfaceType));
                   break;
                }
            }
        }

        if ( NT_SUCCESS(ntStatus) ) {

            if (IsNEC_98) {
                disketteExtension->DeviceUnit = (UCHAR)fdcInfo.UnitNumber;
                disketteExtension->DriveOnValue = (UCHAR)fdcInfo.UnitNumber;
            } else { // (IsNEC_98)
                disketteExtension->DeviceUnit = (UCHAR)fdcInfo.PeripheralNumber;
                disketteExtension->DriveOnValue =
                    (UCHAR)(fdcInfo.PeripheralNumber | ( DRVCTL_DRIVE_0 << fdcInfo.PeripheralNumber ));
            } // (IsNEC_98)

            pnpStatus = IoRegisterDeviceInterface( disketteExtension->UnderlyingPDO,
                                                   (LPGUID)&MOUNTDEV_MOUNTED_DEVICE_GUID,
                                                   NULL,
                                                   &disketteExtension->InterfaceString );

            if ( NT_SUCCESS(pnpStatus) ) {

                pnpStatus = IoSetDeviceInterfaceState( &disketteExtension->InterfaceString,
                                                   TRUE );
            }

            disketteExtension->IsStarted = TRUE;

            ExAcquireFastMutex(&(disketteExtension->HoldNewReqMutex));
            disketteExtension->HoldNewRequests = FALSE;
            ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

            FloppyProcessQueuedRequests( disketteExtension );
        }
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

NTSTATUS
FloppyPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:
    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.

--*/
{

    KeSetEvent ((PKEVENT) Context, 1, FALSE);
    // No special priority
    // No Wait

    return STATUS_MORE_PROCESSING_REQUIRED; // Keep this IRP
}


VOID
FlTerminateFloppyThread(
    PDISKETTE_EXTENSION DisketteExtension
    )
{

    if (DisketteExtension->FloppyThread != NULL) {

        KeWaitForSingleObject( DisketteExtension->FloppyThread,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        //
        // Make sure again FloppyThread is not NULL.
        //
        if (DisketteExtension->FloppyThread != NULL) {
           ObDereferenceObject(DisketteExtension->FloppyThread);
        }

        DisketteExtension->FloppyThread = NULL;
    }
}


NTSTATUS
FloppyPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PDISKETTE_EXTENSION disketteExtension;
    NTSTATUS ntStatus = Irp->IoStatus.Status;
    PIO_STACK_LOCATION irpSp;
    POWER_STATE_TYPE type;
    POWER_STATE state;
    BOOLEAN WaitForCompletion = TRUE;

    FloppyDump( FLOPSHOW, ("FloppyPower:\n"));

    disketteExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    
    type = irpSp->Parameters.Power.Type;
    state = irpSp->Parameters.Power.State;

    switch(irpSp->MinorFunction) {
      
      case IRP_MN_QUERY_POWER: {
         FloppyDump( FLOPDBGP, 
                     ("IRP_MN_QUERY_POWER : Type - %d, State %d\n",
                     type, state));

         if ((type == SystemPowerState) &&
             (state.SystemState > PowerSystemHibernate)) {
            //
            // This is a shutdown request. Pass that.
            //
            ntStatus = STATUS_SUCCESS;
            break;
         }

         //
         // If there are no requests being processed or queued up
         // for floppy, ThreadReferenceCount will be -1. It can be 0 if
         // there was only one request and that has been dequeued and is
         // currently being processed.
         //
         ExAcquireFastMutex(&disketteExtension->ThreadReferenceMutex);
         if (disketteExtension->ThreadReferenceCount > 0) {
            ExReleaseFastMutex(&disketteExtension->ThreadReferenceMutex);
            FloppyDump(FLOPDBGP, 
                       ("Floppy: Requests pending. Cannot powerdown!\n"));
     
            PoStartNextPowerIrp(Irp);
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return STATUS_DEVICE_BUSY;
         } else if ((disketteExtension->ThreadReferenceCount == 0) &&
                    ((disketteExtension->FloppyThread) != NULL)) {
             FloppyDump(FLOPDBGP,
                        ("Ref count 0. No request pending.\n"));
             ExReleaseFastMutex(&disketteExtension->ThreadReferenceMutex);


             ExAcquireFastMutex(&disketteExtension->PowerDownMutex);
             disketteExtension->ReceivedQueryPower = TRUE;
             ExReleaseFastMutex(&disketteExtension->PowerDownMutex);

             KeWaitForSingleObject(&disketteExtension->QueryPowerEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
         } else {
             FloppyDump(FLOPDBGP,
                        ("No IRPs pending. Let system hibernate"));
             ExReleaseFastMutex(&disketteExtension->ThreadReferenceMutex);
         }

         ntStatus = STATUS_SUCCESS;
         break;
      }

      case IRP_MN_SET_POWER: {
         //
         // Indicate that we are going to power down or power up
         // so that FloppyThread can process queued requests
         // accordingly.
         //
         if (type == SystemPowerState) {
            ExAcquireFastMutex(&disketteExtension->PowerDownMutex);
            if (state.SystemState == PowerSystemWorking) {
               FloppyDump( FLOPDBGP, ("Powering Up\n"));
               disketteExtension->PoweringDown = FALSE;
               WaitForCompletion = FALSE;
            } else {
               FloppyDump( FLOPDBGP, ("Powering down\n"));
               WaitForCompletion = TRUE;
               disketteExtension->PoweringDown = TRUE;
            }
            ExReleaseFastMutex(&disketteExtension->PowerDownMutex);
            //
            // Wait till FloppyThread signals that it is done with
            // the queued requests.
            //
            if ((disketteExtension->FloppyThread != NULL) &&
                (WaitForCompletion == TRUE)) {
               KeWaitForSingleObject( disketteExtension->FloppyThread,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL );
            }
         }
     
         FloppyDump( FLOPSHOW, ("Processing power irp : %p\n", Irp));
         ntStatus = STATUS_SUCCESS;
         break;
      }

      default: {
         break;
      }
    }


    PoStartNextPowerIrp( Irp );
    IoSkipCurrentIrpStackLocation( Irp );
    ntStatus = PoCallDriver( disketteExtension->TargetObject, Irp );

    return ntStatus;
}

NTSTATUS
FloppyReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to read or write to a
    device that we control.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_INVALID_PARAMETER if parameters are invalid,
    STATUS_PENDING otherwise.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus;
    PDISKETTE_EXTENSION disketteExtension;

    FloppyDump( FLOPSHOW, ("FloppyReadWrite...\n") );

    disketteExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // This IRP was sent to the function driver.
    // We need to check if we are currently holding requests.
    //
    ExAcquireFastMutex(&(disketteExtension->HoldNewReqMutex));
    if ( disketteExtension->HoldNewRequests ) {

        ntStatus = FloppyQueueRequest( disketteExtension, Irp );

        ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));
        return ntStatus;
    }

    //
    //  If the device is not active (not started yet or removed) we will
    //  just fail this request outright.
    //
    if ( disketteExtension->IsRemoved || !disketteExtension->IsStarted) {

        ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

        if ( disketteExtension->IsRemoved) {
            ntStatus = STATUS_DELETE_PENDING;
        }   else    {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return ntStatus;
    }

    if ( (disketteExtension->MediaType > Unknown) &&
         ((irpSp->Parameters.Read.ByteOffset.LowPart +
           irpSp->Parameters.Read.Length > disketteExtension->ByteCapacity) ||
          ((irpSp->Parameters.Read.Length &
           (disketteExtension->BytesPerSector - 1)) != 0 ))) {

        FloppyDump( FLOPDBGP,
                    ("Floppy: Invalid Parameter, rejecting request\n") );
        FloppyDump( FLOPWARN,
                    ("Floppy: Starting offset = %lx\n"
                     "------  I/O Length = %lx\n"
                     "------  ByteCapacity = %lx\n"
                     "------  BytesPerSector = %lx\n",
                     irpSp->Parameters.Read.ByteOffset.LowPart,
                     irpSp->Parameters.Read.Length,
                     disketteExtension->ByteCapacity,
                     disketteExtension->BytesPerSector) );

        ntStatus = STATUS_INVALID_PARAMETER;

    } else {

        //
        // verify that user is really expecting some I/O operation to
        // occur.
        //

        if (irpSp->Parameters.Read.Length) {

            //
            // Queue request to thread.
            //
    
            FloppyDump( FLOPIRPPATH,
                        ("Floppy: Enqueing  up IRP: %p\n",Irp) );
    
            ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
        } else {

            //
            // Complete this zero length request with no boost.
            //

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_SUCCESS;
            FloppyDump(FLOPDBGP,
               ("Zero length r/w request. Completing IRP.\n"));
            ntStatus = STATUS_SUCCESS;
        }
    }

    ExReleaseFastMutex(&(disketteExtension->HoldNewReqMutex));

    if ( ntStatus != STATUS_PENDING ) {
        Irp->IoStatus.Status = ntStatus;
        FloppyDump(FLOPDBGP,
           ("Completing request. NTStatus %x\n",
           ntStatus));
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return ntStatus;
}

NTSTATUS
FlInterpretError(
    IN UCHAR StatusRegister1,
    IN UCHAR StatusRegister2
    )

/*++

Routine Description:

    This routine is called when the floppy controller returns an error.
    Status registers 1 and 2 are passed in, and this returns an appropriate
    error status.

Arguments:

    StatusRegister1 - the controller's status register #1.

    StatusRegister2 - the controller's status register #2.

Return Value:

    An NTSTATUS error determined from the status registers.

--*/

{
    if ( ( StatusRegister1 & STREG1_CRC_ERROR ) ||
        ( StatusRegister2 & STREG2_CRC_ERROR ) ) {

        FloppyDump(
            FLOPSHOW,
            ("FlInterpretError: STATUS_CRC_ERROR\n")
            );
        return STATUS_CRC_ERROR;
    }

    if ( StatusRegister1 & STREG1_DATA_OVERRUN ) {

        FloppyDump(
            FLOPSHOW,
            ("FlInterpretError: STATUS_DATA_OVERRUN\n")
            );
        return STATUS_DATA_OVERRUN;
    }

    if ( ( StatusRegister1 & STREG1_SECTOR_NOT_FOUND ) ||
        ( StatusRegister1 & STREG1_END_OF_DISKETTE ) ) {

        FloppyDump(
            FLOPSHOW,
            ("FlInterpretError: STATUS_NONEXISTENT_SECTOR\n")
            );
        return STATUS_NONEXISTENT_SECTOR;
    }

    if ( ( StatusRegister2 & STREG2_DATA_NOT_FOUND ) ||
        ( StatusRegister2 & STREG2_BAD_CYLINDER ) ||
        ( StatusRegister2 & STREG2_DELETED_DATA ) ) {

        FloppyDump(
            FLOPSHOW,
            ("FlInterpretError: STATUS_DEVICE_DATA_ERROR\n")
            );
        return STATUS_DEVICE_DATA_ERROR;
    }

    if ( StatusRegister1 & STREG1_WRITE_PROTECTED ) {

        FloppyDump(
            FLOPSHOW,
            ("FlInterpretError: STATUS_MEDIA_WRITE_PROTECTED\n")
            );
        return STATUS_MEDIA_WRITE_PROTECTED;
    }

    if ( StatusRegister1 & STREG1_ID_NOT_FOUND ) {

        FloppyDump(
            FLOPSHOW,
            ("FlInterpretError: STATUS_FLOPPY_ID_MARK_NOT_FOUND\n")
            );
        return STATUS_FLOPPY_ID_MARK_NOT_FOUND;

    }

    if ( StatusRegister2 & STREG2_WRONG_CYLINDER ) {

        FloppyDump(
            FLOPSHOW,
            ("FlInterpretError: STATUS_FLOPPY_WRONG_CYLINDER\n")
            );
        return STATUS_FLOPPY_WRONG_CYLINDER;

    }

    //
    // There's other error bits, but no good status values to map them
    // to.  Just return a generic one.
    //

    FloppyDump(
        FLOPSHOW,
        ("FlInterpretError: STATUS_FLOPPY_UNKNOWN_ERROR\n")
        );
    return STATUS_FLOPPY_UNKNOWN_ERROR;
}

VOID
FlFinishOperation(
    IN OUT PIRP Irp,
    IN PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    This routine is called by FloppyThread at the end of any operation
    whether it succeeded or not.

    If the packet is failing due to a hardware error, this routine will
    reinitialize the hardware and retry once.

    When the packet is done, this routine will start the timer to turn
    off the motor, and complete the IRP.

Arguments:

    Irp - a pointer to the IO Request Packet being processed.

    DisketteExtension - a pointer to the diskette extension for the
    diskette on which the operation occurred.

Return Value:

    None.

--*/

{
    NTSTATUS ntStatus;

    FloppyDump(
        FLOPSHOW,
        ("Floppy: FloppyFinishOperation...\n")
        );

    //
    // See if this packet is being failed due to a hardware error.
    //

    if ( ( Irp->IoStatus.Status != STATUS_SUCCESS ) &&
         ( DisketteExtension->HardwareFailed ) ) {

        DisketteExtension->HardwareFailCount++;

        if ( DisketteExtension->HardwareFailCount <
             HARDWARE_RESET_RETRY_COUNT ) {

            //
            // This is our first time through (that is, we're not retrying
            // the packet after a hardware failure).  If it failed this first
            // time because of a hardware problem, set the HardwareFailed flag
            // and put the IRP at the beginning of the request queue.
            //

            ntStatus = FlInitializeControllerHardware( DisketteExtension );

            if ( NT_SUCCESS( ntStatus ) ) {

                FloppyDump(
                    FLOPINFO,
                    ("Floppy: packet failed; hardware reset.  Retry.\n")
                    );

                //
                // Force media to be redetermined, in case we messed up
                // and to make sure FlDatarateSpecifyConfigure() gets
                // called.
                //

                DisketteExtension->MediaType = Undetermined;

                FloppyDump(
                    FLOPIRPPATH,
                    ("Floppy: irp %x failed - back on the queue with it\n",
                     Irp)
                    );

                ExAcquireFastMutex(&DisketteExtension->ThreadReferenceMutex);
                ASSERT(DisketteExtension->ThreadReferenceCount >= 0);
                (DisketteExtension->ThreadReferenceCount)++;
                ExReleaseFastMutex(&DisketteExtension->ThreadReferenceMutex);

                ExInterlockedInsertHeadList(
                    &DisketteExtension->ListEntry,
                    &Irp->Tail.Overlay.ListEntry,
                    &DisketteExtension->ListSpinLock );

                return;
            }

            FloppyDump(
                FLOPDBGP,
                ("Floppy: packet AND hardware reset failed.\n")
                );
        }

    }

    //
    // If we didn't already RETURN, we're done with this packet so
    // reset the HardwareFailCount for the next packet.
    //

    DisketteExtension->HardwareFailCount = 0;

    //
    // If this request was unsuccessful and the error is one that can be
    // remedied by the user, save the Device Object so that the file system,
    // after reaching its original entry point, can know the real device.
    //

    if ( !NT_SUCCESS( Irp->IoStatus.Status ) &&
         IoIsErrorUserInduced( Irp->IoStatus.Status ) ) {

        IoSetHardErrorOrVerifyDevice( Irp, DisketteExtension->DeviceObject );
    }

    //
    // Even if the operation failed, it probably had to wait for the drive
    // to spin up or somesuch so we'll always complete the request with the
    // standard priority boost.
    //

    if ( ( Irp->IoStatus.Status != STATUS_SUCCESS ) &&
        ( Irp->IoStatus.Status != STATUS_VERIFY_REQUIRED ) &&
        ( Irp->IoStatus.Status != STATUS_NO_MEDIA_IN_DEVICE ) ) {

        FloppyDump(
            FLOPDBGP,
            ("Floppy: IRP failed with error %lx\n", Irp->IoStatus.Status)
            );

    } else {

        FloppyDump(
            FLOPINFO,
            ("Floppy: IoStatus.Status = %x\n", Irp->IoStatus.Status)
            );
    }

    FloppyDump(
        FLOPINFO,
        ("Floppy: IoStatus.Information = %x\n", Irp->IoStatus.Information)
        );

    FloppyDump(
        FLOPIRPPATH,
        ("Floppy: Finishing up IRP: %p\n",Irp)
        );

    //
    //  In order to get explorer to request a format of unformatted media
    //  the STATUS_UNRECOGNIZED_MEDIA error must be translated to a generic
    //  STATUS_UNSUCCESSFUL error.
    //
//    if ( Irp->IoStatus.Status == STATUS_UNRECOGNIZED_MEDIA ) {
//        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
//    }
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );
}

NTSTATUS
FlStartDrive(
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN PIRP Irp,
    IN BOOLEAN WriteOperation,
    IN BOOLEAN SetUpMedia,
    IN BOOLEAN IgnoreChange
    )

/*++

Routine Description:

    This routine is called at the beginning of every operation.  It cancels
    the motor timer if it's on, turns the motor on and waits for it to
    spin up if it was off, resets the disk change line and returns
    VERIFY_REQUIRED if the disk has been changed, determines the diskette
    media type if it's not known and SetUpMedia=TRUE, and makes sure that
    the disk isn't write protected if WriteOperation = TRUE.

Arguments:

    DisketteExtension - a pointer to our data area for the drive being
    started.

    Irp - Supplies the I/O request packet.

    WriteOperation - TRUE if the diskette will be written to, FALSE
    otherwise.

    SetUpMedia - TRUE if the media type of the diskette in the drive
    should be determined.

    IgnoreChange - Do not return VERIFY_REQUIRED eventhough we are mounting
    for the first time.

Return Value:

    STATUS_SUCCESS if the drive is started properly; appropriate error
    propogated otherwise.

--*/

{
    LARGE_INTEGER    delay;
    BOOLEAN  motorStarted;
    BOOLEAN  diskChanged;
    UCHAR    driveStatus;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    FDC_ENABLE_PARMS    fdcEnableParms;
    FDC_DISK_CHANGE_PARMS fdcDiskChangeParms;

    FloppyDump(
        FLOPSHOW,
        ("Floppy: FloppyStartDrive...\n")
        );

    //
    // IMPORTANT
    // NOTE
    // COMMENT
    //
    // Here we will copy the BIOS floppy configuration on top of the
    // highest media value in our global array so that any type of processing
    // that will recalibrate the drive can have it done here.
    // An optimization would be to only do it when we will try to recalibrate
    // the driver or media in it.
    // At this point, we ensure that on any processing of a command we
    // are going to have the real values inthe first entry of the array for
    // driver constants.
    //

    DriveMediaConstants[DriveMediaLimits[DisketteExtension->DriveType].
        HighestDriveMediaType] = DisketteExtension->BiosDriveMediaConstants;

    if ((DisketteExtension->MediaType == Undetermined) ||
        (DisketteExtension->MediaType == Unknown)) {
        DisketteExtension->DriveMediaConstants = DriveMediaConstants[0];
    }

    //
    // Grab the timer spin lock and cancel the timer, since we want the
    // motor to run for the whole operation.  If the proper drive is
    // already running, great; if not, start the motor and wait for it
    // to spin up.
    //

    fdcEnableParms.DriveOnValue = DisketteExtension->DriveOnValue;
    if ( WriteOperation ) {
        fdcEnableParms.TimeToWait =
            DisketteExtension->DriveMediaConstants.MotorSettleTimeWrite;
    } else {
        fdcEnableParms.TimeToWait =
            DisketteExtension->DriveMediaConstants.MotorSettleTimeRead;
    }

    ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                              IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE,
                              &fdcEnableParms );

    motorStarted = fdcEnableParms.MotorStarted;

    if (NT_SUCCESS(ntStatus)) {

        fdcDiskChangeParms.DriveOnValue = DisketteExtension->DriveOnValue;

        ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                                  IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE,
                                  &fdcDiskChangeParms );

        driveStatus = fdcDiskChangeParms.DriveStatus;
    }

    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    //
    // Support for 360K drives:
    // They have no change line, so we will assume a power up of the motor
    // to be equivalent to a change of floppy (we assume noone will
    // change the floppy while it is turning.
    // So force a VERIFY here (unless the file system explicitly turned
    // it off).
    //

    if ( ((DisketteExtension->DriveType == DRIVE_TYPE_0360) &&
              motorStarted) ||
         ((DisketteExtension->DriveType != DRIVE_TYPE_0360) &&
              driveStatus & DSKCHG_DISKETTE_REMOVED) ) {

        FloppyDump(
            FLOPSHOW,
            ("Floppy: disk changed...\n")
            );

        DisketteExtension->MediaType = Undetermined;

        //
        // If the volume is mounted, we must tell the filesystem to
        // verify that the media in the drive is the same volume.
        //

        if ( DisketteExtension->DeviceObject->Vpb->Flags & VPB_MOUNTED ) {

            if (Irp) {
                IoSetHardErrorOrVerifyDevice( Irp,
                                              DisketteExtension->DeviceObject );
            }
            DisketteExtension->DeviceObject->Flags |= DO_VERIFY_VOLUME;
        }

        //
        // Only go through the device reset if we did get the flag set
        // We really only want to go throught here if the diskette changed,
        // but on 360 it will always say the diskette has changed.
        // So based on our previous test, only proceed if it is NOT
        // a 360K driver

        if (DisketteExtension->DriveType != DRIVE_TYPE_0360) {

            if (IsNEC_98) {

                //
                // Before seek, make sure that disk has been removed.
                //

                DisketteExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
                DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;

                ntStatus = FlIssueCommand( DisketteExtension,
                                           DisketteExtension->FifoBuffer,
                                           DisketteExtension->FifoBuffer,
                                           NULL,
                                           0,
                                           0 );

                if ( !NT_SUCCESS( ntStatus ) ) {

                    FloppyDump(
                        FLOPWARN,
                        ("Floppy: SENSE_DRIVE (1) returned%x\n", ntStatus)
                        );

                    return ntStatus;
                }

                if ( DisketteExtension->FifoBuffer[0] & STREG3_DRIVE_READY ) {

                    driveStatus = DSKCHG_RESERVED;

                } else {

                    driveStatus = DSKCHG_DISKETTE_REMOVED;
                }

                if ( driveStatus & DSKCHG_DISKETTE_REMOVED ) {

                    //
                    // If "disk changed" is still set after the double seek, the
                    // drive door must be opened.
                    //

                    FloppyDump(
                        FLOPINFO,
                        ("Floppy: close the door! (1)\n")
                        );

                    //
                    // Turn off the flag for now so that we will not get so many
                    // gratuitous verifys.  It will be set again the next time.
                    //

                    if(DisketteExtension->DeviceObject->Vpb->Flags & VPB_MOUNTED) {

                        DisketteExtension->DeviceObject->Flags &= ~DO_VERIFY_VOLUME;

                    }

                    return STATUS_NO_MEDIA_IN_DEVICE;
                }
            } // (IsNEC_98)

            //
            // Now seek twice to reset the "disk changed" line.  First
            // seek to 1.
            //
            // Normally we'd do a READ ID after a seek.  However, we don't
            // even know if this disk is formatted.  We're not really
            // trying to get anywhere; we're just doing this to reset the
            // "disk changed" line so we'll skip the READ ID.
            //

            DisketteExtension->FifoBuffer[0] = COMMND_SEEK;
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
            DisketteExtension->FifoBuffer[2] = 1;

            ntStatus = FlIssueCommand( DisketteExtension,
                                       DisketteExtension->FifoBuffer,
                                       DisketteExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( !NT_SUCCESS( ntStatus ) ) {

                FloppyDump( FLOPWARN, 
                            ("Floppy: seek to 1 returned %x\n", ntStatus) );

                return ntStatus;

            } else {

                if (!( DisketteExtension->FifoBuffer[0] & STREG0_SEEK_COMPLETE)
                    || ( DisketteExtension->FifoBuffer[1] != 1 ) ) {

                    FloppyDump(
                        FLOPWARN,
                        ("Floppy: Seek to 1 had bad return registers\n")
                        );

                    DisketteExtension->HardwareFailed = TRUE;

                    return STATUS_FLOPPY_BAD_REGISTERS;
                }
            }

            //
            // Seek back to 0.  We can once again skip the READ ID.
            //

            DisketteExtension->FifoBuffer[0] = COMMND_SEEK;
            DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
            DisketteExtension->FifoBuffer[2] = 0;

            //
            // Floppy drives use by Toshiba systems require a delay
            // when this operation is performed.
            //

            delay.LowPart = (ULONG) -900;
            delay.HighPart = -1;
            KeDelayExecutionThread( KernelMode, FALSE, &delay );
            ntStatus = FlIssueCommand( DisketteExtension,
                                       DisketteExtension->FifoBuffer,
                                       DisketteExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );
            //
            // Again, for Toshiba floppy drives, a delay is required.
            //

            delay.LowPart = (ULONG) -5;
            delay.HighPart = -1;
            KeDelayExecutionThread( KernelMode, FALSE, &delay );

            if ( !NT_SUCCESS( ntStatus ) ) {

                FloppyDump( FLOPWARN,
                            ("Floppy: seek to 0 returned %x\n", ntStatus) );

                return ntStatus;

            } else {

                if (!(DisketteExtension->FifoBuffer[0] & STREG0_SEEK_COMPLETE)
                    || ( DisketteExtension->FifoBuffer[1] != 0 ) ) {

                    FloppyDump(
                        FLOPWARN,
                        ("Floppy: Seek to 0 had bad return registers\n")
                        );

                    DisketteExtension->HardwareFailed = TRUE;

                    return STATUS_FLOPPY_BAD_REGISTERS;
                }
            }


            if (IsNEC_98) {

                //
                // Before seek, make sure that disk has been removed.
                //

                DisketteExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
                DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;

                ntStatus = FlIssueCommand( DisketteExtension,
                                           DisketteExtension->FifoBuffer,
                                           DisketteExtension->FifoBuffer,
                                           NULL,
                                           0,
                                           0 );

                if ( !NT_SUCCESS( ntStatus ) ) {

                    FloppyDump(
                        FLOPWARN,
                        ("Floppy: SENSE_DRIVE (1) returned%x\n", ntStatus)
                        );

                    return ntStatus;
                }

                if ( DisketteExtension->FifoBuffer[0] & STREG3_DRIVE_READY ) {

                    driveStatus = DSKCHG_RESERVED;

                } else {

                    driveStatus = DSKCHG_DISKETTE_REMOVED;
                }
            } else { // (IsNEC_98)

                ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                                          IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE,
                                          &fdcDiskChangeParms );

                driveStatus = fdcDiskChangeParms.DriveStatus;

                if (!NT_SUCCESS(ntStatus)) {
                    return ntStatus;
                }
            } // (IsNEC_98)

            if ( driveStatus & DSKCHG_DISKETTE_REMOVED ) {

                //
                // If "disk changed" is still set after the double seek, the
                // drive door must be opened.
                //

                FloppyDump(
                    FLOPINFO,
                    ("Floppy: close the door!\n")
                    );

                //
                // Turn off the flag for now so that we will not get so many
                // gratuitous verifys.  It will be set again the next time.
                //

                if(DisketteExtension->DeviceObject->Vpb->Flags & VPB_MOUNTED) {

                    DisketteExtension->DeviceObject->Flags &= ~DO_VERIFY_VOLUME;

                }

                return STATUS_NO_MEDIA_IN_DEVICE;
            }
        }

        //
        // IgnoreChange indicates the file system is in the process
        // of performing a verify so do not return verify required.
        //

        if ( IgnoreChange == FALSE ) {
            
            if ( DisketteExtension->DeviceObject->Vpb->Flags & VPB_MOUNTED ) {

                //
                // Drive WAS mounted, but door was opened since the last time
                // we checked so tell the file system to verify the diskette.
                //

                FloppyDump(
                    FLOPSHOW,
                    ("Floppy: start drive - verify required because door opened\n")
                    );

                return STATUS_VERIFY_REQUIRED;

            } else {

                return STATUS_IO_DEVICE_ERROR;
            }
        }
    }else{
        if (IsNEC_98) {

            FlHdbit(DisketteExtension);

        } // (IsNEC_98)
    }

    if ( SetUpMedia ) {

        if ( DisketteExtension->MediaType == Undetermined ) {

            ntStatus = FlDetermineMediaType( DisketteExtension );

        } else {

            if ( DisketteExtension->MediaType == Unknown ) {

                //
                // We've already tried to determine the media type and
                // failed.  It's probably not formatted.
                //

                FloppyDump(
                    FLOPSHOW,
                    ("Floppy - start drive - media type was unknown\n")
                    );
                return STATUS_UNRECOGNIZED_MEDIA;

            } else {

                if ( DisketteExtension->DriveMediaType !=
                    DisketteExtension->LastDriveMediaType ) {

                    //
                    // Last drive/media combination accessed by the
                    // controller was different, so set up the controller.
                    //

                    ntStatus = FlDatarateSpecifyConfigure( DisketteExtension );
                    if (!NT_SUCCESS(ntStatus)) {

                        FloppyDump(
                            FLOPWARN,
                            ("Floppy: start drive - bad status from datarate"
                             "------  specify %x\n",
                             ntStatus)
                            );

                    }
                }
            }
        }
    }

    //
    // If this is a WRITE, check the drive to make sure it's not write
    // protected.  If so, return an error.
    //

    if ( ( WriteOperation ) && ( NT_SUCCESS( ntStatus ) ) ) {

        DisketteExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;

        ntStatus = FlIssueCommand( DisketteExtension,
                                   DisketteExtension->FifoBuffer,
                                   DisketteExtension->FifoBuffer,
                                   NULL,
                                   0,
                                   0 );

        if ( !NT_SUCCESS( ntStatus ) ) {

            FloppyDump(
                FLOPWARN,
                ("Floppy: SENSE_DRIVE returned %x\n", ntStatus)
                );

            return ntStatus;
        }

        if (IsNEC_98) {
            //
            // Check if media has be ejected.
            //
            if (!(DisketteExtension->FifoBuffer[0] & STREG3_DRIVE_READY)) {

                FloppyDump(
                    FLOPDBGP,
                    ("Floppy: start drive - media is not ready\n")
                    );
                return STATUS_NO_MEDIA_IN_DEVICE;
            }
        } // (IsNEC_98)

        if ( DisketteExtension->FifoBuffer[0] & STREG3_WRITE_PROTECTED ) {

            FloppyDump(
                FLOPSHOW,
                ("Floppy: start drive - media is write protected\n")
                );
            return STATUS_MEDIA_WRITE_PROTECTED;
        }
    }

    return ntStatus;
}

NTSTATUS
FlDatarateSpecifyConfigure(
    IN PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    This routine is called to set up the controller every time a new type
    of diskette is to be accessed.  It issues the CONFIGURE command if
    it's available, does a SPECIFY, sets the data rate, and RECALIBRATEs
    the drive.

    The caller must set DisketteExtension->DriveMediaType before calling
    this routine.

Arguments:

    DisketteExtension - pointer to our data area for the drive to be
    prepared.

Return Value:

    STATUS_SUCCESS if the controller is properly prepared; appropriate
    error propogated otherwise.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    //
    // If the controller has a CONFIGURE command, use it to enable implied
    // seeks.  If it doesn't, we'll find out here the first time through.
    //
    if ( DisketteExtension->ControllerConfigurable ) {

        DisketteExtension->FifoBuffer[0] = COMMND_CONFIGURE;
        DisketteExtension->FifoBuffer[1] = 0;

        DisketteExtension->FifoBuffer[2] = COMMND_CONFIGURE_FIFO_THRESHOLD;
        DisketteExtension->FifoBuffer[2] += COMMND_CONFIGURE_DISABLE_POLLING;

        if (!DisketteExtension->DriveMediaConstants.CylinderShift) {
            DisketteExtension->FifoBuffer[2] += COMMND_CONFIGURE_IMPLIED_SEEKS;
        }

        DisketteExtension->FifoBuffer[3] = 0;

        ntStatus = FlIssueCommand( DisketteExtension,
                                   DisketteExtension->FifoBuffer,
                                   DisketteExtension->FifoBuffer,
                                   NULL,
                                   0,
                                   0 );

        if ( ntStatus == STATUS_DEVICE_NOT_READY ) {

            DisketteExtension->ControllerConfigurable = FALSE;
            ntStatus = STATUS_SUCCESS;
        }
    }

    //
    // Issue SPECIFY command to program the head load and unload
    // rates, the drive step rate, and the DMA data transfer mode.
    //

    if ( NT_SUCCESS( ntStatus ) ||
         ntStatus == STATUS_DEVICE_NOT_READY ) {

        DisketteExtension->FifoBuffer[0] = COMMND_SPECIFY;
        DisketteExtension->FifoBuffer[1] =
            DisketteExtension->DriveMediaConstants.StepRateHeadUnloadTime;

        DisketteExtension->FifoBuffer[2] =
            DisketteExtension->DriveMediaConstants.HeadLoadTime;

        ntStatus = FlIssueCommand( DisketteExtension,
                                   DisketteExtension->FifoBuffer,
                                   DisketteExtension->FifoBuffer,
                                   NULL,
                                   0,
                                   0 );

        if ( NT_SUCCESS( ntStatus ) ) {

            //
            // Program the data rate
            //

            ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                                      IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE,
                                      &DisketteExtension->
                                        DriveMediaConstants.DataTransferRate );

            //
            // Recalibrate the drive, now that we've changed all its
            // parameters.
            //

            if (NT_SUCCESS(ntStatus)) {

                ntStatus = FlRecalibrateDrive( DisketteExtension );
            }
        } else {
            FloppyDump(
                FLOPINFO,
                ("Floppy: Failed specify %x\n", ntStatus)
                );
        }
    } else {
        FloppyDump(
            FLOPINFO,
            ("Floppy: Failed configuration %x\n", ntStatus)
            );
    }

    if ( NT_SUCCESS( ntStatus ) ) {

        DisketteExtension->LastDriveMediaType =
            DisketteExtension->DriveMediaType;

    } else {

        DisketteExtension->LastDriveMediaType = Unknown;
        FloppyDump(
            FLOPINFO,
            ("Floppy: Failed recalibrate %x\n", ntStatus)
            );
    }

    return ntStatus;
}

NTSTATUS
FlRecalibrateDrive(
    IN PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    This routine recalibrates a drive.  It is called whenever we're
    setting up to access a new diskette, and after certain errors.  It
    will actually recalibrate twice, since many controllers stop after
    77 steps and many disks have 80 tracks.

Arguments:

    DisketteExtension - pointer to our data area for the drive to be
    recalibrated.

Return Value:

    STATUS_SUCCESS if the drive is successfully recalibrated; appropriate
    error is propogated otherwise.

--*/

{
    NTSTATUS ntStatus;
    UCHAR recalibrateCount;

    recalibrateCount = 0;

    do {

        //
        // Issue the recalibrate command
        //

        DisketteExtension->FifoBuffer[0] = COMMND_RECALIBRATE;
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;

        ntStatus = FlIssueCommand( DisketteExtension,
                                   DisketteExtension->FifoBuffer,
                                   DisketteExtension->FifoBuffer,
                                   NULL,
                                   0,
                                   0 );

        if ( !NT_SUCCESS( ntStatus ) ) {

            FloppyDump(
                FLOPWARN,
                ("Floppy: recalibrate returned %x\n", ntStatus)
                );

        }

        if ( NT_SUCCESS( ntStatus ) ) {

            if (IsNEC_98) {
                UCHAR       fifoBuffer[2];

                //
                // Procedure for media is not ready
                //
                fifoBuffer[0] = DisketteExtension->FifoBuffer[0];
                fifoBuffer[1] = DisketteExtension->FifoBuffer[1];

                //
                // Sense target drive and get all data at transition of condistion.
                //
                DisketteExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
                DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;

                ntStatus = FlIssueCommand( DisketteExtension,
                                           DisketteExtension->FifoBuffer,
                                           DisketteExtension->FifoBuffer,
                                           NULL,
                                           0,
                                           0 );

                if ( !NT_SUCCESS( ntStatus ) ) {

                    FloppyDump(
                        FLOPWARN,
                        ("Floppy: SENSE_DRIVE returned %x\n", ntStatus)
                        );

                    return ntStatus;
                }

                DisketteExtension->FifoBuffer[0] = fifoBuffer[0];
                DisketteExtension->FifoBuffer[1] = fifoBuffer[1];

            } // (IsNEC_98)

            if ( !( DisketteExtension->FifoBuffer[0] & STREG0_SEEK_COMPLETE ) ||
                ( DisketteExtension->FifoBuffer[1] != 0 ) ) {

                FloppyDump(
                    FLOPWARN,
                    ("Floppy: recalibrate had bad registers\n")
                    );

                DisketteExtension->HardwareFailed = TRUE;

                ntStatus = STATUS_FLOPPY_BAD_REGISTERS;
            }
        }

        recalibrateCount++;

    } while ( ( !NT_SUCCESS( ntStatus ) ) && ( recalibrateCount < 2 ) );

    FloppyDump( FLOPSHOW,
                ("Floppy: FloppyRecalibrateDrive: status %x, count %d\n",
                ntStatus, recalibrateCount)
                );

    return ntStatus;
}

NTSTATUS
FlDetermineMediaType(
    IN OUT PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    This routine is called by FlStartDrive() when the media type is
    unknown.  It assumes the largest media supported by the drive is
    available, and keeps trying lower values until it finds one that
    works.

Arguments:

    DisketteExtension - pointer to our data area for the drive whose
    media is to checked.

Return Value:

    STATUS_SUCCESS if the type of the media is determined; appropriate
    error propogated otherwise.

--*/

{
    NTSTATUS ntStatus;
    PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
    BOOLEAN mediaTypesExhausted;
    ULONG retries = 0;

    USHORT sectorLengthCode;
    PBOOT_SECTOR_INFO bootSector;
    LARGE_INTEGER offset;
    PIRP irp;

    FloppyDump(
        FLOPSHOW,
        ("FlDetermineMediaType...\n")
        );

    DisketteExtension->IsReadOnly = FALSE;

    //
    // Try up to three times for read the media id.
    //

    for ( retries = 0; retries < 3; retries++ ) {

        if (retries) {

            //
            // We're retrying the media determination because
            // some controllers don't always want to work
            // at setup.  First we'll reset the device to give
            // it a better chance of working.
            //

            FloppyDump(
                FLOPINFO,
                ("FlDetermineMediaType: Resetting controller\n")
                );
            FlInitializeControllerHardware( DisketteExtension );
        }

        //
        // Assume that the largest supported media is in the drive.  If that
        // turns out to be untrue, we'll try successively smaller media types
        // until we find what's really in there (or we run out and decide
        // that the media isn't formatted).
        //

        DisketteExtension->DriveMediaType =
           DriveMediaLimits[DisketteExtension->DriveType].HighestDriveMediaType;
        DisketteExtension->DriveMediaConstants =
            DriveMediaConstants[DisketteExtension->DriveMediaType];

        mediaTypesExhausted = FALSE;

        do {

            if (IsNEC_98) {
                sectorLengthCode = DriveMediaConstants[DisketteExtension->DriveMediaType].SectorLengthCode;

                FlHdbit(DisketteExtension);

            } // (IsNEC_98)

            ntStatus = FlDatarateSpecifyConfigure( DisketteExtension );

            if ( !NT_SUCCESS( ntStatus ) ) {

                //
                // The SPECIFY or CONFIGURE commands resulted in an error.
                // Force ourselves out of this loop and return error.
                //

                FloppyDump(
                    FLOPINFO,
                    ("FlDetermineMediaType: DatarateSpecify failed %x\n", ntStatus)
                    );
                mediaTypesExhausted = TRUE;

            } else {

                //
                // Use the media constants table when trying to determine
                // media type.
                //

                driveMediaConstants =
                    &DriveMediaConstants[DisketteExtension->DriveMediaType];

                //
                // Now try to read the ID from wherever we're at.
                //

                DisketteExtension->FifoBuffer[1] = (UCHAR)
                    ( DisketteExtension->DeviceUnit |
                    ( ( driveMediaConstants->NumberOfHeads - 1 ) << 2 ) );

                DisketteExtension->FifoBuffer[0] =
                    COMMND_READ_ID + COMMND_OPTION_MFM;

                ntStatus = FlIssueCommand( DisketteExtension,
                                           DisketteExtension->FifoBuffer,
                                           DisketteExtension->FifoBuffer,
                                           NULL,
                                           0,
                                           0 );

                if ((!NT_SUCCESS( ntStatus)) ||
                    ((DisketteExtension->FifoBuffer[0]&(~STREG0_SEEK_COMPLETE)) !=
                        (UCHAR)( ( DisketteExtension->DeviceUnit ) |
                        ((driveMediaConstants->NumberOfHeads - 1 ) << 2 ))) ||
                    ( DisketteExtension->FifoBuffer[1] != 0 ) ||
                    ( DisketteExtension->FifoBuffer[2] != 0 ) ||
                    ( IsNEC_98 && ( DisketteExtension->FifoBuffer[6] != sectorLengthCode ))
                    ) {

                    FloppyDump(
                        FLOPINFO,
                        ("Floppy: READID failed trying lower media\n"
                         "------  status = %x\n"
                         "------  SR0 = %x\n"
                         "------  SR1 = %x\n"
                         "------  SR2 = %x\n",
                         ntStatus,
                         DisketteExtension->FifoBuffer[0],
                         DisketteExtension->FifoBuffer[1],
                         DisketteExtension->FifoBuffer[2])
                        );

                    DisketteExtension->DriveMediaType--;
                    DisketteExtension->DriveMediaConstants =
                        DriveMediaConstants[DisketteExtension->DriveMediaType];

                    if (ntStatus != STATUS_DEVICE_NOT_READY) {

                        ntStatus = STATUS_UNRECOGNIZED_MEDIA;
                    }

                    //
                    // Next comparison must be signed, for when
                    // LowestDriveMediaType = 0.
                    //

                    if ( (CHAR)( DisketteExtension->DriveMediaType ) <
                        (CHAR)( DriveMediaLimits[DisketteExtension->DriveType].
                        LowestDriveMediaType ) ) {

                        DisketteExtension->MediaType = Unknown;
                        mediaTypesExhausted = TRUE;

                        FloppyDump(
                            FLOPINFO,
                            ("Floppy: Unrecognized media.\n")
                            );
                    }

                } else {

                    if (IsNEC_98) {
                        //
                        // Read boot sector by current media type's parameters to determine.
                        //

                        DisketteExtension->MediaType = driveMediaConstants->MediaType;

                        DisketteExtension->BytesPerSector =
                            driveMediaConstants->BytesPerSector;

                        FloppyDump(
                            FLOPINFO,
                            ("Floppy: MediaType is %x ---\n", DisketteExtension->MediaType)
                            );

                        DisketteExtension->ByteCapacity =
                            ( driveMediaConstants->BytesPerSector ) *
                            driveMediaConstants->SectorsPerTrack *
                            ( 1 + driveMediaConstants->MaximumTrack ) *
                            driveMediaConstants->NumberOfHeads;

                        //
                        // Structure copy the media constants into the diskette extension.
                        //

                        DisketteExtension->DriveMediaConstants =
                            DriveMediaConstants[DisketteExtension->DriveMediaType];

                        //
                        // Check the boot sector for any overriding geometry information.
                        //
                        //FlCheckBootSector(DisketteExtension);

                        // Set up the IRP to read the boot sector.

                        bootSector = ExAllocatePool(NonPagedPoolCacheAligned, BOOT_SECTOR_SIZE);
                        if (!bootSector) {
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        offset.LowPart = offset.HighPart = 0;
                        irp = IoBuildAsynchronousFsdRequest(IRP_MJ_READ,
                                                            DisketteExtension->DeviceObject,
                                                            bootSector,
                                                            BOOT_SECTOR_SIZE,
                                                            &offset,
                                                            NULL);
                        if (!irp) {
                            FloppyDump(
                                FLOPWARN,
                                ( "Floppy: Returned from IoBuildAsynchronousFsdRequest with error\n" ));
                            ExFreePool(bootSector);
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }
                        irp->CurrentLocation--;
                        irp->Tail.Overlay.CurrentStackLocation = IoGetNextIrpStackLocation(irp);


                        // Allocate an adapter channel, do read, free adapter channel.

                        ntStatus = FlReadWrite(DisketteExtension, irp, TRUE);

                        FloppyDump(
                            FLOPSHOW,
                            ( "Floppy: Read boot sector (called FlReadWrite) with status=%x\n" ,
                            ntStatus ));

                        MmUnlockPages(irp->MdlAddress);
                        IoFreeMdl(irp->MdlAddress);
                        IoFreeIrp(irp);
                        ExFreePool(bootSector);

                        if ( !NT_SUCCESS( ntStatus ) ) {

                            FloppyDump(
                                FLOPINFO,
                                ("Floppy: READID failed trying lower media\n"
                                 "------  Status = %x\n"
                                 "------  SecLen = %x\n"
                                 "------  SR0 = %x\n"
                                 "------  SR1 = %x\n"
                                 "------  SR2 = %x\n"
                                 "------  SR6 = %x\n",
                                 ntStatus,
                                 sectorLengthCode,
                                 DisketteExtension->FifoBuffer[0],
                                 DisketteExtension->FifoBuffer[1],
                                 DisketteExtension->FifoBuffer[2],
                                 DisketteExtension->FifoBuffer[6])
                                );

                            DisketteExtension->DriveMediaType--;

                            DisketteExtension->DriveMediaConstants =
                                DriveMediaConstants[DisketteExtension->DriveMediaType];

                            if (ntStatus != STATUS_DEVICE_NOT_READY) {

                                ntStatus = STATUS_UNRECOGNIZED_MEDIA;

                            }

                            //
                            // Next comparison must be signed, for when
                            // LowestDriveMediaType = 0.
                            //

                            if ( (CHAR)( DisketteExtension->DriveMediaType ) <
                                (CHAR)( DriveMediaLimits[DisketteExtension->DriveType].
                                LowestDriveMediaType ) ) {

                                DisketteExtension->MediaType = Unknown;
                                mediaTypesExhausted = TRUE;

                                FloppyDump(
                                    FLOPINFO,
                                    ("Floppy: Unrecognized media. 2\n")
                                    );

                            }
                        }
                    } // (IsNEC_98)
                }
            }

        } while ( ( !NT_SUCCESS( ntStatus ) ) && !( mediaTypesExhausted ) );

        if (NT_SUCCESS(ntStatus)) {

            //
            // We determined the media type.  Time to move on.
            //

            FloppyDump(
                FLOPINFO,
                ("Floppy: Determined media type %d\n", retries)
                );
            break;
        }
    }

    if ( (!NT_SUCCESS( ntStatus )) || mediaTypesExhausted) {

        FloppyDump(
            FLOPINFO,
            ("Floppy: failed determine types status = %x %s\n",
             ntStatus,
             mediaTypesExhausted ? "media types exhausted" : "")
            );
        return ntStatus;
    }

    DisketteExtension->MediaType = driveMediaConstants->MediaType;
    DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;

    DisketteExtension->ByteCapacity =
        ( driveMediaConstants->BytesPerSector ) *
        driveMediaConstants->SectorsPerTrack *
        ( 1 + driveMediaConstants->MaximumTrack ) *
        driveMediaConstants->NumberOfHeads;

    FloppyDump(
        FLOPINFO,
        ("FlDetermineMediaType: MediaType is %x, bytes per sector %d, capacity %d\n",
         DisketteExtension->MediaType,
         DisketteExtension->BytesPerSector,
         DisketteExtension->ByteCapacity)
        );
    //
    // Structure copy the media constants into the diskette extension.
    //

    DisketteExtension->DriveMediaConstants =
        DriveMediaConstants[DisketteExtension->DriveMediaType];

    //
    // Check the boot sector for any overriding geometry information.
    //
    FlCheckBootSector(DisketteExtension);

    return ntStatus;
}

VOID
FlAllocateIoBuffer(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension,
    IN      ULONG               BufferSize
    )

/*++

Routine Description:

    This routine allocates a PAGE_SIZE io buffer.

Arguments:

    ControllerData      - Supplies the controller data.

    BufferSize          - Supplies the number of bytes to allocate.

Return Value:

    None.

--*/

{
    BOOLEAN         allocateContiguous;
    LARGE_INTEGER   maxDmaAddress;   

    if (DisketteExtension->IoBuffer) {
        if (DisketteExtension->IoBufferSize >= BufferSize) {
            return;
        }
        FlFreeIoBuffer(DisketteExtension);
    }

    if (BufferSize > DisketteExtension->MaxTransferSize ) {
        allocateContiguous = TRUE;
    } else {
        allocateContiguous = FALSE;
    }

    if (allocateContiguous) {
        maxDmaAddress.QuadPart = MAXIMUM_DMA_ADDRESS;
        DisketteExtension->IoBuffer = MmAllocateContiguousMemory(BufferSize,
                                                              maxDmaAddress);
    } else {
        DisketteExtension->IoBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                                  BufferSize);
    }

    if (!DisketteExtension->IoBuffer) {
        return;
    }

    DisketteExtension->IoBufferMdl = IoAllocateMdl(DisketteExtension->IoBuffer,
                                                BufferSize, FALSE, FALSE, NULL);
    if (!DisketteExtension->IoBufferMdl) {
        if (allocateContiguous) {
            MmFreeContiguousMemory(DisketteExtension->IoBuffer);
        } else {
            ExFreePool(DisketteExtension->IoBuffer);
        }
        DisketteExtension->IoBuffer = NULL;
        return;
    }

    try {
       MmProbeAndLockPages(DisketteExtension->IoBufferMdl, KernelMode,
                           IoModifyAccess);
    } except(EXCEPTION_EXECUTE_HANDLER) {
         FloppyDump(FLOPWARN,
                    ("MmProbeAndLockPages failed. Status = %x\n",
                     GetExceptionCode())
                   );
         if (allocateContiguous) {
             MmFreeContiguousMemory(DisketteExtension->IoBuffer);
         } else {
             ExFreePool(DisketteExtension->IoBuffer);
         }
         DisketteExtension->IoBuffer = NULL;
         return;
    }
    
    DisketteExtension->IoBufferSize = BufferSize;
}

VOID
FlFreeIoBuffer(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    This routine free's the controller's IoBuffer.

Arguments:

    DisketteExtension      - Supplies the controller data.

Return Value:

    None.

--*/

{
    BOOLEAN contiguousBuffer;

    if (!DisketteExtension->IoBuffer) {
        return;
    }

    if (DisketteExtension->IoBufferSize >
        DisketteExtension->MaxTransferSize) {

        contiguousBuffer = TRUE;
    } else {
        contiguousBuffer = FALSE;
    }

    DisketteExtension->IoBufferSize = 0;

    MmUnlockPages(DisketteExtension->IoBufferMdl);
    IoFreeMdl(DisketteExtension->IoBufferMdl);
    DisketteExtension->IoBufferMdl = NULL;
    if (contiguousBuffer) {
        MmFreeContiguousMemory(DisketteExtension->IoBuffer);
    } else {
        ExFreePool(DisketteExtension->IoBuffer);
    }
    DisketteExtension->IoBuffer = NULL;
}

VOID
FloppyThread(
    PVOID Context
    )

/*++

Routine Description:

    This is the code executed by the system thread created when the
    floppy driver initializes.  This thread loops forever (or until a
    flag is set telling the thread to kill itself) processing packets
    put into the queue by the dispatch routines.

    For each packet, this thread calls appropriate routines to process
    the request, and then calls FlFinishOperation() to complete the
    packet.

Arguments:

    Context - a pointer to our data area for the controller being
    supported (there is one thread per controller).

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY request;
    PDISKETTE_EXTENSION disketteExtension = Context;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    NTSTATUS waitStatus;
    LARGE_INTEGER queueWait;
    LARGE_INTEGER acquireWait;
    ULONG inx;

    //
    // Set thread priority to lowest realtime level.
    //

    KeSetPriorityThread(KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

    queueWait.QuadPart = -(1 * 1000 * 10000);
    acquireWait.QuadPart = -(15 * 1000 * 10000);

    do {

        //
        // Wait for a request from the dispatch routines.
        // KeWaitForSingleObject won't return error here - this thread
        // isn't alertable and won't take APCs, and we're not passing in
        // a timeout.
        //
        for (inx = 0; inx < 3; inx++) {
            waitStatus = KeWaitForSingleObject(
                (PVOID) &disketteExtension->RequestSemaphore,
                Executive,
                KernelMode,
                FALSE,
                &queueWait );
            if (waitStatus == STATUS_TIMEOUT) {
                ExAcquireFastMutex(&disketteExtension->PowerDownMutex);
                if (disketteExtension->ReceivedQueryPower == TRUE) {
                    ExReleaseFastMutex(&disketteExtension->PowerDownMutex);
                    break;
                } else {
                    ExReleaseFastMutex(&disketteExtension->PowerDownMutex);
                }
            } else {
                break;
            }
        }

        if (waitStatus == STATUS_TIMEOUT) {

            if (!IsNEC_98 &&
                disketteExtension->FloppyControllerAllocated) {

                FloppyDump(FLOPSHOW,
                           ("Floppy: Timed Out - Turning off the motor\n")
                           );
                FlFdcDeviceIo( disketteExtension->TargetObject,
                               IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE,
                               NULL );

                FlFdcDeviceIo( disketteExtension->TargetObject,
                               IOCTL_DISK_INTERNAL_RELEASE_FDC,
                               disketteExtension->DeviceObject );

                disketteExtension->FloppyControllerAllocated = FALSE;

            }

            ExAcquireFastMutex(&disketteExtension->ThreadReferenceMutex);

            if (disketteExtension->ThreadReferenceCount == 0) {
                disketteExtension->ThreadReferenceCount = -1;

                ASSERT(disketteExtension->FloppyThread != NULL);

                //
                // FloppyThread could be NULL in the unlikely event the
                // ObReferenceObjectByHandle failed when we created the
                // thread.
                //

                if (disketteExtension->FloppyThread != NULL) {

                    ObDereferenceObject(disketteExtension->FloppyThread);
                    disketteExtension->FloppyThread = NULL;
                }

                ExReleaseFastMutex(&disketteExtension->ThreadReferenceMutex);

                if (IsNEC_98) {
                    if (disketteExtension->ReleaseFdcWithMotorRunning) {
                        ntStatus = FlFdcDeviceIo(
                                        disketteExtension->TargetObject,
                                        IOCTL_DISK_INTERNAL_ACQUIRE_FDC,
                                        &acquireWait );

                        FlFdcDeviceIo( disketteExtension->TargetObject,
                                       IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE,
                                       NULL );

                        FlFdcDeviceIo( disketteExtension->TargetObject,
                                       IOCTL_DISK_INTERNAL_RELEASE_FDC,
                                       disketteExtension->DeviceObject );

                        disketteExtension->FloppyControllerAllocated = FALSE;
                        disketteExtension->ReleaseFdcWithMotorRunning = FALSE;
                    }
                }

                FloppyPageEntireDriver();

                FloppyDump(FLOPDBGP,
                           ("Floppy: Terminating thread in FloppyThread.\n")
                           );

                ExAcquireFastMutex(&disketteExtension->PowerDownMutex);
                if (disketteExtension->ReceivedQueryPower == TRUE) {
                    disketteExtension->ReceivedQueryPower = FALSE;
                    KeSetEvent(&disketteExtension->QueryPowerEvent,
                               IO_NO_INCREMENT,
                               FALSE);
                }
                ExReleaseFastMutex(&disketteExtension->PowerDownMutex);
                
                PsTerminateSystemThread( STATUS_SUCCESS );
            }

            ExReleaseFastMutex(&disketteExtension->ThreadReferenceMutex);
            continue;
        }

        while (request = ExInterlockedRemoveHeadList(
                &disketteExtension->ListEntry,
                &disketteExtension->ListSpinLock)) {

            ExAcquireFastMutex(&disketteExtension->ThreadReferenceMutex);
            ASSERT(disketteExtension->ThreadReferenceCount > 0);
            (disketteExtension->ThreadReferenceCount)--;
            ExReleaseFastMutex(&disketteExtension->ThreadReferenceMutex);

            disketteExtension->HardwareFailed = FALSE;

            irp = CONTAINING_RECORD( request, IRP, Tail.Overlay.ListEntry );

            //
            // Verify if the system is powering down. If so we fail
            // the irps.
            //
            ExAcquireFastMutex(&disketteExtension->PowerDownMutex);
            if (disketteExtension->PoweringDown == TRUE) {
               ExReleaseFastMutex(&disketteExtension->PowerDownMutex);
               FloppyDump( FLOPDBGP, 
                          ("Bailing out since power irp is waiting.\n"));

               irp = CONTAINING_RECORD( request, IRP, Tail.Overlay.ListEntry );
               irp->IoStatus.Status = STATUS_POWER_STATE_INVALID;
               irp->IoStatus.Information = 0;
               IoCompleteRequest(irp, IO_NO_INCREMENT);
               continue;
            } 
            ExReleaseFastMutex(&disketteExtension->PowerDownMutex);
            FloppyDump( FLOPSHOW, ("No power irp waiting.\n"));

            irpSp = IoGetCurrentIrpStackLocation( irp );

            FloppyDump(
                FLOPIRPPATH,
                ("Floppy: Starting  up IRP: %p for extension %p\n",
                  irp,irpSp->Parameters.Others.Argument4)
                );
            switch ( irpSp->MajorFunction ) {

                case IRP_MJ_PNP:

                    FloppyDump( FLOPSHOW, ("FloppyThread: IRP_MN_QUERY_REMOVE_DEVICE\n") );

                    if ( irpSp->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE ||
                         irpSp->MinorFunction == IRP_MN_QUERY_STOP_DEVICE ) {
                        if (IsNEC_98) {
                            if (disketteExtension->ReleaseFdcWithMotorRunning) {
                                FlFdcDeviceIo( disketteExtension->TargetObject,
                                               IOCTL_DISK_INTERNAL_ACQUIRE_FDC,
                                               &acquireWait );

                                disketteExtension->ReleaseFdcWithMotorRunning = FALSE;
                                disketteExtension->FloppyControllerAllocated  = TRUE;
                            }
                        }

                        if ( disketteExtension->FloppyControllerAllocated ) {

                            FlFdcDeviceIo( disketteExtension->TargetObject,
                                           IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE,
                                           NULL );

                            FlFdcDeviceIo( disketteExtension->TargetObject,
                                           IOCTL_DISK_INTERNAL_RELEASE_FDC,
                                           disketteExtension->DeviceObject );

                            disketteExtension->FloppyControllerAllocated = FALSE;

                        }

                        ExAcquireFastMutex( &disketteExtension->ThreadReferenceMutex );
                        ASSERT(disketteExtension->ThreadReferenceCount == 0);
                        disketteExtension->ThreadReferenceCount = -1;
                        ExReleaseFastMutex(&disketteExtension->ThreadReferenceMutex);

                        FloppyPageEntireDriver();

                        PsTerminateSystemThread( STATUS_SUCCESS );
                    } else {

                        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;

                case IRP_MJ_READ:
                case IRP_MJ_WRITE: {

                    //
                    // Get the diskette extension from where it was hidden
                    // in the IRP.
                    //

//                    disketteExtension = (PDISKETTE_EXTENSION)
//                        irpSp->Parameters.Others.Argument4;

                    if (!disketteExtension->FloppyControllerAllocated) {

                        ntStatus = FlFdcDeviceIo(
                                        disketteExtension->TargetObject,
                                        IOCTL_DISK_INTERNAL_ACQUIRE_FDC,
                                        &acquireWait );

                        if (NT_SUCCESS(ntStatus)) {
                            disketteExtension->FloppyControllerAllocated = TRUE;
                            if (IsNEC_98) disketteExtension->ReleaseFdcWithMotorRunning = FALSE;
                        } else {
                            break;
                        }
                    }

                    //
                    // Until the file system clears the DO_VERIFY_VOLUME
                    // flag, we should return all requests with error.
                    //

                    if (( disketteExtension->DeviceObject->Flags &
                            DO_VERIFY_VOLUME )  &&
                         !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME))
                                {

                        FloppyDump(
                            FLOPINFO,
                            ("Floppy: clearing queue; verify required\n")
                            );

                        //
                        // The disk changed, and we set this bit.  Fail
                        // all current IRPs for this device; when all are
                        // returned, the file system will clear
                        // DO_VERIFY_VOLUME.
                        //

                        ntStatus = STATUS_VERIFY_REQUIRED;

                    } else {

                        ntStatus = FlReadWrite( disketteExtension, irp, FALSE );

                    }

                    break;
                }

                case IRP_MJ_DEVICE_CONTROL: {

//                    disketteExtension = (PDISKETTE_EXTENSION)
//                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    if (!disketteExtension->FloppyControllerAllocated) {

                        ntStatus = FlFdcDeviceIo(
                                        disketteExtension->TargetObject,
                                        IOCTL_DISK_INTERNAL_ACQUIRE_FDC,
                                        &acquireWait );

                        if (NT_SUCCESS(ntStatus)) {
                            disketteExtension->FloppyControllerAllocated = TRUE;
                            if (IsNEC_98) disketteExtension->ReleaseFdcWithMotorRunning = FALSE;
                        } else {
                            break;
                        }
                    }
                    //
                    // Until the file system clears the DO_VERIFY_VOLUME
                    // flag, we should return all requests with error.
                    //

                    if (( disketteExtension->DeviceObject->Flags &
                            DO_VERIFY_VOLUME )  &&
                         !(irpSp->Flags & SL_OVERRIDE_VERIFY_VOLUME))
                                {

                        FloppyDump(
                            FLOPINFO,
                            ("Floppy: clearing queue; verify required\n")
                            );

                        //
                        // The disk changed, and we set this bit.  Fail
                        // all current IRPs; when all are returned, the
                        // file system will clear DO_VERIFY_VOLUME.
                        //

                        ntStatus = STATUS_VERIFY_REQUIRED;

                    } else {

                        switch (
                            irpSp->Parameters.DeviceIoControl.IoControlCode ) {

                            case IOCTL_STORAGE_CHECK_VERIFY:
                            case IOCTL_DISK_CHECK_VERIFY: {

                                //
                                // Just start the drive; it will
                                // automatically check whether or not the
                                // disk has been changed.
                                //
                                FloppyDump(
                                    FLOPSHOW,
                                    ("Floppy: IOCTL_DISK_CHECK_VERIFY called\n")
                                    );

                //
                // IgnoreChange should be TRUE if
                // SL_OVERRIDE_VERIFY_VOLUME flag is set
                // in the irp. Else, IgnoreChange should
                // be FALSE
                //
                                ntStatus = FlStartDrive(
                                    disketteExtension,
                                    irp,
                                    FALSE,
                                    FALSE,
                                    (BOOLEAN)!!(irpSp->Flags &
                                            SL_OVERRIDE_VERIFY_VOLUME));

                                break;
                            }

                            case IOCTL_DISK_IS_WRITABLE: {

                                //
                                // Start the drive with the WriteOperation
                                // flag set to TRUE.
                                //

                                FloppyDump(
                                    FLOPSHOW,
                                    ("Floppy: IOCTL_DISK_IS_WRITABLE called\n")
                                    );

                                if (disketteExtension->IsReadOnly) {

                                    ntStatus = STATUS_INVALID_PARAMETER;

                                } else {
                                    ntStatus = FlStartDrive(
                                        disketteExtension,
                                        irp,
                                        TRUE,
                                        FALSE,
                                        TRUE);
                                }

                                break;
                            }

                            case IOCTL_DISK_GET_DRIVE_GEOMETRY: {

                                FloppyDump(
                                    FLOPSHOW,
                                    ("Floppy: IOCTL_DISK_GET_DRIVE_GEOMETRY\n")
                                    );

                                //
                                // If there's enough room to write the
                                // data, start the drive to make sure we
                                // know what type of media is in the drive.
                                //

                                if ( irpSp->Parameters.DeviceIoControl.
                                    OutputBufferLength <
                                    sizeof( DISK_GEOMETRY ) ) {

                                    ntStatus = STATUS_INVALID_PARAMETER;

                                } else {

                                    ntStatus = FlStartDrive(
                                        disketteExtension,
                                        irp,
                                        FALSE,
                                        TRUE,
                                        (BOOLEAN)!!(irpSp->Flags &
                                            SL_OVERRIDE_VERIFY_VOLUME));

                                }

                                //
                                // If the media wasn't formatted, FlStartDrive
                                // returned STATUS_UNRECOGNIZED_MEDIA.
                                //

                                if ( NT_SUCCESS( ntStatus ) ||
                                    ( ntStatus == STATUS_UNRECOGNIZED_MEDIA )) {

                                    PDISK_GEOMETRY outputBuffer =
                                        (PDISK_GEOMETRY)
                                        irp->AssociatedIrp.SystemBuffer;

                                    // Always return the media type, even if
                                    // it's unknown.
                                    //

                                    ntStatus = STATUS_SUCCESS;

                                    outputBuffer->MediaType =
                                        disketteExtension->MediaType;

                                    //
                                    // The rest of the fields only have meaning
                                    // if the media type is known.
                                    //

                                    if ( disketteExtension->MediaType ==
                                        Unknown ) {

                                        FloppyDump(
                                            FLOPSHOW,
                                            ("Floppy: geometry unknown\n")
                                            );

                                        //
                                        // Just zero out everything.  The
                                        // caller shouldn't look at it.
                                        //

                                        outputBuffer->Cylinders.LowPart = 0;
                                        outputBuffer->Cylinders.HighPart = 0;
                                        outputBuffer->TracksPerCylinder = 0;
                                        outputBuffer->SectorsPerTrack = 0;
                                        outputBuffer->BytesPerSector = 0;

                                    } else {

                                        //
                                        // Return the geometry of the current
                                        // media.
                                        //

                                        FloppyDump(
                                            FLOPSHOW,
                                            ("Floppy: geomentry is known\n")
                                            );
                                        outputBuffer->Cylinders.LowPart =
                                            disketteExtension->
                                            DriveMediaConstants.MaximumTrack + 1;

                                        outputBuffer->Cylinders.HighPart = 0;

                                        outputBuffer->TracksPerCylinder =
                                            disketteExtension->
                                            DriveMediaConstants.NumberOfHeads;

                                        outputBuffer->SectorsPerTrack =
                                            disketteExtension->
                                            DriveMediaConstants.SectorsPerTrack;

                                        outputBuffer->BytesPerSector =
                                            disketteExtension->
                                            DriveMediaConstants.BytesPerSector;
                                    }

                                    FloppyDump(
                                        FLOPSHOW,
                                        ("Floppy: Geometry\n"
                                         "------- Cylinders low:  0x%x\n"
                                         "------- Cylinders high: 0x%x\n"
                                         "------- Track/Cyl:      0x%x\n"
                                         "------- Sectors/Track:  0x%x\n"
                                         "------- Bytes/Sector:   0x%x\n"
                                         "------- Media Type:       %d\n",
                                         outputBuffer->Cylinders.LowPart,
                                         outputBuffer->Cylinders.HighPart,
                                         outputBuffer->TracksPerCylinder,
                                         outputBuffer->SectorsPerTrack,
                                         outputBuffer->BytesPerSector,
                                         outputBuffer->MediaType)
                                         );

                                }

                                irp->IoStatus.Information =
                                    sizeof( DISK_GEOMETRY );

                                break;
                            }

                            case IOCTL_DISK_FORMAT_TRACKS_EX:
                            case IOCTL_DISK_FORMAT_TRACKS: {

                                FloppyDump(
                                    FLOPSHOW,
                                    ("Floppy: IOCTL_DISK_FORMAT_TRACKS\n")
                                    );

                                //
                                // Start the drive, and make sure it's not
                                // write protected.
                                //

                                ntStatus = FlStartDrive(
                                    disketteExtension,
                                    irp,
                                    TRUE,
                                    FALSE,
                                    FALSE );

                                //
                                // Note that FlStartDrive could have returned
                                // STATUS_UNRECOGNIZED_MEDIA if the drive
                                // wasn't formatted.
                                //

                                if ( NT_SUCCESS( ntStatus ) ||
                                    ( ntStatus == STATUS_UNRECOGNIZED_MEDIA)) {

                                    //
                                    // We need a single page to do FORMATs.
                                    // If we already allocated a buffer,
                                    // we'll use that.  If not, let's
                                    // allocate a single page.  Note that
                                    // we'd have to do this anyway if there's
                                    // not enough map registers.
                                    //

                                    FlAllocateIoBuffer( disketteExtension,
                                                        PAGE_SIZE);

                                    if (disketteExtension->IoBuffer) {
                                        ntStatus = FlFormat(disketteExtension,
                                                            irp);
                                    } else {
                                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                                    }
                                }

                                break;
                            }                              //end of case format

                           case IOCTL_DISK_SENSE_DEVICE: {

                                if (IsNEC_98) {
                                    disketteExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
                                    disketteExtension->FifoBuffer[1] = disketteExtension->DeviceUnit;

                                    ntStatus = FlIssueCommand( disketteExtension,
                                                               disketteExtension->FifoBuffer,
                                                               disketteExtension->FifoBuffer,
                                                               NULL,
                                                               0,
                                                               0 );

                                   if ( NT_SUCCESS( ntStatus ) ) {

                                       PSENSE_DEVISE_STATUS_PTOS outputBuffer
                                            =(PSENSE_DEVISE_STATUS_PTOS)irp->AssociatedIrp.SystemBuffer;
                                       ((PSENSE_DEVISE_STATUS_PTOS)outputBuffer)->ST3_PTOS
                                            =Result_Status3_PTOS[0].ST3_PTOS;

                                       irp->IoStatus.Information = sizeof( SENSE_DEVISE_STATUS_PTOS );
                                   }
                                   break;
                                }
                           }                        //end of case sense device

                        }                           //end of switch controlcode
                    }

                    break;
                }                                           //end of case IOCTL

                default: {

                    FloppyDump(
                        FLOPDBGP,
                        ("Floppy: bad majorfunction %x\n",irpSp->MajorFunction)
                        );

                    ntStatus = STATUS_NOT_IMPLEMENTED;
                }

            }                                  //end of switch on majorfunction

            if (ntStatus == STATUS_DEVICE_BUSY) {

                // If the status is DEVICE_BUSY then this indicates that the
                // qic117 has control of the controller.  Therefore complete
                // all remaining requests with STATUS_DEVICE_BUSY.

                for (;;) {

                    disketteExtension->HardwareFailed = FALSE;

                    irp->IoStatus.Status = STATUS_DEVICE_BUSY;

                    IoCompleteRequest(irp, IO_DISK_INCREMENT);

                    request = ExInterlockedRemoveHeadList(
                        &disketteExtension->ListEntry,
                        &disketteExtension->ListSpinLock );

                    if (!request) {
                        break;
                    }

                    ExAcquireFastMutex(
                        &disketteExtension->ThreadReferenceMutex);
                    ASSERT(disketteExtension->ThreadReferenceCount > 0);
                    (disketteExtension->ThreadReferenceCount)--;
                    ExReleaseFastMutex(
                        &disketteExtension->ThreadReferenceMutex);

                    irp = CONTAINING_RECORD( request,
                                             IRP,
                                             Tail.Overlay.ListEntry);
                }

            } else {

                //
                // All operations leave a final status in ntStatus.  Copy it
                // to the IRP, and then complete the operation.
                //

                irp->IoStatus.Status = ntStatus;

                //
                // If we'd allocated an I/O buffer free it now
                //
                if (disketteExtension->IoBuffer) {
                   FlFreeIoBuffer(disketteExtension);
                }

                FlFinishOperation( irp, disketteExtension );

            }

        } // while there are packets to process

        if (IsNEC_98) {
            if (disketteExtension->FloppyControllerAllocated) {
                FlFdcDeviceIo( disketteExtension->TargetObject,
                               IOCTL_DISK_INTERNAL_RELEASE_FDC,
                               disketteExtension->DeviceObject );

                disketteExtension->FloppyControllerAllocated  = FALSE;
                disketteExtension->ReleaseFdcWithMotorRunning = TRUE;
            }
        }

    } while ( TRUE );
}

VOID
FlConsolidateMediaTypeWithBootSector(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension,
    IN      PBOOT_SECTOR_INFO   BootSector
    )

/*++

Routine Description:

    This routine adjusts the DisketteExtension data according
    to the BPB values if this is appropriate.

Arguments:

    DisketteExtension   - Supplies the diskette extension.

    BootSector          - Supplies the boot sector information.

Return Value:

    None.

--*/

{
    USHORT                  bpbNumberOfSectors, bpbNumberOfHeads;
    USHORT                  bpbSectorsPerTrack, bpbBytesPerSector;
    USHORT                  bpbMediaByte, bpbMaximumTrack;
    MEDIA_TYPE              bpbMediaType;
    ULONG                   i, n;
    PDRIVE_MEDIA_CONSTANTS  readidDriveMediaConstants;
    BOOLEAN                 changeToBpbMedia;

    FloppyDump(
        FLOPSHOW,
        ("Floppy: First sector read: media descriptor is: 0x%x\n",
         BootSector->MediaByte[0])
        );

    if (BootSector->JumpByte[0] != 0xeb &&
        BootSector->JumpByte[0] != 0xe9) {

        // This is not a formatted floppy so ignore the BPB.
        return;
    }

    bpbNumberOfSectors = BootSector->NumberOfSectors[1]*0x100 +
                         BootSector->NumberOfSectors[0];
    bpbNumberOfHeads = BootSector->NumberOfHeads[1]*0x100 +
                       BootSector->NumberOfHeads[0];
    bpbSectorsPerTrack = BootSector->SectorsPerTrack[1]*0x100 +
                         BootSector->SectorsPerTrack[0];
    bpbBytesPerSector = BootSector->BytesPerSector[1]*0x100 +
                        BootSector->BytesPerSector[0];
    bpbMediaByte = BootSector->MediaByte[0];

    if (!bpbNumberOfHeads || !bpbSectorsPerTrack) {
        // Invalid BPB, avoid dividing by zero.
        return;
    }

    bpbMaximumTrack =
        bpbNumberOfSectors/bpbNumberOfHeads/bpbSectorsPerTrack - 1;

    // First figure out if this BPB specifies a known media type
    // independantly of the current drive type.

    bpbMediaType = Unknown;
    for (i = 0; i < NUMBER_OF_DRIVE_MEDIA_COMBINATIONS; i++) {

        if (bpbBytesPerSector == DriveMediaConstants[i].BytesPerSector &&
            bpbSectorsPerTrack == DriveMediaConstants[i].SectorsPerTrack &&
            bpbMaximumTrack == DriveMediaConstants[i].MaximumTrack &&
            bpbNumberOfHeads == DriveMediaConstants[i].NumberOfHeads &&
            bpbMediaByte == DriveMediaConstants[i].MediaByte) {

            bpbMediaType = DriveMediaConstants[i].MediaType;
            break;
        }
    }

    //
    // If DriveType is 3.5", we change 5.25" to 3.5".
    // The following media's BPB is the same between 5.25" and 3.5",
    // so 5.25" media types are always found first.
    //
    if (DisketteExtension->DriveType == DRIVE_TYPE_1440) {
        switch (bpbMediaType) {
            case F5_640_512:    bpbMediaType = F3_640_512;    break;
            case F5_720_512:    bpbMediaType = F3_720_512;    break;
            case F5_1Pt2_512:   bpbMediaType = F3_1Pt2_512;   break;
            case F5_1Pt23_1024: bpbMediaType = F3_1Pt23_1024; break;
            default: break;
        }
    }

    FloppyDump(
        FLOPSHOW,
        ("FLOPPY: After switch media type is: %x\n",bpbMediaType)
        );

    FloppyDump(
        FLOPINFO,
        ("FloppyBpb: Media type ")
        );
    if (bpbMediaType == DisketteExtension->MediaType) {

        // No conflict between BPB and readId result.

        changeToBpbMedia = FALSE;
        FloppyDump(
            FLOPINFO,
            ("is same\n")
            );

    } else {

        // There is a conflict between the BPB and the readId
        // media type.  If the new parameters are acceptable
        // then go with them.

        readidDriveMediaConstants = &(DisketteExtension->DriveMediaConstants);

        if (bpbBytesPerSector == readidDriveMediaConstants->BytesPerSector &&
            bpbSectorsPerTrack < 0x100 &&
            bpbMaximumTrack == readidDriveMediaConstants->MaximumTrack &&
            bpbNumberOfHeads <= readidDriveMediaConstants->NumberOfHeads) {

            changeToBpbMedia = TRUE;

        } else {
            changeToBpbMedia = FALSE;
        }

        FloppyDump( FLOPINFO,
                    ("%s",
                    changeToBpbMedia ?
                    "will change to Bpb\n" : "will not change\n")
                    );

        // If we didn't derive a new media type from the BPB then
        // just use the one from readId.  Also override any
        // skew compensation since we don't really know anything
        // about this new media type.

        if (bpbMediaType == Unknown) {
            bpbMediaType = readidDriveMediaConstants->MediaType;
            DisketteExtension->DriveMediaConstants.SkewDelta = 0;
        }
    }

    if (changeToBpbMedia) {

        // Change the DriveMediaType only if this new media type
        // falls in line with what is supported by the drive.

        i = DriveMediaLimits[DisketteExtension->DriveType].LowestDriveMediaType;
        n = DriveMediaLimits[DisketteExtension->DriveType].HighestDriveMediaType;
        for (; i <= n; i++) {

            if (bpbMediaType == DriveMediaConstants[i].MediaType) {
                DisketteExtension->DriveMediaType = i;
                break;
            }
        }

        DisketteExtension->MediaType = bpbMediaType;
        DisketteExtension->ByteCapacity = bpbNumberOfSectors*bpbBytesPerSector;
        DisketteExtension->DriveMediaConstants.SectorsPerTrack =
            (UCHAR) bpbSectorsPerTrack;
        DisketteExtension->DriveMediaConstants.NumberOfHeads =
            (UCHAR) bpbNumberOfHeads;

        // If the MSDMF3. signature is there then make this floppy
        // read-only.

        if (RtlCompareMemory(BootSector->OemData, "MSDMF3.", 7) == 7) {
            DisketteExtension->IsReadOnly = TRUE;
        }
    }
}

VOID
FlCheckBootSector(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    This routine reads the boot sector and then figures
    out whether or not the boot sector contains new geometry
    information.

Arguments:

    DisketteExtension   - Supplies the diskette extension.

Return Value:

    None.

--*/

{

    PBOOT_SECTOR_INFO   bootSector;
    LARGE_INTEGER       offset;
    PIRP                irp;
    NTSTATUS            status;


    // Set up the IRP to read the boot sector.

    bootSector = ExAllocatePool(NonPagedPoolCacheAligned, BOOT_SECTOR_SIZE);
    if (!bootSector) {
        return;
    }

    offset.LowPart = offset.HighPart = 0;
    irp = IoBuildAsynchronousFsdRequest(IRP_MJ_READ,
                                        DisketteExtension->DeviceObject,
                                        bootSector,
                                        BOOT_SECTOR_SIZE,
                                        &offset,
                                        NULL);
    if (!irp) {
        ExFreePool(bootSector);
        return;
    }
    irp->CurrentLocation--;
    irp->Tail.Overlay.CurrentStackLocation = IoGetNextIrpStackLocation(irp);


    // Allocate an adapter channel, do read, free adapter channel.

    status = FlReadWrite(DisketteExtension, irp, TRUE);

    MmUnlockPages(irp->MdlAddress);
    IoFreeMdl(irp->MdlAddress);
    IoFreeIrp(irp);
    ExFreePool(bootSector);
}

NTSTATUS
FlReadWriteTrack(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension,
    IN OUT  PMDL                IoMdl,
    IN OUT  ULONG               IoOffset,
    IN      BOOLEAN             WriteOperation,
    IN      UCHAR               Cylinder,
    IN      UCHAR               Head,
    IN      UCHAR               Sector,
    IN      UCHAR               NumberOfSectors,
    IN      BOOLEAN             NeedSeek
    )

/*++

Routine Description:

    This routine reads a portion of a track.  It transfers the to or from the
    device from or to the given IoBuffer and IoMdl.

Arguments:

    DisketteExtension   - Supplies the diskette extension.

    IoMdl               - Supplies the Mdl for transfering from/to the device.

    IoBuffer            - Supplies the buffer to transfer from/to the device.

    WriteOperation      - Supplies whether or not this is a write operation.

    Cylinder            - Supplies the cylinder number for this track.

    Head                - Supplies the head number for this track.

    Sector              - Supplies the starting sector of the transfer.

    NumberOfSectors     - Supplies the number of sectors to transfer.

    NeedSeek            - Supplies whether or not we need to do a seek.

Return Value:

    An NTSTATUS code.

--*/

{
    PDRIVE_MEDIA_CONSTANTS  driveMediaConstants;
    ULONG                   byteToSectorShift;
    ULONG                   transferBytes;
    LARGE_INTEGER           headSettleTime;
    NTSTATUS                status;
    ULONG                   seekRetry, ioRetry;
    BOOLEAN                 recalibrateDrive = FALSE;
    UCHAR                   i;

    FloppyDump( FLOPSHOW,
                ("\nFlReadWriteTrack:%sseek for %s at chs %d/%d/%d for %d sectors\n",
                NeedSeek ? " need " : " ",
                WriteOperation ? "write" : "read",
                Cylinder,
                Head,
                Sector,
                NumberOfSectors) );

    driveMediaConstants = &DisketteExtension->DriveMediaConstants;
    byteToSectorShift = SECTORLENGTHCODE_TO_BYTESHIFT +
                        driveMediaConstants->SectorLengthCode;
    transferBytes = ((ULONG) NumberOfSectors)<<byteToSectorShift;

    headSettleTime.LowPart = -(10*1000*driveMediaConstants->HeadSettleTime);
    headSettleTime.HighPart = -1;

    for (seekRetry = 0, ioRetry = 0; seekRetry < 3; seekRetry++) {

        if (recalibrateDrive) {

            // Something failed, so recalibrate the drive.

            FloppyDump(
                FLOPINFO,
                ("FlReadWriteTrack: performing recalibrate\n")
                );
            FlRecalibrateDrive(DisketteExtension);
        }

        // Do a seek if we have to.

        if (recalibrateDrive ||
            (NeedSeek &&
             (!DisketteExtension->ControllerConfigurable ||
              driveMediaConstants->CylinderShift != 0))) {

            DisketteExtension->FifoBuffer[0] = COMMND_SEEK;
            DisketteExtension->FifoBuffer[1] = (Head<<2) |
                                            DisketteExtension->DeviceUnit;
            DisketteExtension->FifoBuffer[2] = Cylinder<<
                                            driveMediaConstants->CylinderShift;

            status = FlIssueCommand( DisketteExtension,
                                     DisketteExtension->FifoBuffer,
                                     DisketteExtension->FifoBuffer,
                                     NULL,
                                     0,
                                     0 );

            if (NT_SUCCESS(status)) {

                // Check the completion state of the controller.

                if (!(DisketteExtension->FifoBuffer[0]&STREG0_SEEK_COMPLETE) ||
                    DisketteExtension->FifoBuffer[1] !=
                            Cylinder<<driveMediaConstants->CylinderShift) {

                    DisketteExtension->HardwareFailed = TRUE;
                    status = STATUS_FLOPPY_BAD_REGISTERS;
                }

                if (NT_SUCCESS(status)) {

                    // Delay after doing seek.

                    KeDelayExecutionThread(KernelMode, FALSE, &headSettleTime);

                    // SEEKs should always be followed by a READID.

                    DisketteExtension->FifoBuffer[0] =
                        COMMND_READ_ID + COMMND_OPTION_MFM;
                    DisketteExtension->FifoBuffer[1] =
                        (Head<<2) | DisketteExtension->DeviceUnit;

                    status = FlIssueCommand( DisketteExtension,
                                             DisketteExtension->FifoBuffer,
                                             DisketteExtension->FifoBuffer,
                                             NULL,
                                             0,
                                             0 );

                    if (NT_SUCCESS(status)) {

                        if (IsNEC_98) {
                            if(DisketteExtension->FifoBuffer[0] & STREG0_DRIVE_NOT_READY) {
                                 return STATUS_DEVICE_NOT_READY;
                            }
                        } // (IsNEC_98)

                        if (DisketteExtension->FifoBuffer[0] !=
                                ((Head<<2) | DisketteExtension->DeviceUnit) ||
                            DisketteExtension->FifoBuffer[1] != 0 ||
                            DisketteExtension->FifoBuffer[2] != 0 ||
                            DisketteExtension->FifoBuffer[3] != Cylinder) {

                            DisketteExtension->HardwareFailed = TRUE;

                            status = FlInterpretError(
                                        DisketteExtension->FifoBuffer[1],
                                        DisketteExtension->FifoBuffer[2]);
                        }
                    } else {
                        FloppyDump(
                            FLOPINFO,
                            ("FlReadWriteTrack: Read ID failed %x\n", status)
                            );
                    }
                }
            } else {
                FloppyDump(
                    FLOPINFO,
                    ("FlReadWriteTrack: SEEK failed %x\n", status)
                    );
            }


        } else {
            status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(status)) {

            // The seek failed so try again.

            FloppyDump(
                FLOPINFO,
                ("FlReadWriteTrack: setup failure %x - recalibrating\n", status)
                );
            recalibrateDrive = TRUE;
            continue;
        }

        for (;; ioRetry++) {

            //
            // Issue the READ or WRITE command
            //

            DisketteExtension->FifoBuffer[1] = (Head<<2) |
                                            DisketteExtension->DeviceUnit;
            DisketteExtension->FifoBuffer[2] = Cylinder;
            DisketteExtension->FifoBuffer[3] = Head;
            DisketteExtension->FifoBuffer[4] = Sector + 1;
            DisketteExtension->FifoBuffer[5] =
                    driveMediaConstants->SectorLengthCode;
            DisketteExtension->FifoBuffer[6] = Sector + NumberOfSectors;
            DisketteExtension->FifoBuffer[7] =
                    driveMediaConstants->ReadWriteGapLength;
            DisketteExtension->FifoBuffer[8] = driveMediaConstants->DataLength;

            if (WriteOperation) {
                DisketteExtension->FifoBuffer[0] =
                    COMMND_WRITE_DATA + COMMND_OPTION_MFM;
            } else {
                DisketteExtension->FifoBuffer[0] =
                    COMMND_READ_DATA + COMMND_OPTION_MFM;
            }

            FloppyDump(FLOPINFO,
                       ("FlReadWriteTrack: Params - %x,%x,%x,%x,%x,%x,%x,%x\n",
                        DisketteExtension->FifoBuffer[1],
                        DisketteExtension->FifoBuffer[2],
                        DisketteExtension->FifoBuffer[3],
                        DisketteExtension->FifoBuffer[4],
                        DisketteExtension->FifoBuffer[5],
                        DisketteExtension->FifoBuffer[6],
                        DisketteExtension->FifoBuffer[7],
                        DisketteExtension->FifoBuffer[8])
                       );
            status = FlIssueCommand( DisketteExtension,
                                     DisketteExtension->FifoBuffer,
                                     DisketteExtension->FifoBuffer,
                                     IoMdl,
                                     IoOffset,
                                     transferBytes );

            if (NT_SUCCESS(status)) {

                if (IsNEC_98) {
                    if(DisketteExtension->FifoBuffer[0] & STREG0_DRIVE_NOT_READY) {
                         return STATUS_DEVICE_NOT_READY;
                    }
                } // (IsNEC_98)

                if ((DisketteExtension->FifoBuffer[0] & STREG0_END_MASK) !=
                        STREG0_END_NORMAL) {

                    DisketteExtension->HardwareFailed = TRUE;

                    status = FlInterpretError(DisketteExtension->FifoBuffer[1],
                                              DisketteExtension->FifoBuffer[2]);
                } else {
                    //
                    // The floppy controller may return no errors but not have
                    // read all of the requested data.  If this is the case,
                    // record it as an error and retru the operation.
                    //
                    if (DisketteExtension->FifoBuffer[5] != 1) {

                        DisketteExtension->HardwareFailed = TRUE;
                        status = STATUS_FLOPPY_UNKNOWN_ERROR;
                    }
                }
            } else {
                FloppyDump( FLOPINFO,
                            ("FlReadWriteTrack: %s command failed %x\n",
                            WriteOperation ? "write" : "read",
                            status) );
            }

            if (NT_SUCCESS(status)) {
                break;
            }

            if (ioRetry >= 2) {
                FloppyDump(FLOPINFO,
                           ("FlReadWriteTrack: too many retries - failing\n"));
                break;
            }
        }

        if (NT_SUCCESS(status)) {
            break;
        }

        // We failed quite a bit so make seeks mandatory.
        recalibrateDrive = TRUE;
    }

    if (!NT_SUCCESS(status) && NumberOfSectors > 1) {

        // Retry one sector at a time.

        FloppyDump( FLOPINFO,
                    ("FlReadWriteTrack: Attempting sector at a time\n") );

        for (i = 0; i < NumberOfSectors; i++) {
            status = FlReadWriteTrack( DisketteExtension,
                                       IoMdl,
                                       IoOffset+(((ULONG)i)<<byteToSectorShift),
                                       WriteOperation,
                                       Cylinder,
                                       Head,
                                       (UCHAR) (Sector + i),
                                       1,
                                       FALSE );

            if (!NT_SUCCESS(status)) {
                FloppyDump( FLOPINFO,
                            ("FlReadWriteTrack: failed sector %d status %x\n",
                            i,
                            status) );

                DisketteExtension->HardwareFailed = TRUE;
                break;
            }
        }
    }

    return status;
}

NTSTATUS
FlReadWrite(
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN OUT PIRP Irp,
    IN BOOLEAN DriveStarted
    )

/*++

Routine Description:

    This routine is called by the floppy thread to read/write data
    to/from the diskette.  It breaks the request into pieces called
    "transfers" (their size depends on the buffer size, where the end of
    the track is, etc) and retries each transfer until it succeeds or
    the retry count is exceeded.

Arguments:

    DisketteExtension - a pointer to our data area for the drive to be
    accessed.

    Irp - a pointer to the IO Request Packet.

    DriveStarted - indicated whether or not the drive has been started.

Return Value:

    STATUS_SUCCESS if the packet was successfully read or written; the
    appropriate error is propogated otherwise.

--*/

{
    PIO_STACK_LOCATION      irpSp;
    BOOLEAN                 writeOperation;
    NTSTATUS                status;
    PDRIVE_MEDIA_CONSTANTS  driveMediaConstants;
    ULONG                   byteToSectorShift;
    ULONG                   currentSector, firstSector, lastSector;
    ULONG                   trackSize;
    UCHAR                   sectorsPerTrack, numberOfHeads;
    UCHAR                   currentHead, currentCylinder, trackSector;
    PCHAR                   userBuffer;
    UCHAR                   skew, skewDelta;
    UCHAR                   numTransferSectors;
    PMDL                    mdl;
    PCHAR                   ioBuffer;
    ULONG                   ioOffset;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    FloppyDump(
        FLOPSHOW,
        ("FlReadWrite: for %s at offset %x size %x ",
         irpSp->MajorFunction == IRP_MJ_WRITE ? "write" : "read",
         irpSp->Parameters.Read.ByteOffset.LowPart,
         irpSp->Parameters.Read.Length)
        );

    // Check for valid operation on this device.

    if (irpSp->MajorFunction == IRP_MJ_WRITE) {
        if (DisketteExtension->IsReadOnly) {
            FloppyDump( FLOPSHOW, ("is read-only\n") );
            return STATUS_INVALID_PARAMETER;
        }
        writeOperation = TRUE;
    } else {
        writeOperation = FALSE;
    }

    FloppyDump( FLOPSHOW, ("\n") );

    // Start up the drive.

    if (DriveStarted) {
        status = STATUS_SUCCESS;
    } else {
        status = FlStartDrive( DisketteExtension,
                               Irp,
                               writeOperation,
                               TRUE,
                               (BOOLEAN)
                                      !!(irpSp->Flags&SL_OVERRIDE_VERIFY_VOLUME));
    }

    if (!NT_SUCCESS(status)) {
        FloppyDump(
            FLOPSHOW,
            ("FlReadWrite: error on start %x\n", status)
            );
        return status;
    }

    if (IsNEC_98) {

        FlHdbit(DisketteExtension);

    } // (IsNEC_98)

    if (DisketteExtension->MediaType == Unknown) {
        FloppyDump( FLOPSHOW, ("not recognized\n") );
        return STATUS_UNRECOGNIZED_MEDIA;
    }

    // The drive has started up with a recognized media.
    // Gather some relavant parameters.

    driveMediaConstants = &DisketteExtension->DriveMediaConstants;

    byteToSectorShift = SECTORLENGTHCODE_TO_BYTESHIFT +
                        driveMediaConstants->SectorLengthCode;
    firstSector = irpSp->Parameters.Read.ByteOffset.LowPart>>
                  byteToSectorShift;
    lastSector = firstSector + (irpSp->Parameters.Read.Length>>
                                byteToSectorShift);
    sectorsPerTrack = driveMediaConstants->SectorsPerTrack;
    numberOfHeads = driveMediaConstants->NumberOfHeads;
    userBuffer = MmGetSystemAddressForMdlSafe(Irp->MdlAddress,
                                              HighPagePriority);
    if (userBuffer == NULL) {
       FloppyDump(FLOPWARN,
                  ("MmGetSystemAddressForMdlSafe returned NULL in FlReadWrite\n")
                  );
       return STATUS_INSUFFICIENT_RESOURCES;
    }

    trackSize = ((ULONG) sectorsPerTrack)<<byteToSectorShift;

    skew = 0;
    skewDelta = driveMediaConstants->SkewDelta;
    for (currentSector = firstSector;
         currentSector < lastSector;
         currentSector += numTransferSectors) {

        // Compute cylinder, head and sector from absolute sector.

        currentCylinder = (UCHAR) (currentSector/sectorsPerTrack/numberOfHeads);
        trackSector = (UCHAR) (currentSector%sectorsPerTrack);
        currentHead = (UCHAR) (currentSector/sectorsPerTrack%numberOfHeads);
        numTransferSectors = sectorsPerTrack - trackSector;
        if (lastSector - currentSector < numTransferSectors) {
            numTransferSectors = (UCHAR) (lastSector - currentSector);
        }

        //
        // If we're using a temporary IO buffer because of
        // insufficient registers in the DMA and we're
        // doing a write then copy the write buffer to
        // the contiguous buffer.
        //

        if (trackSize > DisketteExtension->MaxTransferSize) {

            FloppyDump(FLOPSHOW,
                      ("FlReadWrite allocating an IoBuffer\n")
                      );
            FlAllocateIoBuffer(DisketteExtension, trackSize);
            if (!DisketteExtension->IoBuffer) {
                FloppyDump(
                    FLOPSHOW,
                    ("FlReadWrite: no resources\n")
                    );
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            mdl = DisketteExtension->IoBufferMdl;
            ioBuffer = DisketteExtension->IoBuffer;
            ioOffset = 0;
            if (writeOperation) {
                RtlMoveMemory(ioBuffer,
                              userBuffer + ((currentSector - firstSector)<<
                                            byteToSectorShift),
                              ((ULONG) numTransferSectors)<<byteToSectorShift);
            }
        } else {
            mdl = Irp->MdlAddress;
            ioOffset = (currentSector - firstSector) << byteToSectorShift;
        }

        //
        // Transfer the track.
        // Do what we can to avoid missing revs.
        //

        // Alter the skew to be in the range of what
        // we're transfering.

        if (skew >= numTransferSectors + trackSector) {
            skew = 0;
        }

        if (skew < trackSector) {
            skew = trackSector;
        }

        // Go from skew to the end of the irp.

        status = FlReadWriteTrack(
                  DisketteExtension,
                  mdl,
                  ioOffset + (((ULONG) skew - trackSector)<<byteToSectorShift),
                  writeOperation,
                  currentCylinder,
                  currentHead,
                  skew,
                  (UCHAR) (numTransferSectors + trackSector - skew),
                  TRUE);

        // Go from start of irp to skew.

        if (NT_SUCCESS(status) && skew > trackSector) {
            status = FlReadWriteTrack( DisketteExtension,
                                       mdl,
                                       ioOffset,
                                       writeOperation,
                                       currentCylinder,
                                       currentHead,
                                       trackSector,
                                       (UCHAR) (skew - trackSector),
                                       FALSE);
        } else {
            skew = (numTransferSectors + trackSector)%sectorsPerTrack;
        }

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // If we used the temporary IO buffer to do the
        // read then copy the contents back to the IRPs buffer.
        //

        if (!writeOperation &&
            trackSize > DisketteExtension->MaxTransferSize) {

            RtlMoveMemory( userBuffer + ((currentSector - firstSector) <<
                                byteToSectorShift),
                          ioBuffer,
                          ((ULONG) numTransferSectors)<<byteToSectorShift);
        }

        //
        // Increment the skew.  Do this even if just switching sides
        // for National Super I/O chips.
        //

        skew = (skew + skewDelta)%sectorsPerTrack;
    }

    Irp->IoStatus.Information =
        (currentSector - firstSector) << byteToSectorShift;


    // If the read was successful then consolidate the
    // boot sector with the determined density.

    if (NT_SUCCESS(status) && firstSector == 0) {
        FlConsolidateMediaTypeWithBootSector(DisketteExtension,
                                             (PBOOT_SECTOR_INFO) userBuffer);
    }

    FloppyDump( FLOPSHOW,
                ("FlReadWrite: completed status %x information %d\n",
                status, Irp->IoStatus.Information)
                );
    return status;
}

NTSTATUS
FlFormat(
    IN PDISKETTE_EXTENSION DisketteExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the floppy thread to format some tracks on
    the diskette.  This won't take TOO long because the FORMAT utility
    is written to only format a few tracks at a time so that it can keep
    a display of what percentage of the disk has been formatted.

Arguments:

    DisketteExtension - pointer to our data area for the diskette to be
    formatted.

    Irp - pointer to the IO Request Packet.

Return Value:

    STATUS_SUCCESS if the tracks were formatted; appropriate error
    propogated otherwise.

--*/

{
    LARGE_INTEGER headSettleTime;
    PIO_STACK_LOCATION irpSp;
    PBAD_TRACK_NUMBER badTrackBuffer;
    PFORMAT_PARAMETERS formatParameters;
    PFORMAT_EX_PARAMETERS formatExParameters;
    PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
    NTSTATUS ntStatus;
    ULONG badTrackBufferLength;
    DRIVE_MEDIA_TYPE driveMediaType;
    UCHAR driveStatus;
    UCHAR numberOfBadTracks = 0;
    UCHAR currentTrack;
    UCHAR endTrack;
    UCHAR whichSector;
    UCHAR retryCount;
    BOOLEAN bufferOverflow = FALSE;
    FDC_DISK_CHANGE_PARMS fdcDiskChangeParms;

    FloppyDump(
        FLOPSHOW,
        ("Floppy: FlFormat...\n")
        );

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    formatParameters = (PFORMAT_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;
    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_DISK_FORMAT_TRACKS_EX) {
        formatExParameters =
                (PFORMAT_EX_PARAMETERS) Irp->AssociatedIrp.SystemBuffer;
    } else {
        formatExParameters = NULL;
    }

    FloppyDump(
        FLOPFORMAT,
        ("Floppy: Format Params - MediaType: %d\n"
         "------                  Start Cyl: %x\n"
         "------                  End   Cyl: %x\n"
         "------                  Start  Hd: %d\n"
         "------                  End    Hd: %d\n",
         formatParameters->MediaType,
         formatParameters->StartCylinderNumber,
         formatParameters->EndCylinderNumber,
         formatParameters->StartHeadNumber,
         formatParameters->EndHeadNumber)
         );

    badTrackBufferLength =
                    irpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Figure out which entry in the DriveMediaConstants table to use.
    // We know we'll find one, or FlCheckFormatParameters() would have
    // rejected the request.
    //

    driveMediaType =
        DriveMediaLimits[DisketteExtension->DriveType].HighestDriveMediaType;

    while ( ( DriveMediaConstants[driveMediaType].MediaType !=
            formatParameters->MediaType ) &&
        ( driveMediaType > DriveMediaLimits[DisketteExtension->DriveType].
            LowestDriveMediaType ) ) {

        driveMediaType--;
    }

    driveMediaConstants = &DriveMediaConstants[driveMediaType];

    //
    // Set some values in the diskette extension to indicate what we
    // know about the media type.
    //

    DisketteExtension->MediaType = formatParameters->MediaType;
    DisketteExtension->DriveMediaType = driveMediaType;
    DisketteExtension->DriveMediaConstants =
        DriveMediaConstants[driveMediaType];

    if (formatExParameters) {
        DisketteExtension->DriveMediaConstants.SectorsPerTrack =
                (UCHAR) formatExParameters->SectorsPerTrack;
        DisketteExtension->DriveMediaConstants.FormatGapLength =
                (UCHAR) formatExParameters->FormatGapLength;
    }

    driveMediaConstants = &(DisketteExtension->DriveMediaConstants);

    DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;

    DisketteExtension->ByteCapacity =
        ( driveMediaConstants->BytesPerSector ) *
        driveMediaConstants->SectorsPerTrack *
        ( 1 + driveMediaConstants->MaximumTrack ) *
        driveMediaConstants->NumberOfHeads;

    currentTrack = (UCHAR)( ( formatParameters->StartCylinderNumber *
        driveMediaConstants->NumberOfHeads ) +
        formatParameters->StartHeadNumber );

    endTrack = (UCHAR)( ( formatParameters->EndCylinderNumber *
        driveMediaConstants->NumberOfHeads ) +
        formatParameters->EndHeadNumber );

    FloppyDump(
        FLOPFORMAT,
        ("Floppy: Format - Starting/ending tracks: %x/%x\n",
         currentTrack,
         endTrack)
        );

    //
    // Set the data rate (which depends on the drive/media
    // type).
    //

    if (IsNEC_98) {

        FlHdbit(DisketteExtension);

    } // (IsNEC_98)

    if ( DisketteExtension->LastDriveMediaType != driveMediaType ) {

        ntStatus = FlDatarateSpecifyConfigure( DisketteExtension );

        if ( !NT_SUCCESS( ntStatus ) ) {

            return ntStatus;
        }
    }

    //
    // Since we're doing a format, make this drive writable.
    //

    DisketteExtension->IsReadOnly = FALSE;

    //
    // Format each track.
    //

    do {

        //
        // Seek to proper cylinder
        //

        DisketteExtension->FifoBuffer[0] = COMMND_SEEK;
        DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;
        DisketteExtension->FifoBuffer[2] = (UCHAR)( ( currentTrack /
            driveMediaConstants->NumberOfHeads ) <<
            driveMediaConstants->CylinderShift );

        FloppyDump(
            FLOPFORMAT,
            ("Floppy: Format seek to cylinder: %x\n",
              DisketteExtension->FifoBuffer[1])
            );

        ntStatus = FlIssueCommand( DisketteExtension,
                                   DisketteExtension->FifoBuffer,
                                   DisketteExtension->FifoBuffer,
                                   NULL,
                                   0,
                                   0 );

        if ( NT_SUCCESS( ntStatus ) ) {

            if ( ( DisketteExtension->FifoBuffer[0] & STREG0_SEEK_COMPLETE ) &&
                ( DisketteExtension->FifoBuffer[1] == (UCHAR)( ( currentTrack /
                    driveMediaConstants->NumberOfHeads ) <<
                    driveMediaConstants->CylinderShift ) ) ) {

                //
                // Must delay HeadSettleTime milliseconds before
                // doing anything after a SEEK.
                //

                headSettleTime.LowPart = - ( 10 * 1000 *
                    driveMediaConstants->HeadSettleTime );
                headSettleTime.HighPart = -1;

                KeDelayExecutionThread(
                    KernelMode,
                    FALSE,
                    &headSettleTime );

                if (IsNEC_98) {
                    //
                    // We don't need READ ID at format.
                    //
                } else { // (IsNEC_98)

                    //
                    // Read ID.  Note that we don't bother checking the return
                    // registers, because if this media wasn't formatted we'd
                    // get an error.
                    //

                    DisketteExtension->FifoBuffer[0] =
                        COMMND_READ_ID + COMMND_OPTION_MFM;
                    DisketteExtension->FifoBuffer[1] =
                        DisketteExtension->DeviceUnit;

                    ntStatus = FlIssueCommand( DisketteExtension,
                                               DisketteExtension->FifoBuffer,
                                               DisketteExtension->FifoBuffer,
                                               NULL,
                                               0,
                                               0 );
                } // (IsNEC_98)

            } else {

                FloppyDump(
                    FLOPWARN,
                    ("Floppy: format's seek returned bad registers\n"
                     "------  Statusreg0 = %x\n"
                     "------  Statusreg1 = %x\n",
                     DisketteExtension->FifoBuffer[0],
                     DisketteExtension->FifoBuffer[1])
                    );

                DisketteExtension->HardwareFailed = TRUE;

                ntStatus = STATUS_FLOPPY_BAD_REGISTERS;
            }
        }

        if ( !NT_SUCCESS( ntStatus ) ) {

            FloppyDump(
                FLOPWARN,
                ("Floppy: format's seek/readid returned %x\n", ntStatus)
                );

            return ntStatus;
        }

        //
        // Fill the buffer with the format of this track.
        //

        for (whichSector = 0;
             whichSector < driveMediaConstants->SectorsPerTrack;
             whichSector++) {

            DisketteExtension->IoBuffer[whichSector*4] =
                    currentTrack/driveMediaConstants->NumberOfHeads;
            DisketteExtension->IoBuffer[whichSector*4 + 1] =
                    currentTrack%driveMediaConstants->NumberOfHeads;
            if (formatExParameters) {
                DisketteExtension->IoBuffer[whichSector*4 + 2] =
                        (UCHAR) formatExParameters->SectorNumber[whichSector];
            } else {
                DisketteExtension->IoBuffer[whichSector*4 + 2] =
                    whichSector + 1;
            }
            DisketteExtension->IoBuffer[whichSector*4 + 3] =
                    driveMediaConstants->SectorLengthCode;

            FloppyDump(
                FLOPFORMAT,
                ("Floppy - Format table entry %x - %x/%x/%x/%x\n",
                 whichSector,
                 DisketteExtension->IoBuffer[whichSector*4],
                 DisketteExtension->IoBuffer[whichSector*4 + 1],
                 DisketteExtension->IoBuffer[whichSector*4 + 2],
                 DisketteExtension->IoBuffer[whichSector*4 + 3])
                );
        }

        //
        // Retry until success or too many retries.
        //

        retryCount = 0;

        do {

            ULONG length;

            length = driveMediaConstants->BytesPerSector;

            //
            // Issue command to format track
            //

            DisketteExtension->FifoBuffer[0] =
                COMMND_FORMAT_TRACK + COMMND_OPTION_MFM;
            DisketteExtension->FifoBuffer[1] = (UCHAR)
                ( ( ( currentTrack % driveMediaConstants->NumberOfHeads ) << 2 )
                | DisketteExtension->DeviceUnit );
            DisketteExtension->FifoBuffer[2] =
                driveMediaConstants->SectorLengthCode;
            DisketteExtension->FifoBuffer[3] =
                driveMediaConstants->SectorsPerTrack;
            DisketteExtension->FifoBuffer[4] =
                driveMediaConstants->FormatGapLength;
            DisketteExtension->FifoBuffer[5] =
                driveMediaConstants->FormatFillCharacter;

            FloppyDump(
                FLOPFORMAT,
                ("Floppy: format command parameters\n"
                 "------  Head/Unit:        %x\n"
                 "------  Bytes/Sector:     %x\n"
                 "------  Sectors/Cylinder: %x\n"
                 "------  Gap 3:            %x\n"
                 "------  Filler Byte:      %x\n",
                 DisketteExtension->FifoBuffer[1],
                 DisketteExtension->FifoBuffer[2],
                 DisketteExtension->FifoBuffer[3],
                 DisketteExtension->FifoBuffer[4],
                 DisketteExtension->FifoBuffer[5])
                );
            ntStatus = FlIssueCommand( DisketteExtension,
                                       DisketteExtension->FifoBuffer,
                                       DisketteExtension->FifoBuffer,
                                       DisketteExtension->IoBufferMdl,
                                       0,
                                       length );

            if ( !NT_SUCCESS( ntStatus ) ) {

                FloppyDump(
                    FLOPDBGP,
                    ("Floppy: format returned %x\n", ntStatus)
                    );
            }

            if ( NT_SUCCESS( ntStatus ) ) {

                //
                // Check the return bytes from the controller.
                //

                if ( ( DisketteExtension->FifoBuffer[0] &
                        ( STREG0_DRIVE_FAULT |
                          STREG0_END_INVALID_COMMAND |
              STREG0_END_ERROR
              ) )
                    || ( DisketteExtension->FifoBuffer[1] &
                        STREG1_DATA_OVERRUN ) ||
                    ( DisketteExtension->FifoBuffer[2] != 0 ) ) {

                    FloppyDump(
                        FLOPWARN,
                        ("Floppy: format had bad registers\n"
                         "------  Streg0 = %x\n"
                         "------  Streg1 = %x\n"
                         "------  Streg2 = %x\n",
                         DisketteExtension->FifoBuffer[0],
                         DisketteExtension->FifoBuffer[1],
                         DisketteExtension->FifoBuffer[2])
                        );

                    DisketteExtension->HardwareFailed = TRUE;

                    ntStatus = FlInterpretError(
                        DisketteExtension->FifoBuffer[1],
                        DisketteExtension->FifoBuffer[2] );
                }
            }

        } while ( ( !NT_SUCCESS( ntStatus ) ) &&
                  ( retryCount++ < RECALIBRATE_RETRY_COUNT ) );

        if ( !NT_SUCCESS( ntStatus ) ) {

            if (IsNEC_98) {
                DisketteExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
                DisketteExtension->FifoBuffer[1] = DisketteExtension->DeviceUnit;

                ntStatus = FlIssueCommand( DisketteExtension,
                                           DisketteExtension->FifoBuffer,
                                           DisketteExtension->FifoBuffer,
                                           NULL,
                                           0,
                                           0 );

                if ( !NT_SUCCESS( ntStatus ) ) {

                    FloppyDump(
                        FLOPWARN,
                        ("Floppy: SENSE_DRIVE returned %x\n", ntStatus)
                        );

                    return ntStatus;
                }

                if ( DisketteExtension->FifoBuffer[0] & STREG3_DRIVE_READY ) {

                    driveStatus = DSKCHG_RESERVED;

                } else {

                    driveStatus = DSKCHG_DISKETTE_REMOVED;
                }

            } else { // (IsNEC_98)

                ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                                          IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE,
                                          &fdcDiskChangeParms );

                driveStatus = fdcDiskChangeParms.DriveStatus;
            } // (IsNEC_98)

            if ( (DisketteExtension->DriveType != DRIVE_TYPE_0360) &&
                 driveStatus & DSKCHG_DISKETTE_REMOVED ) {

                //
                // The user apparently popped the floppy.  Return error
                // rather than logging bad track.
                //

           return STATUS_NO_MEDIA_IN_DEVICE;
            }

            //
            // Log the bad track.
            //

            FloppyDump(
                FLOPDBGP,
                ("Floppy: track %x is bad\n", currentTrack)
                );

            if ( badTrackBufferLength >= (ULONG)
                ( ( numberOfBadTracks + 1 ) * sizeof( BAD_TRACK_NUMBER ) ) ) {

                badTrackBuffer = (PBAD_TRACK_NUMBER)
                                 Irp->AssociatedIrp.SystemBuffer;

                badTrackBuffer[numberOfBadTracks] = ( BAD_TRACK_NUMBER )
                    currentTrack;

            } else {

                bufferOverflow = TRUE;
            }

            numberOfBadTracks++;
        }

        currentTrack++;

    } while ( currentTrack <= endTrack );

    if ( ( NT_SUCCESS( ntStatus ) ) && ( bufferOverflow ) ) {

        ntStatus = STATUS_BUFFER_OVERFLOW;
    }

    return ntStatus;
}

BOOLEAN
FlCheckFormatParameters(
    IN PDISKETTE_EXTENSION DisketteExtension,
    IN PFORMAT_PARAMETERS FormatParameters
    )

/*++

Routine Description:

    This routine checks the supplied format parameters to make sure that
    they'll work on the drive to be formatted.

Arguments:

    DisketteExtension - a pointer to our data area for the diskette to
    be formatted.

    FormatParameters - a pointer to the caller's parameters for the FORMAT.

Return Value:

    TRUE if parameters are OK.
    FALSE if the parameters are bad.

--*/

{
    PDRIVE_MEDIA_CONSTANTS driveMediaConstants;
    DRIVE_MEDIA_TYPE driveMediaType;

    //
    // Figure out which entry in the DriveMediaConstants table to use.
    //

    driveMediaType =
        DriveMediaLimits[DisketteExtension->DriveType].HighestDriveMediaType;

    while ( ( DriveMediaConstants[driveMediaType].MediaType !=
            FormatParameters->MediaType ) &&
        ( driveMediaType > DriveMediaLimits[DisketteExtension->DriveType].
            LowestDriveMediaType ) ) {

        driveMediaType--;
    }

    if ( DriveMediaConstants[driveMediaType].MediaType !=
        FormatParameters->MediaType ) {

        return FALSE;

    } else {

        driveMediaConstants = &DriveMediaConstants[driveMediaType];

        if ( ( FormatParameters->StartHeadNumber >
                (ULONG)( driveMediaConstants->NumberOfHeads - 1 ) ) ||
            ( FormatParameters->EndHeadNumber >
                (ULONG)( driveMediaConstants->NumberOfHeads - 1 ) ) ||
            ( FormatParameters->StartCylinderNumber >
                driveMediaConstants->MaximumTrack ) ||
            ( FormatParameters->EndCylinderNumber >
                driveMediaConstants->MaximumTrack ) ||
            ( FormatParameters->EndCylinderNumber <
                FormatParameters->StartCylinderNumber ) ) {

            return FALSE;

        } else {

            if (IsNEC_98) {
                if((FormatParameters->MediaType == F5_360_512)||
                   (FormatParameters->MediaType == F5_320_512)||
                   (FormatParameters->MediaType == F5_320_1024)||
                   (FormatParameters->MediaType == F5_180_512)||
                   (FormatParameters->MediaType == F5_160_512)){

                    return FALSE;
                }
            } // (IsNEC_98)

            return TRUE;
        }
    }
}

NTSTATUS
FlIssueCommand(
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN     PUCHAR FifoInBuffer,
    OUT    PUCHAR FifoOutBuffer,
    IN     PMDL   IoMdl,
    IN OUT ULONG  IoOffset,
    IN     ULONG  TransferBytes
    )

/*++

Routine Description:

    This routine sends the command and all parameters to the controller,
    waits for the command to interrupt if necessary, and reads the result
    bytes from the controller, if any.

    Before calling this routine, the caller should put the parameters for
    the command in ControllerData->FifoBuffer[].  The result bytes will
    be returned in the same place.

    This routine runs off the CommandTable.  For each command, this says
    how many parameters there are, whether or not there is an interrupt
    to wait for, and how many result bytes there are.  Note that commands
    without result bytes actually have two, since the ISR will issue a
    SENSE INTERRUPT STATUS command on their behalf.

Arguments:

    Command - a byte specifying the command to be sent to the controller.

    FloppyExtension - a pointer to our data area for the drive being
    accessed (any drive if a controller command is being given).

Return Value:

    STATUS_SUCCESS if the command was sent and bytes received properly;
    appropriate error propogated otherwise.

--*/

{
    NTSTATUS ntStatus;
    UCHAR i;
    PIRP irp;
    KEVENT DoneEvent;
    IO_STATUS_BLOCK IoStatus;
    PIO_STACK_LOCATION irpSp;
    ISSUE_FDC_COMMAND_PARMS issueCommandParms;

    //
    //  Set the command parameters
    //
    issueCommandParms.FifoInBuffer = FifoInBuffer;
    issueCommandParms.FifoOutBuffer = FifoOutBuffer;
    issueCommandParms.IoHandle = (PVOID)IoMdl;
    issueCommandParms.IoOffset = IoOffset;
    issueCommandParms.TransferBytes = TransferBytes;
    issueCommandParms.TimeOut = FDC_TIMEOUT;

    FloppyDump( FLOPSHOW,
                ("Floppy: FloppyIssueCommand %2x...\n",
                DisketteExtension->FifoBuffer[0])
                );

    ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                              IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND,
                              &issueCommandParms );

    //
    //  If it appears like the floppy controller is not responding
    //  set the HardwareFailed flag which will force a reset.
    //
    if ( ntStatus == STATUS_DEVICE_NOT_READY ||
         ntStatus == STATUS_FLOPPY_BAD_REGISTERS ) {

        DisketteExtension->HardwareFailed = TRUE;
    }

    return ntStatus;
}

NTSTATUS
FlInitializeControllerHardware(
    IN OUT  PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

   This routine is called to reset and initialize the floppy controller device.

Arguments:

    disketteExtension   - Supplies the diskette extension.

Return Value:

--*/

{
    NTSTATUS ntStatus;

    ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                              IOCTL_DISK_INTERNAL_RESET_FDC,
                              NULL );

    if (NT_SUCCESS(ntStatus)) {

        if ( DisketteExtension->PerpendicularMode != 0 ) {

            DisketteExtension->FifoBuffer[0] = COMMND_PERPENDICULAR_MODE;
            DisketteExtension->FifoBuffer[1] =
                (UCHAR) (COMMND_PERPENDICULAR_MODE_OW |
                        (DisketteExtension->PerpendicularMode << 2));

            ntStatus = FlIssueCommand( DisketteExtension,
                                       DisketteExtension->FifoBuffer,
                                       DisketteExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );
        }
    }


    return ntStatus;
}

NTSTATUS
FlFdcDeviceIo(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    )
{
    NTSTATUS ntStatus;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;

    FloppyDump(FLOPINFO,("Calling Fdc Device with %x\n", Ioctl));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FloppyDump(FLOPDBGP,("FlFloppyDeviceIo: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver(DeviceObject, irp);

    if ( ntStatus == STATUS_PENDING ) {

        //
        // Now wait for operation to complete (should already be done,  but
        // maybe not)
        //
        KeWaitForSingleObject( &doneEvent, 
                               Executive, 
                               KernelMode, 
                               FALSE, 
                               NULL );

        ntStatus = ioStatus.Status;
    }

    return ntStatus;
}


NTSTATUS
FlHdbit(
    IN OUT PDISKETTE_EXTENSION DisketteExtension
    )

/*++

Routine Description:

    Set a Hd bit or a FDD EXC bit.

Arguments:

    DisketteExtension - a pointer to our data area for the device extension.


Return Value:

        0: Success
        1: Error

--*/

{
    NTSTATUS ntStatus;
    USHORT   st;                // State of HD bit
    USHORT   st2;               // Set on/off HD bit
    USHORT   st3;               // When set HD bit, then st3=1
    USHORT   st4;               // 1.44MB bit for 1.44MB media
    SHORT    sel;               // 1.44MB Selector No for 1.44MB media
    SHORT    st5=0;             // 1.44MB on: wait for spin for 1.44MB media
    LARGE_INTEGER motorOnDelay;

    USHORT      lpc;
    UCHAR       resultStatus0Save[4];
    USHORT      resultStatus0;
    ULONG       getStatusRetryCount;
    ULONG       rqmReadyRetryCount;

    BOOLEAN     media144MB;
    BOOLEAN     mediaUpTo120MB;
    BOOLEAN     supportDrive;

    SET_HD_BIT_PARMS setHdBitParameter;

    media144MB      = FALSE;
    mediaUpTo120MB  = FALSE;
    supportDrive    = TRUE;

    FloppyDump(
            FLOPSTATUS,
           ("Flpydisk : HdBit Media Type = %d \n", DisketteExtension->DriveMediaType)
    );

    switch(DisketteExtension->DriveMediaType){

        //
        // 1.44MB drive
        //

        case    Drive144Media144Nec98:          // 3.5"   1.44Mb  drive; 1.44Mb  media
            media144MB     = TRUE;

        case    Drive144Media120Nec98:          // 3.5"   1.44Mb  drive; 1.2Mb   media
        case    Drive144Media123Nec98:          // 3.5"   1.44Mb  drive; 1.23Mb   media
        case    Drive120Media120Nec98:          // 5.25"  1.2Mb drive; 1.2Mb   media
        case    Drive120Media123Nec98:          // 5.25"  1.2Mb drive; 1.23Mb   media
        case    Drive12EMedia120Nec98:          // 5.25"  1.2Mb extension drive; 1.2Mb   media
        case    Drive12EMedia123Nec98:          // 5.25"  1.2Mb extension drive; 1.23Mb   media
            mediaUpTo120MB = TRUE;

        case    Drive360Media160Nec98:          // 5.25"  360k  drive;  160k   media
        case    Drive360Media180Nec98:          // 5.25"  360k  drive;  180k   media
        case    Drive360Media320Nec98:          // 5.25"  360k  drive;  320k   media
        case    Drive360Media32XNec98:          // 5.25"  360k  drive;  320k 1k secs
        case    Drive360Media360Nec98:          // 5.25"  360k  drive;  360k   media

        case    Drive120Media160Nec98:          // 5.25"  720k  drive;  160k   media
        case    Drive120Media180Nec98:          // 5.25"  720k  drive;  180k   media
        case    Drive120Media320Nec98:          // 5.25"  720k  drive;  320k   media
        case    Drive120Media32XNec98:          // 5.25"  720k  drive;  320k 1k secs
        case    Drive120Media360Nec98:          // 5.25"  720k  drive;  360k   media
        case    Drive120Media640Nec98:          // 5.25"  720k  drive;  640k   media
        case    Drive120Media720Nec98:          // 5.25"  720k  drive;  720k   media

        case    Drive144Media640Nec98:          // 3.5"   1.44Mb  drive;  640k   media
        case    Drive144Media720Nec98:          // 3.5"   1.44Mb  drive;  720k   media

            break;

        default:

            //
            // As 2HD
            //
            mediaUpTo120MB = TRUE;

            break;
    }

    setHdBitParameter.Media144MB = media144MB;
    setHdBitParameter.More120MB  = mediaUpTo120MB;
    setHdBitParameter.DeviceUnit = DisketteExtension->DeviceUnit;
    setHdBitParameter.DriveType144MB  = (DisketteExtension->DriveType == DRIVE_TYPE_1440) ? TRUE:FALSE;


    ntStatus = FlFdcDeviceIo( DisketteExtension->TargetObject,
                              IOCTL_DISK_INTERNAL_SET_HD_BIT,
                              &setHdBitParameter );

    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    if (setHdBitParameter.ChangedHdBit) {

        ntStatus = FlDatarateSpecifyConfigure( DisketteExtension );
    }

    return ntStatus;
}
NTSTATUS
FloppyQueueRequest    (
    IN OUT PDISKETTE_EXTENSION DisketteExtension,
    IN PIRP Irp
    )   

/*++

Routine Description:

    Queues the Irp in the device queue. This routine will be called whenever
    the device receives IRP_MN_QUERY_STOP_DEVICE or IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    FdoData - pointer to the device's extension.
    
    Irp - the request to be queued.

Return Value:

    NT status code.

--*/
{
    
    KIRQL               oldIrql;
    NTSTATUS            ntStatus;

    //
    // Reset driver paging
    //
    FloppyResetDriverPaging();

    //
    // Check if we are allowed to queue requests.
    //
    ASSERT( DisketteExtension->HoldNewRequests );

    //
    // Preparing for dealing with cancelling stuff.
    // We don't know how long the irp will be in the 
    // queue.  So we need to handle cancel. 
    // Since we use out own queue, we don't need to use
    // the cancel spin lock.
    // 
    KeAcquireSpinLock(&DisketteExtension->FlCancelSpinLock,
                      &oldIrql);
    IoSetCancelRoutine(Irp, 
                       FloppyCancelQueuedRequest);

    //
    // Check if the irp was already canceled
    //
    if ( (Irp->Cancel ) &&
         (IoSetCancelRoutine(Irp, NULL))) { 
            //
            // Already canceled
            //
            Irp->IoStatus.Status      = STATUS_CANCELLED; 
            Irp->IoStatus.Information = 0; 
            KeReleaseSpinLock(&DisketteExtension->FlCancelSpinLock,
                              oldIrql);
            IoCompleteRequest( Irp, IO_NO_INCREMENT ); 
             
            FloppyPageEntireDriver();

            ntStatus = STATUS_CANCELLED; 
 
     } else { 
            //
            // Queue the Irp and set a cancel routine
            //
            Irp->IoStatus.Status = STATUS_PENDING; 
            
            IoMarkIrpPending(Irp); 

            ExInterlockedInsertTailList( &DisketteExtension->NewRequestQueue, 
                                         &Irp->Tail.Overlay.ListEntry,
                                         &DisketteExtension->NewRequestQueueSpinLock); 
           
            KeReleaseSpinLock(&DisketteExtension->FlCancelSpinLock,
                              oldIrql);

            ntStatus = STATUS_PENDING;
      }

      return ntStatus;
}
VOID
FloppyCancelQueuedRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    The cancel routine. Will remove the IRP from the queue and will complete it.
    The cancel spin lock is already acquired when this routine is called.
    

Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the IRP to be cancelled.
    
    
Return Value:

    VOID.

--*/
{
    PDISKETTE_EXTENSION disketteExtension = DeviceObject->DeviceExtension; 
    KIRQL oldIrql; 

    FloppyDump(FLOPDBGP,
               ("Floppy Cancel called.\n"));
 
    KeAcquireSpinLock(&disketteExtension->FlCancelSpinLock,
                      &oldIrql);

    Irp->IoStatus.Status = STATUS_CANCELLED; 
    Irp->IoStatus.Information = 0; 
 
    //
    // Make sure the IRP wasn't removed in Process routine.
    //
    if (Irp->Tail.Overlay.ListEntry.Flink) {
       RemoveEntryList( &Irp->Tail.Overlay.ListEntry ); 
    }
    
    KeReleaseSpinLock(&disketteExtension->FlCancelSpinLock,
                      oldIrql);
 
    IoReleaseCancelSpinLock( Irp->CancelIrql ); 
    
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    FloppyPageEntireDriver();

    return;
} 
VOID
FloppyProcessQueuedRequests    (
    IN OUT PDISKETTE_EXTENSION DisketteExtension
    )   

/*++

Routine Description:

    Removes an dprocesses the entries in the queue. If this routine is  called 
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE 
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs 
    are completed with STATUS_DELETE_PENDING.
    

Arguments:

Return Value:

    VOID.

--*/
{
    
    KIRQL               oldIrql;
    PLIST_ENTRY         headOfList;
    PIRP                currentIrp;
    PIO_STACK_LOCATION  irpSp;
    
    //
    // We need to dequeue all the entries in the queue, to reset the cancel 
    // routine for each of them and then to process then:
    // - if the device is active, we will send them down
    // - else we will complete them with STATUS_DELETE_PENDING
    // (it is a surprise removal and we need to dispose the queue)
    //
    KeAcquireSpinLock(&DisketteExtension->FlCancelSpinLock,
                      &oldIrql);
    while ((headOfList = ExInterlockedRemoveHeadList(
                                &DisketteExtension->NewRequestQueue,
                                &DisketteExtension->NewRequestQueueSpinLock)) != NULL) {
        
        currentIrp = CONTAINING_RECORD( headOfList,
                                        IRP,
                                        Tail.Overlay.ListEntry);

        if (IoSetCancelRoutine( currentIrp, NULL)) {
           irpSp = IoGetCurrentIrpStackLocation( currentIrp );
        } else {
           //
           // Cancel routine is already running for this IRP. 
           // Set the IRP field so that it won't be removed
           // in the cancel routine again.
           //
           currentIrp->Tail.Overlay.ListEntry.Flink = NULL; 
           currentIrp = NULL;
        }

        KeReleaseSpinLock(&DisketteExtension->FlCancelSpinLock,
                          oldIrql);

        if (currentIrp) {
           if ( DisketteExtension->IsRemoved ) {
               //
               // The device was removed, we need to fail the request
               //
               currentIrp->IoStatus.Information = 0;
               currentIrp->IoStatus.Status = STATUS_DELETE_PENDING;
               IoCompleteRequest (currentIrp, IO_NO_INCREMENT);
   
           } else {
   
               switch ( irpSp->MajorFunction ) {
   
               case IRP_MJ_READ:
               case IRP_MJ_WRITE:
   
                   (VOID)FloppyReadWrite( DisketteExtension->DeviceObject, currentIrp );
                   break;
   
               case IRP_MJ_DEVICE_CONTROL:
   
                   (VOID)FloppyDeviceControl( DisketteExtension->DeviceObject, currentIrp);
                   break;
   
               default:
   
                   currentIrp->IoStatus.Information = 0;
                   currentIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                   IoCompleteRequest (currentIrp, IO_NO_INCREMENT);
               }
           }
        }

        if (currentIrp) {
           //
           // Page out the driver if it's no more needed.
           //
           FloppyPageEntireDriver();
        }

        KeAcquireSpinLock(&DisketteExtension->FlCancelSpinLock,
                          &oldIrql);

    }

    KeReleaseSpinLock(&DisketteExtension->FlCancelSpinLock,
                      oldIrql);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\inc\ntddfdc.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    ntddfdc.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the fdc.sys port adapter.

Revision History:

--*/

//
// Floppy Drive Motor Enable
//
#define FDC_MOTOR_A         0x10
#define FDC_MOTOR_B         0x20
#define FDC_MOTOR_C         0x40
#define FDC_MOTOR_D         0x80

//
// Floppy Drive Select
//
#define FDC_SELECT_A        0x00
#define FDC_SELECT_B        0x01
#define FDC_SELECT_C        0x02
#define FDC_SELECT_D        0x03

//
// Floppy commands.
//

#define COMMND_READ_DATA                   0x00
#define COMMND_READ_DELETED_DATA           0x01
#define COMMND_WRITE_DATA                  0x02
#define COMMND_WRITE_DELETED_DATA          0x03
#define COMMND_READ_TRACK                  0x04
#define COMMND_VERIFY                      0x05
#define COMMND_VERSION                     0x06
#define COMMND_FORMAT_TRACK                0x07
#define COMMND_SCAN_EQUAL                  0x08
#define COMMND_SCAN_LOW_OR_EQUAL           0x09
#define COMMND_SCAN_HIGH_OR_EQUAL          0x0A
#define COMMND_RECALIBRATE                 0x0B
#define COMMND_SENSE_INTERRUPT_STATUS      0x0C
#define COMMND_SPECIFY                     0x0D
#define COMMND_SENSE_DRIVE_STATUS          0x0E
#define COMMND_DRIVE_SPECIFICATION         0x0F
#define COMMND_SEEK                        0x10
#define COMMND_CONFIGURE                   0x11
#define COMMND_RELATIVE_SEEK               0x12
#define COMMND_DUMPREG                     0x13
#define COMMND_READ_ID                     0x14
#define COMMND_PERPENDICULAR_MODE          0x15
#define COMMND_LOCK                        0x16
#define COMMND_PART_ID                     0x17
#define COMMND_POWERDOWN_MODE              0x18
#define COMMND_OPTION                      0x19
#define COMMND_SAVE                        0x1A
#define COMMND_RESTORE                     0x1B
#define COMMND_FORMAT_AND_WRITE            0x1C

#ifdef TOSHIBA
#define TOSHIBA_COMMND_MODE     0x1D
#endif

//
// Optional bits used with the commands.
//

#define COMMND_OPTION_MULTI_TRACK          0x80     //
#define COMMND_OPTION_MFM                  0x40     /// Used in read and write commands
#define COMMND_OPTION_SKIP                 0x20     //

#define COMMND_OPTION_CLK48                0x80     // Used in configure command

#define COMMND_OPTION_DIRECTION            0x40     // Used in relative seek command

#define COMMND_OPTION_LOCK                 0x80     // Used in lock command

#define COMMND_DRIVE_SPECIFICATION_DONE    0x80     // Done bit in the Drive Specification argument string



//
// Floppy controler data rates (to be OR'd together)
//
#define FDC_SPEED_250KB     0x0001
#define FDC_SPEED_300KB     0x0002
#define FDC_SPEED_500KB     0x0004
#define FDC_SPEED_1MB       0x0008
#define FDC_SPEED_2MB       0x0010

//
// Dma Width supported
//
#define FDC_8_BIT_DMA       0x0001
#define FDC_16_BIT_DMA      0x0002

//
// Clock Rate to the FDC (FDC_82078 only)
//
#define FDC_CLOCK_NORMAL      0x0000    // Use this for non 82078 parts
#define FDC_CLOCK_48MHZ       0x0001    // 82078 with a 48MHz clock
#define FDC_CLOCK_24MHZ       0x0002    // 82078 with a 24MHz clock

//
// Floppy controler types
//
#define FDC_TYPE_UNKNOWN         0
#define FDC_TYPE_NORMAL          2
#define FDC_TYPE_ENHANCED        3
#define FDC_TYPE_82077           4
#define FDC_TYPE_82077AA         5
#define FDC_TYPE_82078_44        6
#define FDC_TYPE_82078_64        7
#define FDC_TYPE_NATIONAL        8

//
// Internal floppy disk driver device controls.
//

#define IOCTL_DISK_INTERNAL_ACQUIRE_FDC              CTL_CODE(IOCTL_DISK_BASE, 0x300, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_RELEASE_FDC              CTL_CODE(IOCTL_DISK_BASE, 0x301, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_FDC_INFO             CTL_CODE(IOCTL_DISK_BASE, 0x302, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND        CTL_CODE(IOCTL_DISK_BASE, 0x303, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED CTL_CODE(IOCTL_DISK_BASE, 0x304, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_RESET_FDC                CTL_CODE(IOCTL_DISK_BASE, 0x305, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE        CTL_CODE(IOCTL_DISK_BASE, 0x306, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE       CTL_CODE(IOCTL_DISK_BASE, 0x307, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE      CTL_CODE(IOCTL_DISK_BASE, 0x308, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE        CTL_CODE(IOCTL_DISK_BASE, 0x309, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE        CTL_CODE(IOCTL_DISK_BASE, 0x30a, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP          CTL_CODE(IOCTL_DISK_BASE, 0x30b, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_ADAPTER_BUFFER       CTL_CODE(IOCTL_DISK_BASE, 0x30c, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_FLUSH_ADAPTER_BUFFER     CTL_CODE(IOCTL_DISK_BASE, 0x30d, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_FDC_START_READ           CTL_CODE(IOCTL_DISK_BASE, 0x30e, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_FDC_START_WRITE          CTL_CODE(IOCTL_DISK_BASE, 0x30f, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_ENABLER              CTL_CODE(IOCTL_DISK_BASE, 0x310, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_HD_BIT               CTL_CODE(IOCTL_DISK_BASE, 0x311, METHOD_NEITHER, FILE_ANY_ACCESS)

#ifdef TOSHIBA
/* 3 mode support */
#define IOCTL_DISK_INTERNAL_ENABLE_3_MODE       CTL_CODE(IOCTL_DISK_BASE, 0xb01, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_AVAILABLE_3_MODE       CTL_CODE(IOCTL_DISK_BASE, 0xb02, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _enable_3_mode
{   UCHAR   DeviceUnit;
    BOOLEAN Enable3Mode;
} ENABLE_3_MODE, *PENABLE_3_MODE;

#endif


//
// Transfer Buffer Array.  Contains the number of buffers allocated and a
// virtual address for each of the allocated buffers.
//
typedef struct _TRANSFER_BUFFER {
    PHYSICAL_ADDRESS Logical;
    PVOID             Virtual;
} TRANSFER_BUFFER, *PTRANSFER_BUFFER;

//
// Parameters for communicating with fdc.sys
//
//
//	Floppy Device Data returned from the ACPI _FDI method.  This data is
//	very nearly identical to the CM_FLOPPY_DEVICE_DATA retured via
//	IoQueryDeviceDescription.
//	
//	Refer to x86 BIOS documentation for Int13, function 8 for definitions of
//	these fields.
//
typedef struct _ACPI_FDI_DATA {

    ULONG   DriveNumber;
    ULONG   DeviceType;
    ULONG   MaxCylinderNumber;
    ULONG   MaxSectorNumber;
    ULONG   MaxHeadNumber;
    ULONG   StepRateHeadUnloadTime;
    ULONG   HeadLoadTime;
    ULONG   MotorOffTime;
    ULONG   SectorLengthCode;
    ULONG   SectorPerTrack;
    ULONG   ReadWriteGapLength;
    ULONG   DataTransferLength;
    ULONG   FormatGapLength;
    ULONG   FormatFillCharacter;
    ULONG   HeadSettleTime; // in 1ms units, typically 15ms
    ULONG   MotorSettleTime; // in 1/8ms units, typically 8=1ms

} ACPI_FDI_DATA, *PACPI_FDI_DATA;

typedef enum _ACPI_FDI_DEVICE_TYPE {

    CmosProblem = 0,
    Form525Capacity360,
    Form525Capacity1200,
    Form35Capacity720,
    Form35Capacity1440,
    Form35Capacity2880

} ACPI_FDI_DEVICE_TYPE ;

typedef struct _FDC_INFO {
    UCHAR FloppyControllerType;     // Should be any ONE of type FDC_TYPE_XXXX
    UCHAR SpeedsAvailable;          // Any combination of FDC_SPEED_xxxx or'd together
    ULONG AdapterBufferSize;        // number of bytes available in the adapters buffer
                                    // If zero,  then no limit on amount of data pending
                                    // in get/flush adapter buffer
    INTERFACE_TYPE BusType;
    ULONG BusNumber;                // These are used by floppy.sys to query
    ULONG ControllerNumber;         // its device description.
    ULONG PeripheralNumber;
    ULONG UnitNumber;               // NEC98: Indicate device unit number.

    ULONG MaxTransferSize;

	BOOLEAN	AcpiBios;
	BOOLEAN AcpiFdiSupported;
	ACPI_FDI_DATA AcpiFdiData;

    ULONG BufferCount;
    ULONG BufferSize;
    TRANSFER_BUFFER BufferAddress[];

} FDC_INFO, *PFDC_INFO;

//
// TurnOnMotor
//

typedef struct _FDC_ENABLE_PARMS {
    UCHAR DriveOnValue;             // FDC_MOTOR_X + FDC_SELECT_X
    USHORT TimeToWait;
    BOOLEAN MotorStarted;
} FDC_ENABLE_PARMS;

typedef FDC_ENABLE_PARMS *PFDC_ENABLE_PARMS;

//
// DiskChange
//

typedef struct _FDC_DISK_CHANGE_PARMS {
    UCHAR  DriveStatus;
    UCHAR  DriveOnValue;
} FDC_DISK_CHANGE_PARMS, *PFDC_DISK_CHANGE_PARMS;

//
// IssueCommand
//

typedef struct _ISSUE_FDC_COMMAND_PARMS {
    PUCHAR  FifoInBuffer;
    PUCHAR  FifoOutBuffer;
    PVOID   IoHandle;           // Must be "Handle" from ISSUE_FDC_ADAPTER_BUFFER_PARMS or Mdl
    ULONG   IoOffset;
    ULONG   TransferBytes;      // Must be return value from ISSUE_FDC_ADAPTER_BUFFER_PARMS "TransferBytes"
    ULONG   TimeOut;
} ISSUE_FDC_COMMAND_PARMS, *PISSUE_FDC_COMMAND_PARMS;

//
// Fill/Flush Adapter Buffer
//

typedef struct _ISSUE_FDC_ADAPTER_BUFFER_PARMS {
    PVOID   IoBuffer;           // Pointer to caller's data buffer (if NULL, no data is copied
                                // to (GET) /from (FLUSH) the adapter buffer)

    USHORT  TransferBytes;      // amount of data to transfer (could be less on return
                                // if insufficient space to copy buffer). Could be Zero
                                // if no buffers are available

    PVOID   Handle;             // used to pass in the IoBuffer field of the ISSUE_FDC_COMMAND_PARMS
                                // structure.

} ISSUE_FDC_ADAPTER_BUFFER_PARMS, *PISSUE_FDC_ADAPTER_BUFFER_PARMS;

//
// NEC98: Set a HD bit or a FDD EXC bit.
//

typedef struct _SET_HD_BIT_PARMS {

    BOOLEAN DriveType144MB;     // Indicate drive Type is 1.44MB.
    BOOLEAN Media144MB;         // Indicate media is 1.44MB
    BOOLEAN More120MB;          // Indicate capacity of media is 1.2MB or more
    UCHAR   DeviceUnit;         // Indicate device unit number
    BOOLEAN ChangedHdBit;       // Indicate HD Bit have been changed

} SET_HD_BIT_PARMS, *PSET_HD_BIT_PARMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\fdc\q117enum.c ===
/*****************************************************************************
*
* COPYRIGHT 1993 - COLORADO MEMORY SYSTEMS, INC.
* COPYRIGHT 1997 - COLORADO SOFTWARE ARCHITECTS, INC.
*
* ALL RIGHTS RESERVED.
*
******************************************************************************
*
* FUNCTION: cqd_LocateDevice
*
* PURPOSE:
*
*****************************************************************************/
#include <ntddk.h>
#include <ntddfdc.h>
#include "q117_dat.h"
/*endinclude*/

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,cqd_LocateDevice)
#pragma alloc_text(PAGE,cqd_InitializeContext)
#pragma alloc_text(PAGE,cqd_LookForDevice)
#pragma alloc_text(PAGE,cqd_SendPhantomSelect)
#pragma alloc_text(PAGE,cqd_CmdSelectDevice)
#pragma alloc_text(PAGE,cqd_CmdDeselectDevice)
#pragma alloc_text(PAGE,cqd_ConnerPreamble)
#pragma alloc_text(PAGE,cqd_DeselectDevice)
#pragma alloc_text(PAGE,cqd_SendByte)
#pragma alloc_text(PAGE,cqd_ReceiveByte)
#pragma alloc_text(PAGE,cqd_GetDeviceError)
#pragma alloc_text(PAGE,cqd_WaitActive)
#pragma alloc_text(PAGE,cqd_GetStatus)
#pragma alloc_text(PAGE,cqd_WaitCommandComplete)
#pragma alloc_text(PAGE,cqd_Report)
#pragma alloc_text(PAGE,cqd_ClearTapeError)
#pragma alloc_text(PAGE,cqd_ResetFDC)
#pragma alloc_text(PAGE,cqd_ConfigureFDC)
#pragma alloc_text(PAGE,cqd_DCROut)
#pragma alloc_text(PAGE,cqd_DSROut)
#pragma alloc_text(PAGE,cqd_TDROut)
#pragma alloc_text(PAGE,cqd_IssueFDCCommand)
#pragma alloc_text(PAGE,kdi_Error)
#pragma alloc_text(PAGE,kdi_GetErrorType)
#pragma alloc_text(PAGE,kdi_ReportAbortStatus)
#pragma alloc_text(PAGE,kdi_GetSystemTime)
#pragma alloc_text(PAGE,kdi_GetInterfaceType)
// #pragma alloc_text(PAGE,kdi_CheckedDump)
#pragma alloc_text(PAGE,kdi_Sleep)
#pragma alloc_text(PAGE,kdi_FdcDeviceIo)
#endif

#define FCT_ID 0x11017

NTSTATUS 
cqd_LocateDevice(
    IN PVOID context,
    IN PUCHAR vendor_detected
    )
/* COMMENTS: *****************************************************************
*
* The drive search must be done in a specific order.  Drives which use only a
* hardware select scheme must be searched first.  If they are not, some of
* them will simulate another manufacturers drive based on the SW select they
* receive.  In many cases this simulation is incomplete and must not be used.
* Whenever possible, an attempt must be made to select a drive in it's native
* mode.
*
* DEFINITIONS: *************************************************************/
{
    NTSTATUS status;          // NTSTATUS or error condition.
    USHORT i;                   // loop variable
	CqdContextPtr cqd_context;
    BOOLEAN found = FALSE;
    USHORT ven;
    UCHAR drv;
    USHORT seq;

    cqd_context = (CqdContextPtr)context;

    for ( i = 0; i < FIND_RETRIES && !found; i++ ) {

        seq = 0;

        do {
            ++seq;
            switch(seq) {
            case 1:  ven = VENDOR_UNKNOWN;          drv = DRIVEU;   break;
            case 2:  ven = VENDOR_MOUNTAIN_SUMMIT;  drv = DRIVEU;   break;
            case 3:  ven = VENDOR_CMS;              drv = DRIVEU;   break;
            case 4:  ven = VENDOR_UNKNOWN;          drv = DRIVED;   break;
            case 5:  ven = VENDOR_MOUNTAIN_SUMMIT;  drv = DRIVED;   break;
            case 6:  ven = VENDOR_CMS;              drv = DRIVED;   break;
#ifdef B_DRIVE
            case 7:  ven = VENDOR_CMS;              drv = DRIVEB;   break;
            case 8:  ven = VENDOR_UNKNOWN;          drv = DRIVEUB;  break;
            case 9:  ven = VENDOR_MOUNTAIN_SUMMIT;  drv = DRIVEUB;  break;
            case 10: ven = VENDOR_CMS;              drv = DRIVEUB;  break;
#endif
            default:
                //ASSERT(seq != seq);
                seq = 0;    // flag complete
                break;
            }

            if (seq) {
                cqd_context->device_descriptor.vendor = ven;
                cqd_ResetFDC( cqd_context );
                status = cqd_LookForDevice( cqd_context,
                                            drv,
                                            vendor_detected,
                                            &found);

            }

        } while(!found && seq);

        // If not found, Wait a second, and retry
        if (!found)
            kdi_Sleep(cqd_context->kdi_context, kdi_wt001s);
    }

   // Sort out the results of the drive address search.  A DriveFlt or a
   // CmdFlt indicate that we could never successfully communicate with
   // the tape drive at either address so we must assume that there is
   // no tape drive present. A NECFlt indicates that we had serious
   // trouble talking to the FDC so we must assume that it is either
   // broken or not there.  The last thing to consider here is a TapeFlt.
   // If the TapeFlt indicates either a hardware or software reset it is
   // save to continue and the error can be ignored (since we must be
   // starting a tape session neither of these errors should bother us).
   // If the TapeFlt indicates any other error, it probably means some
   // badness has happened.

    switch (kdi_GetErrorType(status)) {

    case ERR_DRIVE_FAULT:
    case ERR_CMD_FAULT:
    case ERR_CMD_OVERRUN:
        status = kdi_Error(ERR_NO_DRIVE, FCT_ID, ERR_SEQ_1);
        break;

    case ERR_FDC_FAULT:
    case ERR_INVALID_FDC_STATUS:
        status = kdi_Error(ERR_NO_FDC, FCT_ID, ERR_SEQ_1);
        break;

    case ERR_INVALID_COMMAND:
        break;

    default:
        status = STATUS_SUCCESS;
        break;

    }

#if DBG

    if (status) {

        kdi_CheckedDump( QIC117INFO,
                         "Q117i: DLocateDrv Failed %08x\n",
                         status);
    }

#endif

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11009

VOID 
cqd_InitializeContext(
    IN PVOID cqd_context,
    IN PVOID kdi_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_InitializeContext
*
* PURPOSE: Initialize the common driver context.
*
*****************************************************************************/
{

    RtlZeroMemory( cqd_context, sizeof(CqdContext) );
    ((CqdContextPtr)cqd_context)->kdi_context = kdi_context;
    ((CqdContextPtr)cqd_context)->pegasus_supported = TRUE;
    ((CqdContextPtr)cqd_context)->configured = FALSE;
    ((CqdContextPtr)cqd_context)->cms_mode = FALSE;
    ((CqdContextPtr)cqd_context)->selected = FALSE;
    ((CqdContextPtr)cqd_context)->cmd_selected = FALSE;
    ((CqdContextPtr)cqd_context)->operation_status.no_tape = TRUE;
    ((CqdContextPtr)cqd_context)->device_cfg.speed_change = TRUE;
    ((CqdContextPtr)cqd_context)->drive_parms.mode = PRIMARY_MODE;
    ((CqdContextPtr)cqd_context)->device_descriptor.vendor = VENDOR_UNKNOWN;
    ((CqdContextPtr)cqd_context)->device_descriptor.fdc_type = FDC_TYPE_UNKNOWN;
    ((CqdContextPtr)cqd_context)->controller_data.isr_reentered = 0;
    ((CqdContextPtr)cqd_context)->controller_data.start_format_mode = FALSE;
    ((CqdContextPtr)cqd_context)->controller_data.end_format_mode = FALSE;
    ((CqdContextPtr)cqd_context)->controller_data.perpendicular_mode = FALSE;
    ((CqdContextPtr)cqd_context)->operation_status.xfer_rate = XFER_500Kbps;
    ((CqdContextPtr)cqd_context)->operation_status.retry_mode = FALSE;
    ((CqdContextPtr)cqd_context)->xfer_rate.tape = TAPE_500Kbps;
    ((CqdContextPtr)cqd_context)->xfer_rate.fdc = FDC_500Kbps;
    ((CqdContextPtr)cqd_context)->xfer_rate.srt = SRT_500Kbps;

#if DBG
    ((CqdContextPtr)cqd_context)->dbg_head =
                                ((CqdContextPtr)cqd_context)->dbg_tail = 0;
#endif

    return;
}

#undef FCT_ID
#define FCT_ID 0x1102c

NTSTATUS 
cqd_LookForDevice(
    IN CqdContextPtr cqd_context,
    IN UCHAR drive_selector,
    IN BOOLEAN *vendor_detected,
    IN BOOLEAN *found
    )
/*****************************************************************************
*
* FUNCTION: cqd_LookForDevice
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/

   /* Set the drive select parameters according to the desired target drive */
   /* selector. */

    switch (drive_selector) {

    case DRIVEB:
        cqd_context->device_cfg.select_byte = selb;
        cqd_context->device_cfg.deselect_byte = dselb;
        cqd_context->device_cfg.drive_select = curb;
        break;

    case DRIVED:
        cqd_context->device_cfg.select_byte = seld;
        cqd_context->device_cfg.deselect_byte = dseld;
        cqd_context->device_cfg.drive_select = curd;
        break;

    case DRIVEU:
        cqd_context->device_cfg.select_byte = selu;
        cqd_context->device_cfg.deselect_byte = dselu;
        cqd_context->device_cfg.drive_select = curu;
        break;

    case DRIVEUB:
        cqd_context->device_cfg.select_byte = selub;
        cqd_context->device_cfg.deselect_byte = dselub;
        cqd_context->device_cfg.drive_select = curub;
        break;

    }

   /* Try to communicate with the tape drive by requesting drive status. */
   /* If we can successfully communicate with the drive, wait up to the */
   /* approximate maximum autoload time (150 seconds) for the tape drive */
   /* to become ready. This should cover a new tape being inserted */
   /* immediatley before starting a tape session. */

    *vendor_detected = FALSE;
    *found = FALSE;

    if ((status = cqd_CmdSelectDevice(cqd_context)) == STATUS_SUCCESS) {

        status = cqd_GetDeviceError(cqd_context);
        if (kdi_GetErrorType(status) != ERR_DRIVE_FAULT &&
            kdi_GetErrorType(status) != ERR_CMD_FAULT) {

            *found = TRUE;

            if ((status = cqd_SendByte(cqd_context, FW_CMD_REPORT_VENDOR32)) ==
                 STATUS_SUCCESS) {

                USHORT vendor_id;

                if ((status = cqd_ReceiveByte(
                                cqd_context,
                                READ_WORD,
                                (USHORT *)&vendor_id)) != STATUS_SUCCESS) {
                    cqd_GetDeviceError(cqd_context);
                } else {
                    //
                    // Identify the drive (just new drives that support the
                    // vendor 32 command.  This is needed, as the TEAC drive
                    // can not be de-selected (without it needing to
                    // re-autoload).
                    cqd_context->device_descriptor.vendor =
                                            (USHORT)(vendor_id >> 6);
                    cqd_context->device_descriptor.model =
                                            (UCHAR)(vendor_id & ~VENDOR_MASK);
                    *vendor_detected = TRUE;
                    kdi_CheckedDump(
                        QIC117INFO,
                        "Q117i: Report Vendor 32 succeded (%x) \n", vendor_id);
                    if (cqd_context->device_descriptor.vendor == VENDOR_TEAC &&
                        cqd_context->device_descriptor.model == TEAC_TR1) {
                        // TEAC-800 Does not allow a deselect (except through
                        // a reset)
                        cqd_context->deselect_cmd = 0;
                    }
                }
            }
        }

        cqd_DeselectDevice(cqd_context);
   }

    return status;
}

#undef FCT_ID
#define FCT_ID 0x11040

NTSTATUS 
cqd_SendPhantomSelect(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_SendPhantomSelect
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS status=STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    status = cqd_SendByte( cqd_context, FW_CMD_SELECT_DRIVE );
    if ( status == STATUS_SUCCESS ) {

       kdi_Sleep( cqd_context->kdi_context, INTERVAL_CMD );
       status = cqd_SendByte( cqd_context,
                       (UCHAR)(cqd_context->device_cfg.drive_id + CMD_OFFSET));

        // For teac,  use conner's deselect and cms's slelect
        kdi_Sleep( cqd_context->kdi_context, kdi_wt001s );
        cqd_context->deselect_cmd = FW_CMD_DESELECT_DRIVE;
    }
    return status;
}

NTSTATUS 
cqd_CmdSelectDevice(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_CmdSelectDevice
*
* PURPOSE:
*
*****************************************************************************/
{

    NTSTATUS status = STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    KdiContextPtr kdi_context;
    FDC_ENABLE_PARMS    fdcEnableParms;

    if (cqd_context->selected == FALSE) {

        kdi_context = cqd_context->kdi_context;

        fdcEnableParms.DriveOnValue = cqd_context->device_cfg.select_byte;
        fdcEnableParms.TimeToWait = 0;

        status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                                  IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE,
                                  &fdcEnableParms );

        if (status == STATUS_SUCCESS &&
            (cqd_context->device_cfg.select_byte == seld ||
             cqd_context->device_cfg.select_byte == selu ||
             cqd_context->device_cfg.select_byte == selub) &&
             cqd_context->device_cfg.drive_select != curb) {

            switch ( cqd_context->device_descriptor.vendor ) {

                case VENDOR_UNKNOWN:
                case VENDOR_UNASSIGNED:
                case VENDOR_UNSUPPORTED:
                case VENDOR_PERTEC:
                    cqd_context->deselect_cmd = 0;
                    //Do nothing.
                    break;

                case VENDOR_MOUNTAIN_SUMMIT:
                case VENDOR_ARCHIVE_CONNER:
                case VENDOR_CORE:
                status = cqd_ConnerPreamble(cqd_context, TRUE);
                    cqd_context->deselect_cmd = FW_CMD_CONNER_DESELECT;
                    break;

                case VENDOR_TEAC:
                    if (cqd_context->device_descriptor.model == TEAC_TR1) {
                        // For the teac-800 drive,  we will never deselect the
                        // device (reset is the only way to do so,  not good).
                        // If,  however,  the drive was deselected (reset) by a
                        // floppy drive access, we must take care of that
                        // condition here

                        // Assume the drive is active and send it a device
                        // error command
                        status = cqd_GetDeviceError(cqd_context);

                        // if one of these error occurs,  then the drive was
                        // reset.
                        if (kdi_GetErrorType(status) == ERR_DRIVE_FAULT ||
                            kdi_GetErrorType(status) == ERR_CMD_FAULT) {
                            // the drive must have been reset,  now send the
                            // drive select command, and wait for the drive to
                            // autoload.
                            status = cqd_SendPhantomSelect(cqd_context);

                            // Force no deselect,  We will always leave the
                            // drive selected
                            cqd_context->deselect_cmd = 0;

                            // Wait for the tape to autoload
                            if (status == STATUS_SUCCESS) {
                                status = cqd_ClearTapeError(cqd_context);
                                status = STATUS_SUCCESS;
                            }
                        } else {
                            status = STATUS_SUCCESS;
                            //status = cqd_ClearTapeError(cqd_context);
                        }
                    } else {
                        status = cqd_SendPhantomSelect(cqd_context);
                    }
                    break;

                case VENDOR_IOMEGA:
                case VENDOR_CMS:
                default:
                    status = cqd_SendPhantomSelect(cqd_context);
                    break;
            }
        }

        if (status == STATUS_SUCCESS) {

            cqd_context->selected = TRUE;

        }

        kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );
   }

   return status;
}

#undef  FCT_ID
#define FCT_ID 0x1100C

VOID 
cqd_CmdDeselectDevice(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN drive_selected
    )
/*****************************************************************************
*
* FUNCTION: cqd_CmdDeselectDevice
*
* PURPOSE: Deselect the device and release any locked resources
*
*****************************************************************************/
{

    /* reset the FDC to ensure reliable drive communications */
    (VOID) cqd_ResetFDC(cqd_context);

    if (drive_selected) {

        (VOID) cqd_DeselectDevice(cqd_context);

    }

    /* Dont issue a pause after this command */
    cqd_context->no_pause = TRUE;
    cqd_context->operation_status.new_tape = FALSE;

    return;
}

#undef  FCT_ID
#define FCT_ID 0x1102D

NTSTATUS 
cqd_ConnerPreamble(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN select
    )
/*****************************************************************************
*
* FUNCTION: cqd_ConnerPreamble
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/

    if (select) {

        status = cqd_SendByte(cqd_context, FW_CMD_CONNER_SELECT_1);
        if (status == STATUS_SUCCESS) {

            kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );
            status = cqd_SendByte(cqd_context, FW_CMD_CONNER_SELECT_2);
            kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );

        }

    } else {

        status = cqd_SendByte(cqd_context, cqd_context->deselect_cmd);
        kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );

    }

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x1101D

NTSTATUS 
cqd_DeselectDevice(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_DeselectDevice
*
* PURPOSE: Deselect the tape drive by making the select line inactive (high).
*
*****************************************************************************/
{

    NTSTATUS status=STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    KdiContextPtr kdi_context;

    if (cqd_context->selected == TRUE) {

        if ((cqd_context->device_cfg.select_byte == seld ||
             cqd_context->device_cfg.select_byte == selu ||
             cqd_context->device_cfg.select_byte == selub) &&
             cqd_context->device_cfg.drive_select != curb) {

            if (cqd_context->deselect_cmd) {
                status = cqd_SendByte(cqd_context, cqd_context->deselect_cmd);
                kdi_Sleep(cqd_context->kdi_context, kdi_wt500ms );
            }
        }

        kdi_context = cqd_context->kdi_context;

        status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                                  IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE,
                                  NULL );

        cqd_context->selected = FALSE;
        kdi_Sleep(cqd_context->kdi_context, INTERVAL_CMD );
    }

    return status;
}

#undef FCT_ID
#define FCT_ID 0x11041

NTSTATUS 
cqd_SendByte(
    IN CqdContextPtr cqd_context,
    IN UCHAR command
    )
/*****************************************************************************
*
* FUNCTION: cqd_SendByte
*
* PURPOSE: Transmit a command to the tape drive using step pulses
*          generated by the FDC.
*
*          Using the Present Cylinder Number (pcn) of the FDC
*          calculate a New Cylinder Number (ncn) that will make
*          the FDC generate the number of step pulses corresponding
*          to the command byte.
*
*          Execute a Seek with the FDC.
*
*          Sense Interrupt NTSTATUS of the FDC and make sure that the
*          pcn concurs with the ncn, which indicates that the correct
*          number of step pulses were issued.
*
*****************************************************************************/
{

    NTSTATUS status = STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    FDC_CMD_SEEK seek;
    FDC_CMD_SENSE_INTERRUPT_STATUS sense_int;
    FDC_RESULT result;
#if DBG
    BOOLEAN save;
#endif

#if DBG
   /* Lockout commands used to receive the status */
    save = cqd_context->dbg_lockout;
    cqd_context->dbg_lockout = TRUE;
#endif

    if (command >= MAX_FDC_SEEK || command <= 0) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return kdi_Error(ERR_INVALID_COMMAND, FCT_ID, ERR_SEQ_1);

    }

    if (cqd_context->controller_data.fdc_pcn < MAX_FDC_SEEK) {

        seek.NCN = (UCHAR)(cqd_context->controller_data.fdc_pcn + command);

    } else {

        seek.NCN = (UCHAR)(cqd_context->controller_data.fdc_pcn - command);

    }

    seek.cmd = COMMND_SEEK;
    seek.drive = (UCHAR)cqd_context->device_cfg.drive_select;

    status = cqd_IssueFDCCommand( cqd_context,
                                  (UCHAR *)&seek,
                                  (UCHAR *)&result,
                                  NULL,
                                  0,
                                  0,
                                  kdi_wt001s);

    if (status != STATUS_SUCCESS) {

        return status;

    }

    /* If the sense interrupt status is O.K., then proceed as if */
    /* nothing happened. If, however, there is an error returned by */
    /* status register 0, then return a FDCFLT. */

    if (!(result.ST0 & ST0_IC)) {

        /* If we timed out, then we did the sense interrupt status */
        /* without clearing the interrupt from the interrupt controller. */
        /* Since the FDC did not indicate an error, we assume that we */
        /* missed the interrupt and send the EOI. Only needed for an */
        /* 82072. */

        if (kdi_GetInterfaceType(cqd_context->kdi_context) != MICRO_CHANNEL) {

            if (result.ST0 !=
                (UCHAR)(cqd_context->device_cfg.drive_select | ST0_SE)) {

#if DBG
                cqd_context->dbg_lockout = save;
#endif
                return kdi_Error(ERR_FDC_FAULT, FCT_ID, ERR_SEQ_1);

            }
        }

        if (seek.NCN != result.PCN) {

#if DBG
            cqd_context->dbg_lockout = save;
#endif
            return kdi_Error(ERR_CMD_FAULT, FCT_ID, ERR_SEQ_1);

        }

        cqd_context->controller_data.fdc_pcn = result.PCN;

    } else {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return kdi_Error(ERR_FDC_FAULT, FCT_ID, ERR_SEQ_2);

    }

#if DBG
    cqd_context->dbg_lockout = save;
    DBG_ADD_ENTRY(QIC117SHOWMCMDS, (CqdContextPtr)cqd_context, DBG_SEND_BYTE);
    DBG_ADD_ENTRY(QIC117SHOWMCMDS, (CqdContextPtr)cqd_context, (UCHAR)command);
#endif

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x1103B

NTSTATUS 
cqd_ReceiveByte(
    IN CqdContextPtr cqd_context,
    IN USHORT receive_length,
    OUT PUSHORT receive_data
    )
/*****************************************************************************
*
* FUNCTION: cqd_ReceiveByte
*
* PURPOSE: Read a byte/word of response data from the FDC.  Response data
*          can be drive error/status information or drive configuration
*          information.
*
*          Wait for Track 0 from the tape drive to go active.  This
*          indicates that the drive is ready to start sending data.
*
*          Alternate sending Report Next Bit commands to the tape drive
*          and sampling Track 0 (response data) from the tape drive
*          until the proper number of response data bits have been read.
*
*          Read one final data bit from the tape drive which is the
*          confirmation bit.  This bit must be a 1 to confirm the
*          transmission.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/
    UCHAR i = 0;
    UCHAR stat3;
    USHORT fdc_data= 0;
#if DBG
    BOOLEAN save;
#endif

#if DBG
   /* Lockout commands used to receive the status */
    save = cqd_context->dbg_lockout;
    cqd_context->dbg_lockout = TRUE;
#endif

    if ((status = cqd_WaitActive(cqd_context)) != STATUS_SUCCESS) {
#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return status;
    }

    do {

        if((status = cqd_SendByte( cqd_context,
                                   FW_CMD_RPT_NEXT_BIT)) != STATUS_SUCCESS) {

#if DBG
            cqd_context->dbg_lockout = save;
#endif
            return status;

        }

        kdi_Sleep( cqd_context->kdi_context,
                   INTERVAL_WAIT_ACTIVE );


        if ((status = cqd_GetStatus(cqd_context, &stat3)) != STATUS_SUCCESS) {
#if DBG
            cqd_context->dbg_lockout = save;
#endif
            return status;
        }

        fdc_data >>= 1;
        if (stat3 & ST3_T0) {

            fdc_data |= 0x8000;

        }

        i++;

    } while (i < receive_length);

    /* If the received data is only one byte wide, then shift data to the low */
    /* byte of fdc_data. */

    if (receive_length == READ_BYTE) {

        fdc_data >>= READ_BYTE;

    }

    /* Return the low byte to the caller. */

    ((UCHAR *)receive_data)[LOW_BYTE] = ((UCHAR *)&fdc_data)[LOW_BYTE];

    /* If the FDC data is a word, then return it to the caller. */

    if (receive_length == READ_WORD) {

        ((UCHAR *)receive_data)[HI_BYTE] = ((UCHAR *)&fdc_data)[HI_BYTE];

    }

    if ((status = cqd_SendByte( cqd_context,
                                FW_CMD_RPT_NEXT_BIT)) != STATUS_SUCCESS) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return status;

    }

    kdi_Sleep(cqd_context->kdi_context, INTERVAL_WAIT_ACTIVE );

    if((status = cqd_GetStatus(cqd_context, &stat3)) != STATUS_SUCCESS) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return status;

    }

    if (!(stat3 & (UCHAR)ST3_T0)) {

#if DBG
        cqd_context->dbg_lockout = save;
#endif
        return kdi_Error(ERR_CMD_OVERRUN, FCT_ID, ERR_SEQ_1);

    }

#if DBG
    cqd_context->dbg_lockout = save;
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   DBG_RECEIVE_BYTE);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   fdc_data);
#endif

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11022

NTSTATUS 
cqd_GetDeviceError(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_GetDeviceError
*
* PURPOSE: Read the tape drive NTSTATUS byte and, if necessary, the
*          tape drive Error information.
*
*          Read the Drive NTSTATUS byte from the tape drive.
*
*          If the drive status indicates that the tape drive has an
*          error to report, read the error information which includes
*          both the error code and the command that was being executed
*          when the error occurred.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/
    UCHAR drv_stat;
    USHORT drv_err;
    BOOLEAN repeat_report;
    BOOLEAN repeat_drv_flt = FALSE;
    BOOLEAN esd_retry = FALSE;

    cqd_context->firmware_cmd = FW_NO_COMMAND;
    cqd_context->firmware_error = FW_NO_ERROR;

    do {

        repeat_report = FALSE;

        if ((status = cqd_Report( cqd_context,
                                  FW_CMD_REPORT_STATUS,
                                  (USHORT *)&drv_stat,
                                  READ_BYTE,
                                  &esd_retry)) != STATUS_SUCCESS) {

            if ((kdi_GetErrorType(status) == ERR_DRIVE_FAULT) &&
                    !repeat_drv_flt) {

                repeat_report = TRUE;
                repeat_drv_flt = TRUE;

            }
        }

        if (status == STATUS_SUCCESS) {

            cqd_context->drv_stat = drv_stat;
            kdi_CheckedDump( QIC117DRVSTAT,
                             "QIC117: Drv status = %02x\n",
                             drv_stat);

            if ((drv_stat & STATUS_READY) == 0) {

                status = kdi_Error(ERR_DRV_NOT_READY, FCT_ID, ERR_SEQ_1);

            } else {

                if ((drv_stat & STATUS_CART_PRESENT) != 0) {

                    if ( ((drv_stat & STATUS_NEW_CART) != 0) ||
                         ((cqd_context->device_descriptor.vendor ==
                            VENDOR_IOMEGA) &&
                         cqd_context->operation_status.no_tape) ) {

                      cqd_context->persistent_new_cart = TRUE;

                    }

                    if ((drv_stat & STATUS_BOT) != 0) {

                        cqd_context->rd_wr_op.bot = TRUE;

                    } else {

                        cqd_context->rd_wr_op.bot = FALSE;

                    }

                    if ((drv_stat & STATUS_EOT) != 0) {

                        cqd_context->rd_wr_op.eot = TRUE;

                    } else {

                        cqd_context->rd_wr_op.eot = FALSE;

                    }

                    if ((drv_stat & STATUS_CART_REFERENCED) != 0) {

                        cqd_context->operation_status.cart_referenced = TRUE;

                    } else {

                        cqd_context->operation_status.cart_referenced = FALSE;

                        if (!repeat_drv_flt &&
                            ((drv_stat & STATUS_ERROR) == 0)) {

                            repeat_report = TRUE;
                            repeat_drv_flt = TRUE;

                        }

                    }

                    if ((drv_stat & STATUS_WRITE_PROTECTED) != 0) {

                        cqd_context->tape_cfg.write_protected = TRUE;

                    } else {

                        cqd_context->tape_cfg.write_protected = FALSE;

                    }

                    cqd_context->operation_status.no_tape = FALSE;

                } else {

                    cqd_context->operation_status.no_tape = TRUE;
                    cqd_context->persistent_new_cart = FALSE;
                    cqd_context->operation_status.cart_referenced = FALSE;
                    cqd_context->tape_cfg.write_protected = FALSE;
                    cqd_context->rd_wr_op.bot = FALSE;
                    cqd_context->rd_wr_op.eot = FALSE;

                }


                if ((drv_stat & (STATUS_NEW_CART | STATUS_ERROR)) != 0) {

                    if ((status = cqd_Report(cqd_context,
                                            FW_CMD_REPORT_ERROR,
                                            &drv_err,
                                            READ_WORD,
                                            &esd_retry)) != STATUS_SUCCESS) {

                        if ((kdi_GetErrorType(status) == ERR_DRIVE_FAULT) &&
                            !repeat_drv_flt) {

                            repeat_report = TRUE;
                            repeat_drv_flt = TRUE;

                        }

                    }

                    if (status == STATUS_SUCCESS) {

                        kdi_CheckedDump( QIC117DRVSTAT,
                                        "QIC117: Drv error = %04x\n",
                                        drv_err );

                        if ((drv_stat & STATUS_ERROR) != 0) {

                            cqd_context->firmware_error = (UCHAR)drv_err;
                            cqd_context->firmware_cmd =
                                                (UCHAR)(drv_err >> 8);

                            if (cqd_context->firmware_error ==
                                FW_CMD_WHILE_NEW_CART) {

                                cqd_context->firmware_cmd = FW_NO_COMMAND;
                                cqd_context->firmware_error = FW_NO_ERROR;
                                cqd_context->persistent_new_cart = TRUE;

                            }

                        } else {

                            cqd_context->firmware_cmd = FW_NO_COMMAND;
                            cqd_context->firmware_error = FW_NO_ERROR;

                        }

                        if (cqd_context->firmware_error != FW_NO_ERROR) {

                            switch (cqd_context->firmware_error) {

                            case FW_ILLEGAL_CMD:

                                if (esd_retry) {

                                    esd_retry = FALSE;
                                    repeat_report = TRUE;

                                }

                                break;

                            case FW_NO_DRIVE:

                                cqd_ResetFDC(cqd_context);
                                cqd_context->selected = FALSE;
                                status = cqd_CmdSelectDevice(cqd_context);
                                if (!repeat_drv_flt && (status == STATUS_SUCCESS)) {

                                    repeat_report = TRUE;
                                    repeat_drv_flt = TRUE;

                                } else {

                                    status = kdi_Error( ERR_NO_DRIVE,
                                                        FCT_ID,
                                                        ERR_SEQ_1);

                                }

                                break;

                            case FW_CART_NOT_IN:

                                break;

                            case FW_DRIVE_NOT_READY:

                                status = kdi_Error( ERR_DRV_NOT_READY,
                                                    FCT_ID,
                                                    ERR_SEQ_2);

                                break;

                            default:

                                status = kdi_Error(
                                            (USHORT)(ERR_CQD +
                                                cqd_context->firmware_error),
                                            (ULONG)cqd_context->firmware_cmd,
                                            ERR_SEQ_1);

                            }
                        }
                    }
                }
            }
        }

    } while (repeat_report);

    if (status == STATUS_SUCCESS) {

        cqd_context->operation_status.new_tape =
            cqd_context->persistent_new_cart;

        if (cqd_context->cmd_selected) {

            if (cqd_context->operation_status.no_tape) {

                status = kdi_Error(ERR_NO_TAPE, FCT_ID, ERR_SEQ_1);

            }

            if (cqd_context->operation_status.new_tape) {

                status = kdi_Error(ERR_NEW_TAPE, FCT_ID, ERR_SEQ_1);

            }
        }
    }

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11049

NTSTATUS 
cqd_WaitActive(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_WaitActive
*
* PURPOSE: Wait up to 5ms for tape drive's TRK0 line to go active.
*          5 ms the specified delay for this parameter.
*
*****************************************************************************/
{

    NTSTATUS status;    /* Status or error condition.*/
    UCHAR stat3;

    kdi_Sleep(cqd_context->kdi_context, INTERVAL_WAIT_ACTIVE );

    if ((status = cqd_GetStatus(cqd_context, &stat3)) != STATUS_SUCCESS) {

        return status;

    }

    if (!(stat3 & ST3_T0)) {

        status = kdi_Error(ERR_DRIVE_FAULT, FCT_ID, ERR_SEQ_1);

    }

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11028

NTSTATUS 
cqd_GetStatus(
    IN CqdContextPtr cqd_context,
    OUT UCHAR *status_register_3
    )
/*****************************************************************************
*
* FUNCTION: cqd_GetStatus
*
* PURPOSE: Get status byte from the floppy controller chip.
*          Send the Sense Drive NTSTATUS command to the floppy controller.
*          Read the response from the floppy controller which should be
*          status register 3.
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/
    FDC_CMD_SENSE_DRIVE_STATUS send_st;

    send_st.command = COMMND_SENSE_DRIVE_STATUS;
    send_st.drive = (UCHAR)cqd_context->device_cfg.drive_select;

    status = cqd_IssueFDCCommand( cqd_context,
                                  (UCHAR *)&send_st,
                                  (UCHAR *)status_register_3,
                                  NULL,
                                  0,
                                  0,
                                  0);

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x1104A

NTSTATUS 
cqd_WaitCommandComplete(
    IN CqdContextPtr cqd_context,
    IN ULONG wait_time,
    IN BOOLEAN non_interruptible
    )
/*****************************************************************************
*
* FUNCTION: cqd_WaitCommandComplete
*
* PURPOSE: Wait a specified amount of time for the tape drive to become
*          ready after executing a command.
*
*          Read the Drive NTSTATUS byte from the tape drive.
*
*          If the drive is not ready then wait 1/2 second and try again
*          until the specified time has elapsed.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/
    ULONG wait_start = 0l;
    ULONG wait_current = 0l;

    wait_start = kdi_GetSystemTime();

#if DBG
   /* Lockout commands used to receive the status */
    ++cqd_context->dbg_lockout;
#endif

    do {

        kdi_Sleep(cqd_context->kdi_context, kdi_wt100ms );

        status = cqd_GetDeviceError(cqd_context);

        if (kdi_GetErrorType(status) != ERR_DRV_NOT_READY) {

#if DBG
            --cqd_context->dbg_lockout;
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           DBG_WAITCC);
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           cqd_context->drv_stat);
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           cqd_context->firmware_error);
            DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                           (CqdContextPtr)cqd_context,
                           status);
#endif
            return status;

        }

        if (!non_interruptible &&
            (kdi_ReportAbortStatus(cqd_context->kdi_context) !=
            NO_ABORT_PENDING)) {

#if DBG
            --cqd_context->dbg_lockout;
#endif
            return kdi_Error(ERR_ABORT, FCT_ID, ERR_SEQ_1);

        }

        wait_current = kdi_GetSystemTime();

    } while (wait_time > (wait_current - wait_start));

    if (kdi_ReportAbortStatus(cqd_context->kdi_context) != NO_ABORT_PENDING) {

        status = kdi_Error(ERR_ABORT, FCT_ID, ERR_SEQ_1);

    } else {

       status = kdi_Error(ERR_KDI_TO_EXPIRED, FCT_ID, ERR_SEQ_1);

    }

#if DBG
    --cqd_context->dbg_lockout;

    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   DBG_WAITCC);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   cqd_context->drv_stat);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   cqd_context->firmware_error);
    DBG_ADD_ENTRY( QIC117SHOWMCMDS,
                   (CqdContextPtr)cqd_context,
                   status);
#endif

   return status;
}

#undef  FCT_ID
#define FCT_ID 0x1103C

NTSTATUS 
cqd_Report(
    IN     CqdContextPtr cqd_context,
    IN     UCHAR command,
    IN     PUSHORT report_data,
    IN     USHORT report_size,
    IN OUT PBOOLEAN esd_retry
    )
/*****************************************************************************
*
* FUNCTION: cqd_Report
*
* PURPOSE: Send a report command to the tape drive and get the response
*          data.  If a communication failure occurs, then we assume that
*          it is a result of an ESD hit and retry the communication.
*
*****************************************************************************/
{
    NTSTATUS status;    /* NTSTATUS or error condition.*/
    USHORT i = 0;

    do {

        if (cqd_context->controller_data.end_format_mode) {

            cqd_context->controller_data.end_format_mode = FALSE;
            status = STATUS_SUCCESS;

        } else {

            status = cqd_SendByte(cqd_context, command);

        }

        if (status == STATUS_SUCCESS) {

            status = cqd_ReceiveByte(cqd_context, report_size, report_data);

            if (kdi_GetErrorType(status) == ERR_CMD_OVERRUN) {

                if (esd_retry != NULL) {

                    *esd_retry = TRUE;
                    cqd_ResetFDC(cqd_context);
                    status = cqd_CmdSelectDevice(cqd_context);

                }
            }
        }

    } while (++i < REPORT_RPT && status != STATUS_SUCCESS);

    return status;

}

#undef  FCT_ID
#define FCT_ID 0x11004

NTSTATUS 
cqd_ClearTapeError(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_ClearTapeError
*
* PURPOSE: To correct errors in the Jumbo B drive and firmware version 63.
*
*            This piece of code added due to the face that the Jumbo B drives
*             with firmware 63 have a bug where you put a tape in very slowly,
*            they sense that they have a tape and engage the motor before the
*            tape is actually in. It may also cause the drive to think that
*            the tape is write protected when it actually is not. Sending it
*            the New tape command causes it to go through the tape loading
*            sequence and fixes these 2 bugs.
*
*****************************************************************************/
{

    NTSTATUS status;    /* NTSTATUS or error condition.*/

   /* Send the NewTape command, and then clear the error byte. */

    if ((status = cqd_SendByte(cqd_context, FW_CMD_NEW_TAPE)) == STATUS_SUCCESS) {

        status = cqd_WaitCommandComplete( cqd_context,
                                          INTERVAL_LOAD_POINT,
                                          TRUE);

        /* This command is specific to CMS drives.  Since we don't
         * know whose drive this is when the function is called,
         * the invalid command error is cleared.
         */

        if ((kdi_GetErrorType(status) == ERR_FW_ILLEGAL_CMD) ||
            (kdi_GetErrorType(status) == ERR_FW_UNDEFINED_COMMAND)) {

            status = STATUS_SUCCESS;
        }
    }

    return status;
}
#undef FCT_ID
#define FCT_ID 0x1103d

VOID 
cqd_ResetFDC(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_ResetFDC
*
* PURPOSE: To reset the floppy controller chip.
*
*****************************************************************************/
{

    NTSTATUS status=STATUS_SUCCESS;    /* NTSTATUS or error condition.*/
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_RESET_FDC,
                              NULL );

    if ( NT_SUCCESS(status) ) {
        cqd_ConfigureFDC(cqd_context);
        cqd_context->controller_data.fdc_pcn = 0;
        cqd_context->controller_data.perpendicular_mode = FALSE;
    }

    return;
}

#undef  FCT_ID
#define FCT_ID 0x11006

NTSTATUS 
cqd_ConfigureFDC(
    IN CqdContextPtr cqd_context
    )
/*****************************************************************************
*
* FUNCTION: cqd_ConfigureFDC
*
* PURPOSE: To configure the floppy controller chip according
*          to the current FDC parameters.
*
*****************************************************************************/
{

    NTSTATUS status;                    /* NTSTATUS or error condition.*/
    FDC_CMD_SPECIFY specify;
    FDC_CMD_CONFIGURE config;
    UCHAR precomp_mask = 0;        /* Mask write precomp in DSR register */
    FDC_CMD_DRIVE_SPECIFICATION drive_s;

    status = cqd_DCROut(cqd_context, cqd_context->xfer_rate.fdc);

    if ( status == STATUS_SUCCESS ) {
        if ( cqd_context->device_descriptor.fdc_type == FDC_TYPE_82078_64 )  {    
            drive_s.command = COMMND_DRIVE_SPECIFICATION;
            drive_s.drive_spec = (UCHAR)(DRIVE_SPEC |
                                 ((cqd_context->device_cfg.select_byte &
                                 DRIVE_ID_MASK) << DRIVE_SELECT_OFFSET));
            drive_s.done = DONE_MARKER;
            status = cqd_IssueFDCCommand( cqd_context,
                                          (UCHAR *)&drive_s,
                                          NULL,
                                          NULL,
                                          0,
                                          0,
                                          0 );
        }
    }

    if ((status == STATUS_SUCCESS) &&
        (cqd_context->device_descriptor.fdc_type == FDC_TYPE_82077 ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_82077AA ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_82078_44 ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_82078_64 ||
         cqd_context->device_descriptor.fdc_type == FDC_TYPE_NATIONAL)) {

        /*  if this is a 3010 or 3020 CMS drive, turn off write precomp */
        switch (cqd_context->device_descriptor.drive_class) {
        case QIC3010_DRIVE:
        case QIC3010W_DRIVE:
        case QIC3020_DRIVE:
        case QIC3020W_DRIVE:
            precomp_mask = FDC_PRECOMP_OFF;
            break;
        default:
            precomp_mask = FDC_PRECOMP_ON;
        }

        /* Select the fdc data rate corresponding to the current xfer rate
         * and enable or disable write precomp. */
        status = cqd_DSROut( cqd_context,
                            (UCHAR)(cqd_context->xfer_rate.fdc | precomp_mask));

        /* Deselect the tape drive PLL */
        if (status == STATUS_SUCCESS) {
            cqd_TDROut( cqd_context, curu );

            switch (cqd_context->xfer_rate.fdc) {
            case FDC_250Kbps:
            case FDC_500Kbps:
                /* Enable the tape drive PLL */
                status = cqd_TDROut( cqd_context, curb );
                break;
            }

            if (status == STATUS_SUCCESS) {
                config.cmd = COMMND_CONFIGURE;
                config.czero = FDC_CONFIG_NULL_BYTE;
                config.config = (UCHAR)(FDC_FIFO & FIFO_MASK);
                config.pretrack = FDC_CONFIG_PRETRACK;

                /* issue the configure command to the FDC */
                status = cqd_IssueFDCCommand( cqd_context,
                                            (UCHAR *)&config,
                                            NULL,
                                            NULL,
                                            0,
                                            0,
                                            0 );
            }
        }
        if (status != STATUS_SUCCESS) {

            return status;

        }
    }

    /* Specify the rates for the FDC's three internal timers. */
    /* This includes the head unload time (HUT), the head load */
    /* time (HLT), and the step rate time (SRT) */
    specify.command = COMMND_SPECIFY;
    specify.SRT_HUT = cqd_context->xfer_rate.srt;
    specify.HLT_ND = FDC_HLT;
    status = cqd_IssueFDCCommand( cqd_context,
                                  (UCHAR *)&specify,
                                  NULL,
                                  NULL,
                                  0,
                                  0,
                                  0 );

    return status;
}

#undef  FCT_ID
#define FCT_ID 0x11008

NTSTATUS 
cqd_DCROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR speed
    )
/*****************************************************************************
*
* FUNCTION: cqd_DCROut
*
* PURPOSE: Set the data rate bits of the configuration control register.
*
******************************************************************************/
{
    NTSTATUS status;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    speed = (UCHAR)(speed & FDC_DCR_MASK);

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE,
                              &speed );

    return status;

}

NTSTATUS 
cqd_DSROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR precomp
    )
{

    NTSTATUS status;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP,
                              &precomp );

    return status;

}

NTSTATUS 
cqd_TDROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_mode
    )
{
    NTSTATUS status;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE,
                              &tape_mode );

    return status;

}

NTSTATUS 
cqd_IssueFDCCommand(
    IN CqdContextPtr cqd_context,
    IN PUCHAR     CommandFifo,
    IN PUCHAR     ResultFifo,
    IN PVOID         IoHandle,
    IN ULONG         IoOffset,
    IN ULONG         TransferBytes,
    IN ULONG         TimeOut
    )
{
    NTSTATUS status;
    ISSUE_FDC_COMMAND_PARMS issueCommandParms;
    KdiContextPtr kdi_context;

    kdi_context = cqd_context->kdi_context;

    //
    //  Set the command parameters
    //
    issueCommandParms.FifoInBuffer = CommandFifo;
    issueCommandParms.FifoOutBuffer = ResultFifo;
    issueCommandParms.IoHandle = IoHandle;
    issueCommandParms.IoOffset = IoOffset;
    issueCommandParms.TransferBytes = TransferBytes;
    //
    // Timeouts are requested in terms of milliseconds but fdc.sys needs them
    // in terms of seconds, so adjust the value.
    //
    issueCommandParms.TimeOut = TimeOut / 1000;

    status = kdi_FdcDeviceIo( kdi_context->controller_data.fdcDeviceObject,
                              IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND,
                              &issueCommandParms );

    return status;

}

#undef  FCT_ID
#define FCT_ID 0x15883

NTSTATUS 
kdi_Error(
    IN USHORT  group_and_type,
    IN ULONG grp_fct_id,
    IN UCHAR   sequence
    )
/*****************************************************************************
*
* FUNCTION: kdi_Error
*
* PURPOSE:
*
*****************************************************************************/
{
    return ERROR_ENCODE( group_and_type, grp_fct_id, sequence );
}

#undef  FCT_ID
#define FCT_ID 0x15886

USHORT 
kdi_GetErrorType(
    IN NTSTATUS status
    )
/*****************************************************************************
*
* FUNCTION: kdi_GetErrorType
*
* PURPOSE: Return the GRP+ERROR to the calling function for easy comparisons 
*          and switch statement access.
*****************************************************************************/
{
    return (USHORT)(status >> 16);
}

#undef  FCT_ID
#define FCT_ID 0x15a0f

BOOLEAN 
kdi_ReportAbortStatus(
    IN PVOID   kdi_context
    )
/*****************************************************************************
*
* FUNCTION: kdi_ReportAbortStatus
*
* PURPOSE:
*
*****************************************************************************/
{

    if (((KdiContextPtr)kdi_context)->abort_requested) {

        return ABORT_LEVEL_1;

    } else {

        return NO_ABORT_PENDING;

    }
}

#undef  FCT_ID
#define FCT_ID 0x15A10

ULONG 
kdi_GetSystemTime(
    )
/*****************************************************************************
*
* FUNCTION: kdi_GetSystemTime
*
* PURPOSE:  Gets the system time in milliseconds
*
*****************************************************************************/
{

    ULONG remainder;
    ULONG time_increment;
    ULARGE_INTEGER nanosec_interval;
    LARGE_INTEGER tick_count;
    LARGE_INTEGER temp;

    time_increment = KeQueryTimeIncrement();
    KeQueryTickCount(&tick_count);
    temp = RtlExtendedIntegerMultiply(
                tick_count,
                time_increment);

    nanosec_interval = *(ULARGE_INTEGER *)&temp;

    return RtlEnlargedUnsignedDivide(
                nanosec_interval,
                NANOSEC_PER_MILLISEC,
                &remainder);
}

#undef  FCT_ID
#define FCT_ID 0x15A17

UCHAR 
kdi_GetInterfaceType(
    IN KdiContextPtr kdi_context
    )
/*****************************************************************************
*
* FUNCTION: kdi_GetInterfaceType
*
* PURPOSE:
*
*****************************************************************************/
{
    return kdi_context->interface_type;
}

#undef  FCT_ID
#define FCT_ID 0x15A20

#if DBG

unsigned long kdi_debug_level = 0;

#endif

#if DBG

VOID 
kdi_CheckedDump(
    IN ULONG    debug_level,
    IN PCHAR    format_str,
    IN ULONG_PTR argument
    )
/*****************************************************************************
*
* FUNCTION: kdi_CheckedDump
*
* PURPOSE:
*
*****************************************************************************/
{
   if ((kdi_debug_level & debug_level) != 0) {

      DbgPrint(format_str, argument);
   }

    return;
}

#endif

/*****************************************************************************
*
* FUNCTION: kdi_Sleep
*
* PURPOSE:
*
*****************************************************************************/
#undef  FCT_ID
#define FCT_ID 0x15A0E

NTSTATUS 
kdi_Sleep(
    IN KdiContextPtr kdi_context,
    IN ULONG wait_time
    )
{
    LARGE_INTEGER timeout;

    timeout.QuadPart = -(10 * 1000 * (LONGLONG)wait_time);

    (VOID) KeDelayExecutionThread( KernelMode,
                                   FALSE,
                                   &timeout );

    return kdi_Error( ERR_KDI_TO_EXPIRED, FCT_ID, ERR_SEQ_2 );
}

NTSTATUS 
kdi_FdcDeviceIo(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    )
/*****************************************************************************
*
* FUNCTION: kdi_FdcDeviceIo
*
* PURPOSE:
*
*****************************************************************************/
{
    NTSTATUS ntStatus;
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return ERROR_ENCODE(ERR_OUT_OF_BUFFERS, FCT_ID, 1);
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver(DeviceObject, irp);

    //
    // Now wait for operation to complete (should already be done,  but
    // maybe not)
    //
    if ( ntStatus == STATUS_PENDING ) {

        KeWaitForSingleObject( &doneEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ntStatus = ioStatus.Status;
    }

    if ( ntStatus == STATUS_DEVICE_NOT_READY ) {

        ntStatus = ERROR_ENCODE(ERR_KDI_TO_EXPIRED, FCT_ID, 1);
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\inc\q117_dat.h ===
/*****************************************************************************
*
* COPYRIGHT 1993 - COLORADO MEMORY SYSTEMS, INC.
* COPYRIGHT 1996, 1997 - COLORADO SOFTWARE ARCHITECTS, INC.
* ALL RIGHTS RESERVED.
*
******************************************************************************
*
* PURPOSE: This file contains all of the API's necessary to access
*               the ADI interface.
*
* HISTORY:
*       $Log: /ddk/src/nt50/storage/fdc/qic117/q117_dat.h $
 * 
 * 3     11/15/97 3:06p John Moore
 * Added NTMS support.
 * 
 * 2     11/10/97 9:28a John Moore
 * Update PnP.
 * 
 * 1     11/01/97 11:30a John Moore
*
*****************************************************************************/

#include "ntddk.h"                     /* various NT definitions */
#include "ntdddisk.h"                  /* disk device driver I/O control codes */

NTSTATUS
q117Initialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT q117iDeviceObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
q117Unload(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
q117Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Create (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Close (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

/* QIC117 device specific ioctls. *********************************************/

#define IOCTL_QIC117_BASE                 FILE_DEVICE_TAPE

#define IOCTL_QIC117_DRIVE_REQUEST        CTL_CODE(IOCTL_QIC117_BASE, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_QIC117_CLEAR_QUEUE          CTL_CODE(IOCTL_QIC117_BASE, 0x0002, METHOD_NEITHER, FILE_ANY_ACCESS)

/* ADI PUBLIC DATA STRUCTURES ***********************************************/

#pragma pack(4)

struct S_ADIRequestHdr {

    NTSTATUS    status;             /* O: Status returned from device */
    VOID        (*callback_ptr)(dUDWord, dUDWord, dUWord, dStatus);
    ULONG       callback_host_id;   /* I: (Optional) Add'l routing info for host */
    PVOID       cmd_buffer_ptr;     /* I: Logical buffer pointer passed to ADI */
    PVOID       drv_physical_ptr;   /* X: KDI physical pointer - internal use */
    PVOID       drv_logical_ptr;    /* X: Common driver logical pointer - internal use */
    USHORT      driver_cmd;         /* I: Device driver specific command */
    USHORT      drive_handle;       /* I: Host generated device identifier */
    BOOLEAN     blocking_call;      /* I: TRUE implies block until completion */
};
typedef struct S_ADIRequestHdr ADIRequestHdr, *ADIRequestHdrPtr;

#pragma pack()

/* ERROR CODES: *************************************************************/

#define GROUPID_CQD             (UCHAR)0x11    /* GG = 11, CQD Common QIC117 Device Driver */
#define GROUPID_CSD             (UCHAR)0x12    /* GG = 12, CSD Common SCSI Device Driver */
#define GROUPID_ADI             (UCHAR)0x15    /* GG = 15, Application Driver Interface */

#define ERR_NO_ERR              (NTSTATUS)0
#define ERR_SHIFT               (UCHAR)8

#define ERR_SEQ_1               (UCHAR)0x01
#define ERR_SEQ_2               (UCHAR)0x02
#define ERR_SEQ_3               (UCHAR)0x03
#define ERR_SEQ_4               (UCHAR)0x04
#define ERR_SEQ_5               (UCHAR)0x05
#define ERR_SEQ_6               (UCHAR)0x06

/* ERROR ENCODE MACRO: **************************************************/

#define ERROR_ENCODE(m_error, m_fct, m_seq) \
     (((m_fct & 0x00000fff) << 4) | m_seq) | ((unsigned long)m_error << 16)

/* RAW FIRMWARE ERROR CODES: *************** Hex **** Decimal ***********/

#define FW_NO_COMMAND               (UCHAR)0x0000      /* 0    */
#define FW_NO_ERROR                 (UCHAR)0x0000      /* 0    */
#define FW_DRIVE_NOT_READY          (UCHAR)0x0001      /* 1    */
#define FW_CART_NOT_IN              (UCHAR)0x0002      /* 2    */
#define FW_MOTOR_SPEED_ERROR        (UCHAR)0x0003      /* 3    */
#define FW_STALL_ERROR              (UCHAR)0x0004      /* 4    */
#define FW_WRITE_PROTECTED          (UCHAR)0x0005      /* 5    */
#define FW_UNDEFINED_COMMAND        (UCHAR)0x0006      /* 6    */
#define FW_ILLEGAL_TRACK            (UCHAR)0x0007      /* 7    */
#define FW_ILLEGAL_CMD              (UCHAR)0x0008      /* 8    */
#define FW_ILLEGAL_ENTRY            (UCHAR)0x0009      /* 9    */
#define FW_BROKEN_TAPE              (UCHAR)0x000a      /* 10   */
#define FW_GAIN_ERROR               (UCHAR)0x000b      /* 11   */
#define FW_CMD_WHILE_ERROR          (UCHAR)0x000c      /* 12   */
#define FW_CMD_WHILE_NEW_CART       (UCHAR)0x000d      /* 13   */
#define FW_CMD_UNDEF_IN_PRIME       (UCHAR)0x000e      /* 14   */
#define FW_CMD_UNDEF_IN_FMT         (UCHAR)0x000f      /* 15   */
#define FW_CMD_UNDEF_IN_VERIFY      (UCHAR)0x0010      /* 16   */
#define FW_FWD_NOT_BOT_IN_FMT       (UCHAR)0x0011      /* 17   */
#define FW_EOT_BEFORE_ALL_SEGS      (UCHAR)0x0012      /* 18   */
#define FW_CART_NOT_REFERENCED      (UCHAR)0x0013      /* 19   */
#define FW_SELF_DIAGS_FAILED        (UCHAR)0x0014      /* 20   */
#define FW_EEPROM_NOT_INIT          (UCHAR)0x0015      /* 21   */
#define FW_EEPROM_CORRUPTED         (UCHAR)0x0016      /* 22   */
#define FW_TAPE_MOTION_TIMEOUT      (UCHAR)0x0017      /* 23   */
#define FW_DATA_SEG_TOO_LONG        (UCHAR)0x0018      /* 24   */
#define FW_CMD_OVERRUN              (UCHAR)0x0019      /* 25   */
#define FW_PWR_ON_RESET             (UCHAR)0x001a      /* 26   */
#define FW_SOFTWARE_RESET           (UCHAR)0x001b      /* 27   */
#define FW_DIAG_MODE_1_ERROR        (UCHAR)0x001c      /* 28   */
#define FW_DIAG_MODE_2_ERROR        (UCHAR)0x001d      /* 29   */
#define FW_CMD_REC_DURING_CMD       (UCHAR)0x001e      /* 30   */
#define FW_SPEED_NOT_AVAILABLE      (UCHAR)0x001f      /* 31   */
#define FW_ILLEGAL_CMD_HIGH_SPEED   (UCHAR)0x0020      /* 32   */
#define FW_ILLEGAL_SEEK_SEGMENT     (UCHAR)0x0021      /* 33   */
#define FW_INVALID_MEDIA            (UCHAR)0x0022      /* 34   */
#define FW_HEADREF_FAIL_ERROR       (UCHAR)0x0023      /* 35   */
#define FW_EDGE_SEEK_ERROR          (UCHAR)0x0024      /* 36   */
#define FW_MISSING_TRAINING_TABLE   (UCHAR)0x0025      /* 37   */
#define FW_INVALID_FORMAT           (UCHAR)0x0026      /* 38   */
#define FW_SENSOR_ERROR             (UCHAR)0x0027      /* 39   */
#define FW_TABLE_CHECKSUM_ERROR     (UCHAR)0x0028      /* 40   */
#define FW_WATCHDOG_RESET           (UCHAR)0x0029      /* 41   */
#define FW_ILLEGAL_ENTRY_FMT_MODE   (UCHAR)0x002a      /* 42   */
#define FW_ROM_CHECKSUM_FAILURE     (UCHAR)0x002b      /* 43   */
#define FW_ILLEGAL_ERROR_NUMBER     (UCHAR)0x002c      /* 44   */
#define FW_NO_DRIVE                 (UCHAR)0x00ff    /*255 */


/* DRIVER FIRMWARE ERROR CODES: ******* Range: 0x1100 - 0x112a & 0x11ff *****/

#define ERR_CQD                         (USHORT)(GROUPID_CQD<<ERR_SHIFT)

#define ERR_FW_NO_COMMAND               (USHORT)(ERR_CQD + FW_NO_COMMAND)
#define ERR_FW_NO_ERROR                 (USHORT)(ERR_CQD + FW_NO_ERROR)
#define ERR_FW_DRIVE_NOT_READY          (USHORT)(ERR_CQD + FW_DRIVE_NOT_READY)
#define ERR_FW_CART_NOT_IN              (USHORT)(ERR_CQD + FW_CART_NOT_IN)
#define ERR_FW_MOTOR_SPEED_ERROR        (USHORT)(ERR_CQD + FW_MOTOR_SPEED_ERROR)
#define ERR_FW_STALL_ERROR              (USHORT)(ERR_CQD + FW_STALL_ERROR)
#define ERR_FW_WRITE_PROTECTED          (USHORT)(ERR_CQD + FW_WRITE_PROTECTED)
#define ERR_FW_UNDEFINED_COMMAND        (USHORT)(ERR_CQD + FW_UNDEFINED_COMMAND)
#define ERR_FW_ILLEGAL_TRACK            (USHORT)(ERR_CQD + FW_ILLEGAL_TRACK)
#define ERR_FW_ILLEGAL_CMD              (USHORT)(ERR_CQD + FW_ILLEGAL_CMD)
#define ERR_FW_ILLEGAL_ENTRY            (USHORT)(ERR_CQD + FW_ILLEGAL_ENTRY)
#define ERR_FW_BROKEN_TAPE              (USHORT)(ERR_CQD + FW_BROKEN_TAPE)
#define ERR_FW_GAIN_ERROR               (USHORT)(ERR_CQD + FW_GAIN_ERROR)
#define ERR_FW_CMD_WHILE_ERROR          (USHORT)(ERR_CQD + FW_CMD_WHILE_ERROR)
#define ERR_FW_CMD_WHILE_NEW_CART       (USHORT)(ERR_CQD + FW_CMD_WHILE_NEW_CART)
#define ERR_FW_CMD_UNDEF_IN_PRIME       (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_PRIME)
#define ERR_FW_CMD_UNDEF_IN_FMT         (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_FMT)
#define ERR_FW_CMD_UNDEF_IN_VERIFY      (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_VERIFY)
#define ERR_FW_FWD_NOT_BOT_IN_FMT       (USHORT)(ERR_CQD + FW_FWD_NOT_BOT_IN_FMT)
#define ERR_FW_EOT_BEFORE_ALL_SEGS      (USHORT)(ERR_CQD + FW_EOT_BEFORE_ALL_SEGS)
#define ERR_FW_CART_NOT_REFERENCED      (USHORT)(ERR_CQD + FW_CART_NOT_REFERENCED)
#define ERR_FW_SELF_DIAGS_FAILED        (USHORT)(ERR_CQD + FW_SELF_DIAGS_FAILED)
#define ERR_FW_EEPROM_NOT_INIT          (USHORT)(ERR_CQD + FW_EEPROM_NOT_INIT)
#define ERR_FW_EEPROM_CORRUPTED         (USHORT)(ERR_CQD + FW_EEPROM_CORRUPTED)
#define ERR_FW_TAPE_MOTION_TIMEOUT      (USHORT)(ERR_CQD + FW_TAPE_MOTION_TIMEOUT)
#define ERR_FW_DATA_SEG_TOO_LONG        (USHORT)(ERR_CQD + FW_DATA_SEG_TOO_LONG)
#define ERR_FW_CMD_OVERRUN              (USHORT)(ERR_CQD + FW_CMD_OVERRUN)
#define ERR_FW_PWR_ON_RESET             (USHORT)(ERR_CQD + FW_PWR_ON_RESET)
#define ERR_FW_SOFTWARE_RESET           (USHORT)(ERR_CQD + FW_SOFTWARE_RESET)
#define ERR_FW_DIAG_MODE_1_ERROR        (USHORT)(ERR_CQD + FW_DIAG_MODE_1_ERROR)
#define ERR_FW_DIAG_MODE_2_ERROR        (USHORT)(ERR_CQD + FW_DIAG_MODE_2_ERROR)
#define ERR_FW_CMD_REC_DURING_CMD       (USHORT)(ERR_CQD + FW_CMD_REC_DURING_CMD)
#define ERR_FW_SPEED_NOT_AVAILABLE      (USHORT)(ERR_CQD + FW_SPEED_NOT_AVAILABLE)
#define ERR_FW_ILLEGAL_CMD_HIGH_SPEED   (USHORT)(ERR_CQD + FW_ILLEGAL_CMD_HIGH_SPEED)
#define ERR_FW_ILLEGAL_SEEK_SEGMENT     (USHORT)(ERR_CQD + FW_ILLEGAL_SEEK_SEGMENT)
#define ERR_FW_INVALID_MEDIA            (USHORT)(ERR_CQD + FW_INVALID_MEDIA)
#define ERR_FW_HEADREF_FAIL_ERROR       (USHORT)(ERR_CQD + FW_HEADREF_FAIL_ERROR)
#define ERR_FW_EDGE_SEEK_ERROR          (USHORT)(ERR_CQD + FW_EDGE_SEEK_ERROR)
#define ERR_FW_MISSING_TRAINING_TABLE   (USHORT)(ERR_CQD + FW_MISSING_TRAINING_TABLE)
#define ERR_FW_INVALID_FORMAT           (USHORT)(ERR_CQD + FW_INVALID_FORMAT)
#define ERR_FW_SENSOR_ERROR             (USHORT)(ERR_CQD + FW_SENSOR_ERROR)
#define ERR_FW_TABLE_CHECKSUM_ERROR     (USHORT)(ERR_CQD + FW_TABLE_CHECKSUM_ERROR)
#define ERR_FW_WATCHDOG_RESET           (USHORT)(ERR_CQD + FW_WATCHDOG_RESET)
#define ERR_FW_ILLEGAL_ENTRY_FMT_MODE   (USHORT)(ERR_CQD + FW_ILLEGAL_ENTRY_FMT_MODE)
#define ERR_FW_ROM_CHECKSUM_FAILURE     (USHORT)(ERR_CQD + FW_ROM_CHECKSUM_FAILURE)
#define ERR_FW_ILLEGAL_ERROR_NUMBER     (USHORT)(ERR_CQD + FW_ILLEGAL_ERROR_NUMBER)
#define ERR_FW_NO_DRIVE                 (USHORT)(ERR_CQD + FW_NO_DRIVE)

/* JUMBO DRIVER ERROR CODES: ********** Range: 0x1150 - 0x116f **************/

#define ERR_ABORT                       (USHORT)(ERR_CQD + 0x0050)
#define ERR_BAD_BLOCK_FDC_FAULT         (USHORT)(ERR_CQD + 0x0051)
#define ERR_BAD_BLOCK_HARD_ERR          (USHORT)(ERR_CQD + 0x0052)
#define ERR_BAD_BLOCK_NO_DATA           (USHORT)(ERR_CQD + 0x0053)
#define ERR_BAD_FORMAT                  (USHORT)(ERR_CQD + 0x0054)
#define ERR_BAD_MARK_DETECTED           (USHORT)(ERR_CQD + 0x0055)
#define ERR_BAD_REQUEST                 (USHORT)(ERR_CQD + 0x0056)
#define ERR_CMD_FAULT                   (USHORT)(ERR_CQD + 0x0057)
#define ERR_CMD_OVERRUN                 (USHORT)(ERR_CQD + 0x0058)
#define ERR_DEVICE_NOT_CONFIGURED       (USHORT)(ERR_CQD + 0x0059)
#define ERR_DEVICE_NOT_SELECTED         (USHORT)(ERR_CQD + 0x005a)
#define ERR_DRIVE_FAULT                 (USHORT)(ERR_CQD + 0x005b)
#define ERR_DRV_NOT_READY               (USHORT)(ERR_CQD + 0x005c)
#define ERR_FDC_FAULT                   (USHORT)(ERR_CQD + 0x005d)
#define ERR_FMT_MOTION_TIMEOUT          (USHORT)(ERR_CQD + 0x005e)
#define ERR_FORMAT_TIMED_OUT            (USHORT)(ERR_CQD + 0x005f)
#define ERR_INCOMPATIBLE_MEDIA          (USHORT)(ERR_CQD + 0x0060)
#define ERR_INCOMPATIBLE_PARTIAL_FMT    (USHORT)(ERR_CQD + 0x0061)
#define ERR_INVALID_COMMAND             (USHORT)(ERR_CQD + 0x0062)
#define ERR_INVALID_FDC_STATUS          (USHORT)(ERR_CQD + 0x0063)
#define ERR_NEW_TAPE                    (USHORT)(ERR_CQD + 0x0064)
#define ERR_NO_DRIVE                    (USHORT)(ERR_CQD + 0x0065)
#define ERR_NO_FDC                      (USHORT)(ERR_CQD + 0x0066)
#define ERR_NO_TAPE                     (USHORT)(ERR_CQD + 0x0067)
#define ERR_SEEK_FAILED                 (USHORT)(ERR_CQD + 0x0068)
#define ERR_SPEED_UNAVAILBLE            (USHORT)(ERR_CQD + 0x0069)
#define ERR_TAPE_STOPPED                (USHORT)(ERR_CQD + 0x006a)
#define ERR_UNKNOWN_TAPE_FORMAT         (USHORT)(ERR_CQD + 0x006b)
#define ERR_UNKNOWN_TAPE_LENGTH         (USHORT)(ERR_CQD + 0x006c)
#define ERR_UNSUPPORTED_FORMAT          (USHORT)(ERR_CQD + 0x006d)
#define ERR_UNSUPPORTED_RATE            (USHORT)(ERR_CQD + 0x006e)
#define ERR_WRITE_BURST_FAILURE         (USHORT)(ERR_CQD + 0x006f)
#define ERR_MODE_CHANGE_FAILED          (USHORT)(ERR_CQD + 0x0070)
#define ERR_CONTROLLER_STATE_ERROR      (USHORT)(ERR_CQD + 0x0071)
#define ERR_TAPE_FAULT                  (USHORT)(ERR_CQD + 0x0072)
#define ERR_FORMAT_NOT_SUPPORTED        (USHORT)(ERR_CQD + 0x0073)

/* ADI ERROR CODES: **************** Range: 0x1500 - 0x157F *******************/

#define ERR_ADI                         (USHORT)(GROUPID_ADI<<ERR_SHIFT)

#define ERR_NO_VXD                      (USHORT)(ERR_ADI + 0x0000)
#define ERR_QUEUE_FULL                  (USHORT)(ERR_ADI + 0x0001)
#define ERR_REQS_PENDING                (USHORT)(ERR_ADI + 0x0002)
#define ERR_OUT_OF_MEMORY               (USHORT)(ERR_ADI + 0x0003)
#define ERR_ALREADY_CLOSED              (USHORT)(ERR_ADI + 0x0004)
#define ERR_OUT_OF_HANDLES              (USHORT)(ERR_ADI + 0x0005)
#define ERR_ABORTED_COMMAND             (USHORT)(ERR_ADI + 0x0006)
#define ERR_NOT_INITIALIZED             (USHORT)(ERR_ADI + 0x0007)
#define ERR_NO_REQS_PENDING             (USHORT)(ERR_ADI + 0x0008)
#define ERR_CHANNEL_NOT_OPEN            (USHORT)(ERR_ADI + 0x0009)
#define ERR_NO_HOST_ADAPTER             (USHORT)(ERR_ADI + 0x000a)
#define ERR_CMD_IN_PROGRESS             (USHORT)(ERR_ADI + 0x000b)
#define ERR_IGNORE_ECC                  (USHORT)(ERR_ADI + 0x000c)

#define ERR_INVALID_VXD                 (USHORT)(ERR_ADI + 0x0010)
#define ERR_INVALID_CMD                 (USHORT)(ERR_ADI + 0x0011)
#define ERR_INVALID_CMD_ID              (USHORT)(ERR_ADI + 0x0012)
#define ERR_INVALID_HANDLE              (USHORT)(ERR_ADI + 0x0013)
#define ERR_INVALID_DEVICE_CLASS        (USHORT)(ERR_ADI + 0x0014)

#define ERR_NO_ASPI_VXD                 (USHORT)(ERR_ADI + 0x0020)
#define ERR_INVALID_ASPI_VXD            (USHORT)(ERR_ADI + 0x0021)

#define ERR_END_OF_TAPE                 (USHORT)(ERR_ADI + 0x0060)
#define ERR_TAPE_FULL                   (USHORT)(ERR_ADI + 0x0061)
#define ERR_TAPE_READ_FAILED            (USHORT)(ERR_ADI + 0x0062)
#define ERR_TAPE_WRITE_FAILED           (USHORT)(ERR_ADI + 0x0063)
#define ERR_TAPE_SEEK_FAILED            (USHORT)(ERR_ADI + 0x0064)
#define ERR_TAPE_INFO_FAILED            (USHORT)(ERR_ADI + 0x0065)
#define ERR_TAPE_WRITE_PROTECT          (USHORT)(ERR_ADI + 0x0066)

#define ERR_INTERNAL_ERROR              (USHORT)(ERR_ADI + 0x007f)

/* KDI ERROR CODES: **************** Range: 0x1580 - 0x15FF *******************/

#define ERR_HANDLE_EXISTS               (USHORT)(ERR_ADI + 0x0080)
#define ERR_KDI_NOT_OPEN                (USHORT)(ERR_ADI + 0x0081)
#define ERR_OUT_OF_BUFFERS              (USHORT)(ERR_ADI + 0x0082)
#define ERR_INT13_HOOK_FAILED           (USHORT)(ERR_ADI + 0x0083)
#define ERR_IO_VIRTUALIZE_FAILED        (USHORT)(ERR_ADI + 0x0084)
#define ERR_INVALID_ADDRESS             (USHORT)(ERR_ADI + 0x0085)
#define ERR_JUMPERLESS_CFG_FAILED       (USHORT)(ERR_ADI + 0x0086)
#define ERR_TRK_NO_MEMORY               (USHORT)(ERR_ADI + 0x0090)
#define ERR_TRK_MEM_TEST_FAILED         (USHORT)(ERR_ADI + 0x0091)
#define ERR_TRK_MODE_NOT_SET            (USHORT)(ERR_ADI + 0x0092)
#define ERR_TRK_MODE_SET_FAILED         (USHORT)(ERR_ADI + 0x0093)
#define ERR_TRK_FIFO_FAILED             (USHORT)(ERR_ADI + 0x0094)
#define ERR_TRK_DELAY_NOT_SET           (USHORT)(ERR_ADI + 0x0095)
#define ERR_TRK_BAD_DATA_XFER           (USHORT)(ERR_ADI + 0x0096)
#define ERR_TRK_BAD_CTRL_XFER           (USHORT)(ERR_ADI + 0x0097)
#define ERR_TRK_TEST_WAKE_FAIL          (USHORT)(ERR_ADI + 0x0098)
#define ERR_TRK_AUTO_CFG_FAIL           (USHORT)(ERR_ADI + 0x0099)
#define ERR_TRK_CFG_NEEDS_UPDATE        (USHORT)(ERR_ADI + 0x009A)
#define ERR_TRK_NO_IRQ_AVAIL            (USHORT)(ERR_ADI + 0x009B)
#define ERR_DMA_CONFLICT                (USHORT)(ERR_ADI + 0x009C)
#define ERR_DMA_BUFFER_NOT_AVAIL        (USHORT)(ERR_ADI + 0x009D)
#define ERR_KDI_TO_EXPIRED              (USHORT)(ERR_ADI + 0x00A0)
#define ERR_KDI_CONTROLLER_BUSY         (USHORT)(ERR_ADI + 0x00A1)
#define ERR_KDI_CLAIMED_CONTROLLER      (USHORT)(ERR_ADI + 0x00A2)
#define ERR_KDI_NO_VFBACKUP             (USHORT)(ERR_ADI + 0x00A3)
#define ERR_LAST_KDI_ERROR              (USHORT)(ERR_ADI + 0x00ff)

/* KDI ENTRY POINT DEFINES: *************************************************/

#define KDI_GET_VERSION                 (USHORT)0x0000
#define KDI_OPEN_DRIVER                 (USHORT)0x0101
#define KDI_CLOSE_DRIVER                (USHORT)0x0102
#define KDI_SEND_DRIVER_CMD             (USHORT)0x0103
#define KDI_GET_ASYNC_STATUS            (USHORT)0x0104
#define KDI_DEBUG_OUTPUT                (USHORT)0x0105
#define KDI_COPY_BUFFER                 (USHORT)0x0106

/* Trakker specific entry points */
#define KDI_CHECKXOR                    (USHORT)0x0201
#define KDI_FLUSHFIFOX                  (USHORT)0x0202
#define KDI_POPMASKTRAKKERINT           (USHORT)0x0203
#define KDI_PUSHMASKTRAKKERINT          (USHORT)0x0204
#define KDI_READREG                     (USHORT)0x0205
#define KDI_RECEIVEDATA                 (USHORT)0x0206
#define KDI_SENDDATA                    (USHORT)0x0207
#define KDI_SETFIFOXADDRESS             (USHORT)0x0208
#define KDI_SWITCHTODATA                (USHORT)0x0209
#define KDI_TRAKKERXFER                 (USHORT)0x020A
#define KDI_WRITEREG                    (USHORT)0x020B
#define KDI_FINDIRQ                     (USHORT)0x020C
#define KDI_CREATE_TRAKKER_CONTEXT      (USHORT)0x020D

/*--------------------------------------------------
 * This define is needed until the cbw.2 codebase
 * goes away
 *--------------------------------------------------*/
#define KDI_CONFIG_TRAKKER              KDI_CREATE_TRAKKER_CONTEXT


#define KDI_CONFIGURE_TRAKKER           (USHORT)0x020E
#define KDI_TRISTATE                    (USHORT)0x020F
#define KDI_AGRESSIVE_FINDIRQ           (USHORT)0x0210
#define KDI_LOCATE_JUMPERLESS           (USHORT)0x0211
#define KDI_ACTIVATE_JUMPERLESS         (USHORT)0x0212

/* Miscellaneous functions */
#define KDI_PROGRAM_DMA                 (USHORT)0x0301
#define KDI_HALT_DMA                    (USHORT)0x0302
#define KDI_SHORT_TIMER                 (USHORT)0x0303
#define KDI_GET_DMA_BUFFER              (USHORT)0x0304
#define KDI_FREE_DMA_BUFFER             (USHORT)0x0305
#define KDI_GET_VALID_INTERRUPTS        (USHORT)0x0306

/* KDI DEFINES: *************************************************************/

/* KDI_CLOSE_DRIVER parameter options */
#define KDI_ABORT_CLOSE     (USHORT)0x1
#define KDI_NORMAL_CLOSE    (USHORT)0x2


/*****************************************************************************
*
* FILE: microsol.h
*
* PURPOSE:  This file contains all of the defines necessary to access
*               the microsolutions API's
*
*****************************************************************************/

#ifndef _MICROSOL_H_
#define _MICROSOL_H_

#define msiWord unsigned short
#define msiDWord unsigned long
#define msiByte unsigned char

#pragma warning(disable:4001)  //who says double slash is not nice

typedef struct S_MsiPPC {

// API portion of structure

    msiWord
        flag_word,
        lpt_addr,
        lpt_type,
        fdc_type,
        fdc_loops,
        chip_type,
        chip_mode,
        irq_level,
        max_secs,
        rx_mode,
        tx_mode,
        rx_margin,
        tx_margin,
        tx_to_rx,
        rx_factor,
        tx_factor,
        reserved[64];

} MsiPPC;

typedef struct S_MicroSol {
    MsiPPC      ppc_channel;    /* MicroSolutions IO structure */
    msiWord     lpt_number;     /* (I/O) parallel port number */
    msiWord     open_flags;     /* flags to use on open call */
} MicroSol;

//
// Control Flags
//
#define MSI_NO_EEPROM           0x0001
#define MSI_NO_BIDIR            0x0002
#define MSI_NO_FWRITE           0x0004
#define MSI_NO_IBMPS2           0x0008
#define MSI_NO_EPP              0x0010
#define MSI_NO_IRQ              0x0020
#define MSI_NO_AUTOIRQ          0x0040
#define MSI_IRQ_MODE1           0x0080
#define MSI_IRQ_MODE2           0x0100
#define MSI_IRQ_MODE4           0x0200
#define MSI_NO_TPWIZARD         0x0400

//
// DMA Read and Write codes
//
#define MSI_FDC_2_PC            0x0001
#define MSI_PC_2_FDC            0x0000
#define MSI_MAP_MEM             0x0002
#define MSI_USE_CRC             0x0004      // OBSOLETE Always used on 50772
#define MSI_USE_ECC             0x0008

//
// Fault codes
//
#define MSI_FC_NOT_OPEN     0x0101
#define MSI_FC_NOT_CLOSED   0x0102

#define MSI_FC_CON_FAIL     0x0201

#define MSI_FC_FDC_RQM      0x0301
#define MSI_FC_FDC_DIO      0x0302
#define MSI_FC_FDC_BSY      0x0303

#define MSI_FC_DMA_ACT      0x0401
#define MSI_FC_DMA_ABORT    0x0402
#define MSI_FC_DMA_DIR      0x0403
#define MSI_FC_DMA_SIZE     0x0404
#define MSI_FC_DMA_FLOW     0x0405
#define MSI_FC_DMA_CRC      0x0406
#define MSI_FC_DMA_ECC      0x0407
#define MSI_FC_DMA_ZONE     0x0408
#define MSI_FC_DMA_ILLEGAL  0x0409

#define MSI_FC_NOT_IRQ      0x0501
#define MSI_FC_IRQ_ACT      0x0601
#define MSI_FC_EEP_BAD      0x0701

#define MSI_FC_REP_BIT      0x8001      // Application Fault Codes
#define MSI_FC_WRONG_BIT    0x8002
#define MSI_FC_ERR_STATUS   0x8003
#define MSI_FC_NO_CART      0x8004
#define MSI_FC_NEW_CART     0x8005
#define MSI_FC_ECC_FAIL     0x8006

#define MSI_FC_FDC_ABNORMAL 0x8040
#define MSI_FC_FDC_INVALID  0x8080
#define MSI_FC_FDC_CHANGED  0x80C0

//
// Interrupt type (for fc_par_execute_int)
//
#define MSI_FC_INT_HARDWARE 0       // a result of a hardware interrupt
#define MSI_FC_INT_SOFTWARE 1       // a result of a software poll
#define MSI_FC_INT_FORCE    2       // forced software interrupt
#define MSI_FC_INT_INTERNAL 3       // internally generated interrupt?

//
// Function Prototypes
//

extern msiWord cdecl fc_par_version(void);

extern msiWord cdecl fc_par_open(MsiPPC *,msiWord);
extern msiWord cdecl fc_par_close(void);

extern msiWord cdecl fc_par_rd_fdc(msiByte  *, msiWord);
extern msiWord cdecl fc_par_wr_fdc(msiByte  *, msiWord);

extern msiWord cdecl fc_par_rd_port(msiWord);
extern msiWord cdecl fc_par_wr_port(msiWord, msiByte);

extern msiWord cdecl fc_par_rd_eeprom(msiWord);
extern msiWord cdecl fc_par_wr_eeprom(msiWord, msiWord);

extern msiWord cdecl fc_par_rd_dma(msiByte  *, msiWord, msiDWord);
extern msiWord cdecl fc_par_wr_dma(msiByte  *, msiWord, msiDWord);
extern msiWord cdecl fc_par_chk_dma(msiByte  *, msiWord, msiDWord);

extern msiWord cdecl fc_par_clr_dma(msiWord);
extern msiWord cdecl fc_par_prog_dma(msiWord, msiWord, msiDWord);
extern msiWord cdecl fc_par_term_dma(msiWord, msiWord);

extern msiWord cdecl fc_par_execute_int(msiWord);
extern msiWord cdecl fc_par_handle_int(void (cdecl *)(msiWord));

#ifdef NOT_NOW // As of version 6.02 of the microsolutions API,  the code below is obsolete (EBX saved now)

//
// If this is a 32-bit compiler (not 8086 or 80286) then we need to preserve
// the EBX register on fc_par calls.  The code below will do so.
//
#if !defined(M_I8086) && !defined(M_I286)

#pragma warning(disable:4505)

static __inline msiWord msifix_open(MsiPPC *a,msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_open(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_close(void)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_close();
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_fdc(msiByte  *a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_fdc(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_fdc(msiByte  *a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_fdc(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_port(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_port(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_port(msiWord a, msiByte b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_port(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_eeprom(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_eeprom(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_eeprom(msiWord a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_eeprom(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_chk_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_chk_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_clr_dma(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_clr_dma(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_prog_dma(msiWord a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_prog_dma(a,b,c);
    _asm pop ebx;
    return ret;
    };

static __inline msiWord msifix_term_dma(msiWord a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_term_dma(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_execute_int(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_execute_int(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_handle_int(void (cdecl *a)(msiWord))
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_handle_int(a);
    _asm pop ebx;
    return ret;
    }

// now use inline functions (that preserve ebx) for all calls into
// microsolutions api
#define fc_par_open(a,b)            msifix_open(a,b)
#define fc_par_close                msifix_close
#define fc_par_rd_port(a)           msifix_rd_port(a)
#define fc_par_wr_port(a, b)        msifix_wr_port(a, b)
#define fc_par_rd_eeprom(a)         msifix_rd_eeprom(a)
#define fc_par_wr_eeprom(a, b)  msifix_wr_eeprom(a, b)
#define fc_par_rd_dma(a, b, c)  msifix_rd_dma(a, b, c)
#define fc_par_wr_dma(a, b, c)  msifix_wr_dma(a, b, c)
#define fc_par_chk_dma(a, b, c) msifix_chk_dma(a, b, c)
#define fc_par_clr_dma(a)           msifix_clr_dma(a)
#define fc_par_prog_dma(a, b, c)    msifix_prog_dma(a, b, c)
#define fc_par_term_dma(a, b)       msifix_term_dma(a, b)
#define fc_par_execute_int(a)       msifix_execute_int(a)
#define fc_par_handle_int(a)        msifix_handle_int(a)
#endif // !defined(M_I8086) && !defined(M_I286)
#endif // NOT_NOW
#endif // _MICROSOL_H_

/*****************************************************************************
*
* FILE: FRB_API.H
*
* PURPOSE: This file contains all of the API's necessary to access
*               the common QIC117 device driver and build FRB's.
*
*****************************************************************************/

/* Valid Tape Formats *******************************************************/
/* S_CQDTapeCfg.tape_class */

#define QIC40_FMT               (UCHAR)1    /* QIC-40 formatted tape  */
#define QIC80_FMT               (UCHAR)2    /* QIC-80 formatted tape  */
#define QIC3010_FMT             (UCHAR)3    /* QIC-3010 formatted tape */
#define QIC3020_FMT             (UCHAR)4    /* QIC-3020 formatted tape */
#define QIC80W_FMT              (UCHAR)5    /* QIC-80W formatted tape */
#define QIC3010W_FMT            (UCHAR)6    /* QIC-3010W formatted tape */
#define QIC3020W_FMT            (UCHAR)7    /* QIC-3020W formatted tape */

/* The following parameters are used to indicate the tape format code *******/
/* S_CQDTapeCfg.tape_format_code */

#define QIC_FORMAT                  (UCHAR)2    /* Indicates a standard or extended length tape */
#define QICEST_FORMAT               (UCHAR)3    /* Indicates a 1100 foot tape   */
#define QICFLX_FORMAT               (UCHAR)4    /* Indicates a flexible format tape foot tape */
#define QIC_XLFORMAT            (UCHAR)5    /* Indicates a 425ft tape */

/* Valid Drive Classes ******************************************************/
/* S_DeviceDescriptor.drive_class */
/* S_DeviceInfo.drive_class */

#define UNKNOWN_DRIVE               (UCHAR)1    /* Unknown drive class  */
#define QIC40_DRIVE              (UCHAR)2   /* QIC-40 drive        */
#define QIC80_DRIVE              (UCHAR)3   /* QIC-80 drive        */
#define QIC3010_DRIVE            (UCHAR)4   /* QIC-3010 drive      */
#define QIC3020_DRIVE            (UCHAR)5   /* QIC-3020 drive      */
#define QIC80W_DRIVE             (UCHAR)6   /* QIC-80W drive       */
#define QIC3010W_DRIVE           (UCHAR)7   /* QIC-3010W drive     */
#define QIC3020W_DRIVE           (UCHAR)8   /* QIC-3020W drive     */

/* Valid Tape Types *********************************************************/
/* The defined values match the QIC117-G spec. except for TAPE_205 */
/* S_CQDTapeCfg.tape_type */

#define TAPE_UNKNOWN            (UCHAR)0x00 /* Unknown tape type           */
#define TAPE_205                (UCHAR)0x11     /* 205 foot 550 Oe             */
#define TAPE_425                (UCHAR)0x01     /* 425 foot 550 Oe             */
#define TAPE_307                (UCHAR)0x02     /* 307.5 foot 550 Oe           */
#define TAPE_FLEX_550           (UCHAR)0x03 /* Flexible Format 550 Oe      */
#define TAPE_FLEX_900           (UCHAR)0x06     /* Flexible Format 900 Oe      */
#define TAPE_FLEX_550_WIDE      (UCHAR)0x0B /* Flexible Format 550 Oe Wide */
#define TAPE_FLEX_900_WIDE      (UCHAR)0x0E     /* Flexible Format 900 Oe Wide */

/* Valid Transfer Rates ******************************************************/

#define XFER_250Kbps            (UCHAR)1   /* 250 Kbps transfer rate supported */
#define XFER_500Kbps            (UCHAR)2   /* 500 Kbps transfer rate supported */
#define XFER_1Mbps              (UCHAR)4   /* 1 Mbps transfer rate supported   */
#define XFER_2Mbps              (UCHAR)8   /* 2Mbps transfer rate supported    */

/* Valid Commands for the driver ********************************************/

#define CMD_LOCATE_DEVICE       (USHORT)0x1100
#define CMD_REPORT_DEVICE_CFG   (USHORT)0x1101
#define CMD_SELECT_DEVICE       (USHORT)0x1102
#define CMD_DESELECT_DEVICE     (USHORT)0x1103
#define CMD_LOAD_TAPE           (USHORT)0x1104
#define CMD_UNLOAD_TAPE         (USHORT)0x1105
#define CMD_SET_SPEED           (USHORT)0x1106
#define CMD_REPORT_STATUS       (USHORT)0x1107
#define CMD_SET_TAPE_PARMS      (USHORT)0x1108
#define CMD_READ                (USHORT)0x1109
#define CMD_READ_RAW            (USHORT)0x110A
#define CMD_READ_HEROIC         (USHORT)0x110B
#define CMD_READ_VERIFY         (USHORT)0x110C
#define CMD_WRITE               (USHORT)0x110D
#define CMD_WRITE_DELETED_MARK  (USHORT)0x110E
#define CMD_FORMAT              (USHORT)0x110F
#define CMD_RETENSION           (USHORT)0x1110
#define CMD_ISSUE_DIAGNOSTIC    (USHORT)0x1111
#define CMD_ABORT               (USHORT)0x1112
#define CMD_DELETE_DRIVE        (USHORT)0x1113
#define CMD_REPORT_DEVICE_INFO  (USHORT)0x1114

/* FC20 jumperless sequence size */
/* NOTE: This is a mirror of the SEQUENCE SIZE define in task.h and needs
 * to be in sync with that define */
#define FC20_SEQUENCE_SIZE      (UCHAR)0x10

/* DATA STRUCTURES: *********************************************************/
/* Note:  The following structures are not aligned on DWord boundaries */
#pragma pack(4)

typedef struct S_DeviceCfg {                /* QIC117 device configuration information */
    BOOLEAN speed_change;                   /* device/FDC combination supports dual speeds */
    BOOLEAN alt_retrys;                     /* Enable reduced retries */
    BOOLEAN new_drive;                      /* indicates whether or not drive has been configured */
    UCHAR   select_byte;                    /* FDC select byte */
    UCHAR   deselect_byte;                  /* FDC deselect byte */
    UCHAR   drive_select;                   /* FDC drive select byte */
    UCHAR   perp_mode_select;               /* FDC perpendicular mode select byte */
    UCHAR   supported_rates;                /* Transfer rates supported by the device/FDC combo */
    UCHAR   drive_id;                       /* Tape device id */
} DeviceCfg, *DeviceCfgPtr;

typedef struct S_DeviceDescriptor {     /* Physical characteristics of the tape device */
    USHORT  sector_size;                    /* sector size in bytes */
    USHORT  segment_size;                   /* Number of sectors per segment */
    UCHAR   ecc_blocks;                     /* Number of ECC sectors per segment */
    USHORT  vendor;                         /* Manufacturer of the tape drive */
    UCHAR   model;                          /* Model of the tape drive */
    UCHAR   drive_class;                    /* Class of tape drive. (QIC-40, QIC-80, etc) */
    UCHAR   native_class;                   /* Native class of tape drive (QIC-40, QIC-80, etc) */
    UCHAR   fdc_type;                       /* Floppy disk controller type */
} DeviceDescriptor, *DeviceDescriptorPtr;

typedef struct S_DeviceInfo {       /* Physical information from the tape device */
    UCHAR   drive_class;                    /* Class of tape drive. (QIC-40, QIC-80, etc) */
    USHORT  vendor;                         /* Manufacturer of the tape drive */
    UCHAR   model;                          /* Model of the tape drive */
    USHORT  version;                            /* Firmware Version */
    USHORT  manufacture_date;               /* days since Jan 1, 1992 */
    ULONG   serial_number;                  /* Cnnnnnnn where 'C' is an alpha character */
                                                    /* in the highest byte, and nnnnnnn is a 7 */
                                                    /* digit decimal number in the remaining 3 bytes */
    UCHAR   oem_string[20];             /* OEM the device is destined for */
    UCHAR   country_code[2];                /* Country code chars, "US", "UK", ... */
} DeviceInfo, *DeviceInfoPtr;

typedef struct S_CQDTapeCfg {               /* Physical characteristics of the tape */
    ULONG   log_segments;                   /* number of logical segments on a tape UDWord  formattable_segs */
    ULONG   formattable_segments;       /* the number of formattable segments */
    ULONG   formattable_tracks;         /* the number of formattable tracks */
    ULONG   seg_tape_track;             /* segments per tape track */
    USHORT  num_tape_tracks;                /* number of tape tracks */
    BOOLEAN write_protected;                /* tape is write protected */
    BOOLEAN read_only_media;                /* tape is read only by the current device i.e QIC40 in a QIC80 */
    BOOLEAN formattable_media;          /* tape can be formatted by the current device */
    BOOLEAN speed_change_ok;                /* tape/device combo supports dual speeds */
    UCHAR   tape_class;                     /* Format of tape in drive */
    UCHAR   max_floppy_side;                /* maximum floppy side */
    UCHAR   max_floppy_track;               /* maximum floppy track */
    UCHAR   max_floppy_sector;          /* maximum floppy sector */
    UCHAR   xfer_slow;                      /* slow transfer rate */
    UCHAR   xfer_fast;                      /* fast transfer rate */
    UCHAR   tape_format_code;
    UCHAR   tape_type;                      /* from status bits 4-7, includes wide bit */
} CQDTapeCfg, *CQDTapeCfgPtr;

typedef struct S_RepositionData {       /* reposition counts */
    USHORT  overrun_count;                  /* data overruns/underruns */
    USHORT  reposition_count;               /* tape repositions */
    USHORT  hard_retry_count;               /* tape repositions due to no data errors */
} RepositionData, *RepositionDataPtr;

typedef struct S_OperationStatus {      /* Driver status */
    ULONG   current_segment;                /* current logical segment */
    USHORT  current_track;                  /* current physical track */
    BOOLEAN new_tape;                       /* new cartridge detected */
    BOOLEAN no_tape;                            /* no tape in the deivce */
    BOOLEAN cart_referenced;                /* tape is not referenced */
    BOOLEAN retry_mode;                     /* device is currently retrying an io operation */
    UCHAR   xfer_rate;                      /* Current transfer rate */
} OperationStatus, *OperationStatusPtr;

typedef struct  S_QIC117 {
    USHORT      r_dor;                  /* Tape adapter board digital output register. */
    USHORT      dor;                        /* Floppy disk controller digital output register. */
    UCHAR       drive_id;               /* Physical tape drive id. */
    UCHAR       reserved[3];
} QIC117;

typedef struct S_Trakker {
    USHORT      r_dor;                  /* Tape adapter board digital output register. */
    USHORT      dor;                        /* Floppy disk controller digital output register. */
    ULONG        trakbuf;                    /* pointer to the dymanic trakker buffer */
    ULONG        mem_size;                       /* Number of bytes on the Trakker */
    UCHAR       drive_id;               /* Physical tape drive id. */
    UCHAR    port_mode;                      /* Current mode that the parallel port is operating in communication eith Trakker */
    UCHAR       lpt_type;                       /* 0=none, 1=uni, 2=bidi */
    UCHAR       lpt_number;                     /* 0=none, 1=LPT1, 2=LPT2, 3=LPT3 */
    UCHAR       wake_index;                     /* the wakeup sequence (of 8 possible) used to access the TRAKKER ASIC */
} Trakker;

/* port_mode:   0 - Unidirectional, Full Handshake, 500Kb, Full Delay
 *              1 - Unidirectional, Full Handshake, 500Kb, Optimize Delays
 *              2 - Unidirectional, Full Handshake, 1Mb,   Optimize Delays
 *              3 - Unidirectional, Self Latch,     1Mb,   Optimize Delays
 *              4 - Bidirectional,  Full Handshake, 500Kb, Optimize Delays
 *              5 - Bidirectional,  Full Handshake, 1Mb,   Optimize Delays
 *              6 - Bidirectional,  Self Latch,     1Mb,   Optimize Delays */


/* Duplicated Grizzly Structure */ /* ------------------------- */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ----------------                             --------------- */
/* ----------------                             --------------- */
/* ----------------   This structure is         --------------- */
/* ----------------                             --------------- */
/* ----------------   must be kept in perfect   --------------- */
/* ----------------                             --------------- */
/* ----------------   synce with its evil twin  --------------- */
/* ----------------                             --------------- */
/* ----------------   struct S_GrizzlyDevice    --------------- */
/* ----------------                             --------------- */
/* ----------------   located in                --------------- */
/* ----------------                             --------------- */
/* ----------------   cbw\code\include\task.h   --------------- */
/* ----------------                             --------------- */
/* ----------------                             --------------- */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

typedef struct S_Grizzly {
    UCHAR       drive_id;       /* Physical tape drive id. */
    USHORT      grizzly_ctrl;   /* Grizzly special config control options */
    USHORT      xfer_mode;      /* (I/O) parallel port transfer mode */
    UCHAR       xfer_rate;      /* (I/O) device transfer rate selection */
    SHORT       lpt_type;       /* (O) parallel port type */
    UCHAR       lpt_number;     /* (I/O) parallel port number */
} Grizzly;

/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

typedef union   U_DevSpecific {
    QIC117  q117_dev;           /* Interface specific device parameters for QIC 117 */
    Trakker trakker_dev;        /* Interface specific device parameters for Trakker */
    Grizzly grizzly_dev;
    MicroSol microsol_dev;
} DevSpecific;

typedef struct S_DriveParms {                           /* Hardware parameters for DMA & IRQ enable. */
    DevSpecific dev_parm;                               /* Interface specific device parameters */
    USHORT      drive_handle;                           /* Unique identifier for tape drive. */
    USHORT      base_address;                           /* Controller base address. */
    USHORT      mca_dma_address;                        /* DMA base address on MCA. */
    USHORT      mca_cdma_address;                       /* Compression DMA base address on MCA. */
    BOOLEAN     irq_share;                              /* (TRUE) interrupt sharing enabled. */
    BOOLEAN     io_card;                                    /* (TRUE) IO controller present. */
    BOOLEAN     compress_hard;                          /* (TRUE) hardware compression present. */
    BOOLEAN     micro_channel;                          /* (TRUE) Micro Channel Architecture. */
    BOOLEAN     dual_port_mode;                     /* (TRUE) dual port mode enabled. */
    BOOLEAN     dma_width_mca;                          /* TRUE = 16-bit; FALSE = 8-bit */
    UCHAR       board_type;                             /* Identifies type of controller board */
    UCHAR       clk48mhz;                               /* if true,  then use 48mhz clock if it's an 82078 */
    UCHAR       board_id;                               /* Hard-wired id of board, 0 - 3 */
    UCHAR       irq;                                        /* Hardware interrupt vector. */
    UCHAR       dma;                                        /* Tape drive dma channel. */
    UCHAR       compression_dma;                        /* Compression dma channel. */
    UCHAR       data_dma_16bit;                     /* TRUE-controller is in a 16bit slot */
    UCHAR       extended_irq;                           /* TRUE-IRQ is 10 or 11 */
    UCHAR       setup_reg_shadow;                       /* copy of the setup register used in hio */
    UCHAR       sequence[FC20_SEQUENCE_SIZE];       /* the jumperless sequence used to wake up the FC20 */
} DriveParms, *DriveParmsPtr;

/* JUMBO DRIVER FRB STRUCTURES **********************************************/

typedef struct S_ReportDeviceInfo {             /* Device Information FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    DeviceInfo          device_info;            /* O device information */
} ReportDeviceInfo, *ReportDeviceInfoPtr;

typedef struct S_DriveCfgData {             /* Device Configuration FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    DeviceCfg           device_cfg;             /* I/O device configuration */
    DriveParms          hardware_cfg;           /* I the Hardware I/O Parameters of the drive */
    DeviceDescriptor    device_descriptor;  /* O device description */
    OperationStatus operation_status;       /* O Current status of the device */
} DriveCfgData, *DriveCfgDataPtr;

typedef struct S_DeviceOp {                 /* Generic Device operation FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    OperationStatus operation_status;       /* O Current status of the device */
    ULONG               data;                       /* Command dependent data area */
} DeviceOp, *DeviceOpPtr;

typedef struct S_LoadTape {                 /* New Tape configuration FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    CQDTapeCfg          tape_cfg;               /* O Tape configuration information */
    OperationStatus operation_status;       /* O Current status of the device */
} LoadTape, *LoadTapePtr;

typedef struct S_TapeParms {                    /* Tape length configuration FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    ULONG           segments_per_track;     /* I Segments per tape track */
    CQDTapeCfg      tape_cfg;                   /* O Tape configuration information */
} TapeLength, *TapeLengthPtr;

typedef struct S_DeviceIO {                 /* Device I/O FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    ULONG               starting_sector;        /* I Starting sector for the I/O operation */
    ULONG               number;                 /* I Number of sectors in the I/O operation (including bad) */
    ULONG               bsm;                        /* I Bad sector map for the requested I/O operation */
    ULONG               crc;                        /* O map of sectors that failed CRC check */
    ULONG               retrys;                 /* O map of sectors that had to be retried */
    RepositionData      reposition_data;        /* O reposition counts for the current operation */
    OperationStatus operation_status;       /* O Current status of the device */
} DeviceIO, *DeviceIOPtr;

typedef struct S_FormatRequest {                /* Format request FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    CQDTapeCfg      tape_cfg;                   /* O Tape configuration information */
    USHORT          start_track;                /* I Starting track */
    USHORT          tracks;                     /* I Number of tracks to format */
} FormatRequest, *FormatRequestPtr;

typedef struct S_DComFirm {                 /* Direct firmware communication FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    UCHAR           command_str[32];            /* I Firmware command sequence */
} DComFirm, *DComFirmPtr;

#pragma pack()

/*****************************************************************************
*
* FILE: VENDOR.H
*
* PURPOSE: This file contains all of the defines for each of the vendor
*          numbers and model numbers.  The vendor number data is from the
*          QIC 117 specification.
*
*****************************************************************************/

/* Valid Drive Vendors ******************************************************/
/* The defined values match the QIC117-G spec. */
/* S_DeviceDescriptor.vendor */
/* S_DeviceInfo.vendor */

#define VENDOR_UNASSIGNED       (USHORT)0
#define VENDOR_ALLOY_COMP       (USHORT)1
#define VENDOR_3M               (USHORT)2
#define VENDOR_TANDBERG         (USHORT)3
#define VENDOR_CMS_OLD          (USHORT)4
#define VENDOR_CMS              (USHORT)71
#define VENDOR_ARCHIVE_CONNER   (USHORT)5
#define VENDOR_MOUNTAIN_SUMMIT  (USHORT)6
#define VENDOR_WANGTEK_REXON    (USHORT)7
#define VENDOR_SONY             (USHORT)8
#define VENDOR_CIPHER           (USHORT)9
#define VENDOR_IRWIN            (USHORT)10
#define VENDOR_BRAEMAR          (USHORT)11
#define VENDOR_VERBATIM         (USHORT)12
#define VENDOR_CORE             (USHORT)13
#define VENDOR_EXABYTE          (USHORT)14
#define VENDOR_TEAC             (USHORT)15
#define VENDOR_GIGATEK          (USHORT)16
#define VENDOR_COMBYTE          (USHORT)17
#define VENDOR_PERTEC           (USHORT)18
#define VENDOR_IOMEGA           (USHORT)546
#define VENDOR_CMS_ENHANCEMENTS (USHORT)1021   /* drive_type = CMS Enhancements */
#define VENDOR_UNSUPPORTED      (USHORT)1022   /* drive_type = Unsupported */
#define VENDOR_UNKNOWN          (USHORT)1023   /* drive_type = unknown */

/* Valid Drive Models *******************************************************/
/* S_DeviceDescriptor.model */
/* S_DeviceInfo.model */

#define MODEL_CMS_QIC40           (UCHAR)0x00  /* CMS QIC40 Model # */
#define MODEL_CMS_QIC80           (UCHAR)0x01  /* CMS QIC80 Model # */
#define MODEL_CMS_QIC3010         (UCHAR)0x02  /* CMS QIC3010 Model # */
#define MODEL_CMS_QIC3020         (UCHAR)0x03  /* CMS QIC3020 Model # */
#define MODEL_CMS_QIC80_STINGRAY  (UCHAR)0x04  /* CMS QIC80 STINGRAY Model # */
#define MODEL_CMS_QIC80W          (UCHAR)0x05  /* CMS QIC80W Model # */
#define MODEL_CMS_TR3             (UCHAR)0x06  /* CMS TR3 Model # */
#define MODEL_CONNER_QIC80        (UCHAR)0x0e  /* Conner QIC80 Model # */
#define MODEL_CONNER_QIC80W       (UCHAR)0x10  /* Conner QIC80 Wide Model # */
#define MODEL_CONNER_QIC3010      (UCHAR)0x12  /* Conner QIC3010 Model # */
#define MODEL_CONNER_QIC3020      (UCHAR)0x14  /* Conner QIC3020 Model # */
#define MODEL_CORE_QIC80          (UCHAR)0x21  /* Core QIC80 Model # */
#define MODEL_IOMEGA_QIC80        (UCHAR)0x00  /* Iomega QIC80 Model # */
#define MODEL_IOMEGA_QIC3010      (UCHAR)0x01  /* Iomega QIC3010 Model # */
#define MODEL_IOMEGA_QIC3020      (UCHAR)0x02  /* Iomega QIC3020 Model # */
#define MODEL_SUMMIT_QIC80        (UCHAR)0x01  /* Summit QIC80 Model # */
#define MODEL_SUMMIT_QIC3010      (UCHAR)0x15  /* Summit QIC 3010 Model # */
#define MODEL_WANGTEK_QIC80       (UCHAR)0x0a  /* Wangtek QIC80 Model # */
#define MODEL_WANGTEK_QIC40       (UCHAR)0x02  /* Wangtek QIC40 Model # */
#define MODEL_WANGTEK_QIC3010     (UCHAR)0x0C  /* Wangtek QIC3010 Model # */
#define MODEL_TEAC_TR1            (UCHAR)0x0e
#define MODEL_TEAC_TR2            (UCHAR)0x0f
#define MODEL_PERTEC_TR1          (UCHAR)0x01
#define MODEL_PERTEC_TR2          (UCHAR)0x02
#define MODEL_PERTEC_TR3          (UCHAR)0x03
#define MODEL_UNKNOWN             (UCHAR)0xFF   /* drive_model = unknown */

/*****************************************************************************
*
* FILE: KDIWPRIV.H
*
* PURPOSE: This file contains all of the internal structures and types needed
*          in the KDI.
*
*****************************************************************************/

/* Miscellaneous defines. */
#define NANOSEC_PER_MILLISEC    0x0004f2f0


/* STRUCTURES: **************************************************************/

/* Define the maximum number of controllers and floppies per controller */
/* that this driver will support. */

/* The number of floppies per controller is fixed at 4, since the */
/* controllers don't have enough bits to select more than that (and */
/* actually, many controllers will only support 2).  The number of */
/* controllers per machine is arbitrary; 3 should be more than enough. */

#define MAXIMUM_CONTROLLERS_PER_MACHINE    3

/* MACROS to access the controller.  Note that the *_PORT_UCHAR macros */
/* work on all machines, whether the I/O ports are separate or in */
/* memory space. */

#define READ_CONTROLLER( Address )                         \
    READ_PORT_UCHAR( ( PUCHAR )Address )

#define WRITE_CONTROLLER( Address, Value )                 \
    WRITE_PORT_UCHAR( ( PUCHAR )Address, ( UCHAR )Value )


/* Define the maximum number of tape drives per controller */
/* that this driver will support. */

/* The number of tape drives per controller is fixed at 1, since the */
/* software select schemes generally work for one drive only. */

#define MAXIMUM_TAPE_DRIVES_PER_CONTROLLER 1

/* This structure holds all of the configuration data.  It is filled in */
/* by FlGetConfigurationInformation(), which gets the information from */
/* the configuration manager or the hardware architecture layer (HAL). */

typedef struct s_controllerInfo {
    UCHAR           floppyEnablerApiSupported;
    UCHAR           dmaDirection;
    PDEVICE_OBJECT  apiDeviceObject;
    BOOLEAN         fdcSupported;
    PDEVICE_OBJECT  fdcDeviceObject;
    UNICODE_STRING  fdcUnicodeString;
    WCHAR           idstr[200];
} ControllerInfo;

typedef struct S_KdiContext {
    KEVENT          interrupt_event;
    KEVENT          allocate_adapter_channel_event;
    PKINTERRUPT     interrupt_object;
    PVOID           map_register_base;
    LONG            actual_controller_number;
    PDEVICE_OBJECT  device_object;
    ULONG           base_address;
    PVOID           cqd_context;
    UCHAR           interface_type;
    BOOLEAN         own_floppy_event;
    BOOLEAN         current_interrupt;
    BOOLEAN         interrupt_pending;
    NTSTATUS        interrupt_status;
    BOOLEAN         adapter_locked;
    LIST_ENTRY      list_entry;
    KSEMAPHORE      request_semaphore;
    KSPIN_LOCK      list_spin_lock;
    KEVENT          clear_queue_event;
    BOOLEAN         unloading_driver;
    UCHAR           number_of_tape_drives;
    BOOLEAN         clear_queue;
    BOOLEAN         abort_requested;
    ULONG           error_sequence;
    ULONG           tape_number;
    ControllerInfo  controller_data;
    HANDLE          thread_handle;
} KdiContext, *KdiContextPtr;

typedef struct S_QICDeviceContext {

    PDEVICE_OBJECT      UnderlyingPDO;
    PDEVICE_OBJECT      TargetObject;

    BOOLEAN             DeviceInitialized;
    UNICODE_STRING      InterfaceString;

    PDEVICE_OBJECT  device_object;
    PDEVICE_OBJECT  TapeDeviceObject;
    KdiContextPtr   kdi_context;

    BOOLEAN Paused;
    LIST_ENTRY PauseQueue;
    KSPIN_LOCK PauseQueueSpinLock;

} QICDeviceContext, *QICDeviceContextPtr;


/* PROTOTYPES: **************************************************************/

NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT driver_object_ptr,
    IN PUNICODE_STRING registry_path
    );

NTSTATUS 
kdi_DispatchDeviceControl(
    IN    PDEVICE_OBJECT device_object_ptr,
    IN OUT PIRP irp
    );

BOOLEAN 
kdi_Hardware(
    IN PKINTERRUPT interrupt,
    IN PVOID context
    );

VOID 
kdi_DeferredProcedure(
    IN PKDPC dpc,
    IN PVOID deferred_context,
    IN PVOID system_argument_1,
    IN PVOID system_argument_2
    );

VOID 
kdi_UnloadDriver(
    IN PDRIVER_OBJECT driver_object
    );

VOID 
kdi_ThreadRun(
    IN KdiContextPtr kdi_context
    );

IO_ALLOCATION_ACTION 
kdi_AllocateAdapterChannel(
    IN PDEVICE_OBJECT device_object,
    IN PIRP irp,
    IN PVOID map_register_base,
    IN PVOID context
    );

NTSTATUS 
kdi_ConfigCallBack(
    IN PVOID context,
    IN PUNICODE_STRING path_name,
    IN INTERFACE_TYPE bus_type,
    IN ULONG bus_number,
    IN PKEY_VALUE_FULL_INFORMATION *bus_information,
    IN CONFIGURATION_TYPE controller_type,
    IN ULONG controller_number,
    IN PKEY_VALUE_FULL_INFORMATION *controller_information,
    IN CONFIGURATION_TYPE peripheral_type,
    IN ULONG peripheral_number,
    IN PKEY_VALUE_FULL_INFORMATION *peripheral_information
    );

NTSTATUS 
kdi_InitializeDrive(
    IN KdiContextPtr kdi_context,
    IN PVOID cqd_context,
    IN PDRIVER_OBJECT driver_object_ptr,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#if 0
//
// (fcf) kdi_GetControllerBase() does not appear to be used, so I removed it
//       to get rid of the 64bit-related warnings it was generating.
// 
ULONG 
kdi_GetControllerBase(
    IN INTERFACE_TYPE bus_type,
    IN ULONG bus_number,
    IN PHYSICAL_ADDRESS io_address,
    IN ULONG number_of_bytes,
    IN BOOLEAN in_io_space,
    IN PBOOLEAN mapped_address
    );
#endif

NTSTATUS
kdi_TranslateError(
    IN PDEVICE_OBJECT device_object,
    IN NTSTATUS return_value
    );

NTSTATUS 
kdi_ClearIO(
    IN PIRP irp
    );

NTSTATUS 
q117MapStatus(
    IN NTSTATUS status
    );

VOID
q117LogError(
    PDEVICE_OBJECT device_object,
    ULONG sequence_number,
    UCHAR major_function_code,
    UCHAR retry_count,
    ULONG unique_error_value,
    NTSTATUS final_status,
    NTSTATUS specific_IO_status
);

NTSTATUS kdi_FloppyEnabler(
    PDEVICE_OBJECT device_object,
    int ioctl,
    void *data
);


/*****************************************************************************
*
* FILE: KDI_PUB.H
*
* PURPOSE: Prototypes for the functions required by the common driver.
*
*****************************************************************************/

#if DBG

#define DBG_SEEK_FWD        ((ULONG)0x1234566d)
#define DBG_SEEK_REV        ((ULONG)0x1234566f)
#define DBG_SEEK_OFFSET     ((ULONG)0x12345670)
#define DBG_RW_NORMAL       ((ULONG)0x12345671)
#define DBG_SEEK_PHASE      ((ULONG)0x12345672)
#define DBG_L_SECT          ((ULONG)0x12345673)
#define DBG_C_SEG           ((ULONG)0x12345674)
#define DBG_D_SEG           ((ULONG)0x12345675)
#define DBG_C_TRK           ((ULONG)0x12345676)
#define DBG_D_TRK           ((ULONG)0x12345677)
#define DBG_SEEK_ERR        ((ULONG)0x12345678)
#define DBG_IO_TYPE         ((ULONG)0x12345679)
#define DBG_PGM_FDC         ((ULONG)0x1234567a)
#define DBG_READ_FDC        ((ULONG)0x1234567b)
#define DBG_PGM_DMA         ((ULONG)0x1234567c)
#define DBG_SEND_BYTE       ((ULONG)0x1234567d)
#define DBG_RECEIVE_BYTE    ((ULONG)0x1234567e)
#define DBG_IO_CMD_STAT     ((ULONG)0x1234567f)
#define DBG_TIMER_ACK       ((ULONG)0x12345680)
#define DBG_INT_ACK         ((ULONG)0x12345681)
#define DBG_SLEEP           ((ULONG)0x12345682)
#define DBG_WAKEUP          ((ULONG)0x12345683)
#define DBG_ARMINT          ((ULONG)0x12345684)
#define DBG_STATUS          ((ULONG)0x12345685)
#define DBG_READ_BUF        ((ULONG)0x12345686)
#define DBG_WRITE_BUF       ((ULONG)0x12345687)
#define DBG_CALLBACK        ((ULONG)0x12345688)
#define DBG_WAITCC          ((ULONG)0x12345689)
#define DBG_WAITFAULT       ((ULONG)0x1234568a)
#define DBG_FIFO_FDC        ((ULONG)0x1234568b)

extern ULONG kdi_debug_level;

#define KDI_SET_DEBUG_LEVEL(X)    (kdi_debug_level = X)

#else

#define KDI_SET_DEBUG_LEVEL(X)
#define kdi_CheckedDump(X,Y,Z)

#endif


#define MACHINE_TYPE_MASK  0x0F
#define MICRO_CHANNEL      0x01
#define ISA                0x02
#define EISA               0x03
#define PCMCIA             0x04
#define PCI_BUS            0x05
#define CPU_486            0x10

#define DMA_DIR_UNKNOWN    0xff   /* The DMA direction is not currently known */
#define DMA_WRITE          0   /* Program the DMA to write (FDC->DMA->RAM) */
#define DMA_READ           1   /* Program the DMA to read (RAM->DMA->FDC) */

#define NO_ABORT_PENDING    (UCHAR)0xFF
#define ABORT_LEVEL_0       (UCHAR)0
#define ABORT_LEVEL_1       (UCHAR)1

/* Definitions for the bits in the interrupt status/clear register */
#define INTS_FLOP                   0x01    /* Floppy controller interrupt status */

/* Status & control registers */
#define ASIC_INT_STAT           26  /* Interrupt status / clear register */
#define ASIC_DATA_XOR           27  /* data XOR register */


/* DATA TYPES: **************************************************************/

/* Timing values for kdi_Sleep */

#define kdi_wt10us      (ULONG)10l
#define kdi_wt12us      (ULONG)12l
#define kdi_wt500us     (ULONG)500l
#define kdi_wt0ms       (ULONG)0l
#define kdi_wt001ms     (ULONG)1l
#define kdi_wt002ms     (ULONG)2l
#define kdi_wt003ms     (ULONG)3l
#define kdi_wt004ms     (ULONG)4l
#define kdi_wt005ms     (ULONG)5l
#define kdi_wt010ms     (ULONG)10l
#define kdi_wt025ms     (ULONG)25l
#define kdi_wt031ms     (ULONG)31l
#define kdi_wt090ms     (ULONG)90l
#define kdi_wt100ms     (ULONG)100l
#define kdi_wt200ms     (ULONG)200l
#define kdi_wt265ms     (ULONG)265l
#define kdi_wt390ms     (ULONG)390l
#define kdi_wt500ms     (ULONG)500l
#define kdi_wt001s      (ULONG)1000l
#define kdi_wt003s      (ULONG)3000l
#define kdi_wt004s      (ULONG)4000l
#define kdi_wt005s      (ULONG)5000l
#define kdi_wt007s      (ULONG)7000l
#define kdi_wt010s      (ULONG)10000l
#define kdi_wt016s      (ULONG)16000l
#define kdi_wt035s      (ULONG)35000l
#define kdi_wt045s      (ULONG)45000l
#define kdi_wt050s      (ULONG)50000l
#define kdi_wt055s      (ULONG)55000l
#define kdi_wt060s      (ULONG)60000l
#define kdi_wt065s      (ULONG)65000l
#define kdi_wt085s      (ULONG)85000l
#define kdi_wt090s      (ULONG)90000l
#define kdi_wt100s      (ULONG)100000l
#define kdi_wt105s      (ULONG)105000l
#define kdi_wt125s      (ULONG)125000l
#define kdi_wt130s      (ULONG)130000l
#define kdi_wt150s      (ULONG)150000l
#define kdi_wt180s      (ULONG)180000l
#define kdi_wt200s      (ULONG)200000l
#define kdi_wt228s      (ULONG)228000l
#define kdi_wt250s      (ULONG)250000l
#define kdi_wt260s      (ULONG)260000l
#define kdi_wt300s      (ULONG)300000l
#define kdi_wt350s      (ULONG)350000l
#define kdi_wt455s      (ULONG)455000l
#define kdi_wt460s      (ULONG)460000l
#define kdi_wt475s      (ULONG)475000l
#define kdi_wt650s      (ULONG)650000l
#define kdi_wt670s      (ULONG)670000l
#define kdi_wt700s      (ULONG)700000l
#define kdi_wt910s      (ULONG)910000l
#define kdi_wt1300s     (ULONG)1300000l

/* PROTOTYPES: *** ***********************************************************/

VOID 
kdi_ClaimInterrupt(
    IN PVOID kdi_context
    );

NTSTATUS 
kdi_Error(
    IN USHORT  group_and_type,
    IN ULONG   grp_fct_id,
    IN UCHAR   sequence
    );

VOID 
kdi_FlushDMABuffers(
    IN PVOID kdi_context,
    IN BOOLEAN write_operation,
    IN PVOID phy_data_ptr,
    IN ULONG  bytes_transferred_so_far,
    IN ULONG  total_bytes_of_transfer,
    IN BOOLEAN xfer_error
    );

VOID 
kdi_FlushIOBuffers(
    IN PVOID   physical_addr,
    IN BOOLEAN dma_direction,
    IN BOOLEAN flag
    );

USHORT 
kdi_GetErrorType(
    IN NTSTATUS    status
    );

NTSTATUS 
kdi_GetFloppyController(
    IN PVOID kdi_context
    );

UCHAR 
kdi_GetInterfaceType(
    IN PVOID kdi_context
    );


VOID 
kdi_LockUnlockDMA(
    IN PVOID kdi_context,
    IN BOOLEAN lock
    );


VOID 
kdi_ProgramDMA(
    IN     PVOID kdi_context,
    IN     BOOLEAN write_operation,
    IN     PVOID phy_data_ptr,
    IN     ULONG  bytes_transferred_so_far,
    IN OUT PULONG  total_bytes_of_transfer
    );

BOOLEAN 
kdi_QueueEmpty(
    IN PVOID   kdi_context
    );

UCHAR 
kdi_ReadPort(
    IN PVOID kdi_context,
    IN ULONG   address
    );

VOID 
kdi_ReleaseFloppyController(
    IN PVOID kdi_context
    );

BOOLEAN 
kdi_ReportAbortStatus(
    IN PVOID   kdi_context
    );

VOID 
kdi_ResetInterruptEvent(
    IN PVOID kdi_context
    );

VOID 
kdi_ClearInterruptEvent(
    IN PVOID kdi_context
    );

VOID 
kdi_ShortTimer(
    IN USHORT  time
    );

NTSTATUS 
kdi_Sleep(
    IN PVOID   kdi_context,
    IN ULONG   time
    );

BOOLEAN 
kdi_SetDMADirection(
    IN PVOID   kdi_context,
    IN BOOLEAN dma_direction
    );

NTSTATUS 
kdi_FdcDeviceIo(
    IN     PDEVICE_OBJECT DeviceObject,
    IN     ULONG Ioctl,
    IN OUT PVOID Data
    );

BOOLEAN 
kdi_Trakker(
    IN PVOID   kdi_context
    );

BOOLEAN 
kdi_ParallelDriveSlowRate(
    IN PVOID   kdi_context
    );

NTSTATUS 
kdi_CheckXOR(
    IN USHORT  xor_register
    );

VOID 
kdi_PopMaskTrakkerInt(
    );


UCHAR 
kdi_PushMaskTrakkerInt(
    );


NTSTATUS 
kdi_TrakkerXfer(
    IN PVOID       host_data_ptr,
    IN ULONG       trakker_address,
    IN USHORT      count,
    IN UCHAR       direction,
    IN BOOLEAN     in_format
    );

VOID 
kdi_UpdateRegistryInfo(
    IN PVOID kdi_context,
    IN PVOID device_descriptor,
    IN PVOID device_cfg
    );

VOID 
kdi_WritePort(
    IN PVOID kdi_context,
    IN ULONG   address,
    IN UCHAR   byte
    );

#if DBG
VOID 
kdi_CheckedDump(
    IN ULONG       debug_level,
    IN PCHAR       format_str,
    IN ULONG_PTR    argument
    );
#endif

VOID 
kdi_DumpDebug(
   IN PVOID cqd_context
    );

VOID 
kdi_Nuke(
    IN PVOID io_req,
    IN ULONG index,
    IN BOOLEAN destruct
    );

ULONG 
kdi_Rand(
    );

VOID 
kdi_SetFloppyRegisters(
    IN PVOID kdi_context,
    IN ULONG   r_dor,
    IN ULONG   dor
    );

ULONG 
kdi_GetSystemTime(
    );


VOID 
kdi_QIC117ClearIRQ(
    IN PVOID kdi_context
    );

UCHAR
kdi_GetFDCSpeed(
    IN PVOID kdi_context,
    IN UCHAR dma
    );

BOOLEAN
kdi_Grizzly(
    IN PVOID   kdi_context
    );

BOOLEAN 
kdi_Backpack( // a microsolutions chipset
    IN PVOID   kdi_context
    );

NTSTATUS 
kdi_GrizzlyXfer(
    IN PVOID       host_data_ptr,          /* Address of ADI data buffer */
    IN ULONG       grizzly_address,        /* Address of Grizzly RAM buffer */
    IN USHORT      count,                  /* Number of bytes to be transferred */
    IN UCHAR       direction,              /* SEND_DATA or RECEIVE_DATA */
    IN BOOLEAN     in_format,              /* TRUE if performing format operation */
    IN PVOID       kdi_context             /* Ptr to kdi context */
    );

NTSTATUS 
kdi_CloseGrizzly(
    );

/*****************************************************************************
*
* FILE: CQD_PUB.h
*
* PURPOSE: Public KDI->CQD entry points.
*
*****************************************************************************/

/* CQD Function Templates: ****************************************************/

BOOLEAN 
cqd_CheckFormatMode(
    IN PVOID cqd_context
    );

NTSTATUS 
cqd_ClearInterrupt(
    IN PVOID cqd_context,
    IN BOOLEAN expected_interrupt
    );

VOID 
cqd_ConfigureBaseIO(
    IN PVOID cqd_context,
    IN ULONG base_io
    );

BOOLEAN 
cqd_FormatInterrupt(
    IN PVOID cqd_context
    );

VOID 
cqd_InitializeContext(
    IN PVOID cqd_context,
    IN PVOID kdi_context
    );

NTSTATUS 
cqd_LocateDevice(
    IN PVOID cqd_context,
    IN BOOLEAN *vendor_detected
    );

NTSTATUS 
cqd_ProcessFRB(
    IN     PVOID cqd_context,
    IN OUT PVOID frb
    );

VOID 
cqd_ReportAsynchronousStatus(
    IN     PVOID cqd_context,
    IN OUT PVOID dev_op_ptr
    );

USHORT 
cqd_ReportContextSize(
    );

VOID 
cqd_InitializeCfgInformation(
    IN PVOID cqd_context,
    IN PVOID dev_cfg_ptr
    );

/*****************************************************************************
*
* FILE: CQD_DEFS.H
*
* PURPOSE: This file contains all of the defines required by the common driver.
*
****************************************************************************/

// Drive timeing constants 

#define INTERVAL_CMD            kdi_wt031ms
#define INTERVAL_WAIT_ACTIVE    kdi_wt031ms
#define INTERVAL_TRK_CHANGE     kdi_wt007s
#define INTERVAL_LOAD_POINT     kdi_wt670s
#define INTERVAL_SPEED_CHANGE   kdi_wt010s

// Drive firmware revisions 

#define FIRM_VERSION_38         38    // First jumbo A firmware version 
#define FIRM_VERSION_40         40    // Last jumbo A firmware version 
#define FIRM_VERSION_60         60    // First jumbo B firmware version 
#define FIRM_VERSION_63         63    // Cart in problems 
#define FIRM_VERSION_64         64    // First Firmware version to support Skip_n_Seg through the Erase Gap 
#define FIRM_VERSION_65         65    // First Firmware version to support Pegasus 
#define FIRM_VERSION_80         80    // First Firmware version to support Jumbo c 
#define FIRM_VERSION_87         87    // First Firmware revision to support QIC-117 C 
#define FIRM_VERSION_88         88    // First Firmware revision to support no reverse seek slop 
#define FIRM_VERSION_110        110   // First Firmware version to support Eagle 
#define FIRM_VERSION_112        112   // First Firmware version to support QIC-117 E 
#define FIRM_VERSION_128        128   // First Firmware version to support set n segments in qic 80 
#define PROTOTYPE_BIT           0x80  // 8th bit in the firmware is prototype flag 

// Drive status bit masks 

#define STATUS_READY            (UCHAR)0x01
#define STATUS_ERROR            (UCHAR)0x02
#define STATUS_CART_PRESENT     (UCHAR)0x04
#define STATUS_WRITE_PROTECTED  (UCHAR)0x08
#define STATUS_NEW_CART         (UCHAR)0x10
#define STATUS_CART_REFERENCED  (UCHAR)0x20
#define STATUS_BOT              (UCHAR)0x40
#define STATUS_EOT              (UCHAR)0x80


// Drive config bit masks 

#define CONFIG_QIC80        (UCHAR)0x80
#define CONFIG_XL_TAPE      (UCHAR)0x40
#define CONFIG_SPEED        (UCHAR)0x38
#define CONFIG_250KBS       (UCHAR)0x00
#define CONFIG_500KBS       (UCHAR)0x10
#define CONFIG_1MBS         (UCHAR)0x18
#define CONFIG_2MBS         (UCHAR)0x08
#define XFER_RATE_MASK      (UCHAR)0x18
#define XFER_RATE_SHIFT     (UCHAR)0x03

// CMS proprietary status bit masks 

#define CMS_STATUS_NO_BURST_SEEK    (UCHAR)0x01
#define CMS_STATUS_CMS_MODE         (UCHAR)0x02
#define CMS_STATUS_THRESHOLD_LOAD   (UCHAR)0x04
#define CMS_STATUS_DENSITY          (UCHAR)0x08
#define CMS_STATUS_BURST_ONLY_GAIN  (UCHAR)0x10
#define CMS_STATUS_PEGASUS_CART     (UCHAR)0x20
#define CMS_STATUS_EAGLE            (UCHAR)0x40


#define CMS_STATUS_DRIVE_MASK   (UCHAR)0x48

#define CMS_STATUS_QIC_40   (UCHAR)0x08
#define CMS_STATUS_QIC_80   (UCHAR)0x00


// Tape Types 

#define QIC40_SHORT         (UCHAR)1    // normal length cart (205 ft) 
#define QIC40_LONG          (UCHAR)2    // extended length cart (310 ft) 
#define QICEST_40           (UCHAR)3    // QIC-40 formatted tape (1100 ft) 
#define QIC80_SHORT         (UCHAR)4    // QIC-80 format 205 ft tape 
#define QIC80_LONG          (UCHAR)5    // QIC-80 format 310 ft tape 
#define QICEST_80           (UCHAR)6    // QIC-80 formatted tape (1100 ft) 
#define QIC3010_SHORT       (UCHAR)7    // QIC-3010 formatted tape 
#define QICEST_3010         (UCHAR)8    // QIC-3010 formatted tape (1100 ft) 
#define QICFLX_3010         (UCHAR)9    // QIC-3010 formatted tape (Flexible length) 
#define QIC3020_SHORT       (UCHAR)9    // QIC-3020 formatted tape 
#define QICEST_3020         (UCHAR)10   // QIC-3020 formatted tape (1100 ft) 
#define QICFLX_3020         (UCHAR)11   // QIC-3020 formatted tape (Flexible length) 
#define QIC40_XLONG         (UCHAR)12   // QIC-40 format 425 ft tape 
#define QIC80_XLONG         (UCHAR)13   // QIC-80 format 425 ft tape 
#define QICFLX_80W          (UCHAR)14   // QIC-80W formatted tape (Flexible length) 
#define QIC80_EXLONG        (UCHAR)15   // QIC-80 format 1000 ft tape 
#define QICFLX_3010_WIDE    (UCHAR)16   // QIC-3010 formatted tape (Flexible length) Wide tape 
#define QICFLX_3020_WIDE    (UCHAR)17   // QIC-3020 formatted tape (Flexible length) Wide tape 


// EQU's for QIC-40 firmware commands 

#define FW_CMD_SOFT_RESET               (UCHAR)1    // soft reset of tape drive 
#define FW_CMD_RPT_NEXT_BIT             (UCHAR)2    // report next bit (in report subcontext) 
#define FW_CMD_PAUSE                    (UCHAR)3    // pause tape motion 
#define FW_CMD_MICRO_PAUSE              (UCHAR)4    // pause and microstep the head 
#define FW_CMD_ALT_TIMEOUT              (UCHAR)5    // set alternate command timeout 
#define FW_CMD_REPORT_STATUS            (UCHAR)6    // report drive status 
#define FW_CMD_REPORT_ERROR             (UCHAR)7    // report drive error code 
#define FW_CMD_REPORT_CONFG             (UCHAR)8    // report drive configuration 
#define FW_CMD_REPORT_ROM               (UCHAR)9    // report ROM version 
#define FW_CMD_RPT_SIGNATURE            (UCHAR)9    // report drive signature (model dependant diagnostic mode) 
#define FW_CMD_LOGICAL_FWD              (UCHAR)10   // move tape in logical forward mo 
#define FW_CMD_PHYSICAL_REV             (UCHAR)11   // move tape in physical reverse mode 
#define FW_CMD_PHYSICAL_FWD             (UCHAR)12   // move tape in physical forward mode 
#define FW_CMD_SEEK_TRACK               (UCHAR)13   // seek head to track position 
#define FW_CMD_SEEK_LP                  (UCHAR)14   // seek load poSWord 
#define FW_CMD_FORMAT_MODE              (UCHAR)15   // enter format mode 
#define FW_CMD_WRITE_REF                (UCHAR)16   // write reference burst 
#define FW_CMD_VERIFY_MODE              (UCHAR)17   // enter verify mode 
#define FW_CMD_PARK_HEAD                (UCHAR)17   // park head (model dependant diagnostic mode) 
#define FW_CMD_TOGGLE_PARAMS            (UCHAR)17   // toggle internal modes (model dependant diagnostic mode) 
#define FW_CMD_STOP_TAPE                (UCHAR)18   // stop the tape 
#define FW_CMD_READ_NOISE_CODE          (UCHAR)18   // check noise on drive (model dependent diagnostic mode) 
#define FW_CMD_MICROSTEP_UP             (UCHAR)21   // microstep head up 
#define FW_CMD_DISABLE_WP               (UCHAR)21   // disable write protect line (model dependent diagnostic mode) 
#define FW_CMD_MICROSTEP_DOWN           (UCHAR)22   // microstep head down 
#define FW_CMD_SET_GAIN                 (UCHAR)22   // set absolute drive gain (model dependant diagnostic mode) 
#define FW_CMD_READ_PORT2               (UCHAR)23   // read the drive processor port 2 (diagnostic command) 
#define FW_CMD_REPORT_VENDOR            (UCHAR)24   // report vendor number 
#define FW_CMD_SKIP_N_REV               (UCHAR)25   // skip n segments reverse 
#define FW_CMD_SKIP_N_FWD               (UCHAR)26   // skip n segments forward 
#define FW_CMD_SELECT_SPEED             (UCHAR)27   // select tape speed 
#define FW_CMD_DIAG_1_MODE              (UCHAR)28   // enter diagnostic mode 1 
#define FW_CMD_DIAG_2_MODE              (UCHAR)29   // enter diagnostic mode 2 
#define FW_CMD_PRIMARY_MODE             (UCHAR)30   // enter primary mode 
#define FW_CMD_REPORT_VENDOR32          (UCHAR)32   // report vendor number (for firmware versions > 33) 
#define FW_CMD_REPORT_TAPE_STAT         (UCHAR)33   // reports the tape format of the currently loaded tape 
#define FW_CMD_SKIP_N_REV_EXT           (UCHAR)34   // skip n segments reverse (extended format) 
#define FW_CMD_SKIP_N_FWD_EXT           (UCHAR)35   // skip n segments forward (extended format) 
#define FW_CMD_CAL_TAPE_LENGTH          (UCHAR)36   // Determine the number of seg/trk available on the tape 
#define FW_CMD_REPORT_TAPE_LENGTH       (UCHAR)37   // Report the number of seg/trk available on the tape 
#define FW_CMD_SET_FORMAT_SEGMENTS      (UCHAR)38   // Set the number of segments the drive shall use for generating index pulses 
#define FW_CMD_RPT_CMS_STATUS           (UCHAR)37   // report CMS status byte (model dependant - diagnostic mode) 
#define FW_CMD_SET_RAM_HIGH             (UCHAR)40   // set the high nibble of the ram 
#define FW_CMD_SET_RAM_LOW              (UCHAR)41   // set the low nibble of the ram 
#define FW_CMD_SET_RAM_PTR_HIGH         (UCHAR)42   // set the high nibble of the ram address 
#define FW_CMD_SET_RAM_PTR_LOW          (UCHAR)43   // set the low nibble of the ram address 
#define FW_CMD_READ_RAM                 (UCHAR)44   // read tape drive RAM 
#define FW_CMD_NEW_TAPE                 (UCHAR)45   // load tape sequence 
#define FW_CMD_SELECT_DRIVE             (UCHAR)46   // select the tape drive 
#define FW_CMD_DESELECT_DRIVE           (UCHAR)47   // deselect the tape drive 
#define FW_CMD_REPORTPROTOVER           (UCHAR)50   // reports firmware prototype version number (model dependant - diagnostic mode) 
#define FW_CMD_DTRAIN_INFO              (UCHAR)53   // enter Drive Train Information mode (model dependant - diagnostic mode) 
#define FW_CMD_GDESP_INFO               (UCHAR)5     // display drive train information 
#define FW_CMD_CONNER_SELECT_1          (UCHAR)23   // Mountain select byte 1 
#define FW_CMD_CONNER_SELECT_2          (UCHAR)20   // Mountain select byte 2 
#define FW_CMD_CONNER_DESELECT          (UCHAR)24   // Mountain deselect byte 
#define FW_CMD_RPT_CONNER_NATIVE_MODE   (UCHAR)40   // Conner Native Mode diagnostic command 
#define FW_CMD_CMS_MODE_OLD             (UCHAR)32   // toggle CMS mode (model dependant - diagnostic mode) 

// Floppy Disk Command Bit defines 
#define FIFO_MASK           (UCHAR)0x0f    // Mask for FIFO threshold field in config cmd 
#define FDC_EFIFO           (UCHAR)0x20    // Mask for disabling FIFO in config cmd 
#define FDC_CLK48           (UCHAR)0x80    // Bit of config command that enables 48Mhz clocks on 82078 
#define FDC_PRECOMP_ON      (UCHAR)0x00    // Mask for enabling write precomp 
#define FDC_PRECOMP_OFF     (UCHAR)0x1C    // Mask for disabling write precomp 

// Floppy Disk Controller I/O Ports 

#define FDC_NORM_BASE   (ULONG)0x000003f0     // base for normal floppy controller 
#define DCR_OFFSET      (ULONG)0X00000007     // Digital control register offset 
#define DOR_OFFSET      (ULONG)0X00000002     // Digital-output Register offset 
#define RDOR_OFFSET     (ULONG)0X00000002     // Digital-output Register offset 
#define MSR_OFFSET      (ULONG)0X00000004     // Main Status Register offset 
#define DSR_OFFSET      (ULONG)0X00000004     // Data Rate Select Register offset 
#define TDR_OFFSET      (ULONG)0X00000003     // Tape drive register offset 
#define DR_OFFSET       (ULONG)0X00000005     // Data Register offset 
#define DUAL_PORT_MASK  (ULONG)0x00000080     

// Floppy Disk Port constants 

// normal drive B 
#define curb                1
#define selb                0x2d    // 00101101: motor B + enable DMA/IRQ/FDC + sel B 
#define dselb               0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 
// unselected drive 
#define curu                0
#define selu                0x0d    // 00001101: enable DMA/IRQ/FDC + sel B 
#define dselu               0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 
// normal drive D 
#define curd                3
#define seld                0x8f    // 10001111: motor D + enable DMA/IRQ/FDC + sel D 
#define dseld               0x0e    // 00001110  motor D + enable DMA/IRQ/FDC + sel C 
// laptop unselected drive 
#define curub               0
#define selub               0x2d    // 00101101: motor B + enable DMA/IRQ/FDC + sel B 
#define dselub              0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 

#define alloff              0x08    // no motor + enable DMA/IRQ + disable FDC + sel A 
#define fdc_idle            0x0c    // no motor + enable DMA/IRQ/FDC + sel A 

#define DRIVE_ID_MASK       0x03
#define DRIVE_SELECT_OFFSET 0x05
#define DRIVE_SPECIFICATION 0x8E
#define DRIVE_SPEC          0x08
#define DONE_MARKER         0xC0

// Floppy configuration parameters 

#define FMT_DATA_PATTERN    0x6b    // Format data pattern 
#define FDC_FIFO            15      // FIFO size for an 82077 
#define FDC_HLT             0x02    // FDC head load time 
#define FMT_GPL             233     // gap length for format (QIC-40 QIC-80) 
#define FMT_GPL_3010        241     // gap length for format (QIC-3010) 
#define FMT_GPL_3020        248     // gap length for format (QIC-3020) 
#define WRT_GPL             1       // gap length for write (QIC-40 QIC-80 QIC-3010 QIC-3020) 
#define FMT_BPS             03      // bytes per sector for formatting(1024) 
#define WRT_BPS             FMT_BPS // bytes per sector for reading/writing (1024) 
#define FSC_SEG             32      // floppy sectors per segment (QIC-40 205ft & 310ft) 
#define SEG_FTK             4       // segments per floppy track (QIC-40 205ft & 310ft) 
#define FSC_FTK             (FSC_SEG*SEG_FTK)    // floppy sectors per floppy track (QIC-40 205ft & 310ft) 
#define SEG_TTRK_40         68      // segments per tape track (QIC-40 205ft) 
#define SEG_TTRK_40L        102     // segments per tape track (QIC-40 310ft) 
#define SEG_TTRK_40XL       141     // segments per tape track (QIC-40 425ft) 
#define SEG_TTRK_80         100     // segments per tape track (QIC-80 205ft) 
#define SEG_TTRK_80L        150     // segments per tape track (QIC-80 310ft) 
#define SEG_TTRK_80W        365     // segments per tape track (QIC-80 310ft) 
#define SEG_TTRK_80XL       207     // segments per tape track (QIC-80 425ft) 
#define SEG_TTRK_80EX       490     // segments per tape track (QIC-80 1000ft) 
#define SEG_TTRK_QICEST_40  365     // segments per tape track (QIC-40 QICEST) 
#define SEG_TTRK_QICEST_80  537     // segments per tape track (QIC-80 QICEST) 
#define SEG_TTRK_3010       800     // segments per tape track (QIC-3010 1000ft) 
#define SEG_TTRK_3020       1480    // segments per tape track (QIC-3020 1000ft) 
#define SEG_TTRK_3010_400ft 300     // segments per tape track (QIC-3010 400ft) 
#define SEG_TTRK_3020_400ft 422     // segments per tape track (QIC-3020) 



#define FTK_FSD_40          170     // floppy tracks per floppy side (QIC-40 205ft)     
#define FTK_FSD_40L         255     // floppy tracks per floppy side (QIC-40 310ft)     
#define FTK_FSD_40XL        170     // floppy tracks per floppy side (QIC-40 425ft)     
#define FTK_FSD_80          150     // floppy tracks per floppy side (QIC-80 205ft)     
#define FTK_FSD_80L         150     // floppy tracks per floppy side (QIC-80 310ft)     
#define FTK_FSD_80XL        150     // floppy tracks per floppy side (QIC-80 425ft)     
#define FTK_FSD_QICEST_40   254     // floppy tracks per floppy side (QIC-40 QICEST)    
#define FTK_FSD_QICEST_80   254     // floppy tracks per floppy side (QIC-80 QICEST)    
#define FTK_FSD_FLEX80      255     // floppy tracks per floppy side (QIC-80 Flexible)  
#define FTK_FSD_3010        255     // floppy tracks per floppy side (QIC-3010)         
#define FTK_FSD_3020        255     // floppy tracks per floppy side (QIC-3020)         

#define NUM_TTRK_40         20      // number of tape tracks (QIC-40 205ft & 310ft) 
#define NUM_TTRK_80         28      // number of tape tracks (QIC-40 205ft & 310ft) 
#define NUM_TTRK_80W        36      // 
#define NUM_TTRK_3010       40      // number of tape tracks (QIC-3010) 
#define NUM_TTRK_3020       40      // number of tape tracks (QIC-3020) 
#define NUM_TTRK_3010W      50      // number of tape tracks (QIC-3010 wide) 
#define NUM_TTRK_3020W      50      // number of tape tracks (QIC-3020 wide) 
#define PHY_SECTOR_SIZE     (USHORT)1024    // number of bytes per sector 
#define ECC_SEG             (UCHAR)3        // ecc sectors per segment 
#define MAX_FDC_SEEK        (USHORT)128


// Tape Format Types and lengths/Coercivity 


#define QIC_UNKNOWN         0       // Unknown Tape Format and Length 
#define QIC_40              1       // QIC-40 Tape Format 
#define QIC_80              2       // QIC-80 Tape Format 
#define QIC_3020            3       // QIC-3020 Tape Format 
#define QIC_3010            4       // QIC-3010 Tape Format 

#define QIC_SHORT           1       // Length = 205 & Coercivity = 550 Oe 
                                                // or Length = 425 & Coercivity = 550 Oe 
#define QIC_LONG            2       // Length = 307.5 & Coercivity = 550 Oe 
#define QIC_SHORT_900       3       // Length = 295 & Coercivity = 900 Oe 
#define QICEST              4       // Length = 1100 & Coercivity = 550 Oe 
#define QICEST_900          5       // Length = 1100 & Coercivity = 900 Oe 
#define QIC_FLEXIBLE_550_WIDE  0x0B    // Flexible format tape 550 Oe Wide tape 
#define QIC_FLEXIBLE_900       6       // Flexible format tape 900 Oe 
#define QIC_FLEXIBLE_900_WIDE  0x0E    // Flexible format tape 900 Oe Wide tape 

// Floppy disk controller misc constants 

// 82077 version number 
#define VALID_NEC_FDC           0x90    // version number 
#define NSC_PRIMARY_VERSION     0x70    // National 8477 verion number 
#define NSC_MASK                0xF0    // mask for National version number 
#define FDC_82078_44_MASK       0x40    // mask for 82078 44 pin part id 
#define FDC_DCR_MASK            0x03    // mask for fdc's configuration control register xfer rates 
#define FDC_CONFIG_NULL_BYTE    0x00
#define FDC_CONFIG_PRETRACK     0x00

// main status register 
#define MSR_RQM     0x80    // request for master 
#define MSR_DIO     0x40    // data input/output (0=input, 1=output) 
#define MSR_EXM     0x20    // execution mode 
#define MSR_CB      0x10    // FDC busy 
#define MSR_D3B     0x08    // FDD 3 busy 
#define MSR_D2B     0x04    // FDD 2 busy 
#define MSR_D1B     0x02    // FDD 1 busy 
#define MSR_D0B     0x01    // FDD 0 busy 

// status register 0 
#define ST0_IC      0xC0    // Interrupt code (00=Normal, 01=Abnormal, 10=Illegal cmd, 11=Abnormal) 
#define ST0_SE      0x20    // Seek end 
#define ST0_EC      0x10    // Equipment check 
#define ST0_NR      0x08    // Not Ready 
#define ST0_HD      0x04    // Head Address 
#define ST0_US      0x03    // Unit Select (0-3) 

// status register 1 
#define ST1_EN      0x80    // End of Cylinder 
#define ST1_DE      0x20    // Data Error (CRC error) 
#define ST1_OR      0x10    // Over Run 
#define ST1_ND      0x04    // No Data 
#define ST1_NW      0x02    // Not Writable (write protect error) 
#define ST1_MA      0x01    // Missing Address Mark 

// status register 2 
#define ST2_CM      0x40    // Control Mark (Deleted Data Mark) 
#define ST2_DD      0x20    // Data Error in Data Field 
#define ST2_WC      0x10    // Wrong Cylinder 
#define ST2_SH      0x08    // Scan Equal Hit 
#define ST2_SN      0x04    // Scan Not Satisfied 
#define ST2_BC      0x02    // Bad Cylinder 
#define ST2_MD      0x01    // Missing Address Mark in Data Field 

// status register 3 
#define ST3_FT      0x80    // Fault 
#define ST3_WP      0x40    // Write Protected 
#define ST3_RY      0x20    // Ready 
#define ST3_T0      0x10    // Track 0 
#define ST3_TS      0x08    // Two Side 
#define ST3_HD      0x04    // Head address 
#define ST3_US      0x03    // Unit Select (0-3) 

// Misc. constants 

#define FWD                 0       // seek in the logical forward direction 
#define REV                 1       // seek in the logical reverse direction 
#define STOP_LEN            5       // approximate number of blocks used to stop the tape 
#define SEEK_SLOP           3       // number of blocks to overshoot at high speed in a seek 
#define SEEK_TIMED          0x01    // Perform a timed seek 
#define SEEK_SKIP           0x02    // perform a skip N segemnts seek 
#define SEEK_SKIP_EXTENDED  0x03    // perform an extended skip N segemnts seek 

// number of blocks to overshoot when performing a high speed reverve seek 
#define QIC_REV_OFFSET      3
#define QIC_REV_OFFSET_L    4
#define QICEST_REV_OFFSET   14
#define MAX_SKIP            255     // Max number of segments that a Skip N Segs command can skip 
#define MAX_SEEK_NIBBLES    3       // Maximum number of nibbles in an extended mode seek 

#define TRACK_0             (UCHAR)0
#define TRACK_5             (UCHAR)5
#define TRACK_7             (UCHAR)7
#define TRACK_9             (UCHAR)9
#define TRACK_11            (UCHAR)11
#define TRACK_13            (UCHAR)13
#define TRACK_15            (UCHAR)15
#define TRACK_17            (UCHAR)17
#define TRACK_19            (UCHAR)19
#define TRACK_21            (UCHAR)21
#define TRACK_23            (UCHAR)23
#define TRACK_25            (UCHAR)25
#define TRACK_27            (UCHAR)27
#define ILLEGAL_TRACK       (USHORT)0xffff
#define ODD_TRACK           (USHORT)0x0001
#define EVEN_TRACK          (USHORT)0x0000
#define ALL_BAD             (ULONG)0xffffffff
#define QIC3010_OFFSET      (ULONG)2
#define QIC3020_OFFSET      (ULONG)4

#define NUM_BAD             10      // number of bad READ ID's in row for no_data error 
#define OR_TRYS             10      // number of Over Runs ignored per block (system 50) 

#define PRIMARY_MODE        0       // tape drive is in primary mode 
#define FORMAT_MODE         1       // tape drive is in format mode 
#define VERIFY_MODE         2       // tape drive is in verify mode 
#define DIAGNOSTIC_1_MODE   3       // tape drive is in diagnostic mode 1 
#define DIAGNOSTIC_2_MODE   4       // tape drive is in diagnostic mode 2 

#define READ_BYTE           8       // Number of Bytes to receive from the tape 
#define READ_WORD           16      //  drive during communication. 

#define HD_SELECT           0x01    // High Density Select bit from the PS/2 DCR 


#define TAPE_250Kbps        0       // Program drive for 250 Kbps transfer rate 
#define TAPE_2Mbps          1       // Program drive for 2Mbps transfer rate 
#define TAPE_500Kbps        2       // Program drive for 500 Kbps transfer rate 
#define TAPE_1Mbps          3       // Program drive for 1 Mbps transfer rate 
#define FDC_250Kbps         2       // Program FDC for 250 Kbps transfer rate 
#define FDC_500Kbps         0       // Program FDC for 500 Kbps transfer rate 
#define FDC_1Mbps           3       // Program FDC for 1 Mbps transfer rate 
#define FDC_2Mbps           1       // Program FDC for 2 Mbps transfer rate 
#define SRT_250Kbps         0xff    // FDC step rate for 250 Kbps transfer rate 
#define SRT_500Kbps         0xef    // FDC step rate for 500 Kbps transfer rate 
#define SRT_1Mbps           0xcf    // FDC step ratefor 1 Mbps transfer rate 
#define SRT_2Mbps           0x8f    // FDC step rate for 2 Mbps transfer rate 
#define SPEED_MASK          0x03    // FDC speed mask for lower bits 
#define FDC_2MBPS_TABLE     2       // 2 Mbps data rate table for the 82078 


#define CMS_SIG             0xa5    // drive signature for CMS drives 
#define CMS_VEND_NO_OLD     0x0047  // CMS vendor number old 
#define CMS_VEND_NO_NEW     0x11c0  // CMS vendor number new 
#define CMS_QIC40           0x0000  // CMS QIC40 Model # 
#define CMS_QIC80           0x0001  // CMS QIC80 Model # 
#define CMS_QIC3010         0x0002  // CMS QIC3010 Model # 
#define CMS_QIC3020         0x0003  // CMS QIC3020 Model # 
#define CMS_QIC80_STINGRAY  0x0004  // CMS QIC80 STINGRAY Model # 
#define CMS_QIC80W          0x0005  // CMS QIC80W Model # 
#define CMS_TR3             0x0006  // CMS TR3 Model # 
#define EXABYTE_VEND_NO     0x0380  // Summit vendor number 
#define SUMMIT_VEND_NO      0x0180  // Summit vendor number 
#define IOMEGA_VEND_NO      0x8880  // Iomega vendor number 
#define WANGTEK_VEND_NO     0x01c0  // Wangtek vendor number 
#define TECHMAR_VEND_NO     0x01c0  // Techmar vendor number 
#define CORE_VEND_NO        0x0000  // Core vendor number 
#define CONNER_VEND_NO_OLD  0x0005  // Conner vendor number (old mode) 
#define CONNER_VEND_NO_NEW  0x0140  // Conner vendor number (new mode) 
#define VENDOR_MASK         0xffc0  // Vendor id mask 
#define IOMEGA_QIC80        0x0000  // Iomega QIC80 Model # 
#define IOMEGA_QIC3010      0x0001  // Iomega QIC3010 Model # 
#define IOMEGA_QIC3020      0x0002  // Iomega QIC3020 Model # 
#define SUMMIT_QIC80        0x0001  // Summit QIC80 Model # 
#define SUMMIT_QIC3010      0x0015  // Summit QIC 3010 Model # 
#define WANGTEK_QIC80       0x000a  // Wangtek QIC80 Model # 
#define WANGTEK_QIC40       0x0002  // Wangtek QIC40 Model # 
#define WANGTEK_QIC3010     0x000C  // Wangtek QIC3010 Model # 
#define CORE_QIC80          0x0021  // Core QIC80 Model # 
#define TEAC_VEND_NO        0x03c0  // TEAC vendor number 
#define TEAC_TR1            0x000e  // TEAC TR-1 Model 
#define TEAC_TR2            0x000f  // TEAC TR-2 Model 
#define GIGATEC_VEND_NO     0x0400
#define COMBYTE_VEND_NO     0x0440
#define PERTEC_VEND_NO      0x0480
#define PERTEC_TR1          0x0001  // TR-1 drive 
#define PERTEC_TR2          0x0002  // TR-2 drive 
#define PERTEC_TR3          0x0003  // TR-3 drive 

// Conner Native mode defines 

#define CONNER_500KB_XFER   0x0400  // 500 KB xfer rate 
#define CONNER_1MB_XFER     0x0800  // 1 MB xfer rate 
#define CONNER_20_TRACK     0x0001  // Drive supports 20 tracks 
#define CONNER_28_TRACK     0x000e  // Drive supports 28 tracks 
#define CONNER_40_TRACK     0x0020  // Drive supports 40 tracks 
#define CONNER_MODEL_5580   0x0002  // Conner Model 5580 series (Hornet) 
#define CONNER_MODEL_XKE    0x0004  // Conner 11250 series (1" drives) XKE 
#define CONNER_MODEL_XKEII  0x0008  // Conner 11250 series (1" drives) XKEII 


#define FDC_INVALID_CMD         0x80    // invalid cmd sent to FDC returns this value 
#define RTIMES                  3       // times to retry on a read of a sector (retry mode) 
#define NTIMES                  2       // times to retry on a read of a sector (normaly) 
#define WTIMES                  10      // times to retry on a write of a sector 
#define VTIMES                  0       // times to retry on verify 
#define ANTIMES                 0
#define ARTIMES                 6
#define DRIVE_SPEC_SAVE         2       // sizeof the drive spec save command 
#define INTEL_MASK              0xe0
#define INTEL_44_PIN_VERSION    0x40
#define INTEL_64_PIN_VERSION    0x00

#define FIND_RETRIES        2
#define REPORT_RPT          6       // Number of times to attempt drive communication when 
                                    //  an ESD induced error is suspected. 

//
//   Kurt changed the timeout count for program/read nec from 40 to 20000
//   This was done because the kdi_ShortTimer was removed from these routines
//   Microsoft's floppy driver does NOT use a timer and works,  so
//   this fix is being tested in M8 Windows 95 beta.  If it does not work,
//   then we probably need to change it back (see read/program NEC).

#define FDC_MSR_RETRIES     50  // Number of times to read the FDC Main 

#define DRIVEA              0
#define DRIVEB              1
#define DRIVEC              2
#define DRIVED              3
#define DRIVEU              4
#define DRIVEUB             5

#define DISABLE_PRECOMP     1       // Value used by the 82078's Drive Spec 
                                    // command to disable Precomp 

#define FDC_BOOT_MASK     0x06      // Mask used to isolate the Boot Select 
                                    // Bits in the TDR Register 

#define MAX_SEEK_COUNT_SKIP 10
#define MAX_SEEK_COUNT_TIME 10

#define WRITE_REF_RPT       2

#define _DISK_RESET         0

#define WRITE_PROTECT_MASK  0x20    // bit from byte from port 2 of the jumbo B
                                    // processor that indicates write protect 

// Constants for sense_speed algorithm 
// These ranges are based on 1.5 sec @ 250kb.  The units are 54.95ms (1 IBM PC 
// timer tick (18.2 times a second)) and are +-1 tick from nominal due to time 
// base fluctuation (in FDC and IBM PC TIMER). 
// The threshold for the 750kb transfer rate is < 11 ticks due to the 
// uncertaSWordy of this future transfer rate. 
// If a transfer rate of 750kb is needed code MUST be added to verify that 
// 750kb does exist 

#define sect_cnt            35      // .04285 sec. per sector * 35 = 1.4997 sec. 
#define MIN1000             0
#define MAX1000             11
#define MIN500              12
#define MAX500              15
#define MIN250              26
#define MAX250              29

// Array indices and size for the time_out array. The time out array contains the  * 
// time outs for the QIC-117 commands. 
#define L_SLOW          0
#define L_FAST          1
#define PHYSICAL        2
#define TIME_OUT_SIZE   3

// Constants for the arrays defined in the S_O_DGetInfo structure 
#define OEM_LENGTH              20
#define SERIAL_NUM_LENGTH       4
#define MAN_DATE_LENGTH         2
#define PEGASUS_START_DATE      517
#define PLACE_OF_ORIGIN_LENGTH  2

// Constant for the array dimension used in q117i_HighSpeedSeek 
#define  FOUR_NIBS  4

// Constants for identifing bytes in a word array 
#define LOW_BYTE    0
#define HI_BYTE     1

#define DCOMFIRM_MAX_BYTES          10  // Max number of SBytes in a DComFirm string 
#define FDC_ISR_RESET_THRESHOLD     20

#define SINGLE_BYTE     (UCHAR)0x01     
#define REPORT_BYTE     (UCHAR)0x08     // Number of Bits to receive from the tape  
#define REPORT_WORD     (UCHAR)0x10     // drive during communication.                  
#define DATA_BIT        (USHORT)0x8000  // data bit to or into the receive word 
#define SINGLE_SHIFT    (USHORT)0x0001  // number of bits to shift the receive data when adding a bit 
#define NIBBLE_SHIFT    (USHORT)0x0004  // number of bits to shift the receive data when adding a bit 
#define BYTE_SHIFT      (USHORT)0x0008  // number of bits to shift the receive data when size is byte 
#define NIBBLE_MASK     (USHORT)0x000f
#define BYTE_MASK       (USHORT)0x00ff  // byte mask 
#define SEGMENT_MASK    0x1f


// Various addresses used as arguments in the set ram command for the Sankyo 
// motor fix hack 
#define DOUBLE_HOLE_CNTR_ADDRESS    0x5d
#define HOLE_FLAG_BYTE_ADDRESS      0x48
#define TAPE_ZONE_ADDRESS           0x68

// Miscellaneous defines used in the Sankyo Motor fix hack 
#define REVERSE                 0
#define FORWARD                 1
#define HOLE_INDICATOR_MASK     0X40
#define EOT_ZONE_COUNTER        0x29
#define BOT_ZONE_COUNTER        0x23

#define FDC_TDR_MASK        0x03        // mask for 82077aa tdr test 
#define FDC_REPEAT          0x04        // number of times to loop through the tdr test 
#define CMD_OFFSET          (UCHAR)0x02
#define MAX_FMT_NIBBLES     3
#define MAX_FDC_STATUS      16
#define CLOCK_48            (UCHAR)0x80

// Toggle parameter command arguements 
#define WRITE_EQ                    0
#define AUTO_FILTER_PROG            1
#define AGC_ENABLE                  2
#define DISABLE_FIND_BOT            3
#define WRITE_DATA_DELAY_ENABLE     4
#define REF_HEAD_ON_AUTOLOAD        5
#define DRIVE_CLASS                 6
#define CUE_INDEX_PULSE_SHUTOFF     7
#define CMS_MODE                    8

#define SEG_LENGTH_80W          (ULONG)246  // unit in inches * 10 
#define SEG_LENGTH_3010         (ULONG)165  // unit in inches * 10 
#define SEG_LENGTH_3020         (ULONG)84   // unit in inches * 10 
#define SPEED_SLOW_30n0         (ULONG)226
#define SPEED_FAST_30n0         (ULONG)452
#define SPEED_PHYSICAL_30n0     (ULONG)900
#define SPEED_TOLERANCE         (ULONG)138
#define SPEED_FACTOR            (ULONG)100
#define SPEED_ROUNDING_FACTOR   (ULONG)50


// Perpendicular mode setup values 

#define PERP_OVERWRITE_ON   (UCHAR)0x80
#define PERP_WGATE_ON       (UCHAR)0x01
#define PERP_GAP_ON         (UCHAR)0x02
#define PERP_SELECT_SHIFT   (UCHAR)0x02

// Misc format defines 

#define HDR_1               (USHORT)0
#define HDR_2               (USHORT)1
#define MAX_HDR_BLOCKS      (USHORT)2
#define CQD_DMA_PAGE_SIZE   (ULONG)0x00000800

// Select Format defines, from QIC117 spec, command 27 

#define SELECT_FORMAT_80            (UCHAR)0x09
#define SELECT_FORMAT_80W           (UCHAR)0x0b
#define SELECT_FORMAT_3010          (UCHAR)0x11
#define SELECT_FORMAT_3010W         (UCHAR)0x13
#define SELECT_FORMAT_3020          (UCHAR)0x0d
#define SELECT_FORMAT_3020W         (UCHAR)0x0f
#define SELECT_FORMAT_UNSUPPORTED   (UCHAR)0x00


// Issue Diagnostic defines 
#define DIAG_WAIT_CMD_COMPLETE      (UCHAR)0xff
#define DIAG_WAIT_INTERVAL          (UCHAR)0xfe
#define DIAG_NO_PAUSE_RECEIVE       (UCHAR)0xfd

/****************************************************************************
*
* FILE: CQD_STRC.H
*
* PURPOSE: This file contains all of the structures
*                   required by the common driver.
*
*****************************************************************************/

#pragma pack(1)

typedef struct _TAPE_FORMAT_LENGTH {
    UCHAR format;           // Format of the tape 
    UCHAR length;           // Length of the tape 
} TAPE_FORMAT_LENGTH, *PTAPE_FORMAT_LENGTH;


//                                                                                                          
//   Commands to the Floppy Controller.  FDC commands and the corresponding         
//    driver structures are listed below.                                                   
//                                                                                                          
//         FDC Command                     Command Struct      Response Struct  
//         -----------                     --------------      ---------------  
//         Read Data                       rdv_command         stat                     
//         Read Deleted Data               N/A                 N/A                  
//         Write Data                      rdv_command         stat                     
//         Write Deleted Data              rdv_command         stat                     
//         Read a Track                    N/A                 N/A                  
//         Verify (82077)                  N/A                 N/A                  
//         Version (82077)                 version_cmd         N/A                  
//         Read ID                         read_id_cmd         stat                     
//         Format a Track                  format_cmd          stat                     
//         Scan Equal (765)                N/A                 N/A                  
//         Scan Low or Equal (765)         N/A                 N/A                  
//         Scan High or Equal (765)        N/A                 N/A                  
//         Recalibrate                     N/A                 N/A                  
//         Sense Interrupt Status          sns_SWord_cmd       fdc_result           
//         Specify                         specify_cmd         N/A                  
//         Sense Drive Status              sns_stat_cmd        stat                     
//         Seek                            seek_cmd            N/A                  
//         Configure (82077)               config_cmd          N/A                  
//         Relative Seek (82077)           N/A                 N/A                  
//         Dump Registers (82077)          N/A                 N/A                  
//         Perpendicular Mode (82077)      N/A                 N/A                  
//         Invalid                         invalid_cmd         N/A                  
//                                                                                                          

typedef struct _FDC_CMD_READ_DATA {
    UCHAR   command;            // command UCHAR 
    UCHAR   drive;              // drive specifier 
    UCHAR   C;                  // cylinder number 
    UCHAR   H;                  // head address 
    UCHAR   R;                  // record (sector number) 
    UCHAR   N;                  // number of UCHARs per sector 
    UCHAR   EOT;                // end of track 
    UCHAR   GPL;                // gap length 
    UCHAR   DTL;                // data length 
} FDC_CMD_READ_DATA, *PFDC_CMD_READ_DATA;

typedef struct  _FDC_CMD_READ_ID {   
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_READ_ID, *PFDC_CMD_READ_ID;

typedef struct _FDC_CMD_FORMAT {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
    UCHAR N;                    // number of bytes per sector 
    UCHAR SC;                   // sectors per track (segment) 
    UCHAR GPL;                  // gap length 
    UCHAR D;                    // format filler byte 
} FDC_CMD_FORMAT, *PFDC_CMD_FORMAT;

typedef struct _FDC_CMD_SENSE_INTERRUPT_STATUS {
    UCHAR command;              // command byte 
} FDC_CMD_SENSE_INTERRUPT_STATUS, *PFDC_CMD_SENSE_INTERRUPT_STATUS;

typedef struct _FDC_CMD_VERSION {
    UCHAR command;              // command byte 
} FDC_CMD_VERSION, *PFDC_CMD_VERSION;

typedef struct _FDC_CMD_SPECIFY {
    UCHAR command;              // command byte 
    UCHAR SRT_HUT;              // step rate time (bits 7-4) 
                                // head unload time bits (3-0) 
    UCHAR HLT_ND;               // head load time (bits 7-1) 
                                // non-DMA mode flag (bit 0) 
} FDC_CMD_SPECIFY, *PFDC_CMD_SPECIFY;

typedef struct _FDC_CMD_SENSE_DRIVE_STATUS {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_SENSE_DRIVE_STATUS, *PFDC_CMD_SENSE_DRIVE_STATUS;

typedef struct _FDC_CMD_RECALIBRATE {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_RECALIBRATE, *PFDC_CMD_RECALIBRATE;               
                                
typedef struct _FDC_CMD_SEEK {     
    UCHAR cmd;                  // command byte 
    UCHAR drive;                // drive specifier 
    UCHAR NCN;                  // new cylinder number 
} FDC_CMD_SEEK, *PFDC_CMD_SEEK;

typedef struct _FDC_CMD_CONFIGURE {
    UCHAR cmd;                  // command byte 
    UCHAR czero;                // null byte 
    UCHAR config;               // FDC configuration info  (EIS EFIFO POLL FIFOTHR) 
    UCHAR pretrack;             // Pre-compensation start track number 
} FDC_CMD_CONFIGURE, *PFDC_CMD_CONFIGURE;

typedef struct _FDC_CMD_INVALID {
    UCHAR command;              // command byte 
} FDC_CMD_INVALID, *PFDC_CMD_INVALID;

typedef struct _FDC_STATUS {
    UCHAR ST0;                  // status register 0 
    UCHAR ST1;                  // status register 1 
    UCHAR ST2;                  // status register 2 
    UCHAR C;                    // cylinder number 
    UCHAR H;                    // head address 
    UCHAR R;                    // record (sector number) 
    UCHAR N;                    // number of bytes per sector 
} FDC_STATUS, *PFDC_STATUS;     
                                
typedef struct _FDC_RESULT {    
    UCHAR ST0;                  // status register 0 
    UCHAR PCN;                  // present cylinder number 
} FDC_RESULT, *PFDC_RESULT;

typedef struct _FDC_CMD_PERPENDICULAR_MODE {
    UCHAR command;
    UCHAR perp_setup;
} FDC_CMD_PERPENDICULAR_MODE, *PFDC_CMD_PERPENDICULAR_MODE;

// This command is only valid on the 82078 64 pin Enhanced controller 

typedef struct _FDC_CMD_DRIVE_SPECIFICATION {
    UCHAR command;
    UCHAR drive_spec;
    UCHAR done;
} FDC_CMD_DRIVE_SPECIFICATION, *PFDC_CMD_DRIVE_SPECIFICATION;

typedef struct _FDC_CMD_SAVE {
    UCHAR command;
} FDC_CMD_SAVE, *PFDC_CMD_SAVE;

typedef struct _FDC_SAVE_RESULT {
    UCHAR clk48;
    UCHAR reserved2;
    UCHAR reserved3;
    UCHAR reserved4;
    UCHAR reserved5;
    UCHAR reserved6;
    UCHAR reserved7;
    UCHAR reserved8;
    UCHAR reserved9;
    UCHAR reserved10;
    UCHAR reserved11;
    UCHAR reserved12;
    UCHAR reserved13;
    UCHAR reserved14;
    UCHAR reserved15;
    UCHAR reserved16;
} FDC_SAVE_RESULT, *PFDC_SAVE_RESULT;

//   FDC Sector Header Data used for formatting 

typedef union U_FormatHeader {
    struct {
        UCHAR C;                // cylinder number 
        UCHAR H;                // head address 
        UCHAR R;                // record (sector number) 
        UCHAR N;                // bytes per sector 
    } hdr_struct;
    ULONG hdr_all;
} FormatHeader, *FormatHeaderPtr;

#pragma pack()

//   Tape Drive Parameters 


typedef struct S_DriveParameters {
    UCHAR   seek_mode;                 // seek mode supported by the drive 
    CHAR    mode;                      // drive mode (Primary, Format, Verify) 
    USHORT  conner_native_mode;        // Conner Native Mode Data 
} DriveParameters, *DriveParametersPtr;


//   Tape Parameters 


typedef struct S_FloppyTapeParameters {
    USHORT              fsect_seg;      //  floppy sectors per segment 
    USHORT              seg_ftrack;     //  segments per floppy track 
    USHORT              fsect_ftrack;   //  floppy sectors per floppy track 
    USHORT              rw_gap_length;  //  write gap length 
    USHORT              ftrack_fside;   //  floppy tracks per floppy side 
    ULONG               fsect_fside;    //  floppy sectors per floppy side 
    ULONG               log_sectors;    //  number of logical sectors on a tape 
    ULONG               fsect_ttrack;   //  floppy sectors per tape track 
    UCHAR               tape_rates;     //  supported tape transfer rates 
    UCHAR               tape_type;      //  tape type 
    TAPE_FORMAT_LENGTH  tape_status;
    ULONG               time_out[3];    //  time_out for the QIC-117 commands 
                                        //  time_out[0] = logical_slow, time_out[1] = logical_fast, 
                                        //  time[2] = physical. 
} FloppyTapeParameters, *FloppyTapeParametersPtr;


//   Transfer Rate Parameters 

typedef struct S_TransferRate {
    UCHAR   tape;               // Program tape drive slow (250 or 500 Kbps) 
    UCHAR   fdc;                // Program FDC slow (250 or 500 Kbps) 
    UCHAR   srt;                // FDC step rate for slow xfer rate 
} TransferRate, *TransferRatePtr;

struct S_FormatParameters {
    UCHAR   cylinder;           // floppy cylinder number 
    UCHAR   head;               // floppy head number 
    UCHAR   sector;             // floppy sector number 
    UCHAR   NCN;                // new cylinder number 
    ULONG   *hdr_ptr[2];        // pointer to sector id data for format 
    ULONG   hdr_offset[2];      // offset of header_ptr 
    ULONG   *phy_ptr;           // pointer to physical sector id data for format 
    USHORT  current_hdr;        // current format hdr 
    USHORT  next_hdr;           // next format hdr 
    NTSTATUS retval;             // Format status 
};

typedef struct S_FormatParameters FormatParameters;



// Floppy register structure.  The base address of the controller is 
// passed in by configuration management.  Note that this is the 82077 
// structure, which is a superset of the PD765 structure.  Not all of 
// the registers are used. 

typedef struct S_FDCAddress {
    ULONG   dcr;
    ULONG   dr;
    ULONG   msr;
    ULONG   dsr;
    ULONG   tdr;
    ULONG   dor;
    ULONG   r_dor;
    BOOLEAN dual_port;
} FDCAddress, *FDCAddressPtr;


typedef struct S_FDControllerData {
    FDCAddress      fdc_addr;
    FDC_CMD_FORMAT  fmt_cmd;
    FDC_STATUS      fdc_stat;
    USHORT          isr_reentered;
    BOOLEAN         command_has_result_phase;
    UCHAR           number_of_tape_drives;
    UCHAR           fdc_pcn;
    UCHAR           fifo_byte;
    BOOLEAN         perpendicular_mode;
    BOOLEAN         start_format_mode;
    BOOLEAN         end_format_mode;
} FDControllerData, *FDControllerDataPtr;

typedef struct S_TapeOperationStatus {
    ULONG       bytes_transferred_so_far;
    ULONG       total_bytes_of_transfer;
    ULONG       cur_lst;
    USHORT      data_amount;
    USHORT      s_count;
    USHORT      no_data;
    USHORT      d_amt;
    USHORT      retry_count;
    USHORT      retry_times;
    ULONG       d_segment;        // desired tape segment, (floppy track) 
    USHORT      d_track;          // desired physical tape track 
    UCHAR       d_ftk;
    UCHAR       d_sect;
    UCHAR       d_head;
    UCHAR       retry_sector_id;
    UCHAR       seek_flag;
    UCHAR       s_sect;
    BOOLEAN     log_fwd;          // indicates that the tape is going logical forward 
    BOOLEAN     bot;
    BOOLEAN     eot;
} TapeOperationStatus, *TapeOperationStatusPtr;


typedef struct S_CqdContext {
    DeviceCfg               device_cfg;
    DeviceDescriptor        device_descriptor;
    OperationStatus         operation_status;
    DriveParameters         drive_parms;
    TransferRate            xfer_rate;
    FloppyTapeParameters    floppy_tape_parms;
    CQDTapeCfg              tape_cfg;
    TapeOperationStatus     rd_wr_op;
    FormatParameters        fmt_op;
    FDControllerData        controller_data;
    PVOID                   kdi_context;
    USHORT                  retry_seq_num;
    UCHAR                   firmware_cmd;
    UCHAR                   firmware_error;
    UCHAR                   firmware_version;
    UCHAR                   drive_type;
    UCHAR                   device_unit;
    UCHAR                   drive_on_value;
    UCHAR                   deselect_cmd;
    UCHAR                   drv_stat;
    ULONG                   media_change_count;
    BOOLEAN                 configured;
    BOOLEAN                 selected;
    BOOLEAN                 cmd_selected;
    BOOLEAN                 no_pause;
    BOOLEAN                 cms_mode;
    BOOLEAN                 persistent_new_cart;
    BOOLEAN                 pegasus_supported;
    BOOLEAN                 trakker;
#if DBG
#define DBG_SIZE  (1024*4)
    ULONG                   dbg_command[DBG_SIZE];
    ULONG                   dbg_head;
    ULONG                   dbg_tail;
    BOOLEAN dbg_lockout;
#endif

} CqdContext, *CqdContextPtr;

#if DBG
#define DBG_ADD_ENTRY(dbg_level, dbg_context, data) \
        if (((dbg_level) & kdi_debug_level) != 0 &&  \
        (((kdi_debug_level & QIC117BYPASSLOCKOUT) == 0) || (dbg_context)->dbg_lockout == 0)) {\
            (dbg_context)->dbg_command[(dbg_context)->dbg_tail] = (data); \
            (dbg_context)->dbg_tail = ((dbg_context)->dbg_tail + 1) % DBG_SIZE; \
        }
#else
#define DBG_ADD_ENTRY(dbg_level, dbg_context, data)
#endif

/*****************************************************************************
*
* FILE: CQD_HDRI.H
*
* PURPOSE: This file contains all of the headers for the common driver.
*
*****************************************************************************/

/* CQD Function Templates: **************************************************/

NTSTATUS 
cqd_CmdReportStatus(
    IN CqdContextPtr cqd_context,
    IN DeviceOpPtr dev_op_ptr
    );

NTSTATUS 
cqd_CmdRetension(
    IN CqdContextPtr cqd_context,
    OUT PULONG segments_per_track
    );

NTSTATUS 
cqd_CmdSetSpeed(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_speed
    );

NTSTATUS 
cqd_CmdReportDeviceCfg(
    IN CqdContextPtr cqd_context,
    IN DriveCfgDataPtr drv_cfg
    );

NTSTATUS 
cqd_CmdUnloadTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_DeselectDevice(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_Seek(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_CmdDeselectDevice(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN drive_selected
    );

NTSTATUS 
cqd_GetFDCType(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_ConfigureDevice(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_GetRetryCounts(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_NextTry(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_CmdFormat(
    IN CqdContextPtr cqd_context,
    IN FormatRequestPtr fmt_request
    );  

NTSTATUS 
cqd_GetDeviceInfo(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN report_failed,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_DoReadID(
    IN CqdContextPtr cqd_context,
    IN ULONG read_id_delay,
    IN PFDC_STATUS read_id_status
    );

NTSTATUS 
cqd_GetDeviceError(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetDeviceType(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN vendor_detected
    );

NTSTATUS 
cqd_FormatTrack(
    IN CqdContextPtr cqd_context,
    IN USHORT track
    );

NTSTATUS 
cqd_CmdReportDeviceInfo(
    IN CqdContextPtr cqd_context,
    IN DeviceInfoPtr device_info
    );

NTSTATUS 
cqd_LookForDevice(
    IN CqdContextPtr cqd_context,
    IN UCHAR drive_selector,
    IN BOOLEAN *vendor_detected,
    IN BOOLEAN *found
    );

NTSTATUS 
cqd_ChangeTrack(
    IN CqdContextPtr cqd_context,
    IN USHORT destination_track
    );

NTSTATUS 
cqd_LogicalBOT(
    IN CqdContextPtr cqd_context,
    IN USHORT destination_track
    );

NTSTATUS 
cqd_ConnerPreamble(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN select
    );

NTSTATUS 
cqd_RWTimeout(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT NTSTATUS *drv_status
    );

NTSTATUS 
cqd_HighSpeedSeek(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetStatus(
    IN CqdContextPtr cqd_context,
    OUT PUCHAR status_register_3
    );

NTSTATUS 
cqd_CmdReadWrite(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request
    );

NTSTATUS 
cqd_ReadIDRepeat(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdLoadTape(
    IN CqdContextPtr cqd_context,
    IN LoadTapePtr load_tape_ptr
    );

VOID 
cqd_NextGoodSectors(
    IN CqdContextPtr cqd_context
    );

NTSTATUS
cqd_PauseTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdSelectDevice(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SendPhantomSelect(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_RWNormal(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT NTSTATUS *drv_status
    );

NTSTATUS 
cqd_ReadFDC(
    IN CqdContextPtr cqd_context,
    OUT UCHAR *drv_status,
    OUT USHORT length
    );

NTSTATUS 
cqd_SetDeviceMode(
    IN CqdContextPtr cqd_context,
    IN UCHAR mode
    );

NTSTATUS 
cqd_ProgramFDC(
    IN CqdContextPtr cqd_context,
    IN PUCHAR command,
    IN USHORT length,
    IN BOOLEAN result
    );

NTSTATUS 
cqd_IssueFDCCommand(
    IN CqdContextPtr cqd_context,
    IN PUCHAR FifoIn,
    IN PUCHAR FifoOut,
    IN PVOID  IoHandle,
    IN ULONG  IoOffset,
    IN ULONG  TransferBytes,
    IN ULONG  TimeOut
    );

NTSTATUS 
cqd_ReadWrtProtect(
    IN CqdContextPtr cqd_context,
    OUT PBOOLEAN write_protect
    );

NTSTATUS 
cqd_ReceiveByte(
    IN CqdContextPtr cqd_context,
    IN USHORT receive_length,
    OUT PUSHORT receive_data
    );

NTSTATUS 
cqd_SendByte(
    IN CqdContextPtr cqd_context,
    IN UCHAR command
    );

NTSTATUS 
cqd_DispatchFRB(
    IN     CqdContextPtr cqd_context,
    IN OUT ADIRequestHdrPtr frb
    );

NTSTATUS 
cqd_Report(
    IN     CqdContextPtr cqd_context,
    IN     UCHAR command,
    IN     PUSHORT report_data,
    IN     USHORT report_size,
    IN OUT PBOOLEAN esd_retry
    );

NTSTATUS 
cqd_RetryCode(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT PFDC_STATUS fdc_status,
       OUT PNTSTATUS op_status
    );

NTSTATUS 
cqd_SetBack(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_SenseSpeed(
    IN CqdContextPtr cqd_context,
    IN UCHAR        dma
    );

NTSTATUS 
cqd_WaitSeek(
    IN CqdContextPtr cqd_context,
    IN ULONG seek_delay
    );

NTSTATUS 
cqd_StartTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_StopTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_WaitActive(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_WaitCommandComplete(
    IN CqdContextPtr cqd_context,
    IN ULONG wait_time,
    IN BOOLEAN non_interruptible
    );

NTSTATUS 
cqd_WriteReferenceBurst(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CalcPosition(
    IN CqdContextPtr cqd_context,
    IN ULONG block,
    IN ULONG number
    );

NTSTATUS 
cqd_DCROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR speed
    );

NTSTATUS 
cqd_DSROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR precomp
    );

NTSTATUS 
cqd_TDROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_mode
    );

VOID 
cqd_ResetFDC(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_ClearTapeError(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_CalcFmtSegmentsAndTracks(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetTapeParameters(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track
    );

NTSTATUS 
cqd_ConfigureFDC(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetRamPtr(
    IN CqdContextPtr cqd_context,
    IN UCHAR ram_addr
    );

NTSTATUS 
cqd_CmdIssueDiagnostic(
    IN     CqdContextPtr cqd_context,
    IN OUT PUCHAR command_string
    );

VOID 
cqd_InitDeviceDescriptor(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdSetTapeParms(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track,
    IN TapeLengthPtr tape_length_ptr
    );

NTSTATUS 
cqd_PrepareTape(
    IN CqdContextPtr cqd_context,
    OUT FormatRequestPtr fmt_request
    );

VOID 
cqd_InitializeRate(
    IN CqdContextPtr cqd_context,
    IN UCHAR   tape_xfer_rate
    );

NTSTATUS 
cqd_GetTapeFormatInfo(
    IN CqdContextPtr cqd_context,
    IN FormatRequestPtr fmt_request,
    OUT PULONG segments_per_track
    );

NTSTATUS 
cqd_SetRam(
    IN CqdContextPtr cqd_context,
    IN UCHAR ram_data
    );

NTSTATUS 
cqd_CMSSetupTrack(
    IN CqdContextPtr cqd_context,
    OUT PBOOLEAN new_track
    );

NTSTATUS 
cqd_ReportCMSVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ReportConnerVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ReportSummitVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ToggleParams(
    IN CqdContextPtr cqd_context,
    IN UCHAR parameter
    );


NTSTATUS 
cqd_EnablePerpendicularMode(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN enable_perp_mode
    );

BOOLEAN 
cqd_AtLogicalBOT(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_DoFormat(
   IN CqdContextPtr cqd_context
    );

VOID 
cqd_BuildFormatHdr(
    IN CqdContextPtr cqd_context,
    IN USHORT header
    );

NTSTATUS 
cqd_VerifyMapBad(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request
    );

NTSTATUS 
cqd_CheckMediaCompatibility(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetFWTapeSegments(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track
    );

VOID 
cqd_SetTempFDCRate(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SelectFormat(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_SetXferRates(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetFormatSegments(
    IN CqdContextPtr cqd_context,
    IN ULONG       segments_per_track
    );

NTSTATUS 
cqd_PrepareIomega3010PhysRev(
    IN CqdContextPtr cqd_context
    );

/*++

Copyright (c) 1993 - Colorado Memory Systems, Inc.
All Rights Reserved

Module Name:

   common.h

Abstract:

   Data structures shared by drivers q117 and q117i

Revision History:

--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// QIC117Debug is normally 0.  At compile-time or at run-time, it can be
// set to some bit patter for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//

// Lower level driver defines (do not change)  These mirror kdi_pub.h.

#define QIC117DBGP              0x00000001     // Display error information

#define QIC117WARN              0x00000002     // Displays seek warings (from low level driver)

#define QIC117INFO              0x00000004      // Display extra info (brief)

#define QIC117SHOWTD            0x00000008     // Display KDI tape commands (verbose)

#define QIC117SHOWMCMDS         0x00000010     // does nothing unless QIC117DBGARRAY is on
                                               // shows drive commands,  and FDC information
                                               // This is VERY VERBOSE and will affect system
                                               // performance

#define QIC117SHOWPOLL          0x00000020     // unused

#define QIC117STOP              0x00000080     // only one info message (not very useful)

#define QIC117MAKEBAD           0x00000100     // Creates (simulated) bad sectors to test bad
                                               // sector re-mapping code

#define QIC117SHOWBAD           0x00000200     // unused

#define QIC117DRVSTAT           0x00000400      // Show drive status (verbose)

#define QIC117SHOWINT           0x00000800     // unused

#define QIC117DBGSEEK           0x00001000     // (does nothing unless QIC117DBGARRAY is on)
                                               // Shows drive seek information (verbose)

#define QIC117DBGARRAY          0x00002000     // Shows async messages (does nothing unless
                                               // QIC117DBGSEEK and/or QIC117SHOWMCMDS is set)
                                               // Displays VERBOSE FDC command information if
                                               // QIC117SHOWMCMDS is set.
#define QIC117BYPASSLOCKOUT     0x00004000

// Upper level driver defines (only used in upper level driver)

#define QIC117SHOWAPI           ((ULONG)0x00010000)     // Shows Tape API commands

#define QIC117SHOWAPIPOLL       ((ULONG)0x00020000)     // Shows Tape API commands used in NTBACKUP polling
                                                        // These are not displayed with QIC117SHOWAPI

#define QIC117SHOWKDI           ((ULONG)0x00040000)     // Shows request to KDI (VERBOSE)

#define QIC117SHOWBSM           ((ULONG)0x00080000)     // Display bad sector information (brief)

#define Q117DebugLevel kdi_debug_level

extern unsigned long kdi_debug_level;

#define CheckedDump(LEVEL,STRING) \
            if (kdi_debug_level & LEVEL) { \
               DbgPrint STRING; \
            }
#else
#define CheckedDump(LEVEL,STRING)
#endif


#define BUFFER_SPLIT

typedef unsigned char UBYTE;
typedef unsigned short UWORD;
typedef unsigned short SEGMENT;
typedef unsigned long BLOCK;

#ifndef TRUE
#define TRUE 1
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define MAXLINE 100

//
// The following parameters are used to indicate the tape format code
//


#define MAX_PASSWORD_SIZE   8           // max volume password size
#define QIC_END             0xffea6dff  // 12-31-2097, 23:59:59 in qictime


//
// Tape Constants
//
#define UNIX_MAXBFS     4               // max. data buffers supported in the UNIX kernel

#define MAGIC           0x636d  // "cm"

#define DRIVER_COMMAND USHORT

//
// Prototypes for common functions
//

VOID
q117LogError(
   IN PDEVICE_OBJECT DeviceObject,
   IN ULONG SequenceNumber,
   IN UCHAR MajorFunctionCode,
   IN UCHAR RetryCount,
   IN ULONG UniqueErrorValue,
   IN NTSTATUS FinalStatus,
   IN NTSTATUS SpecificIOStatus
   );

NTSTATUS q117MapStatus(
    IN NTSTATUS Status
    );

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'h71q')
#endif

/*++

Module Name:

    q117.h

Abstract:

    Data structures used only by q117 driver.  Contains QIC-40 structures
    and Context for q117.

Revision History:

--*/

//
//  For NTBACKUP to work,  an early warning is required to allow the
//  application to perform tape linking.  To achive this,  a 5 segment
//  region at the end of the tape is RESERVED to genterate early warning
//  status.  This value is used in q117WriteTape for this purpose.
//
#define SEGMENTS_OF_EARLY_WARNING   5


#define FORMAT_BYTE             0x6b

#define MAX_BAD_BLOCKS          ((1024*27)/sizeof(ULONG))
#define LIST_ENTRY_SIZE         3
#define MAX_BAD_LIST            (((1024*27)/LIST_ENTRY_SIZE) - 1)

#define MAX_TITLE_SIZE          44      // max volume title entry size in far memory array
#define MAX_PASSWORD_SIZE       8       // max volume password size

#define MAX_QIC40_FILENAME      13
#define MAX_HEADER_SIZE         256     // maximum QIC-40 header size
#define DATA_HEADER_SIG_SIZE    4       // data header signature size

#define ECC_BLOCKS_PER_SEGMENT  3       // number of correction sectors ber block
#define BLOCKS_PER_SEGMENT      32      // Number of sectors per block on the tape.
                                        // number of data sectors per block

#define DATA_BLOCKS_PER_SEGMENT (BLOCKS_PER_SEGMENT - ECC_BLOCKS_PER_SEGMENT)

#define BYTES_PER_SECTOR    1024
#define BYTES_PER_SEGMENT   (BYTES_PER_SECTOR*BLOCKS_PER_SEGMENT)

#define TapeHeaderSig       0xaa55aa55l
#define VolumeTableSig      (((ULONG)'L'<<24) + ((ULONG)'B'<<16) + ('T'<<8) + 'V')
#define FileHeaderSig       0x33cc33ccl

#define QIC40_VENDOR_UNIQUE_SIZE        106


#define VENDOR_TYPE_NONE    0
#define VENDOR_TYPE_CMS     1

#define MOUNTAIN_SEMISPECED_SPACE       9

#define VU_SIGNATURE_SIZE           4
#define VU_TAPE_NAME_SIZE           11

#define VU_SEGS_PER_TRACK           68
#define VU_SEGS_PER_TRACK_XL        102
#define VU_80SEGS_PER_TRACK         100
#define VU_80SEGS_PER_TRACK_XL      150

#define VU_MAX_FLOPPY_TRACK         169
#define VU_MAX_FLOPPY_TRACK_XL      254
#define VU_80MAX_FLOPPY_TRACK       149
#define VU_80MAX_FLOPPY_TRACK_XL    149

#define VU_TRACKS_PER_CART          20
#define VU_80TRACKS_PER_CART        28

#define VU_MAX_FLOPPY_SIDE          1
#define VU_80MAX_FLOPPY_SIDE        4
#define VU_80MAX_FLOPPY_SIDE_XL     6

#define VU_MAX_FLOPPY_SECT          128

#define NEW_SPEC_TAPE_NAME_SIZE     44

#define FILE_VENDOR_SPECIFIC        0
#define FILE_UNIX_SPECIFIC          1
#define FILE_DATA_BAD               2

#define OP_MS_DOS           0
#define OP_UNIX             1
#define OP_UNIX_PUBLIC      2
#define OP_OS_2             3
#define OP_WINDOWS_NT       4

// Valid values for compression code
#define COMP_STAC 0x01
#define COMP_VEND 0x3f

//
// The following section specifies QIC-40 data structures.
// These structures are aligned on byte boundaries.
//

typedef struct _SEGMENT_BUFFER {
    PVOID logical;
    PHYSICAL_ADDRESS physical;
} SEGMENT_BUFFER, *PSEGMENT_BUFFER;

typedef struct _IO_REQUEST {
    union {
        ADIRequestHdr adi_hdr;

        /* Device Configuration FRB */
        struct S_DriveCfgData ioDriveCfgData;

        /* Generic Device operation FRB */
        struct S_DeviceOp ioDeviceOp;

        /* New Tape configuration FRB */
        struct S_LoadTape ioLoadTape;

        /* Tape length configuration FRB */
        struct S_TapeParms ioTapeLength;

        /* Device I/O FRB */
        struct S_DeviceIO ioDeviceIO;

        /* Format request FRB */
        struct S_FormatRequest ioFormatRequest;

        /* Direct firmware communication FRB */
        struct S_DComFirm ioDComFirm;

        /* Direct firmware communication FRB */
        struct S_TapeParms ioTapeParms;

        /* device info FRB (CMD_REPORT_DEVICE_INFO) */
        struct S_ReportDeviceInfo ioDeviceInfo;
    } x;

    KEVENT DoneEvent;               // Event that IoCompleteReqeust will set
    IO_STATUS_BLOCK IoStatus;       // Status of request
    PSEGMENT_BUFFER BufferInfo;     // Buffer information
    struct _IO_REQUEST *Next;



} *PIO_REQUEST, IO_REQUEST;

#pragma pack(1)

struct _FAIL_DATE {
    UWORD   Year:7;                     // year +1970 (1970-2097)
    UWORD   Month:4;                        // month (1-12)
    UWORD   Day:5;                      // day (1-31)
};


struct _CMS_VENDOR_UNIQUE {
    UBYTE   type;                           // 0 = none; 1 = CMS
    CHAR    signature[VU_SIGNATURE_SIZE];   // "CMS" , ASCIIZ string
    ULONG   creation_time;                  // QIC40/QIC113 date/time format
    CHAR    tape_name[VU_TAPE_NAME_SIZE];   // space padded name
    CHAR    checksum;                       // checksum of UBYTEs 0 - 19 of this struct
};

struct _CMS_NEW_TAPE_NAME {
    CHAR reserved[MOUNTAIN_SEMISPECED_SPACE];   // leave room for Mountain stuff
    CHAR tape_name[NEW_SPEC_TAPE_NAME_SIZE];    // space padded name
    ULONG creation_time;                        // QIC40/QIC113 date/time format
};

struct _CMS_CORRECT_TAPE_NAME {
    UWORD   unused2;
    UWORD  TrackSeg;                           // Tape segments per tape track
    UBYTE  CartTracks;                         // Tape tracks per cartridge
    UBYTE  MaxFlopSide;                        // Maximum floppy sides
    UBYTE  MaxFlopTrack;                       // Maximum floppy tracks
    UBYTE  MaxFlopSect;                        // Maximum floppy sectors
    CHAR  tape_name[NEW_SPEC_TAPE_NAME_SIZE];  // space padded name
    ULONG creation_time;                       // QIC40/QIC113 date/time format
};

typedef union _QIC40_VENDOR_UNIQUE {
        struct _CMS_VENDOR_UNIQUE cms;
        CHAR vu[QIC40_VENDOR_UNIQUE_SIZE];
        struct _CMS_NEW_TAPE_NAME new_name;
        struct _CMS_CORRECT_TAPE_NAME correct_name;
} QIC40_VENDOR_UNIQUE, *PQIC40_VENDOR_UNIQUE;

typedef struct S_BadList {
    UBYTE ListEntry[LIST_ENTRY_SIZE];
} BAD_LIST, *BAD_LIST_PTR;

typedef union U_BadMap {
    ULONG BadSectors[MAX_BAD_BLOCKS];
    BAD_LIST BadList[MAX_BAD_LIST];
} BAD_MAP, *BAD_MAP_PTR;




// Tape Header (sectors 0-1) and BadSector Array (2-13)
typedef struct _TAPE_HEADER {
    ULONG   Signature;                  // set to 0xaa55aa55l
    UBYTE   FormatCode;                 // set to 0x01
    UBYTE   SubFormatCode;              // Zero for pre-rev L tapes and
                                        //  value + 'A' for rev L and above
    SEGMENT HeaderSegment;              // segment number of header
    SEGMENT DupHeaderSegment;           // segment number of duplicate header
    SEGMENT FirstSegment;               // segment number of Data area
    SEGMENT LastSegment;                // segment number of End of Data area
    ULONG   CurrentFormat;              // time of most recent format
    ULONG   CurrentUpdate;              // time of most recent write to cartridge
    union _QIC40_VENDOR_UNIQUE VendorUnique; // Vendor unique stuff
    UBYTE   ReformatError;              // 0xff if any of remaining data is lost
    UBYTE   unused3;
    ULONG   SegmentsUsed;               // incremented every time a segment is used
    UBYTE   unused4[4];
    ULONG   InitialFormat;              // time of initial format
    UWORD   FormatCount;                // number of times tape has been formatted
    UWORD   FailedSectors;              // the number entries in failed sector log
    CHAR    ManufacturerName[44];       // name of manufacturer that pre-formatted
    CHAR    LotCode[44];                // pre-format lot code
    UBYTE   unused5[22];
    struct S_Failed {
        SEGMENT  Segment;               // number of segment that failed
        struct _FAIL_DATE DateFailed;       // date of failure
    } Failed[(1024+768)/4];             // fill out remaining UBYTEs of sector + next
    BAD_MAP BadMap;
} TAPE_HEADER, *PTAPE_HEADER;

//
// CMS Vendor specific area
//
typedef struct _CMS_VOLUME_VENDOR {
    CHAR Signature[4];          // set to "CMS" (null terminated) if it is our backup
    UWORD FirmwareRevision;     // firmware version
    UWORD SoftwareRevision;     // software version
    CHAR RightsFiles;           // if 0xff = novell rights information present
    UWORD NumFiles;             // number of files in volume
    CHAR OpSysType;             // flavor of operating system at creation
} CMS_VOLUME_VENDOR, PCMS_VOLUME_VENDOR;

//
// QIC-40 Volume table structure
//
typedef struct _VOLUME_TABLE_ENTRY {
    ULONG   Signature;                  // this entry will be "VTBL" if volume exists
    SEGMENT StartSegment;               // starting segment of volume for this cart
    SEGMENT EndingSegment;              // ending segment of volume for this cart
    CHAR    Description[MAX_TITLE_SIZE]; // user description of volume
    ULONG   CreationTime;               // time of creation of the volume
    UWORD   VendorSpecific:1;           // set if remainder of volume entry is vend spec
    UWORD   MultiCartridge:1;           // set if volume spans another tape
    UWORD   NotVerified:1;              // set if volume not verified yet
    UWORD   NoNewName:1;                // set if new file names (redirection) disallowed
    UWORD   StacCompress:1;
    UWORD   reserved:3;
    UWORD   SequenceNumber:8;           // multi-cartridge sequence number
    union {
        CMS_VOLUME_VENDOR cms_QIC40;
        UBYTE reserved[26];             // vendor extension data
    } Vendor;
    CHAR    Password[MAX_PASSWORD_SIZE];// password for volume
    ULONG   DirectorySize;              // number of UBYTEs reserved for directory
    ULONG   DataSize;                   // size of data area (includes other cartridges)
    UWORD   OpSysVersion;               // operating system version
    CHAR    VolumeLabel[16];            // volume label of source drive
    UBYTE   LogicalDevice;              // who knows
    UBYTE   PhysicalDevice;             // who knows
    UWORD   CompressCode:6;             // type of compression, 3Fh = vendor specific
    UWORD   CompressAlwaysZero:1;       // must be 0
    UWORD   CompressSwitch:1;           // compression use flag
    UWORD   reserved1:8;
    UBYTE   reserved2[6];
} VOLUME_TABLE_ENTRY, *PVOLUME_TABLE_ENTRY;

#pragma pack()


//
// The following structure is the context for the q117 driver.  It contains
// all current "state" information for the tape drive.
//
typedef struct _Q117_CONTEXT {

    struct {
        BOOLEAN VerifyOnlyOnFormat;     // Verify only on format.  If TRUE
                                        // Then do NOT perform LOW-LEVEL
                                        // Format

        BOOLEAN DetectOnly;             // If TRUE,  allow only the CMS_DETECT
                                        // ioctl,  and do not allocate memory

        BOOLEAN FormatDisabled;         // If TRUE,  Tape API format will be
                                        // Disabled.

    } Parameters;

    ULONG TapeNumber;                   // Tape number of this context (used
                                        // for DEVICEMAP\tape\Unit {x} and
                                        // device \\.\tape{x}

    BOOLEAN DriverOpened;               // Set if q117Create called (this driver opened)
    BOOLEAN DeviceConfigured;           // Set if CMD_REPORT_DEVICE_CFG performed
    BOOLEAN DeviceSelected;             // Set if CMD_SELECT_DEVICE performed,
                                        // Reset if CMD_DESELECT_DEVICE performed

    struct S_DriveCfgData DriveCfg;


    PVOID PageHandle;

    VOLUME_TABLE_ENTRY ActiveVolume;    // volume currently being saved to (nt volume)
    USHORT ActiveVolumeNumber;          // The sequence number of the current struct VolDir.

    PDEVICE_OBJECT q117iDeviceObject;
    PDEVICE_OBJECT FdcDeviceObject;
    ULONG MaxTransferPages;

    //
    // Error tracking
    //

    ULONG ErrorSequence;
    UCHAR MajorFunction;

    //
    // Queue management globals
    //

    SEGMENT_BUFFER SegmentBuffer[UNIX_MAXBFS];    // Array of segment buffers

    ULONG SegmentBuffersAvailable;

    ULONG QueueTailIndex;               // Index in the IORequest array that indexes the tail.

    ULONG QueueHeadIndex;               // This is the head of the Filer IORequest ring-tail array.

    PIO_REQUEST IoRequest;              // pointer to array of IORequests

    //
    // current buffer information
    //

    struct {

        enum {
            NoOperation,
            BackupInProgress,
            RestoreInProgress
            } Type;

        //
        // Information associated with currently active segment
        //
        PVOID   SegmentPointer;
        USHORT  SegmentBytesRemaining;
        SEGMENT LastSegmentRead;
        SEGMENT CurrentSegment;         // in backup (active segment) in restore (read-ahead segment)
        USHORT  BytesZeroFilled;        // Bytes at end of backup that were zeroed (not part of backup)
        NTSTATUS  SegmentStatus;
        SEGMENT EndOfUsedTape;
        SEGMENT LastSegment;            // Last segment of volume
        ULONG   BytesOnTape;
        BOOLEAN UpdateBadMap;           // if true then update bad sector map
        ULONG   BytesRead;
        ULONG   Position;               // type of last IOCTL_TAPE_SET_POSITION

        } CurrentOperation;

    //
    // current tape information
    //

    struct {
        enum {
            TapeInfoLoaded,
            BadTapeInDrive,
            NeedInfoLoaded
            }   State;

        NTSTATUS BadTapeError;
        SEGMENT LastUsedSegment;
        SEGMENT VolumeSegment;
        ULONG   BadSectors;
        SEGMENT LastSegment;            // Last formatted segment.
        USHORT  MaximumVolumes;         // Maximum volumes entries available
        PTAPE_HEADER TapeHeader;        // Header from tape
        struct _TAPE_GET_MEDIA_PARAMETERS *MediaInfo;
        BAD_MAP_PTR BadMapPtr;
        ULONG BadSectorMapSize;
        USHORT CurBadListIndex;
        USHORT TapeFormatCode;
        enum {
            BadMap3ByteList,
            BadMap8ByteList,
            BadMap4ByteArray,
            BadMapFormatUnknown
            } BadSectorMapFormat;


        } CurrentTape;



    // if this global is set then the tape directory has been loaded
    PIO_REQUEST tapedir;

    char drive_type;                    // QIC40 or QIC80

    //
    // The following pointers are allocated when open is called and
    //  freed at close time.
    //

#ifndef NO_MARKS
#define MAX_MARKS 255
    ULONG CurrentMark;
    struct _MARKENTRIES {
        ULONG TotalMarks;
        ULONG MarksAllocated;       // size of mark entry buffer (in entries not bytes)
        ULONG MaxMarks;
        struct _MARKLIST {
            ULONG Type;
            ULONG Offset;
        } *MarkEntry;
    } MarkArray;
#endif

} Q117_CONTEXT, *PQ117_CONTEXT;


typedef enum _DEQUEUE_TYPE {
    FlushItem,
    WaitForItem
} DEQUEUE_TYPE;

//
// Common need:  convert block into segment
//
#define BLOCK_TO_SEGMENT(block) ((SEGMENT)((block) / BLOCKS_PER_SEGMENT))
#define SEGMENT_TO_BLOCK(segment) ((BLOCK)(segment) * BLOCKS_PER_SEGMENT)


//
// This define is the block size used by position commands
// Note:  It is 512 to be compatible with the Maynstream backup
// that does not do a getmedia parameters
//
#define BLOCK_SIZE  BYTES_PER_SECTOR



#define ERROR_DECODE(val) (val >> 16)

#define ERR_BAD_TAPE                0x0101  /* BadTape */
#define ERR_BAD_SIGNATURE           0x0102  /* Unformat */
#define ERR_UNKNOWN_FORMAT_CODE     0x0103  /* UnknownFmt */
#define ERR_CORRECTION_FAILED       0x0104  /* error recovery failed */
#define ERR_PROGRAM_FAILURE         0x0105  /* coding error */
#define ERR_WRITE_PROTECTED         0x0106
#define ERR_TAPE_NOT_FORMATED       0x0107
#define ERR_UNRECOGNIZED_FORMAT     0x0108 /* badfmt */
#define ERR_END_OF_VOLUME           0x0109 /*EndOfVol */
#define ERR_UNUSABLE_TAPE           0x010a /* badtape - could not format */
#define ERR_SPLIT_REQUESTS          0x010b /* SplitRequests */
#define ERR_EARLY_WARNING           0x010c
#define ERR_SET_MARK                0x010d
#define ERR_FILE_MARK               0x010e
#define ERR_LONG_FILE_MARK          0x010f
#define ERR_SHORT_FILE_MARK         0x0110
#define ERR_NO_VOLUMES              0x0111
#define ERR_NO_MEMORY               0x0112
#define ERR_ECC_FAILED              0x0113
//#define ERR_END_OF_TAPE             0x0114
//#define ERR_TAPE_FULL               0x0115
#define ERR_WRITE_FAILURE           0x0116
#define ERR_BAD_BLOCK_DETECTED      0x0117
#define ERR_OP_PENDING_COMPLETION   0x0118
#define ERR_INVALID_REQUEST         0x0119

/*++

Module Name:

   protos.h

Abstract:

   Prototypes for internal functions of the High-Level portion (data
   formatter) of the QIC-117 device driver.

Revision History:


--*/

NTSTATUS
q117Format(
   OUT LONG *NumberBad,
   IN UCHAR DoFormat,
   IN PQIC40_VENDOR_UNIQUE VendorUnique,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReqIO(
   IN PIO_REQUEST IoRequest,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PIO_COMPLETION_ROUTINE CompletionRoutine,
   IN PVOID CompletionContext,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117WaitIO(
   IN PIO_REQUEST IoRequest,
   IN BOOLEAN Wait,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117DoIO(
   IN PIO_REQUEST IoRequest,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AbortIo(
   IN PQ117_CONTEXT Context,
   IN PKEVENT DoneEvent,
   IN PIO_STATUS_BLOCK IoStatus
   );

NTSTATUS
q117AbortIoDone(
   IN PQ117_CONTEXT Context,
   IN PKEVENT DoneEvent
   );

NTSTATUS
q117DoCmd(
   IN OUT PIO_REQUEST IoRequest,
   IN DRIVER_COMMAND Command,
   IN PVOID Data,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117EndRest(
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117MapBadBlock (
   IN PIO_REQUEST IoRequest,
   OUT PVOID *DataPointer,
   IN OUT USHORT *BytesLeft,
   IN OUT SEGMENT *CurrentSegment,
   IN OUT USHORT *Remainder,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117NewTrkRC(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelectVol(
   IN PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117UpdateHeader(
   IN PTAPE_HEADER Header,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117Update(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117DoUpdateBad(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117DoUpdateMarks(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117GetMarks(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117FillTapeBlocks(
   IN OUT DRIVER_COMMAND Command,
   IN SEGMENT CurrentSegment,
   IN SEGMENT EndSegment,
   IN OUT PVOID Buffer,
   IN SEGMENT FirstGood,
   IN SEGMENT SecondGood,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PQ117_CONTEXT Context
   );
NTSTATUS
q117IssIOReq(
   IN OUT PVOID Data,
   IN DRIVER_COMMAND Command,
   IN LONG Block,
   IN OUT PSEGMENT_BUFFER BufferInfo,
   IN OUT PQ117_CONTEXT Context
   );

BOOLEAN
q117QueueFull(
   IN PQ117_CONTEXT Context
   );

BOOLEAN
q117QueueEmpty(
   IN PQ117_CONTEXT Context
   );

PVOID
q117GetFreeBuffer(
   OUT PSEGMENT_BUFFER *BufferInfo,
   IN PQ117_CONTEXT Context
   );

PVOID
q117GetLastBuffer(
   IN PQ117_CONTEXT Context
   );

PIO_REQUEST
q117Dequeue(
   IN DEQUEUE_TYPE Type,
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117ClearQueue(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117QueueSingle(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117QueueNormal(
   IN OUT PQ117_CONTEXT Context
   );

PIO_REQUEST
q117GetCurReq(
   IN PQ117_CONTEXT Context
   );

ULONG
q117GetQueueIndex(
   IN PQ117_CONTEXT Context
   );

VOID
q117SetQueueIndex(
   IN ULONG Index,
   OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117LoadTape (
   IN OUT PTAPE_HEADER*HeaderPointer,
   IN OUT PQ117_CONTEXT Context,
   IN PUCHAR driver_format_code
   );

NTSTATUS
q117InitFiler (
   IN OUT PQ117_CONTEXT Context
   );

void
q117GetBadSectors (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadHeaderSegment (
   OUT PTAPE_HEADER*HeaderPointer,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117WriteTape(
   IN OUT PVOID FromWhere,
   IN OUT ULONG HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EndBack(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadVolumeEntry(
   PVOLUME_TABLE_ENTRY VolumeEntry,
   PQ117_CONTEXT Context
   );

VOID
q117FakeDataSize(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AppVolTD(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelectTD(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117Start (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117Stop (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117OpenForWrite (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EndWriteOperation (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117OpenForRead (
    IN ULONG StartPosition,
    IN OUT PQ117_CONTEXT Context,
    IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117EndReadOperation (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117StartBack(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117StartAppend(
   IN OUT ULONG BytesAlreadyThere,
   IN PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117StartComm(
   OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelVol (
   PVOLUME_TABLE_ENTRY TheVolumeTable,
   PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadTape (
   OUT PVOID ToWhere,
   IN OUT ULONG *HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ConvertStatus(
   IN PDEVICE_OBJECT DeviceObject,
   IN NTSTATUS status
   );

VOID
q117SetTpSt(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117GetEndBlock (
   OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   OUT LONG *NumberVolumes,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117BuildHeader(
   OUT PQIC40_VENDOR_UNIQUE VendorUnique,
   IN SEGMENT *HeaderSect,
   IN OUT PTAPE_HEADER Header,
   IN CQDTapeCfg *tparms,      // tape parameters from the driver
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117IoCtlGetMediaParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetMediaTypesEx (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117IoCtlSetMediaParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetDeviceNumber (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetDriveParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlSetDriveParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlWriteMarks (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlSetPosition (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117FindMark(
   ULONG Type,
   LONG Number,
   PQ117_CONTEXT Context,
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117SeekToOffset(
   ULONG Offset,
   PQ117_CONTEXT Context,
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117IoCtlErase (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlPrepare (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetStatus (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetPosition (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117CheckNewTape (
   PQ117_CONTEXT             Context
   );

NTSTATUS
q117NewTrkBk(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117GetTapeCapacity(
   struct S_O_DGetCap *ptr,
   PQ117_CONTEXT Context
   );

VOID
q117RdsInitReed (
   VOID
   );

UCHAR
q117RdsMultiplyTuples (
   IN UCHAR tup1,
   IN UCHAR tup2
   );

UCHAR
q117RdsDivideTuples (
   IN UCHAR tup1,
   IN UCHAR tup2
   );

UCHAR
q117RdsExpTuple (
   IN UCHAR tup1,
   IN UCHAR xpnt
   );

VOID
q117RdsMakeCRC (
   IN OUT UCHAR *Array,      // pointer to 32K data area (segment)
   IN UCHAR Count            // number of sectors (1K blocks)(1-32)
   );

BOOLEAN
q117RdsReadCheck (
   IN UCHAR *Array,         // pointer to 32K data area (segment)
   IN UCHAR Count           // number of sectors (1K blocks)(1-32)
   );

BOOLEAN
q117RdsCorrect(
   IN OUT UCHAR *Array,    // pointer to 32K data area (segment)
   IN UCHAR Count,         // number of good sectors in segment (4-32)
   IN UCHAR CRCErrors,     // number of crc errors
   IN UCHAR e1,
   IN UCHAR e2,
   IN UCHAR e3             // sectors where errors occurred
   );

VOID
q117RdsGetSyndromes (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR *ps1,
   IN UCHAR *ps2,
   IN UCHAR *ps3
   );

BOOLEAN
q117RdsCorrectFailure (
   IN OUT UCHAR *Array,     // pointer to 32K data area (segment)
   IN UCHAR Count,          // number of good sectors in segment (4-32)
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectOneError (
   IN OUT UCHAR *Array,      // pointer to 32K data area (segment)
   IN UCHAR Count,           // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectTwoErrors (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR ErrorLocation2,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectThreeErrors (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR ErrorLocation2,
   IN UCHAR ErrorLocation3,
   IN UCHAR s1,
   IN UCHAR s2,
   UCHAR s3
   );

BOOLEAN
q117RdsCorrectOneErrorAndOneFailure (
   IN OUT UCHAR *Array,        // pointer to 32K data area (segment)
   IN UCHAR Count,             // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

void
q117SpacePadString(
   IN OUT CHAR *InputString,
   IN LONG StrSize
   );

NTSTATUS
q117VerifyFormat(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EraseQ(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EraseS(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117ClearVolume (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SkipBlock (
   IN OUT ULONG *HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReconstructSegment(
   IN PIO_REQUEST IoReq,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117DoCorrect(
   IN PVOID DataBuffer,
   IN ULONG BadSectorMap,
   IN ULONG SectorsInError
   );

UCHAR
q117CountBits(
    IN PQ117_CONTEXT Context,
    IN SEGMENT Segment,
    ULONG Map
    );

ULONG q117ReadBadSectorList (
    IN PQ117_CONTEXT Context,
    IN SEGMENT Segment
    );

USHORT
q117GoodDataBytes(
   IN SEGMENT Segment,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AllocatePermanentMemory(
   PQ117_CONTEXT Context,
   PDEVICE_OBJECT FdcDeviceObject
   );

NTSTATUS
q117GetTemporaryMemory(
   PQ117_CONTEXT Context
   );

VOID
q117FreeTemporaryMemory(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117IoCtlReadAbs (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlWriteAbs (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlDetect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117UpdateBadMap(
    IN OUT PQ117_CONTEXT Context,
    IN SEGMENT Segment,
    IN ULONG BadSectors
    );

int
q117BadMapToBadList(
    IN SEGMENT Segment,
    IN ULONG BadSectors,
    IN BAD_LIST_PTR BadListPtr
    );

ULONG
q117BadListEntryToSector(
    IN UCHAR *ListEntry,
    OUT BOOLEAN *hiBitSet
    );

NTSTATUS
q117AllocateBuffers (
    PQ117_CONTEXT Context
    );

NTSTATUS
q117Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
q117Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Create (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Close (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
q117CreateKey(
    IN HANDLE Root,
    IN PSTR key,
    OUT PHANDLE NewKey
    );

NTSTATUS
q117CreateRegistryInfo(
    IN ULONG TapeNumber,
    IN PUNICODE_STRING RegistryPath,
    IN PQ117_CONTEXT Context
    );

cms_IoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DoRewind(
    PQ117_CONTEXT       Context
    );

NTSTATUS q117MakeMarkArrayBigger(
    PQ117_CONTEXT       Context,
    int MinimumToAdd
    );

int
q117SelectBSMLocation(
    IN OUT PQ117_CONTEXT Context
    );

NTSTATUS kdi_WriteRegString(
    HANDLE          unit_key,
    PSTR            name,
    PSTR            value
    );

NTSTATUS kdi_FdcDeviceIo(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEQICH,q117Initialize)
#pragma alloc_text(PAGEQICH,q117CreateRegistryInfo)
#pragma alloc_text(PAGEQICH,q117CreateKey)
#pragma alloc_text(PAGEQICH,q117AllocatePermanentMemory)
#endif

#ifndef NOCODELOCK

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGEQICH, q117Create)
//#pragma alloc_text(PAGEQICH, q117Close)
#pragma alloc_text(PAGEQICH, cms_IoCtl)
#pragma alloc_text(PAGEQICH, q117Read)
#pragma alloc_text(PAGEQICH, q117Write)
#pragma alloc_text(PAGEQICH, q117DeviceControl)
#pragma alloc_text(PAGEQICH, q117DoRewind)
#pragma alloc_text(PAGEQICH, q117AbortIo)
#pragma alloc_text(PAGEQICH, q117AbortIoDone)
#pragma alloc_text(PAGEQICH, q117AllocateBuffers )
#pragma alloc_text(PAGEQICH, q117AppVolTD)
#pragma alloc_text(PAGEQICH, q117BadListEntryToSector)
#pragma alloc_text(PAGEQICH, q117BadMapToBadList)
#pragma alloc_text(PAGEQICH, q117BuildHeader)
#pragma alloc_text(PAGEQICH, q117CheckNewTape )
#pragma alloc_text(PAGEQICH, q117ClearQueue)
#pragma alloc_text(PAGEQICH, q117ClearVolume )
#pragma alloc_text(PAGEQICH, q117ConvertStatus)
#pragma alloc_text(PAGEQICH, q117CountBits)
#pragma alloc_text(PAGEQICH, q117Dequeue)
#pragma alloc_text(PAGEQICH, q117DoCmd)
#pragma alloc_text(PAGEQICH, q117DoCorrect)
#pragma alloc_text(PAGEQICH, q117DoIO)
#pragma alloc_text(PAGEQICH, q117DoUpdateBad)
#pragma alloc_text(PAGEQICH, q117DoUpdateMarks)
#pragma alloc_text(PAGEQICH, q117EndBack)
#pragma alloc_text(PAGEQICH, q117EndReadOperation )
#pragma alloc_text(PAGEQICH, q117EndRest)
#pragma alloc_text(PAGEQICH, q117EndWriteOperation )
#pragma alloc_text(PAGEQICH, q117EraseQ)
#pragma alloc_text(PAGEQICH, q117EraseS)
#pragma alloc_text(PAGEQICH, q117FakeDataSize)
#pragma alloc_text(PAGEQICH, q117FillTapeBlocks)
#pragma alloc_text(PAGEQICH, q117FindMark)
#pragma alloc_text(PAGEQICH, q117Format)
#pragma alloc_text(PAGEQICH, q117FreeTemporaryMemory)
#pragma alloc_text(PAGEQICH, q117GetBadSectors )
#pragma alloc_text(PAGEQICH, q117GetCurReq)
#pragma alloc_text(PAGEQICH, q117GetEndBlock )
#pragma alloc_text(PAGEQICH, q117GetFreeBuffer)
#pragma alloc_text(PAGEQICH, q117GetLastBuffer)
#pragma alloc_text(PAGEQICH, q117GetMarks)
#pragma alloc_text(PAGEQICH, q117GetQueueIndex)
#pragma alloc_text(PAGEQICH, q117GetTapeCapacity)
#pragma alloc_text(PAGEQICH, q117GetTemporaryMemory)
#pragma alloc_text(PAGEQICH, q117GoodDataBytes)
#pragma alloc_text(PAGEQICH, q117InitFiler )
#pragma alloc_text(PAGEQICH, q117IoCtlErase )
#pragma alloc_text(PAGEQICH, q117IoCtlGetDeviceNumber )
#pragma alloc_text(PAGEQICH, q117IoCtlGetDriveParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlGetMediaParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlGetPosition )
#pragma alloc_text(PAGEQICH, q117IoCtlGetStatus )
#pragma alloc_text(PAGEQICH, q117IoCtlPrepare )
#pragma alloc_text(PAGEQICH, q117IoCtlReadAbs )
#pragma alloc_text(PAGEQICH, q117IoCtlSetDriveParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlSetMediaParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlSetPosition )
#pragma alloc_text(PAGEQICH, q117IoCtlWriteAbs )
#pragma alloc_text(PAGEQICH, q117IoCtlWriteMarks )
#pragma alloc_text(PAGEQICH, q117IssIOReq)
#pragma alloc_text(PAGEQICH, q117LoadTape )
#pragma alloc_text(PAGEQICH, q117MapBadBlock )
#pragma alloc_text(PAGEQICH, q117NewTrkBk)
#pragma alloc_text(PAGEQICH, q117NewTrkRC)
#pragma alloc_text(PAGEQICH, q117OpenForRead )
#pragma alloc_text(PAGEQICH, q117OpenForWrite )
#pragma alloc_text(PAGEQICH, q117QueueEmpty)
#pragma alloc_text(PAGEQICH, q117QueueFull)
#pragma alloc_text(PAGEQICH, q117QueueNormal)
#pragma alloc_text(PAGEQICH, q117QueueSingle)
#pragma alloc_text(PAGEQICH, q117RdsCorrect)
#pragma alloc_text(PAGEQICH, q117RdsCorrectFailure )
#pragma alloc_text(PAGEQICH, q117RdsCorrectOneError )
#pragma alloc_text(PAGEQICH, q117RdsCorrectOneErrorAndOneFailure )
#pragma alloc_text(PAGEQICH, q117RdsCorrectThreeErrors )
#pragma alloc_text(PAGEQICH, q117RdsCorrectTwoErrors )
#pragma alloc_text(PAGEQICH, q117RdsDivideTuples )
#pragma alloc_text(PAGEQICH, q117RdsExpTuple )
#pragma alloc_text(PAGEQICH, q117RdsGetSyndromes )
#pragma alloc_text(PAGEQICH, q117RdsInitReed )
#pragma alloc_text(PAGEQICH, q117RdsMakeCRC )
#pragma alloc_text(PAGEQICH, q117RdsMultiplyTuples )
#pragma alloc_text(PAGEQICH, q117RdsReadCheck )
#pragma alloc_text(PAGEQICH, q117ReadBadSectorList )
#pragma alloc_text(PAGEQICH, q117ReadHeaderSegment )
#pragma alloc_text(PAGEQICH, q117ReadTape )
#pragma alloc_text(PAGEQICH, q117ReadVolumeEntry)
#pragma alloc_text(PAGEQICH, q117ReconstructSegment)
#pragma alloc_text(PAGEQICH, q117ReqIO)
#pragma alloc_text(PAGEQICH, q117SeekToOffset)
#pragma alloc_text(PAGEQICH, q117SelectTD)
#pragma alloc_text(PAGEQICH, q117SelectVol)
#pragma alloc_text(PAGEQICH, q117SelVol )
#pragma alloc_text(PAGEQICH, q117SetQueueIndex)
#pragma alloc_text(PAGEQICH, q117SetTpSt)
#pragma alloc_text(PAGEQICH, q117SkipBlock )
#pragma alloc_text(PAGEQICH, q117SpacePadString)
#pragma alloc_text(PAGEQICH, q117Start )
#pragma alloc_text(PAGEQICH, q117StartAppend)
#pragma alloc_text(PAGEQICH, q117StartBack)
#pragma alloc_text(PAGEQICH, q117StartComm)
#pragma alloc_text(PAGEQICH, q117Stop )
#pragma alloc_text(PAGEQICH, q117Update)
#pragma alloc_text(PAGEQICH, q117UpdateBadMap)
#pragma alloc_text(PAGEQICH, q117UpdateHeader)
#pragma alloc_text(PAGEQICH, q117VerifyFormat)
#pragma alloc_text(PAGEQICH, q117WaitIO)
#pragma alloc_text(PAGEQICH, q117WriteTape)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\fdc\q117_dat.h ===
/*****************************************************************************
*
* COPYRIGHT 1993 - COLORADO MEMORY SYSTEMS, INC.
* COPYRIGHT 1996, 1997 - COLORADO SOFTWARE ARCHITECTS, INC.
* ALL RIGHTS RESERVED.
*
******************************************************************************
*
* PURPOSE: This file contains all of the API's necessary to access
*               the ADI interface.
*
* HISTORY:
*       $Log: /ddk/src/nt50/storage/fdc/qic117/q117_dat.h $
 * 
 * 3     11/15/97 3:06p John Moore
 * Added NTMS support.
 * 
 * 2     11/10/97 9:28a John Moore
 * Update PnP.
 * 
 * 1     11/01/97 11:30a John Moore
*
*****************************************************************************/

#include "ntddk.h"                     /* various NT definitions */
#include "ntdddisk.h"                  /* disk device driver I/O control codes */

NTSTATUS
q117Initialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT q117iDeviceObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
q117Unload(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
q117Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Create (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Close (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

/* QIC117 device specific ioctls. *********************************************/

#define IOCTL_QIC117_BASE                 FILE_DEVICE_TAPE

#define IOCTL_QIC117_DRIVE_REQUEST        CTL_CODE(IOCTL_QIC117_BASE, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_QIC117_CLEAR_QUEUE          CTL_CODE(IOCTL_QIC117_BASE, 0x0002, METHOD_NEITHER, FILE_ANY_ACCESS)

/* ADI PUBLIC DATA STRUCTURES ***********************************************/

#pragma pack(4)

struct S_ADIRequestHdr {

    NTSTATUS    status;             /* O: Status returned from device */
    VOID        (*callback_ptr)(dUDWord, dUDWord, dUWord, dStatus);
    ULONG       callback_host_id;   /* I: (Optional) Add'l routing info for host */
    PVOID       cmd_buffer_ptr;     /* I: Logical buffer pointer passed to ADI */
    PVOID       drv_physical_ptr;   /* X: KDI physical pointer - internal use */
    PVOID       drv_logical_ptr;    /* X: Common driver logical pointer - internal use */
    USHORT      driver_cmd;         /* I: Device driver specific command */
    USHORT      drive_handle;       /* I: Host generated device identifier */
    BOOLEAN     blocking_call;      /* I: TRUE implies block until completion */
};
typedef struct S_ADIRequestHdr ADIRequestHdr, *ADIRequestHdrPtr;

#pragma pack()

/* ERROR CODES: *************************************************************/

#define GROUPID_CQD             (UCHAR)0x11    /* GG = 11, CQD Common QIC117 Device Driver */
#define GROUPID_CSD             (UCHAR)0x12    /* GG = 12, CSD Common SCSI Device Driver */
#define GROUPID_ADI             (UCHAR)0x15    /* GG = 15, Application Driver Interface */

#define ERR_NO_ERR              (NTSTATUS)0
#define ERR_SHIFT               (UCHAR)8

#define ERR_SEQ_1               (UCHAR)0x01
#define ERR_SEQ_2               (UCHAR)0x02
#define ERR_SEQ_3               (UCHAR)0x03
#define ERR_SEQ_4               (UCHAR)0x04
#define ERR_SEQ_5               (UCHAR)0x05
#define ERR_SEQ_6               (UCHAR)0x06

/* ERROR ENCODE MACRO: **************************************************/

#define ERROR_ENCODE(m_error, m_fct, m_seq) \
     (((m_fct & 0x00000fff) << 4) | m_seq) | ((unsigned long)m_error << 16)

/* RAW FIRMWARE ERROR CODES: *************** Hex **** Decimal ***********/

#define FW_NO_COMMAND               (UCHAR)0x0000      /* 0    */
#define FW_NO_ERROR                 (UCHAR)0x0000      /* 0    */
#define FW_DRIVE_NOT_READY          (UCHAR)0x0001      /* 1    */
#define FW_CART_NOT_IN              (UCHAR)0x0002      /* 2    */
#define FW_MOTOR_SPEED_ERROR        (UCHAR)0x0003      /* 3    */
#define FW_STALL_ERROR              (UCHAR)0x0004      /* 4    */
#define FW_WRITE_PROTECTED          (UCHAR)0x0005      /* 5    */
#define FW_UNDEFINED_COMMAND        (UCHAR)0x0006      /* 6    */
#define FW_ILLEGAL_TRACK            (UCHAR)0x0007      /* 7    */
#define FW_ILLEGAL_CMD              (UCHAR)0x0008      /* 8    */
#define FW_ILLEGAL_ENTRY            (UCHAR)0x0009      /* 9    */
#define FW_BROKEN_TAPE              (UCHAR)0x000a      /* 10   */
#define FW_GAIN_ERROR               (UCHAR)0x000b      /* 11   */
#define FW_CMD_WHILE_ERROR          (UCHAR)0x000c      /* 12   */
#define FW_CMD_WHILE_NEW_CART       (UCHAR)0x000d      /* 13   */
#define FW_CMD_UNDEF_IN_PRIME       (UCHAR)0x000e      /* 14   */
#define FW_CMD_UNDEF_IN_FMT         (UCHAR)0x000f      /* 15   */
#define FW_CMD_UNDEF_IN_VERIFY      (UCHAR)0x0010      /* 16   */
#define FW_FWD_NOT_BOT_IN_FMT       (UCHAR)0x0011      /* 17   */
#define FW_EOT_BEFORE_ALL_SEGS      (UCHAR)0x0012      /* 18   */
#define FW_CART_NOT_REFERENCED      (UCHAR)0x0013      /* 19   */
#define FW_SELF_DIAGS_FAILED        (UCHAR)0x0014      /* 20   */
#define FW_EEPROM_NOT_INIT          (UCHAR)0x0015      /* 21   */
#define FW_EEPROM_CORRUPTED         (UCHAR)0x0016      /* 22   */
#define FW_TAPE_MOTION_TIMEOUT      (UCHAR)0x0017      /* 23   */
#define FW_DATA_SEG_TOO_LONG        (UCHAR)0x0018      /* 24   */
#define FW_CMD_OVERRUN              (UCHAR)0x0019      /* 25   */
#define FW_PWR_ON_RESET             (UCHAR)0x001a      /* 26   */
#define FW_SOFTWARE_RESET           (UCHAR)0x001b      /* 27   */
#define FW_DIAG_MODE_1_ERROR        (UCHAR)0x001c      /* 28   */
#define FW_DIAG_MODE_2_ERROR        (UCHAR)0x001d      /* 29   */
#define FW_CMD_REC_DURING_CMD       (UCHAR)0x001e      /* 30   */
#define FW_SPEED_NOT_AVAILABLE      (UCHAR)0x001f      /* 31   */
#define FW_ILLEGAL_CMD_HIGH_SPEED   (UCHAR)0x0020      /* 32   */
#define FW_ILLEGAL_SEEK_SEGMENT     (UCHAR)0x0021      /* 33   */
#define FW_INVALID_MEDIA            (UCHAR)0x0022      /* 34   */
#define FW_HEADREF_FAIL_ERROR       (UCHAR)0x0023      /* 35   */
#define FW_EDGE_SEEK_ERROR          (UCHAR)0x0024      /* 36   */
#define FW_MISSING_TRAINING_TABLE   (UCHAR)0x0025      /* 37   */
#define FW_INVALID_FORMAT           (UCHAR)0x0026      /* 38   */
#define FW_SENSOR_ERROR             (UCHAR)0x0027      /* 39   */
#define FW_TABLE_CHECKSUM_ERROR     (UCHAR)0x0028      /* 40   */
#define FW_WATCHDOG_RESET           (UCHAR)0x0029      /* 41   */
#define FW_ILLEGAL_ENTRY_FMT_MODE   (UCHAR)0x002a      /* 42   */
#define FW_ROM_CHECKSUM_FAILURE     (UCHAR)0x002b      /* 43   */
#define FW_ILLEGAL_ERROR_NUMBER     (UCHAR)0x002c      /* 44   */
#define FW_NO_DRIVE                 (UCHAR)0x00ff    /*255 */


/* DRIVER FIRMWARE ERROR CODES: ******* Range: 0x1100 - 0x112a & 0x11ff *****/

#define ERR_CQD                         (USHORT)(GROUPID_CQD<<ERR_SHIFT)

#define ERR_FW_NO_COMMAND               (USHORT)(ERR_CQD + FW_NO_COMMAND)
#define ERR_FW_NO_ERROR                 (USHORT)(ERR_CQD + FW_NO_ERROR)
#define ERR_FW_DRIVE_NOT_READY          (USHORT)(ERR_CQD + FW_DRIVE_NOT_READY)
#define ERR_FW_CART_NOT_IN              (USHORT)(ERR_CQD + FW_CART_NOT_IN)
#define ERR_FW_MOTOR_SPEED_ERROR        (USHORT)(ERR_CQD + FW_MOTOR_SPEED_ERROR)
#define ERR_FW_STALL_ERROR              (USHORT)(ERR_CQD + FW_STALL_ERROR)
#define ERR_FW_WRITE_PROTECTED          (USHORT)(ERR_CQD + FW_WRITE_PROTECTED)
#define ERR_FW_UNDEFINED_COMMAND        (USHORT)(ERR_CQD + FW_UNDEFINED_COMMAND)
#define ERR_FW_ILLEGAL_TRACK            (USHORT)(ERR_CQD + FW_ILLEGAL_TRACK)
#define ERR_FW_ILLEGAL_CMD              (USHORT)(ERR_CQD + FW_ILLEGAL_CMD)
#define ERR_FW_ILLEGAL_ENTRY            (USHORT)(ERR_CQD + FW_ILLEGAL_ENTRY)
#define ERR_FW_BROKEN_TAPE              (USHORT)(ERR_CQD + FW_BROKEN_TAPE)
#define ERR_FW_GAIN_ERROR               (USHORT)(ERR_CQD + FW_GAIN_ERROR)
#define ERR_FW_CMD_WHILE_ERROR          (USHORT)(ERR_CQD + FW_CMD_WHILE_ERROR)
#define ERR_FW_CMD_WHILE_NEW_CART       (USHORT)(ERR_CQD + FW_CMD_WHILE_NEW_CART)
#define ERR_FW_CMD_UNDEF_IN_PRIME       (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_PRIME)
#define ERR_FW_CMD_UNDEF_IN_FMT         (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_FMT)
#define ERR_FW_CMD_UNDEF_IN_VERIFY      (USHORT)(ERR_CQD + FW_CMD_UNDEF_IN_VERIFY)
#define ERR_FW_FWD_NOT_BOT_IN_FMT       (USHORT)(ERR_CQD + FW_FWD_NOT_BOT_IN_FMT)
#define ERR_FW_EOT_BEFORE_ALL_SEGS      (USHORT)(ERR_CQD + FW_EOT_BEFORE_ALL_SEGS)
#define ERR_FW_CART_NOT_REFERENCED      (USHORT)(ERR_CQD + FW_CART_NOT_REFERENCED)
#define ERR_FW_SELF_DIAGS_FAILED        (USHORT)(ERR_CQD + FW_SELF_DIAGS_FAILED)
#define ERR_FW_EEPROM_NOT_INIT          (USHORT)(ERR_CQD + FW_EEPROM_NOT_INIT)
#define ERR_FW_EEPROM_CORRUPTED         (USHORT)(ERR_CQD + FW_EEPROM_CORRUPTED)
#define ERR_FW_TAPE_MOTION_TIMEOUT      (USHORT)(ERR_CQD + FW_TAPE_MOTION_TIMEOUT)
#define ERR_FW_DATA_SEG_TOO_LONG        (USHORT)(ERR_CQD + FW_DATA_SEG_TOO_LONG)
#define ERR_FW_CMD_OVERRUN              (USHORT)(ERR_CQD + FW_CMD_OVERRUN)
#define ERR_FW_PWR_ON_RESET             (USHORT)(ERR_CQD + FW_PWR_ON_RESET)
#define ERR_FW_SOFTWARE_RESET           (USHORT)(ERR_CQD + FW_SOFTWARE_RESET)
#define ERR_FW_DIAG_MODE_1_ERROR        (USHORT)(ERR_CQD + FW_DIAG_MODE_1_ERROR)
#define ERR_FW_DIAG_MODE_2_ERROR        (USHORT)(ERR_CQD + FW_DIAG_MODE_2_ERROR)
#define ERR_FW_CMD_REC_DURING_CMD       (USHORT)(ERR_CQD + FW_CMD_REC_DURING_CMD)
#define ERR_FW_SPEED_NOT_AVAILABLE      (USHORT)(ERR_CQD + FW_SPEED_NOT_AVAILABLE)
#define ERR_FW_ILLEGAL_CMD_HIGH_SPEED   (USHORT)(ERR_CQD + FW_ILLEGAL_CMD_HIGH_SPEED)
#define ERR_FW_ILLEGAL_SEEK_SEGMENT     (USHORT)(ERR_CQD + FW_ILLEGAL_SEEK_SEGMENT)
#define ERR_FW_INVALID_MEDIA            (USHORT)(ERR_CQD + FW_INVALID_MEDIA)
#define ERR_FW_HEADREF_FAIL_ERROR       (USHORT)(ERR_CQD + FW_HEADREF_FAIL_ERROR)
#define ERR_FW_EDGE_SEEK_ERROR          (USHORT)(ERR_CQD + FW_EDGE_SEEK_ERROR)
#define ERR_FW_MISSING_TRAINING_TABLE   (USHORT)(ERR_CQD + FW_MISSING_TRAINING_TABLE)
#define ERR_FW_INVALID_FORMAT           (USHORT)(ERR_CQD + FW_INVALID_FORMAT)
#define ERR_FW_SENSOR_ERROR             (USHORT)(ERR_CQD + FW_SENSOR_ERROR)
#define ERR_FW_TABLE_CHECKSUM_ERROR     (USHORT)(ERR_CQD + FW_TABLE_CHECKSUM_ERROR)
#define ERR_FW_WATCHDOG_RESET           (USHORT)(ERR_CQD + FW_WATCHDOG_RESET)
#define ERR_FW_ILLEGAL_ENTRY_FMT_MODE   (USHORT)(ERR_CQD + FW_ILLEGAL_ENTRY_FMT_MODE)
#define ERR_FW_ROM_CHECKSUM_FAILURE     (USHORT)(ERR_CQD + FW_ROM_CHECKSUM_FAILURE)
#define ERR_FW_ILLEGAL_ERROR_NUMBER     (USHORT)(ERR_CQD + FW_ILLEGAL_ERROR_NUMBER)
#define ERR_FW_NO_DRIVE                 (USHORT)(ERR_CQD + FW_NO_DRIVE)

/* JUMBO DRIVER ERROR CODES: ********** Range: 0x1150 - 0x116f **************/

#define ERR_ABORT                       (USHORT)(ERR_CQD + 0x0050)
#define ERR_BAD_BLOCK_FDC_FAULT         (USHORT)(ERR_CQD + 0x0051)
#define ERR_BAD_BLOCK_HARD_ERR          (USHORT)(ERR_CQD + 0x0052)
#define ERR_BAD_BLOCK_NO_DATA           (USHORT)(ERR_CQD + 0x0053)
#define ERR_BAD_FORMAT                  (USHORT)(ERR_CQD + 0x0054)
#define ERR_BAD_MARK_DETECTED           (USHORT)(ERR_CQD + 0x0055)
#define ERR_BAD_REQUEST                 (USHORT)(ERR_CQD + 0x0056)
#define ERR_CMD_FAULT                   (USHORT)(ERR_CQD + 0x0057)
#define ERR_CMD_OVERRUN                 (USHORT)(ERR_CQD + 0x0058)
#define ERR_DEVICE_NOT_CONFIGURED       (USHORT)(ERR_CQD + 0x0059)
#define ERR_DEVICE_NOT_SELECTED         (USHORT)(ERR_CQD + 0x005a)
#define ERR_DRIVE_FAULT                 (USHORT)(ERR_CQD + 0x005b)
#define ERR_DRV_NOT_READY               (USHORT)(ERR_CQD + 0x005c)
#define ERR_FDC_FAULT                   (USHORT)(ERR_CQD + 0x005d)
#define ERR_FMT_MOTION_TIMEOUT          (USHORT)(ERR_CQD + 0x005e)
#define ERR_FORMAT_TIMED_OUT            (USHORT)(ERR_CQD + 0x005f)
#define ERR_INCOMPATIBLE_MEDIA          (USHORT)(ERR_CQD + 0x0060)
#define ERR_INCOMPATIBLE_PARTIAL_FMT    (USHORT)(ERR_CQD + 0x0061)
#define ERR_INVALID_COMMAND             (USHORT)(ERR_CQD + 0x0062)
#define ERR_INVALID_FDC_STATUS          (USHORT)(ERR_CQD + 0x0063)
#define ERR_NEW_TAPE                    (USHORT)(ERR_CQD + 0x0064)
#define ERR_NO_DRIVE                    (USHORT)(ERR_CQD + 0x0065)
#define ERR_NO_FDC                      (USHORT)(ERR_CQD + 0x0066)
#define ERR_NO_TAPE                     (USHORT)(ERR_CQD + 0x0067)
#define ERR_SEEK_FAILED                 (USHORT)(ERR_CQD + 0x0068)
#define ERR_SPEED_UNAVAILBLE            (USHORT)(ERR_CQD + 0x0069)
#define ERR_TAPE_STOPPED                (USHORT)(ERR_CQD + 0x006a)
#define ERR_UNKNOWN_TAPE_FORMAT         (USHORT)(ERR_CQD + 0x006b)
#define ERR_UNKNOWN_TAPE_LENGTH         (USHORT)(ERR_CQD + 0x006c)
#define ERR_UNSUPPORTED_FORMAT          (USHORT)(ERR_CQD + 0x006d)
#define ERR_UNSUPPORTED_RATE            (USHORT)(ERR_CQD + 0x006e)
#define ERR_WRITE_BURST_FAILURE         (USHORT)(ERR_CQD + 0x006f)
#define ERR_MODE_CHANGE_FAILED          (USHORT)(ERR_CQD + 0x0070)
#define ERR_CONTROLLER_STATE_ERROR      (USHORT)(ERR_CQD + 0x0071)
#define ERR_TAPE_FAULT                  (USHORT)(ERR_CQD + 0x0072)
#define ERR_FORMAT_NOT_SUPPORTED        (USHORT)(ERR_CQD + 0x0073)

/* ADI ERROR CODES: **************** Range: 0x1500 - 0x157F *******************/

#define ERR_ADI                         (USHORT)(GROUPID_ADI<<ERR_SHIFT)

#define ERR_NO_VXD                      (USHORT)(ERR_ADI + 0x0000)
#define ERR_QUEUE_FULL                  (USHORT)(ERR_ADI + 0x0001)
#define ERR_REQS_PENDING                (USHORT)(ERR_ADI + 0x0002)
#define ERR_OUT_OF_MEMORY               (USHORT)(ERR_ADI + 0x0003)
#define ERR_ALREADY_CLOSED              (USHORT)(ERR_ADI + 0x0004)
#define ERR_OUT_OF_HANDLES              (USHORT)(ERR_ADI + 0x0005)
#define ERR_ABORTED_COMMAND             (USHORT)(ERR_ADI + 0x0006)
#define ERR_NOT_INITIALIZED             (USHORT)(ERR_ADI + 0x0007)
#define ERR_NO_REQS_PENDING             (USHORT)(ERR_ADI + 0x0008)
#define ERR_CHANNEL_NOT_OPEN            (USHORT)(ERR_ADI + 0x0009)
#define ERR_NO_HOST_ADAPTER             (USHORT)(ERR_ADI + 0x000a)
#define ERR_CMD_IN_PROGRESS             (USHORT)(ERR_ADI + 0x000b)
#define ERR_IGNORE_ECC                  (USHORT)(ERR_ADI + 0x000c)

#define ERR_INVALID_VXD                 (USHORT)(ERR_ADI + 0x0010)
#define ERR_INVALID_CMD                 (USHORT)(ERR_ADI + 0x0011)
#define ERR_INVALID_CMD_ID              (USHORT)(ERR_ADI + 0x0012)
#define ERR_INVALID_HANDLE              (USHORT)(ERR_ADI + 0x0013)
#define ERR_INVALID_DEVICE_CLASS        (USHORT)(ERR_ADI + 0x0014)

#define ERR_NO_ASPI_VXD                 (USHORT)(ERR_ADI + 0x0020)
#define ERR_INVALID_ASPI_VXD            (USHORT)(ERR_ADI + 0x0021)

#define ERR_END_OF_TAPE                 (USHORT)(ERR_ADI + 0x0060)
#define ERR_TAPE_FULL                   (USHORT)(ERR_ADI + 0x0061)
#define ERR_TAPE_READ_FAILED            (USHORT)(ERR_ADI + 0x0062)
#define ERR_TAPE_WRITE_FAILED           (USHORT)(ERR_ADI + 0x0063)
#define ERR_TAPE_SEEK_FAILED            (USHORT)(ERR_ADI + 0x0064)
#define ERR_TAPE_INFO_FAILED            (USHORT)(ERR_ADI + 0x0065)
#define ERR_TAPE_WRITE_PROTECT          (USHORT)(ERR_ADI + 0x0066)

#define ERR_INTERNAL_ERROR              (USHORT)(ERR_ADI + 0x007f)

/* KDI ERROR CODES: **************** Range: 0x1580 - 0x15FF *******************/

#define ERR_HANDLE_EXISTS               (USHORT)(ERR_ADI + 0x0080)
#define ERR_KDI_NOT_OPEN                (USHORT)(ERR_ADI + 0x0081)
#define ERR_OUT_OF_BUFFERS              (USHORT)(ERR_ADI + 0x0082)
#define ERR_INT13_HOOK_FAILED           (USHORT)(ERR_ADI + 0x0083)
#define ERR_IO_VIRTUALIZE_FAILED        (USHORT)(ERR_ADI + 0x0084)
#define ERR_INVALID_ADDRESS             (USHORT)(ERR_ADI + 0x0085)
#define ERR_JUMPERLESS_CFG_FAILED       (USHORT)(ERR_ADI + 0x0086)
#define ERR_TRK_NO_MEMORY               (USHORT)(ERR_ADI + 0x0090)
#define ERR_TRK_MEM_TEST_FAILED         (USHORT)(ERR_ADI + 0x0091)
#define ERR_TRK_MODE_NOT_SET            (USHORT)(ERR_ADI + 0x0092)
#define ERR_TRK_MODE_SET_FAILED         (USHORT)(ERR_ADI + 0x0093)
#define ERR_TRK_FIFO_FAILED             (USHORT)(ERR_ADI + 0x0094)
#define ERR_TRK_DELAY_NOT_SET           (USHORT)(ERR_ADI + 0x0095)
#define ERR_TRK_BAD_DATA_XFER           (USHORT)(ERR_ADI + 0x0096)
#define ERR_TRK_BAD_CTRL_XFER           (USHORT)(ERR_ADI + 0x0097)
#define ERR_TRK_TEST_WAKE_FAIL          (USHORT)(ERR_ADI + 0x0098)
#define ERR_TRK_AUTO_CFG_FAIL           (USHORT)(ERR_ADI + 0x0099)
#define ERR_TRK_CFG_NEEDS_UPDATE        (USHORT)(ERR_ADI + 0x009A)
#define ERR_TRK_NO_IRQ_AVAIL            (USHORT)(ERR_ADI + 0x009B)
#define ERR_DMA_CONFLICT                (USHORT)(ERR_ADI + 0x009C)
#define ERR_DMA_BUFFER_NOT_AVAIL        (USHORT)(ERR_ADI + 0x009D)
#define ERR_KDI_TO_EXPIRED              (USHORT)(ERR_ADI + 0x00A0)
#define ERR_KDI_CONTROLLER_BUSY         (USHORT)(ERR_ADI + 0x00A1)
#define ERR_KDI_CLAIMED_CONTROLLER      (USHORT)(ERR_ADI + 0x00A2)
#define ERR_KDI_NO_VFBACKUP             (USHORT)(ERR_ADI + 0x00A3)
#define ERR_LAST_KDI_ERROR              (USHORT)(ERR_ADI + 0x00ff)

/* KDI ENTRY POINT DEFINES: *************************************************/

#define KDI_GET_VERSION                 (USHORT)0x0000
#define KDI_OPEN_DRIVER                 (USHORT)0x0101
#define KDI_CLOSE_DRIVER                (USHORT)0x0102
#define KDI_SEND_DRIVER_CMD             (USHORT)0x0103
#define KDI_GET_ASYNC_STATUS            (USHORT)0x0104
#define KDI_DEBUG_OUTPUT                (USHORT)0x0105
#define KDI_COPY_BUFFER                 (USHORT)0x0106

/* Trakker specific entry points */
#define KDI_CHECKXOR                    (USHORT)0x0201
#define KDI_FLUSHFIFOX                  (USHORT)0x0202
#define KDI_POPMASKTRAKKERINT           (USHORT)0x0203
#define KDI_PUSHMASKTRAKKERINT          (USHORT)0x0204
#define KDI_READREG                     (USHORT)0x0205
#define KDI_RECEIVEDATA                 (USHORT)0x0206
#define KDI_SENDDATA                    (USHORT)0x0207
#define KDI_SETFIFOXADDRESS             (USHORT)0x0208
#define KDI_SWITCHTODATA                (USHORT)0x0209
#define KDI_TRAKKERXFER                 (USHORT)0x020A
#define KDI_WRITEREG                    (USHORT)0x020B
#define KDI_FINDIRQ                     (USHORT)0x020C
#define KDI_CREATE_TRAKKER_CONTEXT      (USHORT)0x020D

/*--------------------------------------------------
 * This define is needed until the cbw.2 codebase
 * goes away
 *--------------------------------------------------*/
#define KDI_CONFIG_TRAKKER              KDI_CREATE_TRAKKER_CONTEXT


#define KDI_CONFIGURE_TRAKKER           (USHORT)0x020E
#define KDI_TRISTATE                    (USHORT)0x020F
#define KDI_AGRESSIVE_FINDIRQ           (USHORT)0x0210
#define KDI_LOCATE_JUMPERLESS           (USHORT)0x0211
#define KDI_ACTIVATE_JUMPERLESS         (USHORT)0x0212

/* Miscellaneous functions */
#define KDI_PROGRAM_DMA                 (USHORT)0x0301
#define KDI_HALT_DMA                    (USHORT)0x0302
#define KDI_SHORT_TIMER                 (USHORT)0x0303
#define KDI_GET_DMA_BUFFER              (USHORT)0x0304
#define KDI_FREE_DMA_BUFFER             (USHORT)0x0305
#define KDI_GET_VALID_INTERRUPTS        (USHORT)0x0306

/* KDI DEFINES: *************************************************************/

/* KDI_CLOSE_DRIVER parameter options */
#define KDI_ABORT_CLOSE     (USHORT)0x1
#define KDI_NORMAL_CLOSE    (USHORT)0x2


/*****************************************************************************
*
* FILE: microsol.h
*
* PURPOSE:  This file contains all of the defines necessary to access
*               the microsolutions API's
*
*****************************************************************************/

#ifndef _MICROSOL_H_
#define _MICROSOL_H_

#define msiWord unsigned short
#define msiDWord unsigned long
#define msiByte unsigned char

#pragma warning(disable:4001)  //who says double slash is not nice

typedef struct S_MsiPPC {

// API portion of structure

    msiWord
        flag_word,
        lpt_addr,
        lpt_type,
        fdc_type,
        fdc_loops,
        chip_type,
        chip_mode,
        irq_level,
        max_secs,
        rx_mode,
        tx_mode,
        rx_margin,
        tx_margin,
        tx_to_rx,
        rx_factor,
        tx_factor,
        reserved[64];

} MsiPPC;

typedef struct S_MicroSol {
    MsiPPC      ppc_channel;    /* MicroSolutions IO structure */
    msiWord     lpt_number;     /* (I/O) parallel port number */
    msiWord     open_flags;     /* flags to use on open call */
} MicroSol;

//
// Control Flags
//
#define MSI_NO_EEPROM           0x0001
#define MSI_NO_BIDIR            0x0002
#define MSI_NO_FWRITE           0x0004
#define MSI_NO_IBMPS2           0x0008
#define MSI_NO_EPP              0x0010
#define MSI_NO_IRQ              0x0020
#define MSI_NO_AUTOIRQ          0x0040
#define MSI_IRQ_MODE1           0x0080
#define MSI_IRQ_MODE2           0x0100
#define MSI_IRQ_MODE4           0x0200
#define MSI_NO_TPWIZARD         0x0400

//
// DMA Read and Write codes
//
#define MSI_FDC_2_PC            0x0001
#define MSI_PC_2_FDC            0x0000
#define MSI_MAP_MEM             0x0002
#define MSI_USE_CRC             0x0004      // OBSOLETE Always used on 50772
#define MSI_USE_ECC             0x0008

//
// Fault codes
//
#define MSI_FC_NOT_OPEN     0x0101
#define MSI_FC_NOT_CLOSED   0x0102

#define MSI_FC_CON_FAIL     0x0201

#define MSI_FC_FDC_RQM      0x0301
#define MSI_FC_FDC_DIO      0x0302
#define MSI_FC_FDC_BSY      0x0303

#define MSI_FC_DMA_ACT      0x0401
#define MSI_FC_DMA_ABORT    0x0402
#define MSI_FC_DMA_DIR      0x0403
#define MSI_FC_DMA_SIZE     0x0404
#define MSI_FC_DMA_FLOW     0x0405
#define MSI_FC_DMA_CRC      0x0406
#define MSI_FC_DMA_ECC      0x0407
#define MSI_FC_DMA_ZONE     0x0408
#define MSI_FC_DMA_ILLEGAL  0x0409

#define MSI_FC_NOT_IRQ      0x0501
#define MSI_FC_IRQ_ACT      0x0601
#define MSI_FC_EEP_BAD      0x0701

#define MSI_FC_REP_BIT      0x8001      // Application Fault Codes
#define MSI_FC_WRONG_BIT    0x8002
#define MSI_FC_ERR_STATUS   0x8003
#define MSI_FC_NO_CART      0x8004
#define MSI_FC_NEW_CART     0x8005
#define MSI_FC_ECC_FAIL     0x8006

#define MSI_FC_FDC_ABNORMAL 0x8040
#define MSI_FC_FDC_INVALID  0x8080
#define MSI_FC_FDC_CHANGED  0x80C0

//
// Interrupt type (for fc_par_execute_int)
//
#define MSI_FC_INT_HARDWARE 0       // a result of a hardware interrupt
#define MSI_FC_INT_SOFTWARE 1       // a result of a software poll
#define MSI_FC_INT_FORCE    2       // forced software interrupt
#define MSI_FC_INT_INTERNAL 3       // internally generated interrupt?

//
// Function Prototypes
//

extern msiWord cdecl fc_par_version(void);

extern msiWord cdecl fc_par_open(MsiPPC *,msiWord);
extern msiWord cdecl fc_par_close(void);

extern msiWord cdecl fc_par_rd_fdc(msiByte  *, msiWord);
extern msiWord cdecl fc_par_wr_fdc(msiByte  *, msiWord);

extern msiWord cdecl fc_par_rd_port(msiWord);
extern msiWord cdecl fc_par_wr_port(msiWord, msiByte);

extern msiWord cdecl fc_par_rd_eeprom(msiWord);
extern msiWord cdecl fc_par_wr_eeprom(msiWord, msiWord);

extern msiWord cdecl fc_par_rd_dma(msiByte  *, msiWord, msiDWord);
extern msiWord cdecl fc_par_wr_dma(msiByte  *, msiWord, msiDWord);
extern msiWord cdecl fc_par_chk_dma(msiByte  *, msiWord, msiDWord);

extern msiWord cdecl fc_par_clr_dma(msiWord);
extern msiWord cdecl fc_par_prog_dma(msiWord, msiWord, msiDWord);
extern msiWord cdecl fc_par_term_dma(msiWord, msiWord);

extern msiWord cdecl fc_par_execute_int(msiWord);
extern msiWord cdecl fc_par_handle_int(void (cdecl *)(msiWord));

#ifdef NOT_NOW // As of version 6.02 of the microsolutions API,  the code below is obsolete (EBX saved now)

//
// If this is a 32-bit compiler (not 8086 or 80286) then we need to preserve
// the EBX register on fc_par calls.  The code below will do so.
//
#if !defined(M_I8086) && !defined(M_I286)

#pragma warning(disable:4505)

static __inline msiWord msifix_open(MsiPPC *a,msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_open(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_close(void)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_close();
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_fdc(msiByte  *a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_fdc(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_fdc(msiByte  *a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_fdc(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_port(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_port(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_port(msiWord a, msiByte b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_port(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_eeprom(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_eeprom(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_eeprom(msiWord a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_eeprom(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_rd_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_rd_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_wr_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_wr_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_chk_dma(msiByte  *a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_chk_dma(a,b,c);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_clr_dma(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_clr_dma(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_prog_dma(msiWord a, msiWord b, msiDWord c)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_prog_dma(a,b,c);
    _asm pop ebx;
    return ret;
    };

static __inline msiWord msifix_term_dma(msiWord a, msiWord b)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_term_dma(a,b);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_execute_int(msiWord a)
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_execute_int(a);
    _asm pop ebx;
    return ret;
    }

static __inline msiWord msifix_handle_int(void (cdecl *a)(msiWord))
    {
    msiWord ret;
    _asm push ebx;
    ret = fc_par_handle_int(a);
    _asm pop ebx;
    return ret;
    }

// now use inline functions (that preserve ebx) for all calls into
// microsolutions api
#define fc_par_open(a,b)            msifix_open(a,b)
#define fc_par_close                msifix_close
#define fc_par_rd_port(a)           msifix_rd_port(a)
#define fc_par_wr_port(a, b)        msifix_wr_port(a, b)
#define fc_par_rd_eeprom(a)         msifix_rd_eeprom(a)
#define fc_par_wr_eeprom(a, b)  msifix_wr_eeprom(a, b)
#define fc_par_rd_dma(a, b, c)  msifix_rd_dma(a, b, c)
#define fc_par_wr_dma(a, b, c)  msifix_wr_dma(a, b, c)
#define fc_par_chk_dma(a, b, c) msifix_chk_dma(a, b, c)
#define fc_par_clr_dma(a)           msifix_clr_dma(a)
#define fc_par_prog_dma(a, b, c)    msifix_prog_dma(a, b, c)
#define fc_par_term_dma(a, b)       msifix_term_dma(a, b)
#define fc_par_execute_int(a)       msifix_execute_int(a)
#define fc_par_handle_int(a)        msifix_handle_int(a)
#endif // !defined(M_I8086) && !defined(M_I286)
#endif // NOT_NOW
#endif // _MICROSOL_H_

/*****************************************************************************
*
* FILE: FRB_API.H
*
* PURPOSE: This file contains all of the API's necessary to access
*               the common QIC117 device driver and build FRB's.
*
*****************************************************************************/

/* Valid Tape Formats *******************************************************/
/* S_CQDTapeCfg.tape_class */

#define QIC40_FMT               (UCHAR)1    /* QIC-40 formatted tape  */
#define QIC80_FMT               (UCHAR)2    /* QIC-80 formatted tape  */
#define QIC3010_FMT             (UCHAR)3    /* QIC-3010 formatted tape */
#define QIC3020_FMT             (UCHAR)4    /* QIC-3020 formatted tape */
#define QIC80W_FMT              (UCHAR)5    /* QIC-80W formatted tape */
#define QIC3010W_FMT            (UCHAR)6    /* QIC-3010W formatted tape */
#define QIC3020W_FMT            (UCHAR)7    /* QIC-3020W formatted tape */

/* The following parameters are used to indicate the tape format code *******/
/* S_CQDTapeCfg.tape_format_code */

#define QIC_FORMAT                  (UCHAR)2    /* Indicates a standard or extended length tape */
#define QICEST_FORMAT               (UCHAR)3    /* Indicates a 1100 foot tape   */
#define QICFLX_FORMAT               (UCHAR)4    /* Indicates a flexible format tape foot tape */
#define QIC_XLFORMAT            (UCHAR)5    /* Indicates a 425ft tape */

/* Valid Drive Classes ******************************************************/
/* S_DeviceDescriptor.drive_class */
/* S_DeviceInfo.drive_class */

#define UNKNOWN_DRIVE               (UCHAR)1    /* Unknown drive class  */
#define QIC40_DRIVE              (UCHAR)2   /* QIC-40 drive        */
#define QIC80_DRIVE              (UCHAR)3   /* QIC-80 drive        */
#define QIC3010_DRIVE            (UCHAR)4   /* QIC-3010 drive      */
#define QIC3020_DRIVE            (UCHAR)5   /* QIC-3020 drive      */
#define QIC80W_DRIVE             (UCHAR)6   /* QIC-80W drive       */
#define QIC3010W_DRIVE           (UCHAR)7   /* QIC-3010W drive     */
#define QIC3020W_DRIVE           (UCHAR)8   /* QIC-3020W drive     */

/* Valid Tape Types *********************************************************/
/* The defined values match the QIC117-G spec. except for TAPE_205 */
/* S_CQDTapeCfg.tape_type */

#define TAPE_UNKNOWN            (UCHAR)0x00 /* Unknown tape type           */
#define TAPE_205                (UCHAR)0x11     /* 205 foot 550 Oe             */
#define TAPE_425                (UCHAR)0x01     /* 425 foot 550 Oe             */
#define TAPE_307                (UCHAR)0x02     /* 307.5 foot 550 Oe           */
#define TAPE_FLEX_550           (UCHAR)0x03 /* Flexible Format 550 Oe      */
#define TAPE_FLEX_900           (UCHAR)0x06     /* Flexible Format 900 Oe      */
#define TAPE_FLEX_550_WIDE      (UCHAR)0x0B /* Flexible Format 550 Oe Wide */
#define TAPE_FLEX_900_WIDE      (UCHAR)0x0E     /* Flexible Format 900 Oe Wide */

/* Valid Transfer Rates ******************************************************/

#define XFER_250Kbps            (UCHAR)1   /* 250 Kbps transfer rate supported */
#define XFER_500Kbps            (UCHAR)2   /* 500 Kbps transfer rate supported */
#define XFER_1Mbps              (UCHAR)4   /* 1 Mbps transfer rate supported   */
#define XFER_2Mbps              (UCHAR)8   /* 2Mbps transfer rate supported    */

/* Valid Commands for the driver ********************************************/

#define CMD_LOCATE_DEVICE       (USHORT)0x1100
#define CMD_REPORT_DEVICE_CFG   (USHORT)0x1101
#define CMD_SELECT_DEVICE       (USHORT)0x1102
#define CMD_DESELECT_DEVICE     (USHORT)0x1103
#define CMD_LOAD_TAPE           (USHORT)0x1104
#define CMD_UNLOAD_TAPE         (USHORT)0x1105
#define CMD_SET_SPEED           (USHORT)0x1106
#define CMD_REPORT_STATUS       (USHORT)0x1107
#define CMD_SET_TAPE_PARMS      (USHORT)0x1108
#define CMD_READ                (USHORT)0x1109
#define CMD_READ_RAW            (USHORT)0x110A
#define CMD_READ_HEROIC         (USHORT)0x110B
#define CMD_READ_VERIFY         (USHORT)0x110C
#define CMD_WRITE               (USHORT)0x110D
#define CMD_WRITE_DELETED_MARK  (USHORT)0x110E
#define CMD_FORMAT              (USHORT)0x110F
#define CMD_RETENSION           (USHORT)0x1110
#define CMD_ISSUE_DIAGNOSTIC    (USHORT)0x1111
#define CMD_ABORT               (USHORT)0x1112
#define CMD_DELETE_DRIVE        (USHORT)0x1113
#define CMD_REPORT_DEVICE_INFO  (USHORT)0x1114

/* FC20 jumperless sequence size */
/* NOTE: This is a mirror of the SEQUENCE SIZE define in task.h and needs
 * to be in sync with that define */
#define FC20_SEQUENCE_SIZE      (UCHAR)0x10

/* DATA STRUCTURES: *********************************************************/
/* Note:  The following structures are not aligned on DWord boundaries */
#pragma pack(4)

typedef struct S_DeviceCfg {                /* QIC117 device configuration information */
    BOOLEAN speed_change;                   /* device/FDC combination supports dual speeds */
    BOOLEAN alt_retrys;                     /* Enable reduced retries */
    BOOLEAN new_drive;                      /* indicates whether or not drive has been configured */
    UCHAR   select_byte;                    /* FDC select byte */
    UCHAR   deselect_byte;                  /* FDC deselect byte */
    UCHAR   drive_select;                   /* FDC drive select byte */
    UCHAR   perp_mode_select;               /* FDC perpendicular mode select byte */
    UCHAR   supported_rates;                /* Transfer rates supported by the device/FDC combo */
    UCHAR   drive_id;                       /* Tape device id */
} DeviceCfg, *DeviceCfgPtr;

typedef struct S_DeviceDescriptor {     /* Physical characteristics of the tape device */
    USHORT  sector_size;                    /* sector size in bytes */
    USHORT  segment_size;                   /* Number of sectors per segment */
    UCHAR   ecc_blocks;                     /* Number of ECC sectors per segment */
    USHORT  vendor;                         /* Manufacturer of the tape drive */
    UCHAR   model;                          /* Model of the tape drive */
    UCHAR   drive_class;                    /* Class of tape drive. (QIC-40, QIC-80, etc) */
    UCHAR   native_class;                   /* Native class of tape drive (QIC-40, QIC-80, etc) */
    UCHAR   fdc_type;                       /* Floppy disk controller type */
} DeviceDescriptor, *DeviceDescriptorPtr;

typedef struct S_DeviceInfo {       /* Physical information from the tape device */
    UCHAR   drive_class;                    /* Class of tape drive. (QIC-40, QIC-80, etc) */
    USHORT  vendor;                         /* Manufacturer of the tape drive */
    UCHAR   model;                          /* Model of the tape drive */
    USHORT  version;                            /* Firmware Version */
    USHORT  manufacture_date;               /* days since Jan 1, 1992 */
    ULONG   serial_number;                  /* Cnnnnnnn where 'C' is an alpha character */
                                                    /* in the highest byte, and nnnnnnn is a 7 */
                                                    /* digit decimal number in the remaining 3 bytes */
    UCHAR   oem_string[20];             /* OEM the device is destined for */
    UCHAR   country_code[2];                /* Country code chars, "US", "UK", ... */
} DeviceInfo, *DeviceInfoPtr;

typedef struct S_CQDTapeCfg {               /* Physical characteristics of the tape */
    ULONG   log_segments;                   /* number of logical segments on a tape UDWord  formattable_segs */
    ULONG   formattable_segments;       /* the number of formattable segments */
    ULONG   formattable_tracks;         /* the number of formattable tracks */
    ULONG   seg_tape_track;             /* segments per tape track */
    USHORT  num_tape_tracks;                /* number of tape tracks */
    BOOLEAN write_protected;                /* tape is write protected */
    BOOLEAN read_only_media;                /* tape is read only by the current device i.e QIC40 in a QIC80 */
    BOOLEAN formattable_media;          /* tape can be formatted by the current device */
    BOOLEAN speed_change_ok;                /* tape/device combo supports dual speeds */
    UCHAR   tape_class;                     /* Format of tape in drive */
    UCHAR   max_floppy_side;                /* maximum floppy side */
    UCHAR   max_floppy_track;               /* maximum floppy track */
    UCHAR   max_floppy_sector;          /* maximum floppy sector */
    UCHAR   xfer_slow;                      /* slow transfer rate */
    UCHAR   xfer_fast;                      /* fast transfer rate */
    UCHAR   tape_format_code;
    UCHAR   tape_type;                      /* from status bits 4-7, includes wide bit */
} CQDTapeCfg, *CQDTapeCfgPtr;

typedef struct S_RepositionData {       /* reposition counts */
    USHORT  overrun_count;                  /* data overruns/underruns */
    USHORT  reposition_count;               /* tape repositions */
    USHORT  hard_retry_count;               /* tape repositions due to no data errors */
} RepositionData, *RepositionDataPtr;

typedef struct S_OperationStatus {      /* Driver status */
    ULONG   current_segment;                /* current logical segment */
    USHORT  current_track;                  /* current physical track */
    BOOLEAN new_tape;                       /* new cartridge detected */
    BOOLEAN no_tape;                            /* no tape in the deivce */
    BOOLEAN cart_referenced;                /* tape is not referenced */
    BOOLEAN retry_mode;                     /* device is currently retrying an io operation */
    UCHAR   xfer_rate;                      /* Current transfer rate */
} OperationStatus, *OperationStatusPtr;

typedef struct  S_QIC117 {
    USHORT      r_dor;                  /* Tape adapter board digital output register. */
    USHORT      dor;                        /* Floppy disk controller digital output register. */
    UCHAR       drive_id;               /* Physical tape drive id. */
    UCHAR       reserved[3];
} QIC117;

typedef struct S_Trakker {
    USHORT      r_dor;                  /* Tape adapter board digital output register. */
    USHORT      dor;                        /* Floppy disk controller digital output register. */
    ULONG        trakbuf;                    /* pointer to the dymanic trakker buffer */
    ULONG        mem_size;                       /* Number of bytes on the Trakker */
    UCHAR       drive_id;               /* Physical tape drive id. */
    UCHAR    port_mode;                      /* Current mode that the parallel port is operating in communication eith Trakker */
    UCHAR       lpt_type;                       /* 0=none, 1=uni, 2=bidi */
    UCHAR       lpt_number;                     /* 0=none, 1=LPT1, 2=LPT2, 3=LPT3 */
    UCHAR       wake_index;                     /* the wakeup sequence (of 8 possible) used to access the TRAKKER ASIC */
} Trakker;

/* port_mode:   0 - Unidirectional, Full Handshake, 500Kb, Full Delay
 *              1 - Unidirectional, Full Handshake, 500Kb, Optimize Delays
 *              2 - Unidirectional, Full Handshake, 1Mb,   Optimize Delays
 *              3 - Unidirectional, Self Latch,     1Mb,   Optimize Delays
 *              4 - Bidirectional,  Full Handshake, 500Kb, Optimize Delays
 *              5 - Bidirectional,  Full Handshake, 1Mb,   Optimize Delays
 *              6 - Bidirectional,  Self Latch,     1Mb,   Optimize Delays */


/* Duplicated Grizzly Structure */ /* ------------------------- */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ----------------                             --------------- */
/* ----------------                             --------------- */
/* ----------------   This structure is         --------------- */
/* ----------------                             --------------- */
/* ----------------   must be kept in perfect   --------------- */
/* ----------------                             --------------- */
/* ----------------   synce with its evil twin  --------------- */
/* ----------------                             --------------- */
/* ----------------   struct S_GrizzlyDevice    --------------- */
/* ----------------                             --------------- */
/* ----------------   located in                --------------- */
/* ----------------                             --------------- */
/* ----------------   cbw\code\include\task.h   --------------- */
/* ----------------                             --------------- */
/* ----------------                             --------------- */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

typedef struct S_Grizzly {
    UCHAR       drive_id;       /* Physical tape drive id. */
    USHORT      grizzly_ctrl;   /* Grizzly special config control options */
    USHORT      xfer_mode;      /* (I/O) parallel port transfer mode */
    UCHAR       xfer_rate;      /* (I/O) device transfer rate selection */
    SHORT       lpt_type;       /* (O) parallel port type */
    UCHAR       lpt_number;     /* (I/O) parallel port number */
} Grizzly;

/* ------------------------------------------------------------ */
/* ------------------------------------------------------------ */

typedef union   U_DevSpecific {
    QIC117  q117_dev;           /* Interface specific device parameters for QIC 117 */
    Trakker trakker_dev;        /* Interface specific device parameters for Trakker */
    Grizzly grizzly_dev;
    MicroSol microsol_dev;
} DevSpecific;

typedef struct S_DriveParms {                           /* Hardware parameters for DMA & IRQ enable. */
    DevSpecific dev_parm;                               /* Interface specific device parameters */
    USHORT      drive_handle;                           /* Unique identifier for tape drive. */
    USHORT      base_address;                           /* Controller base address. */
    USHORT      mca_dma_address;                        /* DMA base address on MCA. */
    USHORT      mca_cdma_address;                       /* Compression DMA base address on MCA. */
    BOOLEAN     irq_share;                              /* (TRUE) interrupt sharing enabled. */
    BOOLEAN     io_card;                                    /* (TRUE) IO controller present. */
    BOOLEAN     compress_hard;                          /* (TRUE) hardware compression present. */
    BOOLEAN     micro_channel;                          /* (TRUE) Micro Channel Architecture. */
    BOOLEAN     dual_port_mode;                     /* (TRUE) dual port mode enabled. */
    BOOLEAN     dma_width_mca;                          /* TRUE = 16-bit; FALSE = 8-bit */
    UCHAR       board_type;                             /* Identifies type of controller board */
    UCHAR       clk48mhz;                               /* if true,  then use 48mhz clock if it's an 82078 */
    UCHAR       board_id;                               /* Hard-wired id of board, 0 - 3 */
    UCHAR       irq;                                        /* Hardware interrupt vector. */
    UCHAR       dma;                                        /* Tape drive dma channel. */
    UCHAR       compression_dma;                        /* Compression dma channel. */
    UCHAR       data_dma_16bit;                     /* TRUE-controller is in a 16bit slot */
    UCHAR       extended_irq;                           /* TRUE-IRQ is 10 or 11 */
    UCHAR       setup_reg_shadow;                       /* copy of the setup register used in hio */
    UCHAR       sequence[FC20_SEQUENCE_SIZE];       /* the jumperless sequence used to wake up the FC20 */
} DriveParms, *DriveParmsPtr;

/* JUMBO DRIVER FRB STRUCTURES **********************************************/

typedef struct S_ReportDeviceInfo {             /* Device Information FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    DeviceInfo          device_info;            /* O device information */
} ReportDeviceInfo, *ReportDeviceInfoPtr;

typedef struct S_DriveCfgData {             /* Device Configuration FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    DeviceCfg           device_cfg;             /* I/O device configuration */
    DriveParms          hardware_cfg;           /* I the Hardware I/O Parameters of the drive */
    DeviceDescriptor    device_descriptor;  /* O device description */
    OperationStatus operation_status;       /* O Current status of the device */
} DriveCfgData, *DriveCfgDataPtr;

typedef struct S_DeviceOp {                 /* Generic Device operation FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    OperationStatus operation_status;       /* O Current status of the device */
    ULONG               data;                       /* Command dependent data area */
} DeviceOp, *DeviceOpPtr;

typedef struct S_LoadTape {                 /* New Tape configuration FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    CQDTapeCfg          tape_cfg;               /* O Tape configuration information */
    OperationStatus operation_status;       /* O Current status of the device */
} LoadTape, *LoadTapePtr;

typedef struct S_TapeParms {                    /* Tape length configuration FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    ULONG           segments_per_track;     /* I Segments per tape track */
    CQDTapeCfg      tape_cfg;                   /* O Tape configuration information */
} TapeLength, *TapeLengthPtr;

typedef struct S_DeviceIO {                 /* Device I/O FRB */
    ADIRequestHdr       adi_hdr;                    /* I/O ADI packet header */
    ULONG               starting_sector;        /* I Starting sector for the I/O operation */
    ULONG               number;                 /* I Number of sectors in the I/O operation (including bad) */
    ULONG               bsm;                        /* I Bad sector map for the requested I/O operation */
    ULONG               crc;                        /* O map of sectors that failed CRC check */
    ULONG               retrys;                 /* O map of sectors that had to be retried */
    RepositionData      reposition_data;        /* O reposition counts for the current operation */
    OperationStatus operation_status;       /* O Current status of the device */
} DeviceIO, *DeviceIOPtr;

typedef struct S_FormatRequest {                /* Format request FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    CQDTapeCfg      tape_cfg;                   /* O Tape configuration information */
    USHORT          start_track;                /* I Starting track */
    USHORT          tracks;                     /* I Number of tracks to format */
} FormatRequest, *FormatRequestPtr;

typedef struct S_DComFirm {                 /* Direct firmware communication FRB */
    ADIRequestHdr   adi_hdr;                        /* I/O ADI packet header */
    UCHAR           command_str[32];            /* I Firmware command sequence */
} DComFirm, *DComFirmPtr;

#pragma pack()

/*****************************************************************************
*
* FILE: VENDOR.H
*
* PURPOSE: This file contains all of the defines for each of the vendor
*          numbers and model numbers.  The vendor number data is from the
*          QIC 117 specification.
*
*****************************************************************************/

/* Valid Drive Vendors ******************************************************/
/* The defined values match the QIC117-G spec. */
/* S_DeviceDescriptor.vendor */
/* S_DeviceInfo.vendor */

#define VENDOR_UNASSIGNED       (USHORT)0
#define VENDOR_ALLOY_COMP       (USHORT)1
#define VENDOR_3M               (USHORT)2
#define VENDOR_TANDBERG         (USHORT)3
#define VENDOR_CMS_OLD          (USHORT)4
#define VENDOR_CMS              (USHORT)71
#define VENDOR_ARCHIVE_CONNER   (USHORT)5
#define VENDOR_MOUNTAIN_SUMMIT  (USHORT)6
#define VENDOR_WANGTEK_REXON    (USHORT)7
#define VENDOR_SONY             (USHORT)8
#define VENDOR_CIPHER           (USHORT)9
#define VENDOR_IRWIN            (USHORT)10
#define VENDOR_BRAEMAR          (USHORT)11
#define VENDOR_VERBATIM         (USHORT)12
#define VENDOR_CORE             (USHORT)13
#define VENDOR_EXABYTE          (USHORT)14
#define VENDOR_TEAC             (USHORT)15
#define VENDOR_GIGATEK          (USHORT)16
#define VENDOR_COMBYTE          (USHORT)17
#define VENDOR_PERTEC           (USHORT)18
#define VENDOR_IOMEGA           (USHORT)546
#define VENDOR_CMS_ENHANCEMENTS (USHORT)1021   /* drive_type = CMS Enhancements */
#define VENDOR_UNSUPPORTED      (USHORT)1022   /* drive_type = Unsupported */
#define VENDOR_UNKNOWN          (USHORT)1023   /* drive_type = unknown */

/* Valid Drive Models *******************************************************/
/* S_DeviceDescriptor.model */
/* S_DeviceInfo.model */

#define MODEL_CMS_QIC40           (UCHAR)0x00  /* CMS QIC40 Model # */
#define MODEL_CMS_QIC80           (UCHAR)0x01  /* CMS QIC80 Model # */
#define MODEL_CMS_QIC3010         (UCHAR)0x02  /* CMS QIC3010 Model # */
#define MODEL_CMS_QIC3020         (UCHAR)0x03  /* CMS QIC3020 Model # */
#define MODEL_CMS_QIC80_STINGRAY  (UCHAR)0x04  /* CMS QIC80 STINGRAY Model # */
#define MODEL_CMS_QIC80W          (UCHAR)0x05  /* CMS QIC80W Model # */
#define MODEL_CMS_TR3             (UCHAR)0x06  /* CMS TR3 Model # */
#define MODEL_CONNER_QIC80        (UCHAR)0x0e  /* Conner QIC80 Model # */
#define MODEL_CONNER_QIC80W       (UCHAR)0x10  /* Conner QIC80 Wide Model # */
#define MODEL_CONNER_QIC3010      (UCHAR)0x12  /* Conner QIC3010 Model # */
#define MODEL_CONNER_QIC3020      (UCHAR)0x14  /* Conner QIC3020 Model # */
#define MODEL_CORE_QIC80          (UCHAR)0x21  /* Core QIC80 Model # */
#define MODEL_IOMEGA_QIC80        (UCHAR)0x00  /* Iomega QIC80 Model # */
#define MODEL_IOMEGA_QIC3010      (UCHAR)0x01  /* Iomega QIC3010 Model # */
#define MODEL_IOMEGA_QIC3020      (UCHAR)0x02  /* Iomega QIC3020 Model # */
#define MODEL_SUMMIT_QIC80        (UCHAR)0x01  /* Summit QIC80 Model # */
#define MODEL_SUMMIT_QIC3010      (UCHAR)0x15  /* Summit QIC 3010 Model # */
#define MODEL_WANGTEK_QIC80       (UCHAR)0x0a  /* Wangtek QIC80 Model # */
#define MODEL_WANGTEK_QIC40       (UCHAR)0x02  /* Wangtek QIC40 Model # */
#define MODEL_WANGTEK_QIC3010     (UCHAR)0x0C  /* Wangtek QIC3010 Model # */
#define MODEL_TEAC_TR1            (UCHAR)0x0e
#define MODEL_TEAC_TR2            (UCHAR)0x0f
#define MODEL_PERTEC_TR1          (UCHAR)0x01
#define MODEL_PERTEC_TR2          (UCHAR)0x02
#define MODEL_PERTEC_TR3          (UCHAR)0x03
#define MODEL_UNKNOWN             (UCHAR)0xFF   /* drive_model = unknown */

/*****************************************************************************
*
* FILE: KDIWPRIV.H
*
* PURPOSE: This file contains all of the internal structures and types needed
*          in the KDI.
*
*****************************************************************************/

/* Miscellaneous defines. */
#define NANOSEC_PER_MILLISEC    0x0004f2f0


/* STRUCTURES: **************************************************************/

/* Define the maximum number of controllers and floppies per controller */
/* that this driver will support. */

/* The number of floppies per controller is fixed at 4, since the */
/* controllers don't have enough bits to select more than that (and */
/* actually, many controllers will only support 2).  The number of */
/* controllers per machine is arbitrary; 3 should be more than enough. */

#define MAXIMUM_CONTROLLERS_PER_MACHINE    3

/* MACROS to access the controller.  Note that the *_PORT_UCHAR macros */
/* work on all machines, whether the I/O ports are separate or in */
/* memory space. */

#define READ_CONTROLLER( Address )                         \
    READ_PORT_UCHAR( ( PUCHAR )Address )

#define WRITE_CONTROLLER( Address, Value )                 \
    WRITE_PORT_UCHAR( ( PUCHAR )Address, ( UCHAR )Value )


/* Define the maximum number of tape drives per controller */
/* that this driver will support. */

/* The number of tape drives per controller is fixed at 1, since the */
/* software select schemes generally work for one drive only. */

#define MAXIMUM_TAPE_DRIVES_PER_CONTROLLER 1

/* This structure holds all of the configuration data.  It is filled in */
/* by FlGetConfigurationInformation(), which gets the information from */
/* the configuration manager or the hardware architecture layer (HAL). */

typedef struct s_controllerInfo {
    UCHAR           floppyEnablerApiSupported;
    UCHAR           dmaDirection;
    PDEVICE_OBJECT  apiDeviceObject;
    BOOLEAN         fdcSupported;
    PDEVICE_OBJECT  fdcDeviceObject;
    UNICODE_STRING  fdcUnicodeString;
    WCHAR           idstr[200];
} ControllerInfo;

typedef struct S_KdiContext {
    KEVENT          interrupt_event;
    KEVENT          allocate_adapter_channel_event;
    PKINTERRUPT     interrupt_object;
    PVOID           map_register_base;
    LONG            actual_controller_number;
    PDEVICE_OBJECT  device_object;
    ULONG           base_address;
    PVOID           cqd_context;
    UCHAR           interface_type;
    BOOLEAN         own_floppy_event;
    BOOLEAN         current_interrupt;
    BOOLEAN         interrupt_pending;
    NTSTATUS        interrupt_status;
    BOOLEAN         adapter_locked;
    LIST_ENTRY      list_entry;
    KSEMAPHORE      request_semaphore;
    KSPIN_LOCK      list_spin_lock;
    KEVENT          clear_queue_event;
    BOOLEAN         unloading_driver;
    UCHAR           number_of_tape_drives;
    BOOLEAN         clear_queue;
    BOOLEAN         abort_requested;
    ULONG           error_sequence;
    ULONG           tape_number;
    ControllerInfo  controller_data;
    HANDLE          thread_handle;
} KdiContext, *KdiContextPtr;

typedef struct S_QICDeviceContext {

    PDEVICE_OBJECT      UnderlyingPDO;
    PDEVICE_OBJECT      TargetObject;

    BOOLEAN             DeviceInitialized;
    UNICODE_STRING      InterfaceString;

    PDEVICE_OBJECT  device_object;
    PDEVICE_OBJECT  TapeDeviceObject;
    KdiContextPtr   kdi_context;

    BOOLEAN Paused;
    LIST_ENTRY PauseQueue;
    KSPIN_LOCK PauseQueueSpinLock;

} QICDeviceContext, *QICDeviceContextPtr;


/* PROTOTYPES: **************************************************************/

NTSTATUS 
DriverEntry(
    IN PDRIVER_OBJECT driver_object_ptr,
    IN PUNICODE_STRING registry_path
    );

NTSTATUS 
kdi_DispatchDeviceControl(
    IN    PDEVICE_OBJECT device_object_ptr,
    IN OUT PIRP irp
    );

BOOLEAN 
kdi_Hardware(
    IN PKINTERRUPT interrupt,
    IN PVOID context
    );

VOID 
kdi_DeferredProcedure(
    IN PKDPC dpc,
    IN PVOID deferred_context,
    IN PVOID system_argument_1,
    IN PVOID system_argument_2
    );

VOID 
kdi_UnloadDriver(
    IN PDRIVER_OBJECT driver_object
    );

VOID 
kdi_ThreadRun(
    IN KdiContextPtr kdi_context
    );

IO_ALLOCATION_ACTION 
kdi_AllocateAdapterChannel(
    IN PDEVICE_OBJECT device_object,
    IN PIRP irp,
    IN PVOID map_register_base,
    IN PVOID context
    );

NTSTATUS 
kdi_ConfigCallBack(
    IN PVOID context,
    IN PUNICODE_STRING path_name,
    IN INTERFACE_TYPE bus_type,
    IN ULONG bus_number,
    IN PKEY_VALUE_FULL_INFORMATION *bus_information,
    IN CONFIGURATION_TYPE controller_type,
    IN ULONG controller_number,
    IN PKEY_VALUE_FULL_INFORMATION *controller_information,
    IN CONFIGURATION_TYPE peripheral_type,
    IN ULONG peripheral_number,
    IN PKEY_VALUE_FULL_INFORMATION *peripheral_information
    );

NTSTATUS 
kdi_InitializeDrive(
    IN KdiContextPtr kdi_context,
    IN PVOID cqd_context,
    IN PDRIVER_OBJECT driver_object_ptr,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#if 0
//
// (fcf) kdi_GetControllerBase() does not appear to be used, so I removed it
//       to get rid of the 64bit-related warnings it was generating.
// 
ULONG 
kdi_GetControllerBase(
    IN INTERFACE_TYPE bus_type,
    IN ULONG bus_number,
    IN PHYSICAL_ADDRESS io_address,
    IN ULONG number_of_bytes,
    IN BOOLEAN in_io_space,
    IN PBOOLEAN mapped_address
    );
#endif

NTSTATUS
kdi_TranslateError(
    IN PDEVICE_OBJECT device_object,
    IN NTSTATUS return_value
    );

NTSTATUS 
kdi_ClearIO(
    IN PIRP irp
    );

NTSTATUS 
q117MapStatus(
    IN NTSTATUS status
    );

VOID
q117LogError(
    PDEVICE_OBJECT device_object,
    ULONG sequence_number,
    UCHAR major_function_code,
    UCHAR retry_count,
    ULONG unique_error_value,
    NTSTATUS final_status,
    NTSTATUS specific_IO_status
);

NTSTATUS kdi_FloppyEnabler(
    PDEVICE_OBJECT device_object,
    int ioctl,
    void *data
);


/*****************************************************************************
*
* FILE: KDI_PUB.H
*
* PURPOSE: Prototypes for the functions required by the common driver.
*
*****************************************************************************/

#if DBG

#define DBG_SEEK_FWD        ((ULONG)0x1234566d)
#define DBG_SEEK_REV        ((ULONG)0x1234566f)
#define DBG_SEEK_OFFSET     ((ULONG)0x12345670)
#define DBG_RW_NORMAL       ((ULONG)0x12345671)
#define DBG_SEEK_PHASE      ((ULONG)0x12345672)
#define DBG_L_SECT          ((ULONG)0x12345673)
#define DBG_C_SEG           ((ULONG)0x12345674)
#define DBG_D_SEG           ((ULONG)0x12345675)
#define DBG_C_TRK           ((ULONG)0x12345676)
#define DBG_D_TRK           ((ULONG)0x12345677)
#define DBG_SEEK_ERR        ((ULONG)0x12345678)
#define DBG_IO_TYPE         ((ULONG)0x12345679)
#define DBG_PGM_FDC         ((ULONG)0x1234567a)
#define DBG_READ_FDC        ((ULONG)0x1234567b)
#define DBG_PGM_DMA         ((ULONG)0x1234567c)
#define DBG_SEND_BYTE       ((ULONG)0x1234567d)
#define DBG_RECEIVE_BYTE    ((ULONG)0x1234567e)
#define DBG_IO_CMD_STAT     ((ULONG)0x1234567f)
#define DBG_TIMER_ACK       ((ULONG)0x12345680)
#define DBG_INT_ACK         ((ULONG)0x12345681)
#define DBG_SLEEP           ((ULONG)0x12345682)
#define DBG_WAKEUP          ((ULONG)0x12345683)
#define DBG_ARMINT          ((ULONG)0x12345684)
#define DBG_STATUS          ((ULONG)0x12345685)
#define DBG_READ_BUF        ((ULONG)0x12345686)
#define DBG_WRITE_BUF       ((ULONG)0x12345687)
#define DBG_CALLBACK        ((ULONG)0x12345688)
#define DBG_WAITCC          ((ULONG)0x12345689)
#define DBG_WAITFAULT       ((ULONG)0x1234568a)
#define DBG_FIFO_FDC        ((ULONG)0x1234568b)

extern ULONG kdi_debug_level;

#define KDI_SET_DEBUG_LEVEL(X)    (kdi_debug_level = X)

#else

#define KDI_SET_DEBUG_LEVEL(X)
#define kdi_CheckedDump(X,Y,Z)

#endif


#define MACHINE_TYPE_MASK  0x0F
#define MICRO_CHANNEL      0x01
#define ISA                0x02
#define EISA               0x03
#define PCMCIA             0x04
#define PCI_BUS            0x05
#define CPU_486            0x10

#define DMA_DIR_UNKNOWN    0xff   /* The DMA direction is not currently known */
#define DMA_WRITE          0   /* Program the DMA to write (FDC->DMA->RAM) */
#define DMA_READ           1   /* Program the DMA to read (RAM->DMA->FDC) */

#define NO_ABORT_PENDING    (UCHAR)0xFF
#define ABORT_LEVEL_0       (UCHAR)0
#define ABORT_LEVEL_1       (UCHAR)1

/* Definitions for the bits in the interrupt status/clear register */
#define INTS_FLOP                   0x01    /* Floppy controller interrupt status */

/* Status & control registers */
#define ASIC_INT_STAT           26  /* Interrupt status / clear register */
#define ASIC_DATA_XOR           27  /* data XOR register */


/* DATA TYPES: **************************************************************/

/* Timing values for kdi_Sleep */

#define kdi_wt10us      (ULONG)10l
#define kdi_wt12us      (ULONG)12l
#define kdi_wt500us     (ULONG)500l
#define kdi_wt0ms       (ULONG)0l
#define kdi_wt001ms     (ULONG)1l
#define kdi_wt002ms     (ULONG)2l
#define kdi_wt003ms     (ULONG)3l
#define kdi_wt004ms     (ULONG)4l
#define kdi_wt005ms     (ULONG)5l
#define kdi_wt010ms     (ULONG)10l
#define kdi_wt025ms     (ULONG)25l
#define kdi_wt031ms     (ULONG)31l
#define kdi_wt090ms     (ULONG)90l
#define kdi_wt100ms     (ULONG)100l
#define kdi_wt200ms     (ULONG)200l
#define kdi_wt265ms     (ULONG)265l
#define kdi_wt390ms     (ULONG)390l
#define kdi_wt500ms     (ULONG)500l
#define kdi_wt001s      (ULONG)1000l
#define kdi_wt003s      (ULONG)3000l
#define kdi_wt004s      (ULONG)4000l
#define kdi_wt005s      (ULONG)5000l
#define kdi_wt007s      (ULONG)7000l
#define kdi_wt010s      (ULONG)10000l
#define kdi_wt016s      (ULONG)16000l
#define kdi_wt035s      (ULONG)35000l
#define kdi_wt045s      (ULONG)45000l
#define kdi_wt050s      (ULONG)50000l
#define kdi_wt055s      (ULONG)55000l
#define kdi_wt060s      (ULONG)60000l
#define kdi_wt065s      (ULONG)65000l
#define kdi_wt085s      (ULONG)85000l
#define kdi_wt090s      (ULONG)90000l
#define kdi_wt100s      (ULONG)100000l
#define kdi_wt105s      (ULONG)105000l
#define kdi_wt125s      (ULONG)125000l
#define kdi_wt130s      (ULONG)130000l
#define kdi_wt150s      (ULONG)150000l
#define kdi_wt180s      (ULONG)180000l
#define kdi_wt200s      (ULONG)200000l
#define kdi_wt228s      (ULONG)228000l
#define kdi_wt250s      (ULONG)250000l
#define kdi_wt260s      (ULONG)260000l
#define kdi_wt300s      (ULONG)300000l
#define kdi_wt350s      (ULONG)350000l
#define kdi_wt455s      (ULONG)455000l
#define kdi_wt460s      (ULONG)460000l
#define kdi_wt475s      (ULONG)475000l
#define kdi_wt650s      (ULONG)650000l
#define kdi_wt670s      (ULONG)670000l
#define kdi_wt700s      (ULONG)700000l
#define kdi_wt910s      (ULONG)910000l
#define kdi_wt1300s     (ULONG)1300000l

/* PROTOTYPES: *** ***********************************************************/

VOID 
kdi_ClaimInterrupt(
    IN PVOID kdi_context
    );

NTSTATUS 
kdi_Error(
    IN USHORT  group_and_type,
    IN ULONG   grp_fct_id,
    IN UCHAR   sequence
    );

VOID 
kdi_FlushDMABuffers(
    IN PVOID kdi_context,
    IN BOOLEAN write_operation,
    IN PVOID phy_data_ptr,
    IN ULONG  bytes_transferred_so_far,
    IN ULONG  total_bytes_of_transfer,
    IN BOOLEAN xfer_error
    );

VOID 
kdi_FlushIOBuffers(
    IN PVOID   physical_addr,
    IN BOOLEAN dma_direction,
    IN BOOLEAN flag
    );

USHORT 
kdi_GetErrorType(
    IN NTSTATUS    status
    );

NTSTATUS 
kdi_GetFloppyController(
    IN PVOID kdi_context
    );

UCHAR 
kdi_GetInterfaceType(
    IN PVOID kdi_context
    );


VOID 
kdi_LockUnlockDMA(
    IN PVOID kdi_context,
    IN BOOLEAN lock
    );


VOID 
kdi_ProgramDMA(
    IN     PVOID kdi_context,
    IN     BOOLEAN write_operation,
    IN     PVOID phy_data_ptr,
    IN     ULONG  bytes_transferred_so_far,
    IN OUT PULONG  total_bytes_of_transfer
    );

BOOLEAN 
kdi_QueueEmpty(
    IN PVOID   kdi_context
    );

UCHAR 
kdi_ReadPort(
    IN PVOID kdi_context,
    IN ULONG   address
    );

VOID 
kdi_ReleaseFloppyController(
    IN PVOID kdi_context
    );

BOOLEAN 
kdi_ReportAbortStatus(
    IN PVOID   kdi_context
    );

VOID 
kdi_ResetInterruptEvent(
    IN PVOID kdi_context
    );

VOID 
kdi_ClearInterruptEvent(
    IN PVOID kdi_context
    );

VOID 
kdi_ShortTimer(
    IN USHORT  time
    );

NTSTATUS 
kdi_Sleep(
    IN PVOID   kdi_context,
    IN ULONG   time
    );

BOOLEAN 
kdi_SetDMADirection(
    IN PVOID   kdi_context,
    IN BOOLEAN dma_direction
    );

NTSTATUS 
kdi_FdcDeviceIo(
    IN     PDEVICE_OBJECT DeviceObject,
    IN     ULONG Ioctl,
    IN OUT PVOID Data
    );

BOOLEAN 
kdi_Trakker(
    IN PVOID   kdi_context
    );

BOOLEAN 
kdi_ParallelDriveSlowRate(
    IN PVOID   kdi_context
    );

NTSTATUS 
kdi_CheckXOR(
    IN USHORT  xor_register
    );

VOID 
kdi_PopMaskTrakkerInt(
    );


UCHAR 
kdi_PushMaskTrakkerInt(
    );


NTSTATUS 
kdi_TrakkerXfer(
    IN PVOID       host_data_ptr,
    IN ULONG       trakker_address,
    IN USHORT      count,
    IN UCHAR       direction,
    IN BOOLEAN     in_format
    );

VOID 
kdi_UpdateRegistryInfo(
    IN PVOID kdi_context,
    IN PVOID device_descriptor,
    IN PVOID device_cfg
    );

VOID 
kdi_WritePort(
    IN PVOID kdi_context,
    IN ULONG   address,
    IN UCHAR   byte
    );

#if DBG
VOID 
kdi_CheckedDump(
    IN ULONG       debug_level,
    IN PCHAR       format_str,
    IN ULONG_PTR    argument
    );
#endif

VOID 
kdi_DumpDebug(
   IN PVOID cqd_context
    );

VOID 
kdi_Nuke(
    IN PVOID io_req,
    IN ULONG index,
    IN BOOLEAN destruct
    );

ULONG 
kdi_Rand(
    );

VOID 
kdi_SetFloppyRegisters(
    IN PVOID kdi_context,
    IN ULONG   r_dor,
    IN ULONG   dor
    );

ULONG 
kdi_GetSystemTime(
    );


VOID 
kdi_QIC117ClearIRQ(
    IN PVOID kdi_context
    );

UCHAR
kdi_GetFDCSpeed(
    IN PVOID kdi_context,
    IN UCHAR dma
    );

BOOLEAN
kdi_Grizzly(
    IN PVOID   kdi_context
    );

BOOLEAN 
kdi_Backpack( // a microsolutions chipset
    IN PVOID   kdi_context
    );

NTSTATUS 
kdi_GrizzlyXfer(
    IN PVOID       host_data_ptr,          /* Address of ADI data buffer */
    IN ULONG       grizzly_address,        /* Address of Grizzly RAM buffer */
    IN USHORT      count,                  /* Number of bytes to be transferred */
    IN UCHAR       direction,              /* SEND_DATA or RECEIVE_DATA */
    IN BOOLEAN     in_format,              /* TRUE if performing format operation */
    IN PVOID       kdi_context             /* Ptr to kdi context */
    );

NTSTATUS 
kdi_CloseGrizzly(
    );

/*****************************************************************************
*
* FILE: CQD_PUB.h
*
* PURPOSE: Public KDI->CQD entry points.
*
*****************************************************************************/

/* CQD Function Templates: ****************************************************/

BOOLEAN 
cqd_CheckFormatMode(
    IN PVOID cqd_context
    );

NTSTATUS 
cqd_ClearInterrupt(
    IN PVOID cqd_context,
    IN BOOLEAN expected_interrupt
    );

VOID 
cqd_ConfigureBaseIO(
    IN PVOID cqd_context,
    IN ULONG base_io
    );

BOOLEAN 
cqd_FormatInterrupt(
    IN PVOID cqd_context
    );

VOID 
cqd_InitializeContext(
    IN PVOID cqd_context,
    IN PVOID kdi_context
    );

NTSTATUS 
cqd_LocateDevice(
    IN PVOID cqd_context,
    IN BOOLEAN *vendor_detected
    );

NTSTATUS 
cqd_ProcessFRB(
    IN     PVOID cqd_context,
    IN OUT PVOID frb
    );

VOID 
cqd_ReportAsynchronousStatus(
    IN     PVOID cqd_context,
    IN OUT PVOID dev_op_ptr
    );

USHORT 
cqd_ReportContextSize(
    );

VOID 
cqd_InitializeCfgInformation(
    IN PVOID cqd_context,
    IN PVOID dev_cfg_ptr
    );

/*****************************************************************************
*
* FILE: CQD_DEFS.H
*
* PURPOSE: This file contains all of the defines required by the common driver.
*
****************************************************************************/

// Drive timeing constants 

#define INTERVAL_CMD            kdi_wt031ms
#define INTERVAL_WAIT_ACTIVE    kdi_wt031ms
#define INTERVAL_TRK_CHANGE     kdi_wt007s
#define INTERVAL_LOAD_POINT     kdi_wt670s
#define INTERVAL_SPEED_CHANGE   kdi_wt010s

// Drive firmware revisions 

#define FIRM_VERSION_38         38    // First jumbo A firmware version 
#define FIRM_VERSION_40         40    // Last jumbo A firmware version 
#define FIRM_VERSION_60         60    // First jumbo B firmware version 
#define FIRM_VERSION_63         63    // Cart in problems 
#define FIRM_VERSION_64         64    // First Firmware version to support Skip_n_Seg through the Erase Gap 
#define FIRM_VERSION_65         65    // First Firmware version to support Pegasus 
#define FIRM_VERSION_80         80    // First Firmware version to support Jumbo c 
#define FIRM_VERSION_87         87    // First Firmware revision to support QIC-117 C 
#define FIRM_VERSION_88         88    // First Firmware revision to support no reverse seek slop 
#define FIRM_VERSION_110        110   // First Firmware version to support Eagle 
#define FIRM_VERSION_112        112   // First Firmware version to support QIC-117 E 
#define FIRM_VERSION_128        128   // First Firmware version to support set n segments in qic 80 
#define PROTOTYPE_BIT           0x80  // 8th bit in the firmware is prototype flag 

// Drive status bit masks 

#define STATUS_READY            (UCHAR)0x01
#define STATUS_ERROR            (UCHAR)0x02
#define STATUS_CART_PRESENT     (UCHAR)0x04
#define STATUS_WRITE_PROTECTED  (UCHAR)0x08
#define STATUS_NEW_CART         (UCHAR)0x10
#define STATUS_CART_REFERENCED  (UCHAR)0x20
#define STATUS_BOT              (UCHAR)0x40
#define STATUS_EOT              (UCHAR)0x80


// Drive config bit masks 

#define CONFIG_QIC80        (UCHAR)0x80
#define CONFIG_XL_TAPE      (UCHAR)0x40
#define CONFIG_SPEED        (UCHAR)0x38
#define CONFIG_250KBS       (UCHAR)0x00
#define CONFIG_500KBS       (UCHAR)0x10
#define CONFIG_1MBS         (UCHAR)0x18
#define CONFIG_2MBS         (UCHAR)0x08
#define XFER_RATE_MASK      (UCHAR)0x18
#define XFER_RATE_SHIFT     (UCHAR)0x03

// CMS proprietary status bit masks 

#define CMS_STATUS_NO_BURST_SEEK    (UCHAR)0x01
#define CMS_STATUS_CMS_MODE         (UCHAR)0x02
#define CMS_STATUS_THRESHOLD_LOAD   (UCHAR)0x04
#define CMS_STATUS_DENSITY          (UCHAR)0x08
#define CMS_STATUS_BURST_ONLY_GAIN  (UCHAR)0x10
#define CMS_STATUS_PEGASUS_CART     (UCHAR)0x20
#define CMS_STATUS_EAGLE            (UCHAR)0x40


#define CMS_STATUS_DRIVE_MASK   (UCHAR)0x48

#define CMS_STATUS_QIC_40   (UCHAR)0x08
#define CMS_STATUS_QIC_80   (UCHAR)0x00


// Tape Types 

#define QIC40_SHORT         (UCHAR)1    // normal length cart (205 ft) 
#define QIC40_LONG          (UCHAR)2    // extended length cart (310 ft) 
#define QICEST_40           (UCHAR)3    // QIC-40 formatted tape (1100 ft) 
#define QIC80_SHORT         (UCHAR)4    // QIC-80 format 205 ft tape 
#define QIC80_LONG          (UCHAR)5    // QIC-80 format 310 ft tape 
#define QICEST_80           (UCHAR)6    // QIC-80 formatted tape (1100 ft) 
#define QIC3010_SHORT       (UCHAR)7    // QIC-3010 formatted tape 
#define QICEST_3010         (UCHAR)8    // QIC-3010 formatted tape (1100 ft) 
#define QICFLX_3010         (UCHAR)9    // QIC-3010 formatted tape (Flexible length) 
#define QIC3020_SHORT       (UCHAR)9    // QIC-3020 formatted tape 
#define QICEST_3020         (UCHAR)10   // QIC-3020 formatted tape (1100 ft) 
#define QICFLX_3020         (UCHAR)11   // QIC-3020 formatted tape (Flexible length) 
#define QIC40_XLONG         (UCHAR)12   // QIC-40 format 425 ft tape 
#define QIC80_XLONG         (UCHAR)13   // QIC-80 format 425 ft tape 
#define QICFLX_80W          (UCHAR)14   // QIC-80W formatted tape (Flexible length) 
#define QIC80_EXLONG        (UCHAR)15   // QIC-80 format 1000 ft tape 
#define QICFLX_3010_WIDE    (UCHAR)16   // QIC-3010 formatted tape (Flexible length) Wide tape 
#define QICFLX_3020_WIDE    (UCHAR)17   // QIC-3020 formatted tape (Flexible length) Wide tape 


// EQU's for QIC-40 firmware commands 

#define FW_CMD_SOFT_RESET               (UCHAR)1    // soft reset of tape drive 
#define FW_CMD_RPT_NEXT_BIT             (UCHAR)2    // report next bit (in report subcontext) 
#define FW_CMD_PAUSE                    (UCHAR)3    // pause tape motion 
#define FW_CMD_MICRO_PAUSE              (UCHAR)4    // pause and microstep the head 
#define FW_CMD_ALT_TIMEOUT              (UCHAR)5    // set alternate command timeout 
#define FW_CMD_REPORT_STATUS            (UCHAR)6    // report drive status 
#define FW_CMD_REPORT_ERROR             (UCHAR)7    // report drive error code 
#define FW_CMD_REPORT_CONFG             (UCHAR)8    // report drive configuration 
#define FW_CMD_REPORT_ROM               (UCHAR)9    // report ROM version 
#define FW_CMD_RPT_SIGNATURE            (UCHAR)9    // report drive signature (model dependant diagnostic mode) 
#define FW_CMD_LOGICAL_FWD              (UCHAR)10   // move tape in logical forward mo 
#define FW_CMD_PHYSICAL_REV             (UCHAR)11   // move tape in physical reverse mode 
#define FW_CMD_PHYSICAL_FWD             (UCHAR)12   // move tape in physical forward mode 
#define FW_CMD_SEEK_TRACK               (UCHAR)13   // seek head to track position 
#define FW_CMD_SEEK_LP                  (UCHAR)14   // seek load poSWord 
#define FW_CMD_FORMAT_MODE              (UCHAR)15   // enter format mode 
#define FW_CMD_WRITE_REF                (UCHAR)16   // write reference burst 
#define FW_CMD_VERIFY_MODE              (UCHAR)17   // enter verify mode 
#define FW_CMD_PARK_HEAD                (UCHAR)17   // park head (model dependant diagnostic mode) 
#define FW_CMD_TOGGLE_PARAMS            (UCHAR)17   // toggle internal modes (model dependant diagnostic mode) 
#define FW_CMD_STOP_TAPE                (UCHAR)18   // stop the tape 
#define FW_CMD_READ_NOISE_CODE          (UCHAR)18   // check noise on drive (model dependent diagnostic mode) 
#define FW_CMD_MICROSTEP_UP             (UCHAR)21   // microstep head up 
#define FW_CMD_DISABLE_WP               (UCHAR)21   // disable write protect line (model dependent diagnostic mode) 
#define FW_CMD_MICROSTEP_DOWN           (UCHAR)22   // microstep head down 
#define FW_CMD_SET_GAIN                 (UCHAR)22   // set absolute drive gain (model dependant diagnostic mode) 
#define FW_CMD_READ_PORT2               (UCHAR)23   // read the drive processor port 2 (diagnostic command) 
#define FW_CMD_REPORT_VENDOR            (UCHAR)24   // report vendor number 
#define FW_CMD_SKIP_N_REV               (UCHAR)25   // skip n segments reverse 
#define FW_CMD_SKIP_N_FWD               (UCHAR)26   // skip n segments forward 
#define FW_CMD_SELECT_SPEED             (UCHAR)27   // select tape speed 
#define FW_CMD_DIAG_1_MODE              (UCHAR)28   // enter diagnostic mode 1 
#define FW_CMD_DIAG_2_MODE              (UCHAR)29   // enter diagnostic mode 2 
#define FW_CMD_PRIMARY_MODE             (UCHAR)30   // enter primary mode 
#define FW_CMD_REPORT_VENDOR32          (UCHAR)32   // report vendor number (for firmware versions > 33) 
#define FW_CMD_REPORT_TAPE_STAT         (UCHAR)33   // reports the tape format of the currently loaded tape 
#define FW_CMD_SKIP_N_REV_EXT           (UCHAR)34   // skip n segments reverse (extended format) 
#define FW_CMD_SKIP_N_FWD_EXT           (UCHAR)35   // skip n segments forward (extended format) 
#define FW_CMD_CAL_TAPE_LENGTH          (UCHAR)36   // Determine the number of seg/trk available on the tape 
#define FW_CMD_REPORT_TAPE_LENGTH       (UCHAR)37   // Report the number of seg/trk available on the tape 
#define FW_CMD_SET_FORMAT_SEGMENTS      (UCHAR)38   // Set the number of segments the drive shall use for generating index pulses 
#define FW_CMD_RPT_CMS_STATUS           (UCHAR)37   // report CMS status byte (model dependant - diagnostic mode) 
#define FW_CMD_SET_RAM_HIGH             (UCHAR)40   // set the high nibble of the ram 
#define FW_CMD_SET_RAM_LOW              (UCHAR)41   // set the low nibble of the ram 
#define FW_CMD_SET_RAM_PTR_HIGH         (UCHAR)42   // set the high nibble of the ram address 
#define FW_CMD_SET_RAM_PTR_LOW          (UCHAR)43   // set the low nibble of the ram address 
#define FW_CMD_READ_RAM                 (UCHAR)44   // read tape drive RAM 
#define FW_CMD_NEW_TAPE                 (UCHAR)45   // load tape sequence 
#define FW_CMD_SELECT_DRIVE             (UCHAR)46   // select the tape drive 
#define FW_CMD_DESELECT_DRIVE           (UCHAR)47   // deselect the tape drive 
#define FW_CMD_REPORTPROTOVER           (UCHAR)50   // reports firmware prototype version number (model dependant - diagnostic mode) 
#define FW_CMD_DTRAIN_INFO              (UCHAR)53   // enter Drive Train Information mode (model dependant - diagnostic mode) 
#define FW_CMD_GDESP_INFO               (UCHAR)5     // display drive train information 
#define FW_CMD_CONNER_SELECT_1          (UCHAR)23   // Mountain select byte 1 
#define FW_CMD_CONNER_SELECT_2          (UCHAR)20   // Mountain select byte 2 
#define FW_CMD_CONNER_DESELECT          (UCHAR)24   // Mountain deselect byte 
#define FW_CMD_RPT_CONNER_NATIVE_MODE   (UCHAR)40   // Conner Native Mode diagnostic command 
#define FW_CMD_CMS_MODE_OLD             (UCHAR)32   // toggle CMS mode (model dependant - diagnostic mode) 

// Floppy Disk Command Bit defines 
#define FIFO_MASK           (UCHAR)0x0f    // Mask for FIFO threshold field in config cmd 
#define FDC_EFIFO           (UCHAR)0x20    // Mask for disabling FIFO in config cmd 
#define FDC_CLK48           (UCHAR)0x80    // Bit of config command that enables 48Mhz clocks on 82078 
#define FDC_PRECOMP_ON      (UCHAR)0x00    // Mask for enabling write precomp 
#define FDC_PRECOMP_OFF     (UCHAR)0x1C    // Mask for disabling write precomp 

// Floppy Disk Controller I/O Ports 

#define FDC_NORM_BASE   (ULONG)0x000003f0     // base for normal floppy controller 
#define DCR_OFFSET      (ULONG)0X00000007     // Digital control register offset 
#define DOR_OFFSET      (ULONG)0X00000002     // Digital-output Register offset 
#define RDOR_OFFSET     (ULONG)0X00000002     // Digital-output Register offset 
#define MSR_OFFSET      (ULONG)0X00000004     // Main Status Register offset 
#define DSR_OFFSET      (ULONG)0X00000004     // Data Rate Select Register offset 
#define TDR_OFFSET      (ULONG)0X00000003     // Tape drive register offset 
#define DR_OFFSET       (ULONG)0X00000005     // Data Register offset 
#define DUAL_PORT_MASK  (ULONG)0x00000080     

// Floppy Disk Port constants 

// normal drive B 
#define curb                1
#define selb                0x2d    // 00101101: motor B + enable DMA/IRQ/FDC + sel B 
#define dselb               0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 
// unselected drive 
#define curu                0
#define selu                0x0d    // 00001101: enable DMA/IRQ/FDC + sel B 
#define dselu               0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 
// normal drive D 
#define curd                3
#define seld                0x8f    // 10001111: motor D + enable DMA/IRQ/FDC + sel D 
#define dseld               0x0e    // 00001110  motor D + enable DMA/IRQ/FDC + sel C 
// laptop unselected drive 
#define curub               0
#define selub               0x2d    // 00101101: motor B + enable DMA/IRQ/FDC + sel B 
#define dselub              0x0c    // 00001100: enable DMA/IRQ/FDC + sel A 

#define alloff              0x08    // no motor + enable DMA/IRQ + disable FDC + sel A 
#define fdc_idle            0x0c    // no motor + enable DMA/IRQ/FDC + sel A 

#define DRIVE_ID_MASK       0x03
#define DRIVE_SELECT_OFFSET 0x05
#define DRIVE_SPECIFICATION 0x8E
#define DRIVE_SPEC          0x08
#define DONE_MARKER         0xC0

// Floppy configuration parameters 

#define FMT_DATA_PATTERN    0x6b    // Format data pattern 
#define FDC_FIFO            15      // FIFO size for an 82077 
#define FDC_HLT             0x02    // FDC head load time 
#define FMT_GPL             233     // gap length for format (QIC-40 QIC-80) 
#define FMT_GPL_3010        241     // gap length for format (QIC-3010) 
#define FMT_GPL_3020        248     // gap length for format (QIC-3020) 
#define WRT_GPL             1       // gap length for write (QIC-40 QIC-80 QIC-3010 QIC-3020) 
#define FMT_BPS             03      // bytes per sector for formatting(1024) 
#define WRT_BPS             FMT_BPS // bytes per sector for reading/writing (1024) 
#define FSC_SEG             32      // floppy sectors per segment (QIC-40 205ft & 310ft) 
#define SEG_FTK             4       // segments per floppy track (QIC-40 205ft & 310ft) 
#define FSC_FTK             (FSC_SEG*SEG_FTK)    // floppy sectors per floppy track (QIC-40 205ft & 310ft) 
#define SEG_TTRK_40         68      // segments per tape track (QIC-40 205ft) 
#define SEG_TTRK_40L        102     // segments per tape track (QIC-40 310ft) 
#define SEG_TTRK_40XL       141     // segments per tape track (QIC-40 425ft) 
#define SEG_TTRK_80         100     // segments per tape track (QIC-80 205ft) 
#define SEG_TTRK_80L        150     // segments per tape track (QIC-80 310ft) 
#define SEG_TTRK_80W        365     // segments per tape track (QIC-80 310ft) 
#define SEG_TTRK_80XL       207     // segments per tape track (QIC-80 425ft) 
#define SEG_TTRK_80EX       490     // segments per tape track (QIC-80 1000ft) 
#define SEG_TTRK_QICEST_40  365     // segments per tape track (QIC-40 QICEST) 
#define SEG_TTRK_QICEST_80  537     // segments per tape track (QIC-80 QICEST) 
#define SEG_TTRK_3010       800     // segments per tape track (QIC-3010 1000ft) 
#define SEG_TTRK_3020       1480    // segments per tape track (QIC-3020 1000ft) 
#define SEG_TTRK_3010_400ft 300     // segments per tape track (QIC-3010 400ft) 
#define SEG_TTRK_3020_400ft 422     // segments per tape track (QIC-3020) 



#define FTK_FSD_40          170     // floppy tracks per floppy side (QIC-40 205ft)     
#define FTK_FSD_40L         255     // floppy tracks per floppy side (QIC-40 310ft)     
#define FTK_FSD_40XL        170     // floppy tracks per floppy side (QIC-40 425ft)     
#define FTK_FSD_80          150     // floppy tracks per floppy side (QIC-80 205ft)     
#define FTK_FSD_80L         150     // floppy tracks per floppy side (QIC-80 310ft)     
#define FTK_FSD_80XL        150     // floppy tracks per floppy side (QIC-80 425ft)     
#define FTK_FSD_QICEST_40   254     // floppy tracks per floppy side (QIC-40 QICEST)    
#define FTK_FSD_QICEST_80   254     // floppy tracks per floppy side (QIC-80 QICEST)    
#define FTK_FSD_FLEX80      255     // floppy tracks per floppy side (QIC-80 Flexible)  
#define FTK_FSD_3010        255     // floppy tracks per floppy side (QIC-3010)         
#define FTK_FSD_3020        255     // floppy tracks per floppy side (QIC-3020)         

#define NUM_TTRK_40         20      // number of tape tracks (QIC-40 205ft & 310ft) 
#define NUM_TTRK_80         28      // number of tape tracks (QIC-40 205ft & 310ft) 
#define NUM_TTRK_80W        36      // 
#define NUM_TTRK_3010       40      // number of tape tracks (QIC-3010) 
#define NUM_TTRK_3020       40      // number of tape tracks (QIC-3020) 
#define NUM_TTRK_3010W      50      // number of tape tracks (QIC-3010 wide) 
#define NUM_TTRK_3020W      50      // number of tape tracks (QIC-3020 wide) 
#define PHY_SECTOR_SIZE     (USHORT)1024    // number of bytes per sector 
#define ECC_SEG             (UCHAR)3        // ecc sectors per segment 
#define MAX_FDC_SEEK        (USHORT)128


// Tape Format Types and lengths/Coercivity 


#define QIC_UNKNOWN         0       // Unknown Tape Format and Length 
#define QIC_40              1       // QIC-40 Tape Format 
#define QIC_80              2       // QIC-80 Tape Format 
#define QIC_3020            3       // QIC-3020 Tape Format 
#define QIC_3010            4       // QIC-3010 Tape Format 

#define QIC_SHORT           1       // Length = 205 & Coercivity = 550 Oe 
                                                // or Length = 425 & Coercivity = 550 Oe 
#define QIC_LONG            2       // Length = 307.5 & Coercivity = 550 Oe 
#define QIC_SHORT_900       3       // Length = 295 & Coercivity = 900 Oe 
#define QICEST              4       // Length = 1100 & Coercivity = 550 Oe 
#define QICEST_900          5       // Length = 1100 & Coercivity = 900 Oe 
#define QIC_FLEXIBLE_550_WIDE  0x0B    // Flexible format tape 550 Oe Wide tape 
#define QIC_FLEXIBLE_900       6       // Flexible format tape 900 Oe 
#define QIC_FLEXIBLE_900_WIDE  0x0E    // Flexible format tape 900 Oe Wide tape 

// Floppy disk controller misc constants 

// 82077 version number 
#define VALID_NEC_FDC           0x90    // version number 
#define NSC_PRIMARY_VERSION     0x70    // National 8477 verion number 
#define NSC_MASK                0xF0    // mask for National version number 
#define FDC_82078_44_MASK       0x40    // mask for 82078 44 pin part id 
#define FDC_DCR_MASK            0x03    // mask for fdc's configuration control register xfer rates 
#define FDC_CONFIG_NULL_BYTE    0x00
#define FDC_CONFIG_PRETRACK     0x00

// main status register 
#define MSR_RQM     0x80    // request for master 
#define MSR_DIO     0x40    // data input/output (0=input, 1=output) 
#define MSR_EXM     0x20    // execution mode 
#define MSR_CB      0x10    // FDC busy 
#define MSR_D3B     0x08    // FDD 3 busy 
#define MSR_D2B     0x04    // FDD 2 busy 
#define MSR_D1B     0x02    // FDD 1 busy 
#define MSR_D0B     0x01    // FDD 0 busy 

// status register 0 
#define ST0_IC      0xC0    // Interrupt code (00=Normal, 01=Abnormal, 10=Illegal cmd, 11=Abnormal) 
#define ST0_SE      0x20    // Seek end 
#define ST0_EC      0x10    // Equipment check 
#define ST0_NR      0x08    // Not Ready 
#define ST0_HD      0x04    // Head Address 
#define ST0_US      0x03    // Unit Select (0-3) 

// status register 1 
#define ST1_EN      0x80    // End of Cylinder 
#define ST1_DE      0x20    // Data Error (CRC error) 
#define ST1_OR      0x10    // Over Run 
#define ST1_ND      0x04    // No Data 
#define ST1_NW      0x02    // Not Writable (write protect error) 
#define ST1_MA      0x01    // Missing Address Mark 

// status register 2 
#define ST2_CM      0x40    // Control Mark (Deleted Data Mark) 
#define ST2_DD      0x20    // Data Error in Data Field 
#define ST2_WC      0x10    // Wrong Cylinder 
#define ST2_SH      0x08    // Scan Equal Hit 
#define ST2_SN      0x04    // Scan Not Satisfied 
#define ST2_BC      0x02    // Bad Cylinder 
#define ST2_MD      0x01    // Missing Address Mark in Data Field 

// status register 3 
#define ST3_FT      0x80    // Fault 
#define ST3_WP      0x40    // Write Protected 
#define ST3_RY      0x20    // Ready 
#define ST3_T0      0x10    // Track 0 
#define ST3_TS      0x08    // Two Side 
#define ST3_HD      0x04    // Head address 
#define ST3_US      0x03    // Unit Select (0-3) 

// Misc. constants 

#define FWD                 0       // seek in the logical forward direction 
#define REV                 1       // seek in the logical reverse direction 
#define STOP_LEN            5       // approximate number of blocks used to stop the tape 
#define SEEK_SLOP           3       // number of blocks to overshoot at high speed in a seek 
#define SEEK_TIMED          0x01    // Perform a timed seek 
#define SEEK_SKIP           0x02    // perform a skip N segemnts seek 
#define SEEK_SKIP_EXTENDED  0x03    // perform an extended skip N segemnts seek 

// number of blocks to overshoot when performing a high speed reverve seek 
#define QIC_REV_OFFSET      3
#define QIC_REV_OFFSET_L    4
#define QICEST_REV_OFFSET   14
#define MAX_SKIP            255     // Max number of segments that a Skip N Segs command can skip 
#define MAX_SEEK_NIBBLES    3       // Maximum number of nibbles in an extended mode seek 

#define TRACK_0             (UCHAR)0
#define TRACK_5             (UCHAR)5
#define TRACK_7             (UCHAR)7
#define TRACK_9             (UCHAR)9
#define TRACK_11            (UCHAR)11
#define TRACK_13            (UCHAR)13
#define TRACK_15            (UCHAR)15
#define TRACK_17            (UCHAR)17
#define TRACK_19            (UCHAR)19
#define TRACK_21            (UCHAR)21
#define TRACK_23            (UCHAR)23
#define TRACK_25            (UCHAR)25
#define TRACK_27            (UCHAR)27
#define ILLEGAL_TRACK       (USHORT)0xffff
#define ODD_TRACK           (USHORT)0x0001
#define EVEN_TRACK          (USHORT)0x0000
#define ALL_BAD             (ULONG)0xffffffff
#define QIC3010_OFFSET      (ULONG)2
#define QIC3020_OFFSET      (ULONG)4

#define NUM_BAD             10      // number of bad READ ID's in row for no_data error 
#define OR_TRYS             10      // number of Over Runs ignored per block (system 50) 

#define PRIMARY_MODE        0       // tape drive is in primary mode 
#define FORMAT_MODE         1       // tape drive is in format mode 
#define VERIFY_MODE         2       // tape drive is in verify mode 
#define DIAGNOSTIC_1_MODE   3       // tape drive is in diagnostic mode 1 
#define DIAGNOSTIC_2_MODE   4       // tape drive is in diagnostic mode 2 

#define READ_BYTE           8       // Number of Bytes to receive from the tape 
#define READ_WORD           16      //  drive during communication. 

#define HD_SELECT           0x01    // High Density Select bit from the PS/2 DCR 


#define TAPE_250Kbps        0       // Program drive for 250 Kbps transfer rate 
#define TAPE_2Mbps          1       // Program drive for 2Mbps transfer rate 
#define TAPE_500Kbps        2       // Program drive for 500 Kbps transfer rate 
#define TAPE_1Mbps          3       // Program drive for 1 Mbps transfer rate 
#define FDC_250Kbps         2       // Program FDC for 250 Kbps transfer rate 
#define FDC_500Kbps         0       // Program FDC for 500 Kbps transfer rate 
#define FDC_1Mbps           3       // Program FDC for 1 Mbps transfer rate 
#define FDC_2Mbps           1       // Program FDC for 2 Mbps transfer rate 
#define SRT_250Kbps         0xff    // FDC step rate for 250 Kbps transfer rate 
#define SRT_500Kbps         0xef    // FDC step rate for 500 Kbps transfer rate 
#define SRT_1Mbps           0xcf    // FDC step ratefor 1 Mbps transfer rate 
#define SRT_2Mbps           0x8f    // FDC step rate for 2 Mbps transfer rate 
#define SPEED_MASK          0x03    // FDC speed mask for lower bits 
#define FDC_2MBPS_TABLE     2       // 2 Mbps data rate table for the 82078 


#define CMS_SIG             0xa5    // drive signature for CMS drives 
#define CMS_VEND_NO_OLD     0x0047  // CMS vendor number old 
#define CMS_VEND_NO_NEW     0x11c0  // CMS vendor number new 
#define CMS_QIC40           0x0000  // CMS QIC40 Model # 
#define CMS_QIC80           0x0001  // CMS QIC80 Model # 
#define CMS_QIC3010         0x0002  // CMS QIC3010 Model # 
#define CMS_QIC3020         0x0003  // CMS QIC3020 Model # 
#define CMS_QIC80_STINGRAY  0x0004  // CMS QIC80 STINGRAY Model # 
#define CMS_QIC80W          0x0005  // CMS QIC80W Model # 
#define CMS_TR3             0x0006  // CMS TR3 Model # 
#define EXABYTE_VEND_NO     0x0380  // Summit vendor number 
#define SUMMIT_VEND_NO      0x0180  // Summit vendor number 
#define IOMEGA_VEND_NO      0x8880  // Iomega vendor number 
#define WANGTEK_VEND_NO     0x01c0  // Wangtek vendor number 
#define TECHMAR_VEND_NO     0x01c0  // Techmar vendor number 
#define CORE_VEND_NO        0x0000  // Core vendor number 
#define CONNER_VEND_NO_OLD  0x0005  // Conner vendor number (old mode) 
#define CONNER_VEND_NO_NEW  0x0140  // Conner vendor number (new mode) 
#define VENDOR_MASK         0xffc0  // Vendor id mask 
#define IOMEGA_QIC80        0x0000  // Iomega QIC80 Model # 
#define IOMEGA_QIC3010      0x0001  // Iomega QIC3010 Model # 
#define IOMEGA_QIC3020      0x0002  // Iomega QIC3020 Model # 
#define SUMMIT_QIC80        0x0001  // Summit QIC80 Model # 
#define SUMMIT_QIC3010      0x0015  // Summit QIC 3010 Model # 
#define WANGTEK_QIC80       0x000a  // Wangtek QIC80 Model # 
#define WANGTEK_QIC40       0x0002  // Wangtek QIC40 Model # 
#define WANGTEK_QIC3010     0x000C  // Wangtek QIC3010 Model # 
#define CORE_QIC80          0x0021  // Core QIC80 Model # 
#define TEAC_VEND_NO        0x03c0  // TEAC vendor number 
#define TEAC_TR1            0x000e  // TEAC TR-1 Model 
#define TEAC_TR2            0x000f  // TEAC TR-2 Model 
#define GIGATEC_VEND_NO     0x0400
#define COMBYTE_VEND_NO     0x0440
#define PERTEC_VEND_NO      0x0480
#define PERTEC_TR1          0x0001  // TR-1 drive 
#define PERTEC_TR2          0x0002  // TR-2 drive 
#define PERTEC_TR3          0x0003  // TR-3 drive 

// Conner Native mode defines 

#define CONNER_500KB_XFER   0x0400  // 500 KB xfer rate 
#define CONNER_1MB_XFER     0x0800  // 1 MB xfer rate 
#define CONNER_20_TRACK     0x0001  // Drive supports 20 tracks 
#define CONNER_28_TRACK     0x000e  // Drive supports 28 tracks 
#define CONNER_40_TRACK     0x0020  // Drive supports 40 tracks 
#define CONNER_MODEL_5580   0x0002  // Conner Model 5580 series (Hornet) 
#define CONNER_MODEL_XKE    0x0004  // Conner 11250 series (1" drives) XKE 
#define CONNER_MODEL_XKEII  0x0008  // Conner 11250 series (1" drives) XKEII 


#define FDC_INVALID_CMD         0x80    // invalid cmd sent to FDC returns this value 
#define RTIMES                  3       // times to retry on a read of a sector (retry mode) 
#define NTIMES                  2       // times to retry on a read of a sector (normaly) 
#define WTIMES                  10      // times to retry on a write of a sector 
#define VTIMES                  0       // times to retry on verify 
#define ANTIMES                 0
#define ARTIMES                 6
#define DRIVE_SPEC_SAVE         2       // sizeof the drive spec save command 
#define INTEL_MASK              0xe0
#define INTEL_44_PIN_VERSION    0x40
#define INTEL_64_PIN_VERSION    0x00

#define FIND_RETRIES        2
#define REPORT_RPT          6       // Number of times to attempt drive communication when 
                                    //  an ESD induced error is suspected. 

//
//   Kurt changed the timeout count for program/read nec from 40 to 20000
//   This was done because the kdi_ShortTimer was removed from these routines
//   Microsoft's floppy driver does NOT use a timer and works,  so
//   this fix is being tested in M8 Windows 95 beta.  If it does not work,
//   then we probably need to change it back (see read/program NEC).

#define FDC_MSR_RETRIES     50  // Number of times to read the FDC Main 

#define DRIVEA              0
#define DRIVEB              1
#define DRIVEC              2
#define DRIVED              3
#define DRIVEU              4
#define DRIVEUB             5

#define DISABLE_PRECOMP     1       // Value used by the 82078's Drive Spec 
                                    // command to disable Precomp 

#define FDC_BOOT_MASK     0x06      // Mask used to isolate the Boot Select 
                                    // Bits in the TDR Register 

#define MAX_SEEK_COUNT_SKIP 10
#define MAX_SEEK_COUNT_TIME 10

#define WRITE_REF_RPT       2

#define _DISK_RESET         0

#define WRITE_PROTECT_MASK  0x20    // bit from byte from port 2 of the jumbo B
                                    // processor that indicates write protect 

// Constants for sense_speed algorithm 
// These ranges are based on 1.5 sec @ 250kb.  The units are 54.95ms (1 IBM PC 
// timer tick (18.2 times a second)) and are +-1 tick from nominal due to time 
// base fluctuation (in FDC and IBM PC TIMER). 
// The threshold for the 750kb transfer rate is < 11 ticks due to the 
// uncertaSWordy of this future transfer rate. 
// If a transfer rate of 750kb is needed code MUST be added to verify that 
// 750kb does exist 

#define sect_cnt            35      // .04285 sec. per sector * 35 = 1.4997 sec. 
#define MIN1000             0
#define MAX1000             11
#define MIN500              12
#define MAX500              15
#define MIN250              26
#define MAX250              29

// Array indices and size for the time_out array. The time out array contains the  * 
// time outs for the QIC-117 commands. 
#define L_SLOW          0
#define L_FAST          1
#define PHYSICAL        2
#define TIME_OUT_SIZE   3

// Constants for the arrays defined in the S_O_DGetInfo structure 
#define OEM_LENGTH              20
#define SERIAL_NUM_LENGTH       4
#define MAN_DATE_LENGTH         2
#define PEGASUS_START_DATE      517
#define PLACE_OF_ORIGIN_LENGTH  2

// Constant for the array dimension used in q117i_HighSpeedSeek 
#define  FOUR_NIBS  4

// Constants for identifing bytes in a word array 
#define LOW_BYTE    0
#define HI_BYTE     1

#define DCOMFIRM_MAX_BYTES          10  // Max number of SBytes in a DComFirm string 
#define FDC_ISR_RESET_THRESHOLD     20

#define SINGLE_BYTE     (UCHAR)0x01     
#define REPORT_BYTE     (UCHAR)0x08     // Number of Bits to receive from the tape  
#define REPORT_WORD     (UCHAR)0x10     // drive during communication.                  
#define DATA_BIT        (USHORT)0x8000  // data bit to or into the receive word 
#define SINGLE_SHIFT    (USHORT)0x0001  // number of bits to shift the receive data when adding a bit 
#define NIBBLE_SHIFT    (USHORT)0x0004  // number of bits to shift the receive data when adding a bit 
#define BYTE_SHIFT      (USHORT)0x0008  // number of bits to shift the receive data when size is byte 
#define NIBBLE_MASK     (USHORT)0x000f
#define BYTE_MASK       (USHORT)0x00ff  // byte mask 
#define SEGMENT_MASK    0x1f


// Various addresses used as arguments in the set ram command for the Sankyo 
// motor fix hack 
#define DOUBLE_HOLE_CNTR_ADDRESS    0x5d
#define HOLE_FLAG_BYTE_ADDRESS      0x48
#define TAPE_ZONE_ADDRESS           0x68

// Miscellaneous defines used in the Sankyo Motor fix hack 
#define REVERSE                 0
#define FORWARD                 1
#define HOLE_INDICATOR_MASK     0X40
#define EOT_ZONE_COUNTER        0x29
#define BOT_ZONE_COUNTER        0x23

#define FDC_TDR_MASK        0x03        // mask for 82077aa tdr test 
#define FDC_REPEAT          0x04        // number of times to loop through the tdr test 
#define CMD_OFFSET          (UCHAR)0x02
#define MAX_FMT_NIBBLES     3
#define MAX_FDC_STATUS      16
#define CLOCK_48            (UCHAR)0x80

// Toggle parameter command arguements 
#define WRITE_EQ                    0
#define AUTO_FILTER_PROG            1
#define AGC_ENABLE                  2
#define DISABLE_FIND_BOT            3
#define WRITE_DATA_DELAY_ENABLE     4
#define REF_HEAD_ON_AUTOLOAD        5
#define DRIVE_CLASS                 6
#define CUE_INDEX_PULSE_SHUTOFF     7
#define CMS_MODE                    8

#define SEG_LENGTH_80W          (ULONG)246  // unit in inches * 10 
#define SEG_LENGTH_3010         (ULONG)165  // unit in inches * 10 
#define SEG_LENGTH_3020         (ULONG)84   // unit in inches * 10 
#define SPEED_SLOW_30n0         (ULONG)226
#define SPEED_FAST_30n0         (ULONG)452
#define SPEED_PHYSICAL_30n0     (ULONG)900
#define SPEED_TOLERANCE         (ULONG)138
#define SPEED_FACTOR            (ULONG)100
#define SPEED_ROUNDING_FACTOR   (ULONG)50


// Perpendicular mode setup values 

#define PERP_OVERWRITE_ON   (UCHAR)0x80
#define PERP_WGATE_ON       (UCHAR)0x01
#define PERP_GAP_ON         (UCHAR)0x02
#define PERP_SELECT_SHIFT   (UCHAR)0x02

// Misc format defines 

#define HDR_1               (USHORT)0
#define HDR_2               (USHORT)1
#define MAX_HDR_BLOCKS      (USHORT)2
#define CQD_DMA_PAGE_SIZE   (ULONG)0x00000800

// Select Format defines, from QIC117 spec, command 27 

#define SELECT_FORMAT_80            (UCHAR)0x09
#define SELECT_FORMAT_80W           (UCHAR)0x0b
#define SELECT_FORMAT_3010          (UCHAR)0x11
#define SELECT_FORMAT_3010W         (UCHAR)0x13
#define SELECT_FORMAT_3020          (UCHAR)0x0d
#define SELECT_FORMAT_3020W         (UCHAR)0x0f
#define SELECT_FORMAT_UNSUPPORTED   (UCHAR)0x00


// Issue Diagnostic defines 
#define DIAG_WAIT_CMD_COMPLETE      (UCHAR)0xff
#define DIAG_WAIT_INTERVAL          (UCHAR)0xfe
#define DIAG_NO_PAUSE_RECEIVE       (UCHAR)0xfd

/****************************************************************************
*
* FILE: CQD_STRC.H
*
* PURPOSE: This file contains all of the structures
*                   required by the common driver.
*
*****************************************************************************/

#pragma pack(1)

typedef struct _TAPE_FORMAT_LENGTH {
    UCHAR format;           // Format of the tape 
    UCHAR length;           // Length of the tape 
} TAPE_FORMAT_LENGTH, *PTAPE_FORMAT_LENGTH;


//                                                                                                          
//   Commands to the Floppy Controller.  FDC commands and the corresponding         
//    driver structures are listed below.                                                   
//                                                                                                          
//         FDC Command                     Command Struct      Response Struct  
//         -----------                     --------------      ---------------  
//         Read Data                       rdv_command         stat                     
//         Read Deleted Data               N/A                 N/A                  
//         Write Data                      rdv_command         stat                     
//         Write Deleted Data              rdv_command         stat                     
//         Read a Track                    N/A                 N/A                  
//         Verify (82077)                  N/A                 N/A                  
//         Version (82077)                 version_cmd         N/A                  
//         Read ID                         read_id_cmd         stat                     
//         Format a Track                  format_cmd          stat                     
//         Scan Equal (765)                N/A                 N/A                  
//         Scan Low or Equal (765)         N/A                 N/A                  
//         Scan High or Equal (765)        N/A                 N/A                  
//         Recalibrate                     N/A                 N/A                  
//         Sense Interrupt Status          sns_SWord_cmd       fdc_result           
//         Specify                         specify_cmd         N/A                  
//         Sense Drive Status              sns_stat_cmd        stat                     
//         Seek                            seek_cmd            N/A                  
//         Configure (82077)               config_cmd          N/A                  
//         Relative Seek (82077)           N/A                 N/A                  
//         Dump Registers (82077)          N/A                 N/A                  
//         Perpendicular Mode (82077)      N/A                 N/A                  
//         Invalid                         invalid_cmd         N/A                  
//                                                                                                          

typedef struct _FDC_CMD_READ_DATA {
    UCHAR   command;            // command UCHAR 
    UCHAR   drive;              // drive specifier 
    UCHAR   C;                  // cylinder number 
    UCHAR   H;                  // head address 
    UCHAR   R;                  // record (sector number) 
    UCHAR   N;                  // number of UCHARs per sector 
    UCHAR   EOT;                // end of track 
    UCHAR   GPL;                // gap length 
    UCHAR   DTL;                // data length 
} FDC_CMD_READ_DATA, *PFDC_CMD_READ_DATA;

typedef struct  _FDC_CMD_READ_ID {   
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_READ_ID, *PFDC_CMD_READ_ID;

typedef struct _FDC_CMD_FORMAT {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
    UCHAR N;                    // number of bytes per sector 
    UCHAR SC;                   // sectors per track (segment) 
    UCHAR GPL;                  // gap length 
    UCHAR D;                    // format filler byte 
} FDC_CMD_FORMAT, *PFDC_CMD_FORMAT;

typedef struct _FDC_CMD_SENSE_INTERRUPT_STATUS {
    UCHAR command;              // command byte 
} FDC_CMD_SENSE_INTERRUPT_STATUS, *PFDC_CMD_SENSE_INTERRUPT_STATUS;

typedef struct _FDC_CMD_VERSION {
    UCHAR command;              // command byte 
} FDC_CMD_VERSION, *PFDC_CMD_VERSION;

typedef struct _FDC_CMD_SPECIFY {
    UCHAR command;              // command byte 
    UCHAR SRT_HUT;              // step rate time (bits 7-4) 
                                // head unload time bits (3-0) 
    UCHAR HLT_ND;               // head load time (bits 7-1) 
                                // non-DMA mode flag (bit 0) 
} FDC_CMD_SPECIFY, *PFDC_CMD_SPECIFY;

typedef struct _FDC_CMD_SENSE_DRIVE_STATUS {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_SENSE_DRIVE_STATUS, *PFDC_CMD_SENSE_DRIVE_STATUS;

typedef struct _FDC_CMD_RECALIBRATE {
    UCHAR command;              // command byte 
    UCHAR drive;                // drive specifier 
} FDC_CMD_RECALIBRATE, *PFDC_CMD_RECALIBRATE;               
                                
typedef struct _FDC_CMD_SEEK {     
    UCHAR cmd;                  // command byte 
    UCHAR drive;                // drive specifier 
    UCHAR NCN;                  // new cylinder number 
} FDC_CMD_SEEK, *PFDC_CMD_SEEK;

typedef struct _FDC_CMD_CONFIGURE {
    UCHAR cmd;                  // command byte 
    UCHAR czero;                // null byte 
    UCHAR config;               // FDC configuration info  (EIS EFIFO POLL FIFOTHR) 
    UCHAR pretrack;             // Pre-compensation start track number 
} FDC_CMD_CONFIGURE, *PFDC_CMD_CONFIGURE;

typedef struct _FDC_CMD_INVALID {
    UCHAR command;              // command byte 
} FDC_CMD_INVALID, *PFDC_CMD_INVALID;

typedef struct _FDC_STATUS {
    UCHAR ST0;                  // status register 0 
    UCHAR ST1;                  // status register 1 
    UCHAR ST2;                  // status register 2 
    UCHAR C;                    // cylinder number 
    UCHAR H;                    // head address 
    UCHAR R;                    // record (sector number) 
    UCHAR N;                    // number of bytes per sector 
} FDC_STATUS, *PFDC_STATUS;     
                                
typedef struct _FDC_RESULT {    
    UCHAR ST0;                  // status register 0 
    UCHAR PCN;                  // present cylinder number 
} FDC_RESULT, *PFDC_RESULT;

typedef struct _FDC_CMD_PERPENDICULAR_MODE {
    UCHAR command;
    UCHAR perp_setup;
} FDC_CMD_PERPENDICULAR_MODE, *PFDC_CMD_PERPENDICULAR_MODE;

// This command is only valid on the 82078 64 pin Enhanced controller 

typedef struct _FDC_CMD_DRIVE_SPECIFICATION {
    UCHAR command;
    UCHAR drive_spec;
    UCHAR done;
} FDC_CMD_DRIVE_SPECIFICATION, *PFDC_CMD_DRIVE_SPECIFICATION;

typedef struct _FDC_CMD_SAVE {
    UCHAR command;
} FDC_CMD_SAVE, *PFDC_CMD_SAVE;

typedef struct _FDC_SAVE_RESULT {
    UCHAR clk48;
    UCHAR reserved2;
    UCHAR reserved3;
    UCHAR reserved4;
    UCHAR reserved5;
    UCHAR reserved6;
    UCHAR reserved7;
    UCHAR reserved8;
    UCHAR reserved9;
    UCHAR reserved10;
    UCHAR reserved11;
    UCHAR reserved12;
    UCHAR reserved13;
    UCHAR reserved14;
    UCHAR reserved15;
    UCHAR reserved16;
} FDC_SAVE_RESULT, *PFDC_SAVE_RESULT;

//   FDC Sector Header Data used for formatting 

typedef union U_FormatHeader {
    struct {
        UCHAR C;                // cylinder number 
        UCHAR H;                // head address 
        UCHAR R;                // record (sector number) 
        UCHAR N;                // bytes per sector 
    } hdr_struct;
    ULONG hdr_all;
} FormatHeader, *FormatHeaderPtr;

#pragma pack()

//   Tape Drive Parameters 


typedef struct S_DriveParameters {
    UCHAR   seek_mode;                 // seek mode supported by the drive 
    CHAR    mode;                      // drive mode (Primary, Format, Verify) 
    USHORT  conner_native_mode;        // Conner Native Mode Data 
} DriveParameters, *DriveParametersPtr;


//   Tape Parameters 


typedef struct S_FloppyTapeParameters {
    USHORT              fsect_seg;      //  floppy sectors per segment 
    USHORT              seg_ftrack;     //  segments per floppy track 
    USHORT              fsect_ftrack;   //  floppy sectors per floppy track 
    USHORT              rw_gap_length;  //  write gap length 
    USHORT              ftrack_fside;   //  floppy tracks per floppy side 
    ULONG               fsect_fside;    //  floppy sectors per floppy side 
    ULONG               log_sectors;    //  number of logical sectors on a tape 
    ULONG               fsect_ttrack;   //  floppy sectors per tape track 
    UCHAR               tape_rates;     //  supported tape transfer rates 
    UCHAR               tape_type;      //  tape type 
    TAPE_FORMAT_LENGTH  tape_status;
    ULONG               time_out[3];    //  time_out for the QIC-117 commands 
                                        //  time_out[0] = logical_slow, time_out[1] = logical_fast, 
                                        //  time[2] = physical. 
} FloppyTapeParameters, *FloppyTapeParametersPtr;


//   Transfer Rate Parameters 

typedef struct S_TransferRate {
    UCHAR   tape;               // Program tape drive slow (250 or 500 Kbps) 
    UCHAR   fdc;                // Program FDC slow (250 or 500 Kbps) 
    UCHAR   srt;                // FDC step rate for slow xfer rate 
} TransferRate, *TransferRatePtr;

struct S_FormatParameters {
    UCHAR   cylinder;           // floppy cylinder number 
    UCHAR   head;               // floppy head number 
    UCHAR   sector;             // floppy sector number 
    UCHAR   NCN;                // new cylinder number 
    ULONG   *hdr_ptr[2];        // pointer to sector id data for format 
    ULONG   hdr_offset[2];      // offset of header_ptr 
    ULONG   *phy_ptr;           // pointer to physical sector id data for format 
    USHORT  current_hdr;        // current format hdr 
    USHORT  next_hdr;           // next format hdr 
    NTSTATUS retval;             // Format status 
};

typedef struct S_FormatParameters FormatParameters;



// Floppy register structure.  The base address of the controller is 
// passed in by configuration management.  Note that this is the 82077 
// structure, which is a superset of the PD765 structure.  Not all of 
// the registers are used. 

typedef struct S_FDCAddress {
    ULONG   dcr;
    ULONG   dr;
    ULONG   msr;
    ULONG   dsr;
    ULONG   tdr;
    ULONG   dor;
    ULONG   r_dor;
    BOOLEAN dual_port;
} FDCAddress, *FDCAddressPtr;


typedef struct S_FDControllerData {
    FDCAddress      fdc_addr;
    FDC_CMD_FORMAT  fmt_cmd;
    FDC_STATUS      fdc_stat;
    USHORT          isr_reentered;
    BOOLEAN         command_has_result_phase;
    UCHAR           number_of_tape_drives;
    UCHAR           fdc_pcn;
    UCHAR           fifo_byte;
    BOOLEAN         perpendicular_mode;
    BOOLEAN         start_format_mode;
    BOOLEAN         end_format_mode;
} FDControllerData, *FDControllerDataPtr;

typedef struct S_TapeOperationStatus {
    ULONG       bytes_transferred_so_far;
    ULONG       total_bytes_of_transfer;
    ULONG       cur_lst;
    USHORT      data_amount;
    USHORT      s_count;
    USHORT      no_data;
    USHORT      d_amt;
    USHORT      retry_count;
    USHORT      retry_times;
    ULONG       d_segment;        // desired tape segment, (floppy track) 
    USHORT      d_track;          // desired physical tape track 
    UCHAR       d_ftk;
    UCHAR       d_sect;
    UCHAR       d_head;
    UCHAR       retry_sector_id;
    UCHAR       seek_flag;
    UCHAR       s_sect;
    BOOLEAN     log_fwd;          // indicates that the tape is going logical forward 
    BOOLEAN     bot;
    BOOLEAN     eot;
} TapeOperationStatus, *TapeOperationStatusPtr;


typedef struct S_CqdContext {
    DeviceCfg               device_cfg;
    DeviceDescriptor        device_descriptor;
    OperationStatus         operation_status;
    DriveParameters         drive_parms;
    TransferRate            xfer_rate;
    FloppyTapeParameters    floppy_tape_parms;
    CQDTapeCfg              tape_cfg;
    TapeOperationStatus     rd_wr_op;
    FormatParameters        fmt_op;
    FDControllerData        controller_data;
    PVOID                   kdi_context;
    USHORT                  retry_seq_num;
    UCHAR                   firmware_cmd;
    UCHAR                   firmware_error;
    UCHAR                   firmware_version;
    UCHAR                   drive_type;
    UCHAR                   device_unit;
    UCHAR                   drive_on_value;
    UCHAR                   deselect_cmd;
    UCHAR                   drv_stat;
    ULONG                   media_change_count;
    BOOLEAN                 configured;
    BOOLEAN                 selected;
    BOOLEAN                 cmd_selected;
    BOOLEAN                 no_pause;
    BOOLEAN                 cms_mode;
    BOOLEAN                 persistent_new_cart;
    BOOLEAN                 pegasus_supported;
    BOOLEAN                 trakker;
#if DBG
#define DBG_SIZE  (1024*4)
    ULONG                   dbg_command[DBG_SIZE];
    ULONG                   dbg_head;
    ULONG                   dbg_tail;
    BOOLEAN dbg_lockout;
#endif

} CqdContext, *CqdContextPtr;

#if DBG
#define DBG_ADD_ENTRY(dbg_level, dbg_context, data) \
        if (((dbg_level) & kdi_debug_level) != 0 &&  \
        (((kdi_debug_level & QIC117BYPASSLOCKOUT) == 0) || (dbg_context)->dbg_lockout == 0)) {\
            (dbg_context)->dbg_command[(dbg_context)->dbg_tail] = (data); \
            (dbg_context)->dbg_tail = ((dbg_context)->dbg_tail + 1) % DBG_SIZE; \
        }
#else
#define DBG_ADD_ENTRY(dbg_level, dbg_context, data)
#endif

/*****************************************************************************
*
* FILE: CQD_HDRI.H
*
* PURPOSE: This file contains all of the headers for the common driver.
*
*****************************************************************************/

/* CQD Function Templates: **************************************************/

NTSTATUS 
cqd_CmdReportStatus(
    IN CqdContextPtr cqd_context,
    IN DeviceOpPtr dev_op_ptr
    );

NTSTATUS 
cqd_CmdRetension(
    IN CqdContextPtr cqd_context,
    OUT PULONG segments_per_track
    );

NTSTATUS 
cqd_CmdSetSpeed(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_speed
    );

NTSTATUS 
cqd_CmdReportDeviceCfg(
    IN CqdContextPtr cqd_context,
    IN DriveCfgDataPtr drv_cfg
    );

NTSTATUS 
cqd_CmdUnloadTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_DeselectDevice(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_Seek(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_CmdDeselectDevice(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN drive_selected
    );

NTSTATUS 
cqd_GetFDCType(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_ConfigureDevice(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_GetRetryCounts(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_NextTry(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_CmdFormat(
    IN CqdContextPtr cqd_context,
    IN FormatRequestPtr fmt_request
    );  

NTSTATUS 
cqd_GetDeviceInfo(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN report_failed,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_DoReadID(
    IN CqdContextPtr cqd_context,
    IN ULONG read_id_delay,
    IN PFDC_STATUS read_id_status
    );

NTSTATUS 
cqd_GetDeviceError(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetDeviceType(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN vendor_detected
    );

NTSTATUS 
cqd_FormatTrack(
    IN CqdContextPtr cqd_context,
    IN USHORT track
    );

NTSTATUS 
cqd_CmdReportDeviceInfo(
    IN CqdContextPtr cqd_context,
    IN DeviceInfoPtr device_info
    );

NTSTATUS 
cqd_LookForDevice(
    IN CqdContextPtr cqd_context,
    IN UCHAR drive_selector,
    IN BOOLEAN *vendor_detected,
    IN BOOLEAN *found
    );

NTSTATUS 
cqd_ChangeTrack(
    IN CqdContextPtr cqd_context,
    IN USHORT destination_track
    );

NTSTATUS 
cqd_LogicalBOT(
    IN CqdContextPtr cqd_context,
    IN USHORT destination_track
    );

NTSTATUS 
cqd_ConnerPreamble(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN select
    );

NTSTATUS 
cqd_RWTimeout(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT NTSTATUS *drv_status
    );

NTSTATUS 
cqd_HighSpeedSeek(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetStatus(
    IN CqdContextPtr cqd_context,
    OUT PUCHAR status_register_3
    );

NTSTATUS 
cqd_CmdReadWrite(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request
    );

NTSTATUS 
cqd_ReadIDRepeat(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdLoadTape(
    IN CqdContextPtr cqd_context,
    IN LoadTapePtr load_tape_ptr
    );

VOID 
cqd_NextGoodSectors(
    IN CqdContextPtr cqd_context
    );

NTSTATUS
cqd_PauseTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdSelectDevice(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SendPhantomSelect(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_RWNormal(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT NTSTATUS *drv_status
    );

NTSTATUS 
cqd_ReadFDC(
    IN CqdContextPtr cqd_context,
    OUT UCHAR *drv_status,
    OUT USHORT length
    );

NTSTATUS 
cqd_SetDeviceMode(
    IN CqdContextPtr cqd_context,
    IN UCHAR mode
    );

NTSTATUS 
cqd_ProgramFDC(
    IN CqdContextPtr cqd_context,
    IN PUCHAR command,
    IN USHORT length,
    IN BOOLEAN result
    );

NTSTATUS 
cqd_IssueFDCCommand(
    IN CqdContextPtr cqd_context,
    IN PUCHAR FifoIn,
    IN PUCHAR FifoOut,
    IN PVOID  IoHandle,
    IN ULONG  IoOffset,
    IN ULONG  TransferBytes,
    IN ULONG  TimeOut
    );

NTSTATUS 
cqd_ReadWrtProtect(
    IN CqdContextPtr cqd_context,
    OUT PBOOLEAN write_protect
    );

NTSTATUS 
cqd_ReceiveByte(
    IN CqdContextPtr cqd_context,
    IN USHORT receive_length,
    OUT PUSHORT receive_data
    );

NTSTATUS 
cqd_SendByte(
    IN CqdContextPtr cqd_context,
    IN UCHAR command
    );

NTSTATUS 
cqd_DispatchFRB(
    IN     CqdContextPtr cqd_context,
    IN OUT ADIRequestHdrPtr frb
    );

NTSTATUS 
cqd_Report(
    IN     CqdContextPtr cqd_context,
    IN     UCHAR command,
    IN     PUSHORT report_data,
    IN     USHORT report_size,
    IN OUT PBOOLEAN esd_retry
    );

NTSTATUS 
cqd_RetryCode(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request,
       OUT PFDC_STATUS fdc_status,
       OUT PNTSTATUS op_status
    );

NTSTATUS 
cqd_SetBack(
    IN CqdContextPtr cqd_context,
    IN USHORT command
    );

NTSTATUS 
cqd_SenseSpeed(
    IN CqdContextPtr cqd_context,
    IN UCHAR        dma
    );

NTSTATUS 
cqd_WaitSeek(
    IN CqdContextPtr cqd_context,
    IN ULONG seek_delay
    );

NTSTATUS 
cqd_StartTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_StopTape(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_WaitActive(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_WaitCommandComplete(
    IN CqdContextPtr cqd_context,
    IN ULONG wait_time,
    IN BOOLEAN non_interruptible
    );

NTSTATUS 
cqd_WriteReferenceBurst(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CalcPosition(
    IN CqdContextPtr cqd_context,
    IN ULONG block,
    IN ULONG number
    );

NTSTATUS 
cqd_DCROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR speed
    );

NTSTATUS 
cqd_DSROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR precomp
    );

NTSTATUS 
cqd_TDROut(
    IN CqdContextPtr cqd_context,
    IN UCHAR tape_mode
    );

VOID 
cqd_ResetFDC(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_ClearTapeError(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_CalcFmtSegmentsAndTracks(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_GetTapeParameters(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track
    );

NTSTATUS 
cqd_ConfigureFDC(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetRamPtr(
    IN CqdContextPtr cqd_context,
    IN UCHAR ram_addr
    );

NTSTATUS 
cqd_CmdIssueDiagnostic(
    IN     CqdContextPtr cqd_context,
    IN OUT PUCHAR command_string
    );

VOID 
cqd_InitDeviceDescriptor(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_CmdSetTapeParms(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track,
    IN TapeLengthPtr tape_length_ptr
    );

NTSTATUS 
cqd_PrepareTape(
    IN CqdContextPtr cqd_context,
    OUT FormatRequestPtr fmt_request
    );

VOID 
cqd_InitializeRate(
    IN CqdContextPtr cqd_context,
    IN UCHAR   tape_xfer_rate
    );

NTSTATUS 
cqd_GetTapeFormatInfo(
    IN CqdContextPtr cqd_context,
    IN FormatRequestPtr fmt_request,
    OUT PULONG segments_per_track
    );

NTSTATUS 
cqd_SetRam(
    IN CqdContextPtr cqd_context,
    IN UCHAR ram_data
    );

NTSTATUS 
cqd_CMSSetupTrack(
    IN CqdContextPtr cqd_context,
    OUT PBOOLEAN new_track
    );

NTSTATUS 
cqd_ReportCMSVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ReportConnerVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ReportSummitVendorInfo(
    IN CqdContextPtr cqd_context,
    IN USHORT vendor_id
    );

NTSTATUS 
cqd_ToggleParams(
    IN CqdContextPtr cqd_context,
    IN UCHAR parameter
    );


NTSTATUS 
cqd_EnablePerpendicularMode(
    IN CqdContextPtr cqd_context,
    IN BOOLEAN enable_perp_mode
    );

BOOLEAN 
cqd_AtLogicalBOT(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_DoFormat(
   IN CqdContextPtr cqd_context
    );

VOID 
cqd_BuildFormatHdr(
    IN CqdContextPtr cqd_context,
    IN USHORT header
    );

NTSTATUS 
cqd_VerifyMapBad(
    IN     CqdContextPtr cqd_context,
    IN OUT DeviceIOPtr io_request
    );

NTSTATUS 
cqd_CheckMediaCompatibility(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetFWTapeSegments(
    IN CqdContextPtr cqd_context,
    IN ULONG segments_per_track
    );

VOID 
cqd_SetTempFDCRate(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SelectFormat(
    IN CqdContextPtr cqd_context
    );

VOID 
cqd_SetXferRates(
    IN CqdContextPtr cqd_context
    );

NTSTATUS 
cqd_SetFormatSegments(
    IN CqdContextPtr cqd_context,
    IN ULONG       segments_per_track
    );

NTSTATUS 
cqd_PrepareIomega3010PhysRev(
    IN CqdContextPtr cqd_context
    );

/*++

Copyright (c) 1993 - Colorado Memory Systems, Inc.
All Rights Reserved

Module Name:

   common.h

Abstract:

   Data structures shared by drivers q117 and q117i

Revision History:

--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// QIC117Debug is normally 0.  At compile-time or at run-time, it can be
// set to some bit patter for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//

// Lower level driver defines (do not change)  These mirror kdi_pub.h.

#define QIC117DBGP              0x00000001     // Display error information

#define QIC117WARN              0x00000002     // Displays seek warings (from low level driver)

#define QIC117INFO              0x00000004      // Display extra info (brief)

#define QIC117SHOWTD            0x00000008     // Display KDI tape commands (verbose)

#define QIC117SHOWMCMDS         0x00000010     // does nothing unless QIC117DBGARRAY is on
                                               // shows drive commands,  and FDC information
                                               // This is VERY VERBOSE and will affect system
                                               // performance

#define QIC117SHOWPOLL          0x00000020     // unused

#define QIC117STOP              0x00000080     // only one info message (not very useful)

#define QIC117MAKEBAD           0x00000100     // Creates (simulated) bad sectors to test bad
                                               // sector re-mapping code

#define QIC117SHOWBAD           0x00000200     // unused

#define QIC117DRVSTAT           0x00000400      // Show drive status (verbose)

#define QIC117SHOWINT           0x00000800     // unused

#define QIC117DBGSEEK           0x00001000     // (does nothing unless QIC117DBGARRAY is on)
                                               // Shows drive seek information (verbose)

#define QIC117DBGARRAY          0x00002000     // Shows async messages (does nothing unless
                                               // QIC117DBGSEEK and/or QIC117SHOWMCMDS is set)
                                               // Displays VERBOSE FDC command information if
                                               // QIC117SHOWMCMDS is set.
#define QIC117BYPASSLOCKOUT     0x00004000

// Upper level driver defines (only used in upper level driver)

#define QIC117SHOWAPI           ((ULONG)0x00010000)     // Shows Tape API commands

#define QIC117SHOWAPIPOLL       ((ULONG)0x00020000)     // Shows Tape API commands used in NTBACKUP polling
                                                        // These are not displayed with QIC117SHOWAPI

#define QIC117SHOWKDI           ((ULONG)0x00040000)     // Shows request to KDI (VERBOSE)

#define QIC117SHOWBSM           ((ULONG)0x00080000)     // Display bad sector information (brief)

#define Q117DebugLevel kdi_debug_level

extern unsigned long kdi_debug_level;

#define CheckedDump(LEVEL,STRING) \
            if (kdi_debug_level & LEVEL) { \
               DbgPrint STRING; \
            }
#else
#define CheckedDump(LEVEL,STRING)
#endif


#define BUFFER_SPLIT

typedef unsigned char UBYTE;
typedef unsigned short UWORD;
typedef unsigned short SEGMENT;
typedef unsigned long BLOCK;

#ifndef TRUE
#define TRUE 1
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define MAXLINE 100

//
// The following parameters are used to indicate the tape format code
//


#define MAX_PASSWORD_SIZE   8           // max volume password size
#define QIC_END             0xffea6dff  // 12-31-2097, 23:59:59 in qictime


//
// Tape Constants
//
#define UNIX_MAXBFS     4               // max. data buffers supported in the UNIX kernel

#define MAGIC           0x636d  // "cm"

#define DRIVER_COMMAND USHORT

//
// Prototypes for common functions
//

VOID
q117LogError(
   IN PDEVICE_OBJECT DeviceObject,
   IN ULONG SequenceNumber,
   IN UCHAR MajorFunctionCode,
   IN UCHAR RetryCount,
   IN ULONG UniqueErrorValue,
   IN NTSTATUS FinalStatus,
   IN NTSTATUS SpecificIOStatus
   );

NTSTATUS q117MapStatus(
    IN NTSTATUS Status
    );

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'h71q')
#endif

/*++

Module Name:

    q117.h

Abstract:

    Data structures used only by q117 driver.  Contains QIC-40 structures
    and Context for q117.

Revision History:

--*/

//
//  For NTBACKUP to work,  an early warning is required to allow the
//  application to perform tape linking.  To achive this,  a 5 segment
//  region at the end of the tape is RESERVED to genterate early warning
//  status.  This value is used in q117WriteTape for this purpose.
//
#define SEGMENTS_OF_EARLY_WARNING   5


#define FORMAT_BYTE             0x6b

#define MAX_BAD_BLOCKS          ((1024*27)/sizeof(ULONG))
#define LIST_ENTRY_SIZE         3
#define MAX_BAD_LIST            (((1024*27)/LIST_ENTRY_SIZE) - 1)

#define MAX_TITLE_SIZE          44      // max volume title entry size in far memory array
#define MAX_PASSWORD_SIZE       8       // max volume password size

#define MAX_QIC40_FILENAME      13
#define MAX_HEADER_SIZE         256     // maximum QIC-40 header size
#define DATA_HEADER_SIG_SIZE    4       // data header signature size

#define ECC_BLOCKS_PER_SEGMENT  3       // number of correction sectors ber block
#define BLOCKS_PER_SEGMENT      32      // Number of sectors per block on the tape.
                                        // number of data sectors per block

#define DATA_BLOCKS_PER_SEGMENT (BLOCKS_PER_SEGMENT - ECC_BLOCKS_PER_SEGMENT)

#define BYTES_PER_SECTOR    1024
#define BYTES_PER_SEGMENT   (BYTES_PER_SECTOR*BLOCKS_PER_SEGMENT)

#define TapeHeaderSig       0xaa55aa55l
#define VolumeTableSig      (((ULONG)'L'<<24) + ((ULONG)'B'<<16) + ('T'<<8) + 'V')
#define FileHeaderSig       0x33cc33ccl

#define QIC40_VENDOR_UNIQUE_SIZE        106


#define VENDOR_TYPE_NONE    0
#define VENDOR_TYPE_CMS     1

#define MOUNTAIN_SEMISPECED_SPACE       9

#define VU_SIGNATURE_SIZE           4
#define VU_TAPE_NAME_SIZE           11

#define VU_SEGS_PER_TRACK           68
#define VU_SEGS_PER_TRACK_XL        102
#define VU_80SEGS_PER_TRACK         100
#define VU_80SEGS_PER_TRACK_XL      150

#define VU_MAX_FLOPPY_TRACK         169
#define VU_MAX_FLOPPY_TRACK_XL      254
#define VU_80MAX_FLOPPY_TRACK       149
#define VU_80MAX_FLOPPY_TRACK_XL    149

#define VU_TRACKS_PER_CART          20
#define VU_80TRACKS_PER_CART        28

#define VU_MAX_FLOPPY_SIDE          1
#define VU_80MAX_FLOPPY_SIDE        4
#define VU_80MAX_FLOPPY_SIDE_XL     6

#define VU_MAX_FLOPPY_SECT          128

#define NEW_SPEC_TAPE_NAME_SIZE     44

#define FILE_VENDOR_SPECIFIC        0
#define FILE_UNIX_SPECIFIC          1
#define FILE_DATA_BAD               2

#define OP_MS_DOS           0
#define OP_UNIX             1
#define OP_UNIX_PUBLIC      2
#define OP_OS_2             3
#define OP_WINDOWS_NT       4

// Valid values for compression code
#define COMP_STAC 0x01
#define COMP_VEND 0x3f

//
// The following section specifies QIC-40 data structures.
// These structures are aligned on byte boundaries.
//

typedef struct _SEGMENT_BUFFER {
    PVOID logical;
    PHYSICAL_ADDRESS physical;
} SEGMENT_BUFFER, *PSEGMENT_BUFFER;

typedef struct _IO_REQUEST {
    union {
        ADIRequestHdr adi_hdr;

        /* Device Configuration FRB */
        struct S_DriveCfgData ioDriveCfgData;

        /* Generic Device operation FRB */
        struct S_DeviceOp ioDeviceOp;

        /* New Tape configuration FRB */
        struct S_LoadTape ioLoadTape;

        /* Tape length configuration FRB */
        struct S_TapeParms ioTapeLength;

        /* Device I/O FRB */
        struct S_DeviceIO ioDeviceIO;

        /* Format request FRB */
        struct S_FormatRequest ioFormatRequest;

        /* Direct firmware communication FRB */
        struct S_DComFirm ioDComFirm;

        /* Direct firmware communication FRB */
        struct S_TapeParms ioTapeParms;

        /* device info FRB (CMD_REPORT_DEVICE_INFO) */
        struct S_ReportDeviceInfo ioDeviceInfo;
    } x;

    KEVENT DoneEvent;               // Event that IoCompleteReqeust will set
    IO_STATUS_BLOCK IoStatus;       // Status of request
    PSEGMENT_BUFFER BufferInfo;     // Buffer information
    struct _IO_REQUEST *Next;



} *PIO_REQUEST, IO_REQUEST;

#pragma pack(1)

struct _FAIL_DATE {
    UWORD   Year:7;                     // year +1970 (1970-2097)
    UWORD   Month:4;                        // month (1-12)
    UWORD   Day:5;                      // day (1-31)
};


struct _CMS_VENDOR_UNIQUE {
    UBYTE   type;                           // 0 = none; 1 = CMS
    CHAR    signature[VU_SIGNATURE_SIZE];   // "CMS" , ASCIIZ string
    ULONG   creation_time;                  // QIC40/QIC113 date/time format
    CHAR    tape_name[VU_TAPE_NAME_SIZE];   // space padded name
    CHAR    checksum;                       // checksum of UBYTEs 0 - 19 of this struct
};

struct _CMS_NEW_TAPE_NAME {
    CHAR reserved[MOUNTAIN_SEMISPECED_SPACE];   // leave room for Mountain stuff
    CHAR tape_name[NEW_SPEC_TAPE_NAME_SIZE];    // space padded name
    ULONG creation_time;                        // QIC40/QIC113 date/time format
};

struct _CMS_CORRECT_TAPE_NAME {
    UWORD   unused2;
    UWORD  TrackSeg;                           // Tape segments per tape track
    UBYTE  CartTracks;                         // Tape tracks per cartridge
    UBYTE  MaxFlopSide;                        // Maximum floppy sides
    UBYTE  MaxFlopTrack;                       // Maximum floppy tracks
    UBYTE  MaxFlopSect;                        // Maximum floppy sectors
    CHAR  tape_name[NEW_SPEC_TAPE_NAME_SIZE];  // space padded name
    ULONG creation_time;                       // QIC40/QIC113 date/time format
};

typedef union _QIC40_VENDOR_UNIQUE {
        struct _CMS_VENDOR_UNIQUE cms;
        CHAR vu[QIC40_VENDOR_UNIQUE_SIZE];
        struct _CMS_NEW_TAPE_NAME new_name;
        struct _CMS_CORRECT_TAPE_NAME correct_name;
} QIC40_VENDOR_UNIQUE, *PQIC40_VENDOR_UNIQUE;

typedef struct S_BadList {
    UBYTE ListEntry[LIST_ENTRY_SIZE];
} BAD_LIST, *BAD_LIST_PTR;

typedef union U_BadMap {
    ULONG BadSectors[MAX_BAD_BLOCKS];
    BAD_LIST BadList[MAX_BAD_LIST];
} BAD_MAP, *BAD_MAP_PTR;




// Tape Header (sectors 0-1) and BadSector Array (2-13)
typedef struct _TAPE_HEADER {
    ULONG   Signature;                  // set to 0xaa55aa55l
    UBYTE   FormatCode;                 // set to 0x01
    UBYTE   SubFormatCode;              // Zero for pre-rev L tapes and
                                        //  value + 'A' for rev L and above
    SEGMENT HeaderSegment;              // segment number of header
    SEGMENT DupHeaderSegment;           // segment number of duplicate header
    SEGMENT FirstSegment;               // segment number of Data area
    SEGMENT LastSegment;                // segment number of End of Data area
    ULONG   CurrentFormat;              // time of most recent format
    ULONG   CurrentUpdate;              // time of most recent write to cartridge
    union _QIC40_VENDOR_UNIQUE VendorUnique; // Vendor unique stuff
    UBYTE   ReformatError;              // 0xff if any of remaining data is lost
    UBYTE   unused3;
    ULONG   SegmentsUsed;               // incremented every time a segment is used
    UBYTE   unused4[4];
    ULONG   InitialFormat;              // time of initial format
    UWORD   FormatCount;                // number of times tape has been formatted
    UWORD   FailedSectors;              // the number entries in failed sector log
    CHAR    ManufacturerName[44];       // name of manufacturer that pre-formatted
    CHAR    LotCode[44];                // pre-format lot code
    UBYTE   unused5[22];
    struct S_Failed {
        SEGMENT  Segment;               // number of segment that failed
        struct _FAIL_DATE DateFailed;       // date of failure
    } Failed[(1024+768)/4];             // fill out remaining UBYTEs of sector + next
    BAD_MAP BadMap;
} TAPE_HEADER, *PTAPE_HEADER;

//
// CMS Vendor specific area
//
typedef struct _CMS_VOLUME_VENDOR {
    CHAR Signature[4];          // set to "CMS" (null terminated) if it is our backup
    UWORD FirmwareRevision;     // firmware version
    UWORD SoftwareRevision;     // software version
    CHAR RightsFiles;           // if 0xff = novell rights information present
    UWORD NumFiles;             // number of files in volume
    CHAR OpSysType;             // flavor of operating system at creation
} CMS_VOLUME_VENDOR, PCMS_VOLUME_VENDOR;

//
// QIC-40 Volume table structure
//
typedef struct _VOLUME_TABLE_ENTRY {
    ULONG   Signature;                  // this entry will be "VTBL" if volume exists
    SEGMENT StartSegment;               // starting segment of volume for this cart
    SEGMENT EndingSegment;              // ending segment of volume for this cart
    CHAR    Description[MAX_TITLE_SIZE]; // user description of volume
    ULONG   CreationTime;               // time of creation of the volume
    UWORD   VendorSpecific:1;           // set if remainder of volume entry is vend spec
    UWORD   MultiCartridge:1;           // set if volume spans another tape
    UWORD   NotVerified:1;              // set if volume not verified yet
    UWORD   NoNewName:1;                // set if new file names (redirection) disallowed
    UWORD   StacCompress:1;
    UWORD   reserved:3;
    UWORD   SequenceNumber:8;           // multi-cartridge sequence number
    union {
        CMS_VOLUME_VENDOR cms_QIC40;
        UBYTE reserved[26];             // vendor extension data
    } Vendor;
    CHAR    Password[MAX_PASSWORD_SIZE];// password for volume
    ULONG   DirectorySize;              // number of UBYTEs reserved for directory
    ULONG   DataSize;                   // size of data area (includes other cartridges)
    UWORD   OpSysVersion;               // operating system version
    CHAR    VolumeLabel[16];            // volume label of source drive
    UBYTE   LogicalDevice;              // who knows
    UBYTE   PhysicalDevice;             // who knows
    UWORD   CompressCode:6;             // type of compression, 3Fh = vendor specific
    UWORD   CompressAlwaysZero:1;       // must be 0
    UWORD   CompressSwitch:1;           // compression use flag
    UWORD   reserved1:8;
    UBYTE   reserved2[6];
} VOLUME_TABLE_ENTRY, *PVOLUME_TABLE_ENTRY;

#pragma pack()


//
// The following structure is the context for the q117 driver.  It contains
// all current "state" information for the tape drive.
//
typedef struct _Q117_CONTEXT {

    struct {
        BOOLEAN VerifyOnlyOnFormat;     // Verify only on format.  If TRUE
                                        // Then do NOT perform LOW-LEVEL
                                        // Format

        BOOLEAN DetectOnly;             // If TRUE,  allow only the CMS_DETECT
                                        // ioctl,  and do not allocate memory

        BOOLEAN FormatDisabled;         // If TRUE,  Tape API format will be
                                        // Disabled.

    } Parameters;

    ULONG TapeNumber;                   // Tape number of this context (used
                                        // for DEVICEMAP\tape\Unit {x} and
                                        // device \\.\tape{x}

    BOOLEAN DriverOpened;               // Set if q117Create called (this driver opened)
    BOOLEAN DeviceConfigured;           // Set if CMD_REPORT_DEVICE_CFG performed
    BOOLEAN DeviceSelected;             // Set if CMD_SELECT_DEVICE performed,
                                        // Reset if CMD_DESELECT_DEVICE performed

    struct S_DriveCfgData DriveCfg;


    PVOID PageHandle;

    VOLUME_TABLE_ENTRY ActiveVolume;    // volume currently being saved to (nt volume)
    USHORT ActiveVolumeNumber;          // The sequence number of the current struct VolDir.

    PDEVICE_OBJECT q117iDeviceObject;
    PDEVICE_OBJECT FdcDeviceObject;
    ULONG MaxTransferPages;

    //
    // Error tracking
    //

    ULONG ErrorSequence;
    UCHAR MajorFunction;

    //
    // Queue management globals
    //

    SEGMENT_BUFFER SegmentBuffer[UNIX_MAXBFS];    // Array of segment buffers

    ULONG SegmentBuffersAvailable;

    ULONG QueueTailIndex;               // Index in the IORequest array that indexes the tail.

    ULONG QueueHeadIndex;               // This is the head of the Filer IORequest ring-tail array.

    PIO_REQUEST IoRequest;              // pointer to array of IORequests

    //
    // current buffer information
    //

    struct {

        enum {
            NoOperation,
            BackupInProgress,
            RestoreInProgress
            } Type;

        //
        // Information associated with currently active segment
        //
        PVOID   SegmentPointer;
        USHORT  SegmentBytesRemaining;
        SEGMENT LastSegmentRead;
        SEGMENT CurrentSegment;         // in backup (active segment) in restore (read-ahead segment)
        USHORT  BytesZeroFilled;        // Bytes at end of backup that were zeroed (not part of backup)
        NTSTATUS  SegmentStatus;
        SEGMENT EndOfUsedTape;
        SEGMENT LastSegment;            // Last segment of volume
        ULONG   BytesOnTape;
        BOOLEAN UpdateBadMap;           // if true then update bad sector map
        ULONG   BytesRead;
        ULONG   Position;               // type of last IOCTL_TAPE_SET_POSITION

        } CurrentOperation;

    //
    // current tape information
    //

    struct {
        enum {
            TapeInfoLoaded,
            BadTapeInDrive,
            NeedInfoLoaded
            }   State;

        NTSTATUS BadTapeError;
        SEGMENT LastUsedSegment;
        SEGMENT VolumeSegment;
        ULONG   BadSectors;
        SEGMENT LastSegment;            // Last formatted segment.
        USHORT  MaximumVolumes;         // Maximum volumes entries available
        PTAPE_HEADER TapeHeader;        // Header from tape
        struct _TAPE_GET_MEDIA_PARAMETERS *MediaInfo;
        BAD_MAP_PTR BadMapPtr;
        ULONG BadSectorMapSize;
        USHORT CurBadListIndex;
        USHORT TapeFormatCode;
        enum {
            BadMap3ByteList,
            BadMap8ByteList,
            BadMap4ByteArray,
            BadMapFormatUnknown
            } BadSectorMapFormat;


        } CurrentTape;



    // if this global is set then the tape directory has been loaded
    PIO_REQUEST tapedir;

    char drive_type;                    // QIC40 or QIC80

    //
    // The following pointers are allocated when open is called and
    //  freed at close time.
    //

#ifndef NO_MARKS
#define MAX_MARKS 255
    ULONG CurrentMark;
    struct _MARKENTRIES {
        ULONG TotalMarks;
        ULONG MarksAllocated;       // size of mark entry buffer (in entries not bytes)
        ULONG MaxMarks;
        struct _MARKLIST {
            ULONG Type;
            ULONG Offset;
        } *MarkEntry;
    } MarkArray;
#endif

} Q117_CONTEXT, *PQ117_CONTEXT;


typedef enum _DEQUEUE_TYPE {
    FlushItem,
    WaitForItem
} DEQUEUE_TYPE;

//
// Common need:  convert block into segment
//
#define BLOCK_TO_SEGMENT(block) ((SEGMENT)((block) / BLOCKS_PER_SEGMENT))
#define SEGMENT_TO_BLOCK(segment) ((BLOCK)(segment) * BLOCKS_PER_SEGMENT)


//
// This define is the block size used by position commands
// Note:  It is 512 to be compatible with the Maynstream backup
// that does not do a getmedia parameters
//
#define BLOCK_SIZE  BYTES_PER_SECTOR



#define ERROR_DECODE(val) (val >> 16)

#define ERR_BAD_TAPE                0x0101  /* BadTape */
#define ERR_BAD_SIGNATURE           0x0102  /* Unformat */
#define ERR_UNKNOWN_FORMAT_CODE     0x0103  /* UnknownFmt */
#define ERR_CORRECTION_FAILED       0x0104  /* error recovery failed */
#define ERR_PROGRAM_FAILURE         0x0105  /* coding error */
#define ERR_WRITE_PROTECTED         0x0106
#define ERR_TAPE_NOT_FORMATED       0x0107
#define ERR_UNRECOGNIZED_FORMAT     0x0108 /* badfmt */
#define ERR_END_OF_VOLUME           0x0109 /*EndOfVol */
#define ERR_UNUSABLE_TAPE           0x010a /* badtape - could not format */
#define ERR_SPLIT_REQUESTS          0x010b /* SplitRequests */
#define ERR_EARLY_WARNING           0x010c
#define ERR_SET_MARK                0x010d
#define ERR_FILE_MARK               0x010e
#define ERR_LONG_FILE_MARK          0x010f
#define ERR_SHORT_FILE_MARK         0x0110
#define ERR_NO_VOLUMES              0x0111
#define ERR_NO_MEMORY               0x0112
#define ERR_ECC_FAILED              0x0113
//#define ERR_END_OF_TAPE             0x0114
//#define ERR_TAPE_FULL               0x0115
#define ERR_WRITE_FAILURE           0x0116
#define ERR_BAD_BLOCK_DETECTED      0x0117
#define ERR_OP_PENDING_COMPLETION   0x0118
#define ERR_INVALID_REQUEST         0x0119

/*++

Module Name:

   protos.h

Abstract:

   Prototypes for internal functions of the High-Level portion (data
   formatter) of the QIC-117 device driver.

Revision History:


--*/

NTSTATUS
q117Format(
   OUT LONG *NumberBad,
   IN UCHAR DoFormat,
   IN PQIC40_VENDOR_UNIQUE VendorUnique,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReqIO(
   IN PIO_REQUEST IoRequest,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PIO_COMPLETION_ROUTINE CompletionRoutine,
   IN PVOID CompletionContext,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117WaitIO(
   IN PIO_REQUEST IoRequest,
   IN BOOLEAN Wait,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117DoIO(
   IN PIO_REQUEST IoRequest,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AbortIo(
   IN PQ117_CONTEXT Context,
   IN PKEVENT DoneEvent,
   IN PIO_STATUS_BLOCK IoStatus
   );

NTSTATUS
q117AbortIoDone(
   IN PQ117_CONTEXT Context,
   IN PKEVENT DoneEvent
   );

NTSTATUS
q117DoCmd(
   IN OUT PIO_REQUEST IoRequest,
   IN DRIVER_COMMAND Command,
   IN PVOID Data,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117EndRest(
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117MapBadBlock (
   IN PIO_REQUEST IoRequest,
   OUT PVOID *DataPointer,
   IN OUT USHORT *BytesLeft,
   IN OUT SEGMENT *CurrentSegment,
   IN OUT USHORT *Remainder,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117NewTrkRC(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelectVol(
   IN PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117UpdateHeader(
   IN PTAPE_HEADER Header,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117Update(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117DoUpdateBad(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117DoUpdateMarks(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117GetMarks(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117FillTapeBlocks(
   IN OUT DRIVER_COMMAND Command,
   IN SEGMENT CurrentSegment,
   IN SEGMENT EndSegment,
   IN OUT PVOID Buffer,
   IN SEGMENT FirstGood,
   IN SEGMENT SecondGood,
   IN PSEGMENT_BUFFER BufferInfo,
   IN PQ117_CONTEXT Context
   );
NTSTATUS
q117IssIOReq(
   IN OUT PVOID Data,
   IN DRIVER_COMMAND Command,
   IN LONG Block,
   IN OUT PSEGMENT_BUFFER BufferInfo,
   IN OUT PQ117_CONTEXT Context
   );

BOOLEAN
q117QueueFull(
   IN PQ117_CONTEXT Context
   );

BOOLEAN
q117QueueEmpty(
   IN PQ117_CONTEXT Context
   );

PVOID
q117GetFreeBuffer(
   OUT PSEGMENT_BUFFER *BufferInfo,
   IN PQ117_CONTEXT Context
   );

PVOID
q117GetLastBuffer(
   IN PQ117_CONTEXT Context
   );

PIO_REQUEST
q117Dequeue(
   IN DEQUEUE_TYPE Type,
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117ClearQueue(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117QueueSingle(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117QueueNormal(
   IN OUT PQ117_CONTEXT Context
   );

PIO_REQUEST
q117GetCurReq(
   IN PQ117_CONTEXT Context
   );

ULONG
q117GetQueueIndex(
   IN PQ117_CONTEXT Context
   );

VOID
q117SetQueueIndex(
   IN ULONG Index,
   OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117LoadTape (
   IN OUT PTAPE_HEADER*HeaderPointer,
   IN OUT PQ117_CONTEXT Context,
   IN PUCHAR driver_format_code
   );

NTSTATUS
q117InitFiler (
   IN OUT PQ117_CONTEXT Context
   );

void
q117GetBadSectors (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadHeaderSegment (
   OUT PTAPE_HEADER*HeaderPointer,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117WriteTape(
   IN OUT PVOID FromWhere,
   IN OUT ULONG HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EndBack(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadVolumeEntry(
   PVOLUME_TABLE_ENTRY VolumeEntry,
   PQ117_CONTEXT Context
   );

VOID
q117FakeDataSize(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AppVolTD(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelectTD(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117Start (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117Stop (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117OpenForWrite (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EndWriteOperation (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117OpenForRead (
    IN ULONG StartPosition,
    IN OUT PQ117_CONTEXT Context,
    IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117EndReadOperation (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117StartBack(
   IN OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117StartAppend(
   IN OUT ULONG BytesAlreadyThere,
   IN PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117StartComm(
   OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SelVol (
   PVOLUME_TABLE_ENTRY TheVolumeTable,
   PQ117_CONTEXT Context
   );

NTSTATUS
q117ReadTape (
   OUT PVOID ToWhere,
   IN OUT ULONG *HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ConvertStatus(
   IN PDEVICE_OBJECT DeviceObject,
   IN NTSTATUS status
   );

VOID
q117SetTpSt(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117GetEndBlock (
   OUT PVOLUME_TABLE_ENTRY TheVolumeTable,
   OUT LONG *NumberVolumes,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117BuildHeader(
   OUT PQIC40_VENDOR_UNIQUE VendorUnique,
   IN SEGMENT *HeaderSect,
   IN OUT PTAPE_HEADER Header,
   IN CQDTapeCfg *tparms,      // tape parameters from the driver
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117IoCtlGetMediaParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetMediaTypesEx (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117IoCtlSetMediaParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetDeviceNumber (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetDriveParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlSetDriveParameters (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlWriteMarks (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlSetPosition (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117FindMark(
   ULONG Type,
   LONG Number,
   PQ117_CONTEXT Context,
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117SeekToOffset(
   ULONG Offset,
   PQ117_CONTEXT Context,
   IN PDEVICE_OBJECT DeviceObject
   );

NTSTATUS
q117IoCtlErase (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlPrepare (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetStatus (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlGetPosition (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117CheckNewTape (
   PQ117_CONTEXT             Context
   );

NTSTATUS
q117NewTrkBk(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117GetTapeCapacity(
   struct S_O_DGetCap *ptr,
   PQ117_CONTEXT Context
   );

VOID
q117RdsInitReed (
   VOID
   );

UCHAR
q117RdsMultiplyTuples (
   IN UCHAR tup1,
   IN UCHAR tup2
   );

UCHAR
q117RdsDivideTuples (
   IN UCHAR tup1,
   IN UCHAR tup2
   );

UCHAR
q117RdsExpTuple (
   IN UCHAR tup1,
   IN UCHAR xpnt
   );

VOID
q117RdsMakeCRC (
   IN OUT UCHAR *Array,      // pointer to 32K data area (segment)
   IN UCHAR Count            // number of sectors (1K blocks)(1-32)
   );

BOOLEAN
q117RdsReadCheck (
   IN UCHAR *Array,         // pointer to 32K data area (segment)
   IN UCHAR Count           // number of sectors (1K blocks)(1-32)
   );

BOOLEAN
q117RdsCorrect(
   IN OUT UCHAR *Array,    // pointer to 32K data area (segment)
   IN UCHAR Count,         // number of good sectors in segment (4-32)
   IN UCHAR CRCErrors,     // number of crc errors
   IN UCHAR e1,
   IN UCHAR e2,
   IN UCHAR e3             // sectors where errors occurred
   );

VOID
q117RdsGetSyndromes (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR *ps1,
   IN UCHAR *ps2,
   IN UCHAR *ps3
   );

BOOLEAN
q117RdsCorrectFailure (
   IN OUT UCHAR *Array,     // pointer to 32K data area (segment)
   IN UCHAR Count,          // number of good sectors in segment (4-32)
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectOneError (
   IN OUT UCHAR *Array,      // pointer to 32K data area (segment)
   IN UCHAR Count,           // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectTwoErrors (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR ErrorLocation2,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

BOOLEAN
q117RdsCorrectThreeErrors (
   IN OUT UCHAR *Array,       // pointer to 32K data area (segment)
   IN UCHAR Count,            // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR ErrorLocation2,
   IN UCHAR ErrorLocation3,
   IN UCHAR s1,
   IN UCHAR s2,
   UCHAR s3
   );

BOOLEAN
q117RdsCorrectOneErrorAndOneFailure (
   IN OUT UCHAR *Array,        // pointer to 32K data area (segment)
   IN UCHAR Count,             // number of good sectors in segment (4-32)
   IN UCHAR ErrorLocation1,
   IN UCHAR s1,
   IN UCHAR s2,
   IN UCHAR s3
   );

void
q117SpacePadString(
   IN OUT CHAR *InputString,
   IN LONG StrSize
   );

NTSTATUS
q117VerifyFormat(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EraseQ(
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117EraseS(
   IN OUT PQ117_CONTEXT Context
   );

VOID
q117ClearVolume (
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117SkipBlock (
   IN OUT ULONG *HowMany,
   IN OUT PQ117_CONTEXT Context
   );

NTSTATUS
q117ReconstructSegment(
   IN PIO_REQUEST IoReq,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117DoCorrect(
   IN PVOID DataBuffer,
   IN ULONG BadSectorMap,
   IN ULONG SectorsInError
   );

UCHAR
q117CountBits(
    IN PQ117_CONTEXT Context,
    IN SEGMENT Segment,
    ULONG Map
    );

ULONG q117ReadBadSectorList (
    IN PQ117_CONTEXT Context,
    IN SEGMENT Segment
    );

USHORT
q117GoodDataBytes(
   IN SEGMENT Segment,
   IN PQ117_CONTEXT Context
   );

NTSTATUS
q117AllocatePermanentMemory(
   PQ117_CONTEXT Context,
   PDEVICE_OBJECT FdcDeviceObject
   );

NTSTATUS
q117GetTemporaryMemory(
   PQ117_CONTEXT Context
   );

VOID
q117FreeTemporaryMemory(
   PQ117_CONTEXT Context
   );

NTSTATUS
q117IoCtlReadAbs (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlWriteAbs (
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp
   );

NTSTATUS
q117IoCtlDetect (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117UpdateBadMap(
    IN OUT PQ117_CONTEXT Context,
    IN SEGMENT Segment,
    IN ULONG BadSectors
    );

int
q117BadMapToBadList(
    IN SEGMENT Segment,
    IN ULONG BadSectors,
    IN BAD_LIST_PTR BadListPtr
    );

ULONG
q117BadListEntryToSector(
    IN UCHAR *ListEntry,
    OUT BOOLEAN *hiBitSet
    );

NTSTATUS
q117AllocateBuffers (
    PQ117_CONTEXT Context
    );

NTSTATUS
q117Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
q117Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Create (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117Close (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
q117CreateKey(
    IN HANDLE Root,
    IN PSTR key,
    OUT PHANDLE NewKey
    );

NTSTATUS
q117CreateRegistryInfo(
    IN ULONG TapeNumber,
    IN PUNICODE_STRING RegistryPath,
    IN PQ117_CONTEXT Context
    );

cms_IoCtl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
q117DoRewind(
    PQ117_CONTEXT       Context
    );

NTSTATUS q117MakeMarkArrayBigger(
    PQ117_CONTEXT       Context,
    int MinimumToAdd
    );

int
q117SelectBSMLocation(
    IN OUT PQ117_CONTEXT Context
    );

NTSTATUS kdi_WriteRegString(
    HANDLE          unit_key,
    PSTR            name,
    PSTR            value
    );

NTSTATUS kdi_FdcDeviceIo(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEQICH,q117Initialize)
#pragma alloc_text(PAGEQICH,q117CreateRegistryInfo)
#pragma alloc_text(PAGEQICH,q117CreateKey)
#pragma alloc_text(PAGEQICH,q117AllocatePermanentMemory)
#endif

#ifndef NOCODELOCK

#ifdef ALLOC_PRAGMA
//#pragma alloc_text(PAGEQICH, q117Create)
//#pragma alloc_text(PAGEQICH, q117Close)
#pragma alloc_text(PAGEQICH, cms_IoCtl)
#pragma alloc_text(PAGEQICH, q117Read)
#pragma alloc_text(PAGEQICH, q117Write)
#pragma alloc_text(PAGEQICH, q117DeviceControl)
#pragma alloc_text(PAGEQICH, q117DoRewind)
#pragma alloc_text(PAGEQICH, q117AbortIo)
#pragma alloc_text(PAGEQICH, q117AbortIoDone)
#pragma alloc_text(PAGEQICH, q117AllocateBuffers )
#pragma alloc_text(PAGEQICH, q117AppVolTD)
#pragma alloc_text(PAGEQICH, q117BadListEntryToSector)
#pragma alloc_text(PAGEQICH, q117BadMapToBadList)
#pragma alloc_text(PAGEQICH, q117BuildHeader)
#pragma alloc_text(PAGEQICH, q117CheckNewTape )
#pragma alloc_text(PAGEQICH, q117ClearQueue)
#pragma alloc_text(PAGEQICH, q117ClearVolume )
#pragma alloc_text(PAGEQICH, q117ConvertStatus)
#pragma alloc_text(PAGEQICH, q117CountBits)
#pragma alloc_text(PAGEQICH, q117Dequeue)
#pragma alloc_text(PAGEQICH, q117DoCmd)
#pragma alloc_text(PAGEQICH, q117DoCorrect)
#pragma alloc_text(PAGEQICH, q117DoIO)
#pragma alloc_text(PAGEQICH, q117DoUpdateBad)
#pragma alloc_text(PAGEQICH, q117DoUpdateMarks)
#pragma alloc_text(PAGEQICH, q117EndBack)
#pragma alloc_text(PAGEQICH, q117EndReadOperation )
#pragma alloc_text(PAGEQICH, q117EndRest)
#pragma alloc_text(PAGEQICH, q117EndWriteOperation )
#pragma alloc_text(PAGEQICH, q117EraseQ)
#pragma alloc_text(PAGEQICH, q117EraseS)
#pragma alloc_text(PAGEQICH, q117FakeDataSize)
#pragma alloc_text(PAGEQICH, q117FillTapeBlocks)
#pragma alloc_text(PAGEQICH, q117FindMark)
#pragma alloc_text(PAGEQICH, q117Format)
#pragma alloc_text(PAGEQICH, q117FreeTemporaryMemory)
#pragma alloc_text(PAGEQICH, q117GetBadSectors )
#pragma alloc_text(PAGEQICH, q117GetCurReq)
#pragma alloc_text(PAGEQICH, q117GetEndBlock )
#pragma alloc_text(PAGEQICH, q117GetFreeBuffer)
#pragma alloc_text(PAGEQICH, q117GetLastBuffer)
#pragma alloc_text(PAGEQICH, q117GetMarks)
#pragma alloc_text(PAGEQICH, q117GetQueueIndex)
#pragma alloc_text(PAGEQICH, q117GetTapeCapacity)
#pragma alloc_text(PAGEQICH, q117GetTemporaryMemory)
#pragma alloc_text(PAGEQICH, q117GoodDataBytes)
#pragma alloc_text(PAGEQICH, q117InitFiler )
#pragma alloc_text(PAGEQICH, q117IoCtlErase )
#pragma alloc_text(PAGEQICH, q117IoCtlGetDeviceNumber )
#pragma alloc_text(PAGEQICH, q117IoCtlGetDriveParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlGetMediaParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlGetPosition )
#pragma alloc_text(PAGEQICH, q117IoCtlGetStatus )
#pragma alloc_text(PAGEQICH, q117IoCtlPrepare )
#pragma alloc_text(PAGEQICH, q117IoCtlReadAbs )
#pragma alloc_text(PAGEQICH, q117IoCtlSetDriveParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlSetMediaParameters )
#pragma alloc_text(PAGEQICH, q117IoCtlSetPosition )
#pragma alloc_text(PAGEQICH, q117IoCtlWriteAbs )
#pragma alloc_text(PAGEQICH, q117IoCtlWriteMarks )
#pragma alloc_text(PAGEQICH, q117IssIOReq)
#pragma alloc_text(PAGEQICH, q117LoadTape )
#pragma alloc_text(PAGEQICH, q117MapBadBlock )
#pragma alloc_text(PAGEQICH, q117NewTrkBk)
#pragma alloc_text(PAGEQICH, q117NewTrkRC)
#pragma alloc_text(PAGEQICH, q117OpenForRead )
#pragma alloc_text(PAGEQICH, q117OpenForWrite )
#pragma alloc_text(PAGEQICH, q117QueueEmpty)
#pragma alloc_text(PAGEQICH, q117QueueFull)
#pragma alloc_text(PAGEQICH, q117QueueNormal)
#pragma alloc_text(PAGEQICH, q117QueueSingle)
#pragma alloc_text(PAGEQICH, q117RdsCorrect)
#pragma alloc_text(PAGEQICH, q117RdsCorrectFailure )
#pragma alloc_text(PAGEQICH, q117RdsCorrectOneError )
#pragma alloc_text(PAGEQICH, q117RdsCorrectOneErrorAndOneFailure )
#pragma alloc_text(PAGEQICH, q117RdsCorrectThreeErrors )
#pragma alloc_text(PAGEQICH, q117RdsCorrectTwoErrors )
#pragma alloc_text(PAGEQICH, q117RdsDivideTuples )
#pragma alloc_text(PAGEQICH, q117RdsExpTuple )
#pragma alloc_text(PAGEQICH, q117RdsGetSyndromes )
#pragma alloc_text(PAGEQICH, q117RdsInitReed )
#pragma alloc_text(PAGEQICH, q117RdsMakeCRC )
#pragma alloc_text(PAGEQICH, q117RdsMultiplyTuples )
#pragma alloc_text(PAGEQICH, q117RdsReadCheck )
#pragma alloc_text(PAGEQICH, q117ReadBadSectorList )
#pragma alloc_text(PAGEQICH, q117ReadHeaderSegment )
#pragma alloc_text(PAGEQICH, q117ReadTape )
#pragma alloc_text(PAGEQICH, q117ReadVolumeEntry)
#pragma alloc_text(PAGEQICH, q117ReconstructSegment)
#pragma alloc_text(PAGEQICH, q117ReqIO)
#pragma alloc_text(PAGEQICH, q117SeekToOffset)
#pragma alloc_text(PAGEQICH, q117SelectTD)
#pragma alloc_text(PAGEQICH, q117SelectVol)
#pragma alloc_text(PAGEQICH, q117SelVol )
#pragma alloc_text(PAGEQICH, q117SetQueueIndex)
#pragma alloc_text(PAGEQICH, q117SetTpSt)
#pragma alloc_text(PAGEQICH, q117SkipBlock )
#pragma alloc_text(PAGEQICH, q117SpacePadString)
#pragma alloc_text(PAGEQICH, q117Start )
#pragma alloc_text(PAGEQICH, q117StartAppend)
#pragma alloc_text(PAGEQICH, q117StartBack)
#pragma alloc_text(PAGEQICH, q117StartComm)
#pragma alloc_text(PAGEQICH, q117Stop )
#pragma alloc_text(PAGEQICH, q117Update)
#pragma alloc_text(PAGEQICH, q117UpdateBadMap)
#pragma alloc_text(PAGEQICH, q117UpdateHeader)
#pragma alloc_text(PAGEQICH, q117VerifyFormat)
#pragma alloc_text(PAGEQICH, q117WaitIO)
#pragma alloc_text(PAGEQICH, q117WriteTape)
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\fdc\mode3fdc\desk2fdc\fdc.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999
Copyright (c) 1996  Colorado Software Architects

Module Name:

    fdc.c

Abstract:

    This is the NEC PD756 (aka AT, aka IS1A, aka ix86) and Intel 82077
    (aka MIPS) floppy diskette driver for NT.

Environment:

    Kernel mode only.

--*/

//
// Include files.
//

#include "stdio.h"
#include "ntddk.h"
#include "ntdddisk.h"                    // disk device driver I/O control codes
#include "ntddfdc.h"                     // fdc I/O control codes and parameters
#include <fdc_data.h>                    // this driver's data declarations
#include <flpyenbl.h>
#include <q117_dat.h>

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) > (b) ? (b) : (a))

COMMAND_TABLE CommandTable[] = {
    { 0x06, 8, 1, 7,  TRUE,  TRUE,  FDC_READ_DATA  },   // Read Data
    { 0x0C, 0, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Not Implemented (MIPS)
    { 0x05, 8, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA },   // Write Data
    { 0x09, 0, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Not Implemented
    { 0x02, 8, 1, 7,  TRUE,  TRUE,  FDC_READ_DATA  },   // Read Track
    { 0x16, 8, 1, 7,  TRUE,  FALSE, FDC_NO_DATA    },   // Verify
    { 0x10, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Version
    { 0x0D, 5, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA },   // Format Track
    { 0x11, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan Equal
    { 0x19, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan Low Or Equal
    { 0x1D, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan High Or Equal
    { 0x07, 1, 0, 2,  TRUE,  TRUE,  FDC_NO_DATA    },   // Recalibrate
    { 0x08, 0, 0, 2,  FALSE, TRUE,  FDC_NO_DATA    },   // Sense Interrupt Status
    { 0x03, 2, 0, 0,  FALSE, TRUE,  FDC_NO_DATA    },   // Specify
    { 0x04, 1, 0, 1,  FALSE, TRUE,  FDC_NO_DATA    },   // Sense Drive Status
    { 0x8E, 6, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Drive Specification Command
    { 0x0F, 2, 0, 2,  TRUE,  TRUE,  FDC_NO_DATA    },   // Seek
    { 0x13, 3, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Configure
    { 0x8F, 2, 0, 2,  TRUE,  FALSE, FDC_NO_DATA    },   // Relative Seek
    { 0x0E, 0, 0, 10, FALSE, FALSE, FDC_NO_DATA    },   // Dumpreg
    { 0x0A, 1, 1, 7,  TRUE,  TRUE,  FDC_NO_DATA    },   // Read ID
    { 0x12, 1, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Perpendicular Mode
    { 0x14, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Lock
    { 0x18, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Part ID
    { 0x17, 1, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Powerdown Mode
    { 0x33, 1, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Option
    { 0x2E, 0, 0, 16, FALSE, FALSE, FDC_NO_DATA    },   // Save
    { 0x4E, 16, 0, 0, FALSE, FALSE, FDC_NO_DATA    },   // Restore
    { 0xAD, 5, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA }    // Format And Write
};

//
// This is the actual definition of FdcDebugLevel.
// Note that it is only defined if this is a "debug"
// build.
//
#if DBG
extern ULONG FdcDebugLevel = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'polF')
#endif

BOOLEAN FdcInSetupMode;

//
// Used for paging the driver.
//
ULONG PagingReferenceCount = 0;
PFAST_MUTEX PagingMutex = NULL;

ULONG NumberOfBuffers = 0;
ULONG BufferSize = 0;
ULONG Model30 = 0;
ULONG NotConfigurable = 0;

//  Feb.9.1998 KIADP011 Get base address of configuration ports
//  and device identifier
#ifdef TOSHIBAJ
ULONG   SmcConfigBase;
ULONG   SmcConfigID;
PUCHAR  TranslatedConfigBase = NULL;

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  This routine can be called any number of times,
    as long as the IO system and the configuration manager conspire to
    give it an unmanaged controller to support at each call.  It could
    also be called a single time and given all of the controllers at
    once.

    It initializes the passed-in driver object, calls the configuration
    manager to learn about the devices that it is to support, and for
    each controller to be supported it calls a routine to initialize the
    controller (and all drives attached to it).

Arguments:

    DriverObject - a pointer to the object that represents this device
    driver.

Return Value:

    If we successfully initialize at least one drive, STATUS_SUCCESS is
    returned.

    If we don't (because the configuration manager returns an error, or
    the configuration manager says that there are no controllers or
    drives to support, or no controllers or drives can be successfully
    initialized), then the last error encountered is propogated.

--*/

{
    NTSTATUS ntStatus;

    //
    // We use this to query into the registry as to whether we
    // should break at driver entry.
    //

    RTL_QUERY_REGISTRY_TABLE paramTable[6];
    ULONG zero = 0;
    ULONG one = 1;
    ULONG debugLevel = 0;
    ULONG shouldBreak = 0;
    ULONG setupMode;
    PWCHAR path;
    UNICODE_STRING parameters;
    UNICODE_STRING systemPath;
    UNICODE_STRING identifier;
    UNICODE_STRING thinkpad, ps2e;
    ULONG pathLength;

    RtlInitUnicodeString(&parameters, L"\\Parameters");
    RtlInitUnicodeString(&systemPath,
        L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\System");
    RtlInitUnicodeString(&thinkpad, L"IBM THINKPAD 750");
    RtlInitUnicodeString(&ps2e, L"IBM PS2E");

    pathLength = RegistryPath->Length + parameters.Length + sizeof(WCHAR);
    if (pathLength < systemPath.Length + sizeof(WCHAR)) {
        pathLength = systemPath.Length + sizeof(WCHAR);
    }

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //
    NumberOfBuffers = 3;
    BufferSize = 0x8000;

    if (path = ExAllocatePool(PagedPool, pathLength)) {

        RtlZeroMemory(&paramTable[0],
                      sizeof(paramTable));
        RtlZeroMemory(path, pathLength);
        RtlMoveMemory(path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);

        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"BreakOnEntry";
        paramTable[0].EntryContext = &shouldBreak;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"DebugLevel";
        paramTable[1].EntryContext = &debugLevel;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);
        paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name = L"NumberOfBuffers";
        paramTable[2].EntryContext = &NumberOfBuffers;
        paramTable[2].DefaultType = REG_DWORD;
        paramTable[2].DefaultData = &NumberOfBuffers;
        paramTable[2].DefaultLength = sizeof(ULONG);
        paramTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name = L"BufferSize";
        paramTable[3].EntryContext = &BufferSize;
        paramTable[3].DefaultType = REG_DWORD;
        paramTable[3].DefaultData = &BufferSize;
        paramTable[3].DefaultLength = sizeof(ULONG);
        paramTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[4].Name = L"SetupDone";
        paramTable[4].EntryContext = &setupMode;
        paramTable[4].DefaultType = REG_DWORD;
        paramTable[4].DefaultData = &zero;
        paramTable[4].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                path,
                                &paramTable[0],
                                NULL,
                                NULL))) {

            shouldBreak = 0;
            debugLevel = 0;

        }

        FdcInSetupMode = !(BOOLEAN)setupMode;

        FdcDump( FDCSHOW, ("FdcDriverEntry: FdcInSetupMode = %x\n",FdcInSetupMode) );

        if ( FdcInSetupMode ) {

            OBJECT_ATTRIBUTES keyAttributes;
            HANDLE keyHandle;
            UNICODE_STRING value;

            RtlInitUnicodeString( &value, L"SetupDone" );
            setupMode = 1;

            InitializeObjectAttributes( &keyAttributes,
                                        RegistryPath,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );

            ntStatus = ZwOpenKey( &keyHandle,
                                  KEY_ALL_ACCESS,
                                  &keyAttributes );

            if ( NT_SUCCESS(ntStatus) ) {

                FdcDump( FDCSHOW, ("FdcDriverEntry: Set SetupMode Value in Registry\n") );

                ZwSetValueKey( keyHandle,
                               &value,
                               0,
                               REG_DWORD,
                               &setupMode,
                               sizeof(ULONG) );

                ZwClose( keyHandle);
            }
        }

        //
        // Determine whether or not this type of system has a
        // model 30 floppy controller.
        //

        RtlZeroMemory(paramTable, sizeof(paramTable));
        RtlZeroMemory(path, pathLength);
        RtlMoveMemory(path,
                      systemPath.Buffer,
                      systemPath.Length);


        RtlZeroMemory(&identifier, sizeof(UNICODE_STRING));
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT |
                              RTL_QUERY_REGISTRY_REQUIRED;
        paramTable[0].Name = L"Identifier";
        paramTable[0].EntryContext = &identifier;

        if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                              path,
                                              paramTable,
                                              NULL,
                                              NULL))) {


            if (identifier.Length == thinkpad.Length &&
                RtlCompareMemory(identifier.Buffer, thinkpad.Buffer,
                                 thinkpad.Length) == thinkpad.Length) {

                Model30 = 1;

            } else if (identifier.Length == ps2e.Length &&
                       RtlCompareMemory(identifier.Buffer, ps2e.Buffer,
                                        ps2e.Length) == ps2e.Length) {

                Model30 = 1;
            } else {
                Model30 = 0;
            }
        } else {
            Model30 = 0;
        }

        //
        // This part gets from the parameters part of the registry
        // to see if the controller configuration needs to be disabled.
        // Doing this lets SMC 661, and 662 work.  On hardware that
        // works normally, this change will show a slowdown of up
        // to 40%.  So defining this variable is not recommended
        // unless things don't work without it.
        //
        //
        // Also check the model30 value in the parameters section
        // that is used to override the decision above.
        //

        RtlZeroMemory(&paramTable[0],
                      sizeof(paramTable));
        RtlZeroMemory(path,
                      RegistryPath->Length+parameters.Length+sizeof(WCHAR));
        RtlMoveMemory(path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);
        RtlMoveMemory((PCHAR) path + RegistryPath->Length,
                      parameters.Buffer,
                      parameters.Length);

        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"NotConfigurable";
        paramTable[0].EntryContext = &NotConfigurable;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"Model30";
        paramTable[1].EntryContext = &Model30;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = Model30 ? &one : &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                path,
                                &paramTable[0],
                                NULL,
                                NULL))) {

            NotConfigurable = 0;
        }

#ifdef TOSHIBAJ
        // Feb.9.1998 KIADP011 Get base address and identifier
        RtlZeroMemory(&paramTable[0],
                      sizeof(paramTable));
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"ConfigurationBase";
        paramTable[0].EntryContext = &SmcConfigBase;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"ControllerID";
        paramTable[1].EntryContext = &SmcConfigID;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                               path,
                                               &paramTable[0],
                                               NULL,
                                               NULL))) {
            SmcConfigBase = 0;
            SmcConfigID = 0;
        }

#endif

    }

    //
    // We don't need that path anymore.
    //
    if (path) {
        ExFreePool(path);
    }

#if DBG
    FdcDebugLevel = debugLevel;
#endif
    if (shouldBreak) {
        DbgBreakPoint();
    }


    FdcDump(FDCSHOW,
               ("Fdc: DriverEntry...\n"));


    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = FdcCreateClose;
    DriverObject->MajorFunction[IRP_MJ_POWER]  = FdcPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]    = FdcPnp;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                 FdcInternalDeviceControl;

    DriverObject->DriverStartIo = FdcStartIo;
    DriverObject->DriverExtension->AddDevice = FdcAddDevice;

    FDC_PAGE_INITIALIZE_DRIVER_WITH_MUTEX;

    return STATUS_SUCCESS;
}

NTSTATUS
FdcAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.

    A floppy controller device has been enumerated by the root/firmware
    enumerator.  Create an FDO and attach it to this PDO.

Arguments:

    BusDeviceObject - Device object representing the floppy controller.  That
    to which we attach a new FDO.

    DriverObject - This driver.

Return Value:

    STATUS_SUCCESS if the device is successfully created.

--*/
{

    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject;
    PFDC_FDO_EXTENSION  fdoExtension;
    UNICODE_STRING      deviceName;

    FdcDump( FDCSHOW, ("FdcAddDevice:  CreateDeviceObject\n"));

    //
    //  Create the FDO device.
    //
    //  JB:TBD - Still need to resolve device naming.  For the time being,
    //  this device is unnamed (per the gameport example).
    //
    ntStatus = IoCreateDevice( DriverObject,
                               sizeof( FDC_FDO_EXTENSION ),
                               NULL,
                               FILE_DEVICE_CONTROLLER,
                               FILE_DEVICE_SECURE_OPEN,
                               TRUE,
                               &deviceObject );

    if ( NT_SUCCESS(ntStatus) ) {

        //
        //  Initialize the fdoExtension for this device.
        //
        fdoExtension = deviceObject->DeviceExtension;

        fdoExtension->IsFDO        = TRUE;
        fdoExtension->DriverObject = DriverObject;
        fdoExtension->Self         = deviceObject;
        fdoExtension->OutstandingRequests = 1;
        fdoExtension->TapeEnumerationPending = FALSE;

        KeInitializeEvent( &fdoExtension->TapeEnumerationEvent,
                           SynchronizationEvent,
                           TRUE );

        KeInitializeEvent( &fdoExtension->RemoveEvent,
                           SynchronizationEvent,
                           FALSE );

        InitializeListHead( &fdoExtension->PDOs );

        //
        //  Initialize a queue for power management.
        //
        InitializeListHead( &fdoExtension->PowerQueue );
        KeInitializeSpinLock( &fdoExtension->PowerQueueSpinLock );

        //
        //  Initialize a variable to hold the last motor settle
        //  time that we have seen.  We will use this when we turn
        //  the floppy motor back on after a power event.
        //
        fdoExtension->LastMotorSettleTime.QuadPart = 0;

        //
        // Set the PDO for use with PlugPlay functions
        //
        fdoExtension->UnderlyingPDO = BusPhysicalDeviceObject;

        //
        //  Now attach to the PDO so that we have a target for PnP and
        //  Power irps that we need to pass on.
        //
        FdcDump( FDCSHOW, ("AddDevice: Attaching %p to %p\n",
                           deviceObject,
                           BusPhysicalDeviceObject));

        fdoExtension->TargetObject = IoAttachDeviceToDeviceStack( deviceObject,
                                                                  BusPhysicalDeviceObject );

        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags |= DO_POWER_PAGABLE;

        if ( deviceObject->AlignmentRequirement < FILE_WORD_ALIGNMENT ) {

            deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
        }

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    return ntStatus;
}

NTSTATUS
FdcPnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this Pnp request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_EXTENSION_HEADER extensionHeader;
    KIRQL oldIrq;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    //
    // Lock down the driver code in memory if it is not already.
    //

    FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

    if ( extensionHeader->IsFDO ) {

        ntStatus = FdcFdoPnp( DeviceObject, Irp );

    } else {

        ntStatus = FdcPdoPnp( DeviceObject, Irp );
    }

    //
    //  Page out the driver if it is not busy elsewhere.
    //

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    return ntStatus;
}

NTSTATUS
FdcFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Plug-and-Play
    functions.  This routine handles messages to the FDO which is part
    of the bus DevNode.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    //
    //  Incerement our queued request counter.
    //
    InterlockedIncrement( &fdoExtension->OutstandingRequests);

    if ( fdoExtension->Removed ) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        if ( InterlockedDecrement( &fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        return STATUS_DELETE_PENDING;
    }

    switch (irpSp->MinorFunction) {

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:

        ntStatus = FdcFilterResourceRequirements( DeviceObject, Irp );

        break;

    case IRP_MN_START_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_START_DEVICE - Irp: %p\n", Irp) );

        //
        // First we must pass this Irp on to the underlying PDO.
        //
        KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine( Irp,
                                FdcPnpComplete,
                                &doneEvent,
                                TRUE,
                                TRUE,
                                TRUE );

        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        if ( ntStatus == STATUS_PENDING ) {

            ntStatus = KeWaitForSingleObject( &doneEvent,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL );

            ASSERT( ntStatus == STATUS_SUCCESS );

            ntStatus = Irp->IoStatus.Status;
        }
        //
        //  Try to start the floppy disk controller.
        //
        if ( NT_SUCCESS(ntStatus) ) {

            ntStatus = FdcStartDevice( DeviceObject, Irp );
        }

        Irp->IoStatus.Status = ntStatus;

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_START_DEVICE %08x %08x\n",Irp->IoStatus.Status,Irp->IoStatus.Information) );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_QUERY_REMOVE_DEVICE - Irp: %p\n", Irp) );

        //
        //  If the controller is in use (acquired) then we will not allow
        //  the device to be removed.
        //

        KeWaitForSingleObject( &fdoExtension->TapeEnumerationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        if ( fdoExtension->ControllerInUse ||
             fdoExtension->TapeEnumerationPending ) {

            ntStatus = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            //
            //  If the controller was not in use we will set it so now
            //  so that any other attempted accesses to the fdc will have
            fdoExtension->ControllerInUse = TRUE;
            IoSkipCurrentIrpStackLocation( Irp );
            ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Irp: %p\n", Irp) );

        IoSkipCurrentIrpStackLocation( Irp );
        IoCallDriver( fdoExtension->TargetObject, Irp );

        if ( fdoExtension->FdcEnablerFileObject != NULL ) {
            ObDereferenceObject( fdoExtension->FdcEnablerFileObject );
        }

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Detach from device %p\n", fdoExtension->TargetObject) );
        IoDetachDevice( fdoExtension->TargetObject );

        //
        //  Close the named synchronization event we opened at start time.
        //
        ZwClose( fdoExtension->AcquireEventHandle );

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Delete device %p\n", fdoExtension->Self) );
        IoDeleteDevice( fdoExtension->Self );

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_CANCEL_REMOVE_DEVICE - Irp: %p\n", Irp) );
        fdoExtension->ControllerInUse = FALSE;

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_QUERY_STOP_DEVICE - Irp: %p\n", Irp) );

        if ( fdoExtension->ControllerInUse ||
             fdoExtension->TapeEnumerationPending ) {

            ntStatus = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            fdoExtension->ControllerInUse = TRUE;
            IoSkipCurrentIrpStackLocation( Irp );
            ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );
        }

        break;

    case IRP_MN_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_STOP_DEVICE - Irp: %p\n", Irp) );

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_CANCEL_STOP_DEVICE - Irp: %p\n", Irp) );

        fdoExtension->ControllerInUse = FALSE;
        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_QUERY_DEVICE_RELATIONS - Irp: %p\n", Irp) );

        ntStatus = FdcQueryDeviceRelations( DeviceObject, Irp );

        break;

    default:

        FdcDump( FDCSHOW, ("FdcFdoPnp: Unsupported PNP Request %x\n",irpSp->MinorFunction) );

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;
    }

    if ( InterlockedDecrement( &fdoExtension->OutstandingRequests ) == 0 ) {
        KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
    }
    return ntStatus;
}

NTSTATUS
FdcPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.  We use this completion routine when
    we must post-process the irp after we are sure that the PDO is done
    with it.

Arguments:

    DeviceObject - a pointer to our FDO
    Irp - a pointer to the completed Irp
    Context - an event that we will set indicating the irp is completed.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED so that control will be returned to
    our calling routine.

--*/
{

    if ( Irp->PendingReturned ) {

        IoMarkIrpPending( Irp );
    }

    KeSetEvent( (PKEVENT)Context, 1, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
FdcPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Plug-and-Play
    functions.  This routine handles messages to the PDO which is part
    of the bus DevNode.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PFDC_PDO_EXTENSION pdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;

    pdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = Irp->IoStatus.Status;

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_QUERY_CAPABILITIES: {

        PDEVICE_CAPABILITIES deviceCapabilities;

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_CAPABILITIES - Irp: %p\n", Irp) );

        deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;

        //
        //  Fill in the device capabilities structure and return it.  The
        //  capabilities structure is in irpSp->Parameters.DeviceCapabilities.Capabilities;
        //
        //  The size and Version should already be set appropraitely.
        //
        ASSERT( deviceCapabilities->Version == 1 );
        ASSERT( deviceCapabilities->Size == sizeof(DEVICE_CAPABILITIES) );

        //
        //  JB:TBD - not sure how to set these flags.
        //
        deviceCapabilities->LockSupported = FALSE;  //  No locking.
        deviceCapabilities->EjectSupported = FALSE; //  No ejection mechanism.
        deviceCapabilities->Removable = FALSE;      //  Device is not removable (what about external laptop drives?)
        deviceCapabilities->DockDevice = FALSE;     //  Device is not a docking device (this probably should be TRUE)
        deviceCapabilities->UniqueID = FALSE;       //  ???
        deviceCapabilities->SilentInstall = TRUE;   //  ???
        deviceCapabilities->RawDeviceOK = FALSE;    //  ???

//        deviceCapabilities->Address;
//        deviceCapabilities->UINumber;
//
//        deviceCapabilities->DeviceState[PowerSystemMaximum];
//        deviceCapabilities->SystemWake;
//        deviceCapabilities->DeviceWake;
//
//        deviceCapabilities->D1Latency;
//        deviceCapabilities->D2Latency;
//        deviceCapabilities->D3Latency;

        ntStatus = STATUS_SUCCESS;
        break;
    }

    case IRP_MN_QUERY_ID:

        //
        // Query the IDs of the device
        //
        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_ID - Irp: %p\n", Irp) );
        FdcDump( FDCSHOW, ("FdcPdoPnp:   IdType %x\n", irpSp->Parameters.QueryId.IdType) );

        ntStatus = STATUS_SUCCESS;

        switch ( irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            // return a WCHAR (null terminated) string describing the device
            // For symplicity we make it exactly the same as the Hardware ID.
        case BusQueryHardwareIDs: {

            UCHAR idString[25];
            ANSI_STRING ansiId;
            UNICODE_STRING uniId;
            PWCHAR buffer;
            ULONG length;

            RtlZeroMemory( idString, 25 );

            switch ( pdoExtension->DeviceType ) {

            case FloppyDiskDevice:

                // return a multi WCHAR (null terminated) string (null terminated)
                // array for use in matching hardare ids in inf files;
                //
                sprintf( idString, "FDC\\PNP07%02X", pdoExtension->Instance );

                break;

            case FloppyTapeDevice:

                //
                //  Examine the tape vendor id and build the id string
                //  appropriately.
                //
                if ( pdoExtension->TapeVendorId == -1 ) {

                    strcpy( idString, "FDC\\QICLEGACY" );

                } else {

                    sprintf( idString, "FDC\\QIC%04X", (USHORT)pdoExtension->TapeVendorId );

                }
                break;

            case FloppyControllerDevice:

                sprintf( idString, "FDC\\ENABLER" );

                break;
            }

            //
            //  Allocate enough memory for the string and 2 null characters since
            //  this is a multisz type.
            //
            length = strlen( idString ) * sizeof (WCHAR) + 2 * sizeof(WCHAR);

            buffer = ExAllocatePool (PagedPool, length);

            if ( buffer == NULL ) {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlZeroMemory( buffer, length );

            ansiId.Length = ansiId.MaximumLength = (USHORT) strlen( idString );
            ansiId.Buffer = idString;

            uniId.Length = 0;
            uniId.MaximumLength = (USHORT)length;
            uniId.Buffer = buffer;

            RtlAnsiStringToUnicodeString( &uniId, &ansiId, FALSE );

            Irp->IoStatus.Information = (UINT_PTR) buffer;

            break;
        }

        case BusQueryCompatibleIDs:{

            PWCHAR buffer = NULL;
            USHORT length;

            //
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.
            //
            switch ( pdoExtension->DeviceType ) {

            case FloppyDiskDevice:

                length = FDC_FLOPPY_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);

                buffer = ExAllocatePool( PagedPool, length );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopyMemory( buffer, FDC_FLOPPY_COMPATIBLE_IDS, length );
                    buffer[7] = L'0' + pdoExtension->Instance;
                }

                break;

            case FloppyTapeDevice:

                if ( pdoExtension->TapeVendorId != -1 ) {

                    length = FDC_TAPE_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);

                    buffer = ExAllocatePool( PagedPool, length );

                    if ( buffer == NULL ) {

                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        RtlCopyMemory( buffer, FDC_TAPE_COMPATIBLE_IDS, length );
                    }
                }
                break;

            case FloppyControllerDevice:

                length = FDC_CONTROLLER_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);

                buffer = ExAllocatePool( PagedPool, length );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopyMemory( buffer, FDC_CONTROLLER_COMPATIBLE_IDS, length );
                }

                break;
            }

            Irp->IoStatus.Information = (UINT_PTR)buffer;
            break;
        }

        case BusQueryInstanceID: {

            PWCHAR idString = L"0";
            PWCHAR buffer;

            //
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.

            buffer = ExAllocatePool( NonPagedPool, 4 );

            if ( buffer == NULL ) {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                buffer[0] = L'0' + pdoExtension->Instance;
                buffer[1] = 0;

                Irp->IoStatus.Information = (UINT_PTR)buffer;
            }

            break;
        }
        }

        break;

    case IRP_MN_START_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_START_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_CANCEL_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_REMOVE_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_DEVICE_BUSY;
        break;

    case IRP_MN_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_REMOVE_DEVICE - Irp: %p\n", Irp) );
        pdoExtension->Removed = TRUE;
        IoDeleteDevice( DeviceObject );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_CANCEL_REMOVE_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    default:

        FdcDump( FDCSHOW, ("FdcPdoPnp: Unsupported PNP Request %x\n",irpSp->MinorFunction) );

        // this is a leaf node
        // status = STATUS_NOT_IMPLEMENTED
        // For PnP requests to the PDO that we do not understand we should
        // return the IRP WITHOUT setting the status or information fields.
        // They may have already been set by a filter (eg acpi).

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    FdcDump( FDCSHOW, ("FdcPdoPnp: Return Status - %08x\n", ntStatus) );
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Power functions

Arguments:

    DeviceObject - a pointer to the object that represents the device.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;
    KEVENT doneEvent;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    FdcDump( FDCSHOW, ("FdcPower:\n"));

    if ( fdoExtension->IsFDO ) {

        if ( fdoExtension->Removed ) {

            ntStatus = STATUS_DELETE_PENDING;
            PoStartNextPowerIrp( Irp );
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            switch ( irpSp->MinorFunction ) {

            case IRP_MN_WAIT_WAKE:
            case IRP_MN_POWER_SEQUENCE:
            case IRP_MN_QUERY_POWER:

                //
                //  Just forward this irp to the underlying device.
                //
                PoStartNextPowerIrp( Irp );
                IoSkipCurrentIrpStackLocation( Irp );
                ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );

                break;

            case IRP_MN_SET_POWER:

                //
                // Lock down the driver code in memory if it is not already.
                //

                FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

                if ( irpSp->Parameters.Power.Type == SystemPowerState ) {

                    //
                    //  If we are transitioning to a 'sleep' state start queueing
                    //  irps.
                    //
                    if ( fdoExtension->CurrentPowerState <= PowerSystemWorking &&
                         irpSp->Parameters.Power.State.SystemState > PowerSystemWorking ) {

                        //
                        //  If the device queue is not empty, wait for it now.
                        //
                        fdoExtension->CurrentPowerState = irpSp->Parameters.Power.State.SystemState;

//                        KeWaitForSingleObject( &fdoExtension->RemoveEvent,
//                                               Executive,
//                                               KernelMode,
//                                               FALSE,
//                                               NULL );

                        //
                        //  Make sure that the motors are turned off
                        //
                        if (!IsNEC_98) {
                            WRITE_CONTROLLER(
                                fdoExtension->ControllerAddress.DriveControl,
                                (UCHAR)(fdoExtension->DriveControlImage & ~DRVCTL_MOTOR_MASK) );
                        } // (!IsNEC_98)

                        //
                        //  Now forward this irp to the underlying PDO.
                        //
                        PoStartNextPowerIrp( Irp );
                        IoSkipCurrentIrpStackLocation( Irp );
                        ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );

                    //
                    //  Otherwise, if we are transitioning from a non-working state
                    //  back to a working state turn the motor back on if it was on.
                    //
                    } else if ( fdoExtension->CurrentPowerState > PowerSystemWorking &&
                                irpSp->Parameters.Power.State.SystemState <= PowerSystemWorking ) {

                        //
                        // Pass this irp down to the PDO before proceeding.
                        //
                        KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

                        IoCopyCurrentIrpStackLocationToNext(Irp);

                        IoSetCompletionRoutine( Irp,
                                                FdcPnpComplete,
                                                &doneEvent,
                                                TRUE,
                                                TRUE,
                                                TRUE );

                        ntStatus = PoCallDriver( fdoExtension->TargetObject, Irp );

                        if ( ntStatus == STATUS_PENDING ) {

                            KeWaitForSingleObject( &doneEvent, Executive, KernelMode, FALSE, NULL );
                        }

                        if ( fdoExtension->DriveControlImage & DRVCTL_MOTOR_MASK ) {

                            WRITE_CONTROLLER(
                                fdoExtension->ControllerAddress.DriveControl,
                                fdoExtension->DriveControlImage );

                            if ( fdoExtension->LastMotorSettleTime.QuadPart > 0) {

                                KeDelayExecutionThread( KernelMode,
                                                        FALSE,
                                                        &fdoExtension->LastMotorSettleTime );
                            }
                        }

                        fdoExtension->CurrentPowerState = irpSp->Parameters.Power.State.SystemState;

                        //
                        //  Set a flag to simulate a disk change event so that
                        //  we will be sure to touch the floppy drive hardware
                        //  the next time it is accessed in case it was removed.
                        //
                        fdoExtension->WakeUp = TRUE;

                        PoStartNextPowerIrp( Irp );
                        IoCompleteRequest( Irp, IO_NO_INCREMENT );

                    } else {
                        //
                        //  We must just be changing non-working states.  We
                        //  ignore this activity but pass the irp on to the
                        //  underlying device.
                        //
                        PoStartNextPowerIrp( Irp );
                        IoSkipCurrentIrpStackLocation( Irp );
                        ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );
                    }

                } else {
                    //
                    //  We only handle system power states so if this is a
                    //  device state irp just forward it to the underlying
                    //  device.
                    //
                    PoStartNextPowerIrp( Irp );
                    IoSkipCurrentIrpStackLocation( Irp );
                    ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );
                }

                //
                //  Page out the driver if it is not busy elsewhere.
                //

                FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

                break;
            }
        }

    } else {

        //
        //  We are not yet doing any power management on the floppy controller.
        //
        switch (irpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
            break;

        case IRP_MN_POWER_SEQUENCE:
            break;

        case IRP_MN_SET_POWER:
            break;

        case IRP_MN_QUERY_POWER:
            break;
        }

        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return ntStatus;
}

NTSTATUS
FdcStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine attempts to start the floppy controller device.  Starting
    the floppy controller consists primarily of resetting it and configuring
    it, mostly just to make sure that it is there.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;

    BOOLEAN foundPortA = FALSE;
    BOOLEAN foundPortB = FALSE;
    BOOLEAN foundDma = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    ULONG currentBase = 0xFFFFFFFF;

    PCM_RESOURCE_LIST translatedResources;
    PCM_FULL_RESOURCE_DESCRIPTOR fullList;
    PCM_PARTIAL_RESOURCE_LIST partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    ULONG i;
    ULONG startOffset;
    ULONG currentOffset;

    UCHAR ioPortMap;

#ifdef TOSHIBAJ
    BOOLEAN foundConfigIndex = FALSE;
    BOOLEAN foundConfigData = FALSE;
#endif

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Ask the PDO if it is a tape enabler device and, if so, what
    //  is the enabler device object.
    //
    FdcGetEnablerDevice( fdoExtension );

    if ( fdoExtension->FdcEnablerSupported ) {

        INTERFACE_TYPE InterfaceType;

        //
        //  This is a tape enabler card so we need to get the resources
        //  'the old-fashinoed way'.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 FdcFdoConfigCallBack,
                                                 fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }

        if ( fdoExtension->FdcEnablerDeviceObject == NULL ) {

            ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        } else {

            ntStatus = STATUS_SUCCESS;
        }

    } else {

        //
        //  Now that the PDO is done with the Irp we can have our way with
        //  it.
        //
        FdcDump( FDCSHOW, ("AllocatedResources = %08x\n",irpSp->Parameters.StartDevice.AllocatedResources));
        FdcDump( FDCSHOW, ("AllocatedResourcesTranslated = %08x\n",irpSp->Parameters.StartDevice.AllocatedResourcesTranslated));

        if ( irpSp->Parameters.StartDevice.AllocatedResources == NULL ||
             irpSp->Parameters.StartDevice.AllocatedResourcesTranslated == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Set up the resource information that we will use to access the
        //  controller hardware.  We always expect only 1 full set of resources.
        //  In that list we expect a DMA channel, an Interrupt vector, and 2 I/O Port
        //  ranges.  If we don't see all the required resources we will woof.
        //
        translatedResources = irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

        ASSERT( translatedResources->Count == 1 );

        fullList = &translatedResources->List[0];
        partialList = &translatedResources->List[0].PartialResourceList;

        //
        //  Enumerate the list of resources, adding them into our context as we go.
        //
        RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );

        for ( i = 0; i < partialList->Count; i++ ) {

            partial = &partialList->PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {

                if (IsNEC_98) {
                    if ( partial->u.Port.Length == 1 ) {
                        if (!fdoExtension->ControllerAddress.Status) {
                            fdoExtension->ControllerAddress.Status
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.Fifo) {
                            fdoExtension->ControllerAddress.Fifo
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.DriveControl) {
                            fdoExtension->ControllerAddress.DriveControl
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.ModeChange) {
                            fdoExtension->ControllerAddress.ModeChange
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.ModeChangeEx) {
                            fdoExtension->ControllerAddress.ModeChangeEx
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        }
                    }

                    break;
                }

                //
                //  If we get a base address that is lower than anything we have seen
                //  before, we assume that we have been working with aliased addresses
                //  and start over with the new base address.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) < currentBase ) {

#ifdef TOSHIBAJ
                    // Skip the descriptor including config ports only.
                    if ( !TranslatedConfigBase
                      || ((partial->u.Port.Start.LowPart & 0xFFFFFFF8) != (ULONG)TranslatedConfigBase)
                      || ((partial->u.Port.Start.LowPart & 0x7) + partial->u.Port.Length > 2) ) {
                        RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                        currentBase = partial->u.Port.Start.LowPart & 0xFFFFFFF8;
                        FdcDump( FDCINFO,
                            ("FdcStartDevice: Current base %04x\n", currentBase) );
                    }
#else
                    RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                    currentBase = partial->u.Port.Start.LowPart & 0xFFFFFFF8;
#endif
                }

                //
                //  We only use resources that are associated with the current (lowest)
                //  base addressed.  All others are assumed to be aliased and are not
                //  used.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) == currentBase ) {

                    FdcDump( FDCINFO,
                             ("FdcStartDevice: Adding - %04x, Length - %04x\n",
                             partial->u.Port.Start.LowPart,
                             partial->u.Port.Length) );

                    startOffset = partial->u.Port.Start.LowPart & 0x07;

                    if ( (partial->Flags & CM_RESOURCE_PORT_IO) == CM_RESOURCE_PORT_MEMORY ) {

                        fdoExtension->ControllerAddress.Address[startOffset] =
                            MmMapIoSpace( partial->u.Port.Start,
                                          partial->u.Port.Length,
                                          FALSE );

                        FdcDump( FDCINFO, ("FdcStartDevice: Mapped IoPort\n") );

                    } else {

                        fdoExtension->ControllerAddress.Address[startOffset] = (PUCHAR)partial->u.Port.Start.LowPart;
                    }

                    currentOffset = 1;
                    while ( currentOffset < partial->u.Port.Length ) {

                        fdoExtension->ControllerAddress.Address[startOffset + currentOffset] =
                            fdoExtension->ControllerAddress.Address[startOffset] + currentOffset;
                        ++currentOffset;
                    }
                }

#ifdef TOSHIBAJ
                // Are there configuration ports in a descriptor ?
                if ( TranslatedConfigBase
                  && (partial->u.Port.Start.LowPart <= (ULONG)TranslatedConfigBase)
                  && (partial->u.Port.Start.LowPart + partial->u.Port.Length > (ULONG)TranslatedConfigBase) ) {
                    foundConfigIndex = TRUE;
                    FdcDump( FDCINFO,
                        ("FdcStartDevice: Configration index port in %04x (length %04x)\n",
                        partial->u.Port.Start.LowPart,
                        partial->u.Port.Length) );
                }

                if ( TranslatedConfigBase
                  && (partial->u.Port.Start.LowPart <= (ULONG)TranslatedConfigBase + 1)
                  && (partial->u.Port.Start.LowPart + partial->u.Port.Length > (ULONG)TranslatedConfigBase + 1) ) {
                    foundConfigData = TRUE;
                    FdcDump( FDCINFO,
                        ("FdcStartDevice: Configration data port in %04x (length %04x)\n",
                        partial->u.Port.Start.LowPart,
                        partial->u.Port.Length) );
                }

                if (foundConfigIndex && foundConfigData) {
                    fdoExtension->ConfigBase = (PUCHAR)SmcConfigBase;
                    fdoExtension->Available3Mode = TRUE;
                }
#endif
                break;
            }

            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                FdcDump( FDCINFO, ("FdcStartDevice: DMA - %04x\n", partial->u.Dma.Channel) );

                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                //
                // Always ask for one more page than maximum transfer size.
                //
                deviceDesc.MaximumLength += PAGE_SIZE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = fullList->InterfaceType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                deviceDesc.AutoInitialize = FALSE;

                fdoExtension->AdapterObject =
                    HalGetAdapter( &deviceDesc,
                                   &fdoExtension->NumberOfMapRegisters );

                if (!fdoExtension->AdapterObject) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                //  Here we can get another adapter object for formatting.  It
                //  should look the same as the previous one except AutoInitialize
                //  will be true.
                //

                break;
            }

            case CmResourceTypeInterrupt: {

                FdcDump( FDCINFO, ("FdcStartDevice: IRQ - %04x\n", partial->u.Interrupt.Vector) );

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;
                }

                if (IsNEC_98) {

                    //
                    // NOTENOTE: Invalid Interrupt Level and Vector.
                    //

                    partial->u.Interrupt.Level  = 0x0b;
                    partial->u.Interrupt.Vector = 0x13;

                    //
                    // We get the Vector with HalGetInterruptVector().
                    //

                    fdoExtension->ControllerVector =
                        HalGetInterruptVector( fullList->InterfaceType,
                                               fullList->BusNumber,
                                               partial->u.Interrupt.Level,
                                               partial->u.Interrupt.Vector,
                                               &fdoExtension->ControllerIrql,
                                               &fdoExtension->ProcessorMask );

                    FdcDump( FDCSHOW,
                             ("Resource Requirements - ControllerVector = 0x%x\n",
                             fdoExtension->ControllerVector) );

                } else {
                    fdoExtension->ControllerVector = partial->u.Interrupt.Vector;
                    fdoExtension->ProcessorMask = partial->u.Interrupt.Affinity;
                    fdoExtension->ControllerIrql = (KIRQL)partial->u.Interrupt.Level;
                }
                fdoExtension->SharableVector = TRUE;
                fdoExtension->SaveFloatState = FALSE;

                break;
            }

            default:

                break;
            }
        }

        FdcDump( FDCINFO, ("FdcStartDevice: ControllerAddress.StatusA      = %08x\n"
                           "FdcStartDevice: ControllerAddress.StatusB      = %08x\n"
                           "FdcStartDevice: ControllerAddress.DriveControl = %08x\n"
                           "FdcStartDevice: ControllerAddress.Tape         = %08x\n"
                           "FdcStartDevice: ControllerAddress.Status       = %08x\n"
                           "FdcStartDevice: ControllerAddress.Fifo         = %08x\n"
                           "FdcStartDevice: ControllerAddress.DRDC         = %08x\n",
                           fdoExtension->ControllerAddress.StatusA,
                           fdoExtension->ControllerAddress.StatusB,
                           fdoExtension->ControllerAddress.DriveControl,
                           fdoExtension->ControllerAddress.Tape,
                           fdoExtension->ControllerAddress.Status,
                           fdoExtension->ControllerAddress.Fifo,
                           fdoExtension->ControllerAddress.DRDC) );

        if (IsNEC_98) {
            FdcDump( FDCINFO, ("FdcStartDevice: ControllerAddress.ModeChange   = %08x\n"
                               "FdcStartDevice: ControllerAddress.ModeChangeEx = %08x\n",
                               fdoExtension->ControllerAddress.ModeChange,
                               fdoExtension->ControllerAddress.ModeChangeEx) );
        }

        if ( !foundDma ||
             !foundInterrupt ||
             fdoExtension->ControllerAddress.DriveControl == NULL ||
//             fdoExtension->ControllerAddress.Tape == NULL ||
             fdoExtension->ControllerAddress.Status == NULL ||
             fdoExtension->ControllerAddress.Fifo == NULL ||
             ((!IsNEC_98) ? (fdoExtension->ControllerAddress.DRDC.DataRate == NULL)
                         : ((fdoExtension->ControllerAddress.ModeChange == NULL) ||
                            (fdoExtension->ControllerAddress.ModeChangeEx == NULL)) )
              ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( NT_SUCCESS(ntStatus) ) {
            //
            //  Set up the bus information since we know it now.
            //
            fdoExtension->BusType = fullList->InterfaceType;
            fdoExtension->BusNumber = fullList->BusNumber;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = FdcInitializeDeviceObject( DeviceObject );

        //
        //  Connect the interrupt for the reset operation.
        //
        ntStatus = IoConnectInterrupt( &fdoExtension->InterruptObject,
                                       FdcInterruptService,
                                       fdoExtension,
                                       NULL,
                                       fdoExtension->ControllerVector,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->InterruptMode,
                                       fdoExtension->SharableVector,
                                       fdoExtension->ProcessorMask,
                                       fdoExtension->SaveFloatState );

        FdcDump( FDCINFO, ("FdcStartDevice: IoConnectInterrupt - %08x\n", ntStatus) );

        fdoExtension->CurrentInterrupt = FALSE;

        if ( NT_SUCCESS(ntStatus) ) {

            //
            // Initialize (Reset) the controller hardware.  This will make
            // sure that the controller is really there and leave it in an
            // appropriate state for the rest of the system startup.
            //

            fdoExtension->AllowInterruptProcessing =
                fdoExtension->CurrentInterrupt = TRUE;

            //
            // Acquire the Fdc Enabler card if there is one
            //
            if (fdoExtension->FdcEnablerSupported) {

                LARGE_INTEGER acquireTimeOut;

                acquireTimeOut.QuadPart = -(ONE_SECOND * 15);

                ntStatus = FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
//                                       IOCTL_ACQUIRE_FDC, // For spelling miss in flpyenbl.h
                                         IOCTL_AQUIRE_FDC,
                                         &acquireTimeOut);
            }

            if ( NT_SUCCESS(ntStatus) ) {

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );

                FdcDump( FDCINFO, ("FdcStartDevice: FcInitializeControllerHardware - %08x\n", ntStatus) );

                //
                // Free the tape accelerator card if it was used.
                //
                if (fdoExtension->FdcEnablerSupported) {
                    FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
                                  IOCTL_RELEASE_FDC,
                                  NULL);
                }

                fdoExtension->CurrentInterrupt = FALSE;
            }

            if ( NT_SUCCESS( ntStatus ) ) {

                fdoExtension->HardwareFailed = FALSE;
                ntStatus = FcGetFdcInformation ( fdoExtension );

            } else {

                fdoExtension->HardwareFailed = TRUE;
            }

            if (IsNEC_98) {
                //
                // NEC98's FDD driver can't not disconnect interrupt,
                // and can't not page out this driver. Because when a FD is inserted in FDD or
                // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
                //

            } else { // (IsNEC_98)

                IoDisconnectInterrupt(fdoExtension->InterruptObject);

            } // (IsNEC_98)
        }

        if( NT_SUCCESS( ntStatus ) ) {

            //
            //  We will only attempt to allocate memory for and enumerate tape
            //  drives if we are not in setup mode and we have the tape mode
            //  register (0x3f3).
            //
            if ( !FdcInSetupMode &&
                 fdoExtension->ControllerAddress.Tape != NULL ) {

                ntStatus = FcAllocateCommonBuffers( fdoExtension );
            }
        }
    }

    Irp->IoStatus.Information = 0;

    return ntStatus;
}
NTSTATUS
FdcInitializeDeviceObject(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine initializes the DeviceObject resources.  DeviceObject resources
    only need to be initialized once, regardless of how many times this device
    is started.

Arguments:

    DeviceObject - a pointer to the device object being started.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    UNICODE_STRING unicodeEvent;
    USHORT      motorControlData;

    fdoExtension = DeviceObject->DeviceExtension;

    if ( !fdoExtension->DeviceObjectInitialized ) {

        //
        // Set the time to wait for an interrupt before timing out to a
        // few seconds.
        //
        fdoExtension->InterruptDelay.QuadPart = -(ONE_SECOND * 4);

        //
        // Set the minimum time that we can delay (10ms according to system
        // rules).  This will be used when we have to delay to, say, wait
        // for the FIFO - the FIFO should become ready is well under 10ms.
        //
        fdoExtension->Minimum10msDelay.QuadPart = -(10 * 1000 * 10);

        if (IsNEC_98) {
            //
            // Set initialize data to move state
            //
            fdoExtension->ResultStatus0[0] = 0xc0;
            fdoExtension->ResultStatus0[1] = 0xc1;
            fdoExtension->ResultStatus0[2] = 0xc2;
            fdoExtension->ResultStatus0[3] = 0xc3;

            //
            // Reset high
            //

            READ_CONTROLLER(fdoExtension->ControllerAddress.DriveControl);

            //
            // Initialize motor running status.
            //   0 - stop
            //   1 - just run
            //   2 - be running
            //

            fdoExtension->MotorRunning = 0;

            //
            // Get BIOS common area date.
            //

            {
                ULONG                       nodeNumber;
                CHAR                        AnsiBuffer[512];
                ANSI_STRING                 AnsiString;
                UNICODE_STRING              registryPath;
                ULONG                       Configuration;

                RTL_QUERY_REGISTRY_TABLE    paramTable[2];
                PUCHAR                      ConfigurationData1;

                ConfigurationData1 = ExAllocatePool(NonPagedPoolCacheAligned, 1192);

                if (ConfigurationData1 == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlZeroMemory(ConfigurationData1, 1192);

                paramTable[0].QueryRoutine      = NULL;
                paramTable[0].Flags             = RTL_QUERY_REGISTRY_DIRECT;
                paramTable[0].Name              = L"Configuration Data";
                paramTable[0].EntryContext      = ConfigurationData1;
                paramTable[0].DefaultType       = REG_DWORD;
                paramTable[0].DefaultData       = (PVOID)&Configuration;
                paramTable[0].DefaultLength     = 0;

                paramTable[1].QueryRoutine      = NULL;
                paramTable[1].Flags             = 0;
                paramTable[1].Name              = NULL;
                paramTable[1].EntryContext      = NULL;
                paramTable[1].DefaultType       = REG_NONE;
                paramTable[1].DefaultData       = NULL;
                paramTable[1].DefaultLength     = 0;

                ((PULONG)ConfigurationData1)[0] = 1192;

                nodeNumber = FdcFindIsaBusNode();

                if ( nodeNumber != -1 ) {

                    //
                    // Build path buffer...
                    //

                    sprintf(AnsiBuffer,ISA_BUS_NODE,nodeNumber);
                    RtlInitAnsiString(&AnsiString,AnsiBuffer);
                    ntStatus = RtlAnsiStringToUnicodeString(&registryPath,&AnsiString,TRUE);

                    if (!(NT_SUCCESS(ntStatus))) {
                        ExFreePool(ConfigurationData1);
                        return ntStatus;
                    }

                    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                                      registryPath.Buffer,
                                                      paramTable,
                                                      NULL,
                                                      NULL);

                    RtlFreeUnicodeString(&registryPath);

                }

                if (!(NT_SUCCESS(ntStatus))) {

                    ExFreePool(ConfigurationData1);
                    return ntStatus;
                }

                //
                // Set disk dirve existing bit.
                //

                fdoExtension->FloppyEquip = (UCHAR)(FdcGet0Seg(ConfigurationData1, 0x55c) & 0x0F);

                //
                // Reset high
                //

                READ_CONTROLLER(fdoExtension->ControllerAddress.DriveControl);

                motorControlData  = READ_CONTROLLER(fdoExtension->ControllerAddress.ModeChange);
                motorControlData &= 0x03;
                motorControlData |= 0x04;

                //
                // Motor control.
                //

                WRITE_CONTROLLER(fdoExtension->ControllerAddress.ModeChange, motorControlData);

                ExFreePool(ConfigurationData1);
            }
        } // (IsNEC_98)

        //
        // Initialize the DPC structure in the device object, so that
        // the ISR can queue DPCs.
        //
        IoInitializeDpcRequest( fdoExtension->Self, FdcDeferredProcedure );

        //
        // Occasionally during stress we've seen the device lock up.
        // We create a dpc so that we can log that the device lock up
        // occured and that we reset the device.
        //
        KeInitializeDpc( &fdoExtension->LogErrorDpc,
                         FcLogErrorDpc,
                         fdoExtension );

        //
        // Assume there is a CONFIGURE command until found otherwise.
        // Other Booleans were zero-initialized to FALSE.
        //
        fdoExtension->ControllerConfigurable = NotConfigurable ? FALSE : TRUE;
        fdoExtension->Model30 = Model30 ? TRUE : FALSE;

        fdoExtension->AllowInterruptProcessing = TRUE;
        fdoExtension->CurrentInterrupt         = TRUE;
        fdoExtension->ControllerInUse          = FALSE;
        fdoExtension->CurrentIrp               = NULL;

        //
        // Start the timer
        //
        fdoExtension->InterruptTimer = CANCEL_TIMER;

        IoInitializeTimer( DeviceObject, FdcCheckTimer, fdoExtension );

        //
        // Initialize events to signal interrupts and adapter object
        // allocation
        //
        KeInitializeEvent( &fdoExtension->InterruptEvent,
                           SynchronizationEvent,
                           FALSE);

        KeInitializeEvent( &fdoExtension->AllocateAdapterChannelEvent,
                           NotificationEvent,
                           FALSE );

        fdoExtension->AdapterChannelRefCount = 0;

        RtlInitUnicodeString( &unicodeEvent, L"\\Device\\FloppyControllerEvent0" );

        fdoExtension->AcquireEvent = IoCreateSynchronizationEvent( &unicodeEvent,
                                                                   &fdoExtension->AcquireEventHandle);

        KeInitializeEvent( &fdoExtension->SynchEvent,
                           SynchronizationEvent,
                           FALSE);

    }

    fdoExtension->DeviceObjectInitialized = TRUE;

    return ntStatus;
}


NTSTATUS
FdcFdoConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This routine is used to acquire all of the configuration
    information for a tape enabler if we ever find one.

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       m