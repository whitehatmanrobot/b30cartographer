zEmpty);

    dwErr = RegQueryValueEx(hKeyOE, szOEDllPathKey, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if (REG_EXPAND_SZ == dwType) 
    {
        ExpandEnvironmentStrings(szBuf, szPathExpand, CharSizeOf(szPathExpand));
        lstrcpy(szBuf, szPathExpand);
    }


    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(lstrlen(szBuf))
        lstrcpy(szDllPath, szBuf);

out:
    if(hKeyOE)
        RegCloseKey(hKeyOE);
    if(hKeyMail)
        RegCloseKey(hKeyMail);
    return bRet;
}

//$$//////////////////////////////////////////////////////////////////////
//
//  HrSendMail - does the actual mail sending
//          Our first priority is to Outlook Express which currently has a
//          different code path than the regular MAPI client .. so we look
//          under HKLM\Software\Clients\Mail .. if the client is OE then
//          we just loadlibrary and getprocaddress for sendmail
//          If its not OE, then we call the mapi32.dll and load it ..
//          If both fail we will not be able to send mail ...
//
//          This function will free the lpList no matter what happens
//          so caller should not expect to reuse it (This is so we can
//          give the pointer to a seperate thread and not worry about it)
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMail(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, BOOL bUseOEForSendMail)
{
	HRESULT hr = E_FAIL;
    HINSTANCE hLibMapi = NULL;
    BOOL bIsOE = FALSE; // right now there is a different code path
                        // for OE vs other MAPI clients

    TCHAR szBuf[MAX_PATH];
    LPMAPISENDMAIL lpfnMAPISendMail = NULL;
    LHANDLE hMapiSession = 0;
    LPMAPILOGON lpfnMAPILogon = NULL;
    LPMAPILOGOFF lpfnMAPILogoff = NULL;

    LPBYTE      lpbName, lpbAddrType, lpbEmail;
    ULONG       ulMapiDataType;
    ULONG       cbEntryID = 0;
    LPENTRYID   lpEntryID = NULL;

    MapiMessage Msg = {0};
    MapiRecipDesc * lprecips = NULL;

    if(!nRecipCount)
    {
        hr = MAPI_W_ERRORS_RETURNED;
        goto out;
    }

    // Check if OutlookExpress is the default current client ..
    bIsOE = CheckForOutlookExpress(szBuf);

    // Turn off all notifications for simple MAPI send mail, if the default
    // email client is Outlook.  This is necessary because Outlook changes the 
    // WAB MAPI allocation functions during simple MAPI and we don't want any
    // internal WAB functions using these allocators.
#ifdef LATER
    if (!bIsOE && !bUseOEForSendMail)
        vTurnOffAllNotifications();

    // if OE is the default client or OE launched this WAB, use OE for SendMail
    if(lstrlen(szBuf) && (bIsOE||bUseOEForSendMail))
    {
        hLibMapi = LoadLibrary(szBuf);
    }
    else
#endif
    {
        // Check if simple mapi is installed
        if(GetProfileInt( TEXT("mail"), TEXT("mapi"), 0) == 1)
            hLibMapi = LoadLibrary( TEXT("mapi32.dll"));
        
        if(!hLibMapi) // try loading the OE MAPI dll directly
        {
            // Load the path to the msimnui.dll
            CheckForOutlookExpress(szBuf);
            if(lstrlen(szBuf))  // Load the dll directly - dont bother going through msoemapi.dll
                hLibMapi = LoadLibrary(szBuf);
        }
    }

    if(!hLibMapi)
    {
        _ASSERT(FALSE); // DebugPrintError(( TEXT("Could not load/find simple mapi\n")));
        hr = MAPI_E_NOT_FOUND;
        goto out;
    }
    else if(hLibMapi)
    {
        lpfnMAPILogon = (LPMAPILOGON) GetProcAddress (hLibMapi, "MAPILogon");
        lpfnMAPILogoff= (LPMAPILOGOFF)GetProcAddress (hLibMapi, "MAPILogoff");
        lpfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress (hLibMapi, "MAPISendMail");

        if(!lpfnMAPISendMail || !lpfnMAPILogon || !lpfnMAPILogoff)
        {
            _ASSERT(FALSE); // DebugPrintError(( TEXT("MAPI proc not found\n")));
            hr = MAPI_E_NOT_FOUND;
            goto out;
        }
        hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                            NULL,              // No password needed.
                            0L,                // Use shared session.
                            0L,                // Reserved; must be 0.
                            &hMapiSession);       // Session handle.

        if(hr != SUCCESS_SUCCESS)
        {
            // DebugTrace( TEXT("MAPILogon failed\n"));
            // its possible the logon failed since there was no shared logon session
            // Try again to create a new session with UI
            hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                                NULL,                               // No password needed.
                                MAPI_LOGON_UI | MAPI_NEW_SESSION,   // Use shared session.
                                0L,                // Reserved; must be 0.
                                &hMapiSession);    // Session handle.

            if(hr != SUCCESS_SUCCESS)
            {
                // DebugTrace( TEXT("MAPILogon failed\n"));
                goto out;
            }
        }
    }

    // Load the MAPI functions here ...
    //

    lprecips = (MapiRecipDesc *) LocalAlloc(LMEM_ZEROINIT, sizeof(MapiRecipDesc) * nRecipCount);
    {
        LPRECIPLIST lpTemp = lpList;
        ULONG count = 0;

        while(lpTemp)
        {
            lprecips[count].ulRecipClass = MAPI_TO;
            lprecips[count].lpszName = lpTemp->lpszName;
            lprecips[count].lpszAddress = lpTemp->lpszEmail;

#ifdef LATER
            // [PaulHi] 4/20/99  Raid 73455
            // Convert Unicode EID OneOff strings to ANSI
            if ( IsWABEntryID(lpTemp->lpSB->cb, (LPVOID)lpTemp->lpSB->lpb, 
                              &lpbName, &lpbAddrType, &lpbEmail, (LPVOID *)&ulMapiDataType, NULL) == WAB_ONEOFF )
            {
                if (ulMapiDataType & MAPI_UNICODE)
                {
                    hr = CreateWABEntryIDEx(
                        FALSE,              // Don't want Unicode EID strings
                        WAB_ONEOFF,         // EID type
                        (LPWSTR)lpbName,
                        (LPWSTR)lpbAddrType,
                        (LPWSTR)lpbEmail,
                        0,
                        0,
                        NULL,
                        &cbEntryID,
                        &lpEntryID);

                    if (FAILED(hr))
                        goto out;

                    lprecips[count].ulEIDSize = cbEntryID;
                    lprecips[count].lpEntryID = lpEntryID;
                }
                else
                {
                    lprecips[count].ulEIDSize = lpTemp->lpSB->cb;
                    lprecips[count].lpEntryID = (LPVOID)lpTemp->lpSB->lpb;
                }
            }
#endif // LATER
            lpTemp = lpTemp->lpNext;
            count++;
        }
    }

    Msg.nRecipCount = nRecipCount;
    Msg.lpRecips = lprecips;

    hr = lpfnMAPISendMail (hMapiSession, (ULONG_PTR)hWndParent,
                            &Msg,       // the message being sent
                            MAPI_DIALOG, // allow the user to edit the message
                            0L);         // reserved; must be 0
    if(hr != SUCCESS_SUCCESS)
        goto out;

    hr = S_OK;

out:

    if (lpEntryID)
        LocalFreeAndNull((void **)&lpEntryID);

    // The simple MAPI session should end after this
    if(hMapiSession && lpfnMAPILogoff)
        lpfnMAPILogoff(hMapiSession,0L,0L,0L);

    if(hLibMapi)
        FreeLibrary(hLibMapi);

#ifdef LATER
    // Turn all notifications back on and refresh the WAB UI (just in case)
    if (!bIsOE && !bUseOEForSendMail)
    {
        vTurnOnAllNotifications();
        if (lpIAB->hWndBrowse)
         PostMessage(lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_VIEW_REFRESH, 0);
    }

    if(lprecips)
    {
        ULONG i = 0;
        for(i=0;i < nRecipCount;i++)
        {
            LocalFreeAndNull((void **)&lprecips[i].lpszName);
            LocalFreeAndNull((void **)&lprecips[i].lpszAddress);
        }

        LocalFree(lprecips);
    }
#endif
    
    // The one-off here was allocated before the simple MAPI session and so used
    // the default WAB allocators.
    if(lpList)
        FreeLPRecipList(lpList);

    switch(hr)
    {
    case S_OK:
    case MAPI_E_USER_CANCEL:
    case MAPI_E_USER_ABORT:
        break;
    case MAPI_W_ERRORS_RETURNED:
        _ASSERT(FALSE); // ShowMessageBox(hWndParent, idsSendMailToNoEmail, MB_ICONEXCLAMATION | MB_OK);
        break;
    case MAPI_E_NOT_FOUND:
        _ASSERT(FALSE); // ShowMessageBox(hWndParent, idsSendMailNoMapi, MB_ICONEXCLAMATION | MB_OK); 
        break;
    default:
        _ASSERT(FALSE); // ShowMessageBox(hWndParent, idsSendMailError, MB_ICONEXCLAMATION | MB_OK);
        break;
    }

    return hr;
}

//$$//////////////////////////////////////////////////////////////////////
//
// MailThreadProc - does the actual sendmail and cleans up
//
//////////////////////////////////////////////////////////////////////////
DWORD WINAPI MailThreadProc( LPVOID lpParam )
{
    LPMAIL_PARAMS lpMP = (LPMAIL_PARAMS) lpParam;
#ifdef LATER
    LPPTGDATA lpPTGData = GetThreadStoragePointer(); // Bug - if this new thread accesses the WAB we lose a hunka memory
                                                // So add this thing here ourselves and free it when this thread's work is done
#endif

    if(!lpMP)
        return 0;

    // DebugTrace( TEXT("Mail Thread ID = 0x%.8x\n"),GetCurrentThreadId());

    HrSendMail(lpMP->hWnd, lpMP->nRecipCount, lpMP->lpList, lpMP->bUseOEForSendMail);

    LocalFree(lpMP);

    return 0;
}

//$$//////////////////////////////////////////////////////////////////////
//
// HrStartMailThread
//
//  Starts a seperate thread to send mapi based mail from
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrStartMailThread(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, BOOL bUseOEForSendMail)
{
    LPMAIL_PARAMS lpMP = NULL;
    HRESULT hr = E_FAIL;

    lpMP = (LPMAIL_PARAMS) LocalAlloc(LMEM_ZEROINIT, sizeof(MAIL_PARAMS));

    if(!lpMP)
        goto out;

    {
        HANDLE hThread = NULL;
        DWORD dwThreadID = 0;

        lpMP->hWnd = hWndParent;
        lpMP->nRecipCount = nRecipCount;
        lpMP->lpList = lpList;
        lpMP->bUseOEForSendMail = bUseOEForSendMail;

        hThread = CreateThread(
                                NULL,           // no security attributes
                                0,              // use default stack size
                                MailThreadProc,     // thread function
                                (LPVOID) lpMP,  // argument to thread function
                                0,              // use default creation flags
                                &dwThreadID);   // returns the thread identifier

        if(hThread == NULL)
            goto out;

        hr = S_OK;

        CloseHandle(hThread);
    }

out:
    if(HR_FAILED(hr))
    {
        _ASSERT(FALSE);
#ifdef LATER
        ShowMessageBox(hWndParent, idsSendMailError, MB_OK | MB_ICONEXCLAMATION);
#endif

        // we can assume that HrSendMail never got called so we should free lpList & lpMP
        if(lpMP)
            LocalFree(lpMP);

        if(lpList)
            FreeLPRecipList(lpList);

    }

    return hr;
}

//$$/////////////////////////////////////////////////////////////////////
//
// FreeLPRecipList
//
// Frees a linked list containing the above structures
//
/////////////////////////////////////////////////////////////////////////
void FreeLPRecipList(LPRECIPLIST lpList)
{
    if(lpList)
    {
        LPRECIPLIST lpTemp = lpList;
        while(lpTemp)
        {
            lpList = lpTemp->lpNext;
            if(lpTemp->lpszName)
                LocalFree(lpTemp->lpszName);
            if(lpTemp->lpszEmail)
                LocalFree(lpTemp->lpszEmail);
            if(lpTemp->lpSB)
                LocalFree(lpTemp->lpSB);

            LocalFree(lpTemp);
            lpTemp = lpList;
        }
    }
}

//$$/////////////////////////////////////////////////////////////////////
//
// FreeLPRecipList
//
// Frees a linked list containing the above structures
//
/////////////////////////////////////////////////////////////////////////
LPRECIPLIST AddTeimToRecipList(LPRECIPLIST lpList, WCHAR *pwszEmail, WCHAR *pwszName, LPSBinary lpSB)
{
    LPRECIPLIST lpTemp = NULL;

    lpTemp = (RECIPLIST*) LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPLIST));

    if(!lpTemp)
        return NULL;

    if(pwszEmail)
    {
        LPTSTR pszEmail = LPTSTRfromBstr(pwszEmail);

        if(pszEmail)
        {
            lpTemp->lpszEmail = (TCHAR *) LocalAlloc(LMEM_ZEROINIT, lstrlen(pszEmail)+1);
            if(lpTemp->lpszEmail)
                lstrcpy(lpTemp->lpszEmail, pszEmail);

            MemFree(pszEmail);
        }
    }

    if(pwszName)
    {

        LPTSTR pszName = LPTSTRfromBstr(pwszName);

        if(pszName)
        {
            lpTemp->lpszName = (TCHAR *) LocalAlloc(LMEM_ZEROINIT, lstrlen(pszName)+1);
            if(lpTemp->lpszName)
                lstrcpy(lpTemp->lpszName, pszName);

            MemFree(pszName);
        }
    }

    if(lpSB)
    {
        lpTemp->lpSB = (SBinary *) LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
        if(lpTemp->lpSB )
            *(lpTemp->lpSB) = *lpSB;
    }

    if(lpList)
        lpList->lpNext = lpTemp;

    return lpTemp;
}

const static TCHAR lpszWABDLLRegPathKey[] = TEXT("Software\\Microsoft\\WAB\\DLLPath");
const static TCHAR lpszWABEXERegPathKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe");
const static TCHAR lpszWABEXE[] = TEXT("wab.exe");

// =============================================================================
// HrLoadPathWABEXE - creaetd vikramm 5/14/97 - loads the registered path of the
// latest wab.exe
// szPath - pointer to a buffer
// cbPath - sizeof buffer
// =============================================================================
// ~~~~ @TODO dhaws Might need to convert this
HRESULT HrLoadPathWABEXE(LPWSTR szPath, ULONG cbPath)
{
    DWORD  dwType;
    ULONG  cbData = MAX_PATH;
    HKEY hKey;
    TCHAR szTmpPath[MAX_PATH];

    _ASSERT(szPath != NULL);
    _ASSERT(cbPath > 0);

    *szPath = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABEXERegPathKey, 0, KEY_READ, &hKey))
        {
        SHQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szTmpPath, &cbData);
        RegCloseKey(hKey);
        }

    if(!lstrlen(szTmpPath))
    {
        if(!MultiByteToWideChar(GetACP(), 0, lpszWABEXE, -1, szPath, cbPath))
            return(E_FAIL);
    }
    else
    {
        if(!MultiByteToWideChar(GetACP(), 0, szTmpPath, -1, szPath, cbPath))
            return(E_FAIL);

    }
    return S_OK;
}

DWORD DwGetMessStatus(void)
{
    HKEY hKey;
    DWORD  dwType = 0;
    DWORD dwVal = 0;
    ULONG  cbData = sizeof(dwType);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDisableMessnegerArea, 0, KEY_READ, &hKey))
    {
        RegQueryValueEx(hKey, szUseIM, NULL, &dwType, (LPBYTE) &dwVal, &cbData);

        RegCloseKey(hKey);
    }

    return dwVal;
}

DWORD DwGetDisableMessenger(void)
{
    HKEY hKey;
    DWORD  dwType = 0;
    DWORD dwVal = 0;
    ULONG  cbData = sizeof(dwType);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, KEY_READ, &hKey))
    {
        RegQueryValueEx(hKey, szDisableIM, NULL, &dwType, (LPBYTE) &dwVal, &cbData);

        RegCloseKey(hKey);
    }

    return dwVal;
}

DWORD DwSetDisableMessenger(DWORD dwVal)
{
    HKEY hKey;
    ULONG  cbData = sizeof(DWORD);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, NULL, 0, 
                KEY_ALL_ACCESS, NULL, &hKey, NULL))
    {
        RegSetValueEx(hKey, szDisableIM, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        RegCloseKey(hKey);
    }
    return dwVal;
}

DWORD DwGetOptions(void)
{
    HKEY hKey;
    DWORD  dwType = 0;
    DWORD dwVal = 0;
    ULONG  cbData = sizeof(dwType);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, KEY_READ, &hKey))
    {
        RegQueryValueEx(hKey, szContactOptions, NULL, &dwType, (LPBYTE) &dwVal, &cbData);

        RegCloseKey(hKey);
    }

    return dwVal;
}

DWORD DwSetOptions(DWORD dwVal)
{
    HKEY hKey;
    ULONG  cbData = sizeof(DWORD);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szIEContactsArea, 0, NULL, 0, 
                KEY_ALL_ACCESS, NULL, &hKey, NULL))
    {
        RegSetValueEx(hKey, szContactOptions, NULL, REG_DWORD, (LPBYTE) &dwVal, cbData);
        RegCloseKey(hKey);
    }
    return dwVal;
}

BOOL IsTelInstalled(void)
{
    HKEY hKey;
    BOOL fRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, szPhoenixArea, 0, KEY_READ, &hKey))
    {
        RegCloseKey(hKey);
        fRet = TRUE;
    }
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\abimport.h ===
#ifndef _INC_ABIMPORT_H
#define _INC_ABIMPORT_H

HRESULT HrImportAB(HWND hWndParent, LPTSTR lpszfnImport);

#endif // _INC_ABIMPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\abimport.cpp ===
/*
*
* ABImport.c - Code for calling WABIMP.dll to import
*           Netscape and Eudora files into WAB
*
* Assumes this will be compiled with wab32.lib, else need to
* loadlibrary("wab32.dll") and call GetProcAddress("WABOpen");
*
* Exported functions:
*   HrImportNetscapeAB() - Imports Netscape AB into WAB
*   HrImportEudoraAB() - Imports Eudora AB into WAB
*
* Rough cut - vikramm 4/3/97
*
*/

#include "pch.hxx"
#include <wab.h>
#include <wabmig.h>
#include "abimport.h"
#include <impapi.h>
#include <newimp.h>
#include "import.h"
#include "strconst.h"

HRESULT HrImportAB(HWND hWndParent, LPTSTR lpszfnImport);

static CImpProgress *g_pProgress = NULL;
static TCHAR g_szABFmt[CCHMAX_STRINGRES];

/*
*
* ProgressCallback
*
* This is the call back function that updates the progress bar
*
* In the function below, IDC_Progress is the ID of the progress
* bar that will be updated and IDC_MEssage is the ID of the
* static that will display text returned from the WABImp.Dll
* Replace these 2 ids with your own ids...
*
*/
HRESULT ProgressCallback(HWND hwnd, LPWAB_PROGRESS lpProgress)
    {
    TCHAR sz[CCHMAX_STRINGRES];

    Assert(g_pProgress != NULL);

    if (lpProgress->denominator)
        {
        if (lpProgress->numerator == 0)
            {
            g_pProgress->Reset();
            g_pProgress->AdjustMax(lpProgress->denominator);
            }

        wsprintf(sz, g_szABFmt, lpProgress->numerator + 1, lpProgress->denominator);
        g_pProgress->SetMsg(sz, IDC_MESSAGE_STATIC);

        g_pProgress->HrUpdate(1);
        }

    return(S_OK);
    }


// ===========================================================================
// HrLoadLibraryWabDLL -
// ===========================================================================
HINSTANCE LoadLibraryWabDLL (VOID)
{
    TCHAR  szDll[MAX_PATH];
    TCHAR  szExpand[MAX_PATH];
    LPTSTR psz;
    DWORD  dwType = 0;
    HKEY hKey;
    ULONG  cbData = sizeof(szDll);
    
    *szDll = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszWABDLLRegPathKey, 0, KEY_READ, &hKey))
        {
        if (ERROR_SUCCESS == RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szDll, &cbData))
            if (REG_EXPAND_SZ == dwType)
                {
                ExpandEnvironmentStrings(szDll, szExpand, ARRAYSIZE(szExpand));
                psz = szExpand;
                }
            else
                psz = szDll;

        RegCloseKey(hKey);
        }

    if(!lstrlen(psz))
        lstrcpy(psz, WAB_DLL_NAME);

    return(LoadLibrary(psz));
}


/*
*
*
* HrImportAB
*
* Calls the relevant DLL proc and imports corresponding AB
*
*/
HRESULT HrImportAB(HWND hWndParent, LPTSTR lpszfnImport)
{
    TCHAR sz[CCHMAX_STRINGRES];
    HINSTANCE hinstWabDll;
    LPWABOPEN lpfnWABOpen;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBookWAB = NULL;

    HRESULT hResult;
    BOOL fFinished = FALSE;
    LPWAB_IMPORT lpfnWABImport = NULL;
    HINSTANCE hinstImportDll = NULL;
    WAB_IMPORT_OPTIONS ImportOptions;

    ZeroMemory(&ImportOptions, sizeof(WAB_IMPORT_OPTIONS));

    hinstWabDll = LoadLibraryWabDLL();

    if (hinstWabDll == NULL)
        return(MAPI_E_NOT_INITIALIZED);

    lpfnWABOpen = (LPWABOPEN)GetProcAddress(hinstWabDll, szWabOpen);
    if (lpfnWABOpen == NULL)
        {
        hResult = MAPI_E_NOT_INITIALIZED;
        goto out;
        }

    hinstImportDll = LoadLibrary(szImportDll);

    if(!hinstImportDll)
    {
        hResult = MAPI_E_NOT_INITIALIZED;
        goto out;
    }

    if (! (lpfnWABImport = (LPWAB_IMPORT) GetProcAddress(hinstImportDll,lpszfnImport)))
    {
        hResult = MAPI_E_NOT_INITIALIZED;
        goto out;
    }

    // Flags that can be passed to the WABImp DLL
    //
    ImportOptions.fNoErrors = FALSE; // Display Pop up errors
    ImportOptions.ReplaceOption = WAB_REPLACE_PROMPT; //Prompt user before replacing contacts


    if(hResult = lpfnWABOpen(&lpAdrBookWAB, &lpWABObject, NULL, 0))
        goto out;

    g_pProgress = new CImpProgress;
    if (g_pProgress == NULL)
        {
        hResult = E_OUTOFMEMORY;
        goto out;
        }

    g_pProgress->Init(hWndParent, FALSE);

    LoadString(g_hInstImp, idsImportingABFmt, g_szABFmt, ARRAYSIZE(g_szABFmt));

    LoadString(g_hInstImp, idsImportABTitle, sz, ARRAYSIZE(sz));
    g_pProgress->SetTitle(sz);

    LoadString(g_hInstImp, idsImportAB, sz, ARRAYSIZE(sz));
    g_pProgress->SetMsg(sz, IDC_FOLDER_STATIC);

    g_pProgress->Show(0);

    hResult = lpfnWABImport(hWndParent,
                              lpAdrBookWAB,
                              lpWABObject,
                              (LPWAB_PROGRESS_CALLBACK)&ProgressCallback,
                              &ImportOptions);
    if (hResult == MAPI_E_USER_CANCEL)
    {
        hResult = hrUserCancel;
    }
    else if (FAILED(hResult))
    {
        ImpMessageBox( hWndParent,
                    MAKEINTRESOURCE(idsImportTitle),
                    MAKEINTRESOURCE(idsABImportError),
                    NULL,
                    MB_OK | MB_ICONEXCLAMATION );
    }

out:
    if (g_pProgress != NULL)
        {
        g_pProgress->Release();
        g_pProgress = NULL;
        }

    if (lpAdrBookWAB)
        lpAdrBookWAB->Release();

    if (lpWABObject)
        lpWABObject->Release();

    if(hinstImportDll)
        FreeLibrary(hinstImportDll);

    FreeLibrary(hinstImportDll);

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDBCS_DIVIDE
WIN32_IE_VERSION=0x0500

INCLUDES=\
     $(R); \
     $(R)\pch; \
     $(ATHROOT)\mailnews\inc; \
     $(ATHROOT)\mailnews\inc\$(O); \
     $(ATHROOT)\msoeres; \
     $(ATHROOT)\mailnews\common; \
     $(ATHROOT)\mailnews\extinc; \
     $(BASEDIR)\private\windows\inc; \
     $(ATHROOT)\directdb\inc; \
     $(ATHROOT)\directdb\inc\$(O); \
     $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

#PRECOMPILED_INCLUDE=$(R)\pch.hxx
PRECOMPILED_CXX=1

PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\pch\$(_OBJ_DIR)\*\pch.pch
PRECOMPILED_TARGET=$(R)\pch\$(_OBJ_DIR)\*\pch.pch

#PRECOMPILED_OPTION=/Yupch.hxx /Fppch.pch
#PRECOMPILED_TARGET=pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\comconv.h ===
#ifndef _INC_COMCONV_H
#define _INC_COMCONV_H

enum
    {
    NETSCAPE = 1,
    EUDORA,
	COMMUNICATOR
    };

BOOL ValidStoreDirectory(char *szPath, int program);
HRESULT GetClientDir(char *szDir, int cch, int program);
HRESULT DispDialog(HWND hwnd, char *pathname, int cch);
BOOL GetStorePath(char *szProfile, char *szStorePath);

#endif // _INC_COMCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\comconv.cpp ===
#include "pch.hxx"
#include <iert.h>
#include <mapi.h>
#include <mapix.h>
#include <impapi.h>
#include <newimp.h>
#include "import.h"
#include "comconv.h"
#include "strconst.h"
#include "demand.h"

extern HRESULT GetCommunicatorDirectory(char *szUser, char *szDir, int cch);

int BrowseCallbackProc(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData);
BOOL GetVersion(TCHAR *szFile, DWORD *pdwHigh, DWORD *pdwLow);

HRESULT DispDialog(HWND hwnd, TCHAR *pathname, int cch)
    {
    BROWSEINFO browse;
    BOOL fRet;
    TCHAR szBuffer[CCHMAX_STRINGRES], szPath[MAX_PATH];
    LPITEMIDLIST lpitemid;

    Assert(cch >= MAX_PATH);

    LoadString(g_hInstImp, idsBrowseFolderText, szBuffer, ARRAYSIZE(szBuffer));

    browse.hwndOwner = hwnd;      
    browse.pidlRoot = NULL; 
    browse.pszDisplayName = szPath;
    browse.lpszTitle = szBuffer;        
    browse.ulFlags = BIF_RETURNONLYFSDIRS | BIF_DONTGOBELOWDOMAIN;           
    browse.lpfn = BrowseCallbackProc;
    browse.lParam = (*pathname != 0) ? (LPARAM)pathname : NULL;

	if ((lpitemid = SHBrowseForFolder(&browse)) == NULL)
		return(S_FALSE);
	
    Assert(lpitemid != NULL);

    fRet = SHGetPathFromIDList(lpitemid, szPath);
    SHFree(lpitemid);
    if (!fRet)
		return(E_FAIL);
	
    lstrcpy(pathname, szPath);

	return(S_OK);
    }

int BrowseCallbackProc(HWND hwnd, UINT msg, LPARAM lParam, LPARAM lpData)
    {
    if (msg == BFFM_INITIALIZED && lpData != NULL)
        SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);

    return(0);
    }


HRESULT GetClientDir(char *szDir, int cch, int program)
{
	HKEY hkResult;
    DWORD cb, dwMs, dwLs, dwType;
    HRESULT hr;
    char sz[MAX_PATH * 2], szExpanded[MAX_PATH*2], *szT, *pszTok;

    Assert(cch >= MAX_PATH);
    Assert(program == EUDORA || program == NETSCAPE || program == COMMUNICATOR);

    hr = E_FAIL;
    pszTok = sz;

	switch(program)
	{
		case EUDORA:
			{
				if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szEudoraCommand, 0, KEY_QUERY_VALUE, &hkResult))
				{
					cb = sizeof(sz);
                    if (ERROR_SUCCESS == RegQueryValueEx(hkResult, c_szCurrent, NULL, &dwType, (LPBYTE)sz, &cb))
					{
						if (REG_EXPAND_SZ == dwType)
                        {
                            ExpandEnvironmentStrings(sz, szExpanded, ARRAYSIZE(szExpanded));
                            pszTok = szExpanded;
                        }
                        
                        // TODO: check if user is running version 4 or higher...
						szT = StrTokEx(&pszTok, c_szSpace);
						if (szT != NULL && GetVersion(szT, &dwMs, &dwLs) && dwMs <= 0x00040000)
						{
                            szT = StrTokEx(&pszTok, c_szSpace);
							if (szT != NULL)
							{
						
                                lstrcpy(szDir, szT);
								hr = S_OK;
							}
						}
					}
					RegCloseKey(hkResult);
				}
				break;
			}

		case NETSCAPE:
			{
				if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szNetscapeKey, 0, KEY_QUERY_VALUE, &hkResult))
				{
					cb = cch;
                    if (ERROR_SUCCESS == RegQueryValueEx(hkResult, c_szMailDirectory, NULL, &dwType, (LPBYTE)szDir, &cb))
					{
						if (REG_EXPAND_SZ == dwType)
                        {
                            ExpandEnvironmentStrings(szDir, szExpanded, ARRAYSIZE(szExpanded));
                            lstrcpyn(szDir, szExpanded, cch);
                        }
                        
                        // TODO: check if user is running version 4 or higher...
						hr = S_OK;
					}
					RegCloseKey(hkResult);
				}
				if (hr != S_OK)
				{
					// try to find 16-bit nscp
					cb = GetProfileString(c_szNetscape, c_szIni, c_szEmpty, sz, ARRAYSIZE(sz));
					if (cb > 0)
					{
						cb = GetPrivateProfileString(c_szMail, c_szMailDirectory, c_szEmpty, szDir, cch, sz);
						if (cb > 0)
							hr = S_OK;
					}
				}
				break;
			}
    
		case COMMUNICATOR:
            hr = GetCommunicatorDirectory(NULL, szDir, cch);
            break;

		default:
			//We NEVER come here
			break;
	}
    return(hr);
}

BOOL ValidStoreDirectory(TCHAR *szPath, int program)
    {
    int cch;
    HANDLE hnd;
    TCHAR *szValid, sz[MAX_PATH];
    WIN32_FIND_DATA data;

    lstrcpy(sz, szPath);
    cch = lstrlen(sz);
    Assert(cch > 0);
    if (sz[cch - 1] != '\\')
        {
        sz[cch] = '\\';
        cch++;
        sz[cch] = 0;
        }
    
    szValid = (program == EUDORA ? (TCHAR *)c_szDescmapPce : (TCHAR *)c_szSnmExt);
    lstrcpy(&sz[cch], szValid);

    hnd = FindFirstFile(sz, &data);
    if (hnd != INVALID_HANDLE_VALUE)
        FindClose(hnd);

    return(hnd == INVALID_HANDLE_VALUE ? FALSE : TRUE);
    }

BOOL GetVersion(TCHAR *szFile, DWORD *pdwHigh, DWORD *pdwLow)
    {
    BOOL fRet;
    LPSTR lpInfo;
    UINT uLen;
    DWORD dwVerInfoSize, dwVerHnd;
    VS_FIXEDFILEINFO *pinfo;

    Assert(szFile != NULL);
    Assert(pdwHigh != NULL);
    Assert(pdwLow != NULL);

    fRet = FALSE;

	if (dwVerInfoSize = GetFileVersionInfoSize(szFile, &dwVerHnd))
        {
        if (MemAlloc((void **)&lpInfo, dwVerInfoSize))
            {
			if (GetFileVersionInfo(szFile, dwVerHnd, dwVerInfoSize, lpInfo))
                {
                if (VerQueryValue(lpInfo, "\\", (LPVOID *)&pinfo, &uLen) && 
                    uLen == sizeof(VS_FIXEDFILEINFO))
                    {
                    *pdwHigh = pinfo->dwProductVersionMS;
                    *pdwLow = pinfo->dwProductVersionLS;
                    fRet = TRUE;
                    }
                }

            MemFree(lpInfo);
            }
        }

    return(fRet);
    }


BOOL GetStorePath(char *szProfile, char *szStorePath)
{
	char	szTemp[MAX_PATH * 2];
	char	szDirpath[250];
	char	szLine[1000];
	char	szCompare[1000];
	int		nLine					=	0;
	int		nPosition				=	0;
	HANDLE	hJSHandle				=	NULL;
	HANDLE	hJSFile					=	NULL;
	ULONG	cbJSFile				=	0;

	BYTE	*pBegin					=	NULL, 
			*pCurr					=	NULL, 
			*pEnd					=	NULL;
			
	BOOL	bFoundEntry				=	FALSE;

	lstrcpy(szTemp, szProfile);
	lstrcat(szTemp, c_szScriptFile);

	hJSHandle = CreateFile( szTemp, GENERIC_READ, FILE_SHARE_READ, NULL, 
							OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	if(hJSHandle == INVALID_HANDLE_VALUE)
		return FALSE;

	cbJSFile = GetFileSize(hJSHandle, NULL);

	hJSFile = CreateFileMapping(hJSHandle, NULL, PAGE_READONLY, 0, 0, NULL);

	if(hJSFile == NULL)
    {
        CloseHandle(hJSHandle);        
        return FALSE;
    }

	pBegin = (BYTE *)MapViewOfFile( hJSFile, FILE_MAP_READ, 0, 0, 0);

	if(pBegin == NULL)
    {
        CloseHandle(hJSHandle);
        CloseHandle(hJSFile);
        return FALSE;
    }

	pCurr = pBegin;
	pEnd = pCurr + cbJSFile;
	
	while (pCurr < pEnd)
	{
		szLine[nLine] = *pCurr; //keep storing here. will be used for comparing later. 
		if((pCurr[0] == 0x0D) && (pCurr[1] == 0x0A))
		{
			if(nLine > lstrlen(c_szUserPref))
			{
				lstrcpyn(szCompare, szLine, lstrlen(c_szUserPref) + 1);
				if(lstrcmp(szCompare, c_szUserPref) == 0)//Found a UserPref for "mail.directory"!
				{
					//Extract the Mail Store directory.
					nPosition	=	lstrlen(c_szUserPref);
					
					while (((szLine[nPosition] == '"')||(szLine[nPosition] == ' ')||(szLine[nPosition] == ',')) &&(nPosition < nLine))
						nPosition++;
					lstrcpyn(szDirpath, &szLine[nPosition], nLine - nPosition);

					//Now trim the trailing edge!!!

					nPosition	=	lstrlen(szDirpath) - 1;
					while((szDirpath[nPosition] == '"') || (szDirpath[nPosition] == ')')||(szDirpath[nPosition] == ';')) 
					{
						szDirpath[nPosition] = '\0';
						nPosition	=	lstrlen(szDirpath) - 1;
					}
					// Now replace the double backslashes that Netscape uses 
					// in the JaveScript files, with a single backslash.

					nPosition++; // this now indicates the actual length of the string.

					int nPos = 0;
					for (int nCount = 0; nCount < nPosition; nCount++)
					{
						if ((szDirpath[nCount - 1] == '\\') && (szDirpath[nCount] == '\\'))
							nCount++;
						szStorePath[nPos] = szDirpath[nCount];
						nPos++;
					}
					bFoundEntry = TRUE;
					break;
				}
			}
			nLine = -1; //the nLine++ that follows will make nLine zero.
			pCurr++;
		}
		pCurr++;
		nLine++;
	}

    if(hJSHandle != INVALID_HANDLE_VALUE)
        CloseHandle(hJSHandle);

    if(pBegin)
        UnmapViewOfFile(pBegin);

    if(hJSFile)
        CloseHandle(hJSFile);

	if(bFoundEntry)
		return TRUE;
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInstImp;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);

#include "demand.h"

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include <newimp.h>
#include <eudrimp.h>
#include <commimp.h>
#include <mapiconv.h>
#include <netsimp.h>
#include <Impath16.h>
#include <oe4imp.h>

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
	CClassFactory(&CLSID_COE4Import,	        0,	(PFCREATEINSTANCE)COE4Import_CreateInstance),
	CClassFactory(&CLSID_CIMN1Import,	        0,	(PFCREATEINSTANCE)COE4Import_CreateInstance),
    CClassFactory(&CLSID_CAthena16Import,		0,	(PFCREATEINSTANCE)CAthena16Import_CreateInstance),
    CClassFactory(&CLSID_CEudoraImport,			0,	(PFCREATEINSTANCE)CEudoraImport_CreateInstance),
    CClassFactory(&CLSID_CExchImport,			0,	(PFCREATEINSTANCE)CExchImport_CreateInstance),
    CClassFactory(&CLSID_CNetscapeImport,		0,	(PFCREATEINSTANCE)CNetscapeImport_CreateInstance),
	CClassFactory(&CLSID_CCommunicatorImport,	0,	(PFCREATEINSTANCE)CCommunicatorImport_CreateInstance),
};

// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Get the interface requested from pObj
    CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);
    return NOERROR;
}

//#ifdef DEAD
HRESULT CAthena16Import_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CAthena16Import *pNew = new CAthena16Import;
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}
//#endif // DEAD

HRESULT CEudoraImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CEudoraImport *pNew = new CEudoraImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}

HRESULT CExchImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CExchImport *pNew = new CExchImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}

HRESULT CNetscapeImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNetscapeImport *pNew = new CNetscapeImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}

HRESULT CCommunicatorImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CCommunicatorImport *pNew = new CCommunicatorImport;    
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\dllmain.cpp ===
#include "pch.hxx"
#define DEFINE_STRING_CONSTANTS
#include <commctrl.h>
#include "dllmain.h"
#include "shared.h"
#include "strconst.h"
#include "demand.h"

#define ICC_FLAGS (ICC_LISTVIEW_CLASSES|ICC_PROGRESS_CLASS|ICC_NATIVEFNTCTL_CLASS)

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain = {0};
LONG                g_cRef = 0;
LONG                g_cLock = 0;
HINSTANCE           g_hInstImp = NULL;
LPMALLOC            g_pMalloc = NULL;

SYSTEM_INFO                     g_SystemInfo={0};
OSVERSIONINFO					g_OSInfo={0};
BOOL                g_fAttached = FALSE;

inline BOOL fIsNT5()        { return((g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_OSInfo.dwMajorVersion >= 5)); }

// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD               dwDOUTLevel=0;
DWORD               dwDOUTLMod=0;
DWORD               dwDOUTLModLevel=0;
#endif

static HINSTANCE s_hInst = NULL;

// --------------------------------------------------------------------------------
// InitGlobalVars
// --------------------------------------------------------------------------------
void InitGlobalVars(void)
{
    INITCOMMONCONTROLSEX    icex = { sizeof(icex), ICC_FLAGS };

    // Initialize Global Critical Sections
    InitializeCriticalSection(&g_csDllMain);
    g_fAttached = TRUE;

	// Create OLE Task Memory Allocator
	CoGetMalloc(1, &g_pMalloc);
	Assert(g_pMalloc);

    // Initialize Demand-loaded Libs
    InitDemandLoadedLibs();

    InitCommonControlsEx(&icex);
}

// --------------------------------------------------------------------------------
// FreeGlobalVars
// --------------------------------------------------------------------------------
void FreeGlobalVars(void)
{   
    // Free libraries that demand.cpp loaded
    FreeDemandLoadedLibs();

    // Release Global Memory allocator
	SafeRelease(g_pMalloc);

	// Delete Global Critical Sections
    g_fAttached = FALSE;
    DeleteCriticalSection(&g_csDllMain);
}

// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
int APIENTRY DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
	    // Set global instance handle

        s_hInst = hInst;

        // Initialize Global Variables
		InitGlobalVars();
	    
        g_hInstImp = LoadLangDll(s_hInst, c_szOEResDll, fIsNT5());

        // No Thread Attach Stuff
        // SideAssert(DisableThreadLibraryCalls(hInst));

		// Done
        break;

    case DLL_PROCESS_DETACH:
		// Free Global Variables
		FreeGlobalVars();

        // Done
	    break;
    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    InterlockedIncrement(&g_cRef);
    return g_cRef;
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    InterlockedDecrement(&g_cRef);
    return g_cRef;
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if(!g_fAttached)    // critacal sections was deleted (or not created): we defently can be unloaded
        return S_OK;

    EnterCriticalSection(&g_csDllMain);
    DebugTrace("DllCanUnloadNow: %s - Reference Count: %d, LockServer Count: %d\n", __FILE__, g_cRef, g_cLock);
    hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;
    LeaveCriticalSection(&g_csDllMain);
    return hr;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    hr = CallRegInstall(s_hInst, s_hInst, c_szReg, NULL);
    return(hr);
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    hr = CallRegInstall(s_hInst, s_hInst, c_szUnReg, NULL);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\export.cpp ===
#include "pch.hxx"
#include <mapi.h>
#include <mapix.h>
#include <newimp.h>
#include <impapi.h>
#include "import.h"
#include <imnapi.h>
#include <mapiconv.h>
#include "strconst.h"

ASSERTDATA

static IMAPISession *s_pmapiExp = NULL;

PFNEXPGETFIRSTIMSG      g_pExpGetFirstImsg = 0;
PFNEXPGETNEXTIMSG       g_pExpGetNextImsg = 0;
PFNEXPGETIMSGCLOSE      g_pExpGetImsgClose = 0;
PFNEXPGETFOLDERLIST     g_pExpGetFolderList = 0;
PFNEXPFREEFOLDERLIST    g_pExpFreeFolderList = 0;
PFNFREEIMSG             g_pFreeImsg = 0;

#undef ExpGetFirstImsg
#undef ExpGetNextImsg
#undef ExpGetImsgClose
#undef ExpGetFolderList
#undef ExpFreeFolderList
#undef FreeImsg

#define ExpGetFirstImsg     (*g_pExpGetFirstImsg)
#define ExpGetNextImsg      (*g_pExpGetNextImsg)
#define ExpGetImsgClose     (*g_pExpGetImsgClose)
#define ExpGetFolderList    (*g_pExpGetFolderList)
#define ExpFreeFolderList   (*g_pExpFreeFolderList)
#define FreeImsg            (*g_pFreeImsg)

INT_PTR CALLBACK ExportDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL PerformExport(HWND hwnd, IMPFOLDERNODE **ppnode, int cnode, IMPFOLDERNODE *plist);
HRESULT ExportFolder(TCHAR *szName, LPMAPIFOLDER pfldr, HANDLE hfolder, ULONG cMsg, CImpProgress *pProg);
HRESULT GetExportFolders(HWND hwndList, BOOL fSel, IMPFOLDERNODE ***pplist, int *pcnode);
HRESULT HrGetFolder(LPMAPIFOLDER lpParent, LPSTR szName, LPMAPIFOLDER *lplpFldr, BOOL *pfDidCreate);
INT_PTR CALLBACK ExportProgressDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

HRESULT ExportMessages(HWND hwnd)
    {
    HRESULT hr;
    int iret;
    BOOL fInit;
    HMODULE hinst;
    IMPFOLDERNODE *plist;

    hr = E_FAIL;
    fInit = FALSE;

    hinst = LoadLibrary(c_szMainDll);
    if (hinst != NULL)
        {
        g_pExpGetFirstImsg = (PFNEXPGETFIRSTIMSG)GetProcAddress(hinst, MAKEINTRESOURCE(9));
        g_pExpGetNextImsg = (PFNEXPGETNEXTIMSG)GetProcAddress(hinst, MAKEINTRESOURCE(10));
        g_pExpGetImsgClose = (PFNEXPGETIMSGCLOSE)GetProcAddress(hinst, MAKEINTRESOURCE(11));
        g_pExpGetFolderList = (PFNEXPGETFOLDERLIST)GetProcAddress(hinst, MAKEINTRESOURCE(12));
        g_pExpFreeFolderList = (PFNEXPFREEFOLDERLIST)GetProcAddress(hinst, MAKEINTRESOURCE(13));
        g_pFreeImsg = (PFNFREEIMSG)GetProcAddress(hinst, MAKEINTRESOURCE(14));
        if (g_pExpGetFirstImsg != NULL &&
            g_pExpGetNextImsg != NULL &&
            g_pExpGetImsgClose != NULL &&
            g_pExpGetFolderList != NULL &&
            g_pExpFreeFolderList != NULL &&
            g_pFreeImsg != NULL)
            {
            fInit = TRUE;

            iret = (int) ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
                            MAKEINTRESOURCE(idsPerformExport), NULL, MB_OKCANCEL | MB_ICONINFORMATION);
            if (iret == IDOK)
                {
                hr = ExchInit();
                if (SUCCEEDED(hr))
                    {
                    Assert(s_pmapiExp == NULL);
                    hr = MapiLogon(hwnd, &s_pmapiExp);
                    if (hr == S_OK)
                        {
                        Assert(s_pmapiExp != NULL);

                        hr = ExpGetFolderList(&plist);
                        if (SUCCEEDED(hr))
                            {
                            iret = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddExport), hwnd,
                                                    ExportDlgProc, (LPARAM)plist);

                            ExpFreeFolderList(plist);
                            }

                        s_pmapiExp->Logoff(NULL, 0, 0);
                        s_pmapiExp = NULL;
                        }

                    ExchDeinit();
                    }
                else if (hr == MAPI_E_USER_CANCEL)
                    {
                    hr = S_OK;
                    }
                else
                    {
                    ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
                        MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMAPIInitError),
                        MB_OK | MB_ICONSTOP);
                    }
                }
            else if (iret == IDCANCEL)
                {
                hr = S_OK;
                }
            }

        FreeLibrary(hinst);
        }

    if (!fInit)
    {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
            MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMapiInitError),
            MB_OK | MB_ICONSTOP);
    }

    return(hr);
    }

INT_PTR CALLBACK ExportDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    int id, cnode;
    BOOL fRet;
    HWND hwndList;
    HRESULT hr;
    IMPFOLDERNODE *plist, **ppnode;
    TCHAR sz[256];
    HCURSOR hcur = 0;

    fRet = TRUE;
    hwndList = GetDlgItem(hwnd, IDC_IMPFOLDER_LISTVIEW);
    plist = (IMPFOLDERNODE *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (msg)
        {
        case WM_INITDIALOG:
            plist = (IMPFOLDERNODE *)lParam;
            Assert(plist != NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)plist);

            InitListViewImages(hwndList);
            FillFolderListview(hwndList, plist, NULL);

            SendDlgItemMessage(hwnd, IDC_IMPORTALL_RADIO, BM_SETCHECK, BST_CHECKED, 0);
            EnableWindow(GetDlgItem(hwnd, IDC_IMPFOLDER_LISTVIEW), FALSE);
            break;

        case WM_COMMAND:
            id = LOWORD(wParam);

            switch (id)
                {
                case IDOK:
                    fRet = (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_SELECT_RADIO, BM_GETCHECK, 0, 0));

                    plist = (IMPFOLDERNODE *)GetWindowLongPtr(hwnd, DWLP_USER);
                    Assert(plist != NULL);

                    hr = GetExportFolders(hwndList, fRet, &ppnode, &cnode);
                    if (SUCCEEDED(hr) && cnode > 0)
                        {
                        hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                        
                        fRet = PerformExport(hwnd, ppnode, cnode, plist);

                        if (ppnode != NULL)
                            MemFree(ppnode);

                        SetCursor(hcur);
                        }

                    // fall through...

                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;

                case IDC_IMPORTALL_RADIO:
                case IDC_SELECT_RADIO:
                    if (HIWORD(wParam) == BN_CLICKED)
                        EnableWindow(hwndList, id == IDC_SELECT_RADIO);
                    break;
                }
            break;

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

void ReleaseMapiFolders(IMPFOLDERNODE *plist)
    {
    while (plist != NULL)
        {
        if (plist->dwReserved != NULL)
            {
            ((LPMAPIFOLDER)plist->dwReserved)->Release();
            plist->dwReserved = NULL;
            }
        if (plist->pchild != NULL)
            ReleaseMapiFolders(plist->pchild);
        plist = plist->pnext;
        }
    }

BOOL PerformExport(HWND hwnd, IMPFOLDERNODE **ppnode, int cnode, IMPFOLDERNODE *plist)
    {
    CImpProgress *pProg;
    IMPFOLDERNODE *pnode, *pnodeT;
    int inode;
    LPMAPICONTAINER pcont;
    LPMAPIFOLDER pfldrRoot, pfldrParent, pfldr;
    HRESULT hr;

    Assert(cnode > 0);
    Assert(ppnode != NULL);
    Assert(plist != NULL);

    pProg = new CImpProgress;
    if (pProg == NULL)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
            MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMemory),
            MB_OK | MB_ICONSTOP);

        return(FALSE);
        }

    Assert(s_pmapiExp != NULL);
    pcont = OpenDefaultStoreContainer(hwnd, s_pmapiExp);
    if (pcont == NULL)
        {
        hr = E_OUTOFMEMORY;
        }
    else
        {
        hr = pcont->QueryInterface(IID_IMAPIFolder, (void **)&pfldrRoot);
        pcont->Release();
        }

    if (FAILED(hr))
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsExportTitle),
            MAKEINTRESOURCE(idsExportError), MAKEINTRESOURCE(idsMAPIStoreOpenError),
            MB_OK | MB_ICONSTOP);

        return(FALSE);
        }

    pProg->Init(hwnd, TRUE);
    pProg->SetTitle(MAKEINTRESOURCE(idsExportTitle));

    for (inode = 0; inode < cnode; inode++)
        {
        pnode = ppnode[inode];
        Assert(pnode != NULL);

        pfldrParent = NULL;
        pnodeT = pnode->pparent;
        while (pnodeT != NULL)
            {
            if (pnodeT->dwReserved != NULL)
                {
                pfldrParent = (LPMAPIFOLDER)pnodeT->dwReserved;
                break;
                }
            pnodeT = pnodeT->pparent;
            }
        if (pfldrParent == NULL)
            {
            pfldrParent = pfldrRoot;
            ReleaseMapiFolders(plist);
            }

        hr = HrGetFolder(pfldrParent, pnode->szName, &pfldr, NULL);
        if (!FAILED(hr))
            hr = ExportFolder(pnode->szName, pfldr, (HANDLE)pnode->lparam, pnode->cMsg, pProg);

        if(hr == hrUserCancel)
            break;

        Assert(pnode->dwReserved == NULL);
        pnode->dwReserved = (DWORD_PTR)pfldr;
        }

    pProg->Release();

    ReleaseMapiFolders(plist);
    pfldrRoot->Release();

    return(TRUE);
    }

HRESULT GetExportFolders(HWND hwndList, BOOL fSel, IMPFOLDERNODE ***pplist, int *pcnode)
    {
    int cSel, ili;
    IMPFOLDERNODE **ppnode, **ppnodeT;
    LV_ITEM lvi;

    Assert(pplist != NULL);
    Assert(pcnode != NULL);

    *pplist = NULL;
    *pcnode = 0;

    cSel = (int) SendMessage(hwndList, (fSel ? LVM_GETSELECTEDCOUNT : LVM_GETITEMCOUNT), 0, 0);
    if (cSel == 0)
        return(S_OK);

    if (!MemAlloc((void **)&ppnode, sizeof(IMPFOLDERNODE *) * cSel))
        return(E_OUTOFMEMORY);
    ppnodeT = ppnode;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;

    cSel = 0;
    ili = -1;
    while (-1 != (ili = ListView_GetNextItem(hwndList, ili, fSel ? LVNI_SELECTED : 0)))
        {
        lvi.iItem = ili;
        if (ListView_GetItem(hwndList, &lvi))
            {
            Assert(lvi.lParam != 0);

            *ppnodeT = (IMPFOLDERNODE *)lvi.lParam;
            cSel++;
            ppnodeT++;
            }
        }

    *pplist = ppnode;
    *pcnode = cSel;

    return(S_OK);
    }

HRESULT HrGetFolder(LPMAPIFOLDER lpParent, LPSTR szName, LPMAPIFOLDER *lplpFldr, BOOL *pfDidCreate)
    {
    SPropValue   pv;
    HRESULT      hr;
    SRestriction sr;
    LPMAPITABLE  lpTable = NULL;
    SizedSPropTagArray(3, ptaFindFldr) = 
        { 3, { PR_ENTRYID,
               PR_DISPLAY_NAME,
               PR_STATUS} };


    pv.ulPropTag = PR_DISPLAY_NAME;
    pv.Value.lpszA = szName;

    *lplpFldr = NULL; // in case we fail

    if (FAILED(hr = lpParent->GetHierarchyTable(0, &lpTable)))
        goto cleanup;

    // Set the table's columns to include PR_MODULE_CLASS so FindRow will work.
    if (HR_FAILED(hr=lpTable->SetColumns((LPSPropTagArray)&ptaFindFldr, 0)))
        {
        // Fn might (?) fail if container is an address book
        // so this might need to change...
        DOUTL(2, "HrGetContainer: SetColumns failed.");
        goto cleanup;
        }

    // Find the container.  If it's not there, then we need to create it

    if (pfDidCreate)
        *pfDidCreate = FALSE;  // default value

    sr.rt = RES_PROPERTY;
    sr.res.resProperty.relop = RELOP_EQ;
    sr.res.resProperty.ulPropTag = pv.ulPropTag;
    sr.res.resProperty.lpProp = &pv;

    if (FAILED(hr = lpTable->FindRow(&sr, BOOKMARK_BEGINNING, 0)))
        {   // folder needs to be created
        hr = lpParent->CreateFolder(FOLDER_GENERIC, szName, NULL, NULL, 0, lplpFldr);
        if (pfDidCreate && SUCCEEDED(hr))
            *pfDidCreate = TRUE;          // a new folder was created
        }
    else
        {
        LPSRowSet       lpRowSet = NULL;
        LPSPropValue    lpProp;
        ULONG           ulObjType;

        if (!FAILED(hr = lpTable->QueryRows(1, TBL_NOADVANCE, &lpRowSet)) && lpRowSet->cRows)
            {
            if (lpProp = PvalFind(lpRowSet->aRow, PR_ENTRYID))
                hr = lpParent->OpenEntry(lpProp->Value.bin.cb, 
                                         (LPENTRYID)lpProp->Value.bin.lpb, 
                                         NULL,
                                         MAPI_MODIFY,
                                         &ulObjType,
                                         (LPUNKNOWN FAR *)lplpFldr);
            }

        FreeSRowSet(lpRowSet);
        }

cleanup:
    if (lpTable)
        lpTable->Release();
    return hr;        
    }

HRESULT ExportFolder(TCHAR *szName, LPMAPIFOLDER pfldr, HANDLE hfolder, ULONG cMsg, CImpProgress *pProg)
    {
    HRESULT hr;
    HANDLE hnd;
    IMSG imsg;
    LPMESSAGE pmsg;
    ULONG iMsg;
    TCHAR sz[128], szT[256];

    LoadString(g_hInstImp, idsExportingFolderFmt, sz, ARRAYSIZE(sz));
    wsprintf(szT, sz, szName);

    LoadString(g_hInstImp, idsImportingMessageFmt, sz, ARRAYSIZE(sz));

    iMsg = 0;

    hr = ExpGetFirstImsg(hfolder, &imsg, &hnd);
    while (hr == S_OK)
        {
        if (iMsg == 0)
            {
            pProg->SetMsg(szT, IDC_FOLDER_STATIC);
            pProg->Show(0);

            pProg->Reset();
            pProg->AdjustMax(cMsg);
            }

        wsprintf(szT, sz, iMsg + 1, cMsg);
        pProg->SetMsg(szT, IDC_MESSAGE_STATIC);

        hr = pfldr->CreateMessage(NULL, 0, &pmsg);
        if (!FAILED(hr))
            {
            hr = HrImsgToMapi(&imsg, pmsg);

            pmsg->Release();
            }

        FreeImsg(&imsg);

        hr = ExpGetNextImsg(&imsg, hnd);
        if (hr != S_OK)
            break;

        iMsg++;
        hr = pProg->HrUpdate(1);
        }

    ExpGetImsgClose(hnd);

    if (hr == S_FALSE)
        hr = S_OK;

    return(hr);
    }

#define IDT_PROGRESS_DELAY  (WM_USER + 1)

CImpProgress::CImpProgress ()
{
    DOUT ("CImpProgress::CImpProgress");
    m_cRef = 1;
    m_cMax = 0;
    m_cPerCur = 0;
    m_hwndProgress = NULL;
    m_hwndDlg = NULL;
    m_hwndOwner = NULL;
    m_fCanCancel = FALSE;
    m_fHasCancel = FALSE;
}

// =====================================================================================
// CImpProgress::~CImpProgress
// =====================================================================================
CImpProgress::~CImpProgress ()
{
    DOUT ("CImpProgress::~CImpProgress");
    Close();
}

// =====================================================================================
// CImpProgress::AddRef
// =====================================================================================
ULONG CImpProgress::AddRef ()
{
    ++m_cRef;
    DOUT ("CImpProgress::AddRef () Ref Count=%d", m_cRef);
    return m_cRef;
}

// =====================================================================================
// CImpProgress::AddRef
// =====================================================================================
ULONG CImpProgress::Release ()
{
    ULONG ulCount = --m_cRef;
    DOUT ("CImpProgress::Release () Ref Count=%d", ulCount);
    if (!ulCount)
        delete this;
    return ulCount;
}

// =====================================================================================
// CImpProgress::Init
// =====================================================================================
VOID CImpProgress::Init (HWND      hwndParent, BOOL      fCanCancel)
{
    Assert(m_hwndDlg == NULL);

    // Set Max and cur
    m_fCanCancel = fCanCancel;

    // Save Parent
    m_hwndOwner = hwndParent;

    // Disable Parent
    EnableWindow (m_hwndOwner, FALSE);

    // Create Dialog
    m_hwndDlg = CreateDialogParam (g_hInstImp, MAKEINTRESOURCE (iddImpProgress),
                    hwndParent, (DLGPROC)ProgressDlgProc, (LPARAM)this);
}

// =====================================================================================
// CImpProgress::Close
// =====================================================================================
VOID CImpProgress::Close (VOID)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Enable parent
        if (m_hwndOwner)
            EnableWindow (m_hwndOwner, TRUE);

        // Destroy it
        DestroyWindow (m_hwndDlg);

        // NULL
        m_hwndDlg = NULL;
    }
}

// =====================================================================================
// CImpProgress::Show
// =====================================================================================
VOID CImpProgress::Show (DWORD dwDelaySeconds)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Show the window if now delay
        if (dwDelaySeconds == 0)
            ShowWindow (m_hwndDlg, SW_SHOWNORMAL);
        else
            SetTimer(m_hwndDlg, IDT_PROGRESS_DELAY, dwDelaySeconds * 1000, NULL);
    }
}

// =====================================================================================
// CImpProgress::Hide
// =====================================================================================
VOID CImpProgress::Hide (VOID)
{
    // If we have a window
    if (m_hwndDlg)
    {
        // Hide it
        ShowWindow (m_hwndDlg, SW_HIDE);
    }
}

// =====================================================================================
// CImpProgress::SetMsg
// =====================================================================================
VOID CImpProgress::SetMsg(LPTSTR lpszMsg, int id)
{
    TCHAR sz[CCHMAX_STRINGRES];

    if (m_hwndDlg && lpszMsg)
        {
        if (IS_INTRESOURCE(lpszMsg))
            {
            LoadString(g_hInstImp, PtrToUlong(lpszMsg), sz, sizeof(sz) / sizeof(TCHAR));
            lpszMsg = sz;
            }

        SetWindowText (GetDlgItem (m_hwndDlg, id), lpszMsg);
        }
}

// =====================================================================================
// CImpProgress::SetTitle
// =====================================================================================
VOID CImpProgress::SetTitle(LPTSTR lpszTitle)
{
    TCHAR sz[CCHMAX_STRINGRES];

    if (m_hwndDlg && lpszTitle)
        {
        if (IS_INTRESOURCE(lpszTitle))
            {
            LoadString(g_hInstImp, PtrToUlong(lpszTitle), sz, sizeof(sz) / sizeof(TCHAR));
            lpszTitle = sz;
            }

        SetWindowText (m_hwndDlg, lpszTitle);
        }
}

// =====================================================================================
// CImpProgress::AdjustMax
// =====================================================================================
VOID CImpProgress::AdjustMax(ULONG cNewMax)
{
    // Set Max
    m_cMax = cNewMax;

    // If 0
    if (m_cMax == 0)
    {
        SendMessage (m_hwndProgress, PBM_SETPOS, 0, 0);
        ShowWindow(m_hwndProgress, SW_HIDE);
        return;
    }
    else
        ShowWindow(m_hwndProgress, SW_SHOWNORMAL);

    // If cur is now larget than max ?
    if (m_cCur > m_cMax)
        m_cCur = m_cMax;

    // Compute percent
    m_cPerCur = (m_cCur * 100 / m_cMax);

    // Update status
    SendMessage (m_hwndProgress, PBM_SETPOS, m_cPerCur, 0);

    // msgpump to process user moving window, or pressing cancel... :)
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

VOID CImpProgress::Reset()
{
    m_cCur = 0;
    m_cPerCur = 0;

    // Update status
    SendMessage (m_hwndProgress, PBM_SETPOS, 0, 0);
}

// =====================================================================================
// CImpProgress::HrUpdate
// =====================================================================================
HRESULT CImpProgress::HrUpdate (ULONG cInc)
{
    // No max
    if (m_cMax) 
    {
        // Increment m_cCur
        m_cCur += cInc;
        
        // If cur is now larget than max ?
        if (m_cCur > m_cMax)
            m_cCur = m_cMax;
        
        // Compute percent
        ULONG cPer = (m_cCur * 100 / m_cMax);
        
        // Step percent
        if (cPer > m_cPerCur)
        {
            // Set percur
            m_cPerCur = cPer;
            
            // Update status
            SendMessage (m_hwndProgress, PBM_SETPOS, m_cPerCur, 0);
            
            // msgpump to process user moving window, or pressing cancel... :)
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    
    // Still pump some messages, call may not want to do this too often
    else
    {
        // msgpump to process user moving window, or pressing cancel... :)
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    
    // Done
    return m_fHasCancel ? hrUserCancel : S_OK;
}

// =====================================================================================
// CImpProgress::ProgressDlgProc
// =====================================================================================
INT_PTR CALLBACK CImpProgress::ProgressDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    CImpProgress *lpProgress = (CImpProgress *)GetWndThisPtr(hwnd);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        lpProgress = (CImpProgress *)lParam;
        if (!lpProgress)
        {
            Assert (FALSE);
            return 1;
        }
        lpProgress->m_hwndProgress = GetDlgItem (hwnd, IDC_IMPORT_PROGRESS);
        if (lpProgress->m_cMax == 0)
            ShowWindow(lpProgress->m_hwndProgress, SW_HIDE);

        // Show the cancel button if m_fCanCancel is true.
        if(lpProgress->m_fCanCancel)
            ShowWindow(GetDlgItem(hwnd, IDCANCEL), SW_SHOWNORMAL);

        SetWndThisPtr (hwnd, lpProgress);
        return 1;

    case WM_TIMER:
        if (wParam == IDT_PROGRESS_DELAY)
        {
            KillTimer(hwnd, IDT_PROGRESS_DELAY);
            if (lpProgress->m_cPerCur < 80)
            {
                lpProgress->m_cMax -= lpProgress->m_cCur;
                lpProgress->Reset();
                ShowWindow(hwnd, SW_SHOWNORMAL);
            }
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            if (lpProgress)
            {
                EnableWindow ((HWND)lParam, FALSE);
                lpProgress->m_fHasCancel = TRUE;
            }
            return 1;
        }
        break;

    case WM_DESTROY:
        KillTimer(hwnd, IDT_PROGRESS_DELAY);
        SetWndThisPtr (hwnd, NULL);
        break;
    }

    // Done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

class CClassFactory; // Forward

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
    {
    public:
        CLSID const        *m_pclsid;
        DWORD               m_dwFlags;
        PFCREATEINSTANCE    m_pfCreateInstance;

        // Construction
        CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

        // IUnknown members
        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IClassFactory members
        STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
        STDMETHODIMP LockServer(BOOL);

        // CClassFactory Members
        void SetObjectIndex(ULONG iObjIndex);
    };

// --------------------------------------------------------------------------------
// Object Creators
// --------------------------------------------------------------------------------
HRESULT CAthena16Import_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CEudoraImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CExchImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CNetscapeImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT CCommunicatorImport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\newdel.cpp ===
// --------------------------------------------------------------------------------
// Override new  and delete operator
// --------------------------------------------------------------------------------
#include "pch.hxx"

// --------------------------------------------------------------------------------
// Override new operator
// --------------------------------------------------------------------------------
void * __cdecl operator new(UINT cb )
{
    LPVOID  lpv = 0;

    lpv = CoTaskMemAlloc(cb);
#ifdef DEBUG
    if (lpv)
        memset(lpv, 0xca, cb);
#endif // DEBUG
    return lpv;
}

// --------------------------------------------------------------------------------
// Override delete operator
// --------------------------------------------------------------------------------
#ifndef WIN16
void __cdecl operator delete(LPVOID pv )
#else
void __cdecl operator delete(VOID *pv )
#endif
{
    CoTaskMemFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\import.cpp ===
#include "pch.hxx"
#include <prsht.h>
#include <mapi.h>
#include <mapix.h>
#include <comconv.h>
#include "abimport.h"

#define INITGUID
#include <ole2.h>
#include <initguid.h>
#include "newimp.h"
#include <impapi.h>
#include "import.h"
#include <eudrimp.h>
#include <mapiconv.h>
#include <netsimp.h>	//Netscape
#include <commimp.h>	//Communicator
#include <ImpAth16.h>
#include <oe4imp.h>
#include "strconst.h"
#include "demand.h"

ASSERTDATA

#define IDD_NEXT    0x3024

class CFolderImportProg : public IFolderImport
    {
    private:
        ULONG               m_cRef;
        IFolderImport       *m_pImportEx;
        UINT                m_iMsg;
        UINT                m_cMsg;
        CImpProgress        *m_pProgress;
        TCHAR               m_szFldrFmt[CCHMAX_STRINGRES];
        TCHAR               m_szMsgFmt[CCHMAX_STRINGRES];
        TCHAR               m_szFolder[MAX_PATH];

    public:
        CFolderImportProg(void);
        ~CFolderImportProg(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        HRESULT Initialize(HWND hwnd);
        void SetFolder(IFolderImport *pImport, TCHAR *szName, UINT cMsg);
        void ReleaseFolder(void);
        HRESULT UpdateProgress(void);

        STDMETHODIMP SetMessageCount(ULONG cMsg);
        STDMETHODIMP ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach);
        STDMETHODIMP ImportMessage(IMSG *pimsg);
    };

HRESULT GetFolderList(IMailImport *pMailImp, IMPFOLDERNODE **pplist);
void FreeFolderList(IMPFOLDERNODE *plist);
HRESULT ImportFolders(HWND hwnd, IMailImporter *pImporter, IMailImport *pMailImp, IMPFOLDERNODE *plist, CFolderImportProg *pImpProg);
HRESULT DoImportWizard(HWND hwnd, IMPWIZINFO *pinfo);

CFolderImportProg::CFolderImportProg()
    {
    m_cRef = 1;
    m_pImportEx = NULL;
    // m_iMsg
    // m_cMsg
    m_pProgress = NULL;
    // m_szFldrFmt
    // m_szMsgFmt
    // m_szFolder
    }

CFolderImportProg::~CFolderImportProg()
    {
    if (m_pImportEx != NULL)
        m_pImportEx->Release();
    if (m_pProgress != NULL)
        m_pProgress->Release();
    }

ULONG CFolderImportProg::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CFolderImportProg::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CFolderImportProg::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IFolderImport == riid)
		*ppv = (IFolderImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CFolderImportProg::Initialize(HWND hwnd)
    {
    LoadString(g_hInstImp, idsImportingFolderFmt, m_szFldrFmt, ARRAYSIZE(m_szFldrFmt));
    LoadString(g_hInstImp, idsImportingMessageFmt, m_szMsgFmt, ARRAYSIZE(m_szMsgFmt));

    m_pProgress = new CImpProgress;
    if (m_pProgress == NULL)
        return(E_OUTOFMEMORY);

    m_pProgress->Init(hwnd, TRUE);

    return(S_OK);
    }

void CFolderImportProg::SetFolder(IFolderImport *pImport, TCHAR *szName, UINT cMsg)
    {
    Assert(pImport != NULL);
    Assert(m_pImportEx == NULL);

    m_pImportEx = pImport;
    m_pImportEx->AddRef();

    m_iMsg = 0;
    m_cMsg = cMsg;

    lstrcpyn(m_szFolder, szName, ARRAYSIZE(m_szFolder));
    }

void CFolderImportProg::ReleaseFolder()
    {
    Assert(m_pImportEx != NULL);
    m_pImportEx->Release();
    m_pImportEx = NULL;
    }

HRESULT CFolderImportProg::SetMessageCount(ULONG cMsg)
    {
    m_cMsg = cMsg;

    return(m_pImportEx->SetMessageCount(cMsg));
    }

HRESULT CFolderImportProg::UpdateProgress()
    {
    TCHAR sz[CCHMAX_STRINGRES + MAX_PATH];

    if (m_iMsg == 0)
        {
        wsprintf(sz, m_szFldrFmt, m_szFolder);

        m_pProgress->SetMsg(sz, IDC_FOLDER_STATIC);
        m_pProgress->Show(0);

        m_pProgress->Reset();
        m_pProgress->AdjustMax(m_cMsg);
        }

    m_iMsg++;

    wsprintf(sz, m_szMsgFmt, m_iMsg, m_cMsg);
    m_pProgress->SetMsg(sz, IDC_MESSAGE_STATIC);

    return(m_pProgress->HrUpdate(1));
    }

HRESULT CFolderImportProg::ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach)
    {
    HRESULT hr;
    
    hr = UpdateProgress();

    if (hr != hrUserCancel)
        hr = m_pImportEx->ImportMessage(type, dwState, pstm, rgszAttach, cAttach);

    return(hr);
    }

HRESULT CFolderImportProg::ImportMessage(IMSG *pimsg)
    {
    HRESULT hr;
    
    hr = UpdateProgress();

    if (hr != hrUserCancel)
        hr = m_pImportEx->ImportMessage(pimsg);

    return(hr);
    }

void PerformImport(HWND hwnd, IMailImporter *pImporter, DWORD dwFlags)
    {
    IMPWIZINFO wizinfo;
    HRESULT hr;

    Assert(dwFlags == 0);

    ZeroMemory(&wizinfo, sizeof(IMPWIZINFO));
    wizinfo.pImporter = pImporter;

    hr = DoImportWizard(hwnd, &wizinfo);

    if (wizinfo.pClsid != NULL)
        MemFree(wizinfo.pClsid);

    if (wizinfo.pList != NULL)
        FreeFolderList(wizinfo.pList);

    if (wizinfo.pImport != NULL)
        wizinfo.pImport->Release();

    ExchDeinit();
    }

IMPFOLDERNODE *InsertFolderNode(IMPFOLDERNODE *plist, IMPFOLDERNODE *pnode)
    {
    BOOL fNodeNormal, fCurrNormal;
    IMPFOLDERNODE *pprev, *pcurr;

    Assert(pnode != NULL);
    pnode->pnext = NULL;

    if (plist == NULL)
        return(pnode);

    pprev = NULL;
    pcurr = plist;
    while (pcurr != NULL)
        {
        fNodeNormal = pnode->type == FOLDER_TYPE_NORMAL;
        fCurrNormal = pcurr->type == FOLDER_TYPE_NORMAL;

        if (!fNodeNormal &&
            fCurrNormal)
            break;

        if (fNodeNormal == fCurrNormal &&
            lstrcmpi(pnode->szName, pcurr->szName) <= 0)
            break;

        pprev = pcurr;
        pcurr = pcurr->pnext;
        }

    if (pcurr == NULL)
        {
        // insert at end of list
        Assert(pprev != NULL);
        pprev->pnext = pnode;
        }
    else if (pprev == NULL)
        {
        // insert at beginning of list
        pnode->pnext = plist;
        plist = pnode;
        }
    else
        {
        pprev->pnext = pnode;
        pnode->pnext = pcurr;
        }

    return(plist);
    }

HRESULT GetSubFolderList(IMailImport *pMailImp, IMPFOLDERNODE *pparent, DWORD_PTR dwCookie, IMPFOLDERNODE **pplist)
    {
    HRESULT hr;
    TCHAR *sz;
    IMPORTFOLDER folder;
    IEnumFOLDERS *pEnum;
    IMPFOLDERNODE *pnode, *plist;

    Assert(pMailImp != NULL);
    Assert(pplist != NULL);

    *pplist = NULL;
    plist = NULL;
    pEnum = NULL;

    hr = pMailImp->EnumerateFolders(dwCookie, &pEnum);
    if (FAILED(hr))
        return(hr);
    else if (hr == S_FALSE)
        return(S_OK);

    Assert(pEnum != NULL);

    while (S_OK == (hr = pEnum->Next(&folder)))
        {
        if (!MemAlloc((void **)&pnode, sizeof(IMPFOLDERNODE) + MAX_PATH * sizeof(TCHAR)))
            {
            hr = E_OUTOFMEMORY;
            break;
            }
        ZeroMemory(pnode, sizeof(IMPFOLDERNODE));
        sz = (TCHAR *)((BYTE *)pnode + sizeof(IMPFOLDERNODE));

        pnode->pparent = pparent;
        pnode->depth = (pparent != NULL) ? (pparent->depth + 1) : 0;
        pnode->szName = sz;
        pnode->type = folder.type;
        lstrcpy(sz, folder.szName);
        pnode->lparam = (LPARAM)folder.dwCookie;

        plist = InsertFolderNode(plist, pnode);

        if (folder.fSubFolders > 0)
            {
            hr = GetSubFolderList(pMailImp, pnode, folder.dwCookie, &pnode->pchild);
            if (FAILED(hr))
                break;
            }
        }

    if (hr == S_FALSE)
        hr = S_OK;

    pEnum->Release();

    *pplist = plist;

    return(hr);
    }

HRESULT GetFolderList(IMailImport *pMailImp, IMPFOLDERNODE **pplist)
    {
    IMPFOLDERNODE *plist;
    HRESULT hr;

    Assert(pMailImp != NULL);
    Assert(pplist != NULL);

    plist = NULL;

    hr = GetSubFolderList(pMailImp, NULL, COOKIE_ROOT, &plist);
    if (FAILED(hr))
        {
        FreeFolderList(plist);
        plist = NULL;
        }

    *pplist = plist;

    return(hr);
    }

void FreeFolderList(IMPFOLDERNODE *plist)
    {
    IMPFOLDERNODE *pnode;

    while (plist != NULL)
        {
        if (plist->pchild != NULL)
            FreeFolderList(plist->pchild);
        pnode = plist;
        plist = plist->pnext;
        MemFree(pnode);
        }
    }

void FillFolderListview(HWND hwnd, IMPFOLDERNODE *plist, DWORD_PTR dwReserved)
    {
    LV_ITEM lvi;
    int iret;

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_INDENT;
    lvi.iSubItem = 0;

    for ( ; plist != NULL; plist = plist->pnext)
        {
        plist->dwReserved = dwReserved;

        lvi.pszText = plist->szName;
        lvi.lParam = (LPARAM)plist;
        lvi.iIndent = plist->depth;
        if (plist->type >= CFOLDERTYPE)
            lvi.iImage = iFolderClosed;
        else
            lvi.iImage = (int)plist->type + iFolderClosed;
        lvi.iItem = ListView_GetItemCount(hwnd);

        iret = ListView_InsertItem(hwnd, &lvi);
        Assert(iret != -1);

        if (plist->pchild != NULL)
            FillFolderListview(hwnd, plist->pchild, dwReserved);
        }
    }

void InitListViewImages(HWND hwnd)
    {
    HBITMAP hbm;
    HIMAGELIST himl;
    LV_COLUMN lvc;
    RECT rc;

    GetWindowRect(hwnd, &rc);

    lvc.mask = LVCF_TEXT | LVCF_WIDTH;
    lvc.pszText = (TCHAR *)c_szEmpty;
    lvc.cx = rc.right - rc.left - 2 * GetSystemMetrics(SM_CXEDGE) - GetSystemMetrics(SM_CXVSCROLL);
    lvc.iSubItem = 0;
    ListView_InsertColumn(hwnd, 0, &lvc);

    himl = ImageList_Create(16, 16, ILC_MASK, CFOLDERTYPE, 0);

    if (himl != NULL)
        {
        hbm = LoadBitmap(g_hInstImp, MAKEINTRESOURCE(idbFolders));
        Assert(hbm != NULL);

        ImageList_AddMasked(himl, hbm, RGB(255, 0, 255));

        DeleteObject((HGDIOBJ)hbm);

        ListView_SetImageList(hwnd, himl, LVSIL_SMALL);
        }
    }

HRESULT ImportFolders(HWND hwnd, IMailImporter *pImporter, IMailImport *pMailImp, IMPFOLDERNODE *plist, CFolderImportProg *pImpProg)
    {
    HRESULT hr;
    DWORD_PTR dwParent;
    TCHAR szFmt[CCHMAX_STRINGRES], szError[CCHMAX_STRINGRES];
    IMPFOLDERNODE *pnode, *pnodeT;
    IFolderImport *pFldrImp;

    Assert(pImporter != NULL);
    Assert(pMailImp != NULL);
    Assert(plist != NULL);
    Assert(pImpProg != NULL);

    pnode = plist;
    while (pnode != NULL)
        {
        if (pnode->fImport)
            {
            dwParent = COOKIE_ROOT;
            pnodeT = pnode->pparent;
            while (pnodeT != NULL)
                {
                if (pnodeT->fImport)
                    {
                    dwParent = pnodeT->dwReserved;
                    break;
                    }
                pnodeT = pnodeT->pparent;
                }

            hr = pImporter->OpenFolder(dwParent, pnode->szName, pnode->type, 0, &pFldrImp, &pnode->dwReserved);
            if (hr == E_OUTOFMEMORY || hr == hrDiskFull)
                return(hr);
            else if (SUCCEEDED(hr))
                {
                Assert(pFldrImp != NULL);

                pImpProg->SetFolder(pFldrImp, pnode->szName, pnode->cMsg);

                hr = pMailImp->ImportFolder((DWORD)pnode->lparam, pImpProg);

                pImpProg->ReleaseFolder();
                pFldrImp->Release();

                if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
                    return(hr);
                else if (FAILED(hr))
                    {
                    // display an error, but keep trying to import the other folders
                    LoadString(g_hInstImp, idsFolderImportErrorFmt, szFmt, ARRAYSIZE(szFmt));
                    wsprintf(szError, szFmt, pnode->szName);
                    ImpErrorMessage(hwnd, MAKEINTRESOURCE(idsImportTitle), szError, hr);
                    }
                }
            }

        if (pnode->pchild != NULL)
            {
            hr = ImportFolders(hwnd, pImporter, pMailImp, pnode->pchild, pImpProg);
            if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
                return(hr);
            }

        pnode = pnode->pnext;
        }

    return(S_OK);
    }

void ImpErrorMessage(HWND hwnd, LPTSTR szTitle, LPTSTR szError, HRESULT hrDetail)
    {
    LPTSTR szDetail;

    Assert(FAILED(hrDetail));

    switch (hrDetail)
        {
        case E_OUTOFMEMORY:
            szDetail = MAKEINTRESOURCE(idsMemory);
            break;

        case hrDiskFull:
            szDetail = MAKEINTRESOURCE(idsDiskFull);
            break;

        case hrNoProfilesFound:
        case hrMapiInitFail:
            szDetail = MAKEINTRESOURCE(idsMAPIInitError);
            break;

        case hrFolderOpenFail:
            szDetail = MAKEINTRESOURCE(idsFolderOpenFail);
            break;

        case hrFolderReadFail:
            szDetail = MAKEINTRESOURCE(idsFolderReadFail);
            break;

        default:
            szDetail = MAKEINTRESOURCE(idsGenericError);
            break;
        }

    ImpMessageBox(hwnd, szTitle, szError, szDetail, MB_OK | MB_ICONEXCLAMATION);
    }

int ImpMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle)
    {
    TCHAR rgchTitle[CCHMAX_STRINGRES];
    TCHAR rgchText[2 * CCHMAX_STRINGRES + 2];
    LPTSTR szText;
    int cch;

    Assert(sz1);
    Assert(szTitle != NULL);

    if (IS_INTRESOURCE(szTitle))
        {
        // its a string resource id
        cch = LoadString(g_hInstImp, PtrToUlong(szTitle), rgchTitle, CCHMAX_STRINGRES);
        if (cch == 0)
            return(0);

        szTitle = rgchTitle;
        }

    if (!(IS_INTRESOURCE(sz1)))
        {
        // its a pointer to a string
        Assert(lstrlen(sz1) < CCHMAX_STRINGRES);
        if (NULL == lstrcpy(rgchText, sz1))
            return(0);

        cch = lstrlen(rgchText);
        }
    else
        {
        // its a string resource id
        cch = LoadString(g_hInstImp, PtrToUlong(sz1), rgchText, 2 * CCHMAX_STRINGRES);
        if (cch == 0)
            return(0);
        }

    if (sz2)
        {
        //$$REVIEW is this right??
        //$$REVIEW will this work with both ANSI/UNICODE?

        // there's another string that we need to append to the
        // first string...
        szText = &rgchText[cch];
        *szText = *c_szNewline;

        szText++;
        *szText = *c_szNewline;
        szText++;

        if (!(IS_INTRESOURCE(sz2)))
            {
            // its a pointer to a string
            Assert(lstrlen(sz2) < CCHMAX_STRINGRES);
            if (NULL == lstrcpy(szText, sz2))
                return(0);
            }
        else
            {
            Assert((2 * CCHMAX_STRINGRES - (szText - rgchText)) > 0);
            if (0 == LoadString(g_hInstImp, PtrToUlong(sz2), szText, 2 * CCHMAX_STRINGRES - (int)(szText - rgchText)))
                return(0);
            }
        }

    return(MessageBox(hwndOwner, rgchText, szTitle, MB_SETFOREGROUND | fuStyle));
    }

int AutoDetectClients(MIGRATEINFO *pinfo, int cinfo)
    {
    TCHAR szDir[MAX_PATH];

    Assert(pinfo != NULL);
    Assert(cinfo >= 2);

    cinfo = 0;

    if (SUCCEEDED(GetClientDir(szDir, ARRAYSIZE(szDir), EUDORA)))
        {
        pinfo->clsid = CLSID_CEudoraImport;
        pinfo->idDisplay = idsEudora;
        pinfo->szfnImport = (TCHAR *)szEudoraImportEntryPt;
        cinfo++;
        pinfo++;
        }

    if (SUCCEEDED(GetClientDir(szDir, ARRAYSIZE(szDir), NETSCAPE)))
        {
        pinfo->clsid = CLSID_CNetscapeImport;
        pinfo->idDisplay = idsNetscape;
        pinfo->szfnImport = (TCHAR *)szNetscapeImportEntryPt;
        cinfo++;
        pinfo++;
        }

    if (SUCCEEDED(GetClientDir(szDir, ARRAYSIZE(szDir), COMMUNICATOR)))
        {
        pinfo->clsid = CLSID_CCommunicatorImport;
        pinfo->idDisplay = idsCommunicator;
        pinfo->szfnImport = (TCHAR *)szMessengerImportEntryPt;
        cinfo++;
        pinfo++;
        }

    if (SUCCEEDED(ExchInit()) && SUCCEEDED(MapiLogon(NULL, NULL)))
        {
        pinfo->clsid = CLSID_CExchImport;
        pinfo->idDisplay = idsExchange;
        pinfo->szfnImport = (TCHAR *)szPABImportEntryPt;
        cinfo++;
        pinfo++;
        }

    return(cinfo);
    }

HRESULT PerformMigration(HWND hwnd, IMailImporter *pImporter, DWORD dwFlags)
    {
    HRESULT hr;
    MIGRATEINFO info[4];
    IMPWIZINFO wizinfo;

    Assert(pImporter != NULL);

    hr = S_OK;

    ZeroMemory(&wizinfo, sizeof(IMPWIZINFO));
    wizinfo.pImporter = pImporter;

    wizinfo.cMigrate = AutoDetectClients(info, ARRAYSIZE(info));
    if (wizinfo.cMigrate > 0)
        {
        wizinfo.pMigrate = info;
        wizinfo.fMigrate = TRUE;

        hr = DoImportWizard(hwnd, &wizinfo);
        }

    if (wizinfo.pClsid != NULL)
        MemFree(wizinfo.pClsid);

    if (wizinfo.pList != NULL)
        FreeFolderList(wizinfo.pList);

    if (wizinfo.pImport != NULL)
        wizinfo.pImport->Release();

    ExchDeinit();

    return(hr);
    }

int CALLBACK PropSheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    DLGTEMPLATE *pDlg;

    if (uMsg == PSCB_PRECREATE)
    {
        pDlg = (DLGTEMPLATE *)lParam;
        
        if (!!(pDlg->style & DS_CONTEXTHELP))
            pDlg->style &= ~DS_CONTEXTHELP;
    }

    return(0);
}

const static PAGEINFO g_rgPageInfo[NUM_WIZARD_PAGES] =
{
	{ iddMigrate,           idsMigrate,         MigrateInitProc,    MigrateOKProc,       NULL },
	{ iddMigrateMode,       idsMigrate,         MigModeInitProc,    MigModeOKProc,       NULL },
	{ iddMigrateIncomplete, idsMigIncomplete,   MigIncInitProc,     MigIncOKProc,        NULL },
	{ iddSelectClient,      idsSelectClient,    ClientInitProc,     ClientOKProc,        NULL },
	{ iddLocation,          idsLocation,        LocationInitProc,   LocationOKProc,      LocationCmdProc },
	{ iddSelectFolders,     idsSelectFoldersHdr,FolderInitProc,     FolderOKProc,        NULL },
	{ iddAddressComplete,   idsAddressComplete, NULL,               AddressOKProc,       NULL },
    { iddCongratulations,   idsCongratulations, CongratInitProc,    CongratOKProc,       NULL }
};

HRESULT DoImportWizard(HWND hwnd, IMPWIZINFO *pinfo)
    {
    int nPageIndex, cPages, iRet;
	PROPSHEETPAGE psPage;
	PROPSHEETHEADER psHeader;
	HRESULT hr;
    char sz[CCHMAX_STRINGRES];
    HPROPSHEETPAGE rgPage[NUM_WIZARD_PAGES];
    INITWIZINFO rgInit[NUM_WIZARD_PAGES];

    Assert(pinfo != NULL);

	ZeroMemory(&psPage, sizeof(PROPSHEETPAGE));
	ZeroMemory(&psHeader, sizeof(PROPSHEETHEADER));

	psPage.dwSize = sizeof(psPage);
	psPage.dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE;
	psPage.hInstance = g_hInstImp;
	psPage.pfnDlgProc = GenDlgProc;

    hr = S_OK;

    cPages = 0;

	// create a property sheet page for each page in the wizard
    for (nPageIndex = pinfo->fMigrate ? 0 : 3; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++)
	    {
        rgInit[cPages].pPageInfo = &g_rgPageInfo[nPageIndex];
        rgInit[cPages].pWizInfo = pinfo;
		psPage.lParam = (LPARAM)&rgInit[cPages];
		psPage.pszTemplate = MAKEINTRESOURCE(g_rgPageInfo[nPageIndex].uDlgID);
        LoadString(g_hInstImp, g_rgPageInfo[nPageIndex].uHdrID, sz, ARRAYSIZE(sz));
        psPage.pszHeaderTitle = sz;

		rgPage[cPages] = CreatePropertySheetPage(&psPage);
		if (rgPage[cPages] == NULL)
            {
            hr = E_FAIL;
            break;
            }
        cPages++;
		}

    if (!FAILED(hr))
        {
        psHeader.dwSize = sizeof(PROPSHEETHEADER);
        psHeader.dwFlags = PSH_WIZARD97 | PSH_HEADER | PSH_WATERMARK | PSH_USECALLBACK;
        psHeader.hwndParent = hwnd;
        psHeader.hInstance = g_hInstImp;
        psHeader.nPages = cPages;
        psHeader.phpage = rgPage;
        psHeader.pszbmWatermark = MAKEINTRESOURCE(idbGlobe);
        psHeader.pszbmHeader = 0;
        psHeader.pfnCallback = PropSheetProc;

        iRet = (int) PropertySheet(&psHeader);
        if (iRet == -1)
            hr = E_FAIL;
        else if (iRet == 0)
            hr = S_FALSE;
        else
            hr = S_OK;
        }
    else
        {
	    for (nPageIndex = 0; nPageIndex < cPages; nPageIndex++)
	        {
            if (rgPage[nPageIndex] != NULL)
		        DestroyPropertySheetPage(rgPage[nPageIndex]);
	        }
        }

	return(hr);
    }

/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:    back and next buttons enabled
          next btn:  switches to page following current page
          back btn:  switches to previous page
          cancel btn: prompts user to confirm, and cancels the wizard
          dlg ctrl:   does nothing (in response to WM_COMMANDs)
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
    INITWIZINFO *pInit;
    IMPWIZINFO *pWizInfo;
    BOOL fRet, fKeepHistory, fCancel;
    HWND hwndParent;
    LPPROPSHEETPAGE lpsp;
    const PAGEINFO *pPageInfo;
    NMHDR *lpnm;
    NMLISTVIEW *lpnmlv;
    UINT idPage;

    fRet = TRUE;
    hwndParent = GetParent(hDlg);

    switch (uMsg)
        {
        case WM_INITDIALOG:
            // get propsheet page struct passed in
            lpsp = (LPPROPSHEETPAGE)lParam;
            Assert(lpsp != NULL);

            // fetch our private page info from propsheet struct
            pInit = (INITWIZINFO *)lpsp->lParam;
            Assert(pInit != NULL);

            pWizInfo = pInit->pWizInfo;
            Assert(pWizInfo != NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pWizInfo);

            pPageInfo = pInit->pPageInfo;
            Assert(pPageInfo != NULL);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pPageInfo);

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc != NULL)
                {
                if (!pPageInfo->InitProc(pWizInfo, hDlg, TRUE))
                    {
                    // send a 'cancel' message to ourselves
                    // TODO: handle this
                    Assert(FALSE);
                    }
                }
            break;

        case WM_ENABLENEXT:
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (BOOL)wParam);
            break;

        case WM_POSTSETFOCUS:
            SetFocus((HWND)wParam);
            break;

        case WM_NOTIFY:
            pWizInfo = (IMPWIZINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pWizInfo != NULL);

            pPageInfo = (const PAGEINFO *)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            Assert(pPageInfo != NULL);

            lpnm = (NMHDR *)lParam;

            switch (lpnm->code)
                {
                case PSN_SETACTIVE:
                    // initialize 'back' and 'next' wizard buttons, if
                    // page wants something different it can fix in init proc below
                    PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT | PSWIZB_BACK);

                    // call init proc for this page if one is specified
                    if (pPageInfo->InitProc != NULL)
                        {
                        // TODO: what about the return value for this????
                        pPageInfo->InitProc(pWizInfo, hDlg, FALSE);
                        }

                    pWizInfo->idCurrentPage = pPageInfo->uDlgID;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    Assert((ULONG)pWizInfo->idCurrentPage == pPageInfo->uDlgID);

                    fKeepHistory = TRUE;
                    idPage = 0;

                    Assert(pPageInfo->OKProc != NULL) ;

                    if (!pPageInfo->OKProc(pWizInfo, hDlg, (lpnm->code != PSN_WIZBACK), &idPage, &fKeepHistory))
                        {
                        // stay on this page
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                        break;
                        }

                    if (lpnm->code != PSN_WIZBACK)
                        {
                        // 'next' pressed
                        Assert(pWizInfo->cPagesCompleted < NUM_WIZARD_PAGES);

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if (fKeepHistory)
                            {
                            pWizInfo->rgHistory[pWizInfo->cPagesCompleted] = pWizInfo->idCurrentPage;
                            pWizInfo->cPagesCompleted++;
                            }
                        }
                    else
                        {
                        // 'back' pressed
                        Assert(pWizInfo->cPagesCompleted > 0);

                        // get the last page from the history list
                        pWizInfo->cPagesCompleted--;
                        idPage = pWizInfo->rgHistory[pWizInfo->cPagesCompleted];
                        }

                    // set next page, only if 'next' or 'back' button was pressed
                    if (lpnm->code != PSN_WIZFINISH)
                        {
                        // tell the prop sheet mgr what the next page to display is
                        Assert(idPage != 0);
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, idPage);
                        }
                    break;

                case PSN_QUERYCANCEL:
                    if (IDNO == ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle), MAKEINTRESOURCE(idsCancelWizard), NULL, MB_YESNO|MB_ICONEXCLAMATION |MB_DEFBUTTON2))
                        {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        }
                    break;

                case LVN_ITEMCHANGED:
                    if (lpnm->idFrom == IDC_IMPFOLDER_LISTVIEW &&
                        ((NMLISTVIEW *)lpnm)->iItem != -1)
                    {
                        SendDlgItemMessage(hDlg, IDC_IMPORTALL_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
                        SendDlgItemMessage(hDlg, IDC_SELECT_RADIO, BM_SETCHECK, BST_CHECKED, 0);
                    }
                    break;
                }
            break;

        case WM_COMMAND:
            pWizInfo = (IMPWIZINFO *)GetWindowLongPtr(hDlg, DWLP_USER);
            Assert(pWizInfo != NULL);

            pPageInfo = (const PAGEINFO *)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            Assert(pPageInfo != NULL);

            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc != NULL)
                {
                pPageInfo->CmdProc(pWizInfo, hDlg, wParam, lParam);
                }
            break;

        default:
            fRet = FALSE;
            break;
        }

    return(fRet);
    }

BOOL CALLBACK MigrateInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
{
    HWND hwnd;
    TCHAR sz[CCHMAX_STRINGRES];
    UINT idx, i;

    Assert(pInfo != NULL);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);

    if (fFirstInit)
    {
        pInfo->iMigrate = -1;

        SendDlgItemMessage(hDlg, IDC_IMPORT_RADIO, BM_SETCHECK, BST_CHECKED, 0);

        hwnd = GetDlgItem(hDlg, idcClientsListbox);

        Assert(pInfo->cMigrate > 0);
        for (i = 0; i < pInfo->cMigrate; i++)
        {
            LoadString(g_hInstImp, pInfo->pMigrate[i].idDisplay, sz, ARRAYSIZE(sz));
            idx = (int) SendMessage(hwnd, LB_ADDSTRING, 0, (LPARAM)sz);
            SendMessage(hwnd, LB_SETITEMDATA, (WPARAM)idx, (LPARAM)i);
        }
        SendMessage(hwnd, LB_SETCURSEL, 0, 0);
    }

    return(TRUE);
}

BOOL CALLBACK MigrateOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *fKeepHistory)
{
    UINT idx;
    HWND hwnd;
    HRESULT hr;
    IMPFOLDERNODE *pnode;
    IMailImport *pMailImp;

    Assert(pInfo != NULL);

    if (fForward)
    {
        if (SendDlgItemMessage(hDlg, IDC_NO_IMPORT_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
        {
            *puNextPage = iddMigrateIncomplete;
            return(TRUE);
        }

        hwnd = GetDlgItem(hDlg, idcClientsListbox);

        idx = (int) SendMessage(hwnd, LB_GETCURSEL, 0, 0);

        if (SendMessage(hwnd, LB_GETTEXTLEN, idx, 0) < CCHMAX_STRINGRES)
            SendMessage(hwnd, LB_GETTEXT, idx, (LPARAM)pInfo->szClient);  // save selected client name
        else
            *pInfo->szClient = 0;

        idx = (int) SendMessage(hwnd, LB_GETITEMDATA, (WPARAM)idx, 0);

        if (idx != pInfo->iMigrate)
        {
            pInfo->dwReload = PAGE_ALL;

            pInfo->iMigrate = idx;
            if (pInfo->pImport != NULL)
            {
                pInfo->pImport->Release();
                pInfo->pImport = NULL;
            }
        }

        *puNextPage = iddMigrateMode;
    }

    return(TRUE);
}

BOOL CALLBACK MigModeInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd;
    TCHAR sz[CCHMAX_STRINGRES];
    UINT idx, i;

    Assert(pInfo != NULL);

    if (fFirstInit || !!(pInfo->dwReload & PAGE_MODE))
        {
        SendDlgItemMessage(hDlg, IDC_MSGS_AB_RADIO, BM_SETCHECK, BST_CHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_MSGS_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_AB_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);

        pInfo->dwReload &= ~PAGE_MODE;
        }

    return(TRUE);
    }

BOOL CALLBACK MigModeOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *fKeepHistory)
{
    HWND hwnd;
    HRESULT hr;
    IMPFOLDERNODE *pnode;
    IMailImport *pMailImp;

    Assert(pInfo != NULL);

    if (fForward)
    {
        if (SendDlgItemMessage(hDlg, IDC_MSGS_AB_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
        {
            pInfo->fMessages = TRUE;
            pInfo->fAddresses = TRUE;
        }
        else if (SendDlgItemMessage(hDlg, IDC_MSGS_RADIO, BM_GETCHECK, 0, 0) == BST_CHECKED)
        {
            pInfo->fMessages = TRUE;
            pInfo->fAddresses = FALSE;
        }
        else
        {
            pInfo->fMessages = FALSE;
            pInfo->fAddresses = TRUE;
        }
        
        pMailImp = NULL;

        if (!pInfo->fMessages)
        {
            if (pInfo->pImport != NULL)
            {
                pInfo->pImport->Release();
                pInfo->pImport = NULL;
            }

            *puNextPage = iddAddressComplete;
        }
        else if (pInfo->pImport == NULL)
        {
            hr = CoCreateInstance(pInfo->pMigrate[pInfo->iMigrate].clsid, NULL, CLSCTX_INPROC_SERVER, IID_IMailImport, (void **)&pMailImp);
            if (SUCCEEDED(hr))
            {
                Assert(pMailImp != NULL);

                hr = pMailImp->InitializeImport(GetParent(hDlg));
                if (hr == S_OK)
                {
                    hr = pMailImp->GetDirectory(pInfo->szDir, ARRAYSIZE(pInfo->szDir));
                    if (hr == S_FALSE)
                    {
                        hr = GetFolderList(pMailImp, &pnode);
                        if (FAILED(hr) || pnode == NULL)
                        {
                            // TODO: error message
                            pMailImp->Release();
                            return(FALSE);
                        }

                        if (pInfo->pList != NULL)
                            FreeFolderList(pInfo->pList);
                        pInfo->pList = pnode;

                        pInfo->fLocation = FALSE;
                    }
                    else
                    {
                        pInfo->fLocation = TRUE;
                    }
                }
                else
                {
                    pMailImp->Release();
                    return(FALSE);
                }

                pInfo->dwReload = PAGE_LOCATION | PAGE_FOLDERS;

                pInfo->pImport = pMailImp;

                *puNextPage = pInfo->fLocation ? iddLocation : iddSelectFolders;
            }
        }
        else
        {
            *puNextPage = pInfo->fLocation ? iddLocation : iddSelectFolders;
        }
    }

    return(TRUE);
}

BOOL CALLBACK MigIncInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
{
    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH | PSWIZB_BACK);
    
    return(TRUE);
}

BOOL CALLBACK MigIncOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
{
    return(TRUE);
}

#define CCLSIDBUF   16

void InitListView(HWND hwndList, IMPWIZINFO *pinfo)
    {
    DWORD dwIndex, dwGuid, dwName;
    TCHAR szName[MAX_PATH], szGuid[MAX_PATH], szDisp[16];
    HKEY hkey, hkeyT;
    HRESULT hr;
    FILETIME ft;
    UINT i, index, iClsid;
    LPWSTR pwszCLSID;

    Assert(pinfo != NULL);
    Assert(pinfo->pClsid == NULL);

    iClsid = 0;
    pinfo->cClsid = CCLSIDBUF;

    if (!MemAlloc((void **)&pinfo->pClsid, sizeof(CLSID) * pinfo->cClsid))
        return;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegImport,
                            0, KEY_READ, &hkey))
        {
        dwIndex = 0;

        dwGuid = ARRAYSIZE(szGuid);
        while (ERROR_SUCCESS == RegEnumKeyEx(hkey, dwIndex, szGuid, &dwGuid,
                                    NULL, NULL, NULL, &ft))
            {
            if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szGuid, 0, KEY_READ, &hkeyT))
                {
                for (i = 1; i <= 9; i++)
                    {
                    wsprintf(szDisp, c_szDispFmt, i);
                    dwName = sizeof(szName);
                    if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, szDisp, NULL, NULL,
                                            (LPBYTE)szName, &dwName))
                        {
                        Assert(iClsid < pinfo->cClsid);
                        index = (int) SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)szName);
                        SendMessage(hwndList, LB_SETITEMDATA, (WPARAM)index, (LPARAM)iClsid);

                        // We should be doing something different here. If PszToUnicode fails,
                        // it fails because of low memory. This is an error condition, not an assert.
                        pwszCLSID = PszToUnicode(CP_ACP, szGuid);
                        Assert(pwszCLSID != NULL);

                        hr = CLSIDFromString(pwszCLSID, &pinfo->pClsid[iClsid]);
                        Assert(!FAILED(hr));

                        MemFree(pwszCLSID);

                        iClsid++;
                        }
                    else
                        {
                        break;
                        }
                    }

                RegCloseKey(hkeyT);
                }

            dwIndex++;
            dwGuid = ARRAYSIZE(szGuid);
            }

        RegCloseKey(hkey);
        }

    SendMessage(hwndList, LB_SETCURSEL, 0, 0);
    }

BOOL CALLBACK ClientInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    Assert(pInfo != NULL);

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);

    if (fFirstInit)
        {
        pInfo->iClsid = -1;

        InitListView(GetDlgItem(hDlg, idcClientsListbox), pInfo);
        }

    return(TRUE);
    }

BOOL CALLBACK ClientOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *fKeepHistory)
    {
    UINT i;
    HWND hwnd;
    HRESULT hr;
    IMPFOLDERNODE *pnode;
    IMailImport *pMailImp;

    Assert(pInfo != NULL);

    if (fForward)
        {
        pInfo->fMessages = TRUE;
        pInfo->fAddresses = FALSE;

        hwnd = GetDlgItem(hDlg, idcClientsListbox);

        i = (int) SendMessage(hwnd, LB_GETCURSEL, 0, 0);

        if (SendMessage(hwnd, LB_GETTEXTLEN, i, 0) < CCHMAX_STRINGRES)
            SendMessage(hwnd, LB_GETTEXT, i, (LPARAM)pInfo->szClient);  // save selected client name
        else
            *pInfo->szClient = 0;

        i = (int) SendMessage(hwnd, LB_GETITEMDATA, (WPARAM)i, 0);

        Assert(((int) i) >= 0 && i < pInfo->cClsid);

        if (i != pInfo->iClsid)
            {
            hr = CoCreateInstance(pInfo->pClsid[i], NULL, CLSCTX_INPROC_SERVER, IID_IMailImport, (void **)&pMailImp);
            if (FAILED(hr))
                {
                // TODO: error message
                return(FALSE);
                }

            Assert(pMailImp != NULL);

            hr = pMailImp->InitializeImport(GetParent(hDlg));
            if (hr == S_OK)
                {
                hr = pMailImp->GetDirectory(pInfo->szDir, ARRAYSIZE(pInfo->szDir));
                if (hr == S_FALSE)
                    {
                    hr = GetFolderList(pMailImp, &pnode);
                    if (FAILED(hr) || pnode == NULL)
                        {
                        // TODO: error message
                        pMailImp->Release();
                        return(FALSE);
                        }

                    if (pInfo->pList != NULL)
                        FreeFolderList(pInfo->pList);
                    pInfo->pList = pnode;

                    pInfo->fLocation = FALSE;
                    }
                else
                    {
                    pInfo->fLocation = TRUE;
                    }
                }
            else
                {
                pMailImp->Release();
                return(FALSE);
                }

            pInfo->dwReload = PAGE_ALL;

            if (pInfo->pImport != NULL)
                pInfo->pImport->Release();

            pInfo->iClsid = i;
            pInfo->pImport = pMailImp;
            }

        *puNextPage = pInfo->fLocation ? iddLocation : iddSelectFolders;
        }

    return(TRUE);
    }

BOOL CALLBACK LocationInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwnd;
    DWORD cbSize;
    TCHAR sz[CCHMAX_STRINGRES];

    Assert(pInfo != NULL);
    
    hwnd = GetDlgItem(hDlg, IDC_IMPFOLDER_EDIT);

    if (fFirstInit || !!(pInfo->dwReload & PAGE_LOCATION))
        {
        if (*pInfo->szDir == 0)
            {
            LoadString(g_hInstImp, idsLocationUnknown, sz, ARRAYSIZE(sz));
            SetDlgItemText(hDlg, IDC_LOCATION_STATIC, sz);
            }

        if (pInfo->pList != NULL)
            {
            FreeFolderList(pInfo->pList);
            pInfo->pList = NULL;
            }

        SetWindowText(hwnd, pInfo->szDir);

        pInfo->dwReload &= ~PAGE_LOCATION;
        }

    cbSize = GetWindowText(hwnd, sz, ARRAYSIZE(sz));
    UlStripWhitespace(sz, TRUE, TRUE, &cbSize);
    PostMessage(hDlg, WM_ENABLENEXT, (WPARAM)(cbSize != 0), 0);

    return(TRUE);
    }

BOOL CALLBACK LocationOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
    {
    IMPFOLDERNODE *pnode;
    HRESULT hr;
    TCHAR sz[MAX_PATH];

    Assert(pInfo != NULL);

    if (fForward)
        {
        GetDlgItemText(hDlg, IDC_IMPFOLDER_EDIT, sz, ARRAYSIZE(sz));

        if (*sz == 0)
            {
            ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                MAKEINTRESOURCE(idsLocationInvalid), NULL,
                MB_OK | MB_ICONSTOP);

            return(FALSE);
            }

        if (0 != lstrcmpi(sz, pInfo->szDir) || pInfo->pList == NULL)
            {
            hr = pInfo->pImport->SetDirectory(sz);
            if (hr == S_FALSE)
                {
                ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                    MAKEINTRESOURCE(idsLocationInvalid), NULL,
                    MB_OK | MB_ICONSTOP);

                return(FALSE);
                }

            Assert(hr == S_OK);

            pnode = NULL;
            hr = GetFolderList(pInfo->pImport, &pnode);
            if (FAILED(hr) || pnode == NULL)
                {
                ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                    MAKEINTRESOURCE(idsLocationInvalid), NULL,
                    MB_OK | MB_ICONSTOP);

                return(FALSE);
                }

            pInfo->dwReload |= PAGE_FOLDERS;

            if (pInfo->pList != NULL)
                FreeFolderList(pInfo->pList);

            pInfo->pList = pnode;
            lstrcpy(pInfo->szDir, sz);
            }

        *puNextPage = iddSelectFolders;
        }

    return(TRUE);
    }

BOOL CALLBACK LocationCmdProc(IMPWIZINFO *pInfo, HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    DWORD cbSize;
    char szDir[MAX_PATH];
    
    Assert(pInfo != NULL);
    
    if (LOWORD(wParam) == IDC_SELECTFOLDER_BUTTON)
    {
        GetDlgItemText(hDlg, IDC_IMPFOLDER_EDIT, szDir, ARRAYSIZE(szDir));
        
        hr = DispDialog(hDlg, szDir, ARRAYSIZE(szDir));
        if (hr == S_OK)
        {
            cbSize = lstrlen(szDir);
            UlStripWhitespace(szDir, TRUE, TRUE, &cbSize);
            SetDlgItemText(hDlg, IDC_IMPFOLDER_EDIT, szDir);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDD_NEXT), (cbSize != 0));
        }
    }
    
    return(TRUE);
}

BOOL CALLBACK FolderInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
    {
    HWND hwndList;

    Assert(pInfo != NULL);
    Assert(pInfo->pList != NULL);

    if (fFirstInit || !!(pInfo->dwReload & PAGE_FOLDERS))
        {
        Assert(pInfo->pList != NULL);

        SendDlgItemMessage(hDlg, IDC_IMPORTALL_RADIO, BM_SETCHECK, BST_CHECKED, 0);
        SendDlgItemMessage(hDlg, IDC_SELECT_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);

        hwndList = GetDlgItem(hDlg, IDC_IMPFOLDER_LISTVIEW);

        if (fFirstInit)
            InitListViewImages(hwndList);

        ListView_DeleteAllItems(hwndList);
        FillFolderListview(hwndList, pInfo->pList, (DWORD_PTR)INVALID_FOLDER_HANDLE);

        pInfo->dwReload &= ~PAGE_FOLDERS;
        }

    return(TRUE);
    }

BOOL CALLBACK FolderOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
    {
    BOOL fSel;
    LV_ITEM lvi;
    int ili;
    IMPFOLDERNODE *pnode;
    HWND hwndList;
    CFolderImportProg *pImpProg;
    HRESULT hr;

    Assert(pInfo != NULL);

    if (fForward)
        {
        fSel = (BST_CHECKED == SendDlgItemMessage(hDlg, IDC_SELECT_RADIO, BM_GETCHECK, 0, 0));
        hwndList = GetDlgItem(hDlg, IDC_IMPFOLDER_LISTVIEW);

        if (fSel && 0 == SendMessage(hwndList, LVM_GETSELECTEDCOUNT, 0, 0))
            {
            ImpMessageBox(hDlg, MAKEINTRESOURCE(idsImportTitle),
                MAKEINTRESOURCE(idsSelectFolders), NULL,
                MB_OK | MB_ICONSTOP);

            return(FALSE);
            }

        lvi.mask = LVIF_PARAM;
        lvi.iSubItem = 0;

        ili = -1;

        // First clear all state from possible previous imports. Bug; #
        if(fSel)
            {
            while (-1 != (ili = ListView_GetNextItem(hwndList, ili, 0)))
                {
                lvi.iItem = ili;
                ListView_GetItem(hwndList, &lvi);

                pnode = (IMPFOLDERNODE *)lvi.lParam;
                Assert(pnode != NULL);
                pnode->fImport = FALSE;
                }
            }

        ili = -1;
        while (-1 != (ili = ListView_GetNextItem(hwndList, ili, fSel ? LVNI_SELECTED : 0)))
            {
            lvi.iItem = ili;
            ListView_GetItem(hwndList, &lvi);

            pnode = (IMPFOLDERNODE *)lvi.lParam;
            Assert(pnode != NULL);
            pnode->fImport = TRUE;
            }

        // TODO: error handling...

        pImpProg = new CFolderImportProg;
        if (pImpProg == NULL)
            {
            hr = E_OUTOFMEMORY;
            }
        else
            {
            hr = pImpProg->Initialize(GetParent(hDlg));
            if (!FAILED(hr))
                {
                Assert(pInfo->fMessages || pInfo->fAddresses);
                if (pInfo->fMessages)
                    {
                    hr = ImportFolders(hDlg, pInfo->pImporter, pInfo->pImport, pInfo->pList, pImpProg);
                    if (hr == hrUserCancel)
                        goto FoldDone;
                    else if (FAILED(hr))
                        ImpErrorMessage(hDlg, MAKEINTRESOURCE(idsImportTitle), MAKEINTRESOURCE(idsErrImport), hr);
                    }

                if (pInfo->fAddresses)
                    {
                    Assert(pInfo->pMigrate != NULL);
                    if (pInfo->pMigrate[pInfo->iMigrate].szfnImport != NULL)
                        HrImportAB(hDlg, pInfo->pMigrate[pInfo->iMigrate].szfnImport);
                    }
                }

FoldDone:
            pImpProg->Release();

            *puNextPage = iddCongratulations;
            }
        }

    return(TRUE);
    }

BOOL CALLBACK AddressOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
    {
    CFolderImportProg *pImpProg;
    HRESULT hr;

    Assert(pInfo != NULL);
    Assert(!pInfo->fMessages && pInfo->fAddresses);

    if (fForward)
        {
        // TODO: error handling...

        pImpProg = new CFolderImportProg;
        if (pImpProg == NULL)
            {
            hr = E_OUTOFMEMORY;
            }
        else
            {
            hr = pImpProg->Initialize(hDlg);
            if (!FAILED(hr))
                {
                Assert(pInfo->pMigrate != NULL);
                HrImportAB(hDlg, pInfo->pMigrate[pInfo->iMigrate].szfnImport);
                }

            pImpProg->Release();

            *puNextPage = iddCongratulations;
            }
        }

    return(TRUE);
    }

BOOL CALLBACK CongratInitProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fFirstInit)
{
    TCHAR sz[CCHMAX_STRINGRES*2];
    TCHAR szFmt[CCHMAX_STRINGRES];
    
    LoadString(g_hInstImp, idsCongratStr, szFmt, ARRAYSIZE(szFmt));
    wsprintf(sz, szFmt, pInfo->szClient);
    SetDlgItemText(hDlg, idcStatic1, sz);
    
    if (fFirstInit)
    {
        if (!pInfo->fMigrate)
            ShowWindow(GetDlgItem(hDlg, idcStatic2), SW_HIDE);
    }

    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);
    PropSheet_CancelToClose(GetParent(hDlg));
    
    return(TRUE);
}

BOOL CALLBACK CongratOKProc(IMPWIZINFO *pInfo, HWND hDlg, BOOL fForward, UINT *puNextPage, BOOL *pfKeepHistory)
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\import.h ===
#ifndef _INC_IMPORT_H
#define _INC_IMPORT_H

interface IMAPISession;
#include "resource.h"
#include "impdlg.h" 

extern HINSTANCE        g_hInstImp;

#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

HRESULT ExchInit(void);
void ExchDeinit(void);
HRESULT MapiLogon(HWND hwnd, IMAPISession **ppmapi);

LPMAPICONTAINER OpenDefaultStoreContainer(HWND hwnd, IMAPISession *pmapi);
LPSPropValue PvalFind(LPSRow prw, ULONG ulPropTag);
void FreeSRowSet(LPSRowSet prws);

void ImpErrorMessage(HWND hwnd, LPTSTR szTitle, LPTSTR szError, HRESULT hrDetail);
int ImpMessageBox(HWND hwndOwner, LPTSTR szTitle, LPTSTR sz1, LPTSTR sz2, UINT fuStyle);

void InitListViewImages(HWND hwnd);
void FillFolderListview(HWND hwnd, IMPFOLDERNODE *plist, DWORD_PTR dwReserved);

class CImpProgress
    {
    private:
        ULONG       m_cRef;
        ULONG       m_cMax;
        ULONG       m_cCur;
        ULONG       m_cPerCur;
        HWND        m_hwndProgress;
        HWND        m_hwndDlg;
        HWND        m_hwndOwner;
        BOOL        m_fCanCancel;
        BOOL        m_fHasCancel;

    public:
        CImpProgress ();
        ~CImpProgress ();

        ULONG AddRef ();
        ULONG Release ();

        VOID SetMsg(LPTSTR lpszMsg, int id);
        VOID SetTitle(LPTSTR lpszTitle);
        VOID Show (DWORD dwDelaySeconds=0);
        VOID Hide (VOID);
        VOID Close (VOID);
        VOID AdjustMax(ULONG cNewMax);
        VOID Reset(VOID);
        HRESULT HrUpdate (ULONG cInc);
        static INT_PTR CALLBACK ProgressDlgProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        VOID Init (HWND hwndParent, BOOL fCanCancel);
    };

#define WM_POSTSETFOCUS (WM_USER + 1)
#define WM_ENABLENEXT   (WM_USER + 2)

typedef struct tagIMPWIZINFO IMPWIZINFO;

INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL CALLBACK MigrateInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK MigrateOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK MigModeInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK MigModeOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK MigIncInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK MigIncOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK ClientInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK ClientOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK LocationInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK LocationOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);
BOOL CALLBACK LocationCmdProc(IMPWIZINFO *,HWND,WPARAM,LPARAM);

BOOL CALLBACK FolderInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK FolderOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK AddressOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

BOOL CALLBACK CongratInitProc(IMPWIZINFO *,HWND,BOOL);
BOOL CALLBACK CongratOKProc(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);

typedef BOOL (CALLBACK* INITPROC)(IMPWIZINFO *,HWND,BOOL);
typedef BOOL (CALLBACK* OKPROC)(IMPWIZINFO *,HWND,BOOL,UINT *,BOOL *);
typedef BOOL (CALLBACK* CMDPROC)(IMPWIZINFO *,HWND,WPARAM,LPARAM);

typedef struct tagPAGEINFO
    {
    UINT        uDlgID;
    UINT        uHdrID;
    
    // handler procedures for each page-- any of these can be
    // NULL in which case the default behavior is used
    INITPROC    InitProc;
    OKPROC      OKProc;
    CMDPROC     CmdProc;
    } PAGEINFO;

#define NUM_WIZARD_PAGES    8

typedef struct tagMIGRATEINFO
    {
    CLSID clsid;
    UINT idDisplay;
    char *szfnImport;
    } MIGRATEINFO;

#define PAGE_LOCATION   0x0001
#define PAGE_FOLDERS    0x0002
#define PAGE_MODE       0x0004
#define PAGE_ALL        0x0007

typedef struct tagIMPWIZINFO
    {
    IMailImporter *pImporter;

    BOOL dwReload;

    BOOL fMigrate;
    BOOL fMessages;
    BOOL fAddresses;
    MIGRATEINFO *pMigrate;
    UINT cMigrate;
    UINT iMigrate;

    CLSID *pClsid;
    UINT cClsid;
    UINT iClsid;

    BOOL fLocation;
    char szDir[MAX_PATH];
    IMPFOLDERNODE *pList;
    char szClient[CCHMAX_STRINGRES];

    UINT cPagesCompleted;
    UINT idCurrentPage;
    UINT rgHistory[NUM_WIZARD_PAGES];

    IMailImport *pImport;
    } IMPWIZINFO;

typedef struct tagINITWIZINFO
    {
    const PAGEINFO *pPageInfo;
    IMPWIZINFO *pWizInfo;
    } INITWIZINFO;

#endif // _INC_IMPORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\newdel.h ===
// --------------------------------------------------------------------------------
// Override new  and delete operator
// --------------------------------------------------------------------------------
#ifndef __NEWDEL_
#define __NEWDEL_

#ifdef DEBUG
extern ULONG    g_cObjectNew;
extern ULONG    g_cObjectDel;
#endif

#endif // __NEWDEL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\strconst.h ===
/*
*    strconst.h
*    
*    History:
*      Feb '98: Created.
*    
*    Copyright (C) Microsoft Corp. 1998
*
*   Non-localizeable strings for use by the importer
*/

#ifndef _STRCONST_H
#define _STRCONST_H

#ifndef WIN16
#ifdef DEFINE_STRING_CONSTANTS
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y
#else
#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif
#endif

//  ----------------------------------- FILES ------------------------------------
//  ********* DLLS
STR_GLOBAL(szImportDll,                 "wabimp.dll");
STR_GLOBAL(c_szMainDll,		            "msoe.dll");


//  ********* Program specific Reg, INI and File info
//  -- OE
STR_GLOBAL(c_szRegImport,		        "Software\\Microsoft\\Outlook Express\\Import");

//  -- WAB
STR_GLOBAL(lpszWABDLLRegPathKey,		"Software\\Microsoft\\WAB\\DLLPath");

//  -- Navigator
STR_GLOBAL(c_szNetscapeKey,		        "SOFTWARE\\Netscape\\Netscape Navigator\\Mail");
STR_GLOBAL(c_szMailDirectory,		    "Mail Directory");
STR_GLOBAL(c_szSnmExt,		            "*.snm");
STR_GLOBAL(c_szNetscape,		        "Netscape");
STR_GLOBAL(c_szIni,		                "ini");
STR_GLOBAL(c_szMail,		            "Mail");
STR_GLOBAL(c_szScriptFile,		        "\\prefs.js");
STR_GLOBAL(c_szUserPref,		        "user_pref(\"mail.directory\"");

//  -- Eudora
STR_GLOBAL(c_szEudoraKey,		        "SOFTWARE\\Microsoft\\windows\\CurrentVersion\\App Paths\\Eudora.exe");
STR_GLOBAL(c_szEudoraCommand,		    "SOFTWARE\\Qualcomm\\Eudora\\CommandLine");
STR_GLOBAL(c_szCurrent,		            "current");
STR_GLOBAL(c_szDescmapPce,		        "descmap.pce");

//  -- function names
STR_GLOBAL(szWabOpen,                   "WABOpen");
STR_GLOBAL(szNetscapeImportEntryPt,     "NetscapeImport");
STR_GLOBAL(szEudoraImportEntryPt,       "EudoraImport");
STR_GLOBAL(szPABImportEntryPt,          "PABImport");
STR_GLOBAL(szMessengerImportEntryPt,    "MessengerImport");

//  ********* General Strings
STR_GLOBAL(c_szSpace,		            " ");
STR_GLOBAL(c_szEmpty,		            "");
STR_GLOBAL(c_szNewline,		            "\n");
STR_GLOBAL(c_szDispFmt,		            "Display%1d");
STR_GLOBAL(c_szMicrosoftOutlook,        "Microsoft Outlook");
STR_GLOBAL(c_szRegOutlook,              "Software\\Clients\\Mail\\Microsoft Outlook");
STR_GLOBAL(c_szRegMail,                 "Software\\Clients\\Mail");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\athena16\ath16imp.h ===
#define hrNoMessages 780

#define start						0
#define MessageID					start
#define XMAPIMessageFlags			start+1
#define XMAPIDeleteAfterSubmit		start+2
#define XMAPISentMailEntryID		start+3
#define XMAPIReadReceipt			start+4
#define XMAPIDeliveryReceipt		start+5
#define Priority					start+6
#define To							start+7
#define MIMEVersion					start+8
#define From						start+9
#define Subject						start+10
#define Date						start+11
#define ContentType					start+12
#define ContentTransferEncoding	    start+13
#define ReturnPath					start+14
#define Received					start+15
#define ReplyTo						start+16
#define Cc							start+17
#define MsgBody						start+18


typedef struct tagzMsgHeader
{
	char ver;
	ULONG TotalMessages;
	ULONG ulTotalUnread;
}MsgHeader;

HRESULT AthInit(HWND hwnd);	
void AthDeinit();
void AthFreeFolderList(IMPFOLDERNODE *pnode);
HRESULT AthGetFolderList(HWND hwnd, IMPFOLDERNODE **pplist);
HRESULT AthImportFolder(HWND hwnd, HANDLE hnd, LPARAM lparam);

HRESULT GetAthInstallPath(HWND hwnd,LPTSTR szInstallPath);
HRESULT GetAthSubFolderList(LPTSTR szInstallPath, IMPFOLDERNODE **ppList, IMPFOLDERNODE *);
void GetNewRecurseFolder(LPTSTR szInstallPath, LPTSTR szDir, LPTSTR szInstallNewPath);

HRESULT ProcessMessages(HANDLE hnd,LPTSTR szFileName);
HANDLE OpenMsgFile(LPTSTR szFileName);
long GetMessageCount(HANDLE hFile);
HRESULT ProcessMsgList(HANDLE hnd,HANDLE hFile,LPTSTR szPath);
HRESULT ParseMsgBuffer(LPTSTR szmsgbuffer,LPTSTR szPath,HANDLE hnd);
HRESULT GetMsgFileName(LPTSTR szmsgbuffer,LPTSTR szfilename);
HRESULT GetDateBuffer(LPTSTR szmsgbuffer,TCHAR *szsendDate,TCHAR *szrecvDate);
HRESULT	GetFileinBuffer(HANDLE hnd,LPTSTR *szBuffer);
void CopyStringA1(TOKEN *msgToken);
HRESULT	ProcessSingleMessage(HANDLE hnd,LPTSTR szBuffer,IMSG *imsg);
HRESULT	ProcessTokens(TOKEN *msgToken,IMSG *imsg,HANDLE hnd,LPTSTR szBuffer);
HRESULT FillPriority(IMSG *imsg,TOKEN *msgToken,ULONG counter,LPTSTR szBuffer);
void AthTimeParse(TCHAR * szBuffer1,IMSG *imsg);
HRESULT MessageAttachA(IMSG *imsg,TOKEN *msgToken,TCHAR *szboundary,int tokcount,TCHAR *szBuffer1);
void AthGetTimeBuffer(TCHAR * szBuffer, IMSG *imsg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\athena16\ath16imp.cpp ===
/******************************************************************************
    
    
    FILENAME:       Ath16imp.cpp
    MODULE:         Import Athena 16 folders
    PURPOSE:        Contains routines for initialization,deinitialization,
	                geting list of folders, releasing folder list, and 
					importing folder.
                   

    FUNCTIONS:  
    WIN95 Win32 functions:
       HRESULT AthGetFolderList(HWND hwnd, IMPFOLDERNODE **pplist);
	   HRESULT AthInit(HWND hwnd);	
	   void AthDeinit();
	   void AthFreeFolderList(IMPFOLDERNODE *pnode);
	   HRESULT AthImportFolder(HWND hwnd, HANDLE hnd, LPARAM lparam);
	   
	   HRESULT GetAthInstallPath(LPTSTR &szInstallPath);
	   HRESULT GetAthSubFolderList(LPTSTR szInstallPath,
								   IMPFOLDERNODE **ppList, IMPFOLDERNODE *);
	   void GetNewRecurseFolder(LPTSTR szInstallPath, LPTSTR szDir,
							    LPTSTR szInstallNewPath);
	   
	   HRESULT ProcessMessages(HANDLE hnd,LPTSTR szFileName);
	   HANDLE OpenMsgFile(LPTSTR szFileName);
	   long GetMessageCount(HANDLE hFile);
	   HRESULT ProcessMsgList(HANDLE hnd,HANDLE hFile,LPTSTR szPath);
	   HRESULT ParseMsgBuffer(LPTSTR szmsgbuffer,LPTSTR szPath,HANDLE hnd);
	   HRESULT GetMsgFileName(LPTSTR szmsgbuffer,BOOL Flag,LPTSTR *szfilename);
	   HRESULT GetDateBuffer(LPTSTR szmsgbuffer,TCHAR *szsendDate,
							 TCHAR *szrecvDate);
	   HRESULT	GetFileinBuffer(HANDLE hnd,LPTSTR *szBuffer);
	   void CopyStringA1(TOKEN *msgToken);
	   HRESULT	ProcessSingleMessage(HANDLE hnd,LPTSTR szBuffer,BOOL Flag,
									 IMSG *imsg);
	   HRESULT	ProcessTokens(TOKEN *msgToken,IMSG *imsg,HANDLE hnd,
							  LPTSTR szBuffer);
	   HRESULT FillPriority(IMSG *imsg,TOKEN *msgToken,ULONG counter,
							LPTSTR szBuffer);
	   void AthTimeParse(TCHAR * szBuffer1,IMSG *imsg);
	   HRESULT MessageAttachA(IMSG *imsg,TOKEN *msgToken,TCHAR *szboundary,
							  int tokcount,TCHAR *szBuffer1);
	   void AthGetTimeBuffer(TCHAR * szBuffer, IMSG *imsg); 
	  


******************************************************************************/


/** include files **/

#include "pch.hxx"
#include "string.h"
#include "stdio.h"
#include "impapi.h"
#include "imnapi.h"
#include "comconv.h"
#include "ath16imp.h"
#include "mapi.h"
#include "mapix.h"
#include "error.h"
#include "commdlg.h"
#include "import.h"


/******************************************************************************
*  FUNCTION NAME:AthGetFolderList
*
*  PURPOSE:To Get the Athena16 Folder List
*
*  PARAMETERS:
*
*     IN:	handle to the parent window
*
*     OUT:	Node in which the first folder will be returned
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT AthGetFolderList(HWND hwnd, IMPFOLDERNODE **pplist)
{
	HRESULT hr=S_OK;
	TCHAR szInstallPath[MAX_FILE_PATH];
	IMPFOLDERNODE *plist=NULL;

	hr = GetAthInstallPath(hwnd,szInstallPath);

	if(hr==hrInvalidFolderName)
		return(hrInvalidFolderName);


	if(S_OK!=(hr=GetAthSubFolderList(szInstallPath, &plist, NULL)))
		return(hr);

	if(NULL==plist)
		hr=hrReadFile;
	*pplist = plist;
	return hr;
}

/******************************************************************************
*  FUNCTION NAME:AthFreeFolderList
*
*  PURPOSE:To free the Folders List structure
*
*  PARAMETERS:
*
*     IN:	First folder node
*     OUT:	
*
*  RETURNS:  HRESULT
******************************************************************************/
void AthFreeFolderList(IMPFOLDERNODE *pnode)
{
	if (pnode->pchild != NULL)
        AthFreeFolderList(pnode->pchild);

    if (pnode->pnext != NULL)
        AthFreeFolderList(pnode->pnext);

    if (pnode->szName != NULL)
        delete(pnode->szName);

   if (pnode->lparam != NULL)
        delete [] (LPTSTR)pnode->lparam;


    delete(pnode);
}
/******************************************************************************
*  FUNCTION NAME:AthImportFolder
*
*  PURPOSE:Starts the process of importing the selected athena16 folder
*
*  PARAMETERS:
*
*     IN:	Handle to the window,handle and lparam which stores info about
*			path of the selected folder
*
*     OUT:	
*
*  RETURNS: HRESULT
******************************************************************************/

HRESULT AthImportFolder(HWND hwnd, HANDLE hnd, LPARAM lparam)
{
	HRESULT hr=S_OK;
	
	hr=ProcessMessages(hnd,(LPTSTR)lparam);

	return hr;
}

/******************************************************************************
*  FUNCTION NAME:AthInit
*
*  PURPOSE:Initialization
*
*  PARAMETERS:
*
*     IN:	Handle to the window
*
*     OUT:	
*
*  RETURNS: HRESULT
******************************************************************************/

HRESULT AthInit(HWND hwnd)	
{
	HRESULT hr=S_OK;

	return hr;
}

/******************************************************************************
*  FUNCTION NAME:AthDeinit
*
*  PURPOSE:Deinitialization .
*
*  PARAMETERS:
*
*     IN:	 
*
*     OUT: 
*  RETURNS:  HRESULT
******************************************************************************/

void AthDeinit()
{
	return;
}


/******************************************************************************
*  FUNCTION NAME:GetAthInstallPath
*
*  PURPOSE:To Get the Athena16 Installation path
*
*  PARAMETERS:
*
*     IN:	
*
*     OUT:	Installation path
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT GetAthInstallPath(HWND hwnd,LPTSTR szInstallPath)
{
	HRESULT hr=E_FAIL;

	hr = DispDialog(hwnd,szInstallPath);
	if(hr==hrInvalidFolderName)
		return(hr);
	
	lstrcat(szInstallPath,"\\folders");
	return S_OK;	

}


/******************************************************************************
*  FUNCTION NAME:GetAthSubFolderList
*
*  PURPOSE:To Get the Athena16 Folders List
*
*  PARAMETERS:
*
*     IN:	Installation path of Athena16 mail directory, Parent node
*
*     OUT:	Node in which the first folder will be returned
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT GetAthSubFolderList(LPTSTR szInstallPath, IMPFOLDERNODE **ppList, IMPFOLDERNODE *pParent)
{
	HRESULT hr= S_OK;
	IMPFOLDERNODE *pNode=NULL,
				  *pNew=NULL,
				  *pLast=NULL;
    IMPFOLDERNODE *pPrevious=NULL;
				  
	IMPFOLDERNODE *ptemp=NULL;
	BOOL Flag=TRUE;
	BOOL child=TRUE;
	TCHAR szInstallPathNew[MAX_FILE_PATH];
	TCHAR szInstallPathCur[MAX_FILE_PATH];
	LPTSTR szT=NULL;
	
	WIN32_FIND_DATA fFindData;
	HANDLE hnd=NULL;

	GetNewRecurseFolder(szInstallPath, "\\*", szInstallPathCur);
	
	hnd = FindFirstFile(szInstallPathCur, &fFindData); 
	if (hnd == INVALID_HANDLE_VALUE)
        return(E_FAIL);

	do {
	if((fFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
	{
		if(!lstrcmpi(fFindData.cFileName, ".") || !lstrcmpi(fFindData.cFileName, ".."))
			continue;

		pNew = new IMPFOLDERNODE;
		if(!pNew)
			return E_FAIL;

		ZeroMemory(pNew, sizeof(IMPFOLDERNODE));

		pNew->szName = (TCHAR *)new TCHAR[MAX_FILE_PATH];
		if(!pNew->szName)
		{
			hr=hrMemory;
			goto error;
		}
			
		lstrcpy(pNew->szName, fFindData.cFileName);


		szT = (LPTSTR)new TCHAR[MAX_FILE_PATH];
		if(!szT)
		{
			hr=hrMemory;
			goto error;
		}
		

		
		GetNewRecurseFolder(szInstallPath, fFindData.cFileName, szInstallPathNew);		
		lstrcpy(szT, szInstallPathNew);
		pNew->lparam = (long)szT;

		pNew->pparent=  pParent;

		pNew->depth = (pParent != NULL) ? pParent->depth + 1 : 0;
		
		if(pNode == NULL)
			pNode = pNew;

				
		pLast = pNew;


		if(Flag)
			pPrevious=pNew;
		else
		
		{
			if(pPrevious)
			{
				pPrevious->pnext=pNew;
				pPrevious=pNew;
			}
							

		}

		if(child)
		{
			if(pParent)
				pParent->pchild=pNew;
			child=FALSE;
		}


		GetAthSubFolderList(szInstallPathNew, &pNew->pchild,pNew);
		Flag = FALSE;
	}

	}while(FindNextFile(hnd, &fFindData));

	*ppList = pNode;



	if(hnd)
		FindClose(hnd);
	hnd=NULL;
	return hr;

error:
	Freetempbuffer(pNew->szName);
	Freetempbuffer(szT);
	if(pNew)
		delete(pNew);
	pNew=NULL;
	return(hr);


}

/******************************************************************************
*  FUNCTION NAME:GetNewRecurseFolder
*
*  PURPOSE:To Get the path of the next level of the Folders.
*
*  PARAMETERS:
*
*     IN:	Current directory path,szDir
*
*     OUT:	Next level directory path
*
*  RETURNS:  void
******************************************************************************/
void GetNewRecurseFolder(LPTSTR szInstallPath, LPTSTR szDir, LPTSTR szInstallNewPath)
{
	lstrcpy(szInstallNewPath, szInstallPath);
	lstrcat(szInstallNewPath, "\\");
	lstrcat(szInstallNewPath, szDir);
}





/******************************************************************************
*  FUNCTION NAME:ProcessMessages
*
*  PURPOSE:Starts processing messages within a folder
*
*  PARAMETERS:
*
*     IN:	Handle, folder path
*
*     OUT:	
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT ProcessMessages(HANDLE hnd,LPTSTR szFileName)
{
	HANDLE hFile=NULL;
	long uCount=0;
	long i=0;
	HRESULT hr=0;
	TCHAR szpath[MAX_FILE_PATH];
	ULONG cError=0;

	lstrcpy(szpath,szFileName);

	lstrcat(szFileName,"\\msg_list");

	if(INVALID_HANDLE_VALUE ==(hFile = OpenMsgFile(szFileName)))
	{
		MessageBox(NULL,"Message File Not Present","Message Folder Could not be imported",MB_OK);
		goto Error;
	}

	uCount = GetMessageCount(hFile);

	if(!uCount)
	{
		MessageBox(NULL,"No messages to import","Message Folder Could not be imported",MB_OK);
		return(hrNoMessages);
	}

	for(i=0;i<uCount;i++)
	{	
		hr = ProcessMsgList(hFile,hnd,szpath); 
		if(hr==hrMemory)
			break;
		if(hr!=S_OK)
			cError++;
	}
	

Error:
	if(hFile)
		CloseHandle(hFile);
	if(cError)
		hr=hrCorruptMessage;
	return(hr);

}

/******************************************************************************
*  FUNCTION NAME:OpenMsgFile
*
*  PURPOSE:Opens the file
*
*  PARAMETERS:
*
*     IN:	File name
*
*     OUT:	 
*
*  RETURNS:  HANDLE of the opened file.
******************************************************************************/

HANDLE OpenMsgFile(LPTSTR szFileName)
{

	HANDLE hFile=NULL;
	DWORD dwPointer=0; 

	ULONG i= lstrlen(szFileName);
	WIN32_FIND_DATA fFindData;

	if(INVALID_HANDLE_VALUE== FindFirstFile(szFileName, &fFindData))
		return(INVALID_HANDLE_VALUE);


	if(szFileName[i-1]=='*')
	{
		szFileName[lstrlen(szFileName)-10]='\0';
		lstrcat(szFileName,fFindData.cFileName);
	}



	hFile = CreateFile( szFileName, 
						GENERIC_READ,
						0,
						NULL,
						OPEN_EXISTING,
						FILE_ATTRIBUTE_NORMAL,
						NULL);

	if(hFile == INVALID_HANDLE_VALUE)
		return(hFile);

	dwPointer = SetFilePointer (hFile, 0, 
								NULL, FILE_BEGIN) ; 
	return(hFile);

}

/******************************************************************************
*  FUNCTION NAME:GetMessageCount
*
*  PURPOSE:To Get a count of number of messages inside a folder.
*
*  PARAMETERS:
*
*     IN:	Handle of the msg_list(index) file.
*
*     OUT:	
*
*  RETURNS:  LONG value which contains number of messages in a folder.
******************************************************************************/

long GetMessageCount(HANDLE hFile)
{

	DWORD dwPointer;
	MsgHeader msg;
	ULONG ulRead;

	
	dwPointer = SetFilePointer (hFile, 0, 
								NULL, FILE_BEGIN); 
	
	if(!ReadFile(hFile, &msg.ver, 1,&ulRead,NULL))
		return(0);

	if(!ReadFile(hFile, &msg.TotalMessages, 4,&ulRead,NULL))
		return(0);
	if(!ReadFile(hFile, &msg.ulTotalUnread, 4,&ulRead,NULL))
		return(0);
	return(msg.TotalMessages);

}

/******************************************************************************
*  FUNCTION NAME:ProcessMsgList
*
*  PURPOSE:To Get the Athena16 Folders List
*
*  PARAMETERS:
*
*     IN:	Handle of the msg_list(index) file, Handle and Current folder path. 
*
*     OUT:	 
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT ProcessMsgList(HANDLE hFile,HANDLE hnd,LPTSTR szPath)
{

	DWORD msgheader=0;
	ULONG ulRead=0;
	LPTSTR szmsgbuffer=NULL;
	HRESULT hResult=0;

	if(!ReadFile(hFile, &msgheader, 2,&ulRead,NULL))
		return(0);

	szmsgbuffer = new TCHAR[msgheader+1];
	if(!szmsgbuffer)
		 return(hrMemory);
	
	if(!ReadFile(hFile,(LPVOID)szmsgbuffer,msgheader,&ulRead,NULL))
	{
		hResult=hrReadFile;
		goto error;
	}
	szmsgbuffer[msgheader]='\0';

	hResult=ParseMsgBuffer(szmsgbuffer,szPath,hnd);

error:
	Freetempbuffer(szmsgbuffer);


return(hResult);


}

/******************************************************************************
*  FUNCTION NAME:ParseMsgBuffer
*
*  PURPOSE:To Get the Athena16 Folders List
*
*  PARAMETERS:
*
*     IN:	Handle,current folder path,buffer which contains the msg_list file.
*
*     OUT:	 
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT ParseMsgBuffer(LPTSTR szmsgbuffer,LPTSTR szPath,HANDLE hnd)
{

	IMSG AthImsg;
	HRESULT hResult=S_OK;
	BOOL Flag;
	HANDLE hFile=NULL;

	TCHAR szfilename[FILE_NAME];
	TCHAR szsendDate[DATE_SIZE],
		  szrecvDate[DATE_SIZE];

	LPTSTR szBuffer=NULL;
	TCHAR temp[MAX_FILE_PATH];

	ZeroMemory (&AthImsg,sizeof(IMSG));
	
	if(szmsgbuffer[0]=='R')
		Flag=TRUE;
	if(szmsgbuffer[0]=='S')
		Flag=FALSE;

	GetMsgFileName(szmsgbuffer,szfilename);
	lstrcat(szfilename,".*");

	
	lstrcpy(temp,szPath);
	lstrcat(temp,"\\");
	lstrcat(temp,szfilename);

	if(S_OK!=(hResult=GetDateBuffer(szmsgbuffer,szsendDate,szrecvDate)))
	       goto Error;
	AthGetTimeBuffer(szsendDate,&AthImsg);
	AthGetTimeBuffer(szrecvDate,&AthImsg);

	if(Flag && szmsgbuffer[9]=='R')
	AthImsg.uFlags =  MSGFLAG_READ;

	if(INVALID_HANDLE_VALUE ==(hFile = OpenMsgFile(temp)))
		goto Error;

	if(S_OK!=(hResult=GetFileinBuffer(hFile, &szBuffer)))
		goto Error;
	
	hResult=ProcessSingleMessage(hnd,szBuffer,&AthImsg);


Error:

	if(hFile)
		CloseHandle(hFile);
	Freetempbuffer(szBuffer);

return(hResult);

}

/******************************************************************************
*  FUNCTION NAME:GetMsgFileName
*
*  PURPOSE:Get the file name of each message from msg_list file.
*
*  PARAMETERS:
*
*     IN:	buffer which contains msg_list file
*
*     OUT:	File name of a message file.
*
*  RETURNS:  HRESULT
******************************************************************************/


HRESULT GetMsgFileName(LPTSTR szmsgbuffer,LPTSTR szfilename)
{
	ULONG i;

	lstrcpyn(szfilename,szmsgbuffer,9);

	ULONG ul=lstrlen(szfilename);
	for(i=0;i<ul;i++)
	{
		if(((szfilename)[i])==01)
			((szfilename)[i])='.'; //.

	}

	return(S_OK);

	

}

/******************************************************************************
*  FUNCTION NAME:GetDateBuffer
*
*  PURPOSE:To Get the sent and receive Time info in a buffer from msg_list file
*
*  PARAMETERS:
*
*     IN:	Buffer containing msg_list file,
*
*     OUT:	Sendtime and receive time
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT GetDateBuffer(LPTSTR szmsgbuffer,TCHAR *szsendDate,
					  TCHAR *szrecvDate)
{
	ULONG ul=lstrlen(szmsgbuffer);
	ULONG counter=0;
	for(counter=0;counter<ul;counter++)
	{
		if(szmsgbuffer[counter]==01 && szmsgbuffer[counter+1]==01)
			break;
	}

	if(counter>=ul)
		return(hrReadFile); //error corrupt msgheader

	lstrcpyn(szsendDate,&szmsgbuffer[counter+2],28);
	lstrcpyn(szrecvDate,&szmsgbuffer[counter+30],28);
	
	return(S_OK);
	
}

/******************************************************************************
*  FUNCTION NAME:GetFileinBuffer
*
*  PURPOSE:To Get the message file in a buffer.
*
*  PARAMETERS:
*
*     IN:	Handle of the message file.
*
*     OUT:	Buffer comatining the message.
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT	GetFileinBuffer(HANDLE hnd,LPTSTR *szBuffer)
{

	ULONG ulFileSize;
	ULONG ulRead;
	HRESULT hResult=0;

	ulFileSize = GetFileSize(hnd, NULL);
	if(!ulFileSize)
		goto Error;

	*szBuffer = new TCHAR[ulFileSize+1];

	if(!ReadFile(hnd, (LPVOID)*szBuffer,ulFileSize,&ulRead,NULL))
	{
		hResult=hrReadFile;
		goto Error;
	}

	(*szBuffer)[ulFileSize]='\0';

		
Error:
	return(hResult);


}

/******************************************************************************
*  FUNCTION NAME:ProcessSingleMessage
*
*  PURPOSE:Processes individual messages
*
*  PARAMETERS:
*
*     IN:	Handle,Buffer containing message
*
*     OUT:	Node in which the first folder will be returned
*
*  RETURNS:  HRESULT
******************************************************************************/


HRESULT	ProcessSingleMessage(HANDLE hnd,LPTSTR szBuffer,IMSG *imsg)
{
	
	TOKEN msgToken[19];
	ZeroMemory(msgToken,sizeof(TOKEN)*19);
	ULONG uTokens=19;
	ULONG i=0;
	ULONG uMsgSize=lstrlen(szBuffer);
	HRESULT hResult=0;

	CopyStringA1(msgToken);

	for(ULONG j=0;j<uTokens-1;j++)
		msgToken[j].cAddress = strstr(szBuffer,msgToken[j].cType);
	
	while(i<uMsgSize)
	{
		if(szBuffer[i]==13  &&  szBuffer[i+1]==10 )
		{
			msgToken[j].cAddress =  &szBuffer[i];	 
			break;
		}
		for(;(!(szBuffer[i]==13  &&  szBuffer[i+1]==10 )&&i<= (ULONG)lstrlen(szBuffer));i++);
		i+=2;
	}

	if(i>= (ULONG)lstrlen(szBuffer))
		//error:MessageBody Could not be distinguished
		return(hrCorruptMessage);  
		
	ArrangePointers(msgToken,uTokens);
	for(i=0;strcmp(msgToken[i].cType,"MsgBody")!=0;i++);
	if(i!=uTokens-1)
	{
		for(i=i+1;i<uTokens;i++)
			msgToken[i].cAddress=NULL;
		ArrangePointers(msgToken,uTokens);

	}

	hResult=ProcessTokens(msgToken,imsg,hnd,szBuffer);



return(hResult);

}

/******************************************************************************
*  FUNCTION NAME:ProcessTokens
*
*  PURPOSE:To process each tokens from each message
*  PARAMETERS:
*
*     IN:	Message Token structure,handle, buffer containing the message
*
*     OUT:	IMSG structure
*
*  RETURNS:  HRESULT
******************************************************************************/


HRESULT	ProcessTokens(TOKEN *msgToken,IMSG *imsg,HANDLE hnd,LPTSTR szBuffer)
{


	ULONG counter=0;
	ADDRESS *addinfo=NULL,
		    *addstart=NULL;

	ULONG uTokens=19;
	HRESULT hResult=0;
	ADDRESS *addrcount=NULL;

	TCHAR *szboundary=NULL;

	for(;counter<uTokens;counter++)
	{
		switch(msgToken[counter].TokNumber)
		{
		case(Priority):
			FillPriority(imsg,msgToken,counter,szBuffer);
			break;

		case(Subject):
			SubjectToImsg(msgToken,imsg,counter);
			break;

		case(From):
			if((msgToken[counter].cAddress)!=NULL)
			hResult=ParseAddress(szBuffer,msgToken,counter,&addinfo,&addstart);
			break;

		case(To):
			if((msgToken[counter].cAddress)!=NULL)
			hResult=ParseAddress(szBuffer,msgToken,counter,&addinfo,&addstart);
			break;

		case(Cc):
			if((msgToken[counter].cAddress)!=NULL)
			hResult=ParseAddress(szBuffer,msgToken,counter,&addinfo,&addstart);
			break;

		case(ContentType):
			if((msgToken[counter].cAddress)!=NULL)
				szboundary = ParseAttachments(imsg,msgToken,counter,szBuffer);
			break;

		case(MsgBody):
            hResult=MessageAttachA(imsg,msgToken,szboundary,counter,szBuffer);
			break;
		}
	}


	addrcount = addstart;
	if (addrcount == NULL)
	{
		hResult=hrNoRecipients;
		goto Error;
		//No addresses
	}
	
	if((hResult =FillAddressList(addrcount,imsg))!=S_OK)
		goto Error;
	
	hResult = ImpMessage(hnd,imsg);

	// free the imsg structure, FreeImsg is in imnapi

Error:
	FreeMemory(imsg);
    Freetempbuffer(szboundary);

return(hResult);
}
		 
/******************************************************************************
*  FUNCTION NAME:CopyStringA1
*
*  PURPOSE:Copies strings to msgtoken structure
*
*  PARAMETERS:
*
*     IN:	
*
*     OUT:	msgtoken
*
*  RETURNS:  None
******************************************************************************/

void CopyStringA1(TOKEN *msgToken)
{
	lstrcpy(msgToken[0].cType,"Message-ID: ");
	lstrcpy(msgToken[1].cType,"X-MAPI-MessageFlags: ");
	lstrcpy(msgToken[2].cType,"X-MAPI-DeleteAfterSubmit: ");
	lstrcpy(msgToken[3].cType,"X-MAPI-SentMailEntryID: ");
	lstrcpy(msgToken[4].cType,"X-MAPI-ReadReceipt: ");
	lstrcpy(msgToken[5].cType,"X-MAPI-DeliveryReceipt: ");
	lstrcpy(msgToken[6].cType,"Priority: ");
	lstrcpy(msgToken[7].cType,"To: ");
	lstrcpy(msgToken[8].cType,"MIME-Version: ");
	lstrcpy(msgToken[9].cType,"From: ");
	lstrcpy(msgToken[10].cType,"Subject: ");
	lstrcpy(msgToken[11].cType,"Date: ");
	lstrcpy(msgToken[12].cType,"Content-Type: ");
	lstrcpy(msgToken[13].cType,"Content-Transfer-Encoding: ");
	lstrcpy(msgToken[14].cType,"Return-Path: ");
	lstrcpy(msgToken[15].cType,"Received: ");
	lstrcpy(msgToken[16].cType,"Reply-To: ");
	lstrcpy(msgToken[17].cType,"Cc: ");
	lstrcpy(msgToken[18].cType,"MsgBody");

	for(int i=0;i<19;i++)
		msgToken[i].TokNumber=i;
	return;
}


/******************************************************************************
*  FUNCTION NAME:FillPriority
*
*  PURPOSE:To fill the priority in imsg structure
*  PARAMETERS:
*
*     IN:	msgtoken,counter number,buffer(message file)
*
*     OUT:	Imsg structure
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT FillPriority(IMSG *imsg,TOKEN *msgToken,ULONG counter,LPTSTR szBuffer)
{

	if(!msgToken[counter].cAddress)
		imsg->wPriority=PRI_NORMAL;
	else
	{
		if('U'==msgToken[counter].cAddress[10])
			imsg->wPriority = PRI_HIGH;

		if('N'==msgToken[counter].cAddress[10])
			imsg->wPriority = PRI_LOW;
	}

	return(S_OK);
}


/******************************************************************************
*  FUNCTION NAME:MessageAttachA
*
*  PURPOSE:Parse messages and attachments
*
*  PARAMETERS: 
*
*     IN:pointer msgtoken,boundary,counter,buffer conatining message
*
*     OUT:	Imsg
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT MessageAttachA(IMSG *imsg,TOKEN * msgToken,TCHAR *szboundary,int i,TCHAR *szBuffer1)
{
HRESULT hr=0;
TCHAR *szBuff=NULL;
TCHAR szfilename[_MAX_PATH];
ULONG AttachCount=0;
ULONG ccount=0;
ULONG sizebuff;
TCHAR *dummy1=NULL,*dummy2=NULL,*dummy3=NULL,
      *dummy4=NULL,*temp=NULL,*temp1=NULL;
ULONG flag; //to check whether message body is present or not
ULONG cpoint=0; 
BOOL embeddmessage=FALSE;
ULONG tcount=0;
TCHAR *szattachbuffer=NULL;

if(szboundary == NULL)
{
	sizebuff = lstrlen(szBuffer1)-(msgToken[i].cAddress-szBuffer1+2); // 2 since messagebody points to blank line
	if((szBuff = new TCHAR[sizebuff+1])==0)
		return(hrMemory);

	for( ccount=0;ccount < sizebuff;ccount++)
		szBuff[ccount] = msgToken[i].cAddress[ccount+2];
		szBuff[ccount] = '\0';

}

else
{

	
		dummy1= strstr(msgToken[i].cAddress,szboundary);
		if(dummy1==NULL)
		{
			hr=hrCorruptMessage;
			goto error;
		}

		dummy1=dummy1+lstrlen(szboundary)+2;

		dummy2=strstr(dummy1,szboundary);

		if(dummy2==NULL)
		{
			hr=hrCorruptMessage;
			goto error;
		}
			
		if((temp1=strstr(dummy1,"Content-Type:"))==NULL)
		{
			hr=hrCorruptMessage;
			goto error;
		}			

		while(cpoint < (ULONG)lstrlen(dummy1))
			{
				if(dummy1[cpoint]==13  &&  dummy1[cpoint+1]==10 )
				{
					dummy3=  &dummy1[cpoint]+2;
					break;
				}
				for(;(!(dummy1[cpoint]==13  &&  dummy1[cpoint+1]==10 )&&cpoint<=(ULONG)lstrlen(dummy1));cpoint++);
				cpoint+=2;
			}
			if(cpoint  > (ULONG)lstrlen(dummy1))
			{
				hr=hrCorruptMessage;
				goto error;
			}
		if((strstr(temp1,"name=")!=NULL) && (strstr(temp1,"name=")< dummy3))
		{
			flag=1;
			sizebuff=1;
		}
        else
		{
			flag=0;
			sizebuff=dummy2- dummy3-2;	 //2 for 13 and 10	 (3 new lines)
		}
		if((szBuff = new TCHAR[sizebuff+1])==0)
		{
			hr=hrMemory;
			goto error;
		}
			
		if(sizebuff==1)
			lstrcpy(szBuff,"");
		else
		{
			for( ccount=0;ccount < sizebuff;ccount++)
				szBuff[ccount] = dummy3[ccount];
			szBuff[ccount] = '\0';
		}
		
		//to get attachmentcount
		temp=dummy2;
		if(szboundary!=NULL)
		{
			if (flag==0)
				dummy1=dummy2+lstrlen(szboundary)+2;
			while((dummy2=strstr(dummy1,szboundary))!=NULL)
			{
				AttachCount++;
				dummy1=dummy2+lstrlen(szboundary)+2;
			}
		}
		
		//parsing attachments
		dummy2=temp;

		//allocate imsg->Iattach memory
		imsg->cAttach = AttachCount;
		if (AttachCount==0)
		{
			imsg->lpIatt = NULL;
			if((hr=MessageBodytoImsg(szBuff,imsg))!=S_OK)
				goto error;
			else
			{
				hr=S_OK;
				goto error;
			}

		
		}
		
		if((imsg->lpIatt = new IATTINFO [sizeof(IATTINFO)*AttachCount])==0)
		{
			Freetempbuffer(szBuff);
			return(hrMemory);
		}
		ZeroMemory(imsg->lpIatt,sizeof(IATTINFO)*AttachCount);
	
		for(ccount=0;ccount<AttachCount;ccount++)
			imsg->lpIatt[ccount].fError = TRUE; //just to make sure that if attachment error occurs there should not be any problem.

		ULONG j=0;
		if(szboundary !=NULL && dummy2 != NULL)
		{
			dummy2=dummy2+lstrlen(szboundary)+2;
			while((dummy3 = strstr(dummy2,szboundary))!=NULL && j<AttachCount)
			{
				dummy4=strstr(dummy2,"name=""");
				if(dummy4==NULL||dummy4 > dummy3)
				{
					dummy4=strstr(dummy2,"message/rfc822");
					if(dummy4==NULL||dummy4 > dummy3)
					{
						j++;
						dummy2=dummy3+lstrlen(szboundary)+4;
						imsg->lpIatt[j-1].fError = TRUE;
						continue;
					}
					else
						embeddmessage=TRUE;
				}

				if(!(embeddmessage))
				{
					dummy4=dummy4+lstrlen("name=")+1;
					for(ccount=0;ccount <(ULONG)lstrlen(dummy4);ccount++)
					{
						if(dummy4[ccount]=='"' )
							break;
						szfilename[ccount]=dummy4[ccount];
					}
				
					if(dummy4[ccount]!='"' )
					{
						j++;
						dummy2=dummy3+lstrlen(szboundary)+4;
						imsg->lpIatt[j-1].fError = TRUE;
						continue;
						//error 
					
					}
					szfilename[ccount]='\0';
				}
				else
				{
				//	dummy4=dummy4+lstrlen("message/rfc822")+2;
					dummy4=dummy4+16;
					szfilename[0]='\0';
				}

				cpoint=0;

				while(cpoint < (ULONG)lstrlen(dummy4))
				{
				if(dummy4[cpoint]==13  &&  dummy4[cpoint+1]==10 )
				{
					dummy4=  &dummy4[cpoint]+2;
					break;
				}
				for(;(!(dummy4[cpoint]==13  &&  dummy4[cpoint+1]==10 )&&cpoint<= (ULONG)lstrlen(dummy4));cpoint++);
				cpoint+=2;
				}

			//convert to istream
				
				if(dummy3<dummy4)
				{
					imsg->lpIatt[j].fError = TRUE;
					hr=hrCorruptMessage;
					goto error;
				}

				tcount = dummy3-dummy4-8;
				if((szattachbuffer = new TCHAR[tcount+1])==0)
				{
					hr=hrMemory;
					goto error;
				}
				for(ccount=0;ccount<tcount;ccount++)
					szattachbuffer[ccount]=dummy4[ccount];
				szattachbuffer[ccount]='\0';

				j++;
				dummy2=dummy3+lstrlen(szboundary)+4;
				//fill imsg structure here

				FillAttachImg(imsg,j-1,szattachbuffer,szfilename);

			
			} 
			if (j!=AttachCount)
			{
				hr=hrCorruptMessage;
				goto error;
			}

		}
	
} 	

hr=MessageBodytoImsg(szBuff,imsg);
error:
if(szBuff!=NULL)
	delete szBuff;
szBuff=NULL;

return(hr);

}

/******************************************************************************
*  FUNCTION NAME:AthGetTimeBuffer
*
*  PURPOSE:To Get time field in a buffer
*
*  PARAMETERS:
*
*     IN:	Time field buffer(unformatted)
*
*     OUT:	Time field buffer(formatted ie without spaces)
*
*  RETURNS:  None
******************************************************************************/

void AthGetTimeBuffer(TCHAR * szBuffer, IMSG *imsg)
{

	
	ULONG k=0;
 	for(ULONG j=0;j<((ULONG)lstrlen(szBuffer)+1);j++)
	{
		if(szBuffer[j] != ' ')
		szBuffer[k++]= szBuffer[j];

    }
	szBuffer[k] = NULL ;

	TimeParse(szBuffer,imsg);




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\athena16\impath16.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include <..\Eudora\eudrimp.h>
#include <ImpAth16.h>
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>
#include <imnapi.h>
#include <commdlg.h>
#include <strconst.h>

ASSERTDATA

typedef struct tagSELATH16INFO
    {
    char szFile[MAX_PATH];
    char szUser[MAX_PATH];
    } SELATH16INFO;

INT_PTR CALLBACK ProvideIniPathProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT GetIniFilePath(SELATH16INFO *pSelAth, HWND hwnd);

static const char g_Athena16Mail[] = "c:\\Athena16\\Mail\\Mail.ini";
static const char c_szUsers[] = "Users";
static const char c_szPathFileFmt[] = "%s\\%s";
static const char c_szAsterisk[] = "*";
static const char c_szDot[] = ".";
static const char c_szDotDot[] = "..";
static const char c_szFoldersDir[] = "\\Folders";
static const char c_szMsgListFile[] = "\\msg_list";

CAthena16Import::CAthena16Import()
{
    DllAddRef();
	
    m_cRef = 1;
    m_plist = NULL;
    *m_szUser = 0;
}

CAthena16Import::~CAthena16Import()
{
    if (m_plist != NULL)
		EudoraFreeFolderList(m_plist);
	
    DllRelease();
}

ULONG CAthena16Import::AddRef()
{
    m_cRef++;
	
    return(m_cRef);
}

ULONG CAthena16Import::Release()
{
    ULONG cRef;
	
    cRef = --m_cRef;
    if (cRef == 0)
        delete this;
	
    return(cRef);
}

HRESULT CAthena16Import::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;
	
    if (ppv == NULL)
        return(E_INVALIDARG);
	
    *ppv = NULL;
	
	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;
	
    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
	
    return(hr);
}


HRESULT CAthena16Import::InitializeImport(HWND hwnd)
{
//	Only if the default path to the mail.ini file is 
//	incorrect prompt the user!!!

    HRESULT			hr = S_FALSE;
    int  			iRet;
	SELATH16INFO	sa;

    ZeroMemory(&sa, sizeof(sa));

	hr = GetIniFilePath(&sa, hwnd);

	lstrcpy(m_szIniFile, sa.szFile);

	if (GetNumUsers(sa.szFile, sa.szUser) > 1)
	{
		iRet = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddSelectAth16User), hwnd, SelectAth16UserDlgProc, (LPARAM)&sa);
	    if (iRet == IDCANCEL)
			hr = S_FALSE;
		else if (iRet == IDOK)
			lstrcpy(m_szUser, sa.szUser);
		else
			hr = E_FAIL;
	}
    else
        {
        lstrcpy(m_szUser, sa.szUser);
        }
        
	return(hr);
}

INT_PTR CALLBACK SelectAth16UserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    HWND hwndT;
    WORD id;
    DWORD cb;
    char sz[MAX_PATH];
    SELATH16INFO *psa;
    int index;
	TCHAR szSections[1000];
	TCHAR szUserName[256];
	int nCount		= 0;
	int nOldStop	= 0;
	int nLength		= 0;


    switch (msg)
        {
        case WM_INITDIALOG:
            Assert(lParam != NULL);
            psa = (SELATH16INFO *)lParam;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)psa);

            hwndT = GetDlgItem(hwnd, IDC_USERLIST);

            // fill list
            cb = sizeof(sz);
			if(GetPrivateProfileString(c_szUsers, NULL, c_szEmpty, szSections, 1000, psa->szFile) != NULL)
			{
				lstrcpy(szUserName, (const char*)&szSections[nCount]); // Copies the string up to the first NULL
				nLength = lstrlen(szUserName);
				do
				{
					SendMessage(hwndT, LB_ADDSTRING, 0, (LPARAM)szUserName);
					nCount += (nLength + 1);
					lstrcpy(szUserName, (const char*)&szSections[nCount]); // Copies the string up to the first NULL
					nLength = lstrlen(szUserName);
				}while(nLength);
			}
				
            SendMessage(hwndT, LB_SETCURSEL, 0, 0);
            return(TRUE);

        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
                {
                case IDOK:
                    psa = (SELATH16INFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    Assert(psa != NULL);

                    hwndT = GetDlgItem(hwnd, IDC_USERLIST);
                    index = (int) SendMessage(hwndT, LB_GETCURSEL, 0, 0);
                    Assert(index >= 0);
                    SendMessage(hwndT, LB_GETTEXT, (WPARAM)index, (LPARAM)psa->szUser);

                    // fall through

                case IDCANCEL:
                    EndDialog(hwnd, id);
                    return(TRUE);
                }
            break;
        }

    return(FALSE);
    }

HRESULT CAthena16Import::GetDirectory(char *szDir, UINT cch)
{
	HRESULT hr = S_FALSE;
	
    Assert(szDir != NULL);

	if (*m_szUser != 0)
		hr = GetUserDir(szDir, cch);
	if (FAILED(hr))
		  *szDir = 0;
	return(S_OK);
}

HRESULT CAthena16Import::GetUserDir(char *szDir, UINT cch)
{
	HRESULT hr;
	Assert(lstrlen(m_szUser));

	if(GetPrivateProfileString(c_szUsers, m_szUser, c_szEmpty, szDir, cch, m_szIniFile) != NULL)
	{
		lstrcat(szDir, c_szFoldersDir);
		hr = S_OK;
	}
	else
		hr = S_FALSE;
	return hr;
}

HRESULT CAthena16Import::SetDirectory(char *szDir)
{
    HRESULT hr;
	
    Assert(szDir != NULL);
	
	// CAN WE DO SOMETHING TO VALIDATE THIS MAIL DIRECTORY!!!
	
	if (m_plist != NULL)
	{
        EudoraFreeFolderList(m_plist);
		m_plist = NULL;
	}
	
	hr=GetAthSubFolderList(szDir, &m_plist, NULL);
	
	return(hr);
}

HRESULT CAthena16Import::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
{
    CAthena16FOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;
	
    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;
	
    if (pnode == NULL)
        return(S_FALSE);
	
    pEnum = new CAthena16FOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);
	
    *ppEnum = pEnum;
	
    return(S_OK);
}

STDMETHODIMP CAthena16Import::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
{
	HRESULT hr=S_OK;
	EUDORANODE* pNode = NULL;
	
	pNode  = (EUDORANODE*)dwCookie;
	hr=ProcessMessages(pNode->szFile, pImport);
	return hr;
}

CAthena16FOLDERS::CAthena16FOLDERS(EUDORANODE *plist)
{
    Assert(plist != NULL);
	
    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
}

CAthena16FOLDERS::~CAthena16FOLDERS()
{
	
}

ULONG CAthena16FOLDERS::AddRef()
{
    m_cRef++;
	
    return(m_cRef);
}

ULONG CAthena16FOLDERS::Release()
{
    ULONG cRef;
	
    cRef = --m_cRef;
    if (cRef == 0)
        delete this;
	
    return(cRef);
}

HRESULT CAthena16FOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
{
    HRESULT hr = S_OK;
	
    if (ppv == NULL)
        return(E_INVALIDARG);
	
    *ppv = NULL;
	
	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;
	
    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();
	
    return(hr);
}

HRESULT CAthena16FOLDERS::Next(IMPORTFOLDER *pfldr)
{
    Assert(pfldr != NULL);
	
    if (m_pnext == NULL)
        return(S_FALSE);
	
    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    lstrcpyn(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);
	
    m_pnext = m_pnext->pnext;
	
    return(S_OK);
}

HRESULT CAthena16FOLDERS::Reset()
{
    m_pnext = m_plist;
	
    return(S_OK);
}


HRESULT GetAthSubFolderList(LPTSTR szInstallPath, EUDORANODE **ppList, EUDORANODE *pParent)
{
	HRESULT hr= S_OK;
	EUDORANODE *pNode=NULL,
		*pNew=NULL,
		*pLast=NULL;
    EUDORANODE *pPrevious=NULL;
	
	EUDORANODE *ptemp=NULL;
	BOOL Flag=TRUE;
	BOOL child=TRUE;
	TCHAR szInstallPathNew[MAX_PATH];
	TCHAR szInstallPathCur[MAX_PATH];
	
	WIN32_FIND_DATA fFindData;
	HANDLE hnd=NULL;
	
    wsprintf(szInstallPathCur, c_szPathFileFmt, szInstallPath, c_szAsterisk);
	
	hnd = FindFirstFile(szInstallPathCur, &fFindData); 
	if (hnd == INVALID_HANDLE_VALUE)
        return(E_FAIL);
	
	do {
		if((fFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		{
			if(!lstrcmpi(fFindData.cFileName, c_szDot) || !lstrcmpi(fFindData.cFileName, c_szDotDot))
				continue;// Do not process the system dirs!
			
		    if (!MemAlloc((void **)&pNew, sizeof(EUDORANODE)))
				goto err;
			ZeroMemory(pNew, sizeof(EUDORANODE));
			lstrcpy(pNew->szName, fFindData.cFileName);

            wsprintf(szInstallPathNew, c_szPathFileFmt, szInstallPath, fFindData.cFileName);

			lstrcpy(pNew->szFile, szInstallPathNew);
			
			pNew->pparent=  pParent;
			
			pNew->depth = (pParent != NULL) ? pParent->depth + 1 : 0;
			
			if(pNode == NULL)
				pNode = pNew;
			
			pLast = pNew;

			if(Flag)
				pPrevious=pNew;
			else
			{
				if(pPrevious)
				{
					pPrevious->pnext=pNew;
					pPrevious=pNew;
				}
			}
			
			if(child)
			{
				if(pParent)
					pParent->pchild=pNew;
				child=FALSE;
			}

			GetAthSubFolderList(szInstallPathNew, &pNew->pchild,pNew);
			Flag = FALSE;
		}
		
	}while(FindNextFile(hnd, &fFindData));
	*ppList = pNode;

err:	
	if(hnd)
		FindClose(hnd);
	hnd=NULL;
	return hr;
}

HRESULT ProcessMessages(LPSTR szFileName, IFolderImport *pImport)
{
	HANDLE hFile=NULL;
	long uCount=0;
	long i=0;
	HRESULT hr=S_OK;
	TCHAR szpath[MAX_PATH];
	ULONG cError=0;
	
	lstrcpy(szpath, szFileName);
	
	lstrcat(szFileName,c_szMsgListFile);
	
	hFile = CreateFile(szFileName, 
		GENERIC_READ,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	if (INVALID_HANDLE_VALUE == hFile)
        return(hrNoMessages);
	
	uCount = GetMessageCount(hFile);
	
	if (uCount > 0)
	    {
        pImport->SetMessageCount(uCount);

	    for (i = 0; i < uCount; i++)
	        {	
		    hr = ProcessMsgList(hFile, szpath, pImport);
		    if (hr == hrMemory || hr == hrUserCancel)
			    break;
		    if (hr != S_OK)
			    cError++;
	        }
        }
	
    CloseHandle(hFile);
	if ((cError) && SUCCEEDED(hr))
		hr = hrCorruptMessage;

	return(hr);
}

/******************************************************************************
*  FUNCTION NAME:GetMessageCount
*
*  PURPOSE:To Get a count of number of messages inside a folder.
*
*  PARAMETERS:
*
*     IN:	Handle of the msg_list(index) file.
*
*     OUT:	
*
*  RETURNS:  LONG value which contains number of messages in a folder.
******************************************************************************/

long GetMessageCount(HANDLE hFile)
{
	MsgHeader msg;
	ULONG ulRead;
	
	if(!ReadFile(hFile, &msg.ver, 1,&ulRead,NULL))
		return(0);
	
	if(!ReadFile(hFile, &msg.TotalMessages, 4,&ulRead,NULL))
		return(0);
	if(!ReadFile(hFile, &msg.ulTotalUnread, 4,&ulRead,NULL))
		return(0);
	return(msg.TotalMessages);
	
}


/******************************************************************************
*  FUNCTION NAME:ProcessMsgList
*
*  PURPOSE:To Get the Athena16 Folders List
*
*  PARAMETERS:
*
*     IN:	Handle of the msg_list(index) file, Handle and Current folder path. 
*
*     OUT:	 
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT ProcessMsgList(HANDLE hFile, LPSTR szPath, IFolderImport* pImport)
{
	DWORD msgheader = 0;
	ULONG ulRead;
	LPSTR szmsgbuffer;
	HRESULT hResult = S_FALSE;
	
	if (!ReadFile(hFile, &msgheader, 2, &ulRead, NULL))
		return(0);
	
    if (!MemAlloc((void **)&szmsgbuffer, msgheader + 1))
        return(E_OUTOFMEMORY);
	
	if (!ReadFile(hFile, (LPVOID)szmsgbuffer, msgheader, &ulRead, NULL))
        {
        hResult = hrReadFile;
        }
    else
        {
	    szmsgbuffer[msgheader] = 0;
	    
	    hResult = ParseMsgBuffer(szmsgbuffer, szPath, pImport);
        }
	
    MemFree(szmsgbuffer);
	
	return(hResult);
}

/******************************************************************************
*  FUNCTION NAME:ParseMsgBuffer
*
*  PURPOSE:To Get the Athena16 Folders List
*
*  PARAMETERS:
*
*     IN:	Handle,current folder path,buffer which contains the msg_list file.
*
*     OUT:	 
*
*  RETURNS:  HRESULT
******************************************************************************/

HRESULT ParseMsgBuffer(LPSTR szmsgbuffer, LPSTR szPath, IFolderImport *pImport)
{
    char szfilename[MAX_PATH];
    char temp[MAX_PATH];
    HRESULT hResult = S_OK;
    DWORD dwFlags = 0;	

    GetMsgFileName(szmsgbuffer, szfilename);
    if (szmsgbuffer[9] == 'N')
        dwFlags = MSG_STATE_UNREAD;

    wsprintf(temp, c_szPathFileFmt, szPath, szfilename);

    hResult = ProcessSingleMessage(temp, dwFlags, pImport);

    return(hResult);
}

HRESULT	ProcessSingleMessage(LPTSTR szFilePath, DWORD dwFlags, IFolderImport* pImport)
{
	LPSTREAM lpstm = NULL;
	ULONG ulFileSize, cbMsg;
	ULONG ulRead;
    HANDLE mapMsg, hMsg;
	BYTE *pByteBuffer = NULL;
	HRESULT hResult = S_FALSE;

	hMsg = CreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMsg == INVALID_HANDLE_VALUE)
        return(S_FALSE);

    cbMsg = GetFileSize(hMsg, NULL);
    if (cbMsg > 0)
        {
        mapMsg = CreateFileMapping(hMsg, NULL, PAGE_READONLY, 0, 0, NULL);
        if (mapMsg != NULL)
            {
            pByteBuffer = (BYTE *)MapViewOfFile(mapMsg, FILE_MAP_READ, 0, 0, 0);
            if (pByteBuffer != NULL)
                {
	            hResult = HrByteToStream(&lpstm, (LPBYTE)pByteBuffer, cbMsg);
                if (SUCCEEDED(hResult))
                    {
		            Assert(lpstm != NULL);

                    hResult = pImport->ImportMessage(MSG_TYPE_MAIL, dwFlags, lpstm, NULL, 0);
                    lpstm->Release();
                    }

                UnmapViewOfFile(pByteBuffer);
                }

            CloseHandle(mapMsg);
            }
        }

	CloseHandle(hMsg);

	return(hResult);
}

/******************************************************************************
*  FUNCTION NAME:GetMsgFileName
*
*  PURPOSE:Get the file name of each message from msg_list file.
*
*  PARAMETERS:
*
*     IN:	buffer which contains msg_list file
*
*     OUT:	File name of a message file.
*
*  RETURNS:  HRESULT
******************************************************************************/


HRESULT GetMsgFileName(LPCSTR szmsgbuffer, char *szfilename)
{
	ULONG i, ul;
	
	lstrcpyn(szfilename, szmsgbuffer, 11);
	szfilename[10] = 0;

	ul = lstrlen(szfilename);
    Assert(ul == 10);

    Assert(szfilename[8] == 0x01);
    szfilename[9] = szfilename[9] & 0x7f; // turn off the highbit which is used to indicate attachment
    if (szfilename[9] == ' ')
        szfilename[8] = 0;
    else
        szfilename[8] = '.';
        
	return(S_OK);
}

int GetNumUsers(char *szFile, char *szUser)
{
	TCHAR szSections[1000];
	int nCount = 0;
	int nLoop  = 0;
	
	if (GetPrivateProfileString(c_szUsers, NULL, c_szEmpty, szSections, ARRAYSIZE(szSections), szFile) > 0)
	{
        lstrcpy(szUser, szSections);

		while (nLoop < ARRAYSIZE(szSections))
		{
			if(szSections[nLoop] == 0)
			{
				if(szSections[nLoop+1] == 0)
				{
					nCount++;
					return nCount;
				}
				else
					nCount++;
			}
			nLoop++;
		}
	}
	return nCount;
}

HRESULT GetIniFilePath(SELATH16INFO *pSelAth, HWND hwnd)
{
	int 		nRet	= 0;
	HRESULT		hr;
	WIN32_FIND_DATA pWinFind;

	if(FindFirstFile(g_Athena16Mail, &pWinFind) == INVALID_HANDLE_VALUE)
	{
		nRet = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddProvideMailPath), hwnd, ProvideIniPathProc, (LPARAM)pSelAth);
		if (nRet == IDCANCEL)
			hr = S_FALSE;
		else if (nRet == IDOK)
			hr = S_OK;
		else
			hr = E_FAIL;
	}
	else
	{
		lstrcpy(pSelAth->szFile, g_Athena16Mail);
		hr = S_OK;
	}

	return hr;
}

INT_PTR CALLBACK ProvideIniPathProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;
    WORD id;
    SELATH16INFO *psa;
    int nCount = 0;
	WIN32_FIND_DATA pWinFind;
    OPENFILENAME    ofn;
	TCHAR			szFilter[CCHMAX_STRINGRES];
	TCHAR           szFile[MAX_PATH];
    int nLen, i = 0;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            Assert(lParam != NULL);
            psa = (SELATH16INFO *)lParam;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)psa);
	        return(TRUE);

        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
                {
                case IDOK:
                    psa = (SELATH16INFO *)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                    Assert(psa != NULL);

                    hwndT = GetDlgItem(hwndDlg, IDC_EDT1);
                    nCount = (int) SendMessage(hwndT, WM_GETTEXT, MAX_PATH, (LPARAM)psa->szFile);
					if(nCount)
					{
						//Make sure that the file is valid
						if(FindFirstFile(psa->szFile, &pWinFind) != INVALID_HANDLE_VALUE)
						{
							EndDialog(hwndDlg, id);
							return TRUE;
						}
					}
					//No file was selected. Do not end the dialog. Put up a messagebox asking the user to slect a valid file.
					ImpMessageBox(hwndDlg, MAKEINTRESOURCE(idsImportTitle), MAKEINTRESOURCE(idsErrorMailIni), NULL, MB_OK | MB_ICONSTOP);
					return TRUE;

                    // fall through

                case IDCANCEL:
                    EndDialog(hwndDlg, id);
                    return(TRUE);

				case IDC_BUTT1:
						*szFile = 0;

						// replace the '|' characters in the filter string with nulls.
						nCount = 0;
						nLen = LoadString(g_hInstImp, idsFilterMailIni, szFilter, ARRAYSIZE(szFilter));
						while (i < nLen)
						{
							if (szFilter[i] == '|')
							{
								szFilter[i] = '\0';
								nCount++;
							}
							i++;
						}

						ZeroMemory (&ofn, sizeof(ofn));
						ofn.lStructSize = sizeof(ofn);
						ofn.hwndOwner = hwndDlg;
						ofn.lpstrFilter = szFilter;
						ofn.nFilterIndex = 1;
						ofn.lpstrFile = szFile;
						ofn.nMaxFile = sizeof(szFile);
						ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

						if(GetOpenFileName(&ofn))
						{
                            hwndT = GetDlgItem(hwndDlg, IDC_EDT1);
		                    SendMessage(hwndT, WM_SETTEXT, MAX_PATH, (LPARAM)szFile);
						}
						return TRUE;
                }
            break;
        }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\athena16\impath16.h ===
#ifndef _INC_ATHENAIMP_H
#define _INC_ATHENAIMP_H

// {B7AAC060-2638-11d1-83A9-00C04FBD7C09}
DEFINE_GUID(CLSID_CAthena16Import, 0xb7aac060, 0x2638, 0x11d1, 0x83, 0xa9, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

#define ATH_HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_FIRST 0x1000 // Put at the bottom

#define hrNoMessages 780
#define hrMemory                                E_OUTOFMEMORY
#define hrCorruptMessage                        ATH_HR_E(HR_FIRST + 42)
#define hrReadFile                              ATH_HR_E(HR_FIRST + 30)


typedef struct tagzMsgHeader
{
	char ver;
	ULONG TotalMessages;
	ULONG ulTotalUnread;
}MsgHeader;

class CAthena16FOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG			m_cRef;
        EUDORANODE*	m_plist;
        EUDORANODE*	m_pnext;

    public:
        CAthena16FOLDERS(EUDORANODE *plist);
        ~CAthena16FOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CAthena16Import : public IMailImport
    {
    private:
        ULONG			m_cRef;
        EUDORANODE		*m_plist;
        BOOL			m_bDraft;
        char			m_szUser[MAX_PATH];
		char			m_szIniFile[MAX_PATH];
	

    public:
        CAthena16Import(void);
        ~CAthena16Import(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
		
		//class member functions

		HRESULT GetUserDir(char *szDir, UINT cch);


    };

INT_PTR CALLBACK SelectAth16UserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT GetAthSubFolderList(LPTSTR szInstallPath, EUDORANODE **ppList, EUDORANODE *);
void GetNewRecurseFolder(LPTSTR szInstallPath, LPTSTR szDir, LPTSTR szInstallNewPath);
HRESULT ProcessMessages(LPTSTR szFileName, IFolderImport *pImport);
long GetMessageCount(HANDLE hFile);
HRESULT ProcessMsgList(HANDLE hFile,LPTSTR szPath, IFolderImport* pImport);
HRESULT GetMsgFileName(LPCSTR szmsgbuffer,char *szfilename);
HANDLE OpenMsgFile(LPTSTR szFileName);
HRESULT	GetFileinBuffer(HANDLE hnd,LPTSTR *szBuffer);
HRESULT	ProcessSingleMessage(LPTSTR szBuffer, DWORD dwFlags, IFolderImport* pImport);
HRESULT ParseMsgBuffer(LPTSTR szmsgbuffer,LPTSTR szPath, IFolderImport* pImport);
int GetNumUsers(char *szFile, char *szUser);
HRESULT	GetMessageFlag(char *szmsgbuffer, LPDWORD pdwFlags);

#endif // _INC_ATHENAIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\eudora\eudrimp.h ===
#ifndef _INC_EUDRIMP_H
#define _INC_EUDRIMP_H

// {0A522730-A626-11D0-8D60-00C04FD6202B}
DEFINE_GUID(CLSID_CEudoraImport, 0x0A522730L, 0xA626, 0x11D0, 0x8D, 0x60, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

#define MBX_FILE    1
#define FOL_FILE    2

typedef struct tagEUDORANODE
    {
    struct tagEUDORANODE *pnext;
    struct tagEUDORANODE *pchild;
    struct tagEUDORANODE *pparent;

    int depth;
    IMPORTFOLDERTYPE type;
    int iFileType;  // mbx or fol
    TCHAR szName[MAX_PATH];

    TCHAR szFile[MAX_PATH];     // mbx file or fol directory
    } EUDORANODE;

class CEudoraEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG           m_cRef;
        EUDORANODE      *m_plist;
        EUDORANODE      *m_pnext;

    public:
        CEudoraEnumFOLDERS(EUDORANODE *plist);
        ~CEudoraEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CEudoraImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        EUDORANODE      *m_plist;

    public:
        CEudoraImport(void);
        ~CEudoraImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
    };

void EudoraFreeFolderList(EUDORANODE *pnode);

#endif // _INC_EUDRIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\dll\makefile.inc ===
$(O)\imnimp.res : $(O)\selfreg.inf

..\selfreg.src : ..\reg.src ..\strings.src

$(O)\selfreg.inx : ..\selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\exchange\mapiconv.cpp ===
// =====================================================================================
// m a p c o n v . c p p
// conver a MAPI message to and from an RFC 822/RFC 1521 (mime) internet message
// =====================================================================================
#include "pch.hxx"
#include <newimp.h>
#include "Imnapi.h"
#include "Mapiconv.h"
#include <impapi.h>
#include <import.h>
#include "demand.h"

LPSTR  MapiStringDup (LPCTSTR lpcsz, LPVOID lpobj);

HRESULT HrImsgRecipToMapiRecip(LPMESSAGE lpMessage, LPIMSG lpImsg);
HRESULT HrImsgAttachToMapiAttach(LPMESSAGE lpMessage, LPIMSG lpImsg);

// =====================================================================================
// MAPI Message Properties that I want
// =====================================================================================
#define PR_BODY_HTML    PROP_TAG( PT_TSTRING,	0x1013)

enum 
{ 
    colSenderAddrType,
    colSenderName,
    colSenderEMail,
    colDelegateAddrType,
    colDelegateName,
    colDelegateEMail,
    colSubject, 
    colReceiveTime,
    colSendTime,
    colPriority,
    colFlags,
    colLast1
};

SizedSPropTagArray (colLast1, sptMessageProps) = 
{ 
	colLast1, 
	{
        PR_SENDER_ADDRTYPE,
        PR_SENDER_NAME,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SENT_REPRESENTING_ADDRTYPE,
        PR_SENT_REPRESENTING_NAME,
        PR_SENT_REPRESENTING_EMAIL_ADDRESS,
        PR_SUBJECT,
        PR_MESSAGE_DELIVERY_TIME,
        PR_CLIENT_SUBMIT_TIME,
        PR_IMPORTANCE,
        PR_MESSAGE_FLAGS
    }
};

// =====================================================================================
// MAPI Recip Props
// =====================================================================================
enum 
{ 
    colRecipAddrType,
    colRecipName,
    colRecipAddress,
    colRecipType,
    colLast2
};

SizedSPropTagArray (colLast2, sptRecipProps) = 
{ 
	colLast2, 
	{
        PR_ADDRTYPE,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_RECIPIENT_TYPE
    }
};

// =====================================================================================
// MAPI Attachment Props
// =====================================================================================
enum 
{ 
    colAttMethod,
    colAttNum,
    colAttLongFilename,
    colAttPathname,
    colAttTag,
    colAttFilename,
    colAttExtension,
    colAttSize,
    colLast3
};

SizedSPropTagArray (colLast3, sptAttProps) = 
{ 
	colLast3, 
	{
        PR_ATTACH_METHOD,
        PR_ATTACH_NUM,
        PR_ATTACH_LONG_FILENAME,
        PR_ATTACH_PATHNAME,
        PR_ATTACH_TAG,
        PR_ATTACH_FILENAME,
        PR_ATTACH_EXTENSION,
        PR_ATTACH_SIZE
    }
};

char *GetRecipAddress(LPSPropValue ppropAddr, LPSPropValue ppropType)
    {
    char *sz, *szT;

    sz = NULL;

    if (PROP_TYPE(ppropAddr->ulPropTag) != PT_ERROR &&
        PROP_TYPE(ppropType->ulPropTag) != PT_ERROR)
        {
        szT = ppropType->Value.lpszA;

        if (lstrcmp(szT, "SMTP") == 0 || lstrcmp(szT, "MSNINET") == 0)
            {
            sz = PszDup(ppropAddr->Value.lpszA);
            }
        else if (lstrcmp(szT, "MSN") == 0 || lstrcmp(szT, "MSNLIST") == 0)
            {
            szT = ppropAddr->Value.lpszA;
            if (MemAlloc((void **)&sz, lstrlen(szT) + 16))
                {
                lstrcpy(sz, szT);
                lstrcat(sz, "@msn.com");
                }
            }
        }

    return(sz);
    }

// =====================================================================================
// HrMapiToImsg
// =====================================================================================
HRESULT HrMapiToImsg (LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    // Locals
    LPSPropValue    ppropAddr, ppropType, ppropName;
    TCHAR           szUnk[128];
    int             cchUnk;
    TCHAR           *sz, *szT;
    HRESULT         hr;
    ULONG           cProp, i;
	LPSPropValue	lpMsgPropValue = NULL;
    LPSRowSet       lpRecipRows = NULL, lpAttRows = NULL;
    LPMAPITABLE     lptblRecip = NULL, lptblAtt = NULL;
    LPATTACH        lpAttach = NULL;
    LPMESSAGE       lpMsgAtt = NULL;
    LPSTREAM        lpstmBody = NULL;

    cchUnk = LoadString(g_hInstImp, idsAddressUnknownFmt, szUnk, ARRAYSIZE(szUnk));

    // Zero init
    ZeroMemory (lpImsg, sizeof (IMSG));

    // Get the propsw
    hr = lpMessage->GetProps ((LPSPropTagArray)&sptMessageProps, 0, &cProp, &lpMsgPropValue);
    if (FAILED (hr))
        goto exit;

    // Subject
    if (PROP_TYPE(lpMsgPropValue[colSubject].ulPropTag) != PT_ERROR)
        lpImsg->lpszSubject = PszDup(lpMsgPropValue[colSubject].Value.lpszA);

    // Body
    if (SUCCEEDED(lpMessage->OpenProperty(PR_BODY_HTML, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpstmBody)))
        {
        if (SUCCEEDED(hr = CreateStreamOnHFile (NULL, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpstmHtml)))
            hr = HrCopyStream(lpstmBody, lpImsg->lpstmHtml, NULL);

        lpstmBody->Release();
        lpstmBody = NULL;

        if (FAILED(hr))
            goto exit;
        }
    else if (SUCCEEDED(lpMessage->OpenProperty(PR_BODY, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpstmBody)))
        {
        if (SUCCEEDED(hr = CreateStreamOnHFile (NULL, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpstmBody)))
            hr = HrCopyStream(lpstmBody, lpImsg->lpstmBody, NULL);

        lpstmBody->Release();
        lpstmBody = NULL;
        
        if (FAILED(hr))
            goto exit;
        }

    // Send Time
    if (PROP_TYPE(lpMsgPropValue[colSendTime].ulPropTag) != PT_ERROR)
        CopyMemory(&lpImsg->ftSend, &lpMsgPropValue[colSendTime].Value.ft, sizeof (FILETIME));

    // Receive Time
    if (PROP_TYPE(lpMsgPropValue[colReceiveTime].ulPropTag) != PT_ERROR)
        CopyMemory(&lpImsg->ftReceive, &lpMsgPropValue[colReceiveTime].Value.ft, sizeof (FILETIME));

    // Priority
    lpImsg->wPriority = PRI_NORMAL;
    if (PROP_TYPE(lpMsgPropValue[colPriority].ulPropTag) != PT_ERROR)
    {
        switch (lpMsgPropValue[colPriority].Value.l)
        {
        case IMPORTANCE_LOW:
            lpImsg->wPriority = PRI_LOW;
            break;

        case IMPORTANCE_HIGH:
            lpImsg->wPriority = PRI_HIGH;
            break;

        case IMPORTANCE_NORMAL:
        default:
            lpImsg->wPriority = PRI_NORMAL;
            break;
       }
    }

    // message flags
    if (PROP_TYPE(lpMsgPropValue[colFlags].ulPropTag) != PT_ERROR)
        lpImsg->uFlags = lpMsgPropValue[colFlags].Value.ul;

    // Get the recipient table
    hr = lpMessage->GetRecipientTable (0, &lptblRecip);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = lpHrQueryAllRows (lptblRecip, (LPSPropTagArray)&sptRecipProps, NULL, NULL, 0, &lpRecipRows);
    if (FAILED (hr))
        goto exit;

    // Allocate Recipient Array
    lpImsg->cAddress = lpRecipRows->cRows + 1;
    if (!MemAlloc((void **)&lpImsg->lpIaddr, sizeof (IADDRINFO) * lpImsg->cAddress))
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }
    ZeroMemory(lpImsg->lpIaddr, sizeof (IADDRINFO) * lpImsg->cAddress);

    ppropAddr = &lpMsgPropValue[colDelegateEMail];
    ppropType = &lpMsgPropValue[colDelegateAddrType];
    ppropName = &lpMsgPropValue[colDelegateName];

    if (PROP_TYPE(ppropAddr->ulPropTag) == PT_ERROR ||
        PROP_TYPE(ppropType->ulPropTag) == PT_ERROR)
    {
        ppropAddr = &lpMsgPropValue[colSenderEMail];
        ppropType = &lpMsgPropValue[colSenderAddrType];
        ppropName = &lpMsgPropValue[colSenderName];
    }

    // Originator of the message "From: "
    lpImsg->lpIaddr[0].dwType = IADDR_FROM;
    lpImsg->lpIaddr[0].lpszAddress = GetRecipAddress(ppropAddr, ppropType);

    if (PROP_TYPE(ppropName->ulPropTag) != PT_ERROR)
        {
        szT = ppropName->Value.lpszA;
        if (lpImsg->lpIaddr[0].lpszAddress != NULL)
            {
            sz = PszDup(szT);
            }
        else
            {
            lpImsg->lpIaddr[0].lpszAddress = PszDup(szT);
            if (!MemAlloc((void **)&sz, lstrlen(szT) + cchUnk))
                {
                hr = E_OUTOFMEMORY;
                goto exit;
                }
            wsprintf(sz, szUnk, szT);
            }

        lpImsg->lpIaddr[0].lpszDisplay = sz;
        }
    
    // Add in the rest of the recipients
	for (i=0; i<lpRecipRows->cRows; i++)
	    {	
        Assert (i+1 < lpImsg->cAddress);

        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipType].ulPropTag) != PT_ERROR)
            {
            switch (lpRecipRows->aRow[i].lpProps[colRecipType].Value.ul)
                {
                case MAPI_TO:
                case 0x10000000: /* MAPI_P1: */
                    lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                    break;

                case MAPI_ORIG:
                    lpImsg->lpIaddr[i+1].dwType = IADDR_FROM;
                    break;

                case MAPI_CC:
                    lpImsg->lpIaddr[i+1].dwType = IADDR_CC;
                    break;

                case MAPI_BCC:
                    lpImsg->lpIaddr[i+1].dwType = IADDR_BCC;
                    break;

                default:
                    Assert (FALSE);
                    lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
                    break;
                }
            }
        else
            {
            lpImsg->lpIaddr[i+1].dwType = IADDR_TO;
            }
        
        lpImsg->lpIaddr[i+1].lpszAddress = GetRecipAddress(&lpRecipRows->aRow[i].lpProps[colRecipAddress], &lpRecipRows->aRow[i].lpProps[colRecipAddrType]);

        if (PROP_TYPE(lpRecipRows->aRow[i].lpProps[colRecipName].ulPropTag) != PT_ERROR)
            {
            szT = lpRecipRows->aRow[i].lpProps[colRecipName].Value.lpszA;
            if (lpImsg->lpIaddr[i + 1].lpszAddress != NULL)
                {
                sz = PszDup(szT);
                }
            else
                {
                lpImsg->lpIaddr[i+1].lpszAddress = PszDup(szT);
                if (!MemAlloc((void **)&sz, lstrlen(szT) + cchUnk))
                    {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                    }
                wsprintf(sz, szUnk, szT);
                }

            lpImsg->lpIaddr[i + 1].lpszDisplay = sz;
            }
	    }

    // Free Rows
    if (lpRecipRows)
        lpFreeProws (lpRecipRows);
    lpRecipRows = NULL;

    // Attachments
    hr = lpMessage->GetAttachmentTable (0, &lptblAtt);
    if (FAILED (hr))
        goto exit;

    // Get all the rows of the recipient table
    hr = lpHrQueryAllRows (lptblAtt, (LPSPropTagArray)&sptAttProps, NULL, NULL, 0, &lpAttRows);
    if (FAILED (hr))
        goto exit;

    // Allocate files list
    if (lpAttRows->cRows == 0)
        goto exit;

    // Allocate memory
    lpImsg->cAttach = lpAttRows->cRows;
    if (!MemAlloc((void **)&lpImsg->lpIatt, sizeof (IATTINFO) * lpImsg->cAttach))
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }

    // Zero init
    ZeroMemory (lpImsg->lpIatt, sizeof (IATTINFO) * lpImsg->cAttach);

    // Walk the rows
	for (i=0; i<lpAttRows->cRows; i++)
	{	
        if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttMethod].ulPropTag) != PT_ERROR &&
            PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttNum].ulPropTag) != PT_ERROR)
        {
            // Basic Properties
            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttPathname].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttPathname].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszPathName = PszDup(sz);
                }

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttFilename].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttFilename].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszFileName = PszDup(sz);
                }

            if (lpImsg->lpIatt[i].lpszFileName == NULL &&
                PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttLongFilename].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttLongFilename].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszFileName = PszDup(sz);
                }

            if (PROP_TYPE(lpAttRows->aRow[i].lpProps[colAttExtension].ulPropTag) != PT_ERROR)
                {
                sz = lpAttRows->aRow[i].lpProps[colAttExtension].Value.lpszA;
                if (!FIsEmpty(sz))
                    lpImsg->lpIatt[i].lpszExt = PszDup(sz);
                }

            // Open the attachment
            hr = lpMessage->OpenAttach (lpAttRows->aRow[i].lpProps[colAttNum].Value.l, NULL, MAPI_BEST_ACCESS, &lpAttach);
            if (FAILED (hr))
            {
                lpImsg->lpIatt[i].fError = TRUE;
                continue;
            }

            // Handle the attachment method
            switch (lpAttRows->aRow[i].lpProps[colAttMethod].Value.ul)
            {
            case NO_ATTACHMENT:
                lpImsg->lpIatt[i].dwType = 0;
                lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_RESOLVE:
            case ATTACH_BY_VALUE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_BIN, (LPIID)&IID_IStream, 0, 0, (LPUNKNOWN *)&lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_BY_REF_ONLY:
            case ATTACH_BY_REFERENCE:
                lpImsg->lpIatt[i].dwType = IATT_FILE;
                hr = CreateStreamOnHFile (lpImsg->lpIatt[i].lpszPathName, GENERIC_READ,  FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &lpImsg->lpIatt[i].lpstmAtt);
                if (FAILED (hr))
                    lpImsg->lpIatt[i].fError = TRUE;
                break;

            case ATTACH_EMBEDDED_MSG:
                lpImsg->lpIatt[i].dwType = IATT_MSG;
                hr = lpAttach->OpenProperty (PR_ATTACH_DATA_OBJ, (LPIID)&IID_IMessage, 0, 0, (LPUNKNOWN *)&lpMsgAtt);
                if (FAILED (hr) || lpMsgAtt == NULL)
                    lpImsg->lpIatt[i].fError = TRUE;
                else
                {
                    if (!MemAlloc((void **)&lpImsg->lpIatt[i].lpImsg, sizeof (IMSG)))
                        lpImsg->lpIatt[i].fError = TRUE;
                    else
                    {
                        hr = HrMapiToImsg (lpMsgAtt, lpImsg->lpIatt[i].lpImsg);
                        if (FAILED (hr))
                            lpImsg->lpIatt[i].fError = TRUE;
                    }    
                    lpMsgAtt->Release ();
                    lpMsgAtt = NULL;
                }
                break;

            case ATTACH_OLE:
            default:
                lpImsg->lpIatt[i].dwType = IATT_OLE;
                lpImsg->lpIatt[i].fError = TRUE;
                break;
            }

            // Free Attachment
            if (lpAttach)
                lpAttach->Release ();
            lpAttach = NULL;
        }
    }

    hr = S_OK;

exit:
    // Cleanup
    if (lpAttach)
        lpAttach->Release ();
    if (lptblAtt)
        lptblAtt->Release ();
    if (lpAttRows)
        lpFreeProws (lpAttRows);
    if (lpRecipRows)
        lpFreeProws (lpRecipRows);
    if (lpMsgPropValue)
        lpMAPIFreeBuffer (lpMsgPropValue);
    if (lptblRecip)
        lptblRecip->Release ();
    if (lpMsgAtt)
        lpMsgAtt->Release ();
    if (lpstmBody)
        lpstmBody->Release ();

    // Done
    return hr;
}

// =====================================================================================
//
// HrImsgToMapi: lpImsg => lpMessage
//
// assumes lpMessage is initialized.
// 
// =====================================================================================
HRESULT HrImsgToMapi(LPIMSG lpImsg, LPMESSAGE lpMessage)
{
    // Locals
    LPSTREAM        lpstmBody;
    HRESULT         hr = S_OK;
    ULONG           i, cProp;
	LPSPropValue	lpMsgPropValue = NULL;
    ULONG           cPropMax = 13;

    /*
        properties to copy:

        PR_SENDER_ADDRTYPE,
        PR_SENDER_NAME,
        PR_SENDER_EMAIL_ADDRESS,
        PR_SUBJECT,
        PR_MESSAGE_DELIVERY_TIME,
        PR_IMPORTANCE,
        PR_MESSAGE_FLAGS
        PR_MESSAGE_CLASS
        PR_SENT_REPRESENTING_NAME,
        PR_SENT_REPRESENTING_EMAIL_ADDRESS,
        PR_SENT_REPRESENTING_ADDRTYPE,
    */

    Assert(lpMessage != NULL);

    // create the propvalue array
    hr = lpMAPIAllocateBuffer(cPropMax*sizeof(SPropValue), (LPVOID FAR*)&lpMsgPropValue);
    if (FAILED(hr))
        goto exit;

    ZeroMemory(lpMsgPropValue, cPropMax*sizeof(SPropValue));
    cProp = 0;
    
    lpMsgPropValue[cProp].Value.lpszA = MapiStringDup("IPM.Note", lpMsgPropValue);
    lpMsgPropValue[cProp].ulPropTag = PR_MESSAGE_CLASS;
    cProp++;

    // Subject
    if (lpImsg->lpszSubject)
        {
        lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpszSubject, lpMsgPropValue);
        lpMsgPropValue[cProp].ulPropTag = PR_SUBJECT;
        cProp++;
        Assert(cProp <= cPropMax);
        }

    // Send Time
    CopyMemory(&lpMsgPropValue[cProp].Value.ft, &lpImsg->ftSend, sizeof (FILETIME));
    lpMsgPropValue[cProp].ulPropTag = PR_CLIENT_SUBMIT_TIME;
    cProp++;
    Assert(cProp <= cPropMax);

    // Receive Time
    CopyMemory(&lpMsgPropValue[cProp].Value.ft, &lpImsg->ftReceive, sizeof (FILETIME));
    lpMsgPropValue[cProp].ulPropTag = PR_MESSAGE_DELIVERY_TIME;
    cProp++;
    Assert(cProp <= cPropMax);

    // Priority
    lpMsgPropValue[cProp].ulPropTag = PR_IMPORTANCE;
    switch (lpImsg->wPriority)
    {
    case PRI_HIGH:
        lpMsgPropValue[cProp].Value.l = IMPORTANCE_HIGH;
        break;

    case PRI_LOW:
        lpMsgPropValue[cProp].Value.l = IMPORTANCE_LOW;
        break;

    case PRI_NORMAL:
    default:
        lpMsgPropValue[cProp].Value.l = IMPORTANCE_NORMAL;
        break;
    }
    cProp++;
    Assert(cProp <= cPropMax);

    // Message flags
    lpMsgPropValue[cProp].ulPropTag = PR_MESSAGE_FLAGS;
    lpMsgPropValue[cProp].Value.ul  = lpImsg->uFlags;
    cProp++;
    Assert(cProp <= cPropMax);

    // recipients
    if (FAILED(hr = HrImsgRecipToMapiRecip(lpMessage, lpImsg)))
        goto exit;

    // sender information
    for (i = 0; i < lpImsg->cAddress; i++)
        {
        Assert(lpImsg->lpIaddr != NULL);

        if (lpImsg->lpIaddr[i].dwType == IADDR_FROM)
            {
            Assert(lpImsg->lpIaddr[i].lpszAddress);
            Assert(lpImsg->lpIaddr[i].lpszDisplay);

            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszDisplay, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENDER_NAME;
            cProp++;
            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszDisplay, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENT_REPRESENTING_NAME;
            cProp++;
            Assert(cProp <= cPropMax);

            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszAddress, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENDER_EMAIL_ADDRESS;
            cProp++;
            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup(lpImsg->lpIaddr[i].lpszAddress, lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENT_REPRESENTING_EMAIL_ADDRESS;
            cProp++;
            Assert(cProp <= cPropMax);

            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup("SMTP", lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENDER_ADDRTYPE;
            cProp++;
            lpMsgPropValue[cProp].Value.lpszA = MapiStringDup("SMTP", lpMsgPropValue);
            lpMsgPropValue[cProp].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE;
            cProp++;
            Assert(cProp <= cPropMax);

            break;
            }
        }

    // attachment information
    if (FAILED(hr = HrImsgAttachToMapiAttach(lpMessage, lpImsg)))
        goto exit;

    // save changes
    if (FAILED(hr = lpMessage->SetProps(cProp, lpMsgPropValue, NULL)))
        goto exit;

    // Body
    if (lpImsg->lpstmHtml &&
        SUCCEEDED(lpMessage->OpenProperty(PR_BODY_HTML, (LPIID)&IID_IStream, 0, MAPI_CREATE | MAPI_MODIFY, (LPUNKNOWN *)&lpstmBody)))
        {
        hr = HrCopyStream(lpImsg->lpstmHtml, lpstmBody, NULL);

        lpstmBody->Release();

        if (FAILED(hr))
            goto exit;
        }

    if (lpImsg->lpstmBody &&
        SUCCEEDED(lpMessage->OpenProperty(PR_BODY, (LPIID)&IID_IStream, 0, MAPI_CREATE | MAPI_MODIFY, (LPUNKNOWN *)&lpstmBody)))
        {
        hr = HrCopyStream(lpImsg->lpstmBody, lpstmBody, NULL);

        lpstmBody->Release();
        
        if (FAILED(hr))
            goto exit;
        }

    if (FAILED(hr = lpMessage->SaveChanges(0)))
        goto exit;

exit:
    if (lpMsgPropValue)
        lpMAPIFreeBuffer (lpMsgPropValue);

    return hr;
}

HRESULT HrImsgAttachToMapiAttach(LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    ULONG           i, iAttach;
    HRESULT         hr = S_OK;

    if (!lpMessage || !lpImsg)
        return E_FAIL;

    if (lpImsg->cAttach == 0)
        return S_OK;

    if (!lpImsg->lpIatt)
        return E_FAIL;

    /*
    attachment properties and indices:

    colAttMethod,
    colAttNum,
    colAttLongFilename,
    colAttPathname,
    colAttTag,
    colAttFilename,
    colAttExtension,
    colAttSize,
    colLast3

    PR_ATTACH_METHOD,
    PR_ATTACH_NUM,
    PR_ATTACH_LONG_FILENAME,
    PR_ATTACH_PATHNAME,
    PR_ATTACH_TAG,
    PR_ATTACH_FILENAME,
    PR_ATTACH_EXTENSION,
    PR_ATTACH_SIZE
    */

    for (i=0; i<lpImsg->cAttach; i++)
        {
        LPSPropValue    rgPropVals = 0;
        ULONG           cb = 0, cProp = 0;
        HRESULT         hropen;
        LPMESSAGE       lpmsg = NULL;
        LPSTREAM        lpstm = 0;
        LPIATTINFO      lpiatt = (LPIATTINFO)&(lpImsg->lpIatt[i]);
        LPATTACH        lpAttach = 0;
        Assert(lpiatt);

        if (lpiatt->fError)
            continue;

        if (FAILED(lpMessage->CreateAttach(NULL, NULL, &iAttach, &lpAttach)))
            goto cleanup;

        if (FAILED(lpMAPIAllocateBuffer(sizeof(SPropValue)*colLast3, (LPVOID*)&rgPropVals)))
            goto cleanup;

        ZeroMemory(rgPropVals, sizeof(SPropValue)*colLast3);

        if (lpiatt->lpszPathName)
            {
            rgPropVals[cProp].ulPropTag   = PR_ATTACH_PATHNAME;
            rgPropVals[cProp].Value.lpszA = MapiStringDup(lpiatt->lpszPathName, rgPropVals);
            cProp++;
            }

        if (lpiatt->lpszFileName)
            {
            rgPropVals[cProp].ulPropTag   = PR_ATTACH_FILENAME;
            rgPropVals[cProp].Value.lpszA = MapiStringDup(lpiatt->lpszFileName, rgPropVals);
            cProp++;
            }

        if (lpiatt->lpszExt)
            {
            rgPropVals[cProp].ulPropTag    = PR_ATTACH_EXTENSION;
            rgPropVals[cProp].Value.lpszA  = MapiStringDup(lpiatt->lpszExt, rgPropVals);
            cProp++;
            }

        switch(lpiatt->dwType)
            {
            case IATT_FILE:
                rgPropVals[cProp].ulPropTag = PR_OBJECT_TYPE;
                rgPropVals[cProp].Value.ul = MAPI_ATTACH;
                cProp++;

                rgPropVals[cProp].ulPropTag = PR_ATTACH_METHOD;
                rgPropVals[cProp].Value.ul = ATTACH_BY_VALUE;
                cProp++;

                hropen = lpAttach->OpenProperty(PR_ATTACH_DATA_BIN, (LPIID)&IID_IStream,
                                                STGM_WRITE, MAPI_MODIFY | MAPI_CREATE,
                                                (LPUNKNOWN *)&lpstm); 
                if (!FAILED(hropen))
                    {
                    Assert(lpstm != NULL);

                    if (!FAILED(HrCopyStream(lpiatt->lpstmAtt, lpstm, &cb)))
                        lpstm->Commit(0);

                    lpstm->Release();
                    lpstm=0;
                    }
                break;

            case IATT_MSG:
                rgPropVals[cProp].ulPropTag = PR_OBJECT_TYPE;
                rgPropVals[cProp].Value.ul = MAPI_MESSAGE;
                cProp++;

                rgPropVals[cProp].ulPropTag = PR_ATTACH_METHOD;
                rgPropVals[cProp].Value.ul = ATTACH_EMBEDDED_MSG;
                cProp++;

                hropen = lpAttach->OpenProperty(PR_ATTACH_DATA_OBJ, (LPIID)&IID_IMessage,
                                                0, MAPI_MODIFY | MAPI_CREATE,
                                                (LPUNKNOWN *)&lpmsg); 
                if (!FAILED(hropen))
                    {
                    Assert(lpmsg != NULL);

                    HrImsgToMapi(lpiatt->lpImsg, lpmsg);

                    lpmsg->Release();
                    lpmsg = NULL;
                    }
                break;

            default:
                AssertSz(FALSE, "Unexpected attachment type!");
                break;
            }

        // need to set the property
        hr = lpAttach->SetProps(cProp, rgPropVals, NULL);
        if (FAILED(hr))
            goto cleanup;
        hr = lpAttach->SaveChanges(0);
        if (FAILED(hr))
            goto cleanup;

cleanup:
        if (rgPropVals)
            {
            lpMAPIFreeBuffer(rgPropVals);
            rgPropVals = 0;
            }

        if (lpAttach)
            {
            lpAttach->Release();
            lpAttach = 0;
            }
        }

    return hr;
}

// =====================================================================================
// 
// HrImsgRecipToMapiRecip:
// 
// =====================================================================================
HRESULT HrImsgRecipToMapiRecip(LPMESSAGE lpMessage, LPIMSG lpImsg)
{
    LPADRENTRY      lpadrentry;
    ULONG           cb, i;
    LPADRLIST       lpadrlist = 0;
    LPSPropValue    rgPropVals = 0;
    HRESULT         hr = E_FAIL;
               
    if (lpImsg == NULL)
        return(E_FAIL);

    if (lpImsg->cAddress == 0)
        return(S_OK);

    if (lpMessage == NULL || lpImsg->lpIaddr == NULL)
        return(E_FAIL);

    cb = sizeof(ADRLIST) + lpImsg->cAddress * sizeof(ADRENTRY);
    if (FAILED(lpMAPIAllocateBuffer(cb, (LPVOID*)&lpadrlist)))
        return(E_OUTOFMEMORY);

    ZeroMemory(lpadrlist, cb);

    // enumerate through the recipient list
    for (i = 0; i < lpImsg->cAddress; i++)
        {
        if (lpImsg->lpIaddr[i].dwType == IADDR_FROM)
            continue;

        lpadrentry = (LPADRENTRY)&(lpadrlist->aEntries[lpadrlist->cEntries]);

        // this memory is freed by lpMessage
        if (FAILED(lpMAPIAllocateBuffer(sizeof(SPropValue) * colLast2, (LPVOID *)&rgPropVals)))
            {
            hr = E_OUTOFMEMORY;
            goto exit;
            }

        lpadrentry->cValues    = 0;
        lpadrentry->rgPropVals = rgPropVals;
        lpadrlist->cEntries++;

        rgPropVals[colRecipAddrType].ulPropTag   = PR_ADDRTYPE;
        rgPropVals[colRecipAddrType].Value.lpszA = MapiStringDup("SMTP", rgPropVals);
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        rgPropVals[colRecipName].ulPropTag       = PR_DISPLAY_NAME;
        rgPropVals[colRecipName].Value.lpszA     = MapiStringDup(lpImsg->lpIaddr[i].lpszDisplay, rgPropVals);
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        rgPropVals[colRecipAddress].ulPropTag    = PR_EMAIL_ADDRESS;
        rgPropVals[colRecipAddress].Value.lpszA  = MapiStringDup(lpImsg->lpIaddr[i].lpszAddress, rgPropVals);
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        rgPropVals[colRecipType].ulPropTag       = PR_RECIPIENT_TYPE;
        switch(lpImsg->lpIaddr[i].dwType)
            {
            case IADDR_FROM:
                rgPropVals[colRecipType].Value.ul = MAPI_ORIG;
                break;

            case IADDR_CC:
                rgPropVals[colRecipType].Value.ul = MAPI_CC;
                break;

            case IADDR_BCC:
                rgPropVals[colRecipType].Value.ul = MAPI_BCC;
                break;

            case IADDR_TO:
            default:
                rgPropVals[colRecipType].Value.ul = MAPI_TO;       
                break;
            }
        lpadrentry->cValues++;
        Assert(lpadrentry->cValues <= colLast2);

        // reset the variable so we don't free up on exit
        rgPropVals = 0;
        }

    hr = lpMessage->ModifyRecipients(MODRECIP_ADD, lpadrlist);
        
exit:
    // Free the buffers
    for (i = 0; i < lpadrlist->cEntries; i++)
        lpMAPIFreeBuffer(lpadrlist->aEntries[i].rgPropVals);
    lpMAPIFreeBuffer(lpadrlist);

    return(hr);
    }

LPSTR  MapiStringDup (LPCTSTR lpcsz, LPVOID lpobj)
{
    LPSTR       lpszDup = NULL;

    if (lpcsz == NULL)
        return NULL;

    INT nLen = lstrlen (lpcsz) + 1;

    if (lpobj)
        {
        if (FAILED(lpMAPIAllocateMore(nLen*sizeof(TCHAR), lpobj, (LPVOID FAR*)&lpszDup)))
            return NULL;
        }
    else
        {
        if (FAILED(lpMAPIAllocateBuffer(nLen*sizeof(TCHAR), (LPVOID FAR*)&lpszDup)))
            return NULL;
        }

    CopyMemory (lpszDup, lpcsz, nLen);

    return lpszDup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\exchange\mapiconv.h ===
// =====================================================================================
// MAPI IMessage to IMN message
// =====================================================================================
#ifndef __MAPICONV_H
#define __MAPICONV_H

// {0A522732-A626-11D0-8D60-00C04FD6202B}
DEFINE_GUID(CLSID_CExchImport, 0x0A522732L, 0xA626, 0x11D0, 0x8D, 0x60, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

#include "MAPI.H"
#include "MAPIX.H"

typedef struct tagIMPFOLDERNODE IMPFOLDERNODE;

typedef void (STDAPICALLTYPE FREEPROWS)(LPSRowSet lpRows);
typedef FREEPROWS FAR *LPFREEPROWS;

typedef HRESULT (STDAPICALLTYPE HRQUERYALLROWS)(LPMAPITABLE lpTable, 
                        LPSPropTagArray lpPropTags,
                        LPSRestriction lpRestriction,
                        LPSSortOrderSet lpSortOrderSet,
                        LONG crowsMax,
                        LPSRowSet FAR *lppRows);
typedef HRQUERYALLROWS FAR *LPHRQUERYALLROWS;

typedef HRESULT (STDAPICALLTYPE WRAPCOMPRESSEDRTFSTREAM)(LPSTREAM lpCompressedRTFStream,
                        ULONG ulFlags,
                        LPSTREAM FAR * lpUncompressedRTFStream);
typedef WRAPCOMPRESSEDRTFSTREAM FAR *LPWRAPCOMPRESSEDRTFSTREAM;

extern HMODULE g_hlibMAPI;

extern LPMAPILOGONEX        lpMAPILogonEx;
extern LPMAPIINITIALIZE     lpMAPIInitialize;
extern LPMAPIUNINITIALIZE   lpMAPIUninitialize;
extern LPMAPIALLOCATEBUFFER lpMAPIAllocateBuffer;
extern LPMAPIALLOCATEMORE   lpMAPIAllocateMore;
extern LPMAPIFREEBUFFER     lpMAPIFreeBuffer;
extern LPFREEPROWS          lpFreeProws;
extern LPHRQUERYALLROWS     lpHrQueryAllRows;
extern LPWRAPCOMPRESSEDRTFSTREAM lpWrapCompressedRTFStream;

typedef struct IMSG IMSG, *LPIMSG;

HRESULT HrMapiToImsg(LPMESSAGE lpMessage, LPIMSG lpImsg);
HRESULT HrImsgToMapi(LPIMSG lpImsg, LPMESSAGE lpMessage);

class CExchEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG           m_cRef;
        IMPFOLDERNODE   *m_plist;
        IMPFOLDERNODE   *m_pnext;

    public:
        CExchEnumFOLDERS(IMPFOLDERNODE *plist);
        ~CExchEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CExchImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        IMPFOLDERNODE   *m_plist;
        IMAPISession    *m_pmapi;

    public:
        CExchImport(void);
        ~CExchImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
    };

#endif // __MAPICONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\eudora\eudrimp.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include "eudrimp.h"
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>
#include <shlwapi.h>

ASSERTDATA

HRESULT GetEudoraSubfolders(EUDORANODE *pparent, TCHAR *pdir, EUDORANODE **pplist);
HRESULT ProcessEudoraMsg(const BYTE *cMsgEntry, LPCSTR szBuffer1, ULONG uMsgSize, IFolderImport *pImport);
HRESULT FixEudoraMessage(LPCSTR szBuffer, ULONG uSize, BOOL fAttach, char **pszBufferNew, ULONG *puSizeNew, TCHAR ***prgszAttach, DWORD *pcAttach);
HRESULT FixSentItemDate(LPCSTR szBuffer, ULONG uMsgSize, char **szNewBuffer, ULONG *uNewMsgSize);
LPCSTR GetMultipartContentTypeHeader(LPCSTR szBuffer, LPCSTR szEnd, LPCSTR *pNext);
LPCSTR GetBody(LPCSTR szBuffer, ULONG uSize);
HRESULT FormatDate(LPCSTR szFromLine, char *szRecHdr, int cchMax);

CEudoraImport::CEudoraImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    }

CEudoraImport::~CEudoraImport()
    {
    if (m_plist != NULL)
        EudoraFreeFolderList(m_plist);

    DllRelease();
    }

ULONG CEudoraImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CEudoraImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CEudoraImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CEudoraImport::InitializeImport(HWND hwnd)
    {
	return(S_OK);
    }

HRESULT CEudoraImport::GetDirectory(char *szDir, UINT cch)
    {
	HRESULT hr;

    Assert(szDir != NULL);

    hr = GetClientDir(szDir, cch, EUDORA);
    if (FAILED(hr))
        *szDir = 0;

	return(S_OK);
    }

HRESULT CEudoraImport::SetDirectory(char *szDir)
    {
    HRESULT hr;

    Assert(szDir != NULL);
    
    if (!ValidStoreDirectory(szDir, EUDORA))
        return(S_FALSE);

    if (m_plist != NULL)
        {
        EudoraFreeFolderList(m_plist);
        m_plist = NULL;
        }

    hr = GetEudoraSubfolders(NULL, szDir, &m_plist);
	
    if (m_plist == NULL)
        hr = E_FAIL;

	return(hr);
    }

HRESULT CEudoraImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CEudoraEnumFOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CEudoraEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

STDMETHODIMP CEudoraImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    EUDORANODE *pnode;
    HRESULT hr;
	TCHAR cTocFile[MAX_PATH];
    BYTE *pToc, *pEnd, *pT, *pLast, *pMbx, *pNextMsg, *pEndMbx;
	ULONG i, lMsgs, cbToc, cbMbx, uMsgSize, uOffset;
    HANDLE mapToc, mapMbx;
	HANDLE hToc, hMbx;

    Assert(pImport != NULL);

    pnode = (EUDORANODE *)dwCookie;
    Assert(pnode != NULL);

	// check if it is a folder, folder does not contain any messages
	if (pnode->iFileType == FOL_FILE)
		return(S_OK);
	Assert(pnode->iFileType == MBX_FILE);

    hr = E_FAIL;
    pToc = NULL;
    mapToc = NULL;
    pMbx = NULL;
    mapMbx = NULL;

	lstrcpy(cTocFile, pnode->szFile);
	lstrcpy(&cTocFile[lstrlen(cTocFile) - 3], "toc");

	hMbx = CreateFile(pnode->szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMbx == INVALID_HANDLE_VALUE)
		return(hrFolderOpenFail);

    cbMbx = GetFileSize(hMbx, NULL);
    if (cbMbx == 0)
        {
        // no messages, so no point in continuing
        CloseHandle(hMbx);
        return(S_OK);
        }

	hToc = CreateFile(cTocFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hToc == INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMbx);
        return(hrFolderOpenFail);
        }

    cbToc = GetFileSize(hToc, NULL);
    if (cbToc < 104)
        {
        // the .toc file header is 104 bytes in size, so anything less
        // than this is bogus or doesn't have messages anyway, so no point
        // in continuing
        goto DoneImport;
        }

    mapToc = CreateFileMapping(hToc, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapToc == NULL)
        goto DoneImport;

    pToc = (BYTE *)MapViewOfFile(mapToc, FILE_MAP_READ, 0, 0, 0);
    if (pToc == NULL)
        goto DoneImport;

    pEnd = pToc + cbToc;

    // .toc file contains first x chars of folder name NULL terminated
    // x is usually 31 chars but we've seen cases where it is 28
    // we'll require there to be at least first 24 chars of folder name
    // because this is our only .toc file validation
    pT = &pToc[8];
    for (i = 0; i < 31; i++)
        {
        if (pT[i] == 0)
            {
            if (pnode->szName[i] == 0 || i >= 24)
                break;
            else
                goto DoneImport;
            }
        else if (pnode->szName[i] == 0 || (BYTE)pT[i] != (BYTE)pnode->szName[i])
            {
            // this is a bogus .snm file
            goto DoneImport;
            }
        }

    // # of messages in the folder
	lMsgs = (unsigned long)pToc[102] +
            (unsigned long)pToc[103] * 256;
	if (lMsgs == 0)
        {
        hr = S_OK;
        goto DoneImport;
        }

    mapMbx = CreateFileMapping(hMbx, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapMbx == NULL)
        goto DoneImport;

    pMbx = (BYTE *)MapViewOfFile(mapMbx, FILE_MAP_READ, 0, 0, 0);
    if (pMbx == NULL)
        goto DoneImport;

    pEndMbx = pMbx + cbMbx;

    pImport->SetMessageCount(lMsgs);

    pT = &pToc[104];
    pLast = pMbx;
	for (i = 0; i < lMsgs; i++)
	    {
        if (pT + 218 > pEnd)
            break;

	    uOffset = (unsigned long)pT[0] +
                    (unsigned long)pT[1] * 256 +
                    (unsigned long)pT[2] * 65536 +
                    (unsigned long)pT[3] * 16777216;
        uMsgSize = (unsigned long)pT[4] +
                    (unsigned long)pT[5] * 256 +
                    (unsigned long)pT[6] * 65536 +
                    (unsigned long)pT[7] * 16777216;

        pNextMsg = pMbx + uOffset;

        if (pNextMsg + uMsgSize > pEndMbx)
            {
            // probably not a good idea to read past the end of the message file...
            break;
            }

		hr = ProcessEudoraMsg(pT, (LPCSTR)pNextMsg, uMsgSize, pImport);
        if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
            goto DoneImport;

        pLast = pNextMsg + uMsgSize;

        pT += 218;
	    }

    hr = S_OK;

DoneImport:
    if (pToc != NULL)
        UnmapViewOfFile(pToc);
    if (mapToc != NULL)
        CloseHandle(mapToc);

    if (pMbx != NULL)
        UnmapViewOfFile(pMbx);
    if (mapMbx != NULL)
        CloseHandle(mapMbx);

	CloseHandle(hToc);
	CloseHandle(hMbx);

	return(hr);
    }

CEudoraEnumFOLDERS::CEudoraEnumFOLDERS(EUDORANODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CEudoraEnumFOLDERS::~CEudoraEnumFOLDERS()
    {

    }

ULONG CEudoraEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CEudoraEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CEudoraEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CEudoraEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    lstrcpyn(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CEudoraEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

void EudoraFreeFolderList(EUDORANODE *plist)
    {
    EUDORANODE *pnode;

    while (plist != NULL)
        {
        if (plist->pchild != NULL)
            EudoraFreeFolderList(plist->pchild);
        pnode = plist;
        plist = plist->pnext;
        MemFree(pnode);
        }
    }

const static char c_szInMbx[] = "In.mbx";
const static char c_szTrashMbx[] = "Trash.mbx";

typedef struct tagEUDORASPECIAL
    {
    const char *szFile;
    IMPORTFOLDERTYPE type;
    } EUDORASPECIAL;

const static EUDORASPECIAL c_rges[] =
    {
        {c_szInMbx, FOLDER_TYPE_INBOX},
        {c_szTrashMbx, FOLDER_TYPE_DELETED}
    };

BYTE *GetEudoraFolderInfo(EUDORANODE *pnode, TCHAR *pdir, BYTE *pcurr, BYTE *pend)
    {
    char *pT, *szFile;
    int i, cch;
    const EUDORASPECIAL *pes;
    BOOL fFound;

    Assert(pnode != NULL);
    Assert(pdir != NULL);
    Assert(pcurr != NULL);
    Assert(pend != NULL);
    Assert((DWORD_PTR)pcurr < (DWORD_PTR)pend);

    // get folder name
    pT = pnode->szName;
    fFound = FALSE;
    while (pcurr < pend)
        {
        if (*pcurr == ',')
            {
            fFound = TRUE;
            *pT = 0;
            pcurr++;
            break;
            }

        *pT = *pcurr;
        pT++;
        pcurr++;
        }

    if (!fFound)
        return(NULL);

    // get folder file
    // get folder file
    lstrcpy(pnode->szFile, pdir);
    cch = lstrlen(pnode->szFile);
    if (pnode->szFile[cch - 1] != '\\')
        {
        pnode->szFile[cch] = '\\';
        cch++;
        pnode->szFile[cch] = 0;
        }
    pT = &pnode->szFile[cch];
    szFile = pT;
    fFound = FALSE;
    while (pcurr < pend)
        {
        if (*pcurr == ',')
            {
            fFound = TRUE;
            *pT = 0;
            pcurr++;
            break;
            }

        *pT = *pcurr;
        pT++;
        pcurr++;
        }

    if (!fFound)
        return(NULL);

    // determine the file type
    cch = lstrlen(pnode->szFile);
    Assert(cch > 3);
    pT = &pnode->szFile[cch - 4];
    Assert(*pT == '.');
    if (*pT != '.')
        return(NULL);
    pT++;
    if (0 == lstrcmpi(pT, "fol"))
        pnode->iFileType = FOL_FILE;
    else if (0 == lstrcmpi(pT, "mbx"))
        pnode->iFileType = MBX_FILE;
    else
        return(NULL);

    if (pnode->iFileType == MBX_FILE &&
        pcurr < pend &&
        *pcurr == 'S')
        {
        // it's a special mailbox
        pes = c_rges;
        for (i = 0; i < ARRAYSIZE(c_rges); i++)
            {
            if (0 == lstrcmpi(szFile, pes->szFile))
                {
                pnode->type = pes->type;
                break;
                }

            pes++;
            }
        }

    // go to the end of the line
    fFound = FALSE;
    while (pcurr < (pend - 1))
        {
        if (*pcurr == 0x0d && *(pcurr + 1) == 0x0a)
            {
            fFound = TRUE;
            pcurr += 2;
            break;
            }

        pcurr++;
        }

    return(fFound ? pcurr : NULL);
    }

const static TCHAR c_szDescMap[] = TEXT("descmap.pce");

HRESULT GetEudoraSubfolders(EUDORANODE *pparent, TCHAR *pdir, EUDORANODE **pplist)
    {
    int cch;
    DWORD cbPce;
	HANDLE filePce, mapPce;
    BYTE *pPce, *pcurr, *pend;
	TCHAR path[MAX_PATH];
	EUDORANODE *plist, *pnode;

    Assert(pplist != NULL);
    Assert(pdir != NULL);

    *pplist = NULL;
    plist = NULL;

    lstrcpy(path, pdir);
    cch = lstrlen(path);
    if (path[cch - 1] != '\\')
        {
        path[cch] = '\\';
        cch++;
        path[cch] = 0;
        }
    lstrcat(path, c_szDescMap);

    filePce = CreateFile(path, GENERIC_READ, FILE_SHARE_READ, NULL,
                            OPEN_EXISTING, 0, NULL);
    if (filePce == INVALID_HANDLE_VALUE)
        {
        // although this failed, lets try to continue
        return(S_OK);
        }

    cbPce = GetFileSize(filePce, NULL);

    mapPce = CreateFileMapping(filePce, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapPce != NULL)
        {
        pPce = (BYTE *)MapViewOfFile(mapPce, FILE_MAP_READ, 0, 0, 0);
        if (pPce != NULL)
            {
            pcurr = pPce;
            pend = pPce + cbPce;

            while (pcurr < pend)
                {
                if (!MemAlloc((void **)&pnode, sizeof(EUDORANODE)))
                    break;
                ZeroMemory(pnode, sizeof(EUDORANODE));

                pcurr = GetEudoraFolderInfo(pnode, pdir, pcurr, pend);
                if (pcurr == NULL)
                    {
                    // an error occurred and we can't recover
                    // so we'll just exit and try to carry on with what we have
                    MemFree(pnode);
                    break;
                    }

                if (plist == NULL)
                    {
                    plist = pnode;
                    }
                else
                    {
                    pnode->pnext = plist;
                    plist = pnode;
                    }

                pnode->pparent = pparent;
                pnode->depth = (pparent == NULL ? 0 : (pparent->depth + 1));

                if (pnode->iFileType == FOL_FILE)
                    GetEudoraSubfolders(pnode, pnode->szFile, &pnode->pchild);
                }

            UnmapViewOfFile(pPce);
            }

        CloseHandle(mapPce);
        }

    CloseHandle(filePce);

    *pplist = plist;

    return(S_OK);
    }

HRESULT ProcessEudoraMsg(const BYTE *cMsgEntry, LPCSTR szBuffer1, ULONG uMsgSize, IFolderImport *pImport)
{
    HRESULT hr;
    BOOL fAttach;
    TCHAR **rgszAttach;
	ULONG uMsgSize2;
    DWORD dw, dwState, cAttach;
    BYTE pri;
	LPSTR szBuffer2 = NULL;
    LPSTR szBuffer3 = NULL;
	LPSTREAM lpstm = NULL;

    Assert(cMsgEntry != NULL);
    Assert(pImport != NULL);

	fAttach = !!(cMsgEntry[15] & 0x80);

    // 0 = unread
    // 1 = read
    // 2 = replied
    // 3 = forwarded
    // 4 = redirected
    // 5 = unsendable
    // 6 = sendable
    // 7 = queued
    // 8 = sent
    // 9 = unsent
    dwState = 0;
	switch (cMsgEntry[12])
	    {
        case 0:
            dwState |= MSG_STATE_UNREAD;
            break;

        case 5:
		case 6:
        case 9:
            dwState |= MSG_STATE_UNSENT;
			break;

		case 7:
            dwState |= MSG_STATE_SUBMITTED;
			break;
    	}

    pri = cMsgEntry[16];
    if (pri <= 2)
        dwState |= MSG_PRI_HIGH;
    else if (pri > 3)
        dwState |= MSG_PRI_LOW;
    else
        dwState |= MSG_PRI_NORMAL;

    hr = FixEudoraMessage(szBuffer1, uMsgSize, fAttach, (char **)&szBuffer2, &uMsgSize2, &rgszAttach, &cAttach);
    if (hr == S_OK)
        {
        Assert(szBuffer2 != NULL);
        szBuffer1 = szBuffer2;
        uMsgSize = uMsgSize2;
        }
    else if (FAILED(hr))
        {
        return(hr);
        }

    hr = FixSentItemDate(szBuffer1, uMsgSize, (char **)&szBuffer3, &uMsgSize2);
    if (hr == S_OK)
    {
        Assert(szBuffer3 != NULL);
        szBuffer1 = szBuffer3;
        uMsgSize = uMsgSize2;
    }

    if (SUCCEEDED(hr))
    {
#ifdef DEBUG
        if (cAttach > 0)
            Assert(rgszAttach != NULL);
        else
            Assert(rgszAttach == NULL);
#endif // DEBUG

        hr = HrByteToStream(&lpstm, (LPBYTE)szBuffer1, uMsgSize);
        if (SUCCEEDED(hr))
        {
            Assert(lpstm != NULL);

            hr = pImport->ImportMessage(MSG_TYPE_MAIL, dwState, lpstm, (const TCHAR **)rgszAttach, cAttach);

            lpstm->Release();
        }
    }

    if (szBuffer2 != NULL)
        MemFree(szBuffer2);

    if (szBuffer3 != NULL)
        MemFree(szBuffer3);

    if (cAttach > 0)
    {
        for (dw = 0; dw < cAttach; dw++)
            MemFree(rgszAttach[dw]);

        MemFree(rgszAttach);
    }

    return(hr);
}

LPCSTR GetNextMessageLine(LPCSTR sz, LPCSTR szEnd, BOOL fHeader)
    {
    Assert(sz != NULL);
    Assert(szEnd != NULL);

    if (fHeader && *sz == 0x0d && *(sz + 1) == 0x0a)
        {
        // no more headers
        return(NULL);
        }

    while (sz < (szEnd - 1))
        {
        if (*sz == 0x0d && *(sz + 1) == 0x0a)
            {
            sz += 2;
            return(sz);
            }
        else
            {
            sz++;
            }
        }

    return(NULL);
    }

#define FileExists(_szFile)     (GetFileAttributes(_szFile) != 0xffffffff)

// Attachment Converted: "<file>"\r\n (quotes are optional)
static const char c_szAttConv[] = "Attachment Converted: ";

LPCSTR GetNextAttachment(LPCSTR szBuffer, LPCSTR szEnd, LPCSTR *ppNextLine, LPSTR szAtt)
    {
    int cb;
    LPCSTR sz, szNext, szFile;

    Assert(szBuffer != NULL);
    Assert(szEnd != NULL);
    Assert(ppNextLine != NULL);
    Assert(szAtt != NULL);

    *ppNextLine = NULL;
    sz = szBuffer;

    while (sz != NULL)
        {
        if ((sz + ARRAYSIZE(c_szAttConv)) >= szEnd)
            break;

        if (0 == memcmp(sz, c_szAttConv, ARRAYSIZE(c_szAttConv) - 1))
            {
            szFile = sz + (ARRAYSIZE(c_szAttConv) - 1);
            if (*szFile == '"')
                szFile++;

            szNext = GetNextMessageLine(sz, szEnd, FALSE);
            if (szNext == NULL)
                return(NULL);

            // copy attachment file name
            Assert((DWORD_PTR)szNext > (DWORD_PTR)szFile);
            cb = (int) (szNext - szFile);
            // we're not interested in the CRLF
            cb -= 2;
            if (cb > 0 && cb < MAX_PATH)
                {
                CopyMemory(szAtt, szFile, cb);
                if (szAtt[cb - 1] == '"')
                    cb--;
                szAtt[cb] = 0;

                if (FileExists(szAtt))
                    {
                    *ppNextLine = szNext;
                    return(sz);
                    }
                }
            }

        sz = GetNextMessageLine(sz, szEnd, FALSE);
        }

    return(NULL);
    }

#define CATTACH     16

static const char c_szContentType[] = "Content-Type:";
static const char c_szMultipart[] = "multipart";
static const char c_szTextPlain[] = "text/plain\r\n";
static const char c_szTextHtml[] = "text/html\r\n";
static const char c_szTextEnriched[] = "text/enriched\r\n";
static const char c_szXhtml[] = "<x-html>";
static const char c_szRich[] = "<x-rich>";
static const char c_szCRLF[] = "\r\n";

enum {
    TEXT_PLAIN = 0,
    TEXT_HTML,
    TEXT_RICH
    };

HRESULT FixEudoraMessage(LPCSTR szBuffer, ULONG uSize, BOOL fAttach, char **pszBufferNew, ULONG *puSizeNew, TCHAR ***prgszAttach, DWORD *pcAttach)
    {
    ULONG cb;
    DWORD cAttach, cAttachBuf;
    char *szAttach, **rgszAttach, *szBufferNew, *pT;
    char szBody[16];
    int text;
    LPCSTR szType, pContentType, pBody, pNext;

    Assert(szBuffer != NULL);
    Assert(pszBufferNew != NULL);
    Assert(puSizeNew != NULL);
    Assert(prgszAttach != NULL);
    Assert(pcAttach != NULL);

    *pszBufferNew = NULL;
    *prgszAttach = NULL;
    *pcAttach = 0;
    cAttach = 0;
    cAttachBuf = 0;
    rgszAttach = NULL;
    text = TEXT_PLAIN;

    pBody = GetBody(szBuffer, uSize);
    if (pBody == NULL)
        return(S_FALSE);

    pContentType = GetMultipartContentTypeHeader(szBuffer, pBody, &pNext);
    if (pContentType == NULL && !fAttach)
        return(S_FALSE);

    CopyMemory(szBody, pBody, ARRAYSIZE(c_szXhtml) - 1);
    szBody[ARRAYSIZE(c_szXhtml) - 1] = 0;
    if (0 == lstrcmpi(szBody, c_szXhtml))
        text = TEXT_HTML;
    else if (0 == lstrcmpi(szBody, c_szRich))
        text = TEXT_RICH;

    if (!MemAlloc((void **)&szBufferNew, uSize + 1))
		return(E_OUTOFMEMORY);
    pT = szBufferNew;

    if (pContentType != NULL)
        {
        // copy everything before content type header
        cb = (ULONG) (pContentType - szBuffer);
        CopyMemory(szBufferNew, szBuffer, cb);

        // write new content type header
        pT += cb;
        if (text == TEXT_HTML)
            szType = c_szTextHtml;
        else if (text == TEXT_RICH)
            szType = c_szTextEnriched;
        else
            {
            Assert(text == TEXT_PLAIN);
            szType = c_szTextPlain;
            }
        cb = lstrlen(szType);
        CopyMemory(pT, szType, cb);
        pT += cb;

        // copy remainder of headers
        if (pNext != NULL)
            {
            Assert((ULONG_PTR)pBody > (ULONG_PTR)pNext);
            cb = (ULONG)(pBody - pNext);
            CopyMemory(pT, pNext, cb);
            pT += cb;
            }
        else
            {
            // in case there was no other header following the content type header
            CopyMemory(pT, c_szCRLF, 2);
            pT += 2;
            }
        }
    else
        {
        Assert(fAttach);
        Assert((ULONG_PTR)pBody > (ULONG_PTR)szBuffer);
        cb = (ULONG)(pBody - szBuffer);
        CopyMemory(pT, szBuffer, cb);
        pT += cb;
        }

    if (fAttach)
        {
        LPCSTR pCurr, pAtt, pNextLine, pEnd;
        char szAtt[MAX_PATH];

        pCurr = pBody;
        pEnd = szBuffer + uSize;
        while (TRUE)
            {
            pAtt = GetNextAttachment(pCurr, pEnd, &pNextLine, szAtt);
            if (pAtt == NULL)
                {
                // we're at the end of the message
                // copy whatever remains from the original buffer to the new buffer
                cb = uSize - (ULONG) (pCurr - szBuffer);
                CopyMemory(pT, pCurr, cb);
                pT += cb;

                break;
                }

            if (cAttach == cAttachBuf)
                {
                if (!MemRealloc((void **)&rgszAttach, (cAttachBuf + CATTACH) * sizeof(TCHAR *)))
                    {
                    if (rgszAttach != NULL)
                        MemFree(rgszAttach);
                    MemFree(szBufferNew);
                    return(E_OUTOFMEMORY);
                    }
                cAttachBuf += CATTACH;
                }

            Assert(rgszAttach != NULL);
            if (!MemAlloc((void **)&szAttach, MAX_PATH * sizeof(TCHAR)))
                {
                MemFree(rgszAttach);
                MemFree(szBufferNew);
                return(E_OUTOFMEMORY);
                }
            lstrcpy(szAttach, szAtt);
            rgszAttach[cAttach] = szAttach;
            cAttach++;

            if (pCurr != pAtt)
                {
                cb = (ULONG)(pAtt - pCurr);
                CopyMemory(pT, pCurr, cb);
                pT += cb;
                }

            if (pNextLine >= pEnd)
                break;

            pCurr = pNextLine;
            }
        }
    else
        {
        // just copy body into new buffer
        cb = uSize - (ULONG)(pBody - szBuffer);
        CopyMemory(pT, pBody, cb);
        pT += cb;
        }

    *pT = 0;
    *pszBufferNew = szBufferNew;
    *puSizeNew = (ULONG)(pT - szBufferNew);

    *prgszAttach = rgszAttach;
    *pcAttach = cAttach;

    return(S_OK);
    }

LPCSTR GetMultipartContentTypeHeader(LPCSTR szBuffer, LPCSTR szEnd, LPCSTR *pNext)
    {
    LPCSTR sz, szT;

    Assert(szBuffer != NULL);
    Assert(szEnd != NULL);
    Assert(pNext != NULL);

    *pNext = NULL;
    sz = szBuffer;

    while (sz != NULL)
        {
        if (0 == StrCmpNI(sz, c_szContentType, lstrlen(c_szContentType)))
            {
            sz += lstrlen(c_szContentType);
            if (*sz == 0x20)
                sz++;

            if (0 == StrCmpNI(sz, c_szMultipart, lstrlen(c_szMultipart)))
                {
                szT = sz;
                // find the next header line
                do {
                    szT = GetNextMessageLine(szT, szEnd, TRUE);
                    if (szT == NULL)
                        break;
                    }
                while (*szT == 0x09 || *szT == 0x20);

                *pNext = szT;
                return(sz);
                }

            break;
            }

        sz = GetNextMessageLine(sz, szEnd, TRUE);
        }

    return(NULL);
    }

LPCSTR GetBody(LPCSTR szBuffer, ULONG uSize)
    {
    LPCSTR sz, szEnd;

    Assert(szBuffer != NULL);
    Assert(uSize > 0);
    sz = szBuffer;
    szEnd = szBuffer + uSize;

    while (sz != NULL)
        {
        if (*sz == 0x0d && *(sz + 1) == 0x0a)
            {
            sz += 2;
            break;
            }

        sz = GetNextMessageLine(sz, szEnd, TRUE);
        }

    return(sz);
    }

static const char c_szRecHdr[] = "Received:";
static const char c_szFromHdr[] = "From ???@??? ";
static const char c_szIRecHdr[] = "Received:  ; ";

HRESULT FixSentItemDate(LPCSTR szBuffer, ULONG uMsgSize, char **pszNewBuffer, ULONG *puNewMsgSize)
{
    HRESULT hr;
    int cch;
    BOOL fReceived;
    LPCSTR pBody, pHeader;
    char *szNew, szFrom[80], szReceived[80];

    Assert(lstrlen(c_szFromHdr) == lstrlen(c_szFromHdr));

    Assert(szBuffer != NULL);
    Assert(pszNewBuffer != NULL);
    Assert(puNewMsgSize != NULL);

    *pszNewBuffer = NULL;

    pHeader = szBuffer;
    pBody = GetBody(szBuffer, uMsgSize);
    if (pBody == NULL)
        return(S_FALSE);

    if (0 != StrCmpNI(pHeader, c_szFromHdr, lstrlen(c_szFromHdr)))
        return(S_FALSE);
    pHeader = GetNextMessageLine(pHeader, pBody, TRUE);
    if (pHeader == NULL)
        return(S_FALSE);

    cch = (int)(pHeader - szBuffer);
    if (cch >= ARRAYSIZE(szFrom))
        return(S_FALSE);
    lstrcpyn(szFrom, szBuffer, cch - 1);

    fReceived = FALSE;

    while (pHeader != NULL)
    {
        if (0 == StrCmpNI(pHeader, c_szRecHdr, lstrlen(c_szRecHdr)))
        {
            fReceived = TRUE;
            break;
        }

        pHeader = GetNextMessageLine(pHeader, pBody, TRUE);
    }

    if (!fReceived)
    {
        FormatDate(szFrom, szReceived, ARRAYSIZE(szReceived));
        cch = lstrlen(szReceived);

        if (!MemAlloc((void **)&szNew, uMsgSize + cch))
            return(S_FALSE);

        CopyMemory(szNew, szReceived, cch);
        CopyMemory(&szNew[cch], szBuffer, uMsgSize);

        *pszNewBuffer = szNew;
        *puNewMsgSize = uMsgSize + cch;

        return(S_OK);
    }

    return(S_FALSE);
}

static const char c_szRecFmt[] = "%s ; %s %c%02d%02d\r\n";

HRESULT FormatDate(LPCSTR szFromLine, char *szRecHdr, int cchMax)
{
    DWORD dwTimeZoneId;
    TIME_ZONE_INFORMATION tzi;
    LONG lTZBias, lTZHour, lTZMinute;
    char cTZSign;

    Assert(szFromLine != NULL);
    Assert(szRecHdr != NULL);

    dwTimeZoneId = GetTimeZoneInformation(&tzi);
    switch (dwTimeZoneId)
    {
        case TIME_ZONE_ID_STANDARD:
            lTZBias = tzi.Bias + tzi.StandardBias;
            break;

        case TIME_ZONE_ID_DAYLIGHT:
            lTZBias = tzi.Bias + tzi.DaylightBias;
            break;

        case TIME_ZONE_ID_UNKNOWN:
        default:
            lTZBias = 0;   // $$BUG:  what's supposed to happen here?
            break;
    }

    lTZHour   = lTZBias / 60;
    lTZMinute = lTZBias % 60;
    cTZSign     = (lTZHour < 0) ? '+' : '-';

    szFromLine += lstrlen(c_szFromHdr);
    wsprintf(szRecHdr, c_szRecFmt,
                c_szRecHdr, szFromLine, cTZSign, abs(lTZHour), abs(lTZMinute));

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\exchange\exchimp.cpp ===
#include "pch.hxx"
#include <mapi.h>
#include <mapix.h>
#include <imnapi.h>
#include <newimp.h>
#include <impapi.h>
#include <import.h>
#include "mapiconv.h"
#include <dllmain.h>
#include <shlwapi.h>
#include <strconst.h>

#define INITGUID
#define USES_IID_IMessage
#define USES_IID_IMAPIFolder

#include <ole2.h>
#include <initguid.h>
#include <MAPIGUID.H>

ASSERTDATA

static const TCHAR c_szMapi32Dll[] = TEXT("mapi32.dll");

const static TCHAR szMAPILogonEx[] = TEXT("MAPILogonEx");
const static TCHAR szMAPIInitialize[] = TEXT("MAPIInitialize");
const static TCHAR szMAPIUninitialize[] = TEXT("MAPIUninitialize");
const static TCHAR szMAPIFreeBuffer[] = TEXT("MAPIFreeBuffer");
const static TCHAR szMAPIAllocateBuffer[] = TEXT("MAPIAllocateBuffer");
const static TCHAR szMAPIAllocateMore[] = TEXT("MAPIAllocateMore");
const static TCHAR szMAPIAdminProfiles[] = TEXT("MAPIAdminProfiles");
const static TCHAR szFreeProws[] = TEXT("FreeProws@4");
const static TCHAR szHrQueryAllRows[] = TEXT("HrQueryAllRows@24");
const static TCHAR szWrapCompressedRTFStream[] = TEXT("WrapCompressedRTFStream");

static char g_szDefClient[MAX_PATH];

HMODULE g_hlibMAPI = NULL;

LPMAPILOGONEX lpMAPILogonEx = NULL;
LPMAPIINITIALIZE lpMAPIInitialize = NULL;
LPMAPIUNINITIALIZE lpMAPIUninitialize = NULL;
LPMAPIFREEBUFFER lpMAPIFreeBuffer = NULL;
LPMAPIALLOCATEBUFFER lpMAPIAllocateBuffer = NULL;
LPMAPIALLOCATEMORE lpMAPIAllocateMore = NULL;
LPMAPIADMINPROFILES lpMAPIAdminProfiles = NULL;
LPFREEPROWS lpFreeProws = NULL;
LPHRQUERYALLROWS lpHrQueryAllRows = NULL;
LPWRAPCOMPRESSEDRTFSTREAM lpWrapCompressedRTFStream = NULL;

HRESULT GetSubFolderList(LPMAPICONTAINER pcont, IMPFOLDERNODE **ppnode, IMPFOLDERNODE *pparent);
HRESULT ExchGetFolderList(HWND hwnd, IMAPISession *pmapi, IMPFOLDERNODE **pplist);
void ExchFreeFolderList(IMPFOLDERNODE *pnode);
VOID ExchFreeImsg(LPIMSG lpImsg);

static BOOL g_fMapiInit = FALSE;

CExchImport::CExchImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    m_pmapi = NULL;
    }

CExchImport::~CExchImport()
    {
    if (m_plist != NULL)
        ExchFreeFolderList(m_plist);

    if (m_pmapi != NULL)
        {
        m_pmapi->Logoff(NULL, 0, 0);
        SideAssert(0 == m_pmapi->Release());
        }

    DllRelease();
    }

ULONG CExchImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CExchImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CExchImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CExchImport::InitializeImport(HWND hwnd)
    {
    HRESULT hr;

    if (SUCCEEDED(hr = ExchInit()) && S_OK == (hr = MapiLogon(hwnd, &m_pmapi)))
        {
        Assert(m_pmapi != NULL);
        hr = ExchGetFolderList(hwnd, m_pmapi, &m_plist);
        }

    if (hr == hrMapiInitFail)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsImportTitle),
            MAKEINTRESOURCE(idsMapiImportFailed), MAKEINTRESOURCE(idsMapiInitError),
            MB_OK | MB_ICONSTOP);
        }
    else if (hr == hrNoProfilesFound)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsImportTitle),
            MAKEINTRESOURCE(idsMapiImportFailed), MAKEINTRESOURCE(idsNoMapiProfiles),
            MB_OK | MB_ICONSTOP);
        }
    else if (FAILED(hr) && hr != MAPI_E_USER_CANCEL)
        {
        ImpMessageBox(hwnd, MAKEINTRESOURCE(idsImportTitle),
            MAKEINTRESOURCE(idsMapiImportFailed), MAKEINTRESOURCE(idsGenericError),
            MB_OK | MB_ICONSTOP);
        }

    return(hr);
    }

HRESULT CExchImport::GetDirectory(char *szDir, UINT cch)
    {
	return(S_FALSE);
    }

HRESULT CExchImport::SetDirectory(char *szDir)
    {
    Assert(FALSE);

	return(E_FAIL);
    }

HRESULT CExchImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CExchEnumFOLDERS *pEnum;
    IMPFOLDERNODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((IMPFOLDERNODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CExchEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

static SizedSPropTagArray(1, s_taMessage) = 
    {
        1,
        {
        PR_ENTRYID,
        }
    };

STDMETHODIMP CExchImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    IMPFOLDERNODE *pnode;
    HRESULT hr;
    IMSG imsg;
    LPMAPITABLE ptbl;
    LPMAPICONTAINER pcont;
    ULONG cRow, i, ulObjType;
    LPSRow lprw;
    LPSPropValue lpProp;
    LPSRowSet prset;
    LPMESSAGE pmsg;

    Assert(pImport != NULL);

    pnode = (IMPFOLDERNODE *)dwCookie;
    Assert(pnode != NULL);

    hr = E_FAIL;

    pcont = (LPMAPICONTAINER)pnode->lparam;

    Assert(pcont != NULL);

    hr = pcont->GetContentsTable(0, &ptbl);
    if (FAILED(hr))
        {
        Assert(FALSE);
        return(hr);
        }

    if (!FAILED(hr = ptbl->SetColumns((LPSPropTagArray)&s_taMessage, 0)) &&
        !FAILED(hr = ptbl->GetRowCount(0, &cRow)) &&
        cRow > 0)
        {
        pImport->SetMessageCount(cRow);

        while (TRUE)
            {
            if(hr == hrUserCancel)
                break;
            if (cRow == 0)
                {
                hr = S_OK;
                break;
                }
            hr = ptbl->QueryRows(cRow, 0, &prset);
            if (FAILED(hr))
                break;
            if (prset->cRows == 0)
                {
                FreeSRowSet(prset);
                break;
                }

            for (i = 0, lprw = prset->aRow; i < prset->cRows; i++, lprw++)
                {
                if(hr == hrUserCancel)
                    break;

                lpProp = lprw->lpProps;
                Assert(lpProp->ulPropTag == PR_ENTRYID);

                hr = pcont->OpenEntry(lpProp->Value.bin.cb,
                        (LPENTRYID)lpProp->Value.bin.lpb, NULL, MAPI_BEST_ACCESS,
                        &ulObjType, (LPUNKNOWN *)&pmsg);
                Assert(!FAILED(hr));
                if (!FAILED(hr))
                    {
                    hr = HrMapiToImsg(pmsg, &imsg);
                    Assert(!FAILED(hr));
                    if (!FAILED(hr))
                        {
                        hr = pImport->ImportMessage(&imsg);

                        ExchFreeImsg(&imsg);
                        }

                    pmsg->Release();
                    }
                }

            Assert(prset->cRows <= cRow);
            cRow -= prset->cRows;

            FreeSRowSet(prset);
            }
        }

    ptbl->Release();

    return(hr);
    }

CExchEnumFOLDERS::CExchEnumFOLDERS(IMPFOLDERNODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CExchEnumFOLDERS::~CExchEnumFOLDERS()
    {

    }

ULONG CExchEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CExchEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CExchEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CExchEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    lstrcpyn(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    // pfldr->type = 0;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CExchEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

HRESULT ExchInit(void)
    {
    HRESULT hr;
    DWORD cb, type;
    char sz[MAX_PATH];

    if (g_fMapiInit)
        return(S_OK);

    Assert(g_hlibMAPI == NULL);

    g_hlibMAPI = LoadLibrary(c_szMapi32Dll);
    if (g_hlibMAPI == NULL)
        return(hrMapiInitFail);

    lpMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(g_hlibMAPI, szMAPILogonEx);
    lpMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(g_hlibMAPI, szMAPIInitialize);
    lpMAPIUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(g_hlibMAPI, szMAPIUninitialize);
    lpMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(g_hlibMAPI, szMAPIFreeBuffer);
    lpMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)GetProcAddress(g_hlibMAPI, szMAPIAllocateBuffer);
    lpMAPIAllocateMore = (LPMAPIALLOCATEMORE)GetProcAddress(g_hlibMAPI, szMAPIAllocateMore);
    lpMAPIAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(g_hlibMAPI, szMAPIAdminProfiles);
    lpFreeProws = (LPFREEPROWS)GetProcAddress(g_hlibMAPI, szFreeProws);
    lpHrQueryAllRows = (LPHRQUERYALLROWS)GetProcAddress(g_hlibMAPI, szHrQueryAllRows);
    lpWrapCompressedRTFStream = (LPWRAPCOMPRESSEDRTFSTREAM)GetProcAddress(g_hlibMAPI, szWrapCompressedRTFStream);

    if (lpMAPILogonEx == NULL ||
        lpMAPIInitialize == NULL ||
        lpMAPIUninitialize == NULL ||
        lpMAPIFreeBuffer == NULL ||
        lpFreeProws == NULL ||
        lpHrQueryAllRows == NULL ||
        lpWrapCompressedRTFStream == NULL ||
        lpMAPIAllocateBuffer == NULL || 
        lpMAPIAllocateMore == NULL)
        {
        hr = hrMapiInitFail;
        }
    else
        {
        *g_szDefClient = 0;
        cb = sizeof(sz);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegOutlook, NULL, &type, (LPBYTE)sz, &cb))
        {
            cb = sizeof(g_szDefClient);
            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegMail, NULL, &type, (LPBYTE)g_szDefClient, &cb))
            {
                if (0 != lstrcmpi(g_szDefClient, c_szMicrosoftOutlook))
                {
                    if (ERROR_SUCCESS != SHSetValue(HKEY_LOCAL_MACHINE, c_szRegMail, NULL, REG_SZ, (LPBYTE)c_szMicrosoftOutlook, lstrlen(c_szMicrosoftOutlook) + 1))
                        *g_szDefClient = 0;
                }
                else
                {
                    *g_szDefClient = 0;
                }
            }
        }

        hr = lpMAPIInitialize(NULL);
        }

    if (SUCCEEDED(hr))
        {
        g_fMapiInit = TRUE;
        }
    else
        {
        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = NULL;
        }

    return(hr);
    }

void ExchDeinit()
    {
    if (g_fMapiInit)
        {
        Assert(g_hlibMAPI != NULL);

        lpMAPIUninitialize();

        FreeLibrary(g_hlibMAPI);
        g_hlibMAPI = NULL;

        if (*g_szDefClient != 0)
        {
            SHSetValue(HKEY_LOCAL_MACHINE, c_szRegMail, NULL, REG_SZ, (LPBYTE)g_szDefClient, lstrlen(g_szDefClient) + 1);
            *g_szDefClient = 0;
        }

        g_fMapiInit = FALSE;
        }
    }

HRESULT MapiLogon(HWND hwnd, IMAPISession **ppmapi)
    {
    HRESULT hr;
    LPPROFADMIN lpAdmin;
    LPMAPITABLE lpTable = NULL;
    ULONG ulCount = NULL;

    Assert(g_fMapiInit);
    
    if (ppmapi != NULL)
        *ppmapi = NULL;

    if (!FAILED(hr = lpMAPIAdminProfiles(0, &lpAdmin)))
        {
        Assert(lpAdmin != NULL);

        if (FAILED(hr = lpAdmin->GetProfileTable(0, &lpTable)) ||
            FAILED(hr = lpTable->GetRowCount(0, &ulCount))     || 
            !ulCount)
            {
            // could not find a valid profile

            hr = hrNoProfilesFound;
            }
        else
            {
            if (ppmapi != NULL)
                hr = lpMAPILogonEx((ULONG_PTR)hwnd, NULL, NULL, MAPI_EXTENDED | MAPI_LOGON_UI | MAPI_ALLOW_OTHERS, ppmapi);
            else
                hr = S_OK;
            }

        if (lpTable != NULL)
            lpTable->Release();

        lpAdmin->Release();
        }

    return(hr);
    }

HRESULT ExchGetFolderList(HWND hwnd, IMAPISession *pmapi, IMPFOLDERNODE **pplist)
    {
    HRESULT hr;
    LPMAPICONTAINER pcont;
    IMPFOLDERNODE *plist;

    Assert(g_fMapiInit);
    Assert(pmapi != NULL);

    hr = E_FAIL;

    pcont = OpenDefaultStoreContainer(hwnd, pmapi);
    if (pcont != NULL)
        {
        plist = NULL;

        hr = GetSubFolderList(pcont, &plist, NULL);
        Assert(!FAILED(hr));
        Assert(plist != NULL);

        *pplist = plist;

        pcont->Release();
        }

    return(hr);
    }

void ExchFreeFolderList(IMPFOLDERNODE *pnode)
    {
    Assert(pnode != NULL);

    if (pnode->pchild != NULL)
        ExchFreeFolderList(pnode->pchild);

    if (pnode->pnext != NULL)
        ExchFreeFolderList(pnode->pnext);

    if (pnode->szName != NULL)
        MemFree(pnode->szName);

    if (pnode->lparam != NULL)
        ((LPMAPICONTAINER)pnode->lparam)->Release();

    MemFree(pnode);
    }

LPMAPICONTAINER OpenDefaultStoreContainer(HWND hwnd, IMAPISession *pmapi)
    {
    HRESULT         hr;
    LPMDB           pmdb;
    LPMAPITABLE     ptbl;
    LPSRowSet       lpsrw;
    LPSRow          prw;
    ULONG           cStores,
                    cRows;
    LPSPropValue    ppvDefStore;
    LPENTRYID lpEID;
    ULONG cbEID, ulObjType, ulValues;
    LPMAPICONTAINER pcont;
    LPSPropValue lpPropsIPM = NULL;
    ULONG ulPropTags[2] = {1, PR_IPM_SUBTREE_ENTRYID};
    SizedSPropTagArray(4, pta) = 
        { 4, {PR_DEFAULT_STORE, PR_ENTRYID, PR_OBJECT_TYPE, PR_RESOURCE_FLAGS}};

    Assert(hwnd != NULL);
    Assert(pmapi != NULL);

    pmdb = NULL;
    ptbl = NULL;
    lpsrw = NULL;
    pcont = NULL;

    hr = pmapi->GetMsgStoresTable(0, &ptbl);
    if (HR_FAILED(hr))
        goto error;

    hr = lpHrQueryAllRows(ptbl,(LPSPropTagArray)&pta, NULL, NULL, 0, &lpsrw);
    if (HR_FAILED(hr))
        goto error;

    cRows = lpsrw->cRows;
    prw = &lpsrw->aRow[0];

    cStores = 0;
    ppvDefStore = NULL;

    while (cRows--)
        {
        if (prw->lpProps[2].ulPropTag == PR_OBJECT_TYPE && prw->lpProps[2].Value.l == MAPI_STORE)
            {
            if (prw->lpProps[3].ulPropTag != PR_RESOURCE_FLAGS ||
                !(prw->lpProps[3].Value.l & STATUS_NO_DEFAULT_STORE))
                cStores++;
            }

        if( prw->lpProps[0].ulPropTag == PR_DEFAULT_STORE && 
            prw->lpProps[0].Value.b)
            ppvDefStore=prw->lpProps;

        prw++;
        }

    if (!ppvDefStore || ppvDefStore[1].ulPropTag != PR_ENTRYID)
        goto error;
       
    hr = pmapi->OpenMsgStore((ULONG_PTR)hwnd, ppvDefStore[1].Value.bin.cb,
                (LPENTRYID)ppvDefStore[1].Value.bin.lpb,
                NULL, MAPI_BEST_ACCESS, &pmdb);
    if (!HR_FAILED(hr))
        {
        // Get the IPM_SUBTREE from the ROOT
        if (!FAILED(hr = pmdb->GetProps((LPSPropTagArray)&ulPropTags, 0, &ulValues, &lpPropsIPM)))
            {
            cbEID = lpPropsIPM->Value.bin.cb;
            lpEID = (LPENTRYID)lpPropsIPM->Value.bin.lpb;

            hr = pmdb->OpenEntry(cbEID, lpEID, NULL, MAPI_BEST_ACCESS,
                                    &ulObjType, (LPUNKNOWN *)&pcont);
        
            lpMAPIFreeBuffer(lpPropsIPM);
            }
        }

error:
    if (lpsrw != NULL)
        FreeSRowSet(lpsrw);
    if (ptbl != NULL)
        ptbl->Release();
    if (pmdb != NULL)
        pmdb->Release();

    return(pcont);
    }

/*
 *      FreeSRowSet
 *
 *      Purpose:
 *              Frees an SRowSet structure and the rows therein
 *
 *      Parameters:
 *              LPSRowSet               The row set to free
 */
void FreeSRowSet(LPSRowSet prws)
    {
    ULONG irw;

    if (!prws)
        return;

    // Free each row
    for (irw = 0; irw < prws->cRows; irw++)
        lpMAPIFreeBuffer(prws->aRow[irw].lpProps);

    // Free the top level structure
    lpMAPIFreeBuffer(prws);
    }

static SizedSPropTagArray(5, s_taFolder) = 
    {
        5,
        {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_SUBFOLDERS,
        PR_OBJECT_TYPE,
        PR_CONTENT_COUNT
        }
    };

enum
    {
    iDISPLAY_NAME = 0,
    iENTRYID,
    iSUBFOLDERS,
    iOBJECT_TYPE,
    iCONTENT_COUNT
    };

HRESULT GetSubFolderList(LPMAPICONTAINER pcont, IMPFOLDERNODE **ppnode, IMPFOLDERNODE *pparent)
    {
    HRESULT hr;
    IMPFOLDERNODE *pnode, *pnew, *plast;
    ULONG i, cRow, ulObj;
    int cb;
    LPSRow lprw;
    LPSPropValue lpProp;
    LPMAPITABLE ptbl;
    LPSRowSet prset;

    *ppnode = NULL;

    hr = pcont->GetHierarchyTable(0, &ptbl);
    if (FAILED(hr))
        return(hr);

    pnode = NULL;

    if (!FAILED(hr = ptbl->SetColumns((LPSPropTagArray)&s_taFolder, 0)) &&
        !FAILED(hr = ptbl->GetRowCount(0, &cRow)) &&
        cRow > 0)
        {
        while (TRUE)
            {
            if (cRow == 0)
                {
                hr = S_OK;
                break;
                }
            hr = ptbl->QueryRows(cRow, 0, &prset);
            if (FAILED(hr))
                break;
            if (prset->cRows == 0)
                {
                FreeSRowSet(prset);
                break;
                }

            for (i = 0, lprw = prset->aRow; i < prset->cRows; i++, lprw++)
                {
                if (!MemAlloc((void **)&pnew, sizeof(IMPFOLDERNODE)))
                    break;
                ZeroMemory(pnew, sizeof(IMPFOLDERNODE));

                lpProp = &lprw->lpProps[iENTRYID];
                Assert(lpProp->ulPropTag == PR_ENTRYID);
                hr = pcont->OpenEntry(lpProp->Value.bin.cb, (LPENTRYID)lpProp->Value.bin.lpb, NULL,
                                        MAPI_BEST_ACCESS, &ulObj, (LPUNKNOWN *)&pnew->lparam);
                if (FAILED(hr))
                    {
                    MemFree(pnew);
                    continue;
                    }

                lpProp = &lprw->lpProps[iCONTENT_COUNT];
                Assert(lpProp->ulPropTag == PR_CONTENT_COUNT);
                pnew->cMsg = lpProp->Value.l;

                lpProp = &lprw->lpProps[iDISPLAY_NAME];
                Assert(lpProp->ulPropTag == PR_DISPLAY_NAME);
                cb = (lstrlen(lpProp->Value.LPSZ) + 1) * sizeof(TCHAR);
                if (!MemAlloc((void **)&pnew->szName, cb))
                    break;
                lstrcpy(pnew->szName, lpProp->Value.LPSZ);

                pnew->depth = (pparent != NULL) ? pparent->depth + 1 : 0;

                pnew->pparent = pparent;

                if (pnode == NULL)
                    pnode = pnew;
                else
                    plast->pnext = pnew;

                plast = pnew;

                lpProp = &lprw->lpProps[iSUBFOLDERS];
                Assert(lpProp->ulPropTag == PR_SUBFOLDERS);
                if (lpProp->Value.b)
                    {
                    hr = GetSubFolderList((LPMAPICONTAINER)pnew->lparam, &pnew->pchild, pnew);
                    Assert(!FAILED(hr));
                    }
                }

            Assert(prset->cRows <= cRow);
            cRow -= prset->cRows;

            FreeSRowSet(prset);
            }
        }

    ptbl->Release();

    *ppnode = pnode;

    return(hr);
    }

LPSPropValue PvalFind(LPSRow prw, ULONG ulPropTag)
    {
    UINT            ival = 0;
    LPSPropValue    pval = NULL;

    if(!prw)
        return NULL;

    ival = (UINT) prw->cValues;
    pval = prw->lpProps;
    while (ival--)
        {
        if (pval->ulPropTag == ulPropTag)
            return pval;
        ++pval;
        }
    return NULL;
    }

VOID ExchFreeImsg (LPIMSG lpImsg)
{
    // Locals
    ULONG           i;

    // Nothing
    if (lpImsg == NULL)
        return;

    // Free Stuff
    if (lpImsg->lpszSubject)
        MemFree(lpImsg->lpszSubject);
    lpImsg->lpszSubject = NULL;

    if (lpImsg->lpstmBody)
        lpImsg->lpstmBody->Release ();
    lpImsg->lpstmBody = NULL;

    if (lpImsg->lpstmHtml)
        lpImsg->lpstmHtml->Release ();
    lpImsg->lpstmHtml = NULL;

    // Walk Address list
    for (i=0; i<lpImsg->cAddress; i++)
    {
        if (lpImsg->lpIaddr[i].lpszAddress)
            MemFree(lpImsg->lpIaddr[i].lpszAddress);
        lpImsg->lpIaddr[i].lpszAddress = NULL;

        if (lpImsg->lpIaddr[i].lpszDisplay)
            MemFree(lpImsg->lpIaddr[i].lpszDisplay);
        lpImsg->lpIaddr[i].lpszDisplay = NULL;
    }

    // Free Address list
    if (lpImsg->lpIaddr)
        MemFree(lpImsg->lpIaddr);
    lpImsg->lpIaddr = NULL;

    // Walk Attachment list
    for (i=0; i<lpImsg->cAttach; i++)
    {
        if (lpImsg->lpIatt[i].lpszFileName)
            MemFree(lpImsg->lpIatt[i].lpszFileName);
        lpImsg->lpIatt[i].lpszFileName = NULL;

        if (lpImsg->lpIatt[i].lpszPathName)
            MemFree(lpImsg->lpIatt[i].lpszPathName);
        lpImsg->lpIatt[i].lpszPathName = NULL;

        if (lpImsg->lpIatt[i].lpszExt)
            MemFree(lpImsg->lpIatt[i].lpszExt);
        lpImsg->lpIatt[i].lpszExt = NULL;

        if (lpImsg->lpIatt[i].lpImsg)
        {
            ExchFreeImsg (lpImsg->lpIatt[i].lpImsg);
            MemFree(lpImsg->lpIatt[i].lpImsg);
            lpImsg->lpIatt[i].lpImsg = NULL;
        }

        if (lpImsg->lpIatt[i].lpstmAtt)
            lpImsg->lpIatt[i].lpstmAtt->Release ();
        lpImsg->lpIatt[i].lpstmAtt = NULL;
    }

    // Free the att list
    if (lpImsg->lpIatt)
        MemFree(lpImsg->lpIatt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\pch\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\netscape\commimp.h ===
#ifndef _INC_COMMSIMP_H
#define _INC_COMMSIMP_H

// {1198A2C0-0940-11d1-838F-00C04FBD7C09}
DEFINE_GUID(CLSID_CCommunicatorImport, 0x1198a2c0, 0x940, 0x11d1, 0x83, 0x8f, 0x0, 0xc0, 0x4f, 0xbd, 0x7c, 0x9);

#define SNM_FILE    1
#define SNM_DRAFT   2

#define hrExceptionalCase                 -1
#define hrOSInfoNotFound				 500
#define hrWin32platform					 501

class CCommunicatorEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG		m_cRef;
        EUDORANODE*	m_plist;
        EUDORANODE*	m_pnext;

    public:
        CCommunicatorEnumFOLDERS(EUDORANODE *plist);
        ~CCommunicatorEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CCommunicatorImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        EUDORANODE   *m_plist;
        char        m_szUser[MAX_PATH];
        BOOL            m_bDraft;

    public:
        CCommunicatorImport(void);
        ~CCommunicatorImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);

		// class member functions

		HRESULT ProcessBlocks(BYTE* pSnm, ULONG cbSnm,
							  BYTE* pMsg, ULONG cbMsg,
							  int nLayer, ULONG Offset,
							  IFolderImport *pImport);

		HRESULT ProcessMessages(BYTE* pSnm, ULONG cbSnm,
								BYTE* pMsg, ULONG cbMsg,
								ULONG NewOffset,
								IFolderImport* pImport);
		
		ULONG GetPrimaryOffset(BYTE* pSnm, ULONG cbSnm);

		ULONG GetOffset(BYTE* pSnm, ULONG cbSnm, ULONG Offset, int nElement);
    };

#endif // _INC_COMMSIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\netscape\netsimp.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include <eudrimp.h>
#include "netsimp.h"
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>

ASSERTDATA

HRESULT FindSnm(EUDORANODE **pplist, TCHAR *npath);
HRESULT ProcessMsg(BYTE *cMsgEntry, BYTE *pMsg, ULONG uMsgSize, IFolderImport *pImport);

CNetscapeImport::CNetscapeImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    }

CNetscapeImport::~CNetscapeImport()
    {
    if (m_plist != NULL)
        EudoraFreeFolderList(m_plist);

    DllRelease();
    }

ULONG CNetscapeImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CNetscapeImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CNetscapeImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CNetscapeImport::InitializeImport(HWND hwnd)
    {
	return(S_OK);
    }

HRESULT CNetscapeImport::GetDirectory(char *szDir, UINT cch)
    {
	HRESULT hr;

    Assert(szDir != NULL);

    hr = GetClientDir(szDir, cch, NETSCAPE);
    if (FAILED(hr))
        *szDir = 0;

	return(S_OK);
    }

HRESULT CNetscapeImport::SetDirectory(char *szDir)
    {
    HRESULT hr;

    Assert(szDir != NULL);

    if (!ValidStoreDirectory(szDir, NETSCAPE))
        return(S_FALSE);

    if (m_plist != NULL)
        {
        EudoraFreeFolderList(m_plist);
        m_plist = NULL;
        }

    hr = FindSnm(&m_plist, szDir);

	return(hr);
    }

HRESULT CNetscapeImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CNetscapeEnumFOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CNetscapeEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

// From - dow mmm dd hh:mm:ss yyyy/r/n
const static char c_szNscpSep[] = "From - aaa aaa nn nn:nn:nn nnnn";
#define CCH_NETSCAPE_SEP    (ARRAYSIZE(c_szNscpSep) + 1) // we want CRLF at end of line

inline BOOL IsNetscapeMessage(BYTE *pMsg, BYTE *pEnd)
    {
    const char *pSep;
    int i;

    if (pMsg + CCH_NETSCAPE_SEP > pEnd)
        return(FALSE);

    pSep = c_szNscpSep;
    for (i = 0; i < (CCH_NETSCAPE_SEP - 2); i++)
        {
        if (*pSep == 'a')
            {
            if (!((*pMsg >= 'A' && *pMsg <= 'Z') ||
                (*pMsg >= 'a' && *pMsg <= 'z')))
                return(FALSE);
            }
        else if (*pSep == 'n')
            {
            if (!(*pMsg >= '0' && *pMsg <= '9'))
                return(FALSE);
            }
        else
            {
            if (*pSep != (char)*pMsg)
                return(FALSE);
            }

        pSep++;
        pMsg++;
        }

    if (*pMsg != 0x0d ||
        *(pMsg + 1) != 0x0a)
        return(FALSE);

    return(TRUE);
    }

BYTE *GetNextNetscapeMessage(BYTE *pCurr, BYTE *pEnd)
    {
    BYTE *pT;

    while (pCurr < (pEnd - 1))
        {
        if (*pCurr == 0x0d && *(pCurr + 1) == 0x0a)
            {
            pT = pCurr + 2;
            if (pT == pEnd)
                return(pT);
            else if (IsNetscapeMessage(pT, pEnd))
                return(pT);
            }

        pCurr++;
        }

    return(NULL);
    }

const static char c_szSnmHeader[] = "# Netscape folder cache";

STDMETHODIMP CNetscapeImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    char szHdr[64];
    EUDORANODE *pnode;
    HRESULT hr;
	TCHAR cMsgFile[MAX_PATH];
    BYTE *pSnm, *pMsg, *pEnd, *pEndMsg, *pT, *pNextMsg, *pLast;
	ULONG i, lMsgs, lTotalMsgs, lNumNulls, cbMsg, cbSnm, cExtra, uOffset, uMsgSize, cMsgImp;
    HANDLE mapSnm, mapMsg, hSnm, hMsg;

    Assert(pImport != NULL);

    pnode = (EUDORANODE *)dwCookie;
    Assert(pnode != NULL);

    hr = E_FAIL;
    pSnm = NULL;
    mapSnm = NULL;
    pMsg = NULL;
    mapMsg = NULL;

	lstrcpy(cMsgFile, pnode->szFile);
	cMsgFile[(lstrlen(cMsgFile)) - 4] = 0;

	hMsg = CreateFile(cMsgFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMsg == INVALID_HANDLE_VALUE)
		return(hrFolderOpenFail);

    cbMsg = GetFileSize(hMsg, NULL);
    if (cbMsg == 0)
        {
        CloseHandle(hMsg);
        return(S_OK);
        }

	hSnm = CreateFile(pnode->szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hSnm == INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMsg);
        return(hrFolderOpenFail);
        }

    cbSnm = GetFileSize(hSnm, NULL);
    if (cbSnm < 59)
        {
        // the .snm file header is 59 bytes in size, so anything less
        // than this is bogus or doesn't have messages anyway, so no point
        // in continuing
        goto DoneImport;
        }

    mapSnm = CreateFileMapping(hSnm, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapSnm == NULL)
        goto DoneImport;

    pSnm = (BYTE *)MapViewOfFile(mapSnm, FILE_MAP_READ, 0, 0, 0);
    if (pSnm == NULL)
        goto DoneImport;

    pEnd = pSnm + cbSnm;

    CopyMemory(szHdr, pSnm, ARRAYSIZE(c_szSnmHeader) - 1);
    szHdr[ARRAYSIZE(c_szSnmHeader) - 1] = 0;
    if (0 != lstrcmp(szHdr, c_szSnmHeader))
        {
        // this is a bogus .snm file
        goto DoneImport;
        }

    mapMsg = CreateFileMapping(hMsg, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapMsg == NULL)
        goto DoneImport;

    pMsg = (BYTE *)MapViewOfFile(mapMsg, FILE_MAP_READ, 0, 0, 0);
    if (pMsg == NULL)
        goto DoneImport;

    pEndMsg = pMsg + cbMsg;

	// get the number of messages

    // # of messages in the .snm file
	lTotalMsgs = (unsigned long)pSnm[44] +
            (unsigned long)pSnm[43] * 256 +
            (unsigned long)pSnm[42] * 65536 +
            (unsigned long)pSnm[41] * 16777216;

    // # of non-deleted messages in the folder
    // this number may be larger than lTotalMsgs since messages
    // may exist in the folder that have no headers
	lMsgs = (unsigned long)pSnm[48] +
            (unsigned long)pSnm[47] * 256 +
            (unsigned long)pSnm[46] * 65536 +
            (unsigned long)pSnm[45] * 16777216;
	if (lMsgs == 0)
        {
        hr = S_OK;
        goto DoneImport;
        }

    cMsgImp = 0;
    pLast = pMsg;

    pImport->SetMessageCount(lMsgs);

    if (lTotalMsgs > 0)
        {
        // find the end of the string table
        lNumNulls = (unsigned long)pSnm[58] +
                    (unsigned long)pSnm[57] * 256;
        Assert(lNumNulls > 2);

        pT = pSnm + 59;
        while (pT < pEnd && lNumNulls != 0)
            {
            if (*pT == 0)
                lNumNulls--;
            pT++;
            }

        if (lNumNulls != 0)
            goto DoneImport;

        Assert(*(pT - 1) == 0 && *pT == 0);

	    for (i = 0; i < lTotalMsgs; i++)
	        {
            if (pT + 30 > pEnd)
                {
                // probably not a good idea to read past the end of the header file...
                hr = S_OK;
                goto DoneImport;
                }

	        uOffset = (unsigned long)pT[17] +
                    (unsigned long)pT[16] * 256 +
                    (unsigned long)pT[15] * 65536 +
                    (unsigned long)pT[14] * 16777216;

            uMsgSize = (unsigned long)pT[21] +
                    (unsigned long)pT[20] * 256 +
                    (unsigned long)pT[19] * 65536 +
                    (unsigned long)pT[18] * 16777216;

            pNextMsg = pMsg + uOffset;
            Assert(pNextMsg == pLast);

            if (pNextMsg + uMsgSize > pEndMsg)
                {
                // probably not a good idea to read past the end of the message file...
                hr = S_OK;
                goto DoneImport;
                }

	        if (0 == (pT[13] & 8))
                {
                // this is not a deleted message so lets import it

                cMsgImp++;
    		    hr = ProcessMsg(pT, pNextMsg, uMsgSize, pImport);
                if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
                    goto DoneImport;
                }

            pLast = pNextMsg + uMsgSize;

            // set pointer to next header
    	    cExtra = (unsigned long)pT[29] +
                (unsigned long)pT[28] * 256;
            pT += (30 + cExtra * 2);
	        }
        }

    // now import the messages that don't have headers yet...
    while (pLast < pEndMsg && cMsgImp < lMsgs)
        {
        pNextMsg = GetNextNetscapeMessage(pLast, pEndMsg);
        if (pNextMsg == NULL)
            break;

        uMsgSize = (ULONG)(pNextMsg - pLast);
        cMsgImp++;
        hr = ProcessMsg(NULL, pLast, uMsgSize, pImport);
        if (hr == E_OUTOFMEMORY || hr == hrDiskFull || hr == hrUserCancel)
            goto DoneImport;

        pLast = pNextMsg;
        }

    hr = S_OK;

DoneImport:
    if (pSnm != NULL)
        UnmapViewOfFile(pSnm);
    if (mapSnm != NULL)
        CloseHandle(mapSnm);
    if (pMsg != NULL)
        UnmapViewOfFile(pMsg);
    if (mapMsg != NULL)
        CloseHandle(mapMsg);

	CloseHandle(hSnm);
	CloseHandle(hMsg);

	return(hr);
    }

CNetscapeEnumFOLDERS::CNetscapeEnumFOLDERS(EUDORANODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CNetscapeEnumFOLDERS::~CNetscapeEnumFOLDERS()
    {

    }

ULONG CNetscapeEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CNetscapeEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CNetscapeEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CNetscapeEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;
    lstrcpyn(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CNetscapeEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

 /*******************************************************************
 *  FUNCTION NAME:FindSnm
 *
 *  PURPOSE:To Get the Snm files in a folder
 *
 *  PARAMETERS:
 *
 *     IN:parent EUDORANODE ,previously processed EUDORANODE
 *
 *     OUT:	Pointer to the first node in the tree
 *
 *  RETURNS: TRUE or FALSE
 *******************************************************************/

HRESULT FindSnm(EUDORANODE **pplist,TCHAR *npath)
    {
    HRESULT hr;
    HANDLE h1;
	TCHAR path[MAX_PATH], szInbox[CCHMAX_STRINGRES], szTrash[CCHMAX_STRINGRES];
	WIN32_FIND_DATA	FindFileData;
	EUDORANODE *newp, *last = NULL, *plist = NULL;
		
    Assert(pplist != NULL);
    Assert(npath != NULL);

    *pplist = NULL;

    wsprintf(path, "%s\\*.snm", npath);
	
	h1 = FindFirstFile(path, &FindFileData);
	if (h1 == INVALID_HANDLE_VALUE)
		return(S_OK);
	
    hr = E_OUTOFMEMORY;

    LoadString(g_hInstImp, idsInbox, szInbox, ARRAYSIZE(szInbox));
    LoadString(g_hInstImp, idsTrash, szTrash, ARRAYSIZE(szTrash));

    do
        {
	    if (!MemAlloc((void **)&newp, sizeof(EUDORANODE)))
		    goto err;
	    ZeroMemory(newp, sizeof(EUDORANODE));

	    if (plist == NULL)
            {
            Assert(last == NULL);
            plist = newp;
            }
        else
            {
            last->pnext = newp;
            }
	    last = newp;

	    lstrcpy(newp->szName, FindFileData.cFileName);

        wsprintf(newp->szFile, "%s\\%s", npath, newp->szName);

        newp->szName[(lstrlen(newp->szName)) - 4] = 0;    

        if (0 == lstrcmpi(newp->szName, szInbox))
            newp->type = FOLDER_TYPE_INBOX;
        else if (0 == lstrcmpi(newp->szName, szTrash))
            newp->type = FOLDER_TYPE_DELETED;
        }
    while (FindNextFile(h1, &FindFileData));

    hr = S_OK;

err:
    FindClose(h1);
	
    if (FAILED(hr) && plist != NULL)
        {
        EudoraFreeFolderList(plist);
        plist = NULL;
        }
        
    *pplist = plist;

    return(hr);
    }

HRESULT ProcessMsg(BYTE *cMsgEntry, BYTE *pMsg, ULONG uMsgSize, IFolderImport *pImport)
    {
    HRESULT hr;
    DWORD dw;
	LPSTREAM  lpstm = NULL;

    Assert(pImport != NULL);

    hr = HrByteToStream(&lpstm, pMsg, uMsgSize);
    if (SUCCEEDED(hr))
        {
        Assert(lpstm != NULL);

        dw = 0;
        // 0x01 == read
        // 0x10 == newly downloaded
	    if (cMsgEntry != NULL &&
            0 == (cMsgEntry[13] & 0x01))
	        dw |= MSG_STATE_UNREAD;

        hr = pImport->ImportMessage(MSG_TYPE_MAIL, dw, lpstm, NULL, 0);

        lpstm->Release();
        }

    return(hr);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\netscape\commimp.cpp ===
#include "pch.hxx"
#include "impapi.h"
#include "comconv.h"
#include <newimp.h>
#include <eudrimp.h>
#include "commimp.h"
#include <mapi.h>
#include <mapix.h>
#include <import.h>
#include <dllmain.h>

ASSERTDATA

HRESULT FindSnm(EUDORANODE *pParent, EUDORANODE **pplist, TCHAR *npath);
INT_PTR CALLBACK SelectCommUserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT GetCommunicatorDirectory(char *szUser, char *szDir, int cch);

const static char c_szSnmExt[] = "\\*.snm";
const static char c_szSnmHeader[] = "# Netscape folder cache"; //used for avoiding processing Netscape 3.0 SNM files
const static char c_szDrafts[] = "Drafts";
const static char c_szUnsent[] = "Unsent Messages";
const static char c_szSent[] = "Sent";

CCommunicatorImport::CCommunicatorImport()
    {
    DllAddRef();

    m_cRef = 1;
    m_plist = NULL;
    *m_szUser = 0;
    }

CCommunicatorImport::~CCommunicatorImport()
    {
    if (m_plist != NULL)
        EudoraFreeFolderList(m_plist);

    DllRelease();
    }

ULONG CCommunicatorImport::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CCommunicatorImport::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CCommunicatorImport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IMailImport == riid)
		*ppv = (IMailImport *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

typedef struct tagSELCOMMINFO
    {
    char szUser[MAX_PATH];
    HKEY hkey;
    } SELCOMMINFO;

const static char c_szRegNscp[] = "Software\\Netscape\\Netscape Navigator\\Users";

HRESULT CCommunicatorImport::InitializeImport(HWND hwnd)
    {
    DWORD cUsers;
    int iRet;
    HKEY hkey;
    HRESULT hr;
    SELCOMMINFO si;

    hr = S_OK;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegNscp, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (ERROR_SUCCESS == RegQueryInfoKey(hkey, NULL, NULL, 0, &cUsers, NULL, NULL, NULL, NULL, NULL, NULL, NULL))
            {
            if (cUsers > 1)
                {
                si.hkey = hkey;

                iRet = (int) DialogBoxParam(g_hInstImp, MAKEINTRESOURCE(iddSelectCommUser), hwnd, SelectCommUserDlgProc, (LPARAM)&si);
                if (iRet == IDCANCEL)
                    hr = S_FALSE;
                else if (iRet == IDOK)
                    lstrcpy(m_szUser, si.szUser);
                else
                    hr = E_FAIL;
                }
            }

        RegCloseKey(hkey);
        }

	return(hr);
    }

INT_PTR CALLBACK SelectCommUserDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
    {
    HWND hwndT;
    WORD id;
    DWORD iSubKey, cb;
    char sz[MAX_PATH];
    SELCOMMINFO *psi;
    int index;

    switch (msg)
        {
        case WM_INITDIALOG:
            Assert(lParam != NULL);
            psi = (SELCOMMINFO *)lParam;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)psi);

            hwndT = GetDlgItem(hwnd, IDC_USERLIST);

            // fill list
            iSubKey = 0;
            cb = sizeof(sz);
            while (ERROR_SUCCESS == RegEnumKeyEx(psi->hkey, iSubKey, sz, &cb, NULL, NULL, NULL, NULL))
                {
                SendMessage(hwndT, LB_ADDSTRING, 0, (LPARAM)sz);
                iSubKey++;
                cb = sizeof(sz);
                }

            SendMessage(hwndT, LB_SETCURSEL, 0, 0);
            return(TRUE);

        case WM_COMMAND:
            id = LOWORD(wParam);
            switch (id)
                {
                case IDOK:
                    psi = (SELCOMMINFO *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                    Assert(psi != NULL);

                    hwndT = GetDlgItem(hwnd, IDC_USERLIST);
                    index = (int) SendMessage(hwndT, LB_GETCURSEL, 0, 0);
                    Assert(index >= 0);
                    SendMessage(hwndT, LB_GETTEXT, (WPARAM)index, (LPARAM)psi->szUser);

                    // fall through

                case IDCANCEL:
                    EndDialog(hwnd, id);
                    return(TRUE);
                }
            break;
        }

    return(FALSE);
    }

const static char c_szCommunicatorKey[] = "SOFTWARE\\Netscape\\Netscape Navigator\\Users";
const static char c_szCurrentUser[] = "CurrentUser";
const static char c_szDirRoot[] = "DirRoot";
const static char c_szMailDir[] = "\\Mail";

HRESULT GetCommunicatorDirectory(char *szUser, char *szDir, int cch)
    {
    char sz[MAX_PATH], szTemp[MAX_PATH], szExpanded[MAX_PATH], *psz;
    HKEY hkResult, hkResult1;
    LONG lRes;
    DWORD cb, dwType;
    HRESULT hr;

    hr = E_FAIL;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szCommunicatorKey, 0, KEY_QUERY_VALUE, &hkResult))
        {
        if (szUser == NULL)
            {
            cb = sizeof(sz);
            lRes = RegQueryValueEx(hkResult, c_szCurrentUser, NULL, NULL, (LPBYTE)sz, &cb);
            szUser = sz;
            }
        else
            {
            Assert(*szUser != 0);
            lRes = ERROR_SUCCESS;
            }

        if (lRes == ERROR_SUCCESS)
            {
            cb = sizeof(szTemp);
            if (ERROR_SUCCESS == RegOpenKeyEx(hkResult, szUser, 0, KEY_QUERY_VALUE, &hkResult1))
                {
                if (ERROR_SUCCESS == RegQueryValueEx(hkResult1, c_szDirRoot, NULL, &dwType, (LPBYTE)szTemp, &cb))
                    {
                    if (REG_EXPAND_SZ == dwType)
                    {
                        ZeroMemory(szExpanded, ARRAYSIZE(szExpanded));
                        ExpandEnvironmentStrings(szTemp, szExpanded, ARRAYSIZE(szExpanded));
                        psz = szExpanded;
                    }
                    else
                        psz = szTemp;
                    
                    if (!GetStorePath(psz, szDir))
                        {
                        lstrcpy(szDir, psz);
                        lstrcat(szDir, c_szMailDir);
                        }

                    hr = S_OK;
                    }

                RegCloseKey(hkResult1);
                }
            }

        RegCloseKey(hkResult);
        }

    return(hr);
    }

HRESULT CCommunicatorImport::GetDirectory(char *szDir, UINT cch)
    {
	HRESULT hr;

    Assert(szDir != NULL);

    hr = GetCommunicatorDirectory(*m_szUser != 0 ? m_szUser : NULL, szDir, cch);
    if (FAILED(hr))
        *szDir = 0;

	return(S_OK);
    }

HRESULT CCommunicatorImport::SetDirectory(char *szDir)
    {
    HRESULT hr;

    Assert(szDir != NULL);

    if (!ValidStoreDirectory(szDir, NETSCAPE))
        return(S_FALSE);

    if (m_plist != NULL)
        {
        EudoraFreeFolderList(m_plist);
        m_plist = NULL;
        }

    hr = FindSnm(NULL, &m_plist, szDir);

	return(hr);
    }

HRESULT CCommunicatorImport::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
    {
    CCommunicatorEnumFOLDERS *pEnum;
    EUDORANODE *pnode;

    Assert(ppEnum != NULL);
    *ppEnum = NULL;

    if (dwCookie == COOKIE_ROOT)
        pnode = m_plist;
    else
        pnode = ((EUDORANODE *)dwCookie)->pchild;

    if (pnode == NULL)
        return(S_FALSE);

    pEnum = new CCommunicatorEnumFOLDERS(pnode);
    if (pEnum == NULL)
        return(E_OUTOFMEMORY);

    *ppEnum = pEnum;

    return(S_OK);
    }

STDMETHODIMP CCommunicatorImport::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
    {
    char szHdr[64];
    EUDORANODE *pnode;
    HRESULT hr = E_FAIL;
	TCHAR cMsgFile[MAX_PATH];
    BYTE *pSnm, *pMsg, *pEnd, *pEndMsg, *pT, *pNextMsg, *pLast;
	ULONG i, lMsgs, lTotalMsgs, lNumNulls, cbMsg, cbSnm, cExtra, uOffset, uMsgSize, cMsgImp;
	ULONG	lRoof		=	32;
	ULONG	Offset		=	0;
	int nNumLevels		=	1;
    HANDLE mapSnm, mapMsg, hSnm, hMsg;

    Assert(pImport != NULL);

    pnode = (EUDORANODE *)dwCookie;
    Assert(pnode != NULL);

	if (pnode->iFileType == SNM_DRAFT)
        m_bDraft = TRUE;
    else
        m_bDraft = FALSE;

	Assert((pnode->iFileType == SNM_FILE ) || (pnode->iFileType == SNM_DRAFT));

    hr = E_FAIL;
    pSnm = NULL;
    mapSnm = NULL;
    pMsg = NULL;
    mapMsg = NULL;

	lstrcpy(cMsgFile, pnode->szFile);
	cMsgFile[(lstrlen(cMsgFile)) - 4] = 0;

	hMsg = CreateFile(cMsgFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hMsg == INVALID_HANDLE_VALUE)
		return(hrFolderOpenFail);

    cbMsg = GetFileSize(hMsg, NULL);
    if (cbMsg == 0)
        {
        CloseHandle(hMsg);
        return(S_OK);
        }

	hSnm = CreateFile(pnode->szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
						OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hSnm == INVALID_HANDLE_VALUE)
        {
        CloseHandle(hMsg);
        return(hrFolderOpenFail);
        }

    cbSnm = GetFileSize(hSnm, NULL);
    if (cbSnm < 2560)
        {
        // the .snm file header is 2560 bytes in size, so anything less
        // than this is bogus or doesn't have messages anyway, so no point
        // in continuing
        goto DoneImport;
        }

    mapSnm = CreateFileMapping(hSnm, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapSnm == NULL)
        goto DoneImport;

    pSnm = (BYTE *)MapViewOfFile(mapSnm, FILE_MAP_READ, 0, 0, 0);
    if (pSnm == NULL)
        goto DoneImport;

    pEnd = pSnm + cbSnm;

//	Do something else to verify the genuineness of the SNM file (like 
//	comparing the two separately stored values of "total # of messages").

//  1) Confirm that this is not a NS 3.0 SNM file.

    CopyMemory(szHdr, pSnm, ARRAYSIZE(c_szSnmHeader) - 1);
    szHdr[ARRAYSIZE(c_szSnmHeader) - 1] = 0;
    if (0 == lstrcmp(szHdr, c_szSnmHeader))
        {
        // this is a Version 3.0 SNM file
        goto DoneImport;
        }

//  2) Do someting else!!! We need to verify as much as possible or we'll 
//     end up hanging.

    mapMsg = CreateFileMapping(hMsg, NULL, PAGE_READONLY, 0, 0, NULL);
    if (mapMsg == NULL)
        goto DoneImport;

    pMsg = (BYTE *)MapViewOfFile(mapMsg, FILE_MAP_READ, 0, 0, 0);
    if (pMsg == NULL)
        goto DoneImport;

    pEndMsg = pMsg + cbMsg;

//	Get the total number of messages in the SNM file
	lTotalMsgs	=	GetOffset(pSnm, cbSnm, 400, 0); //408 - 8 as we add 8 in GetOffset

    cMsgImp = 0;
    pLast = pMsg;

    pImport->SetMessageCount(lTotalMsgs);

    if (lTotalMsgs > 0)
	{
		Offset	=	(ULONG)GetPrimaryOffset(pSnm, cbSnm);
		//	Find the number of 'Levels'
		if(Offset < cbSnm)
		{
			while(lRoof < lTotalMsgs)
			{
				lRoof *= 32;
				nNumLevels++;
			}
			hr  = ProcessBlocks(pSnm, cbSnm, pMsg, cbMsg, nNumLevels, Offset, pImport);
		}
	}

DoneImport:
    if (pSnm != NULL)
        UnmapViewOfFile(pSnm);
    if (mapSnm != NULL)
        CloseHandle(mapSnm);
    if (pMsg != NULL)
        UnmapViewOfFile(pMsg);
    if (mapMsg != NULL)
        CloseHandle(mapMsg);

	CloseHandle(hSnm);
	CloseHandle(hMsg);

	return(hr);
    }

HRESULT CCommunicatorImport::ProcessBlocks(BYTE* pSnm, ULONG cbSnm, 
										   BYTE* pMsg, ULONG cbMsg, 
										   int nLayer, ULONG Offset,
										   IFolderImport *pImport)
{
	HRESULT hr = S_OK;
	HRESULT hr1 = E_FAIL;
	Assert(Offset + 7 < cbSnm);
	int		nNumLoops	=	(int)pSnm[Offset + 7];
	ULONG	NewOffset	=	0;

	for(int nElement = 0; nElement < nNumLoops; nElement++)
	{
        if(hr != hrUserCancel)
        {
            if(nLayer == 1)
            {
                NewOffset	=	GetOffset(pSnm, cbSnm, Offset, 2*nElement); 
                // We use 2*nElement above to access elements 8 bytes apart.
                hr1 = ProcessMessages(pSnm,cbSnm, pMsg, cbMsg, NewOffset, pImport);
                if(FAILED(hr1))
                    hr = E_FAIL;
                if(hr1 == hrUserCancel)
                    return hr1;
            }
            else
            {
                NewOffset	=	GetOffset(pSnm, cbSnm, Offset, nElement);
                hr = ProcessBlocks(pSnm, cbSnm, pMsg, cbMsg, nLayer - 1, NewOffset, pImport);
            }
        }
        else
            return(hrUserCancel);
	}
	return(hr);
}

ULONG CCommunicatorImport::GetPrimaryOffset(BYTE* pSnm, ULONG cbSnm)
{
	return GetOffset(pSnm, cbSnm, 416, 0); //424 - 8 as we add 8 in GetOffset
}

ULONG CCommunicatorImport::GetOffset(BYTE* pSnm, ULONG cbSnm, ULONG Offset, int nElement)
{
	Assert (3 + Offset + (4*(nElement + 2)) < cbSnm); // One common check point!!!
	ULONG result = 0;

	result	=	(ULONG)pSnm[0 + Offset + (4*(nElement + 2))]*16777216 + 
				(ULONG)pSnm[1 + Offset + (4*(nElement + 2))]*65536 + 
				(ULONG)pSnm[2 + Offset + (4*(nElement + 2))]*256 + 
				(ULONG)pSnm[3 + Offset + (4*(nElement + 2))];
	return result;
}

HRESULT CCommunicatorImport::ProcessMessages(BYTE* pSnm, ULONG cbSnm,
											 BYTE* pMsg, ULONG cbMsg,
											 ULONG NewOffset,
											 IFolderImport* pImport)
{
	ULONG	    lMsgOffset	=	0;
	ULONG	    uMsgSize	=	0;
	HRESULT     hr			=	E_FAIL;
	LPSTREAM    lpstm       =   NULL;
    int         nPriority   =   1;
    DWORD       dwFlags     =   0;

   	nPriority	=	(int)*(pSnm + NewOffset + 47);

    switch(nPriority)
    {
    case 1:
    case 4:
        dwFlags |= MSG_PRI_NORMAL;
        break;

    case 2:
    case 3:
        dwFlags |= MSG_PRI_LOW;
        break;

    case 5:
    case 6:
        dwFlags |= MSG_PRI_HIGH;
        break;

    default:
        dwFlags |= MSG_PRI_NORMAL;
        break;
    }

	lMsgOffset	=	GetOffset(pSnm, cbSnm, NewOffset + 18, 0);			//26 - 8 as we add 8 in GetOffset
	uMsgSize	=	GetOffset(pSnm, cbSnm, NewOffset + 40, 0);	//48 - 8 as we add 8 in GetOffset

	Assert(lMsgOffset + uMsgSize <= cbMsg);
    Assert(pImport != NULL);
	
    hr = HrByteToStream(&lpstm, pMsg + lMsgOffset, uMsgSize);
    if (SUCCEEDED(hr))
        {
        Assert(lpstm != NULL);
        // 0x01 == read
	    if (((pSnm + NewOffset) != NULL) && (0 == ((pSnm + NewOffset)[45] & 0x01)))
	        dwFlags |= MSG_STATE_UNREAD;
        if(m_bDraft)
            dwFlags |= MSG_STATE_UNSENT;

        hr = pImport->ImportMessage(MSG_TYPE_MAIL, dwFlags, lpstm, NULL, 0);
        lpstm->Release();
        }
	return hr;
}

CCommunicatorEnumFOLDERS::CCommunicatorEnumFOLDERS(EUDORANODE *plist)
    {
    Assert(plist != NULL);

    m_cRef = 1;
    m_plist = plist;
    m_pnext = plist;
    }

CCommunicatorEnumFOLDERS::~CCommunicatorEnumFOLDERS()
    {

    }

ULONG CCommunicatorEnumFOLDERS::AddRef()
    {
    m_cRef++;

    return(m_cRef);
    }

ULONG CCommunicatorEnumFOLDERS::Release()
    {
    ULONG cRef;

    cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return(cRef);
    }

HRESULT CCommunicatorEnumFOLDERS::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    HRESULT hr = S_OK;

    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

	if (IID_IEnumFOLDERS == riid)
		*ppv = (IEnumFOLDERS *)this;
    else if (IID_IUnknown == riid)
		*ppv = (IUnknown *)this;
    else
        hr = E_NOINTERFACE;

    if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

    return(hr);
    }

HRESULT CCommunicatorEnumFOLDERS::Next(IMPORTFOLDER *pfldr)
    {
    Assert(pfldr != NULL);

    if (m_pnext == NULL)
        return(S_FALSE);

    ZeroMemory(pfldr, sizeof(IMPORTFOLDER));
    pfldr->dwCookie = (DWORD_PTR)m_pnext;

    // To map Netscape's "Sent" folder to OE's "Sent Items" - Bug 2688.
    if (m_pnext->type != FOLDER_TYPE_SENT)
        lstrcpyn(pfldr->szName, m_pnext->szName, ARRAYSIZE(pfldr->szName));
    else
        lstrcpy(pfldr->szName, "Sent Items");

    pfldr->type = m_pnext->type;
    pfldr->fSubFolders = (m_pnext->pchild != NULL);

    m_pnext = m_pnext->pnext;

    return(S_OK);
    }

HRESULT CCommunicatorEnumFOLDERS::Reset()
    {
    m_pnext = m_plist;

    return(S_OK);
    }

 /*******************************************************************
 *  FUNCTION NAME:FindSnm
 *
 *  PURPOSE:To Get the Snm files in a folder
 *
 *  PARAMETERS:
 *
 *     IN:parent EUDORANODE ,previously processed EUDORANODE
 *
 *     OUT:	Pointer to the first node in the tree
 *
 *  RETURNS: TRUE or FALSE
 *******************************************************************/

HRESULT FindSnm(EUDORANODE *pparent, EUDORANODE **pplist,TCHAR *npath)
{
    HRESULT hr;
    HANDLE h1, h2;
	TCHAR path[MAX_PATH], path1[MAX_PATH], szInbox[CCHMAX_STRINGRES], szTrash[CCHMAX_STRINGRES];
    TCHAR szNewPath[MAX_PATH];
	WIN32_FIND_DATA	FindFileData;
	WIN32_FIND_DATA	SbdFileData;
	EUDORANODE *newp, *newp1, *last = NULL, *plist = NULL;
		
    Assert(pplist != NULL);
    Assert(npath != NULL);

    *pplist = NULL;

    lstrcpy(path, npath);
    lstrcat(path, c_szSnmExt);
	
	h1 = FindFirstFile(path, &FindFileData);
	if (h1 == INVALID_HANDLE_VALUE)
		return(S_OK);
	
    hr = E_OUTOFMEMORY;

    LoadString(g_hInstImp, idsInbox, szInbox, ARRAYSIZE(szInbox));
    LoadString(g_hInstImp, idsTrash, szTrash, ARRAYSIZE(szTrash));

    do
	{
	    if (!MemAlloc((void **)&newp, sizeof(EUDORANODE)))
		    goto err;
	    ZeroMemory(newp, sizeof(EUDORANODE));

	    if (plist == NULL)
            {
            Assert(last == NULL);
            plist = newp;
            }
        else
            {
            last->pnext = newp;
            }
	    last = newp;

	    lstrcpy(newp->szName, FindFileData.cFileName);

        wsprintf(newp->szFile, "%s\\%s", npath, newp->szName);

        newp->szName[(lstrlen(newp->szName)) - 4] = 0;    

        if (0 == lstrcmpi(newp->szName, szInbox))
            newp->type = FOLDER_TYPE_INBOX;
        else if (0 == lstrcmpi(newp->szName, szTrash))
            newp->type = FOLDER_TYPE_DELETED;
        else if(0 == lstrcmpi(newp->szName, c_szSent)) //c_szSent need not be localised as per my investigation - v-sramas.
            newp->type = FOLDER_TYPE_SENT;

		newp->pparent = pparent;
		newp->depth = (pparent == NULL ? 0 : (pparent->depth + 1));
        
        // This following will be used later to set the flag of 
        // a message so that it is editable (MSG_STATE_UNSENT).
        if ((0 == lstrcmpi(newp->szName, c_szDrafts)) ||(0 == lstrcmpi(newp->szName, c_szUnsent)))
            newp->iFileType = SNM_DRAFT;
        else
            newp->iFileType = SNM_FILE;

		// Search for a corresponding .SBD folder - file now.

	    wsprintf(path1, "%s", newp->szFile);
        path1[(lstrlen(path1)) - 3] = 0;
		lstrcat(path1, "sbd");
		
		h2 = FindFirstFile(path1, &SbdFileData);

		if (h2 != INVALID_HANDLE_VALUE)
		{
			//Recurse here
            wsprintf(szNewPath, "%s\\%s", npath, SbdFileData.cFileName);
			FindSnm(newp, &newp->pchild, szNewPath);
		}
	}
    while (FindNextFile(h1, &FindFileData));

    hr = S_OK;

err:
    FindClose(h1);
	
    if (FAILED(hr) && plist != NULL)
        {
        EudoraFreeFolderList(plist);
        plist = NULL;
        }
        
    *pplist = plist;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\netscape\netsimp.h ===
#ifndef _INC_NETSIMP_H
#define _INC_NETSIMP_H

// {0A522733-A626-11D0-8D60-00C04FD6202B}
DEFINE_GUID(CLSID_CNetscapeImport, 0x0A522733L, 0xA626, 0x11D0, 0x8D, 0x60, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

#define hrExceptionalCase                 -1
#define hrOSInfoNotFound				 500
#define hrWin32platform					 501

class CNetscapeEnumFOLDERS : public IEnumFOLDERS
    {
    private:
        ULONG           m_cRef;
        EUDORANODE   *m_plist;
        EUDORANODE   *m_pnext;

    public:
        CNetscapeEnumFOLDERS(EUDORANODE *plist);
        ~CNetscapeEnumFOLDERS(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP Next(IMPORTFOLDER *pfldr);
        STDMETHODIMP Reset(void);
    };

class CNetscapeImport : public IMailImport
    {
    private:
        ULONG           m_cRef;
        EUDORANODE   *m_plist;

    public:
        CNetscapeImport(void);
        ~CNetscapeImport(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP InitializeImport(HWND hwnd);
        STDMETHODIMP GetDirectory(char *szDir, UINT cch);
        STDMETHODIMP SetDirectory(char *szDir);
        STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
        STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);
    };

#endif // _INC_NETSIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\oe4\oe4imp.cpp ===
//--------------------------------------------------------------------------
// OE4Imp.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "oe4imp.h"
#include "structs.h"
#include "migerror.h"
#include <shared.h>
#include <impapi.h>
#include <shlwapi.h>
#include "dllmain.h"
#include "resource.h"

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
static const char c_szMail[] = "mail";
static const char c_szFoldersNch[] = "folders.nch";
static const char c_szEmpty[] = "";

// --------------------------------------------------------------------------------
// MSG_xxx flags
// --------------------------------------------------------------------------------
#define MSG_DELETED                  0x0001
#define MSG_UNREAD                   0x0002
#define MSG_SUBMITTED                0x0004
#define MSG_UNSENT                   0x0008
#define MSG_RECEIVED                 0x0010
#define MSG_NEWSMSG                  0x0020
#define MSG_NOSECUI                  0x0040
#define MSG_VOICEMAIL                0x0080
#define MSG_REPLIED                  0x0100
#define MSG_FORWARDED                0x0200
#define MSG_RCPTSENT                 0x0400
#define MSG_FLAGGED                  0x0800
#define MSG_LAST                     0x0200
#define MSG_EXTERNAL_FLAGS           0x00fe
#define MSG_FLAGS                    0x000f

//--------------------------------------------------------------------------
// COE4Import_CreateInstance
//--------------------------------------------------------------------------
COE4Import_CreateInstance(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("COE4Import_CreateInstance");

    // Initialize
    *ppUnknown = NULL;

    // Create me
    COE4Import *pNew = new COE4Import();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// GetRecordBlock
// --------------------------------------------------------------------------------
HRESULT GetRecordBlock(LPMEMORYFILE pFile, DWORD faRecord, LPRECORDBLOCKV5B1 *ppRecord,
    LPBYTE *ppbData, BOOL *pfContinue)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("GetRecordBlock");

    // Bad Length
    if (faRecord + sizeof(RECORDBLOCKV5B1) > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Cast the Record
    (*ppRecord) = (LPRECORDBLOCKV5B1)((LPBYTE)pFile->pView + faRecord);

    // Invalid Record Signature
    if (faRecord != (*ppRecord)->faRecord)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_BADRECORDSIGNATURE);
        goto exit;
    }

    // Bad Length
    if (faRecord + (*ppRecord)->cbRecord > pFile->cbSize)
    {
        *pfContinue = TRUE;
        hr = TraceResult(MIGRATE_E_OUTOFRANGEADDRESS);
        goto exit;
    }

    // Set pbData
    *ppbData = (LPBYTE)((LPBYTE)(*ppRecord) + sizeof(RECORDBLOCKV5B1));

exit:
    // Done
    return hr;
}

//--------------------------------------------------------------------------
// COE4Import::COE4Import
//--------------------------------------------------------------------------
COE4Import::COE4Import(void)
{
    TraceCall("COE4Import::COE4Import");
    m_cRef = 1;
    m_pList = NULL;
    *m_szDirectory = '\0';
    m_cFolders = 0;
    m_prgFolder = NULL;
}

//--------------------------------------------------------------------------
// COE4Import::~COE4Import
//--------------------------------------------------------------------------
COE4Import::~COE4Import(void)
{
    TraceCall("COE4Import::~COE4Import");
    _Cleanup();
}

//--------------------------------------------------------------------------
// COE4Import::_FreeFolderList
//--------------------------------------------------------------------------
void COE4Import::_Cleanup(void)
{
    _FreeFolderList(m_pList);
    m_pList = NULL;
    SafeMemFree(m_prgFolder);
    m_cFolders = 0;
}

//--------------------------------------------------------------------------
// COE4Import::_FreeFolderList
//--------------------------------------------------------------------------
void COE4Import::_FreeFolderList(IMPFOLDERNODE *pNode)
{
    // Locals
    IMPFOLDERNODE *pNext;
    IMPFOLDERNODE *pCurrent=pNode;

    // Loop
    while (pCurrent)
    {
        // Save next
        pNext = pCurrent->pnext;

        // Free Children ?
        if (pCurrent->pchild)
        {
            // Free
            _FreeFolderList(pCurrent->pchild);
        }

        // Free szName
        g_pMalloc->Free(pCurrent->szName);

        // Free pCurrent
        g_pMalloc->Free(pCurrent);

        // Set Current
        pCurrent = pNext;
    }
}

//--------------------------------------------------------------------------
// COE4Import::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COE4Import::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMailImport == riid)
        *ppv = (IMailImport *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4Import::AddRef(void)
{
    TraceCall("COE4Import::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COE4Import::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4Import::Release(void)
{
    TraceCall("COE4Import::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// COE4Import::InitializeImport
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::InitializeImport(HWND hwnd)
{
    // Let Importer Ask for the Directory
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4Import::GetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::GetDirectory(LPSTR pszDir, UINT cch)
{
    // Locals
    HKEY        hKey=NULL;
    DWORD       dwType;
    DWORD       cb=cch;

    // Try to query the OE4 store root...
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Outlook Express", 0, KEY_READ, &hKey))
    {
        // Try to read the value
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, "Store Root", NULL, &dwType, (LPBYTE)pszDir, &cb))
            goto exit;
    }

    // Try V1
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Internet Mail and News", 0, KEY_READ, &hKey))
    {
        // Query the Store Root
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, "Store Root", NULL, &dwType, (LPBYTE)pszDir, &cb))
            goto exit;
    }

    // Null It Out
    *pszDir = '\0';

exit:
    // Close the Key
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4Import::SetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::SetDirectory(LPSTR pszDir)
{
    // Trace
    TraceCall("COE4Import::SetDirectory");

    // Save the Directory
    lstrcpyn(m_szDirectory, pszDir, ARRAYSIZE(m_szDirectory));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4Import::_EnumerateV1Folders
//--------------------------------------------------------------------------
HRESULT COE4Import::_EnumerateV1Folders(void)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szRes[255];
    CHAR                szMbxPath[MAX_PATH + MAX_PATH];
    CHAR                szSearch[MAX_PATH + MAX_PATH];
    WIN32_FIND_DATA     fd;
    HANDLE              hFind=INVALID_HANDLE_VALUE;
    DWORD               cAllocated=0;
    LPFLDINFO           pFolder;
    DWORD               i;
    MEMORYFILE          MbxFile={0};
    LPMBXFILEHEADER     pMbxHeader;

    // Trace
    TraceCall("COE4Import::_EnumerateV1Folders");

    // Do we have a sub dir
    wsprintf(szSearch, "%s\\*.mbx", m_szDirectory);

    // Find first file
    hFind = FindFirstFile(szSearch, &fd);

    // Did we find something
    if (INVALID_HANDLE_VALUE == hFind)
        goto exit;

    // Loop for ever
    while(1)
    {
        // If this is not a directory
        if (FALSE == ISFLAGSET(fd.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
        {
            // Open the file
            IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, fd.cFileName, c_szEmpty, szMbxPath, ARRAYSIZE(szMbxPath)));

            // Open the memory file
            if (SUCCEEDED(OpenMemoryFile(szMbxPath, &MbxFile)))
            {
                // Allocate
                if (m_cFolders + 1 > cAllocated)
                {
                    // Reallocate
                    IF_FAILEXIT(hr = HrRealloc((LPVOID *)&m_prgFolder, (cAllocated + 10) * sizeof(FLDINFO)));

                    // Set cAllocated
                    cAllocated += 10;
                }

                // Readability
                pFolder = &m_prgFolder[m_cFolders];

                // Zero this node
                ZeroMemory(pFolder, sizeof(FLDINFO));

                // Copy the filename
                lstrcpyn(pFolder->szFile, fd.cFileName, 259);

                // Strip the Extension Off
                PathRemoveExtensionA(pFolder->szFile);

                // Copy the folder name
                lstrcpyn(pFolder->szFolder, pFolder->szFile, 258);

                // Set Special
                pFolder->tySpecial = (FOLDER_TYPE_NORMAL - 1);

                // Loop through special folder
                for (i=FOLDER_TYPE_INBOX; i<CFOLDERTYPE; i++)
                {
                    // Load the Special Folder Name
                    LoadString(g_hInstImp, idsInbox + (i - 1), szRes, ARRAYSIZE(szRes));

                    // Compare with szFile
                    if (lstrcmpi(pFolder->szFolder, szRes) == 0)
                    {
                        // Copy the Folder Name
                        pFolder->tySpecial = (i - 1);

                        // Done
                        break;
                    }
                }

                // Read the Mbx File Header
                pMbxHeader = (LPMBXFILEHEADER)(MbxFile.pView);

                // Get the message Count so progress will work nicely
                pFolder->cMessages = pMbxHeader->cMsg;

                // Close the memory file
                CloseMemoryFile(&MbxFile);

                // Increment m_cFolders
                m_cFolders++;
            }
        }

        // Find the Next File
        if (!FindNextFile(hFind, &fd))
            break;
    }

exit:
    // Cleanup
    if (hFind)
        FindClose(hFind);
    CloseMemoryFile(&MbxFile);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::EnumerateFolders
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cchDir;
    MEMORYFILE          File={0};
    LPTABLEHEADERV5B1   pHeader;
    LPBYTE              pbData;
    DWORD               faRecord;
    LPFLDINFO           pFolder;
    LPRECORDBLOCKV5B1   pRecord;
    BOOL                fContinue;
    COE4EnumFolders    *pEnum=NULL;
    CHAR                szFilePath[MAX_PATH + MAX_PATH];
    IMPFOLDERNODE      *pList;
    IMPFOLDERNODE      *pNode=(IMPFOLDERNODE *)dwCookie;

    // Trace
    TraceCall("COE4Import::EnumerateFolders");

    // Invalid Args
    Assert(ppEnum);

    // No folders yet ?
    if (COOKIE_ROOT == dwCookie)
    {
        // Reset...
        _Cleanup();

        // Append \Mail onto m_szDirectory
        cchDir = lstrlen(m_szDirectory);

        // Is there enough room
        if (cchDir + lstrlen(c_szMail) + 2 >= ARRAYSIZE(m_szDirectory))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Need a Wack ?
        PathAddBackslash(m_szDirectory);

        // Append \\mail
        lstrcat(m_szDirectory, c_szMail);

        // Make Path to folders.nch file
        IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, c_szFoldersNch, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // If the folders.nch file doesn't exist, just try to enumerate the 
        if (FALSE == PathFileExists(szFilePath))
        {
            // EnumerateV1Folders
            IF_FAILEXIT(hr = _EnumerateV1Folders());
        }

        // Otherwise, crack the folders.nch file
        else
        {
            // Open the Folders file
            IF_FAILEXIT(hr = OpenMemoryFile(szFilePath, &File));

            // Validate Version
            pHeader = (LPTABLEHEADERV5B1)File.pView;

            // Check the Signature...
            if (File.cbSize < sizeof(TABLEHEADERV5B1) || OBJECTDB_SIGNATURE != pHeader->dwSignature || OBJECTDB_VERSION_PRE_V5 != pHeader->wMajorVersion)
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }

            // Allocate Folder Array
            IF_NULLEXIT(m_prgFolder = (LPFLDINFO)ZeroAllocate(sizeof(FLDINFO) * pHeader->cRecords));

            // Initialize faRecord to start
            faRecord = pHeader->faFirstRecord;

            // While we have a record
            while(faRecord)
            {
                // Readability
                pFolder = &m_prgFolder[m_cFolders];

                // Get the Record
                IF_FAILEXIT(hr = GetRecordBlock(&File, faRecord, &pRecord, &pbData, &fContinue));

                // DWORD - hFolder
                CopyMemory(&pFolder->idFolder, pbData, sizeof(pFolder->idFolder));
                pbData += sizeof(pFolder->idFolder);

                // CHAR(MAX_FOLDER_NAME) - szFolder
                CopyMemory(pFolder->szFolder, pbData, sizeof(pFolder->szFolder));
                pbData += sizeof(pFolder->szFolder);

                // CHAR(260) - szFile
                CopyMemory(pFolder->szFile, pbData, sizeof(pFolder->szFile));
                pbData += sizeof(pFolder->szFile);

                // DWORD - idParent
                CopyMemory(&pFolder->idParent, pbData, sizeof(pFolder->idParent));
                pbData += sizeof(pFolder->idParent);

                // DWORD - idChild
                CopyMemory(&pFolder->idChild, pbData, sizeof(pFolder->idChild));
                pbData += sizeof(pFolder->idChild);

                // DWORD - idSibling
                CopyMemory(&pFolder->idSibling, pbData, sizeof(pFolder->idSibling));
                pbData += sizeof(pFolder->idSibling);

                // DWORD - tySpecial
                CopyMemory(&pFolder->tySpecial, pbData, sizeof(pFolder->tySpecial));
                pbData += sizeof(pFolder->tySpecial);

                // DWORD - cChildren
                CopyMemory(&pFolder->cChildren, pbData, sizeof(pFolder->cChildren));
                pbData += sizeof(pFolder->cChildren);

                // DWORD - cMessages
                CopyMemory(&pFolder->cMessages, pbData, sizeof(pFolder->cMessages));
                pbData += sizeof(pFolder->cMessages);

                // DWORD - cUnread
                CopyMemory(&pFolder->cUnread, pbData, sizeof(pFolder->cUnread));
                pbData += sizeof(pFolder->cUnread);

                // DWORD - cbTotal
                CopyMemory(&pFolder->cbTotal, pbData, sizeof(pFolder->cbTotal));
                pbData += sizeof(pFolder->cbTotal);

                // DWORD - cbUsed
                CopyMemory(&pFolder->cbUsed, pbData, sizeof(pFolder->cbUsed));
                pbData += sizeof(pFolder->cbUsed);

                // DWORD - bHierarchy
                CopyMemory(&pFolder->bHierarchy, pbData, sizeof(pFolder->bHierarchy));
                pbData += sizeof(pFolder->bHierarchy);

                // DWORD - dwImapFlags
                CopyMemory(&pFolder->dwImapFlags, pbData, sizeof(pFolder->dwImapFlags));
                pbData += sizeof(DWORD);

                // BLOB - bListStamp
                CopyMemory(&pFolder->bListStamp, pbData, sizeof(pFolder->bListStamp));
                pbData += sizeof(BYTE);

                // DWORD - bReserved[3]
                pbData += (3 * sizeof(BYTE));

                // DWORD - rgbReserved
                pbData += 40;

                // Increment Count
                m_cFolders++;

                // Goto the Next Record
                faRecord = pRecord->faNext;
            }
        }

        // Build Import Folder Hierarchy
        IF_FAILEXIT(hr = _BuildFolderHierarchy(0, 0, NULL, m_cFolders, m_prgFolder));
    }

    // Not Folders ?
    else if (NULL == m_prgFolder)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // What should I 
    if (dwCookie == COOKIE_ROOT)
        pList = m_pList;
    else
        pList = pNode->pchild;

    // Create Folder Enumerator
    IF_NULLEXIT(pEnum = new COE4EnumFolders(pList));

    // Return Enumerator
    *ppEnum = (IEnumFOLDERS *)pEnum;

    // Don't Free
    pEnum = NULL;

exit:
    // Cleanup
    SafeRelease(pEnum);
    CloseMemoryFile(&File);
    
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::_BuildFolderHierarchy
//--------------------------------------------------------------------------
HRESULT COE4Import::_BuildFolderHierarchy(DWORD cDepth, DWORD idParent,
    IMPFOLDERNODE *pParent, DWORD cFolders, LPFLDINFO prgFolder)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    IMPFOLDERNODE  *pPrevious=NULL;
    IMPFOLDERNODE  *pNode;

    // Trace
    TraceCall("COE4Import::_BuildFolderHierarchy");

    // Walk through prgFolder and find items with parent of idParent
    for (i=0; i<cFolders; i++)
    {
        // Correct Parent ?
        if (idParent == prgFolder[i].idParent)
        {
            // Allocate the Root
            IF_NULLEXIT(pNode = (IMPFOLDERNODE *)ZeroAllocate(sizeof(IMPFOLDERNODE)));

            // Set Parent
            pNode->pparent = pParent;

            // Set Depth
            pNode->depth = cDepth;

            // Copy name
            IF_NULLEXIT(pNode->szName = PszDupA(prgFolder[i].szFolder));

            // Count of Messages
            pNode->cMsg = prgFolder[i].cMessages;

            // Set Type
            pNode->type = (IMPORTFOLDERTYPE)(prgFolder[i].tySpecial + 1);

            // Set lParam
            pNode->lparam = i;

            // Link pNode into List
            if (pPrevious)
                pPrevious->pnext = pNode;
            else if (pParent)
                pParent->pchild = pNode;
            else
            {
                Assert(NULL == m_pList);
                m_pList = pNode;
            }

            // Set pPrevious
            pPrevious = pNode;

            // Has Children ?
            if (prgFolder[i].cChildren)
            {
                // Enumerate Children
                IF_FAILEXIT(hr = _BuildFolderHierarchy(cDepth + 1, prgFolder[i].idFolder, pNode, cFolders, prgFolder));
            }
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4Import::ImportFolder
//--------------------------------------------------------------------------
STDMETHODIMP COE4Import::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
{
    // Locals
    HRESULT             hr=S_OK;
    CHAR                szIdxPath[MAX_PATH + MAX_PATH];
    CHAR                szMbxPath[MAX_PATH + MAX_PATH];
    MEMORYFILE          IdxFile={0};
    MEMORYFILE          MbxFile={0};
    LPBYTE              pbStream;
    LPMBXFILEHEADER     pMbxHeader;
    LPIDXFILEHEADER     pIdxHeader;
    DWORD               faIdxRead;
    LPIDXMESSAGEHEADER  pIdxMessage;
    LPMBXMESSAGEHEADER  pMbxMessage;
    DWORD               cMessages=0;
    DWORD               dwMsgState;
    DWORD               i;
    DWORD               cb;
    CByteStream        *pStream=NULL;
    IMPFOLDERNODE      *pNode=(IMPFOLDERNODE *)dwCookie;
    LPFLDINFO           pFolder;

    // Trace
    TraceCall("COE4Import::ImportFolder");

    // Set pFolder
    pFolder = &m_prgFolder[pNode->lparam];

    // .idx path
    IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, pFolder->szFile, ".idx", szIdxPath, ARRAYSIZE(szIdxPath)));

    // .mbx path
    IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, pFolder->szFile, ".mbx", szMbxPath, ARRAYSIZE(szMbxPath)));

    // Open the memory file
    IF_FAILEXIT(hr = OpenMemoryFile(szIdxPath, &IdxFile));

    // Open the memory file
    IF_FAILEXIT(hr = OpenMemoryFile(szMbxPath, &MbxFile));

    // Read the Mbx File Header
    pMbxHeader = (LPMBXFILEHEADER)(MbxFile.pView);

    // Read the Idx File Header
    pIdxHeader = (LPIDXFILEHEADER)(IdxFile.pView);

    // Validate the Version of th idx file
    if (pIdxHeader->ver != CACHEFILE_VER || pIdxHeader->dwMagic != CACHEFILE_MAGIC)
    {
        hr = TraceResult(MIGRATE_E_INVALIDIDXHEADER);
        goto exit;
    }

    // Setup faIdxRead
    faIdxRead = sizeof(IDXFILEHEADER);

    // Set Message Count
    pImport->SetMessageCount(pIdxHeader->cMsg);

    // Prepare to Loop
    for (i=0; i<pIdxHeader->cMsg; i++)
    {
        // Done
        if (faIdxRead >= IdxFile.cbSize)
            break;

        // Read an idx message header
        pIdxMessage = (LPIDXMESSAGEHEADER)((LPBYTE)IdxFile.pView + faIdxRead);

        // If this message is not marked as deleted...
        if (ISFLAGSET(pIdxMessage->dwState, MSG_DELETED))
            goto NextMessage;

        // Initialize State
        dwMsgState = 0;

        // Fixup the Flags
        if (ISFLAGSET(pIdxMessage->dwState, MSG_UNREAD))
            FLAGSET(dwMsgState, MSG_STATE_UNREAD);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_UNSENT))
            FLAGSET(dwMsgState, MSG_STATE_UNSENT);
        if (ISFLAGSET(pIdxMessage->dwState, MSG_SUBMITTED))
            FLAGSET(dwMsgState, MSG_STATE_SUBMITTED);

        // Bad
        if (pIdxMessage->dwOffset > MbxFile.cbSize)
            goto NextMessage;

        // Lets read the message header in the mbx file to validate the msgids
        pMbxMessage = (LPMBXMESSAGEHEADER)((LPBYTE)MbxFile.pView + pIdxMessage->dwOffset);

        // Validate the Message Ids
        if (pMbxMessage->msgid != pIdxMessage->msgid)
            goto NextMessage;

        // Check for magic
        if (pMbxMessage->dwMagic != MSGHDR_MAGIC)
            goto NextMessage;

        // Get the stream pointer
        pbStream = (LPBYTE)((LPBYTE)MbxFile.pView + (pIdxMessage->dwOffset + sizeof(MBXMESSAGEHEADER)));

        // New byte Stream
        IF_NULLEXIT(pStream = new CByteStream(pbStream, pMbxMessage->dwBodySize));

        // Import the message
        IF_FAILEXIT(hr = pImport->ImportMessage(MSG_TYPE_MAIL, dwMsgState, pStream, NULL, 0));

        // Count
        cMessages++;

NextMessage:
        // Cleanup
        if (pStream)
        {
            pStream->AcquireBytes(&cb, &pbStream, ACQ_DISPLACE);
            pStream->Release();
            pStream = NULL;
        }

        // Goto Next Header
        Assert(pIdxMessage);

        // Update faIdxRead
        faIdxRead += pIdxMessage->dwSize;
    }

exit:
    // Cleanup
    if (pStream)
    {
        pStream->AcquireBytes(&cb, &pbStream, ACQ_DISPLACE);
        pStream->Release();
        pStream = NULL;
    }

    CloseMemoryFile(&IdxFile);
    CloseMemoryFile(&MbxFile);

    // Done
    return hr;
}

//--------------------------------------------------------------------------
// COE4EnumFolders::COE4EnumFolders
//--------------------------------------------------------------------------
COE4EnumFolders::COE4EnumFolders(IMPFOLDERNODE *pList)
{
    TraceCall("COE4EnumFolders::COE4EnumFolders");
    m_cRef = 1;
    m_pList = pList;
    m_pNext = pList;
}

//--------------------------------------------------------------------------
// COE4EnumFolders::COE4EnumFolders
//--------------------------------------------------------------------------
COE4EnumFolders::~COE4EnumFolders(void)
{
    TraceCall("COE4EnumFolders::~COE4EnumFolders");
}

//--------------------------------------------------------------------------
// COE4EnumFolders::COE4EnumFolders
//--------------------------------------------------------------------------
STDMETHODIMP COE4EnumFolders::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COE4EnumFolders::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IEnumFOLDERS == riid)
        *ppv = (IEnumFOLDERS *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE4EnumFolders::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4EnumFolders::AddRef(void)
{
    TraceCall("COE4EnumFolders::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COE4EnumFolders::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE4EnumFolders::Release(void)
{
    TraceCall("COE4EnumFolders::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// COE4EnumFolders::Next
//--------------------------------------------------------------------------
STDMETHODIMP COE4EnumFolders::Next(IMPORTFOLDER *pFolder)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("COE4EnumFolders::Next");

    // Invalid Args
    Assert(pFolder != NULL);

    // Done
    if (NULL == m_pNext)
        return(S_FALSE);

    // Zero
    ZeroMemory(pFolder, sizeof(IMPORTFOLDER));

    // Store pNext into dwCookie
    pFolder->dwCookie = (DWORD_PTR)m_pNext;

    // Copy Folder Name
    lstrcpyn(pFolder->szName, m_pNext->szName, ARRAYSIZE(pFolder->szName));

    // Copy Type
    pFolder->type = m_pNext->type;

    // Has Sub Folders ?
    pFolder->fSubFolders = (m_pNext->pchild != NULL);

    // Goto Next
    m_pNext = m_pNext->pnext;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE4EnumFolders::Reset
//--------------------------------------------------------------------------
STDMETHODIMP COE4EnumFolders::Reset(void)
{
    // Trace
    TraceCall("COE4EnumFolders::Reset");

    // Reset
    m_pNext = m_pList;

    // Done
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\import\oe4\oe4imp.h ===
//--------------------------------------------------------------------------
// OE4Imp.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include <newimp.h>

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
typedef struct tagIMPFOLDERNODE IMPFOLDERNODE;
typedef struct tagFLDINFO *LPFLDINFO;

//--------------------------------------------------------------------------
// {BCE9E2E7-1FDD-11d2-9A79-00C04FA309D4}
//--------------------------------------------------------------------------
DEFINE_GUID(CLSID_COE4Import, 0xbce9e2e7, 0x1fdd, 0x11d2, 0x9a, 0x79, 0x0, 0xc0, 0x4f, 0xa3, 0x9, 0xd4);

//--------------------------------------------------------------------------
// {B977CB11-1FF5-11d2-9A7A-00C04FA309D4}
//--------------------------------------------------------------------------
DEFINE_GUID(CLSID_CIMN1Import, 0xb977cb11, 0x1ff5, 0x11d2, 0x9a, 0x7a, 0x0, 0xc0, 0x4f, 0xa3, 0x9, 0xd4);

//--------------------------------------------------------------------------
// COE4EnumFolders
//--------------------------------------------------------------------------
class COE4EnumFolders : public IEnumFOLDERS
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COE4EnumFolders(IMPFOLDERNODE *plist);
    ~COE4EnumFolders(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IEnumFOLDERS Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(IMPORTFOLDER *pfldr);
    STDMETHODIMP Reset(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;
    IMPFOLDERNODE  *m_pList;
    IMPFOLDERNODE  *m_pNext;
};

//--------------------------------------------------------------------------
// COE4Import
//--------------------------------------------------------------------------
class COE4Import : public IMailImport
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COE4Import(void);
    ~COE4Import(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMailImport Members
    //----------------------------------------------------------------------
    STDMETHODIMP InitializeImport(HWND hwnd);
    STDMETHODIMP GetDirectory(LPSTR pszDir, UINT cch);
    STDMETHODIMP SetDirectory(LPSTR pszDir);
    STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
    STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    HRESULT _BuildFolderHierarchy(DWORD cDepth, DWORD idParent, IMPFOLDERNODE *pParent, DWORD cFolders, LPFLDINFO prgFolder);
    HRESULT _EnumerateV1Folders(void);
    void _FreeFolderList(IMPFOLDERNODE *pNode);
    void _Cleanup(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;
    CHAR            m_szDirectory[MAX_PATH];
    DWORD           m_cFolders;
    LPFLDINFO       m_prgFolder;
    IMPFOLDERNODE  *m_pList;
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
COE4Import_CreateInstance(IUnknown *pUnkOuter, IUnknown **ppUnknown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\capiutil.h ===
#ifndef __CAPIUTIL_H
#define __CAPIUTIL_H
#include <msoert.h>
#endif // __CAPIUTIL_H

/*
**  c a p i u t i l . h
**   
**  Purpose:
**      A few helper functions for the crypt32 utilities
**
**  History
**      5/22/97: (t-erikne) Created.
**   
**    Copyright (C) Microsoft Corp. 1997.
*/

#ifndef __WINCRYPT_H__
#define _CRYPT32_
#include <wincrypt.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\envcid.h ===
#ifndef _ENVCID_H
#define _ENVCID_H

#define MSOEENVCMDID_SEND                   1
#define MSOEENVCMDID_CHECKNAMES             2
#define MSOEENVCMDID_AUTOCOMPLETE           4
#define MSOEENVCMDID_SETACTION              5
#define MSOEENVCMDID_ADDALLONTO             6
#define MSOEENVCMDID_PRIORITY               7
#define MSOEENVCMDID_DIRTY                  8
#define MSOEENVCMDID_VCARD                  9
#define MSOEENVCMDID_NEWS                   10
#define MSOEENVCMDID_SETACCOUNT             11
#define MSOEENVCMDID_SELECTRECIPIENTS       12
#define MSOEENVCMDID_PICKNEWSGROUPS         13
#define MSOEENVCMDID_ADDSENDER              14
#define MSOEENVCMDID_DIGSIGN                15
#define MSOEENVCMDID_ENCRYPT                16
#define MSOEENVCMDID_VIEWCONTACTS           17
#define MSOEENVCMDID_ATTACHFILE             18
#define MSOEENVCMDID_FOCUSTO                19
#define MSOEENVCMDID_FOCUSCC                20
#define MSOEENVCMDID_FOCUSSUBJ              21

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY ARE CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS INSTEAD.
//

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;			\
        extern TYP_##name VAR_##name;                   

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;			\
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HINSTANCE g_hInst;

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// CRYPT32.DLL

#define _CRYPT32_

BOOL DemandLoadCrypt32(void);

extern  BOOL    g_FSupportV3;
BOOL IsSMIME3Supported(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef ULONG_PTR HCRYPTPROV;
typedef struct _CERT_INFO *PCERT_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCERT_NAME_INFO;
typedef void *HCRYPTMSG;
typedef struct _CMSG_STREAM_INFO *PCMSG_STREAM_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCCERT_NAME_INFO;

LOADER_FUNCTION( DWORD, CertRDNValueToStrA,
    (DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPTSTR pszValueString, DWORD cszValueString),
    (dwValueType, pValue, pszValueString, cszValueString),
    NULL, Crypt32)
#define CertRDNValueToStrA VAR_CertRDNValueToStrA

LOADER_FUNCTION( BOOL, CertAddCertificateContextToStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, pCertContext, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddCertificateContextToStore VAR_CertAddCertificateContextToStore

LOADER_FUNCTION( BOOL, CertAddEncodedCertificateToStore,
    (HCERTSTORE hCertStore,
     DWORD dwCertEncodingType,
     BYTE *pbCertEncoded,
     DWORD cbCertEncoded,
     DWORD dwAddDisposition,
     PCCERT_CONTEXT *ppStoreContext),
    (hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppStoreContext),
    FALSE, Crypt32)
#define CertAddEncodedCertificateToStore VAR_CertAddEncodedCertificateToStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertEnumCertificatesInStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, pPrevCertContext),
    NULL, Crypt32)
#define CertEnumCertificatesInStore VAR_CertEnumCertificatesInStore

LOADER_FUNCTION( BOOL, CryptDecodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObject VAR_CryptDecodeObject

LOADER_FUNCTION( BOOL, CryptEncodeObject,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, BYTE * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObject VAR_CryptEncodeObject

LOADER_FUNCTION( BOOL, CryptDecodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo),
    (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo),
    FALSE, Crypt32)
#define CryptDecodeObjectEx VAR_CryptDecodeObjectEx

LOADER_FUNCTION( BOOL, CryptEncodeObjectEx,
    (DWORD dwCertEncodingType, LPCSTR lpszStructType, const void * pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void * pbEncoded, DWORD * pcbEncoded),
    (dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pbEncoded, pcbEncoded),
    FALSE, Crypt32)
#define CryptEncodeObjectEx VAR_CryptEncodeObjectEx


LOADER_FUNCTION(PCERT_RDN_ATTR, CertFindRDNAttr,
    (LPCSTR pszObjId, PCERT_NAME_INFO pName),
    (pszObjId, pName),
    NULL, Crypt32)
#define CertFindRDNAttr VAR_CertFindRDNAttr

LOADER_FUNCTION( BOOL, CertFreeCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CertFreeCertificateContext VAR_CertFreeCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertDuplicateCertificateContext,
    (PCCERT_CONTEXT pCertContext),
    (pCertContext), NULL, Crypt32)
#define CertDuplicateCertificateContext VAR_CertDuplicateCertificateContext

LOADER_FUNCTION( PCCERT_CONTEXT, CertFindCertificateInStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext),
    (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext),
    NULL, Crypt32)
#define CertFindCertificateInStore VAR_CertFindCertificateInStore

LOADER_FUNCTION( LONG, CertVerifyTimeValidity,
    (LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo),
    (pTimeToVerify, pCertInfo),
    1, Crypt32)
#define CertVerifyTimeValidity VAR_CertVerifyTimeValidity

LOADER_FUNCTION( BOOL, CertCompareCertificate,
    (DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2),
    (dwCertEncodingType, pCertId1, pCertId2),
    FALSE, Crypt32)
#define CertCompareCertificate VAR_CertCompareCertificate

LOADER_FUNCTION( BOOL, CertCompareCertificateName,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2),
    (dwCertEncodingType, pCertName1, pCertName2),
    FALSE, Crypt32)
#define CertCompareCertificateName VAR_CertCompareCertificateName

LOADER_FUNCTION( BOOL, CertCompareIntegerBlob,
    (PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2),
    (pInt1, pInt2),
    FALSE, Crypt32)
#define CertCompareIntegerBlob VAR_CertCompareIntegerBlob

LOADER_FUNCTION( HCERTSTORE, CertOpenStore,
    (LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV hCryptProv, DWORD dwFlags, const void *pvPara),
    (lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara),
    NULL, Crypt32)
#define CertOpenStore VAR_CertOpenStore

LOADER_FUNCTION( HCERTSTORE, CertDuplicateStore,
    (HCERTSTORE hCertStore),
    (hCertStore),
    NULL, Crypt32)
#define CertDuplicateStore VAR_CertDuplicateStore

LOADER_FUNCTION( BOOL, CertCloseStore,
    (HCERTSTORE hCertStore, DWORD dwFlags),
    (hCertStore, dwFlags),
    FALSE, Crypt32)
#define CertCloseStore VAR_CertCloseStore

LOADER_FUNCTION( BOOL, CertControlStore,
    (
        HCERTSTORE hCertStore,
        DWORD dwFlags,
        DWORD dwCtrlType,
        void const *pvCtrlPara
    ),
    (
        hCertStore,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
    ),
    FALSE, Crypt32)
#define CertControlStore VAR_CertControlStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetSubjectCertificateFromStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId),
    (hCertStore, dwCertEncodingType, pCertId),
    NULL, Crypt32)
#define CertGetSubjectCertificateFromStore VAR_CertGetSubjectCertificateFromStore

LOADER_FUNCTION( PCCERT_CONTEXT, CertGetIssuerCertificateFromStore,
    (HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags),
    (hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags),
    NULL, Crypt32)
#define CertGetIssuerCertificateFromStore VAR_CertGetIssuerCertificateFromStore

LOADER_FUNCTION( BOOL, CertGetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData),
    (pCertContext, dwPropId, pvData, pcbData),
    FALSE, Crypt32)
#define CertGetCertificateContextProperty VAR_CertGetCertificateContextProperty

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToEncode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, void const *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToEncode VAR_CryptMsgOpenToEncode

LOADER_FUNCTION( HCRYPTMSG, CryptMsgOpenToDecode,
    (DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo),
    (dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo),
    NULL, Crypt32)
#define CryptMsgOpenToDecode VAR_CryptMsgOpenToDecode

LOADER_FUNCTION( BOOL, CryptMsgUpdate,
    (HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal),
    (hCryptMsg, pbData, cbData, fFinal),
    FALSE, Crypt32)
#define CryptMsgUpdate VAR_CryptMsgUpdate

LOADER_FUNCTION( BOOL, CryptMsgGetParam,
    (HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData),
    (hCryptMsg, dwParamType, dwIndex, pvData, pcbData),
    FALSE, Crypt32)
#define CryptMsgGetParam VAR_CryptMsgGetParam

LOADER_FUNCTION( BOOL, CryptMsgControl,
    (HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, void const *pvCtrlPara),
    (hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara),
    FALSE, Crypt32)
#define CryptMsgControl VAR_CryptMsgControl

LOADER_FUNCTION( BOOL, CryptMsgClose,
    (HCRYPTMSG hCryptMsg),
    (hCryptMsg),
    TRUE, Crypt32)  // return success since GLE() is meaningless
#define CryptMsgClose VAR_CryptMsgClose

LOADER_FUNCTION( BOOL, CertAddEncodedCRLToStore,
    (HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext),
    (hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext),
    FALSE, Crypt32)
#define CertAddEncodedCRLToStore VAR_CertAddEncodedCRLToStore

LOADER_FUNCTION( PCCRL_CONTEXT, CertEnumCRLsInStore,
    (HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext),
    (hCertStore, pPrevCrlContext),
    NULL, Crypt32)
#define CertEnumCRLsInStore VAR_CertEnumCRLsInStore

LOADER_FUNCTION( PCERT_EXTENSION, CertFindExtension,
    (LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[]),
    (pszObjId, cExtensions, rgExtensions),
    NULL, Crypt32)
#define CertFindExtension VAR_CertFindExtension

LOADER_FUNCTION( PCERT_CONTEXT, CertCreateCertificateContext,
    (DWORD dwCertEncodingType, const BYTE * pbCertEncoded, DWORD cbCertEncoded),
    (dwCertEncodingType, pbCertEncoded, cbCertEncoded),
    NULL, Crypt32)
#define CertCreateCertificateContext VAR_CertCreateCertificateContext

LOADER_FUNCTION( DWORD, CertNameToStrA,
    (DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType,
    LPSTR psz, DWORD csz),
    (dwCertEncodingType, pName, dwStrType, psz, csz),
    NULL, Crypt32)
#define CertNameToStrA VAR_CertNameToStrA

LOADER_FUNCTION( BOOL, CertGetEnhancedKeyUsage,
    (PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage,
     DWORD *pcbUsage),
    (pCertContext, dwFlags, pUsage, pcbUsage),
    FALSE, Crypt32)
#define CertGetEnhancedKeyUsage VAR_CertGetEnhancedKeyUsage

LOADER_FUNCTION( DWORD, CertAddStoreToCollection,
    (HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags,
     DWORD dwPriority),
    (hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority),
    NULL, Crypt32)
#define CertAddStoreToCollection VAR_CertAddStoreToCollection

LOADER_FUNCTION( BOOL, CertSetCertificateContextProperty,
    (PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData),
    (pCertContext, dwPropId, dwFlags, pvData),
    NULL, Crypt32)
#define CertSetCertificateContextProperty VAR_CertSetCertificateContextProperty

LOADER_FUNCTION( BOOL, CertVerifySubjectCertificateContext,
    (PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags),
    (pSubject, pIssuer, pdwFlags),
    FALSE, Crypt32)
#define CertVerifySubjectCertificateContext VAR_CertVerifySubjectCertificateContext

LOADER_FUNCTION_VOID( void, CertFreeCertificateChain,
    (PCCERT_CHAIN_CONTEXT pChainContext),
    (pChainContext),
    Crypt32)
#define CertFreeCertificateChain VAR_CertFreeCertificateChain

LOADER_FUNCTION( BOOL, CertGetCertificateChain,
    (HCERTCHAINENGINE hChainEngine, PCCERT_CONTEXT pCertContext, LPFILETIME pTime, HCERTSTORE hAdditionalStore, 
     PCERT_CHAIN_PARA pChainPara, DWORD dwFlags, LPVOID pvReserved, PCCERT_CHAIN_CONTEXT* ppChainContext),
    (hChainEngine, pCertContext, pTime, hAdditionalStore, pChainPara, dwFlags, pvReserved, ppChainContext),
    FALSE, Crypt32)
#define CertGetCertificateChain VAR_CertGetCertificateChain

LOADER_FUNCTION( BOOL, CertVerifyCertificateChainPolicy,
    (LPCSTR pszPolicyOID, PCCERT_CHAIN_CONTEXT pChainContext, PCERT_CHAIN_POLICY_PARA pPolicyPara, PCERT_CHAIN_POLICY_STATUS pPolicyStatus),
    (pszPolicyOID, pChainContext, pPolicyPara, pPolicyStatus),
    FALSE, Crypt32)
#define CertVerifyCertificateChainPolicy VAR_CertVerifyCertificateChainPolicy

/////////////////////////////////////
// CRYPTDLG.DLL

#define _CRYPTDLG_

// Old cert dialogs
typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A *PCERT_VIEWPROPERTIES_STRUCT_A;
typedef struct tagCSSA *PCERT_SELECT_STRUCT_A;

BOOL DemandLoadCryptDlg();

LOADER_FUNCTION( BOOL, CertViewPropertiesA,
    (PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo),
    (pCertViewInfo),
    FALSE, CryptDlg)
#define CertViewPropertiesA VAR_CertViewPropertiesA

LOADER_FUNCTION( DWORD, GetFriendlyNameOfCertA,
    (PCCERT_CONTEXT pccert, LPSTR pchBuffer, DWORD cchBuffer),
    (pccert, pchBuffer, cchBuffer),
    0, CryptDlg)
#define GetFriendlyNameOfCertA VAR_GetFriendlyNameOfCertA

LOADER_FUNCTION( BOOL, CertSelectCertificateA,
    (PCERT_SELECT_STRUCT_A pCertSelectInfo),
    (pCertSelectInfo),
    FALSE, CryptDlg)
#define CertSelectCertificateA VAR_CertSelectCertificateA

/////////////////////////////////////
// WINTRUST.DLL

BOOL DemandLoadWinTrust();

LOADER_FUNCTION( LONG, WinVerifyTrust,
    (HWND hwnd, GUID *ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData),
    0, WinTrust)
#define WinVerifyTrust VAR_WinVerifyTrust

/////////////////////////////////////
// WININET.DLL

#include <wininet.h>

#define _WININET_

typedef struct _INTERNET_CACHE_ENTRY_INFOA INTERNET_CACHE_ENTRY_INFOA;

BOOL DemandLoadWinINET();

LOADER_FUNCTION( BOOL, RetrieveUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, INTERNET_CACHE_ENTRY_INFOA *lpCacheEntryInfo, LPDWORD lpdwCacheEntryInfoBufferSize, DWORD dwReserved),
    (lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved),
    FALSE, WinINET)
#define RetrieveUrlCacheEntryFileA VAR_RetrieveUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, CommitUrlCacheEntryA,
    (LPCSTR lpszUrlName, LPCSTR lpszLocalFileName, FILETIME ExpireTime, FILETIME LastModifiedTime, DWORD CacheEntryType, LPBYTE lpHeaderInfo,
     DWORD dwHeaderSize, LPCSTR lpszFileExtension, LPCSTR lpszOriginalUrl),
    (lpszUrlName, lpszLocalFileName, ExpireTime, LastModifiedTime, CacheEntryType, lpHeaderInfo,
     dwHeaderSize, lpszFileExtension, lpszOriginalUrl),
    FALSE, WinINET)
#define CommitUrlCacheEntryA VAR_CommitUrlCacheEntryA

LOADER_FUNCTION( BOOL, CreateUrlCacheEntryA,
    (LPCSTR lpszUrlName, DWORD dwExpectedFileSize, LPCSTR lpszFileExtension, LPSTR lpszFileName, DWORD dwReserved),
    (lpszUrlName, dwExpectedFileSize, lpszFileExtension, lpszFileName, dwReserved),
    FALSE, WinINET)
#define CreateUrlCacheEntryA VAR_CreateUrlCacheEntryA
    
LOADER_FUNCTION( BOOL, DeleteUrlCacheEntryA,
    (LPCSTR lpszUrlName),
    (lpszUrlName),
    FALSE, WinINET)
#define DeleteUrlCacheEntryA VAR_DeleteUrlCacheEntryA

LOADER_FUNCTION( BOOL, UnlockUrlCacheEntryFileA,
    (LPCSTR  lpszUrlName, DWORD dwRes),
    (lpszUrlName, dwRes),
    FALSE, WinINET)
#define UnlockUrlCacheEntryFileA VAR_UnlockUrlCacheEntryFileA

LOADER_FUNCTION( BOOL, InternetQueryOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength),
    (hInternet, dwOption, lpBuffer, lpdwBufferLength),
    NULL, WinINET)
#define InternetQueryOptionA VAR_InternetQueryOptionA

LOADER_FUNCTION( BOOL, InternetSetOptionA,
    (HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength),
    (hInternet, dwOption, lpBuffer, dwBufferLength),
    NULL, WinINET)
#define InternetSetOptionA VAR_InternetSetOptionA

LOADER_FUNCTION( BOOL, InternetDialA,
    (HWND hwndParent, LPSTR lpszConnectoid, DWORD dwFlags, DWORD_PTR *lpdwConnection, DWORD dwReserved),
    (hwndParent, lpszConnectoid, dwFlags, lpdwConnection, dwReserved),
    NULL, WinINET)
#define InternetDialA VAR_InternetDialA

LOADER_FUNCTION( BOOL, InternetHangUp,
    (DWORD_PTR dwConnection, DWORD dwReserved),
    (dwConnection, dwReserved),
    NULL, WinINET)
#define InternetHangUp VAR_InternetHangUp

LOADER_FUNCTION(BOOL, InternetGetConnectedStateExA, 
                (LPDWORD dwFlags,  LPTSTR szconn, DWORD size, DWORD reserved),
                (dwFlags, szconn, size, reserved),
                FALSE, WinINET)
#define InternetGetConnectedStateExA  VAR_InternetGetConnectedStateExA

LOADER_FUNCTION(BOOL, InternetCombineUrlA, 
                (LPCSTR lpszBaseUrl, LPCSTR lpszRelativeUrl, LPSTR lpszBuffer, LPDWORD lpdwBufferLength, DWORD dwFlags),
                (lpszBaseUrl, lpszRelativeUrl, lpszBuffer, lpdwBufferLength, dwFlags),
                FALSE, WinINET)
#define InternetCombineUrlA  VAR_InternetCombineUrlA

LOADER_FUNCTION(BOOL, InternetCrackUrlA, 
                (LPCSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTS lpUrlComponents),
                (lpszUrl, dwUrlLength, dwFlags, lpUrlComponents),
                FALSE, WinINET)
#define InternetCrackUrlA  VAR_InternetCrackUrlA

LOADER_FUNCTION(BOOL, InternetCloseHandle, 
                (HINTERNET hInternet),
                (hInternet),
                FALSE, WinINET)
#define   InternetCloseHandle   VAR_InternetCloseHandle

LOADER_FUNCTION(BOOL, InternetReadFile, 
                (HINTERNET hInternet, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead),
                (hInternet, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead),
                FALSE, WinINET)
#define   InternetReadFile   VAR_InternetReadFile

LOADER_FUNCTION(HINTERNET, InternetConnectA, 
                (HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort,
                            LPCSTR lpszUserName,LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext),
                (hInternet, lpszServerName, nServerPort, lpszUserName, lpszPassword, dwService, dwFlags, dwContext),
                NULL, WinINET)
#define   InternetConnectA   VAR_InternetConnectA

LOADER_FUNCTION(HINTERNET, InternetOpenA, 
                (LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags),
                (lpszAgent, dwAccessType, lpszProxy, lpszProxyBypass, dwFlags),
                NULL, WinINET)
#define   InternetOpenA   VAR_InternetOpenA

LOADER_FUNCTION(INTERNET_STATUS_CALLBACK, InternetSetStatusCallbackA,
                (HINTERNET hInternet, INTERNET_STATUS_CALLBACK lpfnInternetCallback),
                (hInternet, lpfnInternetCallback),
                NULL, WinINET)
#define   InternetSetStatusCallbackA   VAR_InternetSetStatusCallbackA

LOADER_FUNCTION(BOOL, HttpQueryInfoA, 
                (HINTERNET hRequest, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpdwBufferLength, LPDWORD lpdwIndex),
                (hRequest, dwInfoLevel, lpBuffer, lpdwBufferLength, lpdwIndex),
                FALSE, WinINET)
#define   HttpQueryInfoA   VAR_HttpQueryInfoA

LOADER_FUNCTION(HINTERNET, HttpOpenRequestA, 
                (HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion,
                            LPCSTR lpszReferrer, LPCSTR FAR * lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext),
                ( hConnect, lpszVerb, lpszObjectName, lpszVersion, lpszReferrer, lplpszAcceptTypes, dwFlags, dwContext),
                NULL, WinINET)
#define   HttpOpenRequestA   VAR_HttpOpenRequestA

LOADER_FUNCTION(BOOL, HttpAddRequestHeadersA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwModifiers),
                (hRequest, lpszHeaders, dwHeadersLength, dwModifiers),
                FALSE, WinINET)
#define   HttpAddRequestHeadersA   VAR_HttpAddRequestHeadersA

LOADER_FUNCTION(BOOL, HttpSendRequestA, 
                (HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength),
                (hRequest, lpszHeaders, dwHeadersLength, lpOptional, dwOptionalLength),
                FALSE, WinINET)
#define   HttpSendRequestA   VAR_HttpSendRequestA

LOADER_FUNCTION(BOOL, InternetWriteFile, 
                (HINTERNET hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite, LPDWORD lpdwNumberOfBytesWritten),
                (hFile, lpBuffer, dwNumberOfBytesToWrite, lpdwNumberOfBytesWritten),
                FALSE, WinINET)
#define   InternetWriteFile   VAR_InternetWriteFile

LOADER_FUNCTION(BOOL, HttpEndRequestA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD_PTR dwContext),
                (hRequest, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpEndRequestA   VAR_HttpEndRequestA

LOADER_FUNCTION(BOOL, HttpSendRequestExA, 
                (HINTERNET hRequest, LPINTERNET_BUFFERSA lpBuffersIn,
                                LPINTERNET_BUFFERSA lpBuffersOut, DWORD dwFlags, DWORD_PTR dwContext),
                (hRequest, lpBuffersIn, lpBuffersOut, dwFlags, dwContext),
                FALSE, WinINET)
#define   HttpSendRequestExA   VAR_HttpSendRequestExA

/////////////////////////////////////
// SHELL32.DLL

#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>

BOOL DemandLoadSHELL32();

LOADER_FUNCTION(BOOL, SHFree, // Actually a void
   (LPVOID lpv),
   (lpv),
   FALSE, SHELL32)
#define SHFree VAR_SHFree

LOADER_FUNCTION(BOOL, SHGetPathFromIDListA,
    (LPCITEMIDLIST pidl, LPSTR pszPath),
    (pidl, pszPath),
    FALSE, SHELL32)
#define SHGetPathFromIDListA VAR_SHGetPathFromIDListA

LOADER_FUNCTION(BOOL, SHGetPathFromIDListW,
    (LPCITEMIDLIST pidl, LPWSTR pwszPath),
    (pidl, pwszPath),
    FALSE, SHELL32)
#define SHGetPathFromIDListW VAR_SHGetPathFromIDListW

LOADER_FUNCTION(HRESULT, SHGetSpecialFolderLocation,
    (HWND hwndOwner, int nFolder, LPITEMIDLIST * ppidl),
    (hwndOwner, nFolder, ppidl),
    E_FAIL, SHELL32)
#define SHGetSpecialFolderLocation VAR_SHGetSpecialFolderLocation

LOADER_FUNCTION(LPITEMIDLIST, SHBrowseForFolderA,
    (LPBROWSEINFOA lpbi),
    (lpbi),
    NULL, SHELL32)
#define SHBrowseForFolderA VAR_SHBrowseForFolderA

LOADER_FUNCTION(LPITEMIDLIST, SHBrowseForFolderW,
    (LPBROWSEINFOW lpbi),
    (lpbi),
    NULL, SHELL32)
#define SHBrowseForFolderW VAR_SHBrowseForFolderW

LOADER_FUNCTION(HRESULT, SHSetUnreadMailCountW,
    (LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand),
    (pszMailAddress, dwCount, pszShellExecuteCommand),
    NULL, SHELL32)
#define SHSetUnreadMailCountW VAR_SHSetUnreadMailCountW

LOADER_FUNCTION(HINSTANCE, ShellExecuteA,
    (HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd),
    (hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd),
    NULL, SHELL32)
#define ShellExecuteA VAR_ShellExecuteA

LOADER_FUNCTION(BOOL, ShellExecuteExA,
    (LPSHELLEXECUTEINFOA lpExecInfo),
    (lpExecInfo),
    FALSE, SHELL32)
#define ShellExecuteExA VAR_ShellExecuteExA

LOADER_FUNCTION(UINT, DragQueryFileA,
    (HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cb),
    (hDrop, iFile, lpszFile, cb),
    0, SHELL32)
#define DragQueryFileA VAR_DragQueryFileA

LOADER_FUNCTION(DWORD, SHGetFileInfoA,
    (LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags),
    (pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags),
    0, SHELL32)
#define SHGetFileInfoA VAR_SHGetFileInfoA

LOADER_FUNCTION(BOOL, Shell_NotifyIconA,
    (DWORD dwMessage, PNOTIFYICONDATAA lpData),
    (dwMessage, lpData),
    FALSE, SHELL32)
#define Shell_NotifyIconA VAR_Shell_NotifyIconA

LOADER_FUNCTION(int, SHFileOperationA,
    (LPSHFILEOPSTRUCTA lpfo),
    (lpfo),
    -1, SHELL32)
#define SHFileOperationA VAR_SHFileOperationA

LOADER_FUNCTION(HICON, ExtractIconA,
    (HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex),
    (hInst, lpszExeFileName, nIconIndex),
    NULL, SHELL32)
#define ExtractIconA VAR_ExtractIconA

#if 0
/////////////////////////////////////
// OLEAUT32.DLL

BOOL DemandLoadOLEAUT32();

#include <olectl.h>

LOADER_FUNCTION(SAFEARRAY *, SafeArrayCreate,
    (VARTYPE vt, UINT cDims, SAFEARRAYBOUND* rgsabound),
    (vt, cDims, rgsabound),
    NULL, OLEAUT32)
#define SafeArrayCreate VAR_SafeArrayCreate

LOADER_FUNCTION(HRESULT, SafeArrayPutElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv),
    (psa, rgIndices, pv),
    E_FAIL, OLEAUT32)
#define SafeArrayPutElement VAR_SafeArrayPutElement

LOADER_FUNCTION(HRESULT, DispInvoke,
    (void * _this, ITypeInfo * ptinfo, DISPID dispidMember, WORD wFlags, DISPPARAMS * pparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr),
    (_this, ptinfo, dispidMember, wFlags, pparams, pvarResult, pexcepinfo, puArgErr),
    E_FAIL, OLEAUT32)
#define DispInvoke VAR_DispInvoke

LOADER_FUNCTION(HRESULT, DispGetIDsOfNames,
    (ITypeInfo * ptinfo, OLECHAR ** rgszNames, UINT cNames, DISPID * rgdispid),
    (ptinfo, rgszNames, cNames, rgdispid),
    E_FAIL, OLEAUT32)
#define DispGetIDsOfNames VAR_DispGetIDsOfNames

LOADER_FUNCTION(BSTR, SysAllocStringByteLen,
    (LPCSTR psz, UINT len),
    (psz, len),
    NULL, OLEAUT32)
#define SysAllocStringByteLen VAR_SysAllocStringByteLen

LOADER_FUNCTION(int, SysReAllocString,
    (BSTR * pbstr,  const OLECHAR * sz),
    (pbstr, sz),
    0, OLEAUT32)
#define SysReAllocString VAR_SysReAllocString

LOADER_FUNCTION(BSTR, SysAllocStringLen,
    (const OLECHAR *pch, unsigned int i),
    (pch, i),
    NULL, OLEAUT32)
#define SysAllocStringLen VAR_SysAllocStringLen

LOADER_FUNCTION(BSTR, SysAllocString,
    (const OLECHAR *pch),
    (pch),
    NULL, OLEAUT32)
#define SysAllocString VAR_SysAllocString

LOADER_FUNCTION(BOOL, SysFreeString,  // Actually a void
    (BSTR bs),
    (bs),
    FALSE, OLEAUT32)
#define SysFreeString VAR_SysFreeString

LOADER_FUNCTION(UINT, SysStringLen,
    (BSTR bs),
    (bs),
    0, OLEAUT32)
#define SysStringLen VAR_SysStringLen

LOADER_FUNCTION(BOOL, VariantInit,
    (VARIANTARG * pvarg),
    (pvarg),
    FALSE, OLEAUT32)
#define VariantInit VAR_VariantInit

LOADER_FUNCTION(HRESULT, LoadTypeLib,
    (const OLECHAR  *szFile, ITypeLib ** pptlib),
    (szFile, pptlib),
    E_FAIL, OLEAUT32)
#define LoadTypeLib VAR_LoadTypeLib

LOADER_FUNCTION(HRESULT, RegisterTypeLib,
    (ITypeLib * ptlib, OLECHAR  *szFullPath, OLECHAR  *szHelpDir),
    (ptlib, szFullPath, szHelpDir),
    E_FAIL, OLEAUT32)
#define RegisterTypeLib VAR_RegisterTypeLib

LOADER_FUNCTION(HRESULT, SafeArrayAccessData,
    (SAFEARRAY * psa, void HUGEP** ppvData),
    (psa, ppvData),
    E_FAIL, OLEAUT32)
#define SafeArrayAccessData VAR_SafeArrayAccessData

LOADER_FUNCTION(HRESULT, SafeArrayUnaccessData,
    (SAFEARRAY * psa),
    (psa),
    E_FAIL, OLEAUT32)
#define SafeArrayUnaccessData VAR_SafeArrayUnaccessData

LOADER_FUNCTION(UINT, SysStringByteLen,
    (BSTR bstr),
    (bstr),
    0, OLEAUT32)
#define SysStringByteLen VAR_SysStringByteLen

LOADER_FUNCTION(HRESULT, SafeArrayDestroy,
    (SAFEARRAY *psa),
    (psa),
    E_FAIL, OLEAUT32)
#define SafeArrayDestroy VAR_SafeArrayDestroy

LOADER_FUNCTION(HRESULT, SafeArrayGetElement,
    (SAFEARRAY * psa, LONG * rgIndices, void * pv),
    (psa, rgIndices, pv),
    E_FAIL, OLEAUT32)
#define SafeArrayGetElement VAR_SafeArrayGetElement

LOADER_FUNCTION(HRESULT, SafeArrayGetUBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plUbound),
    (psa, nDim, plUbound),
    E_FAIL, OLEAUT32)
#define SafeArrayGetUBound VAR_SafeArrayGetUBound

LOADER_FUNCTION(HRESULT, SafeArrayGetLBound,
    (SAFEARRAY * psa, UINT nDim, LONG * plLbound),
    (psa, nDim, plLbound),
    E_FAIL, OLEAUT32)
#define SafeArrayGetLBound VAR_SafeArrayGetLBound

LOADER_FUNCTION(HRESULT, VariantClear,
    (VARIANTARG * pvarg),
    (pvarg),
    E_FAIL, OLEAUT32)
#define VariantClear VAR_VariantClear

LOADER_FUNCTION(HRESULT, VariantCopy,
    (VARIANTARG * pvargDest, VARIANTARG * pvargSrc),
    (pvargDest, pvargSrc),
    E_FAIL, OLEAUT32)
#define VariantCopy VAR_VariantCopy

LOADER_FUNCTION(HRESULT, SetErrorInfo,
    (ULONG dwReserved, IErrorInfo * perrinfo),
    (dwReserved, perrinfo),
    E_FAIL, OLEAUT32)
#define SetErrorInfo VAR_SetErrorInfo

LOADER_FUNCTION(HRESULT, CreateErrorInfo,
    (ICreateErrorInfo ** pperrinfo),
    (pperrinfo),
    E_FAIL, OLEAUT32)
#define CreateErrorInfo VAR_CreateErrorInfo

#endif

/////////////////////////////////////
// COMDLG32.DLL

#include <commdlg.h>

BOOL DemandLoadCOMDLG32();

LOADER_FUNCTION(BOOL, GetSaveFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetSaveFileNameA VAR_GetSaveFileNameA

LOADER_FUNCTION(BOOL, GetOpenFileNameA,
    (LPOPENFILENAME pof),
    (pof),
    FALSE, COMDLG32)
#define GetOpenFileNameA VAR_GetOpenFileNameA

LOADER_FUNCTION(BOOL, ChooseFontA,
    (LPCHOOSEFONT pcf),
    (pcf),
    FALSE, COMDLG32)
#define ChooseFontA VAR_ChooseFontA

/////////////////////////////////////
// VERSION.DLL

BOOL DemandLoadVERSION();

LOADER_FUNCTION(BOOL, VerQueryValueA,
    (const LPVOID pBlock, LPSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen),
    (pBlock, lpSubBlock, lplpBuffer, puLen),
    FALSE, VERSION)
#define VerQueryValueA VAR_VerQueryValueA

LOADER_FUNCTION(BOOL, GetFileVersionInfoA,
    (PSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData),
    (lptstrFilename, dwHandle, dwLen, lpData),
    FALSE, VERSION)
#define GetFileVersionInfoA VAR_GetFileVersionInfoA

LOADER_FUNCTION(DWORD, GetFileVersionInfoSizeA,
    (LPSTR lptstrFilename, LPDWORD lpdwHandle),
    (lptstrFilename, lpdwHandle),
    0, VERSION)
#define GetFileVersionInfoSizeA VAR_GetFileVersionInfoSizeA

/////////////////////////////////////
// URLMON.DLL

BOOL DemandLoadURLMON();

LOADER_FUNCTION(HRESULT, CreateURLMoniker,
    (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR *ppmk),
    (pMkCtx, szURL, ppmk),
    E_FAIL, URLMON)
#define CreateURLMoniker VAR_CreateURLMoniker

LOADER_FUNCTION(HRESULT, URLOpenBlockingStreamA,
    (LPUNKNOWN pUnk,LPCSTR pURL,LPSTREAM* ppstm,DWORD i,LPBINDSTATUSCALLBACK p),
    (pUnk, pURL, ppstm, i, p),
    E_FAIL, URLMON)
#define URLOpenBlockingStreamA VAR_URLOpenBlockingStreamA

LOADER_FUNCTION(HRESULT, FindMimeFromData,
    (LPBC pBC, LPCWSTR pwzUrl, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeProposed, DWORD dwMimeFlags, LPWSTR *ppwzMimeOut, DWORD dwReserved),
    (pBC, pwzUrl, pBuffer, cbSize, pwzMimeProposed, dwMimeFlags, ppwzMimeOut, dwReserved),
    E_FAIL, URLMON)
#define FindMimeFromData VAR_FindMimeFromData

LOADER_FUNCTION( HRESULT, CoInternetCombineUrl,
    (LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
    (pwzBaseUrl, pwzRelativeUrl, dwCombineFlags, pszResult, cchResult, pcchResult, dwReserved),
    E_FAIL, URLMON)
#define CoInternetCombineUrl VAR_CoInternetCombineUrl

LOADER_FUNCTION( HRESULT, RegisterBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb, IBindStatusCallback**  ppBSCBPrev, DWORD dwReserved),
    (pBC, pBSCb, ppBSCBPrev, dwReserved),
    E_FAIL, URLMON)
#define RegisterBindStatusCallback VAR_RegisterBindStatusCallback

LOADER_FUNCTION( HRESULT, RevokeBindStatusCallback,
    (LPBC pBC, IBindStatusCallback *pBSCb),
    (pBC, pBSCb),
    E_FAIL, URLMON)
#define RevokeBindStatusCallback VAR_RevokeBindStatusCallback

LOADER_FUNCTION( HRESULT, FaultInIEFeature,
    (HWND hwnd,     uCLSSPEC    *classpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
    (hwnd, classpec, pQuery, dwFlags),
    E_FAIL, URLMON)
#define FaultInIEFeature VAR_FaultInIEFeature

LOADER_FUNCTION( HRESULT, CoInternetGetSecurityUrl,
    (LPCWSTR pwzUrl, LPWSTR  *ppwzSecUrl, PSUACTION  psuAction, DWORD   dwReserved),
    (pwzUrl, ppwzSecUrl, psuAction, dwReserved),
    E_FAIL, URLMON)
#define CoInternetGetSecurityUrl VAR_CoInternetGetSecurityUrl

LOADER_FUNCTION( HRESULT, ObtainUserAgentString,
    (DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize),
    (dwOption, pszUAOut, cbSize),
    E_FAIL, URLMON)
#define ObtainUserAgentString VAR_ObtainUserAgentString

LOADER_FUNCTION( HRESULT, CoInternetCreateSecurityManager,
    (IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved),
    (pSP, ppSM, dwReserved),
    E_FAIL, URLMON)
#define CoInternetCreateSecurityManager VAR_CoInternetCreateSecurityManager

/////////////////////////////////////
// MLANG.DLL

#include <mlang.h>

BOOL DemandLoadMLANG(void);

LOADER_FUNCTION( HRESULT, IsConvertINetStringAvailable,
    (DWORD dwSrcEncoding, DWORD dwDstEncoding),
    (dwSrcEncoding, dwDstEncoding),
    S_FALSE, MLANG)
#define IsConvertINetStringAvailable VAR_IsConvertINetStringAvailable

LOADER_FUNCTION( HRESULT, ConvertINetString,
    (LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding, LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize),
    (lpdwMode, dwSrcEncoding, dwDstEncoding, lpSrcStr, lpnSrcSize, lpDstStr, lpnDstSize),
    E_FAIL, MLANG)
#define ConvertINetString VAR_ConvertINetString

/////////////////////////////////////
// SHDOCVW.DLL

#include <shlobjp.h>
BOOL DemandLoadSHDOCVW();

LOADER_FUNCTION(HRESULT, AddUrlToFavorites,
    (HWND hwnd, LPWSTR pszUrlW, LPWSTR pszTitleW, BOOL fDisplayUI),
    (hwnd, pszUrlW, pszTitleW, fDisplayUI),
    E_FAIL, SHDOCVW)
#define AddUrlToFavorites VAR_AddUrlToFavorites

LOADER_FUNCTION(long, SetQueryNetSessionCount,
    (enum SessionOp Op),
    (Op),
    0, SHDOCVW)
#define SetQueryNetSessionCount VAR_SetQueryNetSessionCount

LOADER_FUNCTION_VOID(void, SetShellOfflineState,
    (BOOL fPutOfflineState),
    (fPutOfflineState),
    SHDOCVW)
#define SetShellOfflineState    VAR_SetShellOfflineState


/////////////////////////////////////
// INETCPL.CPL

BOOL DemandLoadINETCPL();

LOADER_FUNCTION(int, OpenFontsDialog,
    (HWND hwnd, LPCSTR lpszKey),
    (hwnd, lpszKey),
    0, INETCPL)
#define OpenFontsDialog VAR_OpenFontsDialog

LOADER_FUNCTION(BOOL, LaunchConnectionDialog,
    (HWND   hwnd),
    (hwnd),
    FALSE,  INETCPL)
#define LaunchConnectionDialog VAR_LaunchConnectionDialog

/////////////////////////////////////
// MSO9.DLL
#include "msoci.h"
BOOL DemandLoadMSO9();

LOADER_FUNCTION(BOOL, MsoFGetComponentManager,
    (IMsoComponentManager **ppicm),
    (ppicm),
    FALSE, MSO9)
#define MsoFGetComponentManager VAR_MsoFGetComponentManager

/////////////////////////////////////
// WINMM.DLL


BOOL DemandLoadWinMM();

LOADER_FUNCTION(BOOL, sndPlaySoundA,
    (LPCSTR pszSound, UINT fuSound),
    (pszSound, fuSound),
    FALSE, WinMM)
#define sndPlaySoundA VAR_sndPlaySoundA

/////////////////////////////////////
// WSOCK32.DLL

#include <winsock.h>

typedef struct WSAData FAR * LPWSADATA;
typedef unsigned int    u_int;
typedef unsigned short  u_short;
#ifdef _WIN64
typedef UINT_PTR		SOCKET;
#else
typedef u_int           SOCKET;
#endif	// _WIN64

BOOL DemandLoadWSOCK32();

LOADER_FUNCTION( int, WSAStartup,
    (WORD wVersionRequired, LPWSADATA lpWSAData),
    (wVersionRequired, lpWSAData),
    WSAVERNOTSUPPORTED, WSOCK32)
#define WSAStartup VAR_WSAStartup

LOADER_FUNCTION( int, WSACleanup,
    (void),
    (),
    SOCKET_ERROR, WSOCK32)
#define WSACleanup VAR_WSACleanup

LOADER_FUNCTION( int, WSAGetLastError,
    (void),
    (),
    0, WSOCK32)
#define WSAGetLastError VAR_WSAGetLastError

LOADER_FUNCTION( int, gethostname,
    (char FAR * name, int namelen),
    (name, namelen),
    SOCKET_ERROR, WSOCK32)
#define gethostname VAR_gethostname

LOADER_FUNCTION( struct hostent FAR *, gethostbyname,
    (const char FAR * name),
    (name),
    NULL, WSOCK32)
#define gethostbyname VAR_gethostbyname

LOADER_FUNCTION( HANDLE, WSAAsyncGetHostByName,
    (HWND hWnd, u_int wMsg, const char FAR * name, char FAR * buf, int buflen),
    (hWnd, wMsg, name, buf, buflen),
    0, WSOCK32)
#define WSAAsyncGetHostByName VAR_WSAAsyncGetHostByName

LOADER_FUNCTION( unsigned long, inet_addr,
    (const char FAR * cp),
    (cp),
    INADDR_NONE, WSOCK32)
#define inet_addr VAR_inet_addr

LOADER_FUNCTION( u_short, htons,
    (u_short hostshort),
    (hostshort),
    0, WSOCK32)
#define htons VAR_htons

LOADER_FUNCTION( int, WSACancelAsyncRequest,
    (HANDLE hAsyncTaskHandle),
    (hAsyncTaskHandle),
    SOCKET_ERROR, WSOCK32)
#define WSACancelAsyncRequest VAR_WSACancelAsyncRequest

LOADER_FUNCTION( int, send,
    (SOCKET s, const char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define send VAR_send

LOADER_FUNCTION( int, connect,
    (SOCKET s, const struct sockaddr FAR *name, int namelen),
    (s, name, namelen),
    SOCKET_ERROR, WSOCK32)
#define connect VAR_connect

LOADER_FUNCTION( int, WSAAsyncSelect,
    (SOCKET s, HWND hWnd, u_int wMsg, long lEvent),
    (s, hWnd, wMsg, lEvent),
    SOCKET_ERROR, WSOCK32)
#define WSAAsyncSelect VAR_WSAAsyncSelect

LOADER_FUNCTION( SOCKET, socket,
    (int af, int type, int protocol),
    (af, type, protocol),
    INVALID_SOCKET, WSOCK32)
#define socket VAR_socket

LOADER_FUNCTION( char FAR *, inet_ntoa,
    (struct in_addr in),
    (in),
    NULL, WSOCK32)
#define inet_ntoa VAR_inet_ntoa

LOADER_FUNCTION( int, closesocket,
    (SOCKET s),
    (s),
    SOCKET_ERROR, WSOCK32)
#define closesocket VAR_closesocket

LOADER_FUNCTION( int, recv,
    (SOCKET s, char FAR * buf, int len, int flags),
    (s, buf, len, flags),
    SOCKET_ERROR, WSOCK32)
#define recv VAR_recv

/////////////////////////////////////
// PSTOREC.DLL

#ifndef __IEnumPStoreProviders_FWD_DEFINED__
    #define __IEnumPStoreProviders_FWD_DEFINED__
    typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif 	/* __IEnumPStoreProviders_FWD_DEFINED__ */
#ifndef __IPStore_FWD_DEFINED__
    #define __IPStore_FWD_DEFINED__
    typedef interface IPStore IPStore;
#endif 	/* __IPStore_FWD_DEFINED__ */
typedef GUID PST_PROVIDERID;

BOOL DemandLoadPStoreC();

LOADER_FUNCTION( HRESULT, PStoreCreateInstance,
    (IPStore __RPC_FAR *__RPC_FAR *ppProvider, PST_PROVIDERID __RPC_FAR *pProviderID, void __RPC_FAR *pReserved, DWORD dwFlags),
    (ppProvider, pProviderID, pReserved, dwFlags),
    E_FAIL, PStoreC)
#define PStoreCreateInstance VAR_PStoreCreateInstance

/////////////////////////////////////
// RICHED32.DLL
// note: special case as we don't use any riched functions but need to LoadLibrary it.

BOOL DemandLoadRichEdit();

/////////////////////////////////////
// RAS.DLL
#include <ras.h>
#include <raserror.h>

extern BOOL DemandLoadRAS(void);

LOADER_FUNCTION( DWORD, RasEnumEntriesA,
    (LPSTR reserved, LPSTR lpszPhoneBook, LPRASENTRYNAMEA lpEntry, LPDWORD lpcb, LPDWORD lpcEntries),
    (reserved, lpszPhoneBook, lpEntry, lpcb, lpcEntries),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEnumEntriesA VAR_RasEnumEntriesA

LOADER_FUNCTION( DWORD, RasEditPhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook, LPSTR lpszEntryName),
    (hwnd, lpszPhoneBook, lpszEntryName),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasEditPhonebookEntryA VAR_RasEditPhonebookEntryA

LOADER_FUNCTION( DWORD, RasCreatePhonebookEntryA,
    (HWND hwnd, LPSTR lpszPhoneBook),
    (hwnd, lpszPhoneBook),
    ERROR_FILE_NOT_FOUND, RAS)
#define RasCreatePhonebookEntryA VAR_RasCreatePhonebookEntryA

/////////////////////////////////////
// ADVAPI32.DLL

#ifndef ALGIDDEF
    #define ALGIDDEF
    typedef unsigned int ALG_ID;
#endif
typedef ULONG_PTR HCRYPTKEY;

BOOL DemandLoadAdvApi32(void);

LOADER_FUNCTION( BOOL, CryptAcquireContextW,
    (HCRYPTPROV *phProv, LPCWSTR pszContainer, LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags),
    (phProv, pszContainer, pszProvider, dwProvType, dwFlags),
    FALSE, AdvApi32)
#define CryptAcquireContextW VAR_CryptAcquireContextW

LOADER_FUNCTION( BOOL, CryptContextAddRef,
    (HCRYPTPROV hProv, DWORD * pdwReserved, DWORD dwFlags),
    (hProv, pdwReserved, dwFlags),
    FALSE, AdvApi32)
#define CryptContextAddRef VAR_CryptContextAddRef

LOADER_FUNCTION( BOOL, CryptDuplicateKey,
    (HCRYPTKEY hkey, DWORD * pdwReserved, DWORD dwFlags, HCRYPTKEY * phKey),
    (hkey, pdwReserved, dwFlags, phKey),
    FALSE, AdvApi32)
#define CryptDuplicateKey VAR_CryptDuplicateKey

BOOL MY_CryptContextAddRef(HCRYPTPROV hProv, DWORD * pdwReserved, DWORD dwFlags);
BOOL MY_CryptDuplicateKey(HCRYPTKEY hkey, DWORD * pdwReserved, DWORD dwFlags, HCRYPTKEY * phKey);

HINSTANCE DemandLoadShlWapi(void);

/////////////////////////////////////
// CRYPTUI.DLL

#ifndef _CRYPTUI_YST
#define _CRYPTUI_YST
typedef struct _CRYPTUI_CERT_MGR_STRUCT
{
    DWORD                       dwSize;                     // REQUIRED
    HWND                        hwndParent;                 // OPTIONAL
    DWORD                       dwFlags;                    // OPTIONAL
    LPCWSTR                     pwszTitle;                   // OPTIONAL
    LPCSTR                      pszInitUsageOID;            // OPTIONAL
}CRYPTUI_CERT_MGR_STRUCT, *PCRYPTUI_CERT_MGR_STRUCT;

typedef const CRYPTUI_CERT_MGR_STRUCT *PCCRYPTUI_CERT_MGR_STRUCT;
#endif 

BOOL DemandLoadCryptUI();

LOADER_FUNCTION(BOOL, CryptUIDlgCertMgr,
    (PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr),
    (pCryptUICertMgr),
    0, CryptUI)
#define CryptUIDlgCertMgr VAR_CryptUIDlgCertMgr


/////////////////////////////////////
// MSI.DLL
// Windows Installer (DARWIN) - Used primarily for speller

#include <msi.h>

BOOL DemandLoadMSI();

LOADER_FUNCTION(UINT, MsiEnumComponentQualifiersA,
    (LPCSTR szComponent, DWORD iIndex, LPSTR lpQualifierBuf, DWORD *pcchQualifierBuf, LPSTR lpApplicationDataBuf, DWORD *pcchApplicationDataBuf),
    (       szComponent,       iIndex,       lpQualifierBuf,        pcchQualifierBuf,       lpApplicationDataBuf,        pcchApplicationDataBuf),
    ERROR_UNKNOWN_COMPONENT, MSI)
#define MsiEnumComponentQualifiersA VAR_MsiEnumComponentQualifiersA

LOADER_FUNCTION(UINT, MsiProvideQualifiedComponentA,
    (LPCSTR szCategory, LPCSTR szQualifier, DWORD dwInstallMode, LPSTR lpPathBuf, DWORD *pcchPathBuf),
    (       szCategory,        szQualifier,       dwInstallMode,       lpPathBuf,        pcchPathBuf),
    ERROR_UNKNOWN_COMPONENT, MSI)
#define MsiProvideQualifiedComponentA VAR_MsiProvideQualifiedComponentA

LOADER_FUNCTION(INSTALLSTATE, MsiLocateComponentA,
    (LPCSTR szComponent, LPSTR lpPathBuf, DWORD *pcchBuf),
    (       szComponent,       lpPathBuf,        pcchBuf),
    INSTALLSTATE_UNKNOWN, MSI)
#define MsiLocateComponentA VAR_MsiLocateComponentA

LOADER_FUNCTION(INSTALLUILEVEL, MsiSetInternalUI,
    (INSTALLUILEVEL dwUILevel, HWND *phwnd),
    (               dwUILevel,       phwnd),
    INSTALLUILEVEL_NOCHANGE, MSI)
#define MsiSetInternalUI VAR_MsiSetInternalUI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\bytestm.h ===
// --------------------------------------------------------------------------------
// Bytestm.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BYTESTM_H
#define __BYTESTM_H

// -----------------------------------------------------------------------------
// Acquire Byte Stream Data Types
// -----------------------------------------------------------------------------
typedef enum tagACQUIRETYPE {
    ACQ_COPY,           // Don't reset the object (CByteStream will free m_pbData)
    ACQ_DISPLACE        // ResetObject after acquire, the caller owns the bits
} ACQUIRETYPE;

// -----------------------------------------------------------------------------
// CByteStream
// -----------------------------------------------------------------------------
class CByteStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CByteStream(LPBYTE pb=NULL, ULONG cb=0);
    ~CByteStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
    STDMETHODIMP Read(LPVOID, ULONG, ULONG *);
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Write(const void *, ULONG, ULONG *);
    STDMETHODIMP SetSize(ULARGE_INTEGER);
    STDMETHODIMP Commit(DWORD) { return S_OK; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) { return E_NOTIMPL; }
    STDMETHODIMP Revert(void) { return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) { return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) { return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CByteStream Methods
    // -------------------------------------------------------------------------
    void AcquireBytes(ULONG *pcb, LPBYTE *ppb, ACQUIRETYPE actype);
    HRESULT HrAcquireStringA(ULONG *pcch, LPSTR *ppszStringA, ACQUIRETYPE actype);
    HRESULT HrAcquireStringW(ULONG *pcch, LPWSTR *ppszStringW, ACQUIRETYPE actype);

private:
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    void ResetObject(void);
    HRESULT _HrGrowBuffer(ULONG cbNeeded, ULONG cbExtra);

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    ULONG            m_cRef;                // Reference count
    ULONG            m_cbData;              // Number of valid bytes in m_pbData
    ULONG            m_cbAlloc;             // Current allocated size of m_pbData
    ULONG            m_iData;               // Current data index
    LPBYTE           m_pbData;              // Pointer to data buffer
};

#endif // __BYTESTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\bmapi.h ===
#include <wtypes.h>
//#include <oaidl.h>
#include <oleauto.h>
#include <mapi.h>

// Structures and Functions used by BMAPI and VB2C

#define RECIPIENT   	((USHORT)0x0001)
#define FILE        	((USHORT)0x0002)
#define MESSAGE     	((USHORT)0x0004)
#define USESAFEARRAY	((USHORT)0x1000)

#if defined (WIN32)
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#else
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG __export FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#endif

#ifndef LHANDLE
  #define LHANDLE ULONG
#endif

#ifndef ERR
  #define ERR 	USHORT
#endif


//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface function support
//-----------------------------------------------------------------------
typedef struct
{
	ULONG	ulReserved;
	BSTR 	bstrSubject;
	BSTR 	bstrNoteText;
	BSTR 	bstrMessageType;
	BSTR 	bstrDate;
	BSTR 	bstrConversationID;
	ULONG 	flFlags;
	ULONG 	nRecipCount;
	ULONG 	nFileCount;
} VB_Message,FAR *lpVB_Message;

typedef VB_Message VB_MESSAGE;
typedef VB_Message FAR *LPVB_MESSAGE;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	ulRecipClass;
	BSTR 	bstrName;
	BSTR 	bstrAddress;
	ULONG 	ulEIDSize;
	BSTR 	bstrEID;
} VB_Recip,FAR *lpVB_Recip;

typedef VB_Recip VB_RECIPIENT;
typedef VB_Recip FAR *LPVB_RECIPIENT;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	flFlags;
	ULONG 	nPosition;
	BSTR 	bstrPathName;
	BSTR 	bstrFileName;
	BSTR 	bstrFileType;
} VB_File, FAR *lpVB_File;

/*

// OLEAUT32.DLL loadlib and getprocaddress support

// WINOLEAUTAPI_(void) SysFreeString(BSTR);
typedef VOID (STDAPICALLTYPE *LPFNSYSFREESTRING)
	( BSTR bstr );

// WINOLEAUTAPI_(unsigned int) SysStringByteLen(BSTR bstr);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGBYTELEN)
	(BSTR bstr);

// WINOLEAUTAPI_(BSTR) SysAllocStringByteLen(const char FAR* psz, unsigned int len);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRINGBYTELEN)
	(const char *psz, UINT len );

// WINOLEAUTAPI_(BSTR) SysAllocString(const OLECHAR FAR*);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRING)
	(const OLECHAR * szwString);

// WINOLEAUTAPI_(int)  SysReAllocString(BSTR FAR*, const OLECHAR FAR*);
typedef INT (STDAPICALLTYPE *LPFNSYSREALLOCSTRING)
	(BSTR * lpBstr, const OLECHAR * szwString);

// WINOLEAUTAPI_(unsigned int) SysStringLen(BSTR);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGLEN)
	(BSTR bstr);

// WINOLEAUTAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYACCESSDATA)
	(struct tagSAFEARRAY *psa, void **ppvData);

// WINOLEAUTAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYUNACCESSDATA)
	(struct tagSAFEARRAY *psa);

extern LPFNSYSFREESTRING 			lpfnSysFreeString;
extern LPFNSYSSTRINGBYTELEN 		lpfnSysStringByteLen;
extern LPFNSYSALLOCSTRINGBYTELEN	lpfnSysAllocStringByteLen;
extern LPFNSYSALLOCSTRING			lpfnSysAllocString;
extern LPFNSYSREALLOCSTRING			lpfnSysReAllocString;
extern LPFNSYSSTRINGLEN				lpfnSysStringLen;
extern LPFNSAFEARRAYACCESSDATA		lpfnSafeArrayAccessData;
extern LPFNSAFEARRAYUNACCESSDATA	lpfnSafeArrayUnaccessData;

#undef SysFreeString
#undef SysStringByteLen
#undef SysAllocStringByteLen
#undef SysAllocString
#undef SysReAllocString
#undef SysStringLen
#undef SafeArrayAccessData
#undef SafeArrayUnaccessData
  

#define SysFreeString			(*lpfnSysFreeString)
#define SysStringByteLen 		(*lpfnSysStringByteLen)
#define SysAllocStringByteLen	(*lpfnSysAllocStringByteLen)
#define SysAllocString			(*lpfnSysAllocString)
#define SysReAllocString		(*lpfnSysReAllocString)
#define SysStringLen			(*lpfnSysStringLen)
#define SafeArrayAccessData		(*lpfnSafeArrayAccessData)
#define SafeArrayUnaccessData	(*lpfnSafeArrayUnaccessData)
  
    */



typedef VB_File 			VB_FILE;
typedef VB_File FAR *		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;

typedef VB_File 			VB_FILE;
typedef VB_File FAR * 		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;
typedef LPHANDLE FAR *		LPPHANDLE;

/*
#if defined WIN32




//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface functions
//-----------------------------------------------------------------------
BMAPI_ENTRY BMAPISendMail (LHANDLE 			hSession,
                           ULONG 			ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY *    lppsaRecips,
                           LPSAFEARRAY * 	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved);

BMAPI_ENTRY BMAPIFindNext(LHANDLE 	hSession,
                          ULONG 	ulUIParam,
                          BSTR * 	bstrType,
                          BSTR * 	bstrSeed,
                          ULONG 	flFlags,
                          ULONG 	ulReserved,
                          BSTR * 	lpbstrId);

BMAPI_ENTRY BMAPIReadMail (LPULONG 	lpulMessage,
                           LPULONG 	nRecips,
                           LPULONG 	nFiles,
                           LHANDLE 	hSession,
                           ULONG 	ulUIParam,
                           BSTR * 	lpbstrID,
                           ULONG 	flFlags,
                           ULONG 	ulReserved);

BMAPI_ENTRY BMAPIGetReadMail(ULONG 			lpMessage,
                             LPVB_MESSAGE 	lpvbMessage,
                             LPSAFEARRAY *  lppsaRecips,
                             LPSAFEARRAY *	lppsaFiles,
                             LPVB_RECIPIENT	lpvbOrig);

BMAPI_ENTRY BMAPISaveMail( LHANDLE 			hSession,
                           ULONG 			ulUIParam,
                           LPVB_MESSAGE 	lpM,
                           LPSAFEARRAY * 	lppsaRecips,
                           LPSAFEARRAY *	lppsaFiles,
                           ULONG 			flFlags,
                           ULONG 			ulReserved,
                           BSTR * 			lpbstrID);

BMAPI_ENTRY BMAPIAddress (LPULONG 			lpulRecip,
                          LHANDLE 			hSession,
                          ULONG 			ulUIParam,
                          BSTR * 			lpbstrCaption,
                          ULONG 			ulEditFields,
                          BSTR * 			lpbstrLabel,
                          LPULONG 			lpulRecipients,
                          LPSAFEARRAY * 	lppsaRecip,		// LPVB_RECIPIENT
                          ULONG 			ulFlags,
                          ULONG 			ulReserved);

BMAPI_ENTRY BMAPIGetAddress (ULONG			ulRecipientData,
                             ULONG 			count,
                             LPSAFEARRAY *	lppsaRecips);

BMAPI_ENTRY BMAPIDetails (LHANDLE 			hSession,
                          ULONG 			ulUIParam,
                          LPVB_RECIPIENT	lpVB,
                          ULONG 			ulFlags,
                          ULONG 			ulReserved);

BMAPI_ENTRY BMAPIResolveName (LHANDLE			hSession,
                              ULONG 			ulUIParam,
                              BSTR  			bstrMapiName,
                              ULONG 			ulFlags,
                              ULONG 			ulReserved,
                              LPVB_RECIPIENT 	lpVB);
*/

typedef ULONG (FAR PASCAL BMAPISENDMAIL)(
    LHANDLE 		hSession,
    ULONG 			ulUIParam,
    LPVB_MESSAGE 	lpM,
    LPSAFEARRAY *    lppsaRecips,
    LPSAFEARRAY * 	lppsaFiles,
    ULONG 			flFlags,
    ULONG 			ulReserved
);
typedef BMAPISENDMAIL FAR *LPBMAPISENDMAIL;
BMAPISENDMAIL BMAPISendMail;


typedef ULONG (FAR PASCAL BMAPIFINDNEXT)(
    LHANDLE hSession,
    ULONG 	ulUIParam,
    BSTR * 	bstrType,
    BSTR * 	bstrSeed,
    ULONG 	flFlags,
    ULONG 	ulReserved,
    BSTR * 	lpbstrId
);
typedef BMAPIFINDNEXT FAR *LPBMAPIFINDNEXT;
BMAPIFINDNEXT BMAPIFindNext;


typedef ULONG (FAR PASCAL BMAPIREADMAIL)(
    LPULONG     lpulMessage,
    LPULONG     nRecips,
    LPULONG     nFiles,
    LHANDLE     hSession,
    ULONG 	    ulUIParam,
    BSTR * 	    lpbstrID,
    ULONG 	    flFlags,
    ULONG 	    ulReserved
);
typedef BMAPIREADMAIL FAR *LPBMAPIREADMAIL;
BMAPIREADMAIL BMAPIReadMail;


typedef ULONG (FAR PASCAL BMAPIGETREADMAIL)(
    ULONG 			lpMessage,
    LPVB_MESSAGE 	lpvbMessage,
    LPSAFEARRAY *  lppsaRecips,
    LPSAFEARRAY *	lppsaFiles,
    LPVB_RECIPIENT	lpvbOrig    
);
typedef BMAPIGETREADMAIL FAR *LPBMAPIGETREADMAIL;
BMAPIGETREADMAIL BMAPIGetReadMail;


typedef ULONG (FAR PASCAL BMAPISAVEMAIL)(
    LHANDLE 			hSession,
    ULONG 			    ulUIParam,
    LPVB_MESSAGE 	    lpM,
    LPSAFEARRAY * 	    lppsaRecips,
    LPSAFEARRAY *	    lppsaFiles,
    ULONG 			    flFlags,
    ULONG 			    ulReserved,
    BSTR * 			    lpbstrID
);
typedef BMAPISAVEMAIL FAR *LPBMAPISAVEMAIL;
BMAPISAVEMAIL BMAPISaveMail;


typedef ULONG (FAR PASCAL BMAPIADDRESS)(
    LPULONG 			lpulRecip,
    LHANDLE 			hSession,
    ULONG 			    ulUIParam,
    BSTR * 			    lpbstrCaption,
    ULONG 			    ulEditFields,
    BSTR * 			    lpbstrLabel,
    LPULONG 			lpulRecipients,
    LPSAFEARRAY * 	    lppsaRecip,		// LPVB_RECIPIENT
    ULONG 			    ulFlags,
    ULONG 			    ulReserved
);
typedef BMAPIADDRESS FAR *LPBMAPIADDRESS;
BMAPIADDRESS BMAPIAddress;


typedef ULONG (FAR PASCAL BMAPIGETADDRESS)(
    ULONG			ulRecipientData,
    ULONG 			count,
    LPSAFEARRAY *	lppsaRecips
);
typedef BMAPIGETADDRESS FAR *LPBMAPIGETADDRESS;
BMAPIGETADDRESS BMAPIGetAddress;


typedef ULONG (FAR PASCAL BMAPIDETAILS)(
    LHANDLE 			hSession,
    ULONG 			ulUIParam,
    LPVB_RECIPIENT	lpVB,
    ULONG 			ulFlags,
    ULONG 			ulReserved
);
typedef BMAPIDETAILS FAR *LPBMAPIDETAILS;
BMAPIDETAILS BMAPIDetails;


typedef ULONG (FAR PASCAL BMAPIRESOLVENAME)(
    LHANDLE			hSession,
    ULONG 			ulUIParam,
    BSTR  			bstrMapiName,
    ULONG 			ulFlags,
    ULONG 			ulReserved,
    LPVB_RECIPIENT 	lpVB
);
typedef BMAPIRESOLVENAME FAR *LPBMAPIRESOLVENAME;
BMAPIRESOLVENAME BMAPIResolveName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\athena16.h ===
/*****************************************************************************\
*                                                                             *
* Athena16.h                                                                  *
*                                                                             *
\*****************************************************************************/

#ifndef ATHENA16_H
#define ATHENA16_H

#define SECURITY_WIN16

/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#ifdef __WATCOMC__
#pragma warning 442 9
#pragma warning 604 9
#pragma warning 583 9
#pragma warning 594 9

#pragma warning 379 9	// 'delete' expression will invoke a non-virtual destructor
#pragma warning 387 9   // expression is useful only for its side effects
#pragma warning 354	4	// unsigned or pointer expression is always >= 0
#pragma warning 389 4	// integral value may be truncated during assignment
#pragma warning 4	4	// base class XXX does not have a virtual destructor
#pragma warning 13	4	// unreachable code
#pragma warning 628 4	// expression is not meaningful
#pragma warning 627 9   // text following pre-processor directive (comment after endif)

#pragma warning 188	5	// base class is inherited with private access. basically means base
						// class access hasn't been specified on the class definiton.

#pragma off(unreferenced)

#endif 

#include "x16menu.h"

#ifndef WIN16_INETCOMM
#define _IMNXPORT_
#define _IMNACCT_
#define _MIMEOLE_
#endif // WIN16_INETCOM

#ifdef __cplusplus
extern "C"{
#endif

/*****************************************************************************\
*                                                                             *
*  From rpc.h(INC16) - It should be in "ocidl.h" of the INC16.
*                                                                             *
\*****************************************************************************/

#ifdef __WATCOMC__
#define __RPC_FAR  __far
#define __RPC_API  __far __pascal
#define __RPC_USER __pascal 
#define __RPC_STUB __far __pascal 
#define RPC_ENTRY  __pascal __far

typedef void __near * I_RPC_HANDLE;
#else

#define __RPC_FAR  __far
#define __RPC_API  __far __pascal
#define __RPC_USER __far __pascal __export
#define __RPC_STUB __far __pascal __export
#define RPC_ENTRY  __pascal __export __far

typedef void _near * I_RPC_HANDLE;
#endif


/*****************************************************************************\
*                                                                             *
*  From Winver.h(INC32)
*                                                                             *
\*****************************************************************************/

#if 0
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */

#define GetFileVersionInfoSize  GetFileVersionInfoSizeA

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */

#define GetFileVersionInfo  GetFileVersionInfoA

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );

#define VerQueryValue  VerQueryValueA
#endif


/*****************************************************************************\
*                                                                             *
*  From winbase.h (INC32)
*                                                                             *
\*****************************************************************************/
typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

LPVOID
WINAPI
VirtualAlloc(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD flAllocationType,
    DWORD flProtect
    );

BOOL
WINAPI
VirtualFree(
    LPVOID lpAddress,
    DWORD dwSize,
    DWORD dwFreeType
    );

VOID
WINAPI
GetSystemInfo(
    LPSYSTEM_INFO lpSystemInfo
    );

#if 0    // Now WIN16 has this
typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[ MAX_PATH ];
    CHAR   cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
#endif //0

#define FILE_FLAG_DELETE_ON_CLOSE       0x04000000

typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

//
// dwCreationFlag values
//
#define CREATE_DEFAULT_ERROR_MODE   0x04000000

// File attributes.
BOOL
WINAPI
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );
BOOL
WINAPI
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );
#ifdef UNICODE
#define SetFileAttributes  SetFileAttributesW
#else
#define SetFileAttributes  SetFileAttributesA
#endif // !UNICODE

///////////////////////////////////////////////////////////////
//                                                           //
//      Win Certificate API and Structures                   //
//                                                           //
///////////////////////////////////////////////////////////////

//
// Structures
//

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1
#endif

#if 0 // Now BASETYPS has this
typedef struct _WIN_CERTIFICATE {
    DWORD       dwLength;
    WORD        wRevision;
    WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
    BYTE        bCertificate[ANYSIZE_ARRAY];
} WIN_CERTIFICATE, *LPWIN_CERTIFICATE;
#endif




/* Heap related APIs.
 *
 * HeapCreate and HeapDestroy does nothing.
 * HeapAlloc and HeapFree use GlobalAlloc, GlobalLock and GlobalFree.
 *
 */
#define HeapCreate(a,b,c) ((HANDLE)1)
#define HeapDestroy(a) ((BOOL)1)

#define HeapAlloc OE16HeapAlloc
#define HeapFree OE16HeapFree

LPVOID
WINAPI
OE16HeapAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    DWORD dwBytes
    );

LPVOID
WINAPI
HeapReAlloc(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem,
    DWORD dwBytes
    );

BOOL
WINAPI
OE16HeapFree(
    HANDLE hHeap,
    DWORD dwFlags,
    LPVOID lpMem
    );


DWORD
WINAPI
HeapSize(
    HANDLE hHeap,
    DWORD dwFlags,
    LPCVOID lpMem
    );

DWORD
WINAPI
GetShortPathNameA(
    LPCSTR lpszLongPath,
    LPSTR  lpszShortPath,
    DWORD    cchBuffer
    );

#define GetShortPathName  GetShortPathNameA

VOID
WINAPI
SetLastError(
    DWORD dwErrCode
    );

#ifdef RUN16_WIN16X
LONG
WINAPI
CompareFileTime(
    CONST FILETIME *lpFileTime1,
    CONST FILETIME *lpFileTime2
    );
#endif //RUN16_WIN16X

#define lstrcpyA lstrcpy
#define lstrcpyW lstrcpy
#define lstrlenW lstrlen

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;

typedef STARTUPINFOA STARTUPINFO;

UINT
WINAPI
GetDriveTypeA(
    LPCSTR lpRootPathName
    );

#define GetDriveType  GetDriveTypeA

BOOL
WINAPI
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#define CreateDirectory  CreateDirectoryA

DWORD
WINAPI
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );

#define GetEnvironmentVariable  GetEnvironmentVariableA

/* DUP???
BOOL
WINAPI
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

#define CreateDirectory  CreateDirectoryA
*/

BOOL
WINAPI
GetComputerNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );

#define GetComputerName  GetComputerNameA

BOOL
WINAPI
GetUserNameA (
    LPSTR lpBuffer,
    LPDWORD nSize
    );

#define GetUserName  GetUserNameA

typedef OSVERSIONINFOA OSVERSIONINFO;

HANDLE
WINAPI
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );

#define CreateFileMapping  CreateFileMappingA

// flProtect -- defined in sdk\inc\winnt.h
#define PAGE_READONLY          0x02     
#define PAGE_READWRITE         0x04     

LPVOID
WINAPI
MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    );

// dwDesiredAccess -- defined in sdk\inc\winnt.h
#define SECTION_MAP_WRITE   0x0002
#define SECTION_MAP_READ    0x0004
#define FILE_MAP_WRITE      SECTION_MAP_WRITE
#define FILE_MAP_READ       SECTION_MAP_READ

BOOL
WINAPI
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );


/*****************************************************************************\
*                                                                             *
*  OE16 File mapping object related function prototype
*                                                                             *
\*****************************************************************************/

LPVOID
WINAPI
OE16CreateFileMapping(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );

LPVOID
WINAPI
OE16MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap
    );

BOOL
WINAPI
OE16UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );

BOOL
WINAPI
OE16CloseFileMapping(
    LPVOID lpObject
    );

/*****************************************************************************\
*                                                                             *
*  ???
*                                                                             *
\*****************************************************************************/
BOOL
WINAPI
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );
#define GetDiskFreeSpace  GetDiskFreeSpaceA

#define TIME_ZONE_ID_UNKNOWN  0
#define TIME_ZONE_ID_STANDARD 1
#define TIME_ZONE_ID_DAYLIGHT 2

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, FAR* LPTIME_ZONE_INFORMATION;

DWORD
WINAPI
GetTimeZoneInformation(
    LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );

BOOL
WINAPI
IsTextUnicode(
    CONST LPVOID lpBuffer,
    int cb,
    LPINT lpi
    );

VOID
WINAPI
GetSystemTimeAsFileTime(
    LPFILETIME lpSystemTimeAsFileTime
    );

DWORD
WINAPI
ExpandEnvironmentStrings(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    );

/*****************************************************************************\
*                                                                             *
*  OE16 Thread related function prototype and re-define
*                                                                             *
\*****************************************************************************/

// We don't support following APIs in Win16
#undef CreateSemaphore
#undef CreateSemaphoreA
#undef ReleaseSemaphore
#undef CreateMutex
#undef CreateMutexA
#undef WaitForMultipleObjects

#define CreateSemaphore(a,b,c,d) ((HANDLE)1)
#define CreateSemaphoreA(a,b,c,d) ((HANDLE)1)
#define ReleaseSemaphore(a,b,c) ((BOOL)1)
#define CreateMutex(a,b,c) ((HANDLE)1)
#define CreateMutexA(a,b,c) ((HANDLE)1)
#define WaitForMultipleObjects(a,b,c,d) ((DWORD)WAIT_OBJECT_0)

// Because of the following line in sdk\inc\objidl.h,
// we can't use "#define ReleaseMutex(a), ((BOOL)1)".
//
// virtual HRESULT STDMETHODCALLTYPE ReleaseMutex( void) = 0;
//
#undef ReleaseMutex
#define ReleaseMutex OE16ReleaseMutex

BOOL
WINAPI
OE16ReleaseMutex(
    HANDLE hMutex
    );

// We don't need following APIs in Win16
#undef InitializeCriticalSection
#undef EnterCriticalSection
#undef LeaveCriticalSection
#undef DeleteCriticalSection

#define InitializeCriticalSection(a)
#define EnterCriticalSection(a)
#define LeaveCriticalSection(a)
#define DeleteCriticalSection(a)

// We support following Event APIs in Win16.
//CreateEvent, SetEvent, ResetEvent, PulseEvent

// We suppot WFSO for event and Thread. Since OE32 has a call
// for Mutex and Semaphore, we will have private WFSO in OE16.

#undef  WaitForSingleObject
#define WaitForSingleObject(a,b) ((DWORD)WAIT_OBJECT_0)

// We have a define in common.h
//#define WaitForSingleObject_16 w16WaitForSingleObject

// WIN16FF - Should we ignore process APIs as well??? - WJPark
BOOL
WINAPI
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

#define CreateProcess  CreateProcessA


#if 0
/*****************************************************************************\
*                                                                             *
*  From sspi.h(INC32)
*                                                                             *
\*****************************************************************************/

typedef HRESULT SECURITY_STATUS;

//
// Okay, security specific types:
//

typedef struct _SecHandle
{
    unsigned long dwLower;
    unsigned long dwUpper;
} SecHandle, __far * PSecHandle;

typedef SecHandle CredHandle;
typedef PSecHandle PCredHandle;

typedef SecHandle CtxtHandle;
typedef PSecHandle PCtxtHandle;

//
//  InitializeSecurityContext Requirement and return flags:
//

#define ISC_REQ_DELEGATE                0x00000001
#define ISC_REQ_MUTUAL_AUTH             0x00000002
#define ISC_REQ_REPLAY_DETECT           0x00000004
#define ISC_REQ_SEQUENCE_DETECT         0x00000008
#define ISC_REQ_CONFIDENTIALITY         0x00000010
#define ISC_REQ_USE_SESSION_KEY         0x00000020
#define ISC_REQ_PROMPT_FOR_CREDS        0x00000040
#define ISC_REQ_USE_SUPPLIED_CREDS      0x00000080
#define ISC_REQ_ALLOCATE_MEMORY         0x00000100
#define ISC_REQ_USE_DCE_STYLE           0x00000200
#define ISC_REQ_DATAGRAM                0x00000400
#define ISC_REQ_CONNECTION              0x00000800
#define ISC_REQ_CALL_LEVEL              0x00001000
#define ISC_REQ_EXTENDED_ERROR          0x00004000
#define ISC_REQ_STREAM                  0x00008000
#define ISC_REQ_INTEGRITY               0x00010000
#define ISC_REQ_IDENTIFY                0x00020000

#define ISC_RET_DELEGATE                0x00000001
#define ISC_RET_MUTUAL_AUTH             0x00000002
#define ISC_RET_REPLAY_DETECT           0x00000004
#define ISC_RET_SEQUENCE_DETECT         0x00000008
#define ISC_RET_CONFIDENTIALITY         0x00000010
#define ISC_RET_USE_SESSION_KEY         0x00000020
#define ISC_RET_USED_COLLECTED_CREDS    0x00000040
#define ISC_RET_USED_SUPPLIED_CREDS     0x00000080
#define ISC_RET_ALLOCATED_MEMORY        0x00000100
#define ISC_RET_USED_DCE_STYLE          0x00000200
#define ISC_RET_DATAGRAM                0x00000400
#define ISC_RET_CONNECTION              0x00000800
#define ISC_RET_INTERMEDIATE_RETURN     0x00001000
#define ISC_RET_CALL_LEVEL              0x00002000
#define ISC_RET_EXTENDED_ERROR          0x00004000
#define ISC_RET_STREAM                  0x00008000
#define ISC_RET_INTEGRITY               0x00010000
#define ISC_RET_IDENTIFY                0x00020000

#define ASC_REQ_DELEGATE                0x00000001
#define ASC_REQ_MUTUAL_AUTH             0x00000002
#define ASC_REQ_REPLAY_DETECT           0x00000004
#define ASC_REQ_SEQUENCE_DETECT         0x00000008
#define ASC_REQ_CONFIDENTIALITY         0x00000010
#define ASC_REQ_USE_SESSION_KEY         0x00000020
#define ASC_REQ_ALLOCATE_MEMORY         0x00000100
#define ASC_REQ_USE_DCE_STYLE           0x00000200
#define ASC_REQ_DATAGRAM                0x00000400
#define ASC_REQ_CONNECTION              0x00000800
#define ASC_REQ_CALL_LEVEL              0x00001000
#define ASC_REQ_EXTENDED_ERROR          0x00008000
#define ASC_REQ_STREAM                  0x00010000
#define ASC_REQ_INTEGRITY               0x00020000
#define ASC_REQ_LICENSING               0x00040000


#define ASC_RET_DELEGATE                0x00000001
#define ASC_RET_MUTUAL_AUTH             0x00000002
#define ASC_RET_REPLAY_DETECT           0x00000004
#define ASC_RET_SEQUENCE_DETECT         0x00000008
#define ASC_RET_CONFIDENTIALITY         0x00000010
#define ASC_RET_USE_SESSION_KEY         0x00000020
#define ASC_RET_ALLOCATED_MEMORY        0x00000100
#define ASC_RET_USED_DCE_STYLE          0x00000200
#define ASC_RET_DATAGRAM                0x00000400
#define ASC_RET_CONNECTION              0x00000800
#define ASC_RET_CALL_LEVEL              0x00002000 // skipped 1000 to be like ISC_
#define ASC_RET_THIRD_LEG_FAILED        0x00004000
#define ASC_RET_EXTENDED_ERROR          0x00008000
#define ASC_RET_STREAM                  0x00010000
#define ASC_RET_INTEGRITY               0x00020000
#define ASC_RET_LICENSING               0x00040000

#endif

/*****************************************************************************\
*                                                                             *
*  From shlobj.h(INC32)
*                                                                             *
\*****************************************************************************/

#ifdef _SHLOBJ_H_

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */

//===========================================================================
//
// IShellLink Interface
//
//===========================================================================

#if 0    // Now SHLOBJ has this
#define IShellLink      IShellLinkA

// IShellLink::Resolve fFlags
typedef enum {
    SLR_NO_UI           = 0x0001,
    SLR_ANY_MATCH       = 0x0002,
    SLR_UPDATE          = 0x0004,
} SLR_FLAGS;

// IShellLink::GetPath fFlags
typedef enum {
    SLGP_SHORTPATH      = 0x0001,
    SLGP_UNCPRIORITY    = 0x0002,
    SLGP_RAWPATH        = 0x0004,
} SLGP_FLAGS;

#undef  INTERFACE
#define INTERFACE   IShellLinkA

DECLARE_INTERFACE_(IShellLinkA, IUnknown)       // sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(GetPath)(THIS_ LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATAA *pfd, DWORD fFlags) PURE;

    STDMETHOD(GetIDList)(THIS_ LPITEMIDLIST * ppidl) PURE;
    STDMETHOD(SetIDList)(THIS_ LPCITEMIDLIST pidl) PURE;

    STDMETHOD(GetDescription)(THIS_ LPSTR pszName, int cchMaxName) PURE;
    STDMETHOD(SetDescription)(THIS_ LPCSTR pszName) PURE;

    STDMETHOD(GetWorkingDirectory)(THIS_ LPSTR pszDir, int cchMaxPath) PURE;
    STDMETHOD(SetWorkingDirectory)(THIS_ LPCSTR pszDir) PURE;

    STDMETHOD(GetArguments)(THIS_ LPSTR pszArgs, int cchMaxPath) PURE;
    STDMETHOD(SetArguments)(THIS_ LPCSTR pszArgs) PURE;

    STDMETHOD(GetHotkey)(THIS_ WORD *pwHotkey) PURE;
    STDMETHOD(SetHotkey)(THIS_ WORD wHotkey) PURE;

    STDMETHOD(GetShowCmd)(THIS_ int *piShowCmd) PURE;
    STDMETHOD(SetShowCmd)(THIS_ int iShowCmd) PURE;

    STDMETHOD(GetIconLocation)(THIS_ LPSTR pszIconPath, int cchIconPath, int *piIcon) PURE;
    STDMETHOD(SetIconLocation)(THIS_ LPCSTR pszIconPath, int iIcon) PURE;

    STDMETHOD(SetRelativePath)(THIS_ LPCSTR pszPathRel, DWORD dwReserved) PURE;

    STDMETHOD(Resolve)(THIS_ HWND hwnd, DWORD fFlags) PURE;

    STDMETHOD(SetPath)(THIS_ LPCSTR pszFile) PURE;
};
#endif //0

//-------------------------------------------------------------------------
//
// SHGetPathFromIDList
//
//  This function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.
//
//-------------------------------------------------------------------------

BOOL WINAPI SHGetPathFromIDListA(LPCITEMIDLIST pidl, LPSTR pszPath);

#define SHGetPathFromIDList SHGetPathFromIDListA

//-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
//-------------------------------------------------------------------------

#if 0    // Now SHLOBJ has this
typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

typedef struct _browseinfoA {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPSTR        pszDisplayName;// Return display name of item selected.
    LPCSTR       lpszTitle;      // text to go in the banner over the tree.
    UINT         ulFlags;       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM      lParam;         // extra info that's passed back in callbacks

    int          iImage;      // output var: where to return the Image index.
} BROWSEINFOA, *PBROWSEINFOA, *LPBROWSEINFOA;

#define BROWSEINFO      BROWSEINFOA

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004
#define BIF_RETURNFSANCESTORS  0x0008
#define BIF_EDITBOX            0x0010

// message from browser
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2

// messages to browser
#define BFFM_ENABLEOK           (WM_USER + 101)
#define BFFM_SETSELECTIONA      (WM_USER + 102)

LPITEMIDLIST WINAPI SHBrowseForFolderA(LPBROWSEINFOA lpbi);

#define SHBrowseForFolder   SHBrowseForFolderA
#define BFFM_SETSELECTION   BFFM_SETSELECTIONA
#endif //0

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
#if 0    // Now SHLOBJ has this
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
                                       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, FAR * LPDROPFILES;
#endif //0

#undef  INTERFACE
#define INTERFACE   IShellToolbarSite

DECLARE_INTERFACE_(IShellToolbarSite, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellToolbarSite methods ***
    STDMETHOD(GetBorderST) (THIS_ IUnknown* punkSrc, LPRECT prcBorder) PURE;
    STDMETHOD(RequestBorderSpaceST) (THIS_ IUnknown* punkSrc, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(SetBorderSpaceST) (THIS_ IUnknown* punkSrc, LPCBORDERWIDTHS pbw) PURE;
    STDMETHOD(OnFocusChangeST) (THIS_ IUnknown* punkSrc, BOOL fSetFocus) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellToolbarFrame

#define STFRF_NORMAL            0x0000
#define STFRF_DELETECONFIGDATA  0x0001

DECLARE_INTERFACE_(IShellToolbarFrame, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellToolbarFrame methods ***
    STDMETHOD(AddToolbar) (THIS_ IUnknown* punkSrc, LPCWSTR pwszItem, DWORD dwReserved) PURE;
    STDMETHOD(RemoveToolbar) (THIS_ IUnknown* punkSrc, DWORD dwRemoveFlags) PURE;
    STDMETHOD(FindToolbar) (THIS_ LPCWSTR pwszItem, REFIID riid, LPVOID* ppvObj) PURE;
};

#undef  INTERFACE
#define INTERFACE   IShellToolbar

DECLARE_INTERFACE_(IShellToolbar, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellToolbar methods ***
    STDMETHOD(SetToolbarSite) (THIS_ IUnknown* punkSite) PURE;
    STDMETHOD(ShowST)         (THIS_ BOOL fShow) PURE;
    STDMETHOD(CloseST)        (THIS_ DWORD dwReserved) PURE;
    STDMETHOD(ResizeBorderST) (THIS_ LPCRECT   prcBorder,
                                     IUnknown* punkToolbarSite,
                                     BOOL      fReserved) PURE;
    STDMETHOD(TranslateAcceleratorST) (THIS_ LPMSG lpmsg) PURE;
    STDMETHOD(HasFocus)       (THIS) PURE;
};

#if 0    // Now SHLOBJ has this
// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
#define GIL_FORSHELL     0x0002      // icon is to be displayed in a ShellFolder
#define GIL_ASYNC        0x0020      // this is an async extract, return E_ASYNC

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME  0x0008      // location is not a filename, must call ::ExtractIcon
#define GIL_DONTCACHE    0x0010      // this icon should not be cached

#undef  INTERFACE
#define INTERFACE   IExtractIconA

DECLARE_INTERFACE_(IExtractIconA, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconA * LPEXTRACTICONA;

#undef  INTERFACE
#define INTERFACE   IExtractIconW

DECLARE_INTERFACE_(IExtractIconW, IUnknown)     // exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPWSTR szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCWSTR pszFile,
                           UINT   nIconIndex,
                           HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIconW * LPEXTRACTICONW;

#ifdef UNICODE
#define IExtractIcon        IExtractIconW
#define IExtractIconVtbl    IExtractIconWVtbl
#define LPEXTRACTICON       LPEXTRACTICONW
#else
#define IExtractIcon        IExtractIconA
#define IExtractIconVtbl    IExtractIconAVtbl
#define LPEXTRACTICON       LPEXTRACTICONA
#endif
#endif //0

#if 0    // Now SHLOBJ has this
//==========================================================================
//
// IShellBrowser/IShellView/IShellFolder interface
//
//  These three interfaces are used when the shell communicates with
// name space extensions. The shell (explorer) provides IShellBrowser
// interface, and extensions implements IShellFolder and IShellView
// interfaces.
//
//==========================================================================


//--------------------------------------------------------------------------
//
// Command/menuitem IDs
//
//  The explorer dispatches WM_COMMAND messages based on the range of
// command/menuitem IDs. All the IDs of menuitems that the view (right
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer
// won't dispatch them). The view should not deal with any menuitems
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future
// version of the shell).
//
//  FCIDM_SHVIEWFIRST/LAST      for the right pane (IShellView)
//  FCIDM_BROWSERFIRST/LAST     for the explorer frame (IShellBrowser)
//  FCIDM_GLOBAL/LAST           for the explorer's submenu IDs
//
//--------------------------------------------------------------------------

#define FCIDM_SHVIEWFIRST           0x0000
#define FCIDM_SHVIEWLAST            0x7fff
#define FCIDM_BROWSERFIRST          0xa000
#define FCIDM_BROWSERLAST           0xbf00
#define FCIDM_GLOBALFIRST           0x8000
#define FCIDM_GLOBALLAST            0x9fff

//
// Global submenu IDs and separator IDs
//
#define FCIDM_MENU_FILE             (FCIDM_GLOBALFIRST+0x0000)
#define FCIDM_MENU_EDIT             (FCIDM_GLOBALFIRST+0x0040)
#define FCIDM_MENU_VIEW             (FCIDM_GLOBALFIRST+0x0080)
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)
#define FCIDM_MENU_TOOLS            (FCIDM_GLOBALFIRST+0x00c0)
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1)
#define FCIDM_MENU_HELP             (FCIDM_GLOBALFIRST+0x0100)
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)
#define FCIDM_MENU_EXPLORE          (FCIDM_GLOBALFIRST+0x0150)
#define FCIDM_MENU_FAVORITES        (FCIDM_GLOBALFIRST+0x0170)

//--------------------------------------------------------------------------
// control IDs known to the view
//--------------------------------------------------------------------------

#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)


//--------------------------------------------------------------------------
//
// FOLDERSETTINGS
//
//  FOLDERSETTINGS is a data structure that explorer passes from one folder
// view to another, when the user is browsing. It calls ISV::GetCurrentInfo
// member to get the current settings and pass it to ISV::CreateViewWindow
// to allow the next folder view "inherit" it. These settings assumes a
// particular UI (which the shell's folder view has), and shell extensions
// may or may not use those settings.
//
//--------------------------------------------------------------------------

typedef LPBYTE LPVIEWSETTINGS;

// NB Bitfields.
// FWF_DESKTOP implies FWF_TRANSPARENT/NOCLIENTEDGE/NOSCROLL
typedef enum
    {
    FWF_AUTOARRANGE =       0x0001,
    FWF_ABBREVIATEDNAMES =  0x0002,
    FWF_SNAPTOGRID =        0x0004,
    FWF_OWNERDATA =         0x0008,
    FWF_BESTFITWINDOW =     0x0010,
    FWF_DESKTOP =           0x0020,
    FWF_SINGLESEL =         0x0040,
    FWF_NOSUBFOLDERS =      0x0080,
    FWF_TRANSPARENT  =      0x0100,
    FWF_NOCLIENTEDGE =      0x0200,
    FWF_NOSCROLL     =      0x0400,
    FWF_ALIGNLEFT    =      0x0800,
    FWF_NOICONS      =      0x1000,
    FWF_SINGLECLICKACTIVATE=0x8000  // TEMPORARY -- NO UI FOR THIS
    } FOLDERFLAGS;

typedef enum
    {
    FVM_ICON =              1,
    FVM_SMALLICON =         2,
    FVM_LIST =              3,
    FVM_DETAILS =           4,
    } FOLDERVIEWMODE;

typedef struct
    {
    UINT ViewMode;       // View mode (FOLDERVIEWMODE values)
    UINT fFlags;         // View options (FOLDERFLAGS bits)
    } FOLDERSETTINGS, *LPFOLDERSETTINGS;

typedef const FOLDERSETTINGS * LPCFOLDERSETTINGS;


//--------------------------------------------------------------------------
//
// Interface:   IShellBrowser
//
//  IShellBrowser interface is the interface that is provided by the shell
// explorer/folder frame window. When it creates the "contents pane" of
// a shell folder (which provides IShellFolder interface), it calls its
// CreateViewObject member function to create an IShellView object. Then,
// it calls its CreateViewWindow member to create the "contents pane"
// window. The pointer to the IShellBrowser interface is passed to
// the IShellView object as a parameter to this CreateViewWindow member
// function call.
//
//    +--------------------------+  <-- Explorer window
//    | [] Explorer              |
//    |--------------------------+       IShellBrowser
//    | File Edit View ..        |
//    |--------------------------|
//    |        |                 |
//    |        |              <-------- Content pane
//    |        |                 |
//    |        |                 |       IShellView
//    |        |                 |
//    |        |                 |
//    +--------------------------+
//
//
//
// [Member functions]
//
//
// IShellBrowser::GetWindow(phwnd)
//
//   Inherited from IOleWindow::GetWindow.
//
//
// IShellBrowser::ContextSensitiveHelp(fEnterMode)
//
//   Inherited from IOleWindow::ContextSensitiveHelp.
//
//
// IShellBrowser::InsertMenusSB(hmenuShared, lpMenuWidths)
//
//   Similar to the IOleInPlaceFrame::InsertMenus. The explorer will put
//  "File" and "Edit" pulldown in the File menu group, "View" and "Tools"
//  in the Container menu group and "Help" in the Window menu group. Each
//  pulldown menu will have a uniqu ID, FCIDM_MENU_FILE/EDIT/VIEW/TOOLS/HELP.
//  The view is allowed to insert menuitems into those sub-menus by those
//  IDs must be between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST.
//
//
// IShellBrowser::SetMenuSB(hmenuShared, holemenu, hwndActiveObject)
//
//   Similar to the IOleInPlaceFrame::SetMenu. The explorer ignores the
//  holemenu parameter (reserved for future enhancement)  and performs
//  menu-dispatch based on the menuitem IDs (see the description above).
//  It is important to note that the explorer will add different
//  set of menuitems depending on whether the view has a focus or not.
//  Therefore, it is very important to call ISB::OnViewWindowActivate
//  whenever the view window (or its children) gets the focus.
//
//
// IShellBrowser::RemoveMenusSB(hmenuShared)
//
//   Same as the IOleInPlaceFrame::RemoveMenus.
//
//
// IShellBrowser::SetStatusTextSB(lpszStatusText)
//
//   Same as the IOleInPlaceFrame::SetStatusText. It is also possible to
//  send messages directly to the status window via SendControlMsg.
//
//
// IShellBrowser::EnableModelessSB(fEnable)
//
//   Same as the IOleInPlaceFrame::EnableModeless.
//
//
// IShellBrowser::TranslateAcceleratorSB(lpmsg, wID)
//
//   Same as the IOleInPlaceFrame::TranslateAccelerator, but will be
//  never called because we don't support EXEs (i.e., the explorer has
//  the message loop). This member function is defined here for possible
//  future enhancement.
//
//
// IShellBrowser::BrowseObject(pidl, wFlags)
//
//   The view calls this member to let shell explorer browse to another
//  folder. The pidl and wFlags specifies the folder to be browsed.
//
//  Following three flags specifies whether it creates another window or not.
//   SBSP_SAMEBROWSER  -- Browse to another folder with the same window.
//   SBSP_NEWBROWSER   -- Creates another window for the specified folder.
//   SBSP_DEFBROWSER   -- Default behavior (respects the view option).
//
//  Following three flags specifies open, explore, or default mode. These   .
//  are ignored if SBSP_SAMEBROWSER or (SBSP_DEFBROWSER && (single window   .
//  browser || explorer)).                                                  .
//   SBSP_OPENMODE     -- Use a normal folder window
//   SBSP_EXPLOREMODE  -- Use an explorer window
//   SBSP_DEFMODE      -- Use the same as the current window
//
//  Following three flags specifies the pidl.
//   SBSP_ABSOLUTE -- pidl is an absolute pidl (relative from desktop)
//   SBSP_RELATIVE -- pidl is relative from the current folder.
//   SBSP_PARENT   -- Browse the parent folder (ignores the pidl)
//   SBSP_NAVIGATEBACK    -- Navigate back (ignores the pidl)
//   SBSP_NAVIGATEFORWARD -- Navigate forward (ignores the pidl)
//
//
// IShellBrowser::GetViewStateStream(grfMode, ppstm)
//
//   The browser returns an IStream interface as the storage for view
//  specific state information.
//
//   grfMode -- Specifies the read/write access (STGM_READ/WRITE/READWRITE)
//   ppstm   -- Specifies the LPSTREAM variable to be filled.
//
//
// IShellBrowser::GetControlWindow(id, phwnd)
//
//   The shell view may call this member function to get the window handle
//  of Explorer controls (toolbar or status winodw -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::SendControlMsg(id, uMsg, wParam, lParam, pret)
//
//   The shell view calls this member function to send control messages to
//  one of Explorer controls (toolbar or status window -- FCW_TOOLBAR or
//  FCW_STATUS).
//
//
// IShellBrowser::QueryActiveShellView(IShellView * ppshv)
//
//   This member returns currently activated (displayed) shellview object.
//  A shellview never need to call this member function.
//
//
// IShellBrowser::OnViewWindowActive(pshv)
//
//   The shell view window calls this member function when the view window
//  (or one of its children) got the focus. It MUST call this member before
//  calling IShellBrowser::InsertMenus, because it will insert different
//  set of menu items depending on whether the view has the focus or not.
//
//
// IShellBrowser::SetToolbarItems(lpButtons, nButtons, uFlags)
//
//   The view calls this function to add toolbar items to the exporer's
//  toolbar. "lpButtons" and "nButtons" specifies the array of toolbar
//  items. "uFlags" must be one of FCT_MERGE, FCT_CONFIGABLE, FCT_ADDTOEND.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   IShellBrowser

//
// Values for wFlags parameter of ISB::BrowseObject() member.
//
#define SBSP_DEFBROWSER         0x0000
#define SBSP_SAMEBROWSER        0x0001
#define SBSP_NEWBROWSER         0x0002

#define SBSP_DEFMODE            0x0000
#define SBSP_OPENMODE           0x0010
#define SBSP_EXPLOREMODE        0x0020

#define SBSP_ABSOLUTE           0x0000
#define SBSP_RELATIVE           0x1000
#define SBSP_PARENT             0x2000
#define SBSP_NAVIGATEBACK       0x4000
#define SBSP_NAVIGATEFORWARD    0x8000

#define SBSP_ALLOW_AUTONAVIGATE 0x10000

#define SBSP_INITIATEDBYHLINKFRAME        0x80000000
#define SBSP_REDIRECT                     0x40000000

//
// Values for id parameter of ISB::GetWindow/SendControlMsg members.
//
// WARNING:
//  Any shell extensions which sends messages to those control windows
// might not work in the future version of windows. If you really need
// to send messages to them, (1) don't assume that those control window
// always exist (i.e. GetControlWindow may fail) and (2) verify the window
// class of the window before sending any messages.
//
#define FCW_STATUS      0x0001
#define FCW_TOOLBAR     0x0002
#define FCW_TREE        0x0003
#define FCW_INTERNETBAR 0x0006

//
// Values for uFlags paremeter of ISB::SetToolbarItems member.
//
#define FCT_MERGE       0x0001
#define FCT_CONFIGABLE  0x0002
#define FCT_ADDTOEND    0x0004


DECLARE_INTERFACE_(IShellBrowser, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared,
                                LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenuReserved,
                HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText) PURE;
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID) PURE;

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags) PURE;
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode,
                LPSTREAM  *ppStrm) PURE;
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND * lphwnd) PURE;
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam,
                LPARAM lParam, LRESULT * pret) PURE;
    STDMETHOD(QueryActiveShellView)(THIS_ struct IShellView ** ppshv) PURE;
    STDMETHOD(OnViewWindowActive)(THIS_ struct IShellView * ppshv) PURE;
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON lpButtons, UINT nButtons,
                UINT uFlags) PURE;
};
#define __IShellBrowser_INTERFACE_DEFINED__

typedef IShellBrowser * LPSHELLBROWSER;

enum {
    SBSC_HIDE = 0,
    SBSC_SHOW = 1,
    SBSC_TOGGLE = 2,
    SBSC_QUERY =  3
};

enum {
        SBO_DEFAULT = 0 ,
        SBO_NOBROWSERPAGES = 1
};
#endif //0

#if 0 // Now SHLOBJP has this
// CGID_Explorer Command Target IDs
enum {
    SBCMDID_ENABLESHOWTREE          = 0,
    SBCMDID_SHOWCONTROL             = 1,        // variant vt_i4 = loword = FCW_ * hiword = SBSC_*
    SBCMDID_CANCELNAVIGATION        = 2,        // cancel last navigation
    SBCMDID_MAYSAVECHANGES          = 3,        // about to close and may save changes
    SBCMDID_SETHLINKFRAME           = 4,        // variant vt_i4 = phlinkframe
    SBCMDID_ENABLESTOP              = 5,        // variant vt_bool = fEnable
    SBCMDID_OPTIONS                 = 6,        // the view.options page
    SBCMDID_EXPLORER                = 7,        // are you explorer.exe?
    SBCMDID_ADDTOFAVORITES          = 8,
    SBCMDID_ACTIVEOBJECTMENUS       = 9,
    SBCMDID_MAYSAVEVIEWSTATE        = 10,       // Should we save view stream
    SBCMDID_DOFAVORITESMENU         = 11,       // popup the favorites menu
    SBCMDID_DOMAILMENU              = 12,       // popup the mail menu
    SBCMDID_GETADDRESSBARTEXT       = 13,       // get user-typed text
    SBCMDID_ASYNCNAVIGATION         = 14,       // do an async navigation
    SBCMDID_SEARCHBAR               = 15,       // toggle SearchBar browserbar
    SBCMDID_FLUSHOBJECTCACHE        = 16,       // flush object cache
    SBCMDID_CREATESHORTCUT          = 17,       // create a shortcut
};
#endif


#if 0    // Now SHLOBJ has this

//
// uState values for IShellView::UIActivate
//
typedef enum {
    SVUIA_DEACTIVATE       = 0,
    SVUIA_ACTIVATE_NOFOCUS = 1,
    SVUIA_ACTIVATE_FOCUS   = 2,
    SVUIA_INPLACEACTIVATE  = 3          // new flag for IShellView2
} SVUIA_STATUS;

DECLARE_INTERFACE_(IShellView, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IShellView methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;
#ifdef _FIX_ENABLEMODELESS_CONFLICT
    STDMETHOD(EnableModelessSV) (THIS_ BOOL fEnable) PURE;
#else
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
#endif
    STDMETHOD(UIActivate) (THIS_ UINT uState) PURE;
    STDMETHOD(Refresh) (THIS) PURE;

    STDMETHOD(CreateViewWindow)(THIS_ IShellView  *lpPrevView,
                    LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,
                    RECT * prcView, HWND  *phWnd) PURE;
    STDMETHOD(DestroyViewWindow)(THIS) PURE;
    STDMETHOD(GetCurrentInfo)(THIS_ LPFOLDERSETTINGS lpfs) PURE;
    STDMETHOD(AddPropertySheetPages)(THIS_ DWORD dwReserved,
                    LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam) PURE;
    STDMETHOD(SaveViewState)(THIS) PURE;
    STDMETHOD(SelectItem)(THIS_ LPCITEMIDLIST pidlItem, UINT uFlags) PURE;
    STDMETHOD(GetItemObject)(THIS_ UINT uItem, REFIID riid,
                    LPVOID *ppv) PURE;
};

typedef IShellView *    LPSHELLVIEW;
#endif //0

#define CFSTR_FILEDESCRIPTORA   TEXT("FileGroupDescriptor")     // CF_FILEGROUPDESCRIPTORA
#define CFSTR_FILECONTENTS      TEXT("FileContents")            // CF_FILECONTENTS

#if 0    // Now SHLOBJ has this
//
// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
//
typedef enum {
    FD_CLSID            = 0x0001,
    FD_SIZEPOINT        = 0x0002,
    FD_ATTRIBUTES       = 0x0004,
    FD_CREATETIME       = 0x0008,
    FD_ACCESSTIME       = 0x0010,
    FD_WRITESTIME       = 0x0020,
    FD_FILESIZE         = 0x0040,
    FD_LINKUI           = 0x8000,       // 'link' UI is prefered
} FD_FLAGS;

typedef struct _FILEDESCRIPTORA { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTORA, *LPFILEDESCRIPTORA;

#define FILEDESCRIPTOR      FILEDESCRIPTORA
#define LPFILEDESCRIPTOR    LPFILEDESCRIPTORA

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTORA { // fgd
     UINT cItems;
     FILEDESCRIPTORA fgd[1];
} FILEGROUPDESCRIPTORA, * LPFILEGROUPDESCRIPTORA;

#define FILEGROUPDESCRIPTOR     FILEGROUPDESCRIPTORA
#define LPFILEGROUPDESCRIPTOR   LPFILEGROUPDESCRIPTORA
#endif //0

#endif //_SHLOBJ_H_

/*****************************************************************************\
*                                                                             *
*  From shlobjp.h(private\windows\inc)
*                                                                             *
\*****************************************************************************/

#if 0 // Now SHLOBJP has this
void   WINAPI SHFree(LPVOID pv);
#endif


/*****************************************************************************
 *
 *  From wtypes.h(INC16)
 *
 *****************************************************************************/

typedef unsigned short VARTYPE;

typedef LONG SCODE;

/* 0 == FALSE, -1 == TRUE */
typedef short VARIANT_BOOL;

#ifndef _LPCOLORREF_DEFINED
#define _LPCOLORREF_DEFINED
typedef DWORD __RPC_FAR *LPCOLORREF;

#endif // !_LPCOLORREF_DEFINED


/*****************************************************************************\
 *
 *  From objidl.h(INC32) and it should be added into "objidl.h"(INC16) file.
 *
\*****************************************************************************/

//#ifdef __objidl_h__

/*****************************************************************************\
*                                                                             *
*  From imm.h(INC32)
*                                                                             *
\*****************************************************************************/

typedef UINT FAR *LPUINT;


/*****************************************************************************\
*                                                                             *
*  From comctlie.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/

#ifdef _INC_COMCTLIE

#define EM_SETLIMITTEXT         EM_LIMITTEXT

// From winuser.h
#define IMAGE_BITMAP 0
#define IMAGE_ICON          1
#define IMAGE_CURSOR        2

#define     ImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)

#if 0    // Now COMCTLIE has this
typedef struct {
    HKEY hkr;
    LPCSTR pszSubKey;
    LPCSTR pszValueName;
} TBSAVEPARAMS;
#endif

#define PNM_FINDITEM    LPNMLVFINDITEM

#define PNM_ODSTATECHANGE   LPNMLVODSTATECHANGE


#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG


#define ACM_OPENA               (WM_USER+100)

#define ACM_OPEN                ACM_OPENA

#define ACM_PLAY                (WM_USER+101)
#define ACM_STOP                (WM_USER+102)


#define ACN_START               1
#define ACN_STOP                2

#define Animate_Open(hwnd, szName)          (BOOL)SNDMSG(hwnd, ACM_OPEN, 0, (LPARAM)(LPTSTR)(szName))
#define Animate_Play(hwnd, from, to, rep)   (BOOL)SNDMSG(hwnd, ACM_PLAY, (WPARAM)(UINT)(rep), (LPARAM)MAKELONG(from, to))
#define Animate_Stop(hwnd)                  (BOOL)SNDMSG(hwnd, ACM_STOP, 0, 0)
#define Animate_Close(hwnd)                 Animate_Open(hwnd, NULL)

#if 0    // Now COMCTLIE has this

#define CBEN_FIRST              (0U-800U)       // combo box ex
#define CBEN_LAST               (0U-830U)


////////////////////  ComboBoxEx ////////////////////////////////


#define WC_COMBOBOXEXW         L"ComboBoxEx32"
#define WC_COMBOBOXEXA         "ComboBoxEx32"

#ifdef UNICODE
#define WC_COMBOBOXEX          WC_COMBOBOXEXW
#else
#define WC_COMBOBOXEX          WC_COMBOBOXEXA
#endif


#define CBEIF_TEXT              0x00000001
#define CBEIF_IMAGE             0x00000002
#define CBEIF_SELECTEDIMAGE     0x00000004
#define CBEIF_OVERLAY           0x00000008
#define CBEIF_INDENT            0x00000010
#define CBEIF_LPARAM            0x00000020

#define CBEIF_DI_SETITEM        0x10000000

typedef struct tagCOMBOBOXEXITEMA
{
    UINT mask;
    int iItem;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} COMBOBOXEXITEMA, *PCOMBOBOXEXITEMA;
typedef COMBOBOXEXITEMA CONST *PCCOMBOEXITEMA;

typedef struct tagCOMBOBOXEXITEMW
{
    UINT mask;
    int iItem;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} COMBOBOXEXITEMW, *PCOMBOBOXEXITEMW;
typedef COMBOBOXEXITEMW CONST *PCCOMBOEXITEMW;

#ifdef UNICODE
#define COMBOBOXEXITEM            COMBOBOXEXITEMW
#define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMW
#define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMW
#else
#define COMBOBOXEXITEM            COMBOBOXEXITEMA
#define PCOMBOBOXEXITEM           PCOMBOBOXEXITEMA
#define PCCOMBOBOXEXITEM          PCCOMBOBOXEXITEMA
#endif

#define CBEM_INSERTITEMA        (WM_USER + 1)
#define CBEM_SETIMAGELIST       (WM_USER + 2)
#define CBEM_GETIMAGELIST       (WM_USER + 3)
#define CBEM_GETITEMA           (WM_USER + 4)
#define CBEM_SETITEMA           (WM_USER + 5)
#define CBEM_DELETEITEM         CB_DELETESTRING
#define CBEM_GETCOMBOCONTROL    (WM_USER + 6)
#define CBEM_GETEDITCONTROL     (WM_USER + 7)
#if (_WIN32_IE >= 0x0400)
#define CBEM_SETEXSTYLE         (WM_USER + 8)  // use  SETEXTENDEDSTYLE instead
#define CBEM_SETEXTENDEDSTYLE   (WM_USER + 14)   // lparam == new style, wParam (optional) == mask
#define CBEM_GETEXSTYLE         (WM_USER + 9) // use GETEXTENDEDSTYLE instead
#define CBEM_GETEXTENDEDSTYLE   (WM_USER + 9)
#else
#define CBEM_SETEXSTYLE         (WM_USER + 8)
#define CBEM_GETEXSTYLE         (WM_USER + 9)
#endif
#define CBEM_HASEDITCHANGED     (WM_USER + 10)
#define CBEM_INSERTITEMW        (WM_USER + 11)
#define CBEM_SETITEMW           (WM_USER + 12)
#define CBEM_GETITEMW           (WM_USER + 13)

#ifdef UNICODE
#define CBEM_INSERTITEM         CBEM_INSERTITEMW
#define CBEM_SETITEM            CBEM_SETITEMW
#define CBEM_GETITEM            CBEM_GETITEMW
#else
#define CBEM_INSERTITEM         CBEM_INSERTITEMA
#define CBEM_SETITEM            CBEM_SETITEMA
#define CBEM_GETITEM            CBEM_GETITEMA
#endif

#define CBES_EX_NOEDITIMAGE          0x00000001
#define CBES_EX_NOEDITIMAGEINDENT    0x00000002
#define CBES_EX_PATHWORDBREAKPROC    0x00000004
#if (_WIN32_IE >= 0x0400)
#define CBES_EX_NOSIZELIMIT          0x00000008
#define CBES_EX_CASESENSITIVE        0x00000010

typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEMA ceItem;
} NMCOMBOBOXEXA, *PNMCOMBOBOXEXA;

typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEMW ceItem;
} NMCOMBOBOXEXW, *PNMCOMBOBOXEXW;

#ifdef UNICODE
#define NMCOMBOBOXEX            NMCOMBOBOXEXW
#define PNMCOMBOBOXEX           PNMCOMBOBOXEXW
#define CBEN_GETDISPINFO CBEN_GETDISPINFOW
#else
#define NMCOMBOBOXEX            NMCOMBOBOXEXA
#define PNMCOMBOBOXEX           PNMCOMBOBOXEXA
#define CBEN_GETDISPINFO CBEN_GETDISPINFOA
#endif

#else
typedef struct {
    NMHDR hdr;
    COMBOBOXEXITEM ceItem;
} NMCOMBOBOXEX, *PNMCOMBOBOXEX;

#define CBEN_GETDISPINFO         (CBEN_FIRST - 0)

#endif      // _WIN32_IE

#define CBEN_GETDISPINFOA        (CBEN_FIRST - 0)
#define CBEN_INSERTITEM         (CBEN_FIRST - 1)
#define CBEN_DELETEITEM         (CBEN_FIRST - 2)
#define CBEN_BEGINEDIT          (CBEN_FIRST - 4)
#define CBEN_ENDEDITA            (CBEN_FIRST - 5)
#define CBEN_ENDEDITW            (CBEN_FIRST - 6)
#define CBEN_GETDISPINFOW        (CBEN_FIRST - 7)

        // lParam specifies why the endedit is happening
#ifdef UNICODE
#define CBEN_ENDEDIT CBEN_ENDEDITW
#else
#define CBEN_ENDEDIT CBEN_ENDEDITA
#endif

#define CBENF_KILLFOCUS         1
#define CBENF_RETURN            2
#define CBENF_ESCAPE            3
#define CBENF_DROPDOWN          4

#define CBEMAXSTRLEN 260

#endif //0

#if 0
#define TTN_NEEDTEXTW      TTN_NEEDTEXT
#endif

// Copied from ..\inc\commctrl.h
#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

#if 0    // Now COMCTLIE has this

#define DTN_FIRST               (0U-760U)       // datetimepick
#define DTN_LAST                (0U-799U)

#define DTN_DATETIMECHANGE  (DTN_FIRST + 1) // the systemtime has changed
typedef struct tagNMDATETIMECHANGE
{
    NMHDR       nmhdr;
    DWORD       dwFlags;    // GDT_VALID or GDT_NONE
    SYSTEMTIME  st;         // valid iff dwFlags==GDT_VALID
} NMDATETIMECHANGE, FAR * LPNMDATETIMECHANGE;

#define GDT_ERROR    -1
#define GDT_VALID    0
#define GDT_NONE     1

#define DTM_FIRST        0x1000

#define DTM_GETSYSTEMTIME   (DTM_FIRST + 1)
#define DateTime_GetSystemtime(hdp, pst)    (DWORD)SNDMSG(hdp, DTM_GETSYSTEMTIME, 0, (LPARAM)(pst))

#define DTM_SETSYSTEMTIME   (DTM_FIRST + 2)
#define DateTime_SetSystemtime(hdp, gd, pst)    (BOOL)SNDMSG(hdp, DTM_SETSYSTEMTIME, (LPARAM)(gd), (LPARAM)(pst))

#endif //0

#define TCS_BOTTOM   0     // 0x0002 - Not supported in Win16
#endif //_INC_COMCTLIE

/*****************************************************************************\
*                                                                             *
*  From wingdi.h(INC32)
*                                                                             *
\*****************************************************************************/

#define GB2312_CHARSET          134
#define JOHAB_CHARSET           130
#define HEBREW_CHARSET          177
#define ARABIC_CHARSET          178
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define VIETNAMESE_CHARSET      163
#define THAI_CHARSET            222
#define EASTEUROPE_CHARSET      238
#define RUSSIAN_CHARSET         204

#define MAC_CHARSET             77
#define BALTIC_CHARSET          186

//LOGFONGA is defined as LOGFONT in Win16x.h
#undef  LOGFONTA

typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[LF_FACESIZE];
} LOGFONTA, *PLOGFONTA, NEAR *NPLOGFONTA, FAR *LPLOGFONTA;

typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[LF_FULLFACESIZE];
    BYTE        elfStyle[LF_FACESIZE];
    BYTE        elfScript[LF_FACESIZE];
} ENUMLOGFONTEXA, FAR *LPENUMLOGFONTEXA;

typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;


typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA, NEAR *NPNEWTEXTMETRICA, FAR *LPNEWTEXTMETRICA;

typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE,FAR *LPFONTSIGNATURE;

typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;

typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;


typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO, NEAR *NPCHARSETINFO, FAR *LPCHARSETINFO;

#define TCI_SRCCHARSET  1
#define TCI_SRCCODEPAGE 2
#define TCI_SRCFONTSIG  3

BOOL WINAPI TranslateCharsetInfo( DWORD FAR *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);

#ifdef GetObject
#undef GetObject
#undef DeleteObject
#undef StretchBlt
#endif

#define GetTextExtentPoint32     GetTextExtentPoint

/*****************************************************************************\
*                                                                             *
*  From winuser.h - It should be in the (win16x.h)INC16
*                                                                             *
\*****************************************************************************/

/*
 * lParam of WM_COPYDATA message points to...
 */
typedef struct tagCOPYDATASTRUCT {
    DWORD dwData;
    DWORD cbData;
    PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;

#define WM_COPYDATA                     0x004A
#define WM_HELP                         0x0053

#define WM_CTLCOLORSTATIC               0x0138

#define RegisterWindowMessageA  RegisterWindowMessage

#define SendDlgItemMessageA SendDlgItemMessage
/*
 * WM_SETICON / WM_GETICON Type Codes
 */
#define ICON_SMALL          0
#define ICON_BIG            1

/*
 * Predefined Clipboard Formats
 */
#define CF_HDROP            15

//#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_CONTROLPARENT     0x00000000L  // this is not valid on Win16

#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#define WM_WININICHANGE                 0x001A
#define WM_SETTINGCHANGE                WM_WININICHANGE


#define SM_CXEDGE               45
#define SM_CYEDGE               46

#define LR_DEFAULTCOLOR     0x0000
#define LR_LOADFROMFILE     0x0010
#define LR_LOADTRANSPARENT  0x0020
#define LR_DEFAULTSIZE      0x0040
#define LR_LOADMAP3DCOLORS  0x1000
#define LR_CREATEDIBSECTION 0x2000

BOOL
WINAPI
EnumThreadWindows(
    DWORD dwThreadId,
    WNDENUMPROC lpfn,
    LPARAM lParam);

typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONT lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONT lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONT lfMenuFont;
    LOGFONT lfStatusFont;
    LOGFONT lfMessageFont;
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, FAR* LPNONCLIENTMETRICSA;

typedef NONCLIENTMETRICSA NONCLIENTMETRICS;


int
WINAPI
DrawTextEx(
    HDC hdc,
    LPCSTR lpsz,
    int cb,
    LPRECT lprc,
    UINT fuFormat,
    LPVOID lpDTP );

#define DI_MASK         0x0001
#define DI_IMAGE        0x0002
#define DI_NORMAL       0x0003
#define DI_DEFAULTSIZE  0x0008

BOOL
WINAPI
DrawIconEx(
    HDC hdc,
    int xLeft,
    int yTop,
    HICON hIcon,
    int cxWidth,
    int cyWidth,
    UINT istepIfAniCur,
    HBRUSH hbrFlickerFreeDraw,
    UINT diFlags );


HANDLE
WINAPI
LoadImageA(
    HINSTANCE,
    LPCSTR,
    UINT,
    int,
    int,
    UINT);

#define LoadImage  LoadImageA

BOOL
WINAPI
PostThreadMessageA(
    DWORD idThread,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

#define PostThreadMessage  PostThreadMessageA

#define BN_SETFOCUS         6
#define BN_KILLFOCUS        7

#define BM_GETIMAGE        0x00F6
#define BM_SETIMAGE        0x00F7

#define BST_UNCHECKED      0x0000
//#define BST_CHECKED        0x0001    // defined in WIN16X
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008

typedef struct tagTPMPARAMS
{
    UINT    cbSize;     /* Size of structure */
    RECT    rcExclude;  /* Screen coordinates of rectangle to exclude when positioning */
}   TPMPARAMS;
typedef TPMPARAMS FAR *LPTPMPARAMS;

BOOL
WINAPI
TrackPopupMenuEx(
    HMENU hMenu,
    UINT fuFlags,
    int x,
    int y,
    HWND hwnd,
    LPTPMPARAMS lptpm);

/*
 * Flags for TrackPopupMenu
 */
#define MB_SETFOREGROUND            0     // 0x00010000L - Not supported in Win16
#define MB_DEFAULT_DESKTOP_ONLY     0x00020000L

#define TPM_TOPALIGN        0x0000L
#define TPM_VCENTERALIGN    0x0010L
#define TPM_BOTTOMALIGN     0x0020L

#define TPM_HORIZONTAL      0x0000L     /* Horz alignment matters more */
#define TPM_VERTICAL        0x0040L     /* Vert alignment matters more */
#define TPM_NONOTIFY        0x0080L     /* Don't send any notification msgs */
#define TPM_RETURNCMD       0x0100L

#define DS_SETFOREGROUND    0x0200L     // Not supported in Win16
#define DS_3DLOOK           0x0004L     // Not supported in Win16
#define DS_CONTROL          0x0400L     // Not supported in Win16
#define DS_CENTER           0x0800L     // Not supported in Win16
#define DS_CONTEXTHELP      0x2000L     // Not supported in Win16

#define SS_BITMAP           0x0000000EL // Not supported in Win16
#define SS_ETCHEDHORZ       0x00000010L // Not supported in Win16
#define SS_NOTIFY           0x00000100L // Not supported in Win16
#define SS_CENTERIMAGE      0x00000200L // Not supported in Win16
#define SS_REALSIZEIMAGE    0x00000800L // Not supported in Win16
#define SS_SUNKEN           0x00001000L // Not supported in Win16

#define BS_ICON         0     // 0x00000040L - Not supported in Win16
#define BS_PUSHLIKE     0     // 0x00001000L - Not supported in Win16
#define BS_MULTILINE    0     // 0x00002000L - Not supported in Win16

#define ES_NUMBER       0     // 0x2000L - Not supported in Win16

#ifndef NOWINMESSAGES
/*
 * Static Control Mesages
 */
// #define STM_SETICON         0x0170
// #define STM_GETICON         0x0171
#if(WINVER >= 0x0400)
#define STM_SETIMAGE        0x0172
#define STM_GETIMAGE        0x0173
#define STN_CLICKED         0
#define STN_DBLCLK          1
#define STN_ENABLE          2
#define STN_DISABLE         3
#endif /* WINVER >= 0x0400 */
#define STM_MSGMAX          0x0174
#endif /* !NOWINMESSAGES */

#define HELP_FINDER       0x000b

#ifndef NOWINSTYLES

// begin_r_winuser

/*
 * Scroll Bar Styles
 */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L
#define SBS_SIZEGRIP                0x0010L

// end_r_winuser

//#define CharNextA  AnsiNext    // defined in WIN16X
#define CharNextW  AnsiNext

#endif /* !NOWINSTYLES */

/*****************************************************************************\
*                                                                             *
*  From winnls.h(INC32) - It should be in the (win16x.h)INC16
*                                                                             *
\*****************************************************************************/

//
//  String Length Maximums.
//
#define MAX_LEADBYTES             12          // 5 ranges, 2 bytes ea., 0 term.
#define MAX_DEFAULTCHAR           2           // single or double byte

#define GetDateFormat GetDateFormatA
#define GetTimeFormat GetTimeFormatA

//
//  CP Info.
//

typedef struct _cpinfo {
    UINT    MaxCharSize;                    // max length (in bytes) of a char
    BYTE    DefaultChar[MAX_DEFAULTCHAR];   // default character
    BYTE    LeadByte[MAX_LEADBYTES];        // lead byte ranges
} CPINFO, *LPCPINFO;

BOOL
WINAPI
IsValidCodePage(
    UINT  CodePage);

BOOL
WINAPI
GetCPInfo(
    UINT      CodePage,
    LPCPINFO  lpCPInfo);

BOOL
WINAPI
IsDBCSLeadByteEx(
    UINT  CodePage,
    BYTE  TestChar);

//
//  MBCS and Unicode Translation Flags.
//
#define MB_PRECOMPOSED            0x00000001  // use precomposed chars
#define MB_COMPOSITE              0x00000002  // use composite chars
#define MB_USEGLYPHCHARS          0x00000004  // use glyph chars, not ctrl chars
#define MB_ERR_INVALID_CHARS      0x00000008  // error for invalid chars

#define WC_COMPOSITECHECK         0x00000200  // convert composite to precomposed
#define WC_DISCARDNS              0x00000010  // discard non-spacing chars
#define WC_SEPCHARS               0x00000020  // generate separate chars
#define WC_DEFAULTCHAR            0x00000040  // replace w/ default char

#define CompareStringW            CompareString

/*****************************************************************************\
*                                                                             *
*  From wincrypt.h(INC32)
*                                                                             *
\*****************************************************************************/

#define _WIN32_WINNT  0x0400     // temp until we got 16bit wincrypt.h
#define WINADVAPI                // temp until we got 16bit wincrypt.h
#define _CRYPT32_
#include "wincrypt.h"


/*****************************************************************************\
*                                                                             *
*  From icwcfg.h(INC32)
*                                                                             *
\*****************************************************************************/

//
// defines
//

// ICW registry settings

// HKEY_CURRENT_USER
#define ICW_REGPATHSETTINGS     "Software\\Microsoft\\Internet Connection Wizard"
#define ICW_REGKEYCOMPLETED     "Completed"

// Maximum field lengths
#define ICW_MAX_ACCTNAME        256
#define ICW_MAX_PASSWORD        256     // PWLEN
#define ICW_MAX_LOGONNAME       256     // UNLEN
#define ICW_MAX_SERVERNAME      64
#define ICW_MAX_RASNAME         256     // RAS_MaxEntryName
#define ICW_MAX_EMAILNAME       64
#define ICW_MAX_EMAILADDR       128

// Bit-mapped flags

// CheckConnectionWizard input flags
#define ICW_CHECKSTATUS         0x0001

#define ICW_LAUNCHFULL          0x0100
#define ICW_LAUNCHMANUAL        0x0200

// CheckConnectionWizard output flags
#define ICW_FULLPRESENT         0x0001
#define ICW_MANUALPRESENT       0x0002
#define ICW_ALREADYRUN          0x0004

#define ICW_LAUNCHEDFULL        0x0100
#define ICW_LAUNCHEDMANUAL      0x0200

// InetCreateMailNewsAccount input flags
#define ICW_USEDEFAULTS         0x0001

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

//
// type definitions
//
typedef enum tagICW_ACCTTYPE
{
	ICW_ACCTMAIL = 0,
	ICW_ACCTNEWS = ICW_ACCTMAIL + 1
} ICW_ACCTTYPE;

typedef struct tagIMNACCTINFO
{
	DWORD dwSize;                                                           // sizeof(MAILNEWSINFO) for versioning
	CHAR szAccountName[ICW_MAX_ACCTNAME + 1];       // Name of Account
	DWORD dwConnectionType;                                         // RAS Connection Type
												// 0 = LAN Connection
												// 1 = Manual Connection
												// 2 = RAS Dialup Connect
	CHAR szPassword[ICW_MAX_PASSWORD + 1];          // Password
	CHAR szUserName[ICW_MAX_LOGONNAME + 1];         // User name (name of logged-on user, if any)
	BOOL fUseSicily;                                                        // Use sicily authentication (FALSE)
	CHAR szNNTPServer[ICW_MAX_SERVERNAME + 1];      // NNTP server name
	CHAR szPOP3Server[ICW_MAX_SERVERNAME + 1];      // POP3 server name
	CHAR szSMTPServer[ICW_MAX_SERVERNAME + 1];      // SMTP server name
	CHAR szIMAPServer[ICW_MAX_SERVERNAME + 1];      // IMAP server name
	CHAR szConnectoid[ICW_MAX_RASNAME + 1];         // RAS Connection Name
	CHAR szDisplayName[ICW_MAX_EMAILNAME + 1];      // Users display name used for sending mail
	CHAR szEmailAddress[ICW_MAX_EMAILADDR + 1];     // Users email address
} IMNACCTINFO;

//
// external function typedefs
//
//typedef HRESULT (WINAPI *PFNCHECKCONNECTIONWIZARD) (DWORD, LPDWORD);
typedef HRESULT (WINAPI *PFNINETCREATEMAILNEWSACCOUNT) (HWND, ICW_ACCTTYPE, IMNACCTINFO*, DWORD);

#ifdef __cplusplus
}
#endif // __cplusplus


/*****************************************************************************\
*                                                                             *
*  From winerror.h(INC16) - winerror.h file should be included from INC16.
*                                                                             *
\*****************************************************************************/

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED


//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND             3L

//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
//  The data is invalid.
//
#define ERROR_INVALID_DATA               13L

//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network
//  adapter card was exceeded.
//
#define ERROR_TOO_MANY_NAMES             68L

//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
//  The file exists.
//
#define ERROR_FILE_EXISTS                80L

//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
//  There is not enough space on the disk.
//
#define ERROR_DISK_FULL                  112L

//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Cannot create a file when that file already exists.
//
#define ERROR_ALREADY_EXISTS             183L

//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
//  More data is available.
//
#define ERROR_MORE_DATA                  234L    // dderror

//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
//  Invalid flags.
//
#define ERROR_INVALID_FLAGS              1004L

//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define ERROR_NO_UNICODE_TRANSLATION     1113L

//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
//  Class already exists.
//
#define ERROR_CLASS_ALREADY_EXISTS       1410L

//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
//  Bad Data.
//
#define NTE_BAD_DATA                     _HRESULT_TYPEDEF_(0x80090005L)

//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
//  Invalid Signature.
//
#define NTE_BAD_SIGNATURE                _HRESULT_TYPEDEF_(0x80090006L)

//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
//  Invalid algorithm specified.
//
#define NTE_BAD_ALGID                    _HRESULT_TYPEDEF_(0x80090008L)

//
// MessageId: NTE_EXISTS
//
// MessageText:
//
//  Object already exists.
//
#define NTE_EXISTS                       _HRESULT_TYPEDEF_(0x8009000FL)

//
// MessageId: NTE_FAIL
//
// MessageText:
//
//  An internal error occurred.
//
#define NTE_FAIL                         _HRESULT_TYPEDEF_(0x80090020L)

//
// MessageId: CRYPT_E_MSG_ERROR
//
// MessageText:
//
//  An error was encountered doing a cryptographic message operation.
//
#define CRYPT_E_MSG_ERROR                _HRESULT_TYPEDEF_(0x80091001L)

//
// MessageId: CRYPT_E_HASH_VALUE
//
// MessageText:
//
//  The hash value is not correct.
//
#define CRYPT_E_HASH_VALUE               _HRESULT_TYPEDEF_(0x80091007L)

//
// MessageId: CRYPT_E_SIGNER_NOT_FOUND
//
// MessageText:
//
//  The original signer is not found.
//
#define CRYPT_E_SIGNER_NOT_FOUND         _HRESULT_TYPEDEF_(0x8009100EL)

//
// MessageId: CRYPT_E_STREAM_MSG_NOT_READY
//
// MessageText:
//
//  The steamed message is note yet able to return the requested data.
//
#define CRYPT_E_STREAM_MSG_NOT_READY     _HRESULT_TYPEDEF_(0x80091010L)

//
// MessageId: CRYPT_E_NOT_FOUND
//
// MessageText:
//
//  The object or property wasn't found
//
#define CRYPT_E_NOT_FOUND                _HRESULT_TYPEDEF_(0x80092004L)

// MessageId: CRYPT_E_EXISTS
//
// MessageText:
//
//  The object or property already exists
//
#define CRYPT_E_EXISTS                   _HRESULT_TYPEDEF_(0x80092005L)

//
// MessageId: CRYPT_E_SELF_SIGNED
//
// MessageText:
//
//  The specified certificate is self signed.
//
#define CRYPT_E_SELF_SIGNED              _HRESULT_TYPEDEF_(0x80092007L)

//
//
// MessageId: CRYPT_E_NO_KEY_PROPERTY
//
// MessageText:
//
//  The certificate doesn't have a private key property
//
#define CRYPT_E_NO_KEY_PROPERTY          _HRESULT_TYPEDEF_(0x8009200BL)


// MessageId: CRYPT_E_NO_DECRYPT_CERT
//
// MessageText:
//
//  No certificate was found having a private key property to use for decrypting.
//
#define CRYPT_E_NO_DECRYPT_CERT          _HRESULT_TYPEDEF_(0x8009200CL)

//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to perform an initialization operation when
//  initialization has already been completed.
//
#define ERROR_ALREADY_INITIALIZED        1247L

/*****************************************************************************\
*                                                                             *
*  From winreg.h(INC32)
*                                                                             *
\*****************************************************************************/
#if 0
LONG
APIENTRY
RegEnumValueA (
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

#define RegEnumValue  RegEnumValueA
#endif

#define STANDARD_RIGHTS_WRITE            (READ_CONTROL)


/*****************************************************************************\
*                                                                             *
*  From mmsystem.h(INC32)
*                                                                             *
\*****************************************************************************/

typedef UINT FAR   *LPUINT;


/*****************************************************************************\
*                                                                             *
*  From shellapi.h(INC32)
*                                                                             *
\*****************************************************************************/

#if 0    // Started to use SHELLAPI
typedef struct _SHFILEINFOA
{
        HICON       hIcon;                      // out: icon
        int         iIcon;                      // out: icon index
        DWORD       dwAttributes;               // out: SFGAO_ flags
        CHAR        szDisplayName[MAX_PATH];    // out: display name (or path)
        CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;

typedef SHFILEINFOA SHFILEINFO;

#define SHGFI_ICON              0x000000100     // get icon
#define SHGFI_DISPLAYNAME       0x000000200     // get display name
#define SHGFI_TYPENAME          0x000000400     // get type name
#define SHGFI_ATTRIBUTES        0x000000800     // get attributes
#define SHGFI_ICONLOCATION      0x000001000     // get icon location
#define SHGFI_EXETYPE           0x000002000     // return exe type
#define SHGFI_SYSICONINDEX      0x000004000     // get system icon index
#define SHGFI_LINKOVERLAY       0x000008000     // put a link overlay on icon
#define SHGFI_SELECTED          0x000010000     // show icon in selected state
#define SHGFI_LARGEICON         0x000000000     // get large icon
#define SHGFI_SMALLICON         0x000000001     // get small icon
#define SHGFI_OPENICON          0x000000002     // get open icon
#define SHGFI_SHELLICONSIZE     0x000000004     // get shell size icon
#define SHGFI_PIDL              0x000000008     // pszPath is a pidl
#define SHGFI_USEFILEATTRIBUTES 0x000000010     // use passed dwFileAttribute

DWORD WINAPI SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA FAR *psfi, UINT cbFileInfo, UINT uFlags);
#define SHGetFileInfo  SHGetFileInfoA

////
//// Tray notification definitions
////

typedef struct _NOTIFYICONDATAA {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        CHAR   szTip[64];
} NOTIFYICONDATAA, *PNOTIFYICONDATAA;
typedef struct _NOTIFYICONDATAW {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;
        WCHAR  szTip[64];
} NOTIFYICONDATAW, *PNOTIFYICONDATAW;
#ifdef UNICODE
typedef NOTIFYICONDATAW NOTIFYICONDATA;
typedef PNOTIFYICONDATAW PNOTIFYICONDATA;
#else
typedef NOTIFYICONDATAA NOTIFYICONDATA;
typedef PNOTIFYICONDATAA PNOTIFYICONDATA;
#endif // UNICODE


#define NIM_ADD         0x00000000
#define NIM_MODIFY      0x00000001
#define NIM_DELETE      0x00000002

#define NIF_MESSAGE     0x00000001
#define NIF_ICON        0x00000002
#define NIF_TIP         0x00000004

BOOL WINAPI Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
BOOL WINAPI Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);
#ifdef UNICODE
#define Shell_NotifyIcon  Shell_NotifyIconW
#else
#define Shell_NotifyIcon  Shell_NotifyIconA
#endif // !UNICODE

////
//// End Tray Notification Icons
////

////
////  Begin ShellExecuteEx and family
////









/* ShellExecute() and ShellExecuteEx() error codes */

/* regular WinExec() codes */
#define SE_ERR_FNF              2       // file not found
#define SE_ERR_PNF              3       // path not found
#define SE_ERR_ACCESSDENIED     5       // access denied
#define SE_ERR_OOM              8       // out of memory
#define SE_ERR_DLLNOTFOUND              32

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE                    26
#define SE_ERR_ASSOCINCOMPLETE          27
#define SE_ERR_DDETIMEOUT               28
#define SE_ERR_DDEFAIL                  29
#define SE_ERR_DDEBUSY                  30
#define SE_ERR_NOASSOC                  31

// Note CLASSKEY overrides CLASSNAME
#define SEE_MASK_CLASSNAME      0x00000001
#define SEE_MASK_CLASSKEY       0x00000003
// Note INVOKEIDLIST overrides IDLIST
#define SEE_MASK_IDLIST         0x00000004
#define SEE_MASK_INVOKEIDLIST   0x0000000c
#define SEE_MASK_ICON           0x00000010
#define SEE_MASK_HOTKEY         0x00000020
#define SEE_MASK_NOCLOSEPROCESS 0x00000040
#define SEE_MASK_CONNECTNETDRV  0x00000080
#define SEE_MASK_FLAG_DDEWAIT   0x00000100
#define SEE_MASK_DOENVSUBST     0x00000200
#define SEE_MASK_FLAG_NO_UI     0x00000400
#define SEE_MASK_UNICODE        0x00004000
#define SEE_MASK_NO_CONSOLE     0x00008000
#define SEE_MASK_ASYNCOK        0x00100000
#define SEE_MASK_HMONITOR       0x00200000

typedef struct _SHELLEXECUTEINFOA
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR   lpVerb;
        LPCSTR   lpFile;
        LPCSTR   lpParameters;
        LPCSTR   lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCSTR   lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        };
        HANDLE hProcess;
} SHELLEXECUTEINFOA, FAR *LPSHELLEXECUTEINFOA;
typedef struct _SHELLEXECUTEINFOW
{
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR  lpVerb;
        LPCWSTR  lpFile;
        LPCWSTR  lpParameters;
        LPCWSTR  lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        // Optional fields
        LPVOID lpIDList;
        LPCWSTR  lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union {
        HANDLE hIcon;
        HANDLE hMonitor;
        };
        HANDLE hProcess;
} SHELLEXECUTEINFOW, FAR *LPSHELLEXECUTEINFOW;
#ifdef UNICODE
typedef SHELLEXECUTEINFOW SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOW LPSHELLEXECUTEINFO;
#else
typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;
#endif // UNICODE

BOOL WINAPI ShellExecuteExA(LPSHELLEXECUTEINFOA lpExecInfo);
BOOL WINAPI ShellExecuteExW(LPSHELLEXECUTEINFOW lpExecInfo);
#ifdef UNICODE
#define ShellExecuteEx  ShellExecuteExW
#else
#define ShellExecuteEx  ShellExecuteExA
#endif // !UNICODE
////
////  End ShellExecuteEx and family
////
#endif //0

/*****************************************************************************\
*                                                                             *
*  From windowsx.h(INC32)
*                                                                             *
\*****************************************************************************/

/* void Cls_OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos) */
#define HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)), 0L)
#define HANDLE_WM_CTLCOLORSTATIC(hwnd, wParam, lParam, fn) \
    (LRESULT)(DWORD)(UINT)(HBRUSH)(fn)((hwnd), (HDC)(wParam), (HWND)(lParam), CTLCOLOR_STATIC)

typedef MINMAXINFO FAR * LPMINMAXINFO;

typedef MINMAXINFO FAR * LPMINMAXINFO;

typedef WCHAR  PWCHAR;

#if 0    // Now WINDEF has this
#define DECLSPEC_IMPORT
#endif

#define wvsprintfA                   wvsprintf
#define GetPrivateProfileIntA        GetPrivateProfileInt
#define lstrcatA                     lstrcat
#define lstrcmpA                     lstrcmp
#define lstrcmpW                     lstrcmp
#define lstrcmpiA                    lstrcmpi
#define LoadStringA                  LoadString
#define IsBadStringPtrA              IsBadStringPtr
#define IsBadStringPtrW              IsBadStringPtr

/*****************************************************************************\
*                                                                             *
*  From commdlg.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
#define OFN_NONETWORKBUTTON          0x00020000
#define OFN_EXPLORER             0   // 0x00080000 - Not available on Win16
#define OFN_NODEREFERENCELINKS   0   // 0x00100000 - Not available on Win16

typedef UINT (CALLBACK *LPOFNHOOKPROC)( HWND, UINT, WPARAM, LPARAM );

#define CF_NOVERTFONTS       0   // 0x01000000L - Not available on Win16

#define CDM_FIRST       (WM_USER + 100)
#define CDM_LAST        (WM_USER + 200)

// lParam = pointer to a string
// wParam = ID of control to change
// return = not used
#define CDM_SETCONTROLTEXT      (CDM_FIRST + 0x0004)
#define CommDlg_OpenSave_SetControlText(_hdlg, _id, _text) \
        (void)SNDMSG(_hdlg, CDM_SETCONTROLTEXT, (WPARAM)_id, (LPARAM)(LPSTR)_text)

/*****************************************************************************\
*                                                                             *
*  From ntregapi.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
//
// Key creation/open disposition
//

#define REG_CREATED_NEW_KEY         (0x00000001L)   // New Registry Key created
#define REG_OPENED_EXISTING_KEY     (0x00000002L)   // Existing Key opened

/*****************************************************************************\
*                                                                             *
*  From ntregapi.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
#if 0
typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;
#endif

#if 0    // Now WINERROR has this
/*****************************************************************************\
*                                                                             *
*  From compobj.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/

#define CO_E_NOT_SUPPORTED          (CO_E_FIRST + 0x10)
#endif

/*****************************************************************************\
*                                                                             *
*  From mbstring.h - It should be in the INC16
*                                                                             *
\*****************************************************************************/
/***
* mbstring.h - MBCS string manipulation macros and functions
*
*	Copyright (c) 1990-1995, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*	This file contains macros and function declarations for the MBCS
*	string manipulation functions.
*
*       [Public]
*
****/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_MBSTRING
#define _INC_MBSTRING

#ifdef _MSC_VER
/*
 * Currently, all MS C compilers for Win32 platforms default to 8 byte
 * alignment.
 */
#pragma pack(push,8)
#endif	/* _MSC_VER */

#ifdef __cplusplus
extern "C" {
#endif

/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef	_NTSDK
/* definition compatible with NT SDK */
#define _CRTIMP
#else	/* ndef _NTSDK */
/* current definition */
#ifdef	_DLL
#define _CRTIMP __declspec(dllimport)
#else	/* ndef _DLL */
#define _CRTIMP
#endif	/* _DLL */
#endif	/* _NTSDK */
#endif	/* _CRTIMP */

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _NLSCMP_DEFINED
#define _NLSCMPERROR    2147483647	/* currently == INT_MAX */
#define _NLSCMP_DEFINED
#endif


#if 0
#ifndef _VA_LIST_DEFINED
#ifdef	_M_ALPHA
typedef struct {
	char *a0;	/* pointer to first homed integer argument */
	int offset;	/* byte offset of next parameter */
} va_list;
#else
typedef char *	va_list;
#endif
#define _VA_LIST_DEFINED
#endif

#ifndef _FILE_DEFINED
struct _iobuf {
	char *_ptr;
	int   _cnt;
	char *_base;
	int   _flag;
	int   _file;
	int   _charbuf;
	int   _bufsiz;
	char *_tmpfname;
	};
typedef struct _iobuf FILE;
#define _FILE_DEFINED
#endif
#endif

/*
 * MBCS - Multi-Byte Character Set
 */

#ifndef _MBSTRING_DEFINED

/* function prototypes */

_CRTIMP unsigned int __cdecl _mbbtombc(unsigned int);
_CRTIMP int __cdecl _mbbtype(unsigned char, int);
_CRTIMP unsigned int __cdecl _mbctombb(unsigned int);
_CRTIMP int __cdecl _mbsbtype(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbscat(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbschr(const unsigned char *, unsigned int);
_CRTIMP int __cdecl _mbscmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbscoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbscpy(unsigned char *, const unsigned char *);
_CRTIMP size_t __cdecl _mbscspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdec(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsdup(const unsigned char *);
_CRTIMP int __cdecl _mbsicmp(const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _mbsicoll(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsinc(const unsigned char *);
_CRTIMP size_t __cdecl _mbslen(const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbslwr(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsnbcat(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbcoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnbcnt(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbcpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnbicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnbset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbsncat(unsigned char *, const unsigned char *, size_t);
_CRTIMP size_t __cdecl _mbsnccnt(const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsncoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsncpy(unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned int __cdecl _mbsnextc (const unsigned char *);
_CRTIMP int __cdecl _mbsnicmp(const unsigned char *, const unsigned char *, size_t);
_CRTIMP int __cdecl _mbsnicoll(const unsigned char *, const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsninc(const unsigned char *, size_t);
_CRTIMP unsigned char * __cdecl _mbsnset(unsigned char *, unsigned int, size_t);
_CRTIMP unsigned char * __cdecl _mbspbrk(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsrchr(const unsigned char *, unsigned int);
_CRTIMP unsigned char * __cdecl _mbsrev(unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsset(unsigned char *, unsigned int);
_CRTIMP size_t __cdecl _mbsspn(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsspnp(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsstr(const unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbstok(unsigned char *, const unsigned char *);
_CRTIMP unsigned char * __cdecl _mbsupr(unsigned char *);

_CRTIMP size_t __cdecl _mbclen(const unsigned char *);
_CRTIMP void __cdecl _mbccpy(unsigned char *, const unsigned char *);
#define _mbccmp(_cpc1, _cpc2) _mbsncmp((_cpc1),(_cpc2),1)

/* character routines */

_CRTIMP int __cdecl _ismbcalnum(unsigned int);
_CRTIMP int __cdecl _ismbcalpha(unsigned int);
_CRTIMP int __cdecl _ismbcdigit(unsigned int);
_CRTIMP int __cdecl _ismbcgraph(unsigned int);
_CRTIMP int __cdecl _ismbclegal(unsigned int);
_CRTIMP int __cdecl _ismbclower(unsigned int);
_CRTIMP int __cdecl _ismbcprint(unsigned int);
_CRTIMP int __cdecl _ismbcpunct(unsigned int);
_CRTIMP int __cdecl _ismbcspace(unsigned int);
_CRTIMP int __cdecl _ismbcupper(unsigned int);

_CRTIMP unsigned int __cdecl _mbctolower(unsigned int);
_CRTIMP unsigned int __cdecl _mbctoupper(unsigned int);

#define _MBSTRING_DEFINED
#endif

#ifndef _MBLEADTRAIL_DEFINED
_CRTIMP int __cdecl _ismbblead( unsigned int );
_CRTIMP int __cdecl _ismbbtrail( unsigned int );
_CRTIMP int __cdecl _ismbslead( const unsigned char *, const unsigned char *);
_CRTIMP int __cdecl _ismbstrail( const unsigned char *, const unsigned char *);
#define _MBLEADTRAIL_DEFINED
#endif

/*  Kanji specific prototypes.	*/

_CRTIMP int __cdecl _ismbchira(unsigned int);
_CRTIMP int __cdecl _ismbckata(unsigned int);
_CRTIMP int __cdecl _ismbcsymbol(unsigned int);
_CRTIMP int __cdecl _ismbcl0(unsigned int);
_CRTIMP int __cdecl _ismbcl1(unsigned int);
_CRTIMP int __cdecl _ismbcl2(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjistojms(unsigned int);
_CRTIMP unsigned int __cdecl _mbcjmstojis(unsigned int);
_CRTIMP unsigned int __cdecl _mbctohira(unsigned int);
_CRTIMP unsigned int __cdecl _mbctokata(unsigned int);

#ifdef __cplusplus
}
#endif

#ifdef _MSC_VER
#pragma pack(pop)
#endif	/* _MSC_VER */

#endif	/* _INC_MBSTRING */


/*****************************************************************************\
*                                                                             *
*  From winnt.h(INC32)
*                                                                             *
\*****************************************************************************/

#define MEM_COMMIT           0x1000     
#define MEM_RESERVE          0x2000     
#define MEM_DECOMMIT         0x4000     
#define MEM_RELEASE          0x8000     


struct WNDMSGPARAM16
{
   LPARAM  wParam;
   LPARAM  lParam;
};


/*****************************************************************************\
*                                                                             *
*  From shlwapi.h - shlwapi.h in INC16 is not feasible for us
*                                                                             *
\*****************************************************************************/

#ifdef __cplusplus
}
#endif //__cplusplus


/*****************************************************************************\
*                                                                             *
*  From iehelpid - iehelpid.h from INC which is not in INC16
*                                                                             *
\*****************************************************************************/

//CERTIFICATE PROPERTIES DIALOG BOX
#define IDH_CERTVWPROP_GEN_FINEPRINT          50228
#define IDH_CERTVWPROP_DET_ISSUER_CERT        50229
#define IDH_CERTVWPROP_DET_FRIENDLY           50230
#define IDH_CERTVWPROP_DET_STATUS             50231
#define IDH_CERTVWPROP_TRUST_PURPOSE          50232
#define IDH_CERTVWPROP_TRUST_HIERAR           50233
#define IDH_CERTVWPROP_TRUST_VIEWCERT         50234
#define IDH_CERTVWPROP_TRUST_INHERIT          50235
#define IDH_CERTVWPROP_TRUST_EXPLICIT_TRUST   50236
#define IDH_CERTVWPROP_TRUST_EXPLICIT_DISTRUST 50237
#define IDH_CERTVWPROP_ADV_FIELD              50238
#define IDH_CERTVWPROP_ADV_DETAILS            50239



#endif // ATHENA16_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\envguid.h ===
#ifndef _ENVGUID_H
#define _ENVGUID_H

// {A08AF898-C2A3-11d1-BE23-00C04FA31009}
DEFINE_GUID(CLSID_OEEnvelope, 0xa08af898, 0xc2a3, 0x11d1, 0xbe, 0x23, 0x0, 0xc0, 0x4f, 0xa3, 0x10, 0x9);
//{42F07860-4692-11d1-82D3-00C04FD9753F}
DEFINE_GUID(CGID_Envelope, 0x42f07860, 0x4692, 0x11d1, 0x82, 0xd3, 0x0, 0xc0,0x4f, 0xd9, 0x75, 0x3f);
// {00067298-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoEnvelope, 0x00067298, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
// {0006729A-0000-0000-C0000-00000000046}
DEFINE_GUID(IID_IMsoEnvelopeHost, 0x0006729A, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
// {00067299-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoEnvelopeSite, 0x00067299, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

// {000C0601-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoComponentManager, 0x000C0601, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
// {000C0600-0000-0000-C000-000000000046}
DEFINE_GUID(IID_IMsoComponent, 0x000C0600, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

DEFINE_GUID(CLSID_GWEnvelopeHost, 0x00000000, 0x7bc4, 0x11d1, 0xbd, 0xfa, 0x0, 0xc0, 0x4f, 0xa3, 0x10, 0x9);

// {8CC497C0-A1DF-11ce-8098-00AA0047BE5D} Taken from tom.h
DEFINE_GUID(IID_ITextDocument, 0x8CC497C0, 0xA1DF, 0x11ce, 0x80, 0x98, 0x00, 0xAA, 0x00, 0x47, 0xBE, 0x5D);
DEFINE_GUID(IID_ITextServices, 0x8d33f740, 0xcf58, 0x11ce, 0xa8, 0x9d, 0x00, 0xaa, 0x00, 0x6c, 0xad, 0xc5);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\list.h ===
//============================================================================
//
//    Header file for generic linked list class
//
//============================================================================

#ifndef LIST_H
#define LIST_H

class CList;
typedef class CItem FAR * LPItem;
class CItem
{
friend class CList;
private:
    LPItem FAR * lppListHead;
    LPItem lpPrevItem;
    LPItem lpNextItem;
protected:
    LPVOID lpObj;
    LPCSTR lpName;
    int    iRefCnt;
public:
    CItem(LPVOID lpObj,LPItem FAR * lppHeadItem, LPCSTR lpName);
    ~CItem();
};

class CList
{
protected:
    LPItem lpItem;
    LPItem lpListHead;
    LPItem FindItem(LPVOID lpObj);
public:
    CList(){lpListHead=NULL;}
    ~CList();
    void AddItemWithName(LPVOID lpObj, LPCSTR lpName){new CItem(lpObj,&lpListHead,lpName);}
    void DelItem(LPVOID lpObj){LPItem lpItem=FindItem(lpObj);delete lpItem;}
    LPVOID FindItemHandleWithName( LPCSTR lpName, LPVOID lpMem );
    BOOL IsEmpty(){return lpListHead==NULL;}
};
typedef CList FAR * LPList;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\hotdisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

#pragma once

// hack - from OLE headers
#define DISPID_VALUE                                ( 0 )
#define DISPID_NEWENUM                              ( -4 )
// hack - from OLE headers

#define DISPID_IOEACCTWIZ_BASE                      1000

#define DISPID_IOEACCTWIZ_SET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 1)
#define DISPID_IOEACCTWIZ_GET_PROP_SZ           (DISPID_IOEACCTWIZ_BASE + 2)
#define DISPID_IOEACCTWIZ_CLEAR_PROPS           (DISPID_IOEACCTWIZ_BASE + 3)
#define DISPID_IOEACCTWIZ_CLOSE                 (DISPID_IOEACCTWIZ_BASE + 4)
#define DISPID_IOEACCTWIZ_NEW_HOTMAIL_ACCOUNT   (DISPID_IOEACCTWIZ_BASE + 5)
#define DISPID_IOEACCTWIZ_WIDTH                 (DISPID_IOEACCTWIZ_BASE + 6)
#define DISPID_IOEACCTWIZ_HEIGHT                (DISPID_IOEACCTWIZ_BASE + 7)
#define DISPID_IOEACCTWIZ_SET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 8)
#define DISPID_IOEACCTWIZ_GET_PROP_I            (DISPID_IOEACCTWIZ_BASE + 9)
#define DISPID_IOEACCTWIZ_NEW_ACCOUNT           (DISPID_IOEACCTWIZ_BASE + 10)
#define DISPID_IOEACCTWIZ_RELOAD                (DISPID_IOEACCTWIZ_BASE + 11)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\icwacct.h ===
#ifndef _INC_ICWACCT_H
#define _INC_ICWACCT_H

#ifndef MAC
#define EXTERNAL_DIALOGID_MINIMUM   2200
#define EXTERNAL_DIALOGID_MAXIMUM   3000

#include <prsht.h>

typedef enum
    {
    CANCEL_PROMPT = 0,
    CANCEL_SILENT,
    CANCEL_REBOOT
    } CANCELTYPE;

// {796AD8F0-B2B7-11d0-8D69-00A0C9A06E1F}
DEFINE_GUID(IID_IICWExtension, 0x796ad8f0, 0xb2b7, 0x11d0, 0x8d, 0x69, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

interface IICWExtension : public IUnknown
    {
	public:
		virtual BOOL STDMETHODCALLTYPE AddExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
		virtual BOOL STDMETHODCALLTYPE RemoveExternalPage(HPROPSHEETPAGE hPage, UINT uDlgID) = 0;
		virtual BOOL STDMETHODCALLTYPE ExternalCancel(CANCELTYPE type) = 0;
		virtual BOOL STDMETHODCALLTYPE SetFirstLastPage(UINT uFirstPageDlgID, UINT uLastPageDlgID) = 0;
    };

#ifndef WIN16
typedef enum
#else
enum
#endif
    {
    CONNECT_LAN = 0,
    CONNECT_MANUAL,
    CONNECT_RAS
    };

typedef struct tagCONNECTINFO
    {
    DWORD   cbSize;
    DWORD   type;
    char    szConnectoid[MAX_PATH];
    } CONNECTINFO;

// IICWApprentice::Save error values
#define ERR_MAIL_ACCT       0x0001
#define ERR_NEWS_ACCT       0x0002
#define ERR_DIRSERV_ACCT    0x0004

// IICWApprentice::AddWizardPages flags
#define WIZ_USE_WIZARD97    0x0008

// {1438E820-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(IID_IICWApprentice, 0x1438E820L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

interface IICWApprentice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICWExtension *pExt) = 0;
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetConnectionInformation(CONNECTINFO *pInfo) = 0;
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID) = 0;
    };

// Athena's CLSID
// {1438E821-B6D2-11D0-8D86-00C04FD6202B}
DEFINE_GUID(CLSID_ApprenticeAcctMgr, 0x1438E821L, 0xB6D2, 0x11D0, 0x8D, 0x86, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

//ICW's CLSID
// {8EE42293-C315-11d0-8D6F-00A0C9A06E1F}
DEFINE_GUID(CLSID_ApprenticeICW, 0x8ee42293L, 0xc315, 0x11d0, 0x8d, 0x6f, 0x0, 0xa0, 0xc9, 0xa0, 0x6e, 0x1f);

// flags for CreateAccountsFromFile
#define CAFF_USE_AUTODIAL   0x0001
#define CAFF_NO_SET_DEFAULT 0x0002
#define CAFF_CURRENT_USER   0x0004

HRESULT WINAPI CreateAccountsFromFile(LPSTR lpFile, DWORD dwFlags);
typedef HRESULT	(WINAPI *PFNCREATEACCOUNTSFROMFILE) (LPSTR, DWORD);

HRESULT WINAPI CreateAccountsFromFileEx(LPSTR lpFile, CONNECTINFO *pci, DWORD dwFlags);
typedef HRESULT	(WINAPI *PFNCREATEACCOUNTSFROMFILEEX) (LPSTR, CONNECTINFO *, DWORD);

#endif  // !MAC
#endif // _INC_ICWACCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\mimeolep.h ===
#ifndef _MIMEOLEP_H
#define _MIMEOLEP_H

/* 
 * MimeOle 'P' .h ?
 *
 * what and why:
 * this is a private header file for exports from inetcomm.dll. Why? there are some funcitons we need to share between MimeEdit and Athena
 * to avoid code duplication, some of these functions require string and other resources. If we put them in msoert2.dll (the logical places)
 * this forces the runtime to be a resourced-dll, which means we need yet another dll - msoertres.dll or something. So this
 * hack of exporting them privatley from inetcomm.dll is a less complicated hack.
 * (sorry opie)
 *
 */

#include "mimeole.h"

// forward refs
typedef struct tagOFNA OPENFILENAME;
typedef struct tagOFNW OPENFILENAMEW;

typedef struct ATTACHDATA_tag
{
    WCHAR       szTempFile[MAX_PATH],       // temp file created with this attachment in it
                szDisplay[MAX_PATH],        // the display name of the attachment as generated by MimeOle (this includes (nK))
                szFileName[MAX_PATH];       // the true filename of the attachment
    HICON       hIcon;                      // the associated icon
    HANDLE      hProcess;                   // handle to process that last opened this attachment
    LPSTREAM    pstm;                       // stream to source bits
    HBODY       hAttach;                    // if coming from a message, this is the handle to the body part, if it's a new attachment
                                            // this this will be null. The data can either be found in pstm, or a full path in lpszFileName
    BOOL        fSafe;                      // is this file safe to open/save
} ATTACHDATA, *LPATTACHDATA;

enum
    {
    AV_OPEN      =0,
    AV_SAVEAS,
    AV_PRINT,
    AV_PROPERTIES,
    AV_QUICKVIEW,
    AV_MAX
    };

// attachment helpers
MIMEOLEAPI HrDoAttachmentVerb(HWND hwnd, ULONG uVerb, IMimeMessage *pMsg, LPATTACHDATA pAttach);
MIMEOLEAPI HrAttachDataFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, LPATTACHDATA *ppAttach);
MIMEOLEAPI HrFreeAttachData(LPATTACHDATA pAttach);
MIMEOLEAPI HrGetAttachIcon(IMimeMessage *pMsg, HBODY hAttach, BOOL fLargeIcon, HICON *phIcon);
MIMEOLEAPI HrSaveAttachmentAs(HWND hwnd, IMimeMessage *pMsg, LPATTACHDATA lpAttach);
MIMEOLEAPI HrAttachSafetyFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, BOOL *pfSafe);

MIMEOLEAPI HrGetDisplayNameWithSizeForFile(LPWSTR szPathName, LPWSTR szDisplayName, int cchMaxDisplayName);
MIMEOLEAPI HrAttachDataFromFile(IStream *pstm, LPWSTR szFileName, LPATTACHDATA *ppAttach);
MIMEOLEAPI HrSaveAttachToFile(IMimeMessage *pMsg, HBODY hAttach, LPWSTR lpszFileName);
MIMEOLEAPI HrGetAttachIconByFile(LPWSTR szFilename, BOOL fLargeIcon, HICON *phIcon);

// fileopen dialog wrapper
MIMEOLEAPI HrGetLastOpenFileDirectory(int cchMax, LPSTR lpsz);
MIMEOLEAPI HrGetLastOpenFileDirectoryW(int cchMax, LPWSTR lpsz);
MIMEOLEAPI HrAthGetFileName(OPENFILENAME *pofn, BOOL fOpen);
MIMEOLEAPI HrAthGetFileNameW(OPENFILENAMEW *pofn, BOOL fOpen);

// {53659CFE-AFA1-11d1-BE17-00C04FA31009}
DEFINE_GUID(CMDSETID_OESecurity, 0x53659cfe, 0xafa1, 0x11d1, 0xbe, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x10, 0x9);

#define OECSECCMD_ENCRYPTED     1
#define OECSECCMD_SIGNED        2

#endif //_MIMEOLEP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\error.h ===
//=================================================================================
// Thor Errors - HRESULTS that map to string resource Ids
// =================================================================================
#ifndef __ERROR_H
#define __ERROR_H

#ifndef S_TRUE
#define S_TRUE  S_OK
#endif

// =================================================================================
// Makes an Error HRESULT
// =================================================================================
#define ATH_HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)

// =================================================================================
// Makes a Success HRESULT
// =================================================================================
#define ATH_HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)

// =================================================================================
// Computes the String Resource Id of the HRESULT
// =================================================================================
#define HR_CODE(hr) (INT)(hr & 0xffff)

// =================================================================================
// HRESULT_BASE - Increment off of this base number if not using a resource string
// =================================================================================
// moved from 100 to 1000 to avoid conflicts with mimeole (t-erikne)
#define HR_FIRST 0x1000 // Put at the bottom

// =================================================================================
// HRESULTS - General
// =================================================================================
#define hrRasInitFailure                        ATH_HR_E(idshrRasInitFailure)
#define hrRasDialFailure                        ATH_HR_E(idshrRasDialFailure)
#define hrRasServerNotFound                     ATH_HR_E(idshrRasServerNotFound)
#define hrGetDialParamsFailed                   ATH_HR_E(idshrGetDialParamsFailed)
#define hrRasPasswordExpired                    ATH_HR_E(idshrRasPasswordExpired)
#define hrSetDialParamsFailed                   ATH_HR_E(idshrSetDialParamsFailed)
#define hrSicilyLogonFailed                     ATH_HR_E(idsErrSicilyLogonFailed)
#define hrFailedToLoadSicily                    ATH_HR_E(idsErrSicilyFailedToLoad)

// =================================================================================
// Non-String based HRESULTS
// =================================================================================
#define hrMemory                                E_OUTOFMEMORY
#define hrCharsetSyntax                         ATH_HR_E(HR_FIRST + 1)
#define hrCreateFile                            ATH_HR_E(HR_FIRST + 2)
#define hrLoadLibraryFailed                     ATH_HR_E(HR_FIRST + 3)
#define hrGetProcAddressFailed                  ATH_HR_E(HR_FIRST + 4)
#define hrCharSetDllGetDispatchTable            ATH_HR_E(HR_FIRST + 5)
#define hrFolderIsLocked                        ATH_HR_E(HR_FIRST + 6)
#define hrInvalidMimeMessage                    ATH_HR_E(HR_FIRST + 7)
#define hrCntListOutofSync                      ATH_HR_E(HR_FIRST + 8)
#define hrWriteFileFailed                       ATH_HR_E(HR_FIRST + 9)
#define hrUserCancel                            ATH_HR_E(HR_FIRST + 10)
#define hrInvalidParameter                      ATH_HR_E(HR_FIRST + 11)
#define hrBufferTooShort                        ATH_HR_E(HR_FIRST + 13)
#define hrIncompleteHeader                      ATH_HR_E(HR_FIRST + 14)
#define hrErrSplitMsg                           ATH_HR_E(HR_FIRST + 15)
#define hrInvalidAccount                        ATH_HR_E(HR_FIRST + 16)
#define hrInvalidPassword                       ATH_HR_E(HR_FIRST + 17)
#define hrPOP3ErrorResponse                     ATH_HR_E(HR_FIRST + 18)
#define hrSMTPRecipientsRejected                ATH_HR_E(HR_FIRST + 19)
#define hrWSAStartupFailed                      ATH_HR_E(HR_FIRST + 20)
#define hrWSAVerNotSupported                    ATH_HR_E(HR_FIRST + 21)
#define hrNoRecipients                          ATH_HR_E(HR_FIRST + 22)
#define hrNoSender                              ATH_HR_E(HR_FIRST + 23)
#define hrEmptySenderAddress                    ATH_HR_E(HR_FIRST + 24)
#define hrEmptyRecipientAddress                 ATH_HR_E(HR_FIRST + 25)
#define hrSMTPInvalidResponseCode               ATH_HR_E(HR_FIRST + 26)
#define hrXPNotOpen                             ATH_HR_E(HR_FIRST + 27)
#define hrInvalidMsgIndex                       ATH_HR_E(HR_FIRST + 28)
#define hrSetFilePointer                        ATH_HR_E(HR_FIRST + 29)
#define hrReadFile                              ATH_HR_E(HR_FIRST + 30)
#define hrWriteFile                             ATH_HR_E(HR_FIRST + 31)
#define hrDuplicateUidl                         ATH_HR_E(HR_FIRST + 32)
#define hrCantDeleteSpecialFolder               ATH_HR_E(HR_FIRST + 33)
#define hrCantRenameSpecialFolder               ATH_HR_E(HR_FIRST + 34)
#define hrFolderNameConflict                    ATH_HR_E(HR_FIRST + 35)
#define hrFileNameConflict                      ATH_HR_E(HR_FIRST + 36)
#define hrPasswordNotFound                      ATH_HR_E(HR_FIRST + 37)
#define hrBusy                                  ATH_HR_E(HR_FIRST + 38)
#define hrUnresolvedNames                       ATH_HR_E(HR_FIRST + 39)
#define hrUidlNotSupported                      ATH_HR_E(HR_FIRST + 40)
#define hrNoServers                             ATH_HR_E(HR_FIRST + 41)

// keep these in this order and contiguous
#define hrCorruptMessage                        ATH_HR_E(HR_FIRST + 42)
#define hrCorruptFolder                         ATH_HR_E(HR_FIRST + 43)
#define hrFolderDeleted                         ATH_HR_E(HR_FIRST + 44)
#define hrBlobVersionChanged                    ATH_HR_E(HR_FIRST + 45)
#define hrFolderDeletedIndex                    ATH_HR_E(HR_FIRST + 46)
// keep these in this order and contiguous

#define hrGeneralProtocolError                  ATH_HR_E(HR_FIRST + 50)
#define hrSMTP500SyntaxError                    ATH_HR_E(HR_FIRST + 51)
#define hrSMTP501ParameterSyntax                ATH_HR_E(HR_FIRST + 52)
#define hrSMTP502CommandNotImpl                 ATH_HR_E(HR_FIRST + 53)
#define hrSMTP503CommandSeq                     ATH_HR_E(HR_FIRST + 54)
#define hrSMTP504CommandParamNotImpl            ATH_HR_E(HR_FIRST + 55)
#define hrSMTP421NotAvailable                   ATH_HR_E(HR_FIRST + 56)
#define hrSMTP450MailboxBusy                    ATH_HR_E(HR_FIRST + 57)
#define hrSMTP550MailboxNotFound                ATH_HR_E(HR_FIRST + 58)
#define hrSMTP451ErrorProcessing                ATH_HR_E(HR_FIRST + 59)
#define hrSMTP551UserNotLocal                   ATH_HR_E(HR_FIRST + 60)
#define hrSMTP452NoSystemStorage                ATH_HR_E(HR_FIRST + 61)
#define hrSMTP552StorageOverflow                ATH_HR_E(HR_FIRST + 62)
#define hrSMTP553MailboxNameSyntax              ATH_HR_E(HR_FIRST + 63)
#define hrSMTP554TransactionFailed              ATH_HR_E(HR_FIRST + 64)
#define hrSMTPNotRecognized                     ATH_HR_E(HR_FIRST + 65)
#define hrSMTP211SystemStatus                   ATH_HR_S(HR_FIRST + 66)
#define hrSMTP214HelpMessage                    ATH_HR_S(HR_FIRST + 67)
#define hrSMTP220Ready                          ATH_HR_S(HR_FIRST + 68)
#define hrSMTP221Closing                        ATH_HR_S(HR_FIRST + 69)
#define hrSMTP250MailActionOkay                 ATH_HR_S(HR_FIRST + 70)
#define hrSMTP251ForwardingMail                 ATH_HR_S(HR_FIRST + 71)
#define hrSMTP354StartMailInput                 ATH_HR_S(HR_FIRST + 72)
#define hrNotConnected                          ATH_HR_E(HR_FIRST + 73)
#define hrDroppedConn                           ATH_HR_E(HR_FIRST + 74)
#define hrBtreeCorrupt                          ATH_HR_E(HR_FIRST + 75)
#define hrDisableOption                         ATH_HR_E(HR_FIRST + 76)
#define hrFolderIsInUseByOther                  ATH_HR_E(HR_FIRST + 77)
#define hrUnableToLoadWab32Dll                  ATH_HR_E(HR_FIRST + 78)
#define hrWabNotLoaded                          ATH_HR_E(HR_FIRST + 79)
#define hrTreeInsertDuplicate                   ATH_HR_E(HR_FIRST + 80)
#define hrBufferTooSmall                        ATH_HR_E(HR_FIRST + 81)
#define hrBufferTooLarge                        ATH_HR_E(HR_FIRST + 82)
#define hrGetPropsFailed                        ATH_HR_E(HR_FIRST + 83)
#define hrSetPropsFailed                        ATH_HR_E(HR_FIRST + 84)
#define hrNotFound                              ATH_HR_E(HR_FIRST + 85)
#define hrFolderNameTooLong                     ATH_HR_E(HR_FIRST + 86)
#define hrDiskFull                              ATH_HR_E(HR_FIRST + 87)
#define hrAlreadyConnected                      ATH_HR_E(HR_FIRST + 88)
#define hrInvalidState                          ATH_HR_E(HR_FIRST + 89)
#define hrConn                                  ATH_HR_E(HR_FIRST + 90)
#define hrConnRecv                              ATH_HR_E(HR_FIRST + 91)
#define hrConnSend                              ATH_HR_E(HR_FIRST + 92)
#define hrTooManyReplyTo                        ATH_HR_E(HR_FIRST + 93)
#define hrUnableToLoadMapi32Dll                 ATH_HR_E(HR_FIRST + 94)
#define hrIncomplete                            ATH_HR_E(HR_FIRST + 95)
#define hrAlreadyExists                         ATH_HR_E(HR_FIRST + 96)
#define hrHostLookupFailed                      ATH_HR_E(HR_FIRST + 97)
#define hrInvalidResponse                       ATH_HR_E(HR_FIRST + 98)
#define hrConnectFailed                         ATH_HR_E(HR_FIRST + 99)
#define hrWouldBlock                            ATH_HR_E(HR_FIRST + 100)
#define hrImportLoad                            ATH_HR_E(HR_FIRST + 101)
#define hrMailNotConfigured                     ATH_HR_E(HR_FIRST + 103)
#define hrInvalidFolderName                     ATH_HR_E(HR_FIRST + 104)
#define hrSwitchRasConnection                   ATH_HR_S(HR_FIRST + 105)
#define hrInvalidCertCN                         ATH_HR_E(HR_FIRST + 106)
#define hrInvalidCertDate                       ATH_HR_E(HR_FIRST + 107)

//#define hrRegCreateKeyFailed                    ATH_HR_E(HR_FIRST + 108)
#define hrRegQueryInfoKeyFailed                 ATH_HR_E(HR_FIRST + 109)
//#define hrBadFriendlyName                       ATH_HR_E(HR_FIRST + 110)
//#define hrInvalidPropTag                        ATH_HR_E(HR_FIRST + 111)
//#define hrPropNoData                            ATH_HR_E(HR_FIRST + 112)
//#define hrBufferSizeMismatch                    ATH_HR_E(HR_FIRST + 113)
//#define hrEnumFinished                          ATH_HR_S(HR_FIRST + 114)
//#define hrUnknownPropType                       ATH_HR_E(HR_FIRST + 115)    
//#define hrInvalidPropertySet                    ATH_HR_E(HR_FIRST + 116)
//#define hrRegSetValueFailed                     ATH_HR_E(HR_FIRST + 117)
#define hrRegOpenKeyFailed                      ATH_HR_E(HR_FIRST + 118)
//#define hrDuplicateAccountName                  ATH_HR_E(HR_FIRST + 119)
//#define hrPropOutOfRange                        ATH_HR_E(HR_FIRST + 120)
//#define hrPropInvalidBool                       ATH_HR_E(HR_FIRST + 121)
//#define hrNoAccounts                            ATH_HR_E(HR_FIRST + 122)
//#define hrRegDeleteKeyFailed                    ATH_HR_E(HR_FIRST + 123)
#define hrCantMoveFolderBetweenServers          ATH_HR_E(HR_FIRST + 122)
#define hrCantDeleteAllSubfolders               ATH_HR_E(HR_FIRST + 123)
#define hrCantDeleteFolderWithChildren          ATH_HR_E(HR_FIRST + 124)
#define hrCantMoveSpecialFolder                 ATH_HR_E(HR_FIRST + 125)
#define hrCantMoveIntoSubfolder                 ATH_HR_E(HR_FIRST + 126)

// Offline News Error Codes
#define HR_E_NOTINITIALIZED                     ATH_HR_E(HR_FIRST + 127)
#define HR_E_COULDNOTSTARTTHREAD                ATH_HR_E(HR_FIRST + 128)
#define HR_S_ACCOUNTNOTCONFIGURED               ATH_HR_S(HR_FIRST + 129)
#define HR_E_NOSUBSCRIBEDLIST                   ATH_HR_E(HR_FIRST + 130)
#define HR_E_QUEUEEMPTY                         ATH_HR_E(HR_FIRST + 131)
#define HR_E_COULDNOTFINDACCOUNT                ATH_HR_E(HR_FIRST + 132)
#define HR_E_COULDNOTINITSUBLIST                ATH_HR_E(HR_FIRST + 133)
#define HR_S_DOWNLOADCOMPLETE                   ATH_HR_S(HR_FIRST + 134)
#define HR_E_DOWNLOADCOMPLETE                   ATH_HR_E(HR_FIRST + 135)
#define hrNoSubject                             ATH_HR_E(HR_FIRST + 136)

// Connection Manager Error Codes
#define HR_E_ALREADYEXISTS                      ATH_HR_E(HR_FIRST + 137)
#define HR_S_RASNOTLOADED                       ATH_HR_S(HR_FIRST + 138)
#define HR_E_UNINITIALIZED                      ATH_HR_E(HR_FIRST + 139)
#define HR_E_OFFLINE                            ATH_HR_E(HR_FIRST + 140)
#define HR_E_USER_CANCEL_CONNECT                ATH_HR_E(HR_FIRST + 141)

// BEGIN another general section
#define hrEmptyDistList                         ATH_HR_E(HR_FIRST + 149)
#define hrBadRecipients                         ATH_HR_E(HR_FIRST + 150)
#define HR_S_NOOP                               ATH_HR_S(HR_FIRST + 151)
#define VIEW_E_NOCOLUMNS                        ATH_HR_E(HR_FIRST + 152)
#define VIEW_E_BADVERSION                       ATH_HR_E(HR_FIRST + 153)

#define HR_E_CONFIGURE_SERVER                   ATH_HR_E(HR_FIRST + 154)
#define HR_E_POST_WITHOUT_NEWS                  ATH_HR_E(HR_FIRST + 155)

// IMAP Error codes
#define hrIMAP_E_NoHierarchy                    ATH_HR_E(HR_FIRST + 300)
#define hrIMAP_E_OFFLINE                        ATH_HR_E(HR_FIRST + 301) // online op attempted while offline
#define hrIMAP_E_NoInferiors                    ATH_HR_E(HR_FIRST + 302)

// Security Error codes
#define HR_E_ATHSEC_NOCERTTOSIGN                ATH_HR_E(HR_FIRST + 400)
#define HR_E_ATHSEC_TRUSTFAILED                 ATH_HR_E(HR_FIRST + 401)
#define HR_E_ATHSEC_FAILED                      ATH_HR_E(HR_FIRST + 402)
#define HR_E_ATHSEC_CERTBEGONE                  ATH_HR_E(HR_FIRST + 403)
#define HR_E_ATHSEC_SAMEASSIGNED                ATH_HR_E(HR_FIRST + 404)
#define HR_E_ATHSEC_DONTSIGN                    ATH_HR_E(HR_FIRST + 405)
#define HR_E_ATHSEC_USENEWSIGN                  ATH_HR_E(HR_FIRST + 406)

// SafeOpen return codes
#define S_OPENFILE                              ATH_HR_S(HR_FIRST + 410)
#define S_SAVEFILE                              ATH_HR_S(HR_FIRST + 411)
#define S_READONLY                              ATH_HR_S(HR_FIRST + 412)

// Spell checking
#define HR_S_ABORT                              ATH_HR_S(HR_FIRST + 420)
#define HR_S_SPELLCANCEL                        ATH_HR_S(HR_FIRST + 421)

#define HR_S_BADURLSNOTATTACHED                 ATH_HR_S(HR_FIRST + 422)
#define HR_S_SPELLCONTINUE                      ATH_HR_S(HR_FIRST + 423)
#define HR_S_SPELLBREAK                         ATH_HR_S(HR_FIRST + 424)

// papyrus
#define PAPYRUS_PRESENT                         ATH_HR_E(HR_FIRST + 450)

// FolderCache error codes
#define hrFolderDoesNotExist                    ATH_HR_E(HR_FIRST + 500)
#define hrFolderHasNoChildren                   ATH_HR_E(HR_FIRST + 501)

#define E_NOT_ONLINE                            ATH_HR_E(HR_FIRST + 502)

#define S_PENDING                               ATH_HR_S(HR_FIRST + 503)
#define E_NOMORETASKS                           ATH_HR_E(HR_FIRST + 504)

#define HR_W_CACHEDELTED                        ATH_HR_S(HR_FIRST + 505)    // warning that the cached messages were delted
#define HR_S_OFFLINE                            ATH_HR_S(HR_FIRST + 506)

//Offline folder operation errors
#define HR_E_OFFLINE_FOLDER_CREATE              ATH_HR_E(HR_FIRST + 507)
#define HR_E_OFFLINE_FOLDER_MOVE                ATH_HR_E(HR_FIRST + 508)
#define HR_E_OFFLINE_FOLDER_RENAME              ATH_HR_E(HR_FIRST + 509)
#define HR_E_OFFLINE_FOLDER_DELETE              ATH_HR_E(HR_FIRST + 510)

#define HR_E_DIALING_INPROGRESS                 ATH_HR_E(HR_FIRST + 511)

#endif //__ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\macdupls.h ===
// -----------------------------------------------------------------------------
// macdupls.h
// 
// This file is used to map functions to Macintosh specific implementations.
// 
// Brian A. Moore - 4/28/97
// -----------------------------------------------------------------------------
#ifndef _MACDUPLS_H
#define _MACDUPLS_H
#ifdef MAC

// Need to make these functions unique
#define DebugStrf               Athena_DebugStrf
#define AssertSzFn              Athena_AssertSzFn
#define DllCanUnloadNow         Athena_DllCanUnloadNow

#define HinstDll                CryptDlg_HinstDll

// for functions in IMNXPORT.LIB
#define SzGetLocalPackedIP      Mac_SzGetLocalPackedIP   
#define SzGetLocalHostNameForID Mac_SzGetLocalHostNameForID
#define SzGetLocalHostName      Mac_SzGetLocalHostNameForID

// for some functions that are duplicated in Capone
#define MakeFileName        Athena_MakeFileName
#define StripUndesirables   Athena_StripUndesirables

// These are needed only for MLANG support and
// can be removed when MLANG is brought online.
typedef HRESULT (*PFMAC_BreakLineA)(LCID, UINT, const CHAR*, long, long, long*, long*);
typedef HRESULT (*PFMAC_BreakLineW)(LCID, const WCHAR*, long, long, long*, long*);

HRESULT MAC_BreakLineA(LCID locale, UINT uCodePage, const CHAR* pszSrc, long cchSrc,
                            long cMaxColumns, long* pcchLine, long* pcchSkip);
HRESULT MAC_BreakLineW(LCID locale, const WCHAR* pszSrc, long cchSrc,
                            long cMaxColumns, long* pcchLine, long* pcchSkip);
typedef struct _MAC_LineBreakConsole
{
    PFMAC_BreakLineA BreakLineA;
    PFMAC_BreakLineW BreakLineW;
} MAC_LineBreakConsole, * PMAC_LineBreakConsole;

STDAPI MAC_IsConvertINetStringAvailable(DWORD dwSrcEncoding, DWORD dwDstEncoding);
#define IsConvertINetStringAvailable    MAC_IsConvertINetStringAvailable

STDAPI MAC_ConvertINetString(LPDWORD lpdwMode, DWORD dwSrcEncoding, DWORD dwDstEncoding,
                    LPCSTR lpSrcStr, LPINT lpnSrcSize, LPSTR lpDstStr, LPINT lpnDstSize);
#define ConvertINetString    MAC_ConvertINetString

// for inetcomm\mimeole\vstream.cpp
#define VirtualAlloc(_a, _b, _c, _d)    malloc(_b)
#define VirtualFree(_a, _b, _c)         free(_a)

// for lack of CoRegisterClassObject support
#undef CoCreateInstance
STDAPI Athena_CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwContext,
							REFIID iid, LPVOID * ppv);
#define CoCreateInstance    Athena_CoCreateInstance
STDAPI Ares_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv);
STDAPI Athena_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv);
#define DllGetClassObject       Athena_DllGetClassObject

#include <mapinls.h>

// For WinNLS support
#ifndef MB_PRECOMPOSED
#define MB_PRECOMPOSED       0x00000001     /* use precomposed chars */
#endif  // !MB_PRECOMPOSED

EXTERN_C BOOL WINAPI MNLS_IsValidCodePage(UINT  uiCodePage);
#define IsValidCodePage     MNLS_IsValidCodePage

EXTERN_C BOOL WINAPI MNLS_IsDBCSLeadByteEx(UINT  uiCodePage, BYTE TestChar);
#define IsDBCSLeadByteEx    MNLS_IsDBCSLeadByteEx
#define IsDBCSLeadByte(_a)  MNLS_IsDBCSLeadByteEx(CP_ACP, (_a))

EXTERN_C int WINAPI MAC_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
		LPCSTR lpMultiByteStr, int cchMultiByte,
		LPWSTR lpWideCharStr, int cchWideChar);
#undef MultiByteToWideChar
#define MultiByteToWideChar MAC_MultiByteToWideChar

EXTERN_C int WINAPI MAC_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
	LPCWSTR lpWideCharStr, int cchWideChar,
	LPSTR lpMultiByteStr, int cchMultiByte,
	LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
#undef WideCharToMultiByte
#define WideCharToMultiByte MAC_WideCharToMultiByte

// For inetcomm\mapimime\cpropv.cpp
#define X_lstrcmpW lstrcmpW

// For inetcomm\mapimime\mapimime.cpp
#define CharNextExA(_a, _b, _c)         CharNext((_b))
#define CharPrevExA(_a, _b, _c, _d)     CharPrev((_b), (_c))

// For cryptdlg/select.cpp
STDAPI_(LPWSTR) PszDupW(LPCWSTR pcwszSource);
STDAPI_(LPWSTR) MNLS_lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
STDAPI_(int) MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);

#define wcslen(_a)          ((size_t)lstrlenW(_a))
#define _wcsdup             PszDupW
#define wcscpy              MNLS_lstrcpyW
#define wcscmp              MNLS_lstrcmpW
#define lstrcpyW            MNLS_lstrcpyW
#define wcscat(_a, _b)      CopyMemory(&((_a)[lstrlenW(_a)]), (_b), sizeof(WCHAR) * (lstrlenW(_b) + 1))
wchar_t * __cdecl WchCryptDlgWcsStr (const wchar_t * wcs1, const wchar_t * wcs2);
#define wcsstr              WchCryptDlgWcsStr

// For _splitpath support
#ifndef _MAX_EXT
#define _MAX_EXT    256
#endif  // !_MAX_EXT

// WinHelp patch
EXTERN_C BOOL ExchWinHelp(HWND hwndMain, LPCSTR szHelp, UINT uCommand, DWORD dwData);
#define WinHelpA    ExchWinHelp
#undef WinHelp
#define WinHelp     ExchWinHelp

// More support for SHLWAPI.H
STDAPI_(LPSTR)  MAC_PathFindExtension(LPCSTR pszPath);
STDAPI_(LPSTR)  MAC_PathFindFileName(LPCSTR pszPath);
STDAPI_(LPSTR)  MAC_StrFormatByteSize(DWORD dw, LPSTR szBuf, UINT uiBufSize);
STDAPI_(LPSTR)  Mac_StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch);
STDAPI_(LPSTR)  PszDupA(LPCSTR pcszSource);
STDAPI          MAC_UrlUnescapeA(LPSTR pszIn, LPSTR pszOut, LPDWORD pcchOut, DWORD dwFlags);

#define URL_DONT_ESCAPE_EXTRA_INFO      0x02000000
#define URL_DONT_UNESCAPE_EXTRA_INFO    URL_DONT_ESCAPE_EXTRA_INFO
#define URL_BROWSER_MODE                URL_DONT_ESCAPE_EXTRA_INFO
#define URL_UNESCAPE_INPLACE            0x00100000

#define StrChr              strchr
#define StrChrA             strchr
#define StrDupA             PszDupA
#define StrToInt            atoi
#define StrCmpNI            _strnicmp
#define StrCmpN             strncmp
#define StrStr              strstr
#define StrStrI             Mac_StrStrIA
#define StrCpyN             strncpy
#define StrFormatByteSize   MAC_StrFormatByteSize
#define PathFindExtension   MAC_PathFindExtension
#define PathFindFileName    MAC_PathFindFileName
#define UrlUnescapeA        MAC_UrlUnescapeA

// Support for URLMON.H
STDAPI MAC_CoInternetCombineUrl(LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags,          
                        LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved);                                   
#define CoInternetCombineUrl    MAC_CoInternetCombineUrl

// These are for functions in MSOERT
#define CchFileTimeToDateTimeSz     MAC_CchFileTimeToDateTimeSz

// For _int64 support with LARGE_INTEGER
#define QuadPart    BuildBreak

#endif  // MAC
#endif  //  !_MACDUPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\privunk.h ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __PRIVUNK_H
#define __PRIVUNK_H

// --------------------------------------------------------------------------------
// CPrivateUnknown
// --------------------------------------------------------------------------------
class CPrivateUnknown : public IUnknown
{
private:
    // ----------------------------------------------------------------------------
    // Embed default IUnknown handler
    // ----------------------------------------------------------------------------
    class CUnkInner : public IUnknown
    {
    private:
        LONG m_cRef;     // Private Ref Count

    public:
        // Construction
        CUnkInner(void) { m_cRef = 1; }

        // IUnknown Members
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);
    };

    friend class CUnkInner;

    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    CUnkInner           m_cUnkInner;      // Private Inner
    IUnknown           *m_pUnkOuter;      // points to _cUnkInner or aggregating IUnknown

protected:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPrivateUnknown(IUnknown *pUnkOuter);
    virtual ~CPrivateUnknown(void) {};

    // ----------------------------------------------------------------------------
    // This is the QueryInterface the aggregator implements
    // ----------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj) = 0;

public:
    // ----------------------------------------------------------------------------
    // This is the IUnknown that subclasses returns from their CreateInstance func
    // ----------------------------------------------------------------------------
    IUnknown* GetInner() { return &m_cUnkInner; }

    // ----------------------------------------------------------------------------
    // IUnknown Members
    // ----------------------------------------------------------------------------
    inline virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) {
        return m_pUnkOuter->QueryInterface(riid, ppvObj); }
    inline virtual STDMETHODIMP_(ULONG) AddRef(void) {
        return m_pUnkOuter->AddRef(); }
    inline virtual STDMETHODIMP_(ULONG) Release(void) {
        return m_pUnkOuter->Release(); }

    // ----------------------------------------------------------------------------
    // Public Utilities
    // ----------------------------------------------------------------------------
    void SetOuter(IUnknown *pUnkOuter);
};

#endif // __PRIVUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\migerror.h ===
// --------------------------------------------------------------------------------
// MigError.h
// --------------------------------------------------------------------------------
#ifndef __MIGERROR_H
#define __MIGERROR_H

// --------------------------------------------------------------------------------
// Macros
// --------------------------------------------------------------------------------
#ifndef FACILITY_INTERNET
#define FACILITY_INTERNET 12
#endif
#ifndef HR_E
#define HR_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_INTERNET, n)
#endif
#ifndef HR_S
#define HR_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_INTERNET, n)
#endif
#ifndef HR_CODE
#define HR_CODE(hr) (INT)(hr & 0xffff)
#endif

// --------------------------------------------------------------------------------
// Error HRESULTs
// --------------------------------------------------------------------------------
#define MIGRATE_E_REGOPENKEY                HR_E(100)
#define MIGRATE_E_REGQUERYVALUE             HR_E(101)
#define MIGRATE_E_EXPANDSTRING              HR_E(102)
#define MIGRATE_E_NOFILES                   HR_E(103)
#define MIGRATE_E_BADVERSION                HR_E(104)
#define MIGRATE_E_NOTNEEDED                 HR_E(105)
#define MIGRATE_E_CANTOPENFILE              HR_E(106)
#define MIGRATE_E_CANTGETFILESIZE           HR_E(107)
#define MIGRATE_E_CANTCREATEFILEMAPPING     HR_E(108)
#define MIGRATE_E_CANTMAPVIEWOFFILE         HR_E(109)
#define MIGRATE_E_BADCHAINSIGNATURE         HR_E(111)
#define MIGRATE_E_TOOMANYCHAINNODES         HR_E(112)
#define MIGRATE_E_BADMINCAPACITY            HR_E(113)
#define MIGRATE_E_CANTSETFILEPOINTER        HR_E(115)
#define MIGRATE_E_WRITEFILE                 HR_E(116)
#define MIGRATE_E_OUTOFRANGEADDRESS         HR_E(117)
#define MIGRATE_E_BADRECORDSIGNATURE        HR_E(118)
#define MIGRATE_E_BADSTREAMBLOCKSIGNATURE   HR_E(119)
#define MIGRATE_E_INVALIDIDXHEADER          HR_E(120)
#define MIGRATE_E_NOTENOUGHDISKSPACE        HR_E(121)
#define MIGRATE_E_BADRECORDFORMAT           HR_E(122)
#define MIGRATE_E_CANTCOPYFILE              HR_E(123)
#define MIGRATE_E_CANTSETENDOFFILE          HR_E(124)
#define MIGRATE_E_USERDATASIZEDIFF          HR_E(125)
#define MIGRATE_E_REGSETVALUE               HR_E(126)
#define MIGRATE_E_SHARINGVIOLATION          HR_E(127)

// --------------------------------------------------------------------------------
// Results Returned from oemig50.exe
// --------------------------------------------------------------------------------
#define MIGRATE_S_SUCCESS                   HR_S(800)
#define MIGRATE_E_NOCONTINUE                HR_E(801)
#define MIGRATE_E_CONTINUE                  HR_E(802)

#endif // __MIGERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\mirror.h ===
//
// Mirroring-Support APIs (astracted in \mailnews\lib\mirror\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

#ifdef USE_MIRRORING
BOOL  IsBiDiLocalizedSystem( void );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
LONG Mirror_EnableWindowLayoutInheritance( HWND hWnd );
LONG Mirror_DisableWindowLayoutInheritance( HWND hWnd );
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define IS_BIDI_LOCALIZED_SYSTEM()       IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()           Mirror_IsEnabledOS()
#define ENABLE_LAYOUT_INHERITANCE(hWnd)  Mirror_EnableWindowLayoutInheritance( hWnd )
#define DISABLE_LAYOUT_INHERITANCE(hWnd) Mirror_DisableWindowLayoutInheritance( hWnd )
#define IS_WINDOW_RTL_MIRRORED(hwnd)     (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)          (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)     (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()        (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)         Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)           Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()         Mirror_MirrorProcessRTL()
#define DONTMIRRORBITMAP                 dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW              dwExStyleRTLMirrorWnd
#define LAYOUT_PRESERVEBITMAP            dwPreserveBitmap

#else
#define IS_BIDI_LOCALIZED_SYSTEM()       FALSE
#define IS_MIRRORING_ENABLED()           FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)     FALSE
#define IS_DC_RTL_MIRRORED(hdc)          FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)     FALSE
#define IS_PROCESS_RTL_MIRRORED()        FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT()  
#define ENABLE_LAYOUT_INHERITANCE(hWnd)  0L
#define DISABLE_LAYOUT_INHERITANCE(hWnd) 0L  
#define DONTMIRRORBITMAP                 0L
#define RTL_MIRRORED_WINDOW              0L
#define LAYOUT_PRESERVEBITMAP            0L

// MirLibIsOS(): returns TRUE/FALSE if the platform is the indicated OS.
STDAPI_(BOOL) MirLibIsOS(DWORD dwOS);
#endif  // USE_MIRRROING

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\msoedbg.h ===
// --------------------------------------------------------------------------------
// Msoedbg.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MSOEDBG_H
#define __MSOEDBG_H

// --------------------------------------------------------------------------------
// Forwards
// --------------------------------------------------------------------------------
#ifdef __cplusplus
interface ILogFile;
#endif

// --------------------------------------------------------------------------------
// IF_DEBUG
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define IF_DEBUG(_block_) _block_
#else
#define IF_DEBUG(_block_)
#endif

// --------------------------------------------------------------------------------
// CRLF Definitions
// --------------------------------------------------------------------------------
#ifdef MAC
#define szCRLF  "\n\r"
#else   // !MAC
#define szCRLF  "\r\n"
#endif  // MAC

// --------------------------------------------------------------------------------
//
// "Normal" assertion checking.  Provided for compatibility with imported code.
// 
// Assert(a)        Displays a message indicating the file and line number
//                  of this Assert() if a == 0.
// 
// AssertSz(a,b)    As Assert(); also displays the message b (which should
//                  be a string literal.)
//
// SideAssert(a)    As Assert(); the expression a is evaluated even if 
//                  asserts are disabled.
//
// --------------------------------------------------------------------------------
#undef AssertSz
#undef Assert
#undef SideAssert

// --------------------------------------------------------------------------------
// We used to define the ASSERTDATA macro as storing the _szFile
// string.  However, that won't work when we have Assert()'s in
// pre-compiled header files.  We've changed this so that we
// define the _szFile for each assert.  However, other functions
// still use _szAssertFile such as the DEBUG PvAlloc(), HvAlloc(), etc.
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define ASSERTDATA                      static char _szAssertFile[]= __FILE__;
#define SideAssert(_exp)                Assert(_exp)
#define Assert(_exp)                    AssertSz(_exp, "Assert(" #_exp ")")
#else // DEBUG
#define ASSERTDATA
#define SideAssert(a)                   (void)(a)
#define Assert(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// IxpAssert - Used in internet transport code so as not to affect the message pump
// --------------------------------------------------------------------------------
#ifdef DEBUG
#ifndef _X86_
#define IxpAssert(a)   \
    if (!(a)) { \
        DebugBreak(); \
    } else
#else // _X86_
#define IxpAssert(a)   \
    if (!(a)) { \
        __asm { int 3 }; \
    } else
#endif // _X86_
#else
#define IxpAssert(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertSz - Assert with a message
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertSz(_exp, _msg)   \
    if (!(_exp)) { \
        static char _szFile[] = __FILE__; \
        AssertSzFn(_msg, _szFile, __LINE__); \
    } else
#else // DEBUG
#define AssertSz(a,b)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertFalseSz - Assert with a message
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertFalseSz(_msg)   \
    { \
        static char _szFile[] = __FILE__; \
        AssertSzFn(_msg, _szFile, __LINE__); \
    }
#else // DEBUG
#define AssertFalseSz(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// NFAssertSz - Non-Fatal Assert
// --------------------------------------------------------------------------------
#ifdef DEBUG
#ifndef NFAssertSz
#define NFAssertSz(_exp, _msg)  \
    if (!(_exp)) { \
        static char _szFile[] = __FILE__; \
        static char _szAssertMsg[] = _msg; \
        NFAssertSzFn(_szAssertMsg, _szFile, __LINE__); \
    } else
#endif
#else // DEBUG
#ifndef NFAssertSz
#define NFAssertSz(a,b)
#endif
#endif // DEBUG

// --------------------------------------------------------------------------------
// NYI - Net Yet Implemented
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define NYI(_msg)   \
    if (1) { \
        static char _szFnNYI[]= _msg; \
        static char _szNYI[]= "Not Implemented"; \
        AssertSzFn(_szFnNYI, _szNYI, __LINE__); \
    } else
#else // DEBUG
#define NYI(a)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertReadWritePtr - Assert can read and write cb from ptr
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertReadWritePtr(ptr, cb) \
    if (IsBadReadPtr(ptr, cb) && IsBadWritePtr(ptr, cb)) { \
        AssertSz(FALSE, "AssertReadWritePtr: Bad Pointer"); \
    } else
#else // DEBUG
#define AssertReadWritePtr(ptr, cb)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertReadPtr - Assert can read cb from ptr
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertReadPtr(ptr, cb) \
    if (IsBadReadPtr(ptr, cb)) { \
        AssertSz(FALSE, "AssertReadPtr: Bad Pointer"); \
    } else
#else // DEBUG
#define AssertReadPtr(ptr, cb)
#endif // DEBUG

// --------------------------------------------------------------------------------
// AssertWritePtr - Assert can write cb to ptr
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define AssertWritePtr(ptr, cb) \
    if (IsBadWritePtr(ptr, cb)) { \
        AssertSz(FALSE, "AssertWritePtr: Bad Pointer"); \
    } else
#else // DEBUG
#define AssertWritePtr(ptr, cb)
#endif // DEBUG

#ifdef DEBUG
#define AssertZeroMemory(ptr, cb) \
    if (1) { \
        for (DWORD _ib = 0; _ib < (cb); _ib++) { \
            Assert(((LPBYTE)(ptr))[_ib] == 0); } \
    } else
#else // DEBUG
#define AssertZeroMemory(ptr, cb)
#endif // DEBUG

// --------------------------------------------------------------------------------
// Debug Output Levels
// --------------------------------------------------------------------------------
#define DOUT_LEVEL1  1
#define DOUT_LEVEL2  2
#define DOUT_LEVEL3  4
#define DOUT_LEVEL4  8
#define DOUT_LEVEL5 16
#define DOUT_LEVEL6 32
#define DOUT_LEVEL7 64

// --------------------------------------------------------------------------------
// Defines for DOUTLL modules
// --------------------------------------------------------------------------------
#define DOUTL_DRAGDROP 1
#define DOUTL_ADDRBOOK 128
#define DOUTL_ATTMAN   256
#define DOUTL_CRYPT    1024

// --------------------------------------------------------------------------------
// CHECKHR - If hrExp FAILED, then Trap the Error (dbgout) and jump to exit label
// Caller must have a local variable named hr and a label named exit:.
// --------------------------------------------------------------------------------
#define CHECKHR(hrExp) \
    if (FAILED (hrExp)) { \
        TRAPHR(hr); \
        goto exit; \
    } else

#define IF_FAILEXIT(hrExp) \
    if (FAILED(hrExp)) { \
        TraceResult(hr); \
        goto exit; \
    } else

#define IF_FAILEXIT_LOG(_pLog, hrExp) \
    if (FAILED(hrExp)) { \
        TraceResultLog((_pLog), hr); \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// CHECKALLOC - If _palloc FAILED, then Trap E_OUTOFMEMORY (dbgout) and jump to 
// exit label. Caller must have a local variable named hr and a label named exit:.
// --------------------------------------------------------------------------------
#define CHECKALLOC(_palloc) \
    if (NULL == (_palloc)) { \
        hr = TRAPHR(E_OUTOFMEMORY); \
        goto exit; \
    } else

#define IF_NULLEXIT(_palloc) \
    if (NULL == (_palloc)) { \
        hr = TraceResult(E_OUTOFMEMORY); \
        goto exit; \
    } else

#define IF_NULLEXIT_LOG(_pLog, _palloc) \
    if (NULL == (_palloc)) { \
        hr = TraceResultLog((_pLog), E_OUTOFMEMORY); \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// CHECKEXP - If _expression is TRUE, then Trap _hresult (dbgout) and jump to 
// exit label. Caller must have a local variable named hr and a label named exit:.
// --------------------------------------------------------------------------------
#define CHECKEXP(_expression, _hresult) \
    if (_expression) { \
        hr = TrapError(_hresult); \
        goto exit; \
    } else

#define IF_TRUEEXIT(_expression, _hresult) \
    if (_expression) { \
        hr = TraceResult(_hresult); \
        goto exit; \
    } else

#define IF_FALSEEXIT(_expression, _hresult) \
    if (FALSE == _expression) { \
        hr = TraceResult(_hresult); \
        goto exit; \
    } else

// --------------------------------------------------------------------------------
// TRACEMACROTYPE
// --------------------------------------------------------------------------------
typedef enum tagTRACEMACROTYPE {
    TRACE_INFO,
    TRACE_CALL,
    TRACE_RESULT
} TRACEMACROTYPE;

// --------------------------------------------------------------------------------
// These Traces are for c++ only
// --------------------------------------------------------------------------------
typedef DWORD SHOWTRACEMASK;
#define SHOW_TRACE_NONE     0x00000000
#define SHOW_TRACE_INFO     0x00000001
#define SHOW_TRACE_CALL     0x00000002
#define SHOW_TRACE_ALL      0xffffffff

// --------------------------------------------------------------------------------
// These Traces are for c++ only
// --------------------------------------------------------------------------------
#if defined(__cplusplus)

// --------------------------------------------------------------------------------
// TRACELOGINFOINFO
// --------------------------------------------------------------------------------
typedef struct tagTRACELOGINFO {
    SHOWTRACEMASK       dwMask;
    ILogFile           *pLog;
} TRACELOGINFO, *LPTRACELOGINFO;

// --------------------------------------------------------------------------------
// DebugTraceEx
// --------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C HRESULT DebugTraceEx(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, LPTRACELOGINFO pLog,
    HRESULT hr, LPSTR pszFile, INT nLine, LPCSTR pszMsg, LPCSTR pszFunc);

EXTERN_C DWORD GetDebugTraceTagMask(LPCSTR pszTag, SHOWTRACEMASK dwDefaultMask);
#endif

// --------------------------------------------------------------------------------
// TraceCall(_pszFunc)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCall(_pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceCall(_pszFunc) DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceCall(_pszFunc)
#endif

// --------------------------------------------------------------------------------
// TraceCallLog(_pszFunc)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallLog(_pLog, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceCallLog(_pLog, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceCallLog(_pLog, _pszFunc)
#endif

// --------------------------------------------------------------------------------
// TraceCallTag(_pszFunc)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallTag(_dwMask, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceCallTag(_dwMask, _pszFunc) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceCallTag(_dwMask, _pszFunc)
#endif

// --------------------------------------------------------------------------------
// TraceCallSz(_pszFunc, _pszMsg)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallSz(_pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceCallSz(_pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceCallSz(_pszFunc, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceCallLogSz(_pLog, _pszFunc, _pszMsg)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallLogSz(_pLog, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceCallLogSz(_pLog, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(SHOW_TRACE_ALL, TRACE_CALL, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceCallLogSz(_pLog, _pszFunc, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceCallTagSz(_dwMask, _pszFunc, _pszMsg)
// -------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceCallTagSz(_dwMask, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceCallTagSz(_dwMask, _pszFunc, _pszMsg) LPCSTR _pszfn = _pszFunc; DebugTraceEx(_dwMask, TRACE_CALL, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceCallTagSz(_dwMask, _pszFunc, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceInfo(_pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfo(_pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceInfo(_pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceInfo(_pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceInfoAssert(_exp, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn);	\
    } else
#else
#define TraceInfoAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL);	\
    } else
#endif
#else
#define TraceInfoAssert(_exp, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceInfoSideAssert(_exp, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoSideAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn);	\
    } else
#else
#define TraceInfoSideAssert(_exp, _pszMsg)	\
    if (!(_exp)) { \
		DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL);	\
    } else
#endif
#else
#define TraceInfoSideAssert(_exp, _pszMsg)	(void)(_exp)
#endif

// --------------------------------------------------------------------------------
// TraceInfoLog(_pLog, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoLog(_pLog, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceInfoLog(_pLog, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_INFO, _pLog, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceInfoLog(_pLog, _pszMsg) ((_pLog && _pLog->pLog) ? _pLog->pLog->TraceLog((_pLog)->dwMask, TRACE_INFO, __LINE__, S_OK, _pszMsg) : (void)0)
#endif

// --------------------------------------------------------------------------------
// TraceInfoTag(_dwMask, _pszMsg)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceInfoTag(_dwMask, _pszMsg) DebugTraceEx(_dwMask, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceInfoTag(_dwMask, _pszMsg) DebugTraceEx(_dwMask, TRACE_INFO, NULL, S_OK, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceInfoTag(_dwMask, _pszMsg)
#endif

// --------------------------------------------------------------------------------
// TraceError(_hrResult)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceError(_hrResult) \
    if (FAILED(_hrResult)) {                                                                            \
        DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, _pszfn);  \
    }                                                                                                   \
    else
#else
#define TraceError(_hrResult) \
    if (FAILED(_hrResult)) {                                                                            \
        DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, NULL);    \
    }                                                                                                   \
    else
#endif // defined(MSOEDBG_TRACECALLS)
#else
#define TraceError(_hrResult) _hrResult
#endif // defined(DEBUG)

// --------------------------------------------------------------------------------
// TraceResult(_hrResult)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResult(_hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceResult(_hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceResult(_hrResult) _hrResult
#endif

// --------------------------------------------------------------------------------
// TraceResultLog(_pLog, _hrResult)
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResultLog(_pLog, _hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, NULL, _pszfn)
#else
#define TraceResultLog(_pLog, _hrResult) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, NULL, NULL)
#endif
#else
#define TraceResultLog(_pLog, _hrResult) ((_pLog && _pLog->pLog) ? _pLog->pLog->TraceLog((_pLog)->dwMask, TRACE_RESULT, __LINE__, _hrResult, NULL) : _hrResult)
#endif

// --------------------------------------------------------------------------------
// TraceResultSz(_hrResult, _pszMsg) - Use to log HRESULTs
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResultSz(_hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceResultSz(_hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, NULL, _hrResult, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceResultSz(_hrResult, _pszMsg) _hrResult
#endif

// --------------------------------------------------------------------------------
// TraceResultLogSz(_pLog, _hrResult, _pszMsg) - Use to log HRESULTs
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#if defined(MSOEDBG_TRACECALLS)
#define TraceResultLogSz(_pLog, _hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, _pszMsg, _pszfn)
#else
#define TraceResultLogSz(_pLog, _hrResult, _pszMsg) DebugTraceEx(SHOW_TRACE_ALL, TRACE_RESULT, _pLog, _hrResult, __FILE__, __LINE__, _pszMsg, NULL)
#endif
#else
#define TraceResultLogSz(_pLog, _hrResult, _pszMsg) ((_pLog && _pLog->pLog) ? _pLog->pLog->TraceLog((_pLog)->dwMask, TRACE_RESULT, __LINE__, _hrResult, _pszMsg) : _hrResult)
#endif

// --------------------------------------------------------------------------------
// TraceAssert(_exp, _msg) - Performs an assertSz() and TraceInfo
// --------------------------------------------------------------------------------
#if defined(DEBUG)
#define TraceAssert(_exp, _msg) \
    if (!(_exp)) { \
        TraceInfo(_msg); \
        static char _szFile[] = __FILE__; \
        AssertSzFn((char*) _msg, _szFile, __LINE__); \
    } else
#else
#define TraceAssert(_exp, _msg) 
#endif

#endif // #if defined(__cplusplus)

// --------------------------------------------------------------------------------
// DOUT External Values
// --------------------------------------------------------------------------------
#ifdef DEBUG
extern DWORD dwDOUTLevel;
extern DWORD dwDOUTLMod;
extern DWORD dwDOUTLModLevel;
extern DWORD dwATLTraceLevel;
#endif // DEBUG

#if !defined( WIN16 ) || defined( __cplusplus )

// --------------------------------------------------------------------------------
// DOUTLL
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl DOUTLL(int iModule, int iLevel, LPSTR szFmt, ...) {
    if((iModule & dwDOUTLMod) && (iLevel & dwDOUTLModLevel)) {
        CHAR ach[MAX_PATH];
        va_list arglist;
        va_start(arglist, szFmt);
        wvsprintf(ach, szFmt, arglist);
        va_end(arglist);
        lstrcat(ach, szCRLF);
        OutputDebugString(ach);
    }
}
#else
#define DOUTLL  1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// vDOUTL
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void vDOUTL(int iLevel, LPSTR szFmt, va_list arglist) {
    if (iLevel & dwDOUTLevel) {
        CHAR ach[MAX_PATH];
        wvsprintf(ach, szFmt, arglist);
        lstrcat(ach, szCRLF);
        OutputDebugString(ach);
    }
}
#else
#define vDOUTL  1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// DOUTL
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl DOUTL(int iLevel, LPSTR szFmt, ...) {
    va_list arglist;
    va_start(arglist, szFmt);
    vDOUTL(iLevel, szFmt, arglist);
    va_end(arglist);
}
#else
#define DOUTL   1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// vDOUT
// --------------------------------------------------------------------------------
#ifdef DEBUG
_inline void vDOUT(LPSTR szFmt, va_list arglist) {
    if (DOUT_LEVEL1 & dwDOUTLevel) {
        CHAR ach[MAX_PATH];
        wvsprintf(ach, szFmt, arglist);
        lstrcat(ach, szCRLF);
        OutputDebugString(ach);
    }
}
#else
#define vDOUT   1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// OEAtlTrace - This is just like vDOUT except it doesn't add the crlf at the end.
//              It also has a different flag for turning off just the ATL output.
// --------------------------------------------------------------------------------
#ifdef DEBUG
_inline void OEAtlTrace(LPSTR szFmt, va_list arglist) {
    if (DOUT_LEVEL1 & dwATLTraceLevel) {
        CHAR ach[MAX_PATH];
        wvsprintf(ach, szFmt, arglist);
        OutputDebugString(ach);
    }
}
#else
#define OEAtlTrace   1 ? (void)0 : (void)
#endif // DEBUG

// --------------------------------------------------------------------------------
// OEATLTRACE
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl OEATLTRACE(LPSTR szFmt, ...) {
    va_list arglist;
    va_start(arglist, szFmt);
    OEAtlTrace(szFmt, arglist);
    va_end(arglist);
}
#else
#define OEATLTRACE    1 ? (void)0 : (void)
#endif // DEBUG


// --------------------------------------------------------------------------------
// DOUT
// --------------------------------------------------------------------------------
#ifdef DEBUG
__inline void __cdecl DOUT(LPSTR szFmt, ...) {
    va_list arglist;
    va_start(arglist, szFmt);
    vDOUT(szFmt, arglist);
    va_end(arglist);
}
#else
#define DOUT    1 ? (void)0 : (void)
#endif // DEBUG

#define TRACE DOUT
#endif //!def(WIN16) || def(__cplusplus)

// --------------------------------------------------------------------------------
// DOUT Functions implemented in msoert2.dll - debug.c
// --------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C __cdecl DebugStrf(LPTSTR lpszFormat, ...);
EXTERN_C HRESULT HrTrace(HRESULT hr, LPSTR lpszFile, INT nLine);
#endif

// --------------------------------------------------------------------------------
// DebugTrace
// --------------------------------------------------------------------------------
#ifdef DEBUG
#ifndef DebugTrace
#define DebugTrace DebugStrf
#endif
#else
#ifndef DebugTrace
#define DebugTrace 1 ? (void)0 : (void)
#endif
#endif // DEBUG

// --------------------------------------------------------------------------------
// TrapError
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define TrapError(_hresult) HrTrace(_hresult, __FILE__, __LINE__)
#else
#define TrapError(_hresult) _hresult
#endif // DEBUG

// --------------------------------------------------------------------------------
// TRAPHR
// --------------------------------------------------------------------------------
#ifdef DEBUG
#define TRAPHR(_hresult)    HrTrace(_hresult, __FILE__, __LINE__)
#else
#define TRAPHR(_hresult)    _hresult
#endif // DEBUG

// --------------------------------------------------------------------------------
// Assert Functions implemented in msoedbg.lib
// --------------------------------------------------------------------------------
#ifdef DEBUG
EXTERN_C void AssertSzFn(LPSTR, LPSTR, int);
EXTERN_C void NFAssertSzFn(LPSTR, LPSTR, int);
#endif // DEBUG


#endif // __MSOEDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\msoeopt.h ===
#ifndef _INC_MSOEOPT_H
#define _INC_MSOEOPT_H

#include <msoeprop.h>

interface IOptionBucketEx;

// {ED5EE630-5BA4-11d1-AA16-006097D474C4}
DEFINE_GUID(IID_IOptionBucketNotify, 0xed5ee630, 0x5ba4, 0x11d1, 0xaa, 0x16, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

interface IOptionBucketNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoNotification(IOptionBucketEx *pBckt, HWND hwnd, PROPID id) = 0;
    };

MSOEACCTAPI CreatePropertyBucket(IPropertyBucket **ppPropBckt);

typedef HRESULT (CALLBACK *PFNVALIDPROP)(PROPID, LPCPROPVARIANT);

typedef struct tagOPTIONINFO
    {
    PROPID id;
    VARTYPE vt;
    int iszRegKey;      // index into rgpszRegKey
    LPCSTR pszRegValue;
    LPCSTR pszDef;
    int cbDefBinary;    // if pszDef points to a binary struct, this is the size
    DWORD dwMin;
    DWORD dwMax;
    PFNVALIDPROP pfnValid;
    } OPTIONINFO;

typedef const OPTIONINFO *LPCOPTIONINFO;

// {4091C7B0-5557-11d1-AA13-006097D474C4}
DEFINE_GUID(IID_IOptionBucketEx, 0x4091c7b0, 0x5557, 0x11d1, 0xaa, 0x13, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// flags for ISetProperty
#define SP_DONOTIFY     0x0001

typedef struct tagOPTBCKTINIT
    {
    LPCOPTIONINFO rgInfo;
    int cInfo;

    HKEY hkey;
    LPCSTR pszRegKeyBase;
    LPCSTR *rgpszRegSubKey;
    int cszRegKey;
    } OPTBCKTINIT, *LPOPTBCKTINIT;
typedef const OPTBCKTINIT *LPCOPTBCKTINIT;

// implemented by athena
// used by options and accounts
interface IOptionBucketEx : public IOptionBucket
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(LPCOPTBCKTINIT pInit) = 0;
        virtual HRESULT STDMETHODCALLTYPE ISetProperty(HWND hwnd, LPCSTR pszProp, LPCPROPVARIANT pVar, DWORD dwFlags) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetNotification(IOptionBucketNotify *pNotify) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnableNotification(BOOL fEnable) = 0;

        virtual LONG STDMETHODCALLTYPE GetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD *ptype, LPBYTE pb, DWORD *pcb) = 0;
        virtual LONG STDMETHODCALLTYPE SetValue(LPCSTR szSubKey, LPCSTR szValue, DWORD type, LPBYTE pb, DWORD cb) = 0;
    };

MSOEACCTAPI CreateOptionBucketEx(IOptionBucketEx **ppOptBcktEx);

#ifdef DEAD
// IDisplayOption::SetOption flags
#define SETOPTION_DISABLE   0x0001
#define SETOPTION_HIDE      0x0002

// {EC320F22-4B33-11d1-AA10-006097D474C4}
DEFINE_GUID(IID_IDisplayOptions, 0xec320f22, 0x4b33, 0x11d1, 0xaa, 0x10, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// implemented by athena
interface IDisplayOptions : public IOptionBucket
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InsertPage(HPROPSHEETPAGE hpage, DWORD dwBeforePageID, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE RemovePage(DWORD dwPageID, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetOption(PROPID id, DWORD dwFlags) = 0;
    };

// {EC320F23-4B33-11d1-AA10-006097D474C4}
DEFINE_GUID(IID_IOptionsExtension, 0xec320f23, 0x4b33, 0x11d1, 0xaa, 0x10, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// implemented by externals
interface IOptionsExtension : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayOptions(HWND hwndParent, IOptionBucket *pCont, DWORD dwReserved) = 0;
        virtual HRESULT STDMETHODCALLTYPE InitializeOptions(IDisplayOptions *pOpt, DWORD dwReserved) = 0;
    };

interface IAccount;

// {EC320F24-4B33-11d1-AA10-006097D474C4}
DEFINE_GUID(IID_IAccountExtension, 0xec320f24, 0x4b33, 0x11d1, 0xaa, 0x10, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

// implemented by externals
interface IAccountExtension : public IOptionsExtension
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NewAccountWizard(HWND hwndParent, IAccount *pAcctNew) = 0;
    };

#endif // DEAD

#endif // _INC_MSOEOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\msoert.h ===
// --------------------------------------------------------------------------------
// Msoert.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Debug Crap
// --------------------------------------------------------------------------------
#include "msoedbg.h"

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
#if !defined(__MSOERT_H) || defined(INITGUID)

// {220D5CC1-853A-11d0-84BC-00C04FD43F8F}
#ifdef ENABLE_RULES
DEFINE_GUID(PST_IDENT_TYPE_GUID, 0x220d5cc3, 0x853a, 0x11d0, 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#elif defined(N_TEST)
DEFINE_GUID(PST_IDENT_TYPE_GUID, 0x220d5cc2, 0x853a, 0x11d0, 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#else
DEFINE_GUID(PST_IDENT_TYPE_GUID, 0x220d5cc1, 0x853a, 0x11d0, 0x84, 0xbc, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#endif

// {417E2D75-84BD-11d0-84BB-00C04FD43F8F}
#ifdef ENABLE_RULES
DEFINE_GUID(PST_IMNACCT_SUBTYPE_GUID, 0x417e2d77, 0x84bd, 0x11d0, 0x84, 0xbb, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#elif defined(N_TEST)
DEFINE_GUID(PST_IMNACCT_SUBTYPE_GUID, 0x417e2d76, 0x84bd, 0x11d0, 0x84, 0xbb, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#else
DEFINE_GUID(PST_IMNACCT_SUBTYPE_GUID, 0x417e2d75, 0x84bd, 0x11d0, 0x84, 0xbb, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);
#endif

// {6ADF2E20-8803-11d0-84BF-00C04FD43F8F}
DEFINE_GUID(PST_CERTS_SUBTYPE_GUID, 0x6adf2e20, 0x8803, 0x11d0, 0x84, 0xbf, 0x0, 0xc0, 0x4f, 0xd4, 0x3f, 0x8f);

#endif // !defined(__MSOERT_H) || defined(INITGUID)

// --------------------------------------------------------------------------------
// Include the rest of the stuff
// --------------------------------------------------------------------------------
#ifndef __MSOERT_H
#define __MSOERT_H


// --------------------------------------------------------------------------------
// Define API decoration for direct importing of DLL references.
// --------------------------------------------------------------------------------

// OESTDAPI - Things exported from msoert2.dll (no debug exports)
#if !defined(_MSOERT_)
    #define OESTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else   // _MSOERT_
    #define OESTDAPI_(type)   STDAPI_(type)
#endif  // !_MSOERT_

#define DLLEXPORT   __declspec(dllexport)

#ifndef NOFLAGS
#define NOFLAGS 0
#endif

// --------------------------------------------------------------------------------
// IN OUT OPTIONS Definitions
// --------------------------------------------------------------------------------
#ifndef OUT
#define OUT
#endif

#ifndef IN
#define IN
#endif

#ifndef IN_OUT
#define IN_OUT
#endif

#ifndef IN_OPT
#define IN_OPT
#endif

#ifndef OUT_OPT
#define OUT_OPT
#endif

#ifndef IN_OUT_OPT
#define IN_OUT_OPT
#endif

//WIn64 macros
#ifdef _WIN64
#if defined (_AMD64_) || defined (_IA64_)
#define ALIGNTYPE			LARGE_INTEGER
#else
#define ALIGNTYPE			DWORD
#endif
#define	ALIGN				((ULONG) (sizeof(ALIGNTYPE) - 1))
#define LcbAlignLcb(lcb)	(((lcb) + ALIGN) & ~ALIGN)
#define PbAlignPb(pb)		((LPBYTE) ((((DWORD) (pb)) + ALIGN) & ~ALIGN))
#define	MYALIGN				((POINTER_64_INT) (sizeof(ALIGNTYPE) - 1))
#define MyPbAlignPb(pb)		((LPBYTE) ((((POINTER_64_INT) (pb)) + MYALIGN) & ~MYALIGN))
#else //!WIN64
#define LcbAlignLcb(lcb)	(lcb)
#define PbAlignPb(pb)		(pb)
#define MyPbAlignPb(pb)		(pb)
#endif 

// --------------------------------------------------------------------------------
// CRLF Definitions
// --------------------------------------------------------------------------------
#define wchCR   L'\r'
#define wchLF   L'\n'
#define chCR    '\r'
#define chLF    '\n'
#define szCRLF  "\r\n"

// --------------------------------------------------------------------------------
// Versioning Magic
// --------------------------------------------------------------------------------
typedef enum tagOEDLLVERSION {
    OEDLL_VERSION_5=1
} OEDLLVERSION;

#define OEDLL_VERSION_CURRENT OEDLL_VERSION_5
#define STR_GETDLLMAJORVERSION "GetDllMajorVersion"
typedef OEDLLVERSION (APIENTRY *PFNGETDLLMAJORVERSION)(void);

// --------------------------------------------------------------------------------
// RGB_AUTOCOLOR
// --------------------------------------------------------------------------------
#define RGB_AUTOCOLOR       ((COLORREF)-1)

// --------------------------------------------------------------------------------
// NEXTID
// --------------------------------------------------------------------------------
#define NEXTID(pidl)    ((LPITEMIDLIST)(((BYTE *)(pidl))+(pidl)->mkid.cb))
#define PAD4(x)         (((x)+3)&~3)

// --------------------------------------------------------------------------------
// INLINE
// --------------------------------------------------------------------------------
#ifdef INLINE
    #error define overlap
#else
// speed up debug build by turning off inline functions
    #ifdef DEBUG
        #define INLINE
    #else
        #define INLINE inline
    #endif
#endif

// --------------------------------------------------------------------------------
// IS_EXTENDED
// --------------------------------------------------------------------------------
#define IS_EXTENDED(ch) \
    ((ch > 126 || ch < 32) && ch != '\t' && ch != '\n' && ch != '\r')

// --------------------------------------------------------------------------------
// Flag Utility Functions
// --------------------------------------------------------------------------------
#define FLAGSET(_dw, _f)             do {_dw |= (_f);} while (0)
#define FLAGTOGGLE(_dw, _f)          do {_dw ^= (_f);} while (0)
#define FLAGCLEAR(_dw, _f)           do {_dw &= ~(_f);} while (0)
#define ISFLAGSET(_dw, _f)           (BOOL)(((_dw) & (_f)) == (_f))
#define ISFLAGCLEAR(_dw, _f)         (BOOL)(((_dw) & (_f)) != (_f))

// --------------------------------------------------------------------------------
// Used for building an IDataObject format enumerator
// --------------------------------------------------------------------------------
#define SETDefFormatEtc(fe, cf, med) {\
    (fe).cfFormat = ((CLIPFORMAT) (cf)); \
    (fe).dwAspect = DVASPECT_CONTENT; \
    (fe).ptd = NULL; \
    (fe).tymed = med; \
    (fe).lindex = -1; \
}

// --------------------------------------------------------------------------------
// Some defines to create bit fields easier
// --------------------------------------------------------------------------------
#define FLAG01 0x00000001
#define FLAG02 0x00000002
#define FLAG03 0x00000004
#define FLAG04 0x00000008
#define FLAG05 0x00000010
#define FLAG06 0x00000020
#define FLAG07 0x00000040
#define FLAG08 0x00000080
#define FLAG09 0x00000100
#define FLAG10 0x00000200
#define FLAG11 0x00000400
#define FLAG12 0x00000800
#define FLAG13 0x00001000
#define FLAG14 0x00002000
#define FLAG15 0x00004000
#define FLAG16 0x00008000
#define FLAG17 0x00010000
#define FLAG18 0x00020000
#define FLAG19 0x00040000
#define FLAG20 0x00080000
#define FLAG21 0x00100000
#define FLAG22 0x00200000
#define FLAG23 0x00400000
#define FLAG24 0x00800000
#define FLAG25 0x01000000
#define FLAG26 0x02000000
#define FLAG27 0x04000000
#define FLAG28 0x08000000
#define FLAG29 0x10000000
#define FLAG30 0x20000000
#define FLAG31 0x40000000
#define FLAG32 0x80000000

// --------------------------------------------------------------------------------
// Support Inclusion into a C file
// --------------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------------
// Common String Lengths
// --------------------------------------------------------------------------------
#define cchMaxDate  64
#define cchMaxTime  22

// --------------------------------------------------------------------------------
// ARRAYSIZE - Don't use this on extern'ed global data structures, it won't work
// --------------------------------------------------------------------------------
#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

// --------------------------------------------------------------------------------
// HANDLE_COMMAND - Used in a WindowProc to simplify handling of WM_COMMAND messages
// --------------------------------------------------------------------------------
#define HANDLE_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
                case (id): { (fn)((HWND)(hwnd), (HWND)(hwndCtl), (UINT)(codeNotify)); break; }

// --------------------------------------------------------------------------------
// Standard Boolean Constants
// --------------------------------------------------------------------------------
#define fFalse          ((BOOL) 0)
#define fTrue           ((BOOL) 1)

// --------------------------------------------------------------------------------
// Storage class macros
// --------------------------------------------------------------------------------
#ifdef _X86_
#define BEGIN_CODESPACE_DATA data_seg(".rdata")
#define BEGIN_NAME_CODESPACE_DATA(a) data_seg(".rdata$"#a, ".rdata")
#define BEGIN_FUNCTION_CODESPACE_DATA data_seg(".rdata")
#define END_CODESPACE_DATA data_seg()
#define BEGIN_NAME_DATA(a) data_seg(".data$"#a, ".data")
#define END_NAME_DATA data_seg()
#else
#define BEGIN_FUNCTION_CODESPACE_DATA
#define BEGIN_NAME_CODESPACE_DATA(a)
#define BEGIN_CODESPACE_DATA
#define END_CODESPACE_DATA
#define BEGIN_NAME_DATA(a)
#define END_NAME_DATA
#endif

// --------------------------------------------------------------------------------
// Macro that causes the compiler to ignore a local variable or
// parameter without generating a warning.
// --------------------------------------------------------------------------------
#ifndef Unreferenced
#define Unreferenced(a)         ((void)a)
#endif

// --------------------------------------------------------------------------------
// SAFECAST - Insures that a cast is valid, otherwise it won't compile
// --------------------------------------------------------------------------------
#define SAFECAST(_src, _type) (((_type)(_src)==(_src)?0:0), (_type)(_src))
// --------------------------------------------------------------------------------
// Computes the size of a member in a structure
// --------------------------------------------------------------------------------
#define sizeofMember(s,m)       sizeof(((s *)0)->m)

#if 0

// --------------------------------------------------------------------------------
// Computes the byte offset to the parent class from a nested class
// --------------------------------------------------------------------------------
#define _OEOffset(class, itf)         ((UINT)&(((class *)0)->itf))

// --------------------------------------------------------------------------------
// Computes the parent interface of a nested class
// --------------------------------------------------------------------------------
/------------------Merge Conflict------------------\
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_OEOffset(class, itf)))
#endif

// --------------------------------------------------------------------------------
// SafeReleaseCnt - SafeRelease and set ulCount to the after release ref count
// --------------------------------------------------------------------------------
#define SafeReleaseCnt(_object, _refcount) \
    if (_object) { \
        (_refcount) = (_object)->Release (); \
        (_object) = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeRelease - Releases an object and sets the object to NULL
// --------------------------------------------------------------------------------
#define SafeRelease(_object) \
    if (_object) { \
        (_object)->Release(); \
        (_object) = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeFreeLibrary - Checks if _hinst is non null and then calls FreeLibrary
// --------------------------------------------------------------------------------
#define SafeFreeLibrary(_hinst) \
    if (_hinst) { \
        FreeLibrary(_hinst); \
        _hinst = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeCloseHandle
// --------------------------------------------------------------------------------
#define SafeCloseHandle(_handle) \
    if (_handle) { \
        CloseHandle(_handle); \
        _handle = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeUnmapViewOfFile
// --------------------------------------------------------------------------------
#define SafeUnmapViewOfFile(_pView) \
    if (_pView) { \
        UnmapViewOfFile((LPVOID)_pView); \
        _pView = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafePidlFree
// --------------------------------------------------------------------------------
#define SafePidlFree(_pidl) \
    if (_pidl) { \
        PidlFree(_pidl); \
        _pidl = NULL; \
    } else

// --------------------------------------------------------------------------------
// SafeInternetCloseHandle
// --------------------------------------------------------------------------------
#define SafeInternetCloseHandle(_handle) \
        if (_handle) { \
                InternetCloseHandle(_handle); \
                _handle = NULL; \
        } else

// --------------------------------------------------------------------------------
// SafeDelete - safely deletes a non-referenced counted object
// --------------------------------------------------------------------------------
#define SafeDelete(_obj) \
        if (_obj) { \
                delete _obj; \
                _obj = NULL; \
        } else

// --------------------------------------------------------------------------------
// ReleaseObj - Releases an Object if it is not NULL
// --------------------------------------------------------------------------------
#ifndef ReleaseObj
#ifdef __cplusplus
#define ReleaseObj(_object)   (_object) ? (_object)->Release() : 0
#else
#define ReleaseObj(_object)   (_object) ? (_object)->lpVtbl->Release(_object) : 0
#endif // __cplusplus
#endif

// --------------------------------------------------------------------------------
// SafeSysFreeString - Frees a bstr if not NULL
// --------------------------------------------------------------------------------
#define SafeSysFreeString(_x) \
    if (_x) { \
        SysFreeString(_x);\
        _x = NULL; \
    } else

 // -------------------------------------------------------------------------

 // ReplaceInterface - Replaces a member interface with a new interface
 // -------------------------------------------------------------------------

 #define ReplaceInterface(_pUnk, _pUnkNew)  \
     { \
     if (_pUnk)  \
         _pUnk->Release();   \
     if (_pUnk = _pUnkNew)   \
         _pUnk->AddRef();    \
     }

#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------------
// SetWndThisPtrOnCreate
// --------------------------------------------------------------------------------
#define SetWndThisPtrOnCreate(hwnd, lpcs) \
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)(((LPCREATESTRUCT)lpcs)->lpCreateParams))

// --------------------------------------------------------------------------------
// SetWndThisPtr
// --------------------------------------------------------------------------------
#define SetWndThisPtr(hwnd, THIS) \
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)THIS)

// --------------------------------------------------------------------------------
// GetWndThisPtr
// --------------------------------------------------------------------------------
#define GetWndThisPtr(hwnd) \
    GetWindowLongPtr(hwnd, GWLP_USERDATA)

// --------------------------------------------------------------------------------
// ListView Helper Macros
// --------------------------------------------------------------------------------
#define ListView_GetSelFocused(_hwndlist)        ListView_GetNextItem(_hwndlist, -1, LVNI_SELECTED|LVIS_FOCUSED)
#define ListView_GetFirstSel(_hwndlist)          ListView_GetNextItem(_hwndlist, -1, LVNI_SELECTED)
#define ListView_GetFocusedItem(_hwndlist)       ListView_GetNextItem(_hwndlist, -1, LVNI_FOCUSED)
#define ListView_SelectItem(_hwndlist, _i)       ListView_SetItemState(_hwndlist, _i, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED)
#define ListView_UnSelectItem(_hwndlist, _i)     ListView_SetItemState(_hwndlist, _i, 0, LVIS_SELECTED)
#define ListView_FocusItem(_hwndlist, _i)        ListView_SetItemState(_hwndlist, _i, LVIS_FOCUSED, LVIS_FOCUSED)
#if (_WIN32_IE >= 0x0400)
#define ListView_UnSelectAll(_hwndlist)          { \
                                                 ListView_SetItemState(_hwndlist, -1, 0, LVIS_SELECTED|LVIS_FOCUSED); \
                                                 ListView_SetSelectionMark(_hwndlist, -1); \
                                                 }
#else
#define ListView_UnSelectAll(_hwndlist)          ListView_SetItemState(_hwndlist, -1, 0, LVIS_SELECTED|LVIS_FOCUSED);
#endif
#define ListView_SelectAll(_hwndlist)            ListView_SetItemState(_hwndlist, -1, LVIS_SELECTED, LVIS_SELECTED)

// --------------------------------------------------------------------------------
// MAX Move Memory Definitions
// --------------------------------------------------------------------------------
#ifdef RtlMoveMemory
#undef RtlMoveMemory
#ifdef __cplusplus
extern "C" {
#endif
__declspec(dllimport) void RtlMoveMemory(void *, const void *, unsigned long);
#ifdef __cplusplus
}
#endif
#endif

#ifndef MSOERT_NO_MEMUTIL
// --------------------------------------------------------------------------------
// Memory Utility Functions
// --------------------------------------------------------------------------------
extern IMalloc *g_pMalloc;

// --------------------------------------------------------------------------------
// SafeMemFree
// --------------------------------------------------------------------------------
#ifndef SafeMemFree
#ifdef __cplusplus
#define SafeMemFree(_pv) \
    if (_pv) { \
        g_pMalloc->Free(_pv); \
        _pv = NULL; \
    } else
#else
#define SafeMemFree(_pv) \
    if (_pv) { \
        g_pMalloc->lpVtbl->Free(g_pMalloc, _pv); \
        _pv = NULL; \
    } else
#endif // __cplusplus
#endif // SafeMemFree

// --------------------------------------------------------------------------------
// MemFree
// --------------------------------------------------------------------------------
#define MemFree(_pv)        g_pMalloc->Free(_pv)
#define ReleaseMem(_pv)     MemFree(_pv)
#define AthFreeString(_psz) g_pMalloc->Free((LPVOID)_psz)

// --------------------------------------------------------------------------------
// Memory Allocation Functions
// --------------------------------------------------------------------------------
LPVOID     ZeroAllocate(DWORD cbSize);
BOOL       MemAlloc(LPVOID* ppv, ULONG cb);
BOOL       MemRealloc(LPVOID *ppv, ULONG cbNew);
HRESULT    HrAlloc(LPVOID *ppv, ULONG cb);
HRESULT    HrRealloc(LPVOID *ppv, ULONG cbNew);

#endif // !MSOERT_NO_MEMUTIL

// --------------------------------------------------------------------------------
// Debug Utility Functions
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_DEBUG

#endif // !MSOERT_NO_DEBUG

// --------------------------------------------------------------------------------
// String Utility Functions
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_STRUTIL

#define CCHMAX_STRINGRES    512

// Used with HrFindInetTimeZone
typedef struct tagINETTIMEZONE {
    LPSTR  lpszZoneCode;
    INT    cHourOffset;
    INT    cMinuteOffset;
} INETTIMEZONE, *LPINETTIMEZONE;

// Used with CchFileTimeToDateTimeSz
#define DTM_LONGDATE            0x00000001
#define DTM_NOSECONDS           0x00000002
#define DTM_NOTIME              0x00000004
#define DTM_NODATE              0x00000008
#define DTM_DOWSHORTDATE        0x00000010
#define DTM_FORCEWESTERN        0x00000020
#define DTM_NOTIMEZONEOFFSET    0x00000040

#define TOUPPERA(_ch) (CHAR)LOWORD(CharUpperA((LPSTR)(DWORD_PTR)MAKELONG(_ch, 0)))
#define TOLOWERA(_ch) (CHAR)LOWORD(CharLowerA((LPSTR)(DWORD_PTR)MAKELONG(_ch, 0)))

OESTDAPI_(LPWSTR)   PszDupW(LPCWSTR pcwszSource);
OESTDAPI_(LPSTR)    PszDupA(LPCSTR pcszSource);
OESTDAPI_(LPSTR)    PszDupLenA(LPCSTR pcszSource, int nLen);
OESTDAPI_(BOOL)     FIsEmptyA(LPCSTR pcszString);
OESTDAPI_(BOOL)     FIsEmptyW(LPCWSTR pcwszString);
OESTDAPI_(LPWSTR)   PszToUnicode(UINT cp, LPCSTR pcszSource);
OESTDAPI_(ULONG)    UlStripWhitespace(LPTSTR lpsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb);
OESTDAPI_(ULONG)    UlStripWhitespaceW(LPWSTR lpwsz, BOOL fLeading, BOOL fTrailing, ULONG *pcb);
OESTDAPI_(LPSTR)    PszSkipWhiteA(LPSTR psz);
OESTDAPI_(LPWSTR)   PszSkipWhiteW(LPWSTR psz);
OESTDAPI_(LPSTR)    PszScanToWhiteA(LPSTR psz);
OESTDAPI_(LPSTR)    PszScanToCharA(LPSTR psz, CHAR ch);
OESTDAPI_(VOID)     StripCRLF(LPSTR lpsz, ULONG *pcb);
OESTDAPI_(LPSTR)    PszAllocA(INT nLen);
OESTDAPI_(LPWSTR)   PszAllocW(INT nLen);
OESTDAPI_(BOOL)     FIsSpaceA(LPSTR psz);
OESTDAPI_(BOOL)     FIsSpaceW(LPWSTR psz);
OESTDAPI_(LPSTR)    PszToANSI(UINT cp, LPCWSTR pcwszSource);
OESTDAPI_(UINT)     StrToUintW(LPCWSTR lpSrc);
OESTDAPI_(UINT)     StrToUintA(LPCSTR lpSrc);
OESTDAPI_(INT)      IsDigit(LPSTR psz);
OESTDAPI_(CHAR)     ChConvertFromHex(CHAR ch);
OESTDAPI_(LPSTR)    PszFromANSIStreamA(LPSTREAM pstm);
OESTDAPI_(HRESULT)  HrIndexOfMonth(LPCSTR pszMonth, ULONG *pulIndex);
OESTDAPI_(HRESULT)  HrIndexOfWeek(LPCSTR pszDay, ULONG *pulIndex);
OESTDAPI_(HRESULT)  HrFindInetTimeZone(LPCSTR pszTimeZone, LPINETTIMEZONE pTimeZone);
OESTDAPI_(LPCSTR)   PszDayFromIndex(ULONG ulIndex);
OESTDAPI_(LPCSTR)   PszMonthFromIndex(ULONG ulIndex);
OESTDAPI_(LPSTR)    PszEscapeMenuStringA(LPCSTR pszSource, LPSTR pszQuoted, int cch);
OESTDAPI_(INT)      IsPrint(LPSTR psz);
OESTDAPI_(INT)      IsUpper(LPSTR psz);
OESTDAPI_(INT)      IsAlphaNum(LPSTR psz);
OESTDAPI_(LPSTR)    strtrim(char *s);
OESTDAPI_(LPWSTR)   strtrimW(WCHAR *s);
OESTDAPI_(INT)      CchFileTimeToDateTimeSz(FILETIME * pft, CHAR * szDateTime, int cch, DWORD dwFlags);
OESTDAPI_(LPCSTR)   StrChrExA(UINT codepage, LPCSTR pszString, CHAR ch);
OESTDAPI_(BOOL)     FIsValidFileNameCharW(WCHAR wch);
OESTDAPI_(BOOL)     FIsValidFileNameCharA(UINT codepage, CHAR ch);
OESTDAPI_(ULONG)    CleanupFileNameInPlaceA(UINT codepage, LPSTR psz);
OESTDAPI_(ULONG)    CleanupFileNameInPlaceW(LPWSTR pwsz);
OESTDAPI_(INT)      ReplaceChars(LPCSTR pszString, CHAR chFind, CHAR chReplace);
OESTDAPI_(INT)      ReplaceCharsW(LPCWSTR pszString, WCHAR chFind, WCHAR chReplace);
OESTDAPI_(LPCSTR)   _MSG(LPSTR pszFormat, ...);
OESTDAPI_(BOOL)     IsValidFileIfFileUrl(LPSTR pszUrl);
OESTDAPI_(BOOL)     IsValidFileIfFileUrlW(LPWSTR pwszUrl);
OESTDAPI_(BOOL)     fGetBrowserUrlEncoding(LPDWORD pdwFlags);

typedef int (*PFGETTIMEFORMATW)(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, 
                                                  LPCWSTR pwzFormat, LPWSTR pwzTimeStr, int cchTime);

typedef int (*PFGETDATEFORMATW)(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, 
                                                  LPCWSTR pwzFormat, LPWSTR pwzDateStr, int cchDate);

typedef int (*PFGETLOCALEINFOW)(LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData);

OESTDAPI_(BOOL)     CchFileTimeToDateTimeW(FILETIME *pft, WCHAR * wsDateTime, int cch, 
                                            DWORD dwFlags, PFGETDATEFORMATW pfGetDateFormatW,
                                            PFGETTIMEFORMATW  pfGetTimeFormatW,
                                            PFGETLOCALEINFOW  pfGetLocaleInfo);

// --------------------------------------------------------------------------------
// Unicode/ANSI Function Mapping
// --------------------------------------------------------------------------------
#ifdef UNICODE
#define FIsEmpty            FIsEmptyW
#define PszDup              PszDupW
#define PszAlloc            PszAllocW
#define FIsSpace            FIsSpaceW
#define StrToUint           StrToUintW
#else
#define FIsEmpty            FIsEmptyA
#define PszDup              PszDupA
#define PszAlloc            PszAllocA
#define FIsSpace            FIsSpaceA
#define StrToUint           StrToUintA
#endif

#define IsSpace             FIsSpaceA

#endif // !MSOERT_NO_STRUTIL

// --------------------------------------------------------------------------------
// IStream Utility Functions
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_STMUTIL

OESTDAPI_(HRESULT)  HrIsStreamUnicode(LPSTREAM pstm, BOOL *pfLittleEndian);
OESTDAPI_(HRESULT)  HrCopyStreamToByte(LPSTREAM lpstmIn, LPBYTE pbDest, ULONG *pcb);
OESTDAPI_(HRESULT)  HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb);
OESTDAPI_(HRESULT)  HrGetStreamSize(LPSTREAM pstm, ULONG *pcb);
OESTDAPI_(HRESULT)  HrRewindStream(LPSTREAM pstm);
OESTDAPI_(HRESULT)  HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);
OESTDAPI_(HRESULT)  HrCopyLockBytesToStream(ILockBytes *pLockBytes, IStream *pStream, ULONG *pcbCopied);
OESTDAPI_(HRESULT)  HrSafeGetStreamSize(LPSTREAM pstm, ULONG *pcb);
OESTDAPI_(HRESULT)  HrGetStreamPos(LPSTREAM pstm, ULONG *piPos);
OESTDAPI_(HRESULT)  HrStreamSeekSet(LPSTREAM pstm, ULONG iPos);
OESTDAPI_(HRESULT)  HrCopyStreamCBEndOnCRLF(LPSTREAM lpstmIn, LPSTREAM  lpstmOut, ULONG cb, ULONG *pcbActual);
OESTDAPI_(HRESULT)  CreateTempFileStream(LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  HrStreamToByte(LPSTREAM lpstm, LPBYTE *lppb, ULONG *pcb);
OESTDAPI_(HRESULT)  HrCopyStreamCB(LPSTREAM lpstmIn, LPSTREAM lpstmOut, ULARGE_INTEGER uliCopy, ULARGE_INTEGER *puliRead, ULARGE_INTEGER *puliWritten);
OESTDAPI_(HRESULT)  HrStreamSeekCur(LPSTREAM pstm, LONG iPos);
OESTDAPI_(HRESULT)  HrStreamSeekEnd(LPSTREAM pstm);
OESTDAPI_(HRESULT)  HrStreamSeekBegin(LPSTREAM pstm);
OESTDAPI_(BOOL)     StreamSubStringMatch(LPSTREAM pstm, TCHAR *sz);

OESTDAPI_(HRESULT)  OpenFileStream(LPSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamWithFlags(LPSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwFlagsAndAttributes, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamShare(LPSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwShare, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  WriteStreamToFile(LPSTREAM pstm, LPSTR lpszFile, DWORD dwCreationDistribution, DWORD dwAccess);

OESTDAPI_(HRESULT)  OpenFileStreamW(LPWSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamWithFlagsW(LPWSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwFlagsAndAttributes, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  OpenFileStreamShareW(LPWSTR pszFile, DWORD dwCreationDistribution, DWORD dwAccess, DWORD dwShare, LPSTREAM *ppstmFile);
OESTDAPI_(HRESULT)  WriteStreamToFileW(LPSTREAM pstm, LPWSTR lpszFile, DWORD dwCreationDistribution, DWORD dwAccess);
OESTDAPI_(int)      AthwsprintfW( LPWSTR lpOut, int cchLimitIn, LPCWSTR lpFmt, ... );

#endif // !MSOERT_NO_STRUTIL

// --------------------------------------------------------------------------------
// Protected Storage
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_PROTSTOR

#include "pstore.h"

#ifdef ENABLE_RULES
#define PST_IDENT_TYPE_STRING       L"Identification with rules"
#elif defined(N_TEST)
#define PST_IDENT_TYPE_STRING       L"Identification test"
#else
#define PST_IDENT_TYPE_STRING       L"Identification"
#endif

#define PST_IMNACCT_SUBTYPE_STRING  L"INETCOMM Server Passwords"
#define PST_CERTS_SUBTYPE_STRING    L"Certificate Trust"



// --------------------------------------------------------------------------------
// Protected Storage Functions
// --------------------------------------------------------------------------------
OESTDAPI_(HRESULT)  PSTSetNewData(
        IN IPStore *const      pISecProv,
        IN const GUID *const   guidType,
        IN const GUID *const   guidSubt,
        IN LPCWSTR             wszAccountName,
        IN const BLOB *const   pclear,
        OUT BLOB *const        phandle);

OESTDAPI_(HRESULT)  PSTGetData(
        IN IPStore *const      pISecProv,
        IN const GUID *const   guidType,
        IN const GUID *const   guidSubt,
        IN LPCWSTR             wszLookupName,
        OUT BLOB *const        pclear);

OESTDAPI_(HRESULT)  PSTCreateTypeSubType_NoUI(
        IN IPStore *const     pISecProv,
        IN const GUID *const  guidType,
        IN LPCWSTR            szType,
        IN const GUID *const  guidSubt,
        IN LPCWSTR            szSubt);

OESTDAPI_(LPWSTR)   WszGenerateNameFromBlob(IN BLOB blob);
OESTDAPI_(void)     PSTFreeHandle(IN LPBYTE pb);

#endif // !MSOERT_NO_PROTSTOR

// --------------------------------------------------------------------------------
// CAPI Utility - A few helper functions for the crypt32 utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_CAPIUTIL

#ifndef __WINCRYPT_H__
#define _CRYPT32_
#include <wincrypt.h>
#endif
typedef enum tagCERTSTATE CERTSTATE; // From mimeole.h

OESTDAPI_(LPSTR)    SzGetCertificateEmailAddress(const PCCERT_CONTEXT pCert);
 
OESTDAPI_(HRESULT)  HrDecodeObject(const BYTE *pbEncoded, DWORD cbEncoded, LPCSTR item, DWORD dwFlags,
  DWORD *pcbOut, LPVOID *ppvOut);
OESTDAPI_(LPVOID)   PVDecodeObject(const BYTE *pbEncoded, DWORD cbEncoded, LPCSTR  item, DWORD  *pcbOut);
OESTDAPI_(LPVOID)   PVGetCertificateParam(PCCERT_CONTEXT pCert, DWORD dwParam, DWORD *cbOut);
OESTDAPI_(HRESULT)  HrGetCertificateParam(PCCERT_CONTEXT pCert, DWORD dwParam, LPVOID * pvOut, DWORD *cbOut);
OESTDAPI_(BOOL)     FMissingCert(const CERTSTATE cs);
OESTDAPI_(LPVOID)   PVGetMsgParam(HCRYPTMSG hCryptMsg, DWORD dwParam, DWORD dwIndex, DWORD *pcbData);
OESTDAPI_(HRESULT)  HrGetMsgParam(HCRYPTMSG hCryptMsg, DWORD dwParam, DWORD dwIndex, LPVOID * ppv, DWORD * pcbData);

LPVOID WINAPI                  CryptAllocFunc(size_t cbSize);
VOID WINAPI                    CryptFreeFunc(LPVOID pv);

HRESULT HrGetCertKeyUsage(PCCERT_CONTEXT pccert, DWORD * pdwUsage);
HRESULT HrVerifyCertEnhKeyUsage(PCCERT_CONTEXT pccert, LPCSTR pszOidUsage);

#endif // !MSOERT_NO_CAPIUTIL

// --------------------------------------------------------------------------------
// CAPI Utility - A few helper functions for the crypt32 utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_RASUTIL

OESTDAPI_(HRESULT)  HrCreatePhonebookEntry(HWND hwnd, DWORD *pdwRASResult);
OESTDAPI_(HRESULT)  HrEditPhonebookEntry(HWND hwnd, LPTSTR pszEntryName, DWORD *pdwRASResult);
OESTDAPI_(HRESULT)  HrFillRasCombo(HWND hwndComboBox, BOOL fUpdateOnly, DWORD *pdwRASResult);

#endif // !MSOERT_NO_RASUTIL

// --------------------------------------------------------------------------------
// Win32 Registry Utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_REGUTIL

OESTDAPI_(VOID)     CopyRegistry(HKEY hSourceKey, HKEY hDestinationKey);

#endif // !MSOERT_NO_REGUTIL

// --------------------------------------------------------------------------------
// t-wstrings
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_WSTRINGS

OESTDAPI_(BOOL) UnlocStrEqNW(LPCWSTR pwsz1, LPCWSTR pwsz2, DWORD cch);

#endif // !MSOERT_NO_WSTRINGS

// --------------------------------------------------------------------------------
// CStringParser
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_STRPARSE
#ifdef __cplusplus
#include "strparse.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_STRPARSE

// --------------------------------------------------------------------------------
// DataObject Utility
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_ENUMFMT
#ifdef __cplusplus
typedef struct tagDATAOBJINFO 
    {
    FORMATETC   fe;
    LPVOID      pData;
    DWORD       cbData;
    } DATAOBJINFO, *PDATAOBJINFO;

OESTDAPI_(HRESULT) CreateEnumFormatEtc(LPUNKNOWN pUnkRef, ULONG celt, PDATAOBJINFO rgInfo, LPFORMATETC rgfe,
                             IEnumFORMATETC **  lppstmHFile);
#endif // !__cplusplus
#endif // !MSOERT_NO_ENUMFMT

// --------------------------------------------------------------------------------
// CPrivateUnknown Utility
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_PRIVUNK
#ifdef __cplusplus
#include "privunk.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_PRIVUNK


// --------------------------------------------------------------------------------
// CByteStream Object
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_BYTESTM
#ifdef __cplusplus
#include "bytestm.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_BYTESTM

// --------------------------------------------------------------------------------
// CLogFile Object
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_CLOGFILE
#ifdef __cplusplus
#include "..\\msoert\\clogfile.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_CLOGFILE

// --------------------------------------------------------------------------------
// CDataObject Object
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_DATAOBJ
#ifdef __cplusplus
#include "..\\msoert\\dataobj.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_DATAOBJ

// --------------------------------------------------------------------------------
// CUnknownList and CVoidPtrList Objects
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_LISTOBJS
#ifdef __cplusplus
#include "..\\msoert\\listintr.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_LISTOBJS

// --------------------------------------------------------------------------------
// MSHTML utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_MSHTMLUTILS
#ifdef __cplusplus
#include "..\\msoert\\mshtutil.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_MSHTMLUTILS

// --------------------------------------------------------------------------------
// BSTR utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_BSTUTILS
#ifdef __cplusplus
#include "..\\msoert\\bstr.h"
#endif // !__cplusplus
#endif // !MSOERT_NO_BSTRUTILS

// --------------------------------------------------------------------------------
// HFILESTM utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_HFILESTM
#ifdef __cplusplus
OESTDAPI_(HRESULT) CreateStreamOnHFile (LPTSTR                  lpszFile, 
                                        DWORD                   dwDesiredAccess,
                                        DWORD                   dwShareMode,
                                        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
                                        DWORD                   dwCreationDistribution,
                                        DWORD                   dwFlagsAndAttributes,
                                        HANDLE                  hTemplateFile,
                                        LPSTREAM                *lppstmHFile);

OESTDAPI_(HRESULT) CreateStreamOnHFileW(LPWSTR                  lpwszFile, 
                                        DWORD                   dwDesiredAccess,
                                        DWORD                   dwShareMode,
                                        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
                                        DWORD                   dwCreationDistribution,
                                        DWORD                   dwFlagsAndAttributes,
                                        HANDLE                  hTemplateFile,
                                        LPSTREAM                *lppstmHFile);
#endif // !__cplusplus
#endif // !MSOERT_NO_HFILESTM


// --------------------------------------------------------------------------------
// Outlook Express Runtime Utilities
// --------------------------------------------------------------------------------
#ifndef MSOERT_NO_OERTUTIL

typedef struct tagTEMPFILEINFO *LPTEMPFILEINFO;
typedef struct tagTEMPFILEINFO {
    LPTEMPFILEINFO      pNext;
    LPSTR               pszFilePath;
    HANDLE              hProcess;
} TEMPFILEINFO;

#ifndef HIMAGELIST
struct _IMAGELIST;
typedef struct _IMAGELIST NEAR* HIMAGELIST;
#endif

OESTDAPI_(HIMAGELIST)   LoadMappedToolbarBitmap(HINSTANCE hInst, int idBitmap, int cx);
OESTDAPI_(VOID)         UpdateRebarBandColors(HWND hwnd);
OESTDAPI_(HRESULT)      IsPlatformWinNT(void);
OESTDAPI_(HRESULT)      GenerateUniqueFileName(LPCSTR pszDirectory, LPCSTR pszFileName, LPCSTR pszExtension, LPSTR pszFilePath, ULONG cchMaxPath);
OESTDAPI_(HRESULT)      CreateTempFile(LPCSTR pszSuggest, LPCSTR pszExtension, LPSTR *ppszFilePath, HANDLE *phFile);
OESTDAPI_(HRESULT)      WriteStreamToFileHandle(IStream *pStream, HANDLE hFile, ULONG *pcbTotal);
OESTDAPI_(HRESULT)      AppendTempFileList(LPTEMPFILEINFO *ppHead, LPSTR pszFilePath, HANDLE hProcess);
OESTDAPI_(VOID)         DeleteTempFileOnShutdown(LPTEMPFILEINFO pTempFile);
OESTDAPI_(VOID)         DeleteTempFileOnShutdownEx(LPSTR pszFilePath, HANDLE hProcess);
OESTDAPI_(VOID)         CleanupGlobalTempFiles(void);
OESTDAPI_(HRESULT)      DeleteTempFile(LPTEMPFILEINFO pTempFile);
OESTDAPI_(VOID)         FreeTempFileList(LPTEMPFILEINFO pTempFileHead);

#define SafeFreeTempFileList(_p)    \
    {                               \
    if (_p)                         \
        {                           \
        FreeTempFileList(_p);       \
        _p=NULL;                    \
        }                           \
    }

OESTDAPI_(BOOL) FBuildTempPath(LPTSTR lpszOrigFile, LPTSTR lpszPath, ULONG cbMaxPath, BOOL fLink);
OESTDAPI_(BOOL) FBuildTempPathW(LPWSTR lpszOrigFile, LPWSTR lpszPath, ULONG cchMaxPath, BOOL fLink);

OESTDAPI_(HRESULT) ShellUtil_GetSpecialFolderPath(DWORD dwSpecialFolder, LPSTR rgchPath);

OESTDAPI_(BOOL) FIsHTMLFile(LPSTR pszFile);
OESTDAPI_(BOOL) FIsHTMLFileW(LPWSTR pwszFile);

typedef int (*PFLOADSTRINGW)(HINSTANCE,UINT,LPWSTR,int);
typedef int (*PFMESSAGEBOXW)(HWND,LPCWSTR,LPCWSTR,UINT);


OESTDAPI_(int)  MessageBoxInst(HINSTANCE hInst, HWND hwndOwner, LPTSTR pszTitle, LPTSTR psz1, LPTSTR psz2, UINT fuStyle);
OESTDAPI_(int)  MessageBoxInstW(HINSTANCE hInst, HWND hwndOwner, LPWSTR pwszTitle, LPWSTR pwsz1, LPWSTR pwsz2, UINT fuStyle, 
                                PFLOADSTRINGW pfLoadStringW, PFMESSAGEBOXW pfMessageBoxW);

// window utils
OESTDAPI_(void) IDrawText(HDC hdc, LPCTSTR pszText, RECT FAR* prc, BOOL fEllipses, int cyChar);
OESTDAPI_(HRESULT) RicheditStreamIn(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags);
OESTDAPI_(HRESULT) RicheditStreamOut(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags);
OESTDAPI_(VOID) CenterDialog(HWND hwndDlg);
OESTDAPI_(VOID) SetIntlFont(HWND hwnd);
OESTDAPI_(BOOL) GetExePath(LPCTSTR szExe, TCHAR *szPath, DWORD cch, BOOL fDirOnly);
OESTDAPI_(BOOL) BrowseForFolder(HINSTANCE hInst, HWND hwnd, TCHAR *pszDir, int cch, int idsText, BOOL fFileSysOnly);
OESTDAPI_(BOOL) BrowseForFolderW(HINSTANCE hInst, HWND hwnd, WCHAR *pwszDir, int cch, int idsText, BOOL fFileSysOnly);

OESTDAPI_(HRESULT) DoHotMailWizard(HWND hwndOwner, LPSTR pszUrl, LPSTR pszFriendly, RECT *prc, IUnknown *pUnkHost);

OESTDAPI_(LONG_PTR) SetWindowLongPtrAthW(HWND hWnd, int  nIndex, LONG_PTR dwNewLong);

HRESULT GetHtmlCharset(IStream *pStmHtml, LPSTR *ppszCharset);

#endif // MSOERT_NO_OERTUTIL


typedef HANDLE  HTHREAD;
typedef HANDLE  HEVENT;
typedef HANDLE  HPROCESS;

typedef HANDLE  HANDLE_16;
typedef WPARAM  WPARAM_16;

#define EXTERN_C_16
#define WINAPI_16
#define CALLBACK_16
#define EXPORT_16
#define LOADDS_16
#define HUGEP_16

#define WaitForSingleObject_16 WaitForSingleObject
#define GlobalAlloc_16 GlobalAlloc
#define GlobalFree_16 GlobalFree

#define CreateFileMapping_16 CreateFileMapping
#define MapViewOfFile_16 MapViewOfFile
#define UnmapViewOfFile_16 UnmapViewOfFile
#define CloseHandle_FM16 CloseHandle

#define CloseHandle_F16 CloseHandle

#define INVALID_HANDLE_VALUE_16 INVALID_HANDLE_VALUE

#define SetDlgThisPtr(hwnd, THIS) SetWndThisPtr(hwnd, THIS)
#define GetDlgThisPtr(hwnd) GetWndThisPtr(hwnd)

// Some one liners can be wrapped in IF_WIN16 or IF_WIN32 so that the
// code is more readable.
#define IF_WIN16(x)
#define IF_NOT_WIN16(x) x
#define IF_WIN32(x) x

#endif // __MSOERT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\newimp.h ===
#ifndef _INC_NEWIMP_H
#define _INC_NEWIMP_H


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// WARNING:  If you make changes to this header, you must also update  //
//           inetcore\published\inc\newimp.h !!!                       //
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#ifndef NO_IMPORT_ERROR

#define HR_IMP_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_IMP_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)
#define HR_IMP      0x3000

#define hrFolderOpenFail    HR_IMP_E(HR_IMP + 1)
#define hrFolderReadFail    HR_IMP_E(HR_IMP + 2)
#define hrMapiInitFail      HR_IMP_E(HR_IMP + 3)
#define hrNoProfilesFound   HR_IMP_E(HR_IMP + 4)
#define hrDiskFull          HR_IMP_E(HR_IMP + 5)
#define hrUserCancel        HR_IMP_E(HR_IMP + 6)

#endif // NO_IMPORT_ERROR

typedef enum tagIMPORTFOLDERTYPE
    {
    FOLDER_TYPE_NORMAL = 0,
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT,
    FOLDER_TYPE_DELETED,
    FOLDER_TYPE_DRAFT,
    CFOLDERTYPE
    } IMPORTFOLDERTYPE;

typedef struct IMSG IMSG;

typedef enum
    {
    MSG_TYPE_MAIL = 0,
    MSG_TYPE_NEWS
    } MSGTYPE;

#define MSG_STATE_UNREAD    0x0001
#define MSG_STATE_UNSENT    0x0002
#define MSG_STATE_SUBMITTED 0x0004
#define MSG_PRI_LOW         0x0010
#define MSG_PRI_NORMAL      0x0020
#define MSG_PRI_HIGH        0x0040
#define MSG_PRI_MASK        0x0070

// {E4499DE7-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IFolderImport, 0xE4499DE7L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IFolderImport IFolderImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IFolderImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMessageCount(ULONG cMsg) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(IMSG *pimsg) = 0;
    };
#else   /* C style interface */
typedef struct IFolderImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IFolderImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IFolderImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IFolderImport * This);

    HRESULT ( STDMETHODCALLTYPE *SetMessageCount )(
		IFolderImport * This,
		ULONG cMsg);
    HRESULT ( STDMETHODCALLTYPE *ImportMessageEx )(
		IFolderImport * This,
		MSGTYPE type, 
		DWORD dwState, 
		LPSTREAM pstm, 
		const TCHAR **rgszAttach, 
		DWORD cAttach);
    HRESULT ( STDMETHODCALLTYPE *ImportMessage )(
		IFolderImport * This,
		IMSG *pimsg);
    END_INTERFACE
} IFolderImportVtbl;

interface IFolderImport
{
    CONST_VTBL struct IFolderImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IFolderImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IFolderImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IFolderImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IFolderImport_SetMessageCount(This,cMsg)	\
	(This)->lpVtbl -> SetMessageCount(This,cMsg)
#define IFolderImport_ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)	\
	(This)->lpVtbl -> ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)
#define IFolderImport_ImportMessage(This,pimsg)	\
	(This)->lpVtbl -> ImportMessage(This,pimsg)
#endif /* COBJMACROS */

#endif  /* C style interface */



// {E4499DE8-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImporter, 0xE4499DE8L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IMailImporter IMailImporter;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImporter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie) = 0;
    };
#else   /* C style interface */
typedef struct IMailImporterVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImporter * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImporter * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImporter * This);

    HRESULT ( STDMETHODCALLTYPE *OpenFolder )(
		IMailImporter * This,
		DWORD_PTR dwCookie, 
		const TCHAR *szFolder, 
		IMPORTFOLDERTYPE type, 
		DWORD dwFlags, 
		IFolderImport **ppFldrImp, 
		DWORD_PTR *pdwCookie);
    END_INTERFACE
} IMailImporterVtbl;

interface IMailImporter
{
    CONST_VTBL struct IMailImporterVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImporter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImporter_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImporter_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImporter_OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)	\
   (This)->lpVtbl -> OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)

#endif /* COBJMACROS */

#endif  /* C style interface */

typedef struct tagIMPORTFOLDER
    {
    DWORD_PTR           dwCookie;
    TCHAR               szName[MAX_PATH];
    IMPORTFOLDERTYPE    type;
    // DWORD       cMsg;
    BOOL                fSubFolders;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    } IMPORTFOLDER;

// {E4499DE9-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IEnumFOLDERS, 0xE4499DE9L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IEnumFOLDERS IEnumFOLDERS;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IEnumFOLDERS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPORTFOLDER *pfldr) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };
#else   /* C style interface */
typedef struct IEnumFOLDERSVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IEnumFOLDERS * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IEnumFOLDERS * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IEnumFOLDERS * This);

    HRESULT ( STDMETHODCALLTYPE *Next )(
		IEnumFOLDERS * This,
        IMPORTFOLDER *pfldr);
    HRESULT ( STDMETHODCALLTYPE *Reset )(
		IEnumFOLDERS * This);
    END_INTERFACE
} IEnumFOLDERSVtbl;

interface IEnumFOLDERS
{
    CONST_VTBL struct IEnumFOLDERSVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IEnumFOLDERS_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IEnumFOLDERS_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IEnumFOLDERS_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IEnumFOLDERS_Next(This,pfldr)	\
   (This)->lpVtbl -> Next(This,pfldr);
#define IEnumFOLDERS_Reset(This)	\
   (This)->lpVtbl -> Reset(This);
#endif /* COBJMACROS */

#endif  /* C style interface */


#define COOKIE_ROOT     MAXULONG_PTR

// {E4499DEA-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImport, 0xE4499DEAL, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IMailImport IMailImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetDirectory(char *szDir, UINT cch) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDirectory(char *szDir) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport) = 0;
    };
#else   /* C style interface */
typedef struct IMailImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImport * This);

    HRESULT ( STDMETHODCALLTYPE *InitializeImport )(
		IMailImport * This,
        HWND hwnd);
    HRESULT ( STDMETHODCALLTYPE *GetDirectory )(
		IMailImport * This,
        char *szDir, 
        UINT cch);
    HRESULT ( STDMETHODCALLTYPE *SetDirectory )(
		IMailImport * This,
        char *szDir);
    HRESULT ( STDMETHODCALLTYPE *EnumerateFolders )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IEnumFOLDERS **ppEnum);
    HRESULT ( STDMETHODCALLTYPE *ImportFolder )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IFolderImport *pImport);

    END_INTERFACE
} IMailImportVtbl;

interface IMailImport
{
    CONST_VTBL struct IMailImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImport_InitializeImport(This,hwnd) \
    (This)->lpVtbl -> InitializeImport(This,hwnd)
#define IMailImport_GetDirectory(This,szDir,cch)    \
    (This)->lpVtbl -> GetDirectory(This,szDir,cch)
#define IMailImport_SetDirectory(This,szDir)    \
    (This)->lpVtbl -> SetDirectory(This,szDir)
#define IMailImport_EnumerateFolders(This,dwCookie,ppEnum)  \
    (This)->lpVtbl -> EnumerateFolders(This,dwCookie,ppEnum)
#define IMailImport_ImportFolder(This,dwCookie,pImport) \
    (This)->lpVtbl -> ImportFolder(This,dwCookie,pImport)

#endif /* COBJMACROS */

#endif  /* C style interface */

#define achPerformImport    "PerformImport"
void PerformImport(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef void (*PFNPERFORMIMPORT)(HWND, IMailImporter *, DWORD);

#define achPerformMigration "PerformMigration"
HRESULT PerformMigration(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef HRESULT (*PFNPERFORMMIGRATION)(HWND, IMailImporter *, DWORD);

#endif // _INC_NEWIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\notify.h ===
//+-------------------------------------------------------------------------
// Notify.h
//--------------------------------------------------------------------------
#ifndef __NOTIFY_H
#define __NOTIFY_H

#include <msoeapi.h>

//+-------------------------------------------------------------------------
// Consts
//--------------------------------------------------------------------------
#define CMAX_HWND_NOTIFY         128
#define CMAX_STRUCT_MEMBERS      10
#define MSEC_WAIT_NOTIFY         10000

//+-------------------------------------------------------------------------
// STNOTIFYINFO
//--------------------------------------------------------------------------
#define SNF_POSTMSG              0           // Default: Use a PostMessage Command
#define SNF_SENDMSG              0x00000001  // Use a SendMessage command
#define SNF_CALLBACK             0x00000002  // DoNotify - wParam = callback function, lParam = cookie
#define SNF_CROSSPROCESS         0x00000004  // Do not do any cross-process notifications, data can't be thunked
#define SNF_HASTHUNKINFO         0x00000008  // Can go cross-process and data does not need no thunking (wParam and/or lParam are not pointers)
#define SNF_VALIDPARAM1          0x00000010  // NOTIFYDATA::rParam1 is valid
#define SNF_VALIDPARAM2          0x00000020  // NOTIFYDATA::rParam2 is valid
#define SNR_UNREGISTER           0xfffffff0  // A notified hwnd can return this after a SendMessage to auto-unregister itself

//+-------------------------------------------------------------------------
// NOTIFYWINDOW
//--------------------------------------------------------------------------
typedef struct tagNOTIFYWINDOW const *LPCNOTIFYWINDOW;
typedef struct tagNOTIFYWINDOW {
    HWND            hwndThunk;          // Thunking window for x-process notify
    HWND            hwndNotify;         // Handle of window to notify
    BOOL            fExternal;          // Notification is going to an IStoreNamespace or IStoreFolder user
} NOTIFYWINDOW, *LPNOTIFYWINDOW;

//+-------------------------------------------------------------------------
// NOTIFYWINDOWTABLE
//--------------------------------------------------------------------------
typedef struct tagNOTIFYWINDOWTABLE const *LPCNOTIFYWINDOWTABLE;
typedef struct tagNOTIFYWINDOWTABLE {
    DWORD           cWindows;           // Number of registered windows
    NOTIFYWINDOW    rgWindow[CMAX_HWND_NOTIFY]; // Array of thunk/notify windows
} NOTIFYWINDOWTABLE, *LPNOTIFYWINDOWTABLE;

//+-------------------------------------------------------------------------
// MEMBERINFO Flags
//--------------------------------------------------------------------------
#define MEMBERINFO_POINTER       0x00000001
#define MEMBERINFO_POINTER_NULL  (MEMBERINFO_POINTER | 0x00000002)

//+-------------------------------------------------------------------------
// MEMBERINFO - Used to describe the members of a structure
//--------------------------------------------------------------------------
typedef struct tagMEMBERINFO const *LPCMEMBERINFO;
typedef struct tagMEMBERINFO {
    DWORD           dwFlags;            // MEMBERINFO_xxx Flags
    DWORD           cbSize;             // Size of the member
    DWORD           cbData;             // Size of the data
    LPBYTE          pbData;             // Pointer to the data
} MEMBERINFO, *LPMEMBERINFO;

//+-------------------------------------------------------------------------
// STRUCTINFO Flags
//--------------------------------------------------------------------------
#define STRUCTINFO_VALUEONLY     0x00000001
#define STRUCTINFO_POINTER       0x00000002

//+-------------------------------------------------------------------------
// STRUCTINFO - Used to describe the data in a notification parameter
//--------------------------------------------------------------------------
typedef struct tagSTRUCTINFO const *LPCSTRUCTINFO;
typedef struct tagSTRUCTINFO {
    DWORD           dwFlags;            // STRUCTINFO_xxx Flags
    DWORD           cbStruct;           // Size of the structure that we are defining
    LPBYTE          pbStruct;           // Parameter that can be used inproc
    ULONG           cMembers;           // Number of members in the structure
    MEMBERINFO      rgMember[CMAX_STRUCT_MEMBERS]; // An array of members
} STRUCTINFO, *LPSTRUCTINFO;

//+-------------------------------------------------------------------------
// NOTIFYDATA
//--------------------------------------------------------------------------
typedef struct tagNOTIFYDATA {
    HWND            hwndNotify;         // Window to notify
    UINT            msg;                // The notification window message to send
    WPARAM          wParam;             // The wParam data
    LPARAM          lParam;             // The lParam data
    DWORD           dwFlags;            // SNF_xxx Flags
    STRUCTINFO      rParam1;            // First parameter (wParam)
    STRUCTINFO      rParam2;            // Second parameter (lParam)
    COPYDATASTRUCT  rCopyData;          // CopyData Struct
} NOTIFYDATA, *LPNOTIFYDATA;

//+-------------------------------------------------------------------------
// A Callback can return 
//--------------------------------------------------------------------------
typedef HRESULT (*PFNNOTIFYCALLBACK)(LPARAM lParam, LPNOTIFYDATA pNotify, BOOL fNeedThunk, BOOL fExternal);

//+-------------------------------------------------------------------------
// IStoreNotify
//--------------------------------------------------------------------------
interface INotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(LPCSTR pszName) = 0;
        virtual HRESULT STDMETHODCALLTYPE Register(HWND hwndNotify, HWND hwndThunk, BOOL fExternal) = 0;
        virtual HRESULT STDMETHODCALLTYPE Unregister(HWND hwndNotify) = 0;
        virtual HRESULT STDMETHODCALLTYPE Lock(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE Unlock(void) = 0;
        virtual HRESULT STDMETHODCALLTYPE NotificationNeeded(void) = 0;
        virtual HRESULT STDMETHODCALLTYPE DoNotification(UINT uWndMsg, WPARAM wParam, LPARAM lParam, DWORD dwFlags) = 0;
    };

//+-------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
OESTDAPI_(HRESULT) CreateNotify(INotify **ppNotify);
OESTDAPI_(HRESULT) BuildNotificationPackage(LPNOTIFYDATA pNotify, PCOPYDATASTRUCT pCopyData);
OESTDAPI_(HRESULT) CrackNotificationPackage(PCOPYDATASTRUCT pCopyData, LPNOTIFYDATA pNotify);

#endif // __NOTIFY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\qstrcmpi.h ===
#ifndef __QSTRCMPI_INC
#define __QSTRCMPI_INC

unsigned char __declspec(selectany) g_achOEMtoupper[256] = {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
     'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
     'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};

#define OEMtoupper(ch)	g_achOEMtoupper[(unsigned char) (ch)]

inline int OEMstrcmpi(LPCSTR psz1, LPCSTR psz2) {

    for (;*psz1||*psz2;psz1++,psz2++) {
        if (OEMtoupper(*psz1) < OEMtoupper(*psz2)) {
            return (-1);
        }
        if (OEMtoupper(*psz1) > OEMtoupper(*psz2)) {
            return (1);
        }
    }
    return (0);
}

typedef enum tagOEMcharinfo {
    OCI_isspace = 1
} OEMcharinfo;

DWORD __declspec(selectany) g_adwOEMcharinfo[256] = {
    0,0,0,0,0,0,0,0,/*HT*/OCI_isspace,/*LF*/OCI_isspace,/*VT*/OCI_isspace,/*FF*/OCI_isspace,/*CR*/OCI_isspace,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    /*space*/OCI_isspace,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

inline int OEMisspace(char ch) {

    return (g_adwOEMcharinfo[(unsigned char) ch] & OCI_isspace);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\sterror.h ===
// --------------------------------------------------------------------------------
// STERROR.H
// --------------------------------------------------------------------------------
#ifndef __STERROR_H
#define __STERROR_H

// --------------------------------------------------------------------------------
// REPORTERRORINFO
// --------------------------------------------------------------------------------
typedef struct tagREPORTERRORINFO {
    UINT                nTitleIds;          // Title of the messagebox
    UINT                nPrefixIds;         // Prefix string resource id
    UINT                nErrorIds;          // Error string resource id
    UINT                nReasonIds;         // Reason string resource id
    BOOL                nHelpIds;           // Help String Resource Id
    LPCSTR              pszExtra1;          // Extra parameter 1
    ULONG               ulLastError;        // GetLastError() Value
} REPORTERRORINFO, *LPREPORTERRORINFO;

// --------------------------------------------------------------------------------
// ReportError - Shared between main Dll and EXE Startup Code
// --------------------------------------------------------------------------------
BOOL ReportError(
    HINSTANCE           hInstance,          // Dll Instance
    HRESULT             hrResult,           // HRESULT of the error
    LONG                lResult,            // LRESULT from like a registry function
    LPREPORTERRORINFO   pInfo)              // Report Error Information
{
    // Locals
    CHAR        szRes[255];
    CHAR        szMessage[1024];
    CHAR        szTitle[128];

    // INit
    *szMessage = '\0';

    // Is there a prefix
    if (pInfo->nPrefixIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nPrefixIds, szMessage, ARRAYSIZE(szMessage));
    }

    // Error ?
    if (pInfo->nErrorIds)
    {
        // Are there extras in this error string
        if (NULL != pInfo->pszExtra1)
        {
            // Locals
            CHAR szTemp[255];

            // Load and format
            LoadString(hInstance, pInfo->nErrorIds, szTemp, ARRAYSIZE(szTemp));

            // Format the string
            wsprintf(szRes, szTemp, pInfo->pszExtra1);
        }

        // Load the string
        else
        {
            // Load the error string
            LoadString(hInstance, pInfo->nErrorIds, szRes, ARRAYSIZE(szRes));
        }

        // Add to szMessage
        lstrcat(szMessage, g_szSpace);
        lstrcat(szMessage, szRes);
    }

    // Reason ?
    if (pInfo->nReasonIds)
    {
        // Load the string
        LoadString(hInstance, pInfo->nReasonIds, szRes, ARRAYSIZE(szRes));

        // Add to szMessage
        lstrcat(szMessage, g_szSpace);
        lstrcat(szMessage, szRes);
    }

    // Load the string
    LoadString(hInstance, pInfo->nHelpIds, szRes, ARRAYSIZE(szRes));

    // Add to szMessage
    lstrcat(szMessage, g_szSpace);
    lstrcat(szMessage, szRes);

    // Append Error Results
    if (lResult != 0 && E_FAIL == hrResult && pInfo->ulLastError)
        wsprintf(szRes, "(%d, %d)", lResult, pInfo->ulLastError);
    else if (lResult != 0 && E_FAIL == hrResult && 0 == pInfo->ulLastError)
        wsprintf(szRes, "(%d)", lResult);
    else if (pInfo->ulLastError)
        wsprintf(szRes, "(0x%08X, %d)", hrResult, pInfo->ulLastError);
    else
        wsprintf(szRes, "(0x%08X)", hrResult);

    // Add to szMessage
    lstrcat(szMessage, g_szSpace);
    lstrcat(szMessage, szRes);

    // Get the title
    LoadString(hInstance, pInfo->nTitleIds, szTitle, ARRAYSIZE(szTitle));

    // Show the error message
    MessageBox(NULL, szMessage, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);

    // Done
    return TRUE;
}

#endif // __STERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\main.h ===
#ifndef __MAIN_H
#define __MAIN_H

extern UINT g_msgSMTP;

#endif __MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\shared.h ===
/*
*    shared.h
*    
*    History:
*      Feb '98: Created.
*    
*    Copyright (C) Microsoft Corp. 1998
*
*   Describes functions in staticRT/shared.cpp
*/

#ifndef _SHARED_H
#define _SHARED_H

#ifdef  __cplusplus
#define _EXTERN_ extern "C"
#else
#define _EXTERN_ extern
#endif 

#define STR_PATH_MAIN_EXE "msimn.exe"

#ifdef DEFINE_SHARED_STRINGS
#define SHARED_GLOBAL(x,y)         _EXTERN_ CDECL const TCHAR x[] = TEXT(y)
#else
#define SHARED_GLOBAL(x,y)         _EXTERN_ CDECL const TCHAR x[]
#endif

// Files
SHARED_GLOBAL(c_szAdvPackDll,       "ADVPACK.DLL");
SHARED_GLOBAL(c_szOEResDll,         "msoeres.dll");
SHARED_GLOBAL(c_szInetResDll,       "inetres.dll");
SHARED_GLOBAL(c_szAcctResDll,       "acctres.dll");
SHARED_GLOBAL(c_szOutlAcctManDll,   "outlacct.dll");
SHARED_GLOBAL(c_szOEExe,            STR_PATH_MAIN_EXE);

// Reg Keys
SHARED_GLOBAL(c_szRegWinCurrVer,    "Software\\Microsoft\\Windows\\CurrentVersion");
SHARED_GLOBAL(c_szRegInetCommDll,   "Software\\Microsoft\\Outlook Express\\Inetcomm");
SHARED_GLOBAL(c_szRegOEAppPath,     "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\" STR_PATH_MAIN_EXE);
SHARED_GLOBAL(c_szRegMsoeAcctDll,   "Software\\Microsoft\\Internet Account Manager");

// Reg Value Names
SHARED_GLOBAL(c_szDllPath,          "DllPath");
SHARED_GLOBAL(c_szProgFilesDir,     "ProgramFilesDir");

// Misc
SHARED_GLOBAL(c_szReg,              "Reg");
SHARED_GLOBAL(c_szUnReg,            "UnReg");
SHARED_GLOBAL(c_szPath,             "Path");


// Some codepage mapping data structures and functions
struct _tagOENonStdCP
{
    UINT Codepage;              
    UINT cpRead;                // Read note CP
    UINT cpReadMenu;            // Read Note menu
    UINT cpReadTitle;           // Note Title CP
    UINT cpSendMenu;            // Compose note menu CP
    UINT cpSend;                // Send CP
    UINT UseSIO;                // Use SIO

//    UINT cpSend;             // Default compose note CP
};

typedef struct _tagOENonStdCP OENONSTDCP;

extern const OENONSTDCP OENonStdCPs[];

#ifdef __cplusplus
extern "C" {
#endif

HRESULT   CallRegInstall(HINSTANCE hInstCaller, HINSTANCE hInstRes, LPCSTR szSection, LPSTR pszExtra);
BOOL      AddEnvInPath  (LPCSTR pszOldPath, LPSTR pszNew);
HRESULT MakeFilePath(LPCSTR pszDirectory, LPCSTR pszFileName, LPCSTR pszExtension, LPSTR pszFilePath, ULONG cchMaxFilePath);

//PlugUI functions
#ifndef NT5B2
HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT);
#else
HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName);
#endif
BOOL OEWinHelp(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
HWND OEHtmlHelp(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData);
BOOL GetPCAndOSTypes(SYSTEM_INFO * pSysInf, OSVERSIONINFO * pOsInf);

// --------------------------------------------------------------------------------
// MEMORYFILE
// --------------------------------------------------------------------------------
typedef struct tagMEMORYFILE {
    HANDLE          hFile;
    HANDLE          hMemoryMap;
    DWORD           cbSize;
    LPVOID          pView;
} MEMORYFILE, *LPMEMORYFILE;

HRESULT CloseMemoryFile(LPMEMORYFILE pFile);
HRESULT OpenMemoryFile(LPCSTR pszFile, LPMEMORYFILE pFile);

#define     S_RESTART_OE            _HRESULT_TYPEDEF_(0x00000714L)
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\strparse.h ===
// --------------------------------------------------------------------------------
// Strparse.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __STRPARSE_H
#define __STRPARSE_H

typedef DWORD CODEPAGEID;

// --------------------------------------------------------------------------------
// Parse Flags, pass to CStringParser::Init
// --------------------------------------------------------------------------------
#define PSF_NOTRAILWS        0x00000001    // String trailing whitespace from pszValue  
#define PSF_NOFRONTWS        0x00000002    // Skip white space before searching for tokens
#define PSF_ESCAPED          0x00000004    // Detect escaped characters such as '\\'  or '\"'
#define PSF_DBCS             0x00000008    // The String could contain DBCS characters
#define PSF_NOCOMMENTS       0x00000010    // Skips comments (comment)
#define PSF_NORESET          0x00000020    // Don't reset the destination buffer on ChParse

// --------------------------------------------------------------------------------
// LITERALINFO
// --------------------------------------------------------------------------------
typedef struct tagLITERALINFO {
    BYTE            fInside;               // Are we in a literal
    CHAR            chStart;               // Starting literal delimiter
    CHAR            chEnd;                 // Ending literal delimiter if chEnd == chStart, no nesting
    DWORD           cNested;               // Number of nested delimiters
} LITERALINFO, *LPLITERALINFO;

// --------------------------------------------------------------------------------
// CStringParser
// --------------------------------------------------------------------------------
class CStringParser
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CStringParser(void);
    ~CStringParser(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CStringParser Methods
    // ----------------------------------------------------------------------------
    void    Init(LPCSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags);
    void    SetTokens(LPCSTR pszTokens);
    CHAR    ChSkip(void);
    CHAR    ChParse(void);
    CHAR    ChSkipWhite(void);
    CHAR    ChPeekNext(ULONG cchFromCurrent);
    HRESULT HrAppendValue(CHAR ch);

    // ----------------------------------------------------------------------------
    // Inline CStringParser Methods
    // ----------------------------------------------------------------------------
    UINT    GetCP(void) { return m_codepage; }
    void    SetCodePage(CODEPAGEID codepage) { m_codepage = codepage; }
    void    SetIndex(ULONG iIndex) { m_iSource = iIndex; }
    CHAR    ChSkip(LPCSTR pszTokens) { SetTokens(pszTokens); return ChSkip(); }
    CHAR    ChParse(LPCSTR pszTokens, DWORD dwFlags);
    CHAR    ChParse(LPCSTR pszTokens) { SetTokens(pszTokens); return ChParse(); }
    CHAR    ChParse(CHAR chStart, CHAR chEnd, DWORD dwFlags);
    ULONG   GetLength(void) { return m_cchSource; }
    ULONG   GetIndex(void) { return m_iSource; }
    LPCSTR  PszValue(void) { Assert(m_pszDest && '\0' == m_pszDest[m_cchDest]); return m_pszDest; }
    ULONG   CchValue(void) { Assert(m_pszDest && '\0' == m_pszDest[m_cchDest]); return m_cchDest; }
    void    FlagSet(DWORD dwFlags) { FLAGSET(m_dwFlags, dwFlags); }
    void    FlagClear(DWORD dwFlags) { FLAGCLEAR(m_dwFlags, dwFlags); }
    BOOL    FIsParseSpace(CHAR ch, BOOL *pfCommentChar);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrGrowDestination(ULONG cbWrite);
    HRESULT _HrDoubleByteIncrement(BOOL fEscape);
    
private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG           m_cRef;             // Reference Count
    CODEPAGEID      m_codepage;         // Code page to use to parse the string
    LPCSTR          m_pszSource;        // String to parse
    ULONG           m_cchSource;        // Length of pszString
    ULONG           m_iSource;          // Index into m_pszString
    LPSTR           m_pszDest;          // Destination buffer
    ULONG           m_cchDest;          // Write Index/size of dest buffer
    ULONG           m_cbDestMax;        // Maximum size of m_pszDest
    DWORD           m_dwFlags;          // Parse String Flags
    CHAR            m_szScratch[256];   // Scratch Buffer
    BYTE            m_rgbTokTable[256]; // Token Table
    LPCSTR          m_pszTokens;        // Current Parse Tokens
    ULONG           m_cCommentNest;     // Nested comment parens
    LITERALINFO     m_rLiteral;         // Literal Information
};

#endif // __STRPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\wstrpar.h ===
// --------------------------------------------------------------------------------
// wstrpar.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#pragma once

// --------------------------------------------------------------------------------
// Parse Flags, pass to CStringParser::Init
// --------------------------------------------------------------------------------
#define PSF_NOTRAILWS        0x00000001    // String trailing whitespace from pszValue  
#define PSF_NOFRONTWS        0x00000002    // Skip white space before searching for tokens
#define PSF_ESCAPED          0x00000004    // Detect escaped characters such as '\\'  or '\"'
#define PSF_NOCOMMENTS       0x00000010    // Skips comments (comment)
#define PSF_NORESET          0x00000020    // Don't reset the destination buffer on ChParse

// --------------------------------------------------------------------------------
// LITERALINFOW
// --------------------------------------------------------------------------------
typedef struct tagLITERALINFOW {
    BYTE            fInside;               // Are we in a literal
    WCHAR           chStart;               // Starting literal delimiter
    WCHAR           chEnd;                 // Ending literal delimiter if chEnd == chStart, no nesting
    DWORD           cNested;               // Number of nested delimiters
} LITERALINFOW, *LPLITERALINFOW;

// --------------------------------------------------------------------------------
// CStringParserW
// --------------------------------------------------------------------------------
class CStringParserW
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CStringParserW(void);
    ~CStringParserW(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // CStringParser Methods
    // ----------------------------------------------------------------------------
    void    Init(LPCWSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags);
    void    SetTokens(LPCWSTR pszTokens);
    WCHAR   ChSkip(void);
    WCHAR   ChParse(void);
    WCHAR   ChSkipWhite(void);
    WCHAR   ChPeekNext(ULONG cchFromCurrent);
    HRESULT HrAppendValue(WCHAR ch);

    // ----------------------------------------------------------------------------
    // Inline CStringParser Methods
    // ----------------------------------------------------------------------------
    void    SetIndex(ULONG iIndex) { m_iSource = iIndex; }
    WCHAR   ChSkip(LPCWSTR pszTokens) { SetTokens(pszTokens); return ChSkip(); }
    WCHAR   ChParse(LPCWSTR pszTokens, DWORD dwFlags);
    WCHAR   ChParse(LPCWSTR pszTokens) { SetTokens(pszTokens); return ChParse(); }
    WCHAR   ChParse(WCHAR chStart, WCHAR chEnd, DWORD dwFlags);
    ULONG   GetLength(void) { return m_cchSource; }
    ULONG   GetIndex(void) { return m_iSource; }
    LPCWSTR PszValue(void) { Assert(m_pszDest && L'\0' == m_pszDest[m_cchDest]); return m_pszDest; }
    ULONG   CchValue(void) { Assert(m_pszDest && L'\0' == m_pszDest[m_cchDest]); return m_cchDest; }
    ULONG   CbValue(void)  { Assert(m_pszDest && L'\0' == m_pszDest[m_cchDest]); return (m_cchDest * sizeof(WCHAR)); }
    void    FlagSet(DWORD dwFlags) { FLAGSET(m_dwFlags, dwFlags); }
    void    FlagClear(DWORD dwFlags) { FLAGCLEAR(m_dwFlags, dwFlags); }
    BOOL    FIsParseSpace(WCHAR ch, BOOL *pfCommentChar);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrGrowDestination(ULONG cch);
    
private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    ULONG           m_cRef;             // Reference Count
    LPCWSTR         m_pszSource;        // String to parse
    ULONG           m_cchSource;        // Length of pszString
    ULONG           m_iSource;          // Index into m_pszString
    LPWSTR          m_pszDest;          // Destination buffer
    ULONG           m_cchDest;          // Write Index/size of dest buffer
    ULONG           m_cchDestMax;        // Maximum size of m_pszDest
    DWORD           m_dwFlags;          // Parse String Flags
    WCHAR           m_szScratch[256];   // Scratch Buffer
    ULONG           m_cCommentNest;     // Nested comment parens
    LPCWSTR         m_pszTokens;        // The tokens
    LITERALINFOW    m_rLiteral;         // Literal Information
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inc\x16menu.h ===
/***********************************************************************
*
*   X16MENU.H
*
*       Copyright Microsoft Corporation 1997.  All Rights Reserved.
*
*   This module contains a set of functions to provide Win32 specific
*   windows menu handling ability.
*
*
*   This file provides following features:
*
*   - 32bit specific APIs
*   - Menu ID associated with Popup menu (32bit API only)
*   - Application-defined 32bit value associated with a menu item
*   - (TBD)Read values like hBitmap, hbmpChecked, hbmpUnchecked, MFS_HILIGHT
*
*   In order to provide these features, following things happen inside:
*
*   - Provide 32bit specific APIs
*   - Replace 16bit menu APIs to keep track of changes to menus
*   - (TBD)Hook WH_CBT to clean up when a window (and its menu) is destroyed
*
*   To use these functionalities, you need to do followings:
*
*   - If you want to associate ID to a popup menu in RC file, add one menu
*     item at the beginning of the popup menu.  Define the menu item to
*     have menu string of STR_POPUPMENUID and ID value for the popup menu.
*   - Call "InitX16Menu" in the beginning of your application (usually
*     before creating any Windows, and before entering message loop.)
*
***********************************************************************/

#ifndef __INC_X16MENU_H__
#define __INC_X16MENU_H__


#ifdef __cplusplus
extern "C"{
#endif

#define MIIM_STATE       0x00000001
#define MIIM_ID          0x00000002
#define MIIM_SUBMENU     0x00000004
#define MIIM_CHECKMARKS  0x00000008
#define MIIM_TYPE        0x00000010
#define MIIM_DATA        0x00000020

#define MF_DEFAULT          0x00001000L
#define MF_RIGHTJUSTIFY     0x00004000L

#define MFT_STRING          MF_STRING
#define MFT_BITMAP          MF_BITMAP
#define MFT_MENUBARBREAK    MF_MENUBARBREAK
#define MFT_MENUBREAK       MF_MENUBREAK
#define MFT_OWNERDRAW       MF_OWNERDRAW
#define MFT_RADIOCHECK      0x00000200L
#define MFT_SEPARATOR       MF_SEPARATOR
#define MFT_RIGHTORDER      0x00002000L
#define MFT_RIGHTJUSTIFY    MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED          0x00000003L
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         MF_CHECKED
#define MFS_HILITE          MF_HILITE
#define MFS_ENABLED         MF_ENABLED
#define MFS_UNCHECKED       MF_UNCHECKED
#define MFS_UNHILITE        MF_UNHILITE
#define MFS_DEFAULT         MF_DEFAULT

#if 0    // win16x now has this definition
typedef struct tagMENUITEMINFO
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE (4.0) or MIIM_FTYPE (>4.0)
    UINT    fState;         // used if MIIM_STATE
    UINT    wID;            // used if MIIM_ID
    HMENU   hSubMenu;       // used if MIIM_SUBMENU
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS
    DWORD   dwItemData;     // used if MIIM_DATA
    LPSTR   dwTypeData;     // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
    UINT    cch;            // used if MIIM_TYPE (4.0) or MIIM_STRING (>4.0)
}   MENUITEMINFO, FAR *LPMENUITEMINFO, CONST FAR *LPCMENUITEMINFO;

//typedef MENUITEMINFO MENUITEMINFOA;
//typedef MENUITEMINFO CONST FAR *LPCMENUITEMINFOA;
#endif


#define STR_POPUPMENUID  "Popup Menu ID"

#define DEFINE_POPUP(name,id)  POPUP name \
                               BEGIN \
                                   MENUITEM STR_POPUPMENUID id

// EXTERNAL HELPER APIs

void
WINAPI
X16MenuInitialize(
   HMENU hMenu
);

void
WINAPI
X16MenuDeInitialize(
   HMENU hMenu
);


// 16bit Old MENU APIs

BOOL
WINAPI __export
X16EnableMenuItem(
   HMENU hMenu,
   UINT idEnableItem,
   UINT uEnable
);

#ifndef DONT_USE_16BIT_MENU_WRAPPER
#define EnableMenuItem  X16EnableMenuItem
#endif


// 32bit New MENU APIs

BOOL
WINAPI
GetMenuItemInfo(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPMENUITEMINFO lpmii
);
//#define GetMenuItemInfoA  GetMenuItemInfo

BOOL
WINAPI
SetMenuItemInfo(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFO lpmii
);
//#define SetMenuItemInfoA  SetMenuItemInfo

BOOL
WINAPI
InsertMenuItem(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFO lpmii );
//#define InsertMenuItemA  InsertMenuItem

BOOL
WINAPI
GetMenuItemRect(
    HWND hWnd,
    HMENU hMenu,
    UINT uItem,
    LPRECT lprcItem
);

BOOL
WINAPI
CheckMenuRadioItem(
    HMENU hMenu,
    UINT idFirst,
    UINT idLast,
    UINT idCheck,
    UINT uFlags
);

#ifdef __cplusplus
}
#endif


#endif //__INC_X16MENU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pch.h ===
#include <windows.h>
#include <stdio.h>
#include <ole2.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\iconsole.h ===
#ifndef __MAIN_H
#define __MAIN_H

interface IRASTransport;
interface INNTPTransport;

extern IRASTransport  *g_pRAS;
extern INNTPTransport *g_pNNTP;

extern UINT g_msgSMTP;
extern UINT g_msgPOP3;
extern UINT g_msgRAS;
extern UINT g_msgNNTP;
extern UINT g_msgHTTPMail;

#define RAS_CONNECT WM_USER + 1000

#endif __MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDBCS_DIVIDE -D_MIMEOLE_ -D_IMNXPORT_ -D_WIN32_OE=0x0501 -D_INETCOMM_DLL_

!ifdef WIN16
C_DEFINES=$(C_DEFINES) -DWIN16_INETCOMM
!endif

WIN32_IE_VERSION=0x0500

!ifndef WIN16
INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(ATHROOT)\inc; \
    $(ATHROOT)\mailnews\extinc; \
    $(R)\inc; \
    $(R)\dll; \
    $(R)\common; \
    $(R)\mimeedit; \
    $(R)\mimeole; \
    $(R)\imnxport; \
    $(R)\fntcache; \
    $(INCLUDES)
!else
INCLUDES=\
    $(ATHROOT)\inc; \
    $(R)\inc; \
    $(R)\dll; \
    $(R)\mimeole; \
    $(R)\imnxport; \
    $(INCLUDES)
!endif

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin

PRECOMPILED_CXX=1
!ifndef WIN16
PRECOMPILED_OPTION=/Yupch.hxx /Fp$R\inc\$(_OBJ_DIR)\*\pch.pch
!else
PRECOMPILED_OPTION=/fh=$R\inc\$(_OBJ_DIR)\*\pch.pch
!endif
PRECOMPILED_TARGET=$(R)\inc\$(_OBJ_DIR)\*\pch.pch
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pch.cpp ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\nntpcall.h ===
// --------------------------------------------------------------------------------
// Nntpcall.h
// --------------------------------------------------------------------------------

#ifndef __NNTPCALL_H__
#define __NNTPCALL_H__

#include "imnxport.h"

HRESULT HrCreateNNTPTransport(INNTPTransport **ppNNTP);


class CNNTPCallback : public INNTPCallback
    {
private:
    ULONG       m_cRef;

public:
    CNNTPCallback(void);
    ~CNNTPCallback(void);

    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // INNTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPNNTPRESPONSE              pResponse);
    };

#endif // __NNTPCALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pop3call.h ===
// --------------------------------------------------------------------------------
// Pop3call.h
// --------------------------------------------------------------------------------
#ifndef __POP3CALL_H
#define __POP3CALL_H

#include "imnxport.h"

HRESULT HrCreatePOP3Transport(IPOP3Transport **ppPOP3);

// --------------------------------------------------------------------------------
// CPOP3Callback Implementation
// --------------------------------------------------------------------------------
class CPOP3Callback : public IPOP3Callback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPOP3Callback(void);
    ~CPOP3Callback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // IPOP3Callback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPPOP3RESPONSE              pResponse);
};

#endif // __POP3CALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\nntpcall.cpp ===
// --------------------------------------------------------------------------------
// Nntpcall.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "nntpcall.h"

// --------------------------------------------------------------------------------
// HrCreateNNTPTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateNNTPTransport(INNTPTransport **ppNNTP)
    {
    HRESULT          hr;
    CNNTPCallback   *pCallback = NULL;

    // Create the callback object
    pCallback = new CNNTPCallback();
    if (NULL == pCallback)
        {
        printf("Memory allocation failure\n");
        return (E_OUTOFMEMORY);
        }

    // Load the NNTP Transport
    hr = CoCreateInstance(CLSID_INNTPTransport, NULL, CLSCTX_INPROC_SERVER, 
                          IID_INNTPTransport, (LPVOID*) ppNNTP);
    if (FAILED(hr))
        {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_INNTPTransport\n");
        return (hr);
        }

    // Initialize the transport
    hr = (*ppNNTP)->InitNew(NULL, pCallback);
    if (FAILED(hr))
        {
        pCallback->Release();
        printf("Unable to initialize the transport\n");
        return (hr);
        }

    // Release our refcount on the callback since the transport has one now
    pCallback->Release();
    return (S_OK);
    }


// --------------------------------------------------------------------------------
// CNNTPCallback::CNNTPCallback
// --------------------------------------------------------------------------------
CNNTPCallback::CNNTPCallback(void)
    {
    m_cRef = 1;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::~CNNTPCallback
// --------------------------------------------------------------------------------
CNNTPCallback::~CNNTPCallback(void)
    {
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;
    
    // Bad param
    if (ppv == NULL)
        {
        hr = E_INVALIDARG;
        goto exit;
        }
    
    // Init
    *ppv=NULL;
    
    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    
    // IID_INNTPCallback
    else if (IID_INNTPCallback == riid)
        *ppv = (INNTPCallback *)this;
    
    // If not null, addref it and return
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
        }
    
    // No Interface
    hr = E_NOINTERFACE;
    
exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNNTPCallback::AddRef(void) 
    {
    return ++m_cRef;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNNTPCallback::Release(void) 
    {
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnLogonPrompt(LPINETSERVER pInetServer,
                                          IInternetTransport *pTransport)
    {
    printf("Enter User Name ('quit' to abort logon)>");
    scanf("%s", pInetServer->szUserName);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szUserName, "quit") == 0)
        return S_FALSE;
    
    printf("Enter Password ('quit' to abort logon)>");
    scanf("%s", pInetServer->szPassword);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szPassword, "quit") == 0)
        return S_FALSE;
    
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CNNTPCallback::OnPrompt(HRESULT hrError, LPCTSTR pszText, 
                                           LPCTSTR pszCaption, UINT uType,
                                           IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pIxpResult,
                                    IInternetTransport *pTransport)
    {
    HANDLE                      hConsole = INVALID_HANDLE_VALUE;
    CONSOLE_SCREEN_BUFFER_INFO  csbi;
    BOOL                        fChanged = FALSE;
    char                        szBuffer[256];
    DWORD                       dwWritten = 0;

    // Get a handle to the console window
    if (INVALID_HANDLE_VALUE != (hConsole = GetStdHandle(STD_OUTPUT_HANDLE)))
        {
        // Get the current attributes for the console
        if (GetConsoleScreenBufferInfo(hConsole, &csbi))
            {
            // Set the text color to be red on whatever background is currently
            // there
            fChanged = SetConsoleTextAttribute(hConsole, 
                                               (csbi.wAttributes & 0xF0) | FOREGROUND_RED | FOREGROUND_INTENSITY);
            }
        }

    wsprintf(szBuffer, "CNNTPCallback::OnError - Status: %d, hrResult: %08x\n", 
             ixpstatus, pIxpResult->hrResult);
    WriteConsole(hConsole, szBuffer, lstrlen(szBuffer), &dwWritten, NULL);

    // If we changed the screen attributes, then change them back
    if (fChanged)
        SetConsoleTextAttribute(hConsole, csbi.wAttributes);

    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnStatus(IXPSTATUS ixpstatus,
                                     IInternetTransport *pTransport)
    {
    INETSERVER                  rServer;
    HANDLE                      hConsole = INVALID_HANDLE_VALUE;
    CONSOLE_SCREEN_BUFFER_INFO  csbi;
    BOOL                        fChanged = FALSE;
    char                        szBuffer[256];
    DWORD                       dwWritten = 0;
    
    // Get a handle to the console window
    if (INVALID_HANDLE_VALUE != (hConsole = GetStdHandle(STD_OUTPUT_HANDLE)))
        {
        // Get the current attributes for the console
        if (GetConsoleScreenBufferInfo(hConsole, &csbi))
            {
            // Set the text color to be red on whatever background is currently
            // there
            fChanged = SetConsoleTextAttribute(hConsole, 
                (csbi.wAttributes & 0xF0) | FOREGROUND_GREEN | FOREGROUND_INTENSITY);
            }
        }

    pTransport->GetServerInfo(&rServer);
    
    switch(ixpstatus)
        {
        case IXP_FINDINGHOST:
            wsprintf(szBuffer, "Finding '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTING:
            wsprintf(szBuffer, "Connecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_SECURING:
            wsprintf(szBuffer, "Establishing secure connection to '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTED:
            wsprintf(szBuffer, "Connected '%s'\n", rServer.szServerName);
            break;
        case IXP_AUTHORIZING:
            wsprintf(szBuffer, "Authorizing '%s'...\n", rServer.szServerName);
            break;
        case IXP_AUTHRETRY:
            wsprintf(szBuffer, "Retrying Logon '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTING:
            wsprintf(szBuffer, "Disconnecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTED:
            wsprintf(szBuffer, "Disconnected '%s'\n", rServer.szServerName);
            break;
        }

    WriteConsole(hConsole, szBuffer, lstrlen(szBuffer), &dwWritten, NULL);

    // If we changed the screen attributes, then change them back
    if (fChanged)
        SetConsoleTextAttribute(hConsole, csbi.wAttributes);

    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnProgress(DWORD dwIncrement, DWORD dwCurrent, 
                                       DWORD dwMaximum, IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, 
                                      HRESULT hrResponse,
                                      IInternetTransport *pTransport)
    {
    INETSERVER rServer;

#if 1
    HANDLE     hOut;
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(hOut, &csbi);
    SetConsoleTextAttribute(hOut, FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | (0xf0 & csbi.wAttributes));
#endif 

    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
        {
        if (strstr(pszLine, "pass") || strstr(pszLine, "PASS"))
            printf("    %s[TX]: <Secret Password>\n", rServer.szServerName);
        else
            printf("    %s[TX]: %s", rServer.szServerName, pszLine);
        }
    else if (CMD_RESP == cmdtype)
        printf("    %s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);

#if 1
    SetConsoleTextAttribute(hOut, csbi.wAttributes);
#endif

    return S_OK;
    }

// --------------------------------------------------------------------------------
// CNNTPCallback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnTimeout(DWORD *pdwTimeout, 
                                      IInternetTransport *pTransport)
    {
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CNNTPCallback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPCallback::OnResponse(LPNNTPRESPONSE pResponse)
    {
    switch(pResponse->state)
        {
        case NS_DISCONNECTED:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_CONNECT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_AUTHINFO:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_GROUP:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_GROUP_RESP - rGroup.dwFirst  = %d\n"
                       "                rGroup.dwLast   = %d\n"
                       "                rGroup.dwCount  = %d\n"
                       "                rGroup.pszGroup = %s\n\n",
                       pResponse->rGroup.dwFirst, pResponse->rGroup.dwLast, 
                       pResponse->rGroup.dwCount, pResponse->rGroup.pszGroup);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEXT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_NEXT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rNext.dwArticleNum, pResponse->rNext.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;
            
        case NS_LAST:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_LAST_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_STAT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_STAT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_LIST:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_LIST_DATA_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rList.cLines; i++)
                        printf("%s\n", pResponse->rList.rgszLines[i]);
                    }

                g_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
            
        case NS_LISTGROUP:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_GROUP_SELECTED)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rListGroup.cArticles; i++)
                        printf("%d\n", pResponse->rListGroup.rgArticles[i]);
                    }

                g_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_DATE:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\nNS_DATE - %02d/%02d/%04d %02d:%02d:%02d\n\n",
                       pResponse->rDate.wMonth, pResponse->rDate.wDay,
                       pResponse->rDate.wYear, pResponse->rDate.wHour, 
                       pResponse->rDate.wMinute, pResponse->rDate.wSecond);
                }

            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_MODE:
            printf("\nNS_MODE\n\n");
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEWGROUPS:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_NEWNEWSGROUPS_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rNewgroups.cLines; i++)
                        printf("%s\n", pResponse->rNewgroups.rgszLines[i]);
                    }

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;                       

        case NS_ARTICLE:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_ARTICLE_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    printf("%s", pResponse->rArticle.pszLines);

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_HEAD:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_HEAD_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    printf("%s", pResponse->rArticle.pszLines);

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_BODY:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_BODY_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    printf("%s", pResponse->rArticle.pszLines);
                    }
                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_IDLE:
            printf("NS_IDLE\n");
            printf("Why would we ever be here?");
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_HEADERS:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rHeaders.cHeaders; i++)
                        {
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwArticleNum);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszSubject);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszFrom);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszDate);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszMessageId);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszReferences);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwBytes);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwLines);
                        if (pResponse->rHeaders.rgHeaders[i].pszXref)
                            printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszXref);

                        printf("\n\n");
                        }
                    }

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_XHDR:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rXhdr.cHeaders; i++)
                        {
                        printf("%6d %s\n", pResponse->rXhdr.rgHeaders[i].dwArticleNum,
                               pResponse->rXhdr.rgHeaders[i].pszHeader);
                        }
                    }

                g_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
        
        case NS_POST:
            printf("%s\n", pResponse->rIxpResult.pszResponse);
            g_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_QUIT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP,0, 0);
            break;
        }
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\pop3call.cpp ===
// --------------------------------------------------------------------------------
// Pop3call.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "pop3call.h"

// --------------------------------------------------------------------------------
// HrCreatePOP3Transport
// --------------------------------------------------------------------------------
HRESULT HrCreatePOP3Transport(IPOP3Transport **ppPOP3)
{
    // Locals
    HRESULT             hr;
    CPOP3Callback      *pCallback=NULL;

    // Create callback object
    pCallback = new CPOP3Callback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_IPOP3Transport, NULL, CLSCTX_INPROC_SERVER, IID_IPOP3Transport, (LPVOID *)ppPOP3);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IPOP3Transport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppPOP3)->InitNew(NULL, pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IPOP3Transport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::CPOP3Callback
// --------------------------------------------------------------------------------
CPOP3Callback::CPOP3Callback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::~CPOP3Callback
// --------------------------------------------------------------------------------
CPOP3Callback::~CPOP3Callback(void)
{
}

// --------------------------------------------------------------------------------
// CPOP3Callback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_IPOP3Callback
    else if (IID_IPOP3Callback == riid)
        *ppv = (IPOP3Callback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Callback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Callback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    printf("Enter User Name ('quit' to abort logon)>");
    scanf("%s", pInetServer->szUserName);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szUserName, "quit") == 0)
        return S_FALSE;

    printf("Enter Password ('quit' to abort logon)>");
    scanf("%s", pInetServer->szPassword);
    fflush(stdin);
    if (lstrcmpi(pInetServer->szPassword, "quit") == 0)
        return S_FALSE;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CPOP3Callback::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnError(
        IXPSTATUS               ixpstatus,
        LPIXPRESULT             pIxpResult,
        IInternetTransport     *pTransport)
{
    printf("CPOP3Callback::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnStatus(
        IXPSTATUS               ixpstatus,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;

    pTransport->GetServerInfo(&rServer);

    switch(ixpstatus)
    {
    case IXP_FINDINGHOST:
        printf("Finding '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTING:
        printf("Connecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_SECURING:
        printf("Establishing secure connection to '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTED:
        printf("Connected '%s'\n", rServer.szServerName);
        break;
    case IXP_AUTHORIZING:
        printf("Authorizing '%s'...\n", rServer.szServerName);
        break;
    case IXP_AUTHRETRY:
        printf("Retrying Logon '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTING:
        printf("Disconnecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTED:
        printf("Disconnected '%s'\n", rServer.szServerName);
        PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, IXP_DISCONNECTED, 0);
        PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_QUIT, 0);
        break;
    }
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnProgress(
        DWORD                   dwIncrement,
        DWORD                   dwCurrent,
        DWORD                   dwMaximum,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnCommand(
        CMDTYPE                 cmdtype,                                            
        LPSTR                   pszLine,
        HRESULT                 hrResponse,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
    {
        if (strstr(pszLine, "pass") || strstr(pszLine, "PASS"))
            printf("%s[TX]: <Secret Password>\n", rServer.szServerName);
        else
            printf("%s[TX]: %s", rServer.szServerName, pszLine);
    }
    else if (CMD_RESP == cmdtype)
        printf("%s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnTimeout(
        DWORD                  *pdwTimeout,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CPOP3Callback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Callback::OnResponse(
        LPPOP3RESPONSE              pResponse)
{
    switch(pResponse->command)
    {
    case POP3_NONE:
        break;

    case POP3_BANNER:
        break;

    case POP3_CONNECTED:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_CONNECTED, 0);
        break;

    case POP3_RSET:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_RSET, 0);
        break;

    case POP3_QUIT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_QUIT, 0);
        break;

    case POP3_LIST:
        // 0 is invalid for dwPopId
        if (pResponse->rListInfo.dwPopId)
        {
            printf("OnResponse::POP3_LIST - dwPopId = %d\n", pResponse->rListInfo.dwPopId);
            printf("OnResponse::POP3_LIST - cbSize = %d\n", pResponse->rListInfo.cbSize);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_LIST, 0);
        break;

    case POP3_UIDL:
        // 0 is invalid for dwPopId
        if (pResponse->fValidInfo)
        {
            printf("OnResponse::POP3_UIDL - dwPopId = %d\n", pResponse->rUidlInfo.dwPopId);
            printf("OnResponse::POP3_UIDL - pszUidl = %s\n", pResponse->rUidlInfo.pszUidl);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_UIDL, 0);
        break;

    case POP3_DELE:
        // 0 is invalid for dwPopId
        if (pResponse->fValidInfo)
            printf("OnResponse::POP3_DELE - dwPopId = %d\n", pResponse->dwPopId);
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_DELE, 0);
        break;

    case POP3_STAT:
        if (pResponse->fDone)
        {
            printf("OnResponse::POP3_STAT - cMessages = %d\n", pResponse->rStatInfo.cMessages);
            printf("OnResponse::POP3_STAT - cbMessages = %d\n", pResponse->rStatInfo.cbMessages);
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_STAT, 0);
        }
        break;

    case POP3_TOP:
        if (pResponse->fValidInfo)
        {
            if (pResponse->rTopInfo.pszLines)
                printf("%s", pResponse->rTopInfo.pszLines);
            if (pResponse->rTopInfo.cPreviewLines && pResponse->rTopInfo.fHeader && pResponse->rTopInfo.fBody)
                printf("%d Total\n", pResponse->rTopInfo.cbSoFar);
            else if (pResponse->rTopInfo.cPreviewLines == 0 && pResponse->rTopInfo.fHeader)
                printf("%d Total\n", pResponse->rTopInfo.cbSoFar);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_TOP, 0);
        break;

    case POP3_RETR:
        if (pResponse->fValidInfo)
        {
            if (pResponse->rRetrInfo.pszLines)
                printf("%s", pResponse->rRetrInfo.pszLines);
            if (pResponse->rRetrInfo.fHeader && pResponse->rRetrInfo.fBody)
                printf("%d Total\n", pResponse->rRetrInfo.cbSoFar);
        }
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgPOP3, POP3_RETR, 0);
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\rascall.cpp ===
// --------------------------------------------------------------------------------
// Rascall.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "rascall.h"

// --------------------------------------------------------------------------------
// HrCreateRASTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateRASTransport(IRASTransport **ppRAS)
{
    // Locals
    HRESULT             hr;
    CRASCallback      *pCallback=NULL;

    // Create callback object
    pCallback = new CRASCallback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_IRASTransport, NULL, CLSCTX_INPROC_SERVER, IID_IRASTransport, (LPVOID *)ppRAS);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IRASTransport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppRAS)->InitNew(pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_IRASTransport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CRASCallback::CRASCallback
// --------------------------------------------------------------------------------
CRASCallback::CRASCallback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CRASCallback::~CRASCallback
// --------------------------------------------------------------------------------
CRASCallback::~CRASCallback(void)
{
}

// --------------------------------------------------------------------------------
// CRASCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CRASCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_IRASCallback
    else if (IID_IRASCallback == riid)
        *ppv = (IRASCallback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASCallback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CRASCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASCallback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

STDMETHODIMP CRASCallback::OnReconnect(
        LPSTR                   pszCurrentConnectoid,
        LPSTR                   pszNewConnectoid,
		IRASTransport          *pTransport)
{
    printf("CRASCallback::OnReconnect - %s --> %s\n", pszCurrentConnectoid, pszNewConnectoid);
    return S_OK;
}

STDMETHODIMP CRASCallback::OnLogonPrompt(
        LPIXPRASLOGON           pRasLogon,
        IRASTransport          *pTransport)
{
    printf("CRASCallback::OnLogonPrompt\n");
    return S_OK;
}

STDMETHODIMP CRASCallback::OnRasDialStatus(
        RASCONNSTATE            rasconnstate, 
        DWORD                   dwError, 
        IRASTransport          *pTransport)
{
    printf("CRASCallback::OnRasDialStatus - State: %d, dwError: %d\n", rasconnstate, dwError);
    if (dwError || (rasconnstate == RASCS_Connected || rasconnstate == RASCS_Disconnected))
    {
        if (dwError)
        {
            CHAR szError[1024];
            DWORD dwResult;

            g_pRAS->GetRasErrorString(dwError, szError, 1024, &dwResult);
            if (dwResult == 0)
                printf("Ras Error: %s\n", szError);
        }
        PostThreadMessage(GetCurrentThreadId(), g_msgRAS, RAS_CONNECT, 0);
    }
    return S_OK;
}

STDMETHODIMP CRASCallback::OnDisconnect(
        LPSTR                   pszCurrentConnectoid,
        boolean                 fConnectionOwner,
		IRASTransport          *pTransport)
{
    printf("CRASCallback::OnDisconnect - %s, Connection Owner: %d\n", pszCurrentConnectoid, fConnectionOwner);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\main.cpp ===
// --------------------------------------------------------------------------------
// Main.cpp
// --------------------------------------------------------------------------------
#define INITGUID
#include "pch.h"
#include "windowsx.h"
#include <initguid.h>
#include "imnxport.h"
#include "smtpcall.h"
#include "pop3call.h"
#include "nntpcall.h"
#include "iconsole.h"
#include "rascall.h"
#include "httpcall.h"

// Globals
IImnAccountManager  *g_pAcctMan=NULL;
ISMTPTransport      *g_pSMTP=NULL;
IPOP3Transport      *g_pPOP3=NULL;
IRASTransport       *g_pRAS=NULL;
INNTPTransport      *g_pNNTP=NULL;
IHTTPMailTransport  *g_pHTTPMail=NULL;
UINT                 g_msgSMTP=0;
UINT                 g_msgPOP3=0;
UINT                 g_msgRAS=0;
UINT                 g_msgNNTP=0;
UINT                 g_msgHTTPMail=0;

// Prototypes
void ImnxportCommandShell(LPSTR pszShell);
void SMTPCommandShell(void);
void POP3CommandShell(void);
void NNTPCommandShell(void);
void IMAPCommandShell(void);
void RASCommandShell(void);
void HTTPMailCommandShell(void);

void ConnectToSMTPTransport(LPINETSERVER pServer);
void WaitForCompletion(UINT uiMsg, DWORD wparam);

void __cdecl main(int argc, char *argv[])
{
    // Locals
    HRESULT         hr;

    // OLE Init
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf("CoInitialize - FAILED\n");
        exit(1);
    }

    // Register completion message
    g_msgSMTP = RegisterWindowMessage("SMTPTransport_Notify");
    g_msgPOP3 = RegisterWindowMessage("POP3Transport_Notify");
    g_msgRAS  = RegisterWindowMessage("RASTransport_Notify");
    g_msgNNTP = RegisterWindowMessage("NNTPTransport_Notify");
    g_msgHTTPMail = RegisterWindowMessage("HTTPMailTransport_Notify");

    // Load the account manager
    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (LPVOID *)&g_pAcctMan);
    if (FAILED(hr))
    {
        printf("Unable to load the IMN Account Manager.\n");
        goto exit;
    }

    // Init the account manager
    hr = g_pAcctMan->Init(NULL);
    if (FAILED(hr))
    {
        printf("Unable to initialize the IMN Account Manager.\n");
        goto exit;
    }

    // Create smtp transport
    hr = HrCreateSMTPTransport(&g_pSMTP);
    if (FAILED(hr))
        goto exit;

    // Create pop3 transport
    hr = HrCreatePOP3Transport(&g_pPOP3);
    if (FAILED(hr))
        goto exit;

    // Create ras transport
    hr = HrCreateRASTransport(&g_pRAS);
    if (FAILED(hr))
        goto exit;

    // Create NNTP transport
    hr = HrCreateNNTPTransport(&g_pNNTP);
    if (FAILED(hr))
        goto exit;

    hr = HrCreateHTTPMailTransport(&g_pHTTPMail);
    if (FAILED(hr))
        goto exit;

    // Our console IO manager
    if (argc == 2)
        ImnxportCommandShell(argv[1]);
    else
        ImnxportCommandShell(NULL);

exit:
    // Cleanup
    if (g_pSMTP)
        g_pSMTP->Release();
    if (g_pPOP3)
        g_pPOP3->Release();
    if (g_pRAS)
        g_pRAS->Release();
    if (g_pNNTP)
        g_pNNTP->Release();
    if (g_pHTTPMail)
        g_pHTTPMail->Release();
    if (g_pAcctMan)
        g_pAcctMan->Release();

    // CoUninitialize
    CoUninitialize();

    // Done
    exit(1);
}

// --------------------------------------------------------------------------------
// HrByteToStream
// --------------------------------------------------------------------------------
HRESULT HrByteToStream(LPSTREAM *lppstm, LPBYTE lpb, ULONG cb)
{
    // Locals
    HRESULT hr=S_OK;
    LARGE_INTEGER  liOrigin = {0,0};

    // Create H Global Stream
    hr = CreateStreamOnHGlobal (NULL, TRUE, lppstm);
    if (FAILED(hr))
        goto exit;

    // Write String
    hr = (*lppstm)->Write (lpb, cb, NULL);
    if (FAILED(hr))
        goto exit;

    // Rewind the steam
    hr = (*lppstm)->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    if (FAILED(hr))
        goto exit;

exit:
    // Done
    return hr;
}

void ImnxportCommandShellHelp(void)
{
    printf("Valid commands:\nSMTP\nPOP3\nNNTP\nIMAP\nRAS\nHTTPMail\nEXIT\n\n");
}

// Main command handler
void ImnxportCommandShell(LPSTR pszShell)
{
    // Locals
    char    szCommand[50];

    // Title
    printf("\nMicrosoft(R) Internet Mail and News Command Shell.\n");
    printf("(C) Copyright 1985-1996 Microsoft Corp.\n");
    printf("Type ? for help.\n\n");

IMNXPORTPrompt:
    if (!pszShell)
        {
        // Prompt
        printf("Internet> ");
        scanf("%s", szCommand);
        fflush(stdin);
        }
    else
        lstrcpy(szCommand, pszShell);

    printf("\n");

    // Handle Prompt
    if (lstrcmpi(szCommand, "SMTP") == 0)
        SMTPCommandShell();
    else if (lstrcmpi(szCommand, "POP3") == 0)
        POP3CommandShell();
    else if (lstrcmpi(szCommand, "IMAP") == 0)
        IMAPCommandShell();
    else if (lstrcmpi(szCommand, "NNTP") == 0)
        NNTPCommandShell();
    else if (lstrcmpi(szCommand, "RAS") == 0)
        RASCommandShell();
    else if (lstrcmpi(szCommand, "HTTPMail") == 0 || lstrcmpi(szCommand, "HTTP") == 0)
        HTTPMailCommandShell();
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        ImnxportCommandShellHelp();

    // RePrompt
    pszShell = NULL;
    goto IMNXPORTPrompt;
}

// SMTP Command Help
void SMTPCommandShellHelp(void)
{
    printf("Valid commands:\nACCOUNTS\nCONNECT\nQUIT\nRSET\nSENDMESSAGE\nEHLO\nHELO\nMAIL\nRCPT\nDATA\nSTREAM\nCUSTOM\nEXIT\n\n");
}

// SMTP Command Handler
void SMTPCommandShell(void)
{
    // Locals
    INETSERVER      rServer;
    IImnAccount    *pAccount=NULL;
    char            szCommand[50];

    // Title
    printf("Microsoft(R) SMTP Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
SMTPPrompt:
    printf("SMTP>");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "ACCOUNTS") == 0)
        g_pAcctMan->AccountListDialog(NULL, NULL);

    else if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name>");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto SMTPPrompt;
        }

        if (FAILED(g_pSMTP->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto SMTPPrompt;
        }

        if (FAILED(g_pSMTP->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto SMTPPrompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgSMTP, SMTP_CONNECTED);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "EHLO") == 0)
    {
        if (FAILED(g_pSMTP->CommandEHLO()))
        {
            printf("ISMTPTransport::CommandEHLO failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_EHLO);
    }
    else if (lstrcmpi(szCommand, "DOT") == 0)
    {
        if (FAILED(g_pSMTP->CommandDOT()))
        {
            printf("ISMTPTransport::CommandDOT failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_DOT);
    }
    else if (lstrcmpi(szCommand, "DATA") == 0)
    {
        if (FAILED(g_pSMTP->CommandDATA()))
        {
            printf("ISMTPTransport::CommandDATA failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_DATA);
    }
    else if (lstrcmpi(szCommand, "HELO") == 0)
    {
        if (FAILED(g_pSMTP->CommandHELO()))
        {
            printf("ISMTPTransport::CommandHELO failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_HELO);
    }
    else if (lstrcmpi(szCommand, "QUIT") == 0)
    {
        if (FAILED(g_pSMTP->CommandQUIT()))
        {
            printf("ISMTPTransport::CommandQUIT failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_QUIT);
    }
    else if (lstrcmpi(szCommand, "RSET") == 0)
    {
        if (FAILED(g_pSMTP->CommandRSET()))
        {
            printf("ISMTPTransport::CommandRSET failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_RSET);
    }
    else if (lstrcmpi(szCommand, "MAIL") == 0)
    {
        char szEmail[CCHMAX_EMAIL_ADDRESS];

        printf("Enter Sender Email Address>");
        scanf("%s", szEmail);
        fflush(stdin);
        if (FAILED(g_pSMTP->CommandMAIL(szEmail)))
        {
            printf("ISMTPTransport::CommandMAIL failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_MAIL);
    }

    else if (lstrcmpi(szCommand, "RCPT") == 0)
    {
        char szEmail[CCHMAX_EMAIL_ADDRESS];

        while(1)
        {
            printf("Enter Recipient Email ('Done')>");
            scanf("%s", szEmail);
            fflush(stdin);
            if (lstrcmpi(szEmail, "DONE") == 0)
                break;

            if (FAILED(g_pSMTP->CommandRCPT(szEmail)))
            {
                printf("ISMTPTransport::CommandRCPT failed.\n");
                goto SMTPPrompt;
            }
            WaitForCompletion(g_msgSMTP, SMTP_RCPT);
        }
    }

    else if (lstrcmpi(szCommand, "SENDMESSAGE") == 0)
    {
        INETADDR            rgAddress[11];
        SMTPMESSAGE         rMessage;
        CHAR                szText[1024];

        ZeroMemory(&rgAddress, sizeof(rgAddress));
        ZeroMemory(&rMessage, sizeof(rMessage));

        printf("Enter Sender Email Address>");
        rgAddress[0].addrtype = ADDR_FROM;
        scanf("%s", rgAddress[0].szEmail);
        fflush(stdin);

        rMessage.rAddressList.prgAddress = rgAddress;
        rMessage.rAddressList.cAddress = 1;
        while(rMessage.rAddressList.cAddress < 11)
        {
            INT i = rMessage.rAddressList.cAddress;
            printf("(%d of 10) Enter Recipient Email ('Done')>", i);
            rgAddress[i].addrtype = ADDR_TO;
            scanf("%s", rgAddress[i].szEmail);
            fflush(stdin);
            if (lstrcmpi(rgAddress[i].szEmail, "DONE") == 0)
                break;
            rMessage.rAddressList.cAddress++;
        }

        printf("Enter Message Text, end with pressing RETURN:\n");
        scanf("%s", szText);
        fflush(stdin);

        rMessage.cbSize = lstrlen(szText);

        if (FAILED(HrByteToStream(&rMessage.pstmMsg, (LPBYTE)szText, rMessage.cbSize + 1)))
        {
            printf("HrByteToStream failed.\n");
            goto SMTPPrompt;
        }

        if (FAILED(g_pSMTP->SendMessage(&rMessage)))
        {
            rMessage.pstmMsg->Release();
            printf("ISMTPTransport::SendMessage failed.\n");
            goto SMTPPrompt;
        }
        WaitForCompletion(g_msgSMTP, SMTP_SEND_MESSAGE);
        rMessage.pstmMsg->Release();
    }


    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        SMTPCommandShellHelp();

    // Go back to the prompt
    goto SMTPPrompt;
}

// POP3 Command Help
void POP3CommandShellHelp(void)
{
    printf("Valid commands:\nACCOUNTS\nCONNECT\nQUIT\nSTAT\nLIST\nUIDL\nTOP\nRETR\nMARK\n\n");
}

POP3CMDTYPE GetCommandType(LPDWORD pdwPopId)
{
    INT i;
    *pdwPopId = 0;
    printf("(1) - POP3CMD_GET_POPID\n(2) - POP3CMD_GET_MARKED\n(3) - POP3CMD_GET_ALL\nSelect Command Type>");
    scanf("%d", &i);
    fflush(stdin);
    if (i == 1)
    {
        printf("Enter PopId>");
        scanf("%d", pdwPopId);
        return POP3CMD_GET_POPID;
    }
    else if (i == 2)
        return POP3CMD_GET_MARKED;
    return POP3CMD_GET_ALL;
}

// POP3 Command Shell
void POP3CommandShell(void)
{
    // Locals
    DWORD           dwPopId;
    POP3CMDTYPE     cmdtype;
    INETSERVER      rServer;
    IImnAccount    *pAccount=NULL;
    char            szCommand[50];

    // Title
    printf("Microsoft(R) POP3 Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
POP3Prompt:
    printf("POP3>");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "ACCOUNTS") == 0)
        g_pAcctMan->AccountListDialog(NULL, NULL);

    else if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name>");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto POP3Prompt;
        }

        if (FAILED(g_pPOP3->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto POP3Prompt;
        }

        if (FAILED(g_pPOP3->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto POP3Prompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgPOP3, POP3_CONNECTED);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "QUIT") == 0)
    {
        if (FAILED(g_pPOP3->CommandQUIT()))
        {
            printf("IPOP3Transport::CommandQUIT failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_QUIT);
    }
    else if (lstrcmpi(szCommand, "STAT") == 0)
    {
        if (FAILED(g_pPOP3->CommandSTAT()))
        {
            printf("IPOP3Transport::CommandSTAT failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_STAT);
    }
    else if (lstrcmpi(szCommand, "LIST") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandLIST(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandLIST failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_LIST);
    }
    else if (lstrcmpi(szCommand, "UIDL") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandUIDL(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandUIDL failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_UIDL);
    }
    else if (lstrcmpi(szCommand, "DELE") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandDELE(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandDELE failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_DELE);
    }
    else if (lstrcmpi(szCommand, "TOP") == 0)
    {
        INT cLines;
        cmdtype = GetCommandType(&dwPopId);
        printf("Number of Lines to Preview>");
        scanf("%d", &cLines);
        fflush(stdin);
        if (FAILED(g_pPOP3->CommandTOP(cmdtype, dwPopId, cLines)))
        {
            printf("IPOP3Transport::CommandTOP failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_TOP);
    }
    else if (lstrcmpi(szCommand, "RETR") == 0)
    {
        cmdtype = GetCommandType(&dwPopId);
        if (FAILED(g_pPOP3->CommandRETR(cmdtype, dwPopId)))
        {
            printf("IPOP3Transport::CommandRETR failed.\n");
            goto POP3Prompt;
        }
        WaitForCompletion(g_msgPOP3, POP3_RETR);
    }
    else if (lstrcmpi(szCommand, "MARK") == 0)
    {
        INT     type, popid, flag;
        POP3MARKTYPE marktype;

        printf("(1) - POP3_MARK_FOR_TOP\n");
        printf("(2) - POP3_MARK_FOR_RETR\n");
        printf("(3) - POP3_MARK_FOR_DELE\n");
        printf("(4) - POP3_MARK_FOR_UIDL\n");
        printf("(5) - POP3_MARK_FOR_LIST\n");
        printf("Select MarkItem Type>");
        scanf("%d", &type);
        fflush(stdin);
        printf("Enter PopId>");
        scanf("%d", &popid);
        fflush(stdin);
        printf("Enable or Disable Marked Item (1 = Enable, 0 = Disable)>");
        scanf("%d", &flag);
        fflush(stdin);
        if (1 == type) marktype = POP3_MARK_FOR_TOP;
        else if (2 == type) marktype = POP3_MARK_FOR_RETR;
        else if (3 == type) marktype = POP3_MARK_FOR_DELE;
        else if (4 == type) marktype = POP3_MARK_FOR_UIDL;
        else if (5 == type) marktype = POP3_MARK_FOR_LIST;
        else
        {
            printf("Invalid MarkItemType!\n");
            goto POP3Prompt;
        }

        if (FAILED(g_pPOP3->MarkItem(marktype, popid, flag)))
        {
            printf("IPOP3Transport::MarkItem failed!\n");
            goto POP3Prompt;
        }
    }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        POP3CommandShellHelp();

    // Go back to the prompt
    goto POP3Prompt;
}

// NNTP Command Help
void NNTPCommandShellHelp(void)
{
    printf("Valid commands:\nACCOUNTS\nCONNECT\nGROUP\nNEXT\nLAST\n"
           "STAT\nLIST\nMODE\nDATE\nARTICLE\nHEAD\nBODY\nHEADERS\nXHDR\n"
           "POST\nQUIT\n\n");
}

void NNTPCommandShell(void)
{
    // Locals
    INETSERVER      rServer;
    IImnAccount    *pAccount=NULL;
    char            szCommand[50];

    // Title
    printf("Microsoft(R) NNTP Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
NNTPPrompt:
    printf("NNTP> ");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "ACCOUNTS") == 0)
        g_pAcctMan->AccountListDialog(GetDesktopWindow(), NULL);

    else if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name> ");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto NNTPPrompt;
        }

        if (FAILED(g_pNNTP->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto NNTPPrompt;
        }

        if (FAILED(g_pNNTP->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto NNTPPrompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgNNTP, 0);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "QUIT") == 0)
    {
        if (FAILED(g_pNNTP->CommandQUIT()))
        {
            printf("INNTPTransport::CommandQUIT failed.\n");
            goto NNTPPrompt;
        }
        WaitForCompletion(g_msgNNTP, NS_DISCONNECTED);
    }
    else if (lstrcmpi(szCommand, "AUTHINFO") == 0)
        {
        DWORD dwType;
        char  szUserName[256];
        char  szPassword[256];
        NNTPAUTHINFO authinfo;

        printf("(1) AUTHINFO USER/PASS\n");
        printf("(2) AUTHINFO SIMPLE\n");
        printf("(3) AUTHINFO TRANSACT\n");
        printf("Select type > ");
        scanf("%d", &dwType);
        fflush(stdin);

        authinfo.authtype = (dwType == 1) ? AUTHTYPE_USERPASS : ((dwType == 2) ? AUTHTYPE_SIMPLE : AUTHTYPE_SASL);
        if (dwType < 3)
            {
            printf("User Name > ");
            scanf("%s", &szUserName);
            fflush(stdin);
            printf("Password > ");
            scanf("%s", &szPassword);

            authinfo.pszUser = szUserName;
            authinfo.pszPass = szPassword;
            }

        if (FAILED(g_pNNTP->CommandAUTHINFO(&authinfo)))
            {
            printf("INNTPTransport::CommandAUTHINFO() failed\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "GROUP") == 0)
        {
        char szGroup[256];
        printf("Enter Group Name> ");
        scanf("%s", szGroup);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandGROUP(szGroup)))
            {
            printf("INNTPTransport::CommandGROUP failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_GROUP);
        }
    else if (lstrcmpi(szCommand, "NEXT") == 0)
        {
        if (FAILED(g_pNNTP->CommandNEXT()))
            {
            printf("INNTPTransport::CommandNEXT failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_NEXT);
        }
    else if (lstrcmpi(szCommand, "LAST") == 0)
        {
        if (FAILED(g_pNNTP->CommandLAST()))
            {
            printf("INNTPTransport::CommandLAST failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_LAST);
        }
    else if (lstrcmpi(szCommand, "STAT") == 0)
        {
        char szStat[256];
        ARTICLEID aid;

        ZeroMemory(szStat, sizeof(szStat));
        ZeroMemory(&aid, sizeof(aid));

        printf("Enter article> ");
        scanf("%s", szStat);
        fflush(stdin);

        if (0 == sscanf(szStat, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szStat;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandSTAT(*szStat ? &aid : NULL)))
            {
            printf("INNTPTransport::CommandSTAT failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_STAT);
        }
    else if (lstrcmpi(szCommand, "LIST") == 0)
        {
        if (FAILED(g_pNNTP->CommandLIST(NULL)))
            {
            printf("INNTPTransport::CommandLIST failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "LISTGROUP") == 0)
        {
        char szGroup[256];
        printf("Enter Group Name> ");
        scanf("%s", szGroup);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandLISTGROUP(szGroup)))
            {
            printf("INNTPTransport::CommandLISTGROUP failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "LISTARG") == 0)
        {
        char szArg[256];
        ZeroMemory(szArg, 256);

        printf("Enter Arguments> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandLIST(szArg)))
            {
            printf("INNTPTransport::CommandLIST failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "DATE") == 0)
        {
        if (FAILED(g_pNNTP->CommandDATE()))
            {
            printf("INNTPTransport::CommandDATE failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_DATE);
        }
    else if (lstrcmpi(szCommand, "MODE") == 0)
        {
        char szArg[256];
        ZeroMemory(szArg, 256);

        printf("Enter Arguments> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (FAILED(g_pNNTP->CommandMODE(szArg)))
            {
            printf("INNTPTransport::CommandMODE failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, NS_MODE);
        }
    else if (lstrcmpi(szCommand, "NEWGROUPS") == 0)
        {
        SYSTEMTIME st = {1996, 11, 0, 1, 0, 0, 0, 0};

        if (FAILED(g_pNNTP->CommandNEWGROUPS(&st, "<alt>")))
            {
            printf("INNTPTransport::CommandNEWGROUPS failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "ARTICLE") == 0)
        {
        char szArg[256];
        ARTICLEID aid;
        ZeroMemory(szArg, 256);

        printf("Enter article number> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (0 == sscanf(szArg, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szArg;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandARTICLE(&aid)))
            {
            printf("INNTPTransport::CommandARTICLE failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "HEAD") == 0)
        {
        char szArg[256];
        ARTICLEID aid;
        ZeroMemory(szArg, 256);

        printf("Enter article number> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (0 == sscanf(szArg, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szArg;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandHEAD(&aid)))
            {
            printf("INNTPTransport::CommandHEAD failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "BODY") == 0)
        {
        char szArg[256];
        ARTICLEID aid;
        ZeroMemory(szArg, 256);

        printf("Enter article number> ");
        scanf("%s", szArg);
        fflush(stdin);

        if (0 == sscanf(szArg, "%d", &aid.dwArticleNum))
            {
            aid.idType = AID_MSGID;
            aid.pszMessageId = szArg;
            }
        else
            aid.idType = AID_ARTICLENUM;

        if (FAILED(g_pNNTP->CommandBODY(&aid)))
            {
            printf("INNTPTransport::CommandBODY failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "HEADERS") == 0)
        {
        char szArg1[30], szArg2[30];
        RANGE range;
        
        printf("Enter starting article number> ");
        scanf("%s", szArg1);
        fflush(stdin);

        printf("Enter ending article number (0 for a single article)> ");
        scanf("%s", szArg2);
        fflush(stdin);

        range.idType = (atol(szArg2) == 0 ? RT_SINGLE : RT_RANGE);
        range.dwFirst = atol(szArg1);
        range.dwLast = atol(szArg2);

        if (FAILED(g_pNNTP->GetHeaders(&range)))
            {
            printf("INNTPTransport::GetHeaders() failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "XHDR") == 0)
        {
        char szHdr[256];
        char szArg1[30], szArg2[30];
        RANGE range;
        HRESULT hr;

        // I tested this scenario as well -- SteveSer
        // hr = g_pNNTP->CommandXHDR("Subject", NULL, "<01bb9b7a$7767b020$ff22369d@a-dmay>");

        printf("Enter header> ");
        scanf("%s", szHdr);
        
        printf("Enter starting article number (0 for the current article)> ");
        scanf("%s", szArg1);
        fflush(stdin);

        if (atol(szArg1) != 0)
            {
            printf("Enter ending article number (0 for a single article)> ");
            scanf("%s", szArg2);
            fflush(stdin);
            }

        if (atol(szArg1) == 0)
            hr = g_pNNTP->CommandXHDR(szHdr, NULL, NULL);
        else
            {
            range.idType = (atol(szArg2) == 0 ? RT_SINGLE : RT_RANGE);
            range.dwFirst = atol(szArg1);
            range.dwLast = atol(szArg2);
            hr = g_pNNTP->CommandXHDR(szHdr, &range, NULL);
            }

        if (FAILED(hr))
            {
            printf("INNTPTransport::CommandXHDR() failed.\n");
            goto NNTPPrompt;
            }
        WaitForCompletion(g_msgNNTP, 0);
        }
    else if (lstrcmpi(szCommand, "POST") == 0)
        {
        char szMessage[] = "From: \"Steve Serdy\" <steveser@microsoft.com>\r\n"
                           "Newsgroups: alt.test\r\n"
                           "Subject: Test Message\r\n"
                           "\r\nTest\r\n";
        NNTPMESSAGE rMessage;
        LPSTREAM    pStream = 0;
        HRESULT     hr;
        
        if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
            {
            pStream->Write((void const*) szMessage, lstrlen(szMessage) + 1, NULL);

            rMessage.cbSize = lstrlen(szMessage);
            rMessage.pstmMsg = pStream;
            
            hr = g_pNNTP->CommandPOST(&rMessage);
            pStream->Release();

            if (FAILED(hr))
                {
                printf("INNTPTransport::CommandPOST() failed.\n");
                goto NNTPPrompt;
                }
            WaitForCompletion(g_msgNNTP, 0);
            }
        }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        NNTPCommandShellHelp();

    // Go back to the prompt
    goto NNTPPrompt;
}


void IMAPCommandShell(void)
{
    printf("Not yet implemented.\n\n");
}

void RASCommandShellHelp(void)
{
    printf("Valid commands:\nCONNECT\nDISCONNECT\nEXIT\n\n");
}

void RASCommandShell(void)
{
    char            szCommand[50];
    IImnAccount    *pAccount=NULL;
    INETSERVER      rServer;

    // Title
    printf("Microsoft(R) RAS Command Shell.\n");
    printf("Type ? for help.\n\n");

    // Show command
RASPrompt:
    printf("RAS>");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        char szAccount[CCHMAX_ACCOUNT_NAME];
        printf("Enter Account Name>");
        scanf("%s", szAccount);
        fflush(stdin);

        if (FAILED(g_pAcctMan->FindAccount(AP_ACCOUNT_NAME, szAccount, &pAccount)))
        {
            printf("Invalid Account Name: '%s'\n\n", szAccount);
            goto RASPrompt;
        }

        if (FAILED(g_pPOP3->InetServerFromAccount(pAccount, &rServer)))
        {
            pAccount->Release();
            printf("IInternetTransport::InetServerFromAccount failed\n");
            goto RASPrompt;
        }

        if (RAS_CONNECT_RAS != rServer.rasconntype)
        {
            pAccount->Release();
            printf("Account is not using RAS.\n");
            goto RASPrompt;
        }

        if (FAILED(g_pRAS->Connect(&rServer, TRUE, TRUE)))
        {
            pAccount->Release();
            printf("IInternetTransport::Connect failed\n");
            goto RASPrompt;
        }

        // Wait for completion
        WaitForCompletion(g_msgRAS, RAS_CONNECT);

        // Done
        pAccount->Release();
    }
    else if (lstrcmpi(szCommand, "DISCONNECT") == 0)
    {
        g_pRAS->Disconnect();
    }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        RASCommandShellHelp();

    // Go back to the prompt
    goto RASPrompt;
}

void HTTPMailCommandShellHelp(void)
{
    printf("Valid commands:\nCONNECT\nDISCONNECT\nGET\nGETROOTPROP\nLISTFOLDERS\nPUT\nPROPFIND\nEXIT\n\n");
}

void HTTPMailCommandShell(void)
{
    INETSERVER      rServer;    
    char            szCommand[50];
    
    // Title
    printf("Microsoft(R) HTTPMail Command Shell.\n");
    printf("Type ? for help.\n\n");

HTTPMailPrompt:
    printf("HTTPMail> ");
    scanf("%s", szCommand);
    fflush(stdin);

    if (lstrcmpi(szCommand, "CONNECT") == 0)
    {
        ZeroMemory(&rServer, sizeof(rServer));
        printf("Enter server> ");
        scanf("%s", rServer.szServerName);
        fflush(stdin);

        printf("Enter login ('*' for anonymous)> ");
        scanf("%s", rServer.szUserName);
        fflush(stdin);
        if ('*' == rServer.szUserName[0])
            rServer.szUserName[0] = '\0';
        else
        {
            printf("Enter password> ");
            scanf("%s", rServer.szPassword);
        }

        if (FAILED(g_pHTTPMail->Connect(&rServer, FALSE, TRUE)))
        {
            printf("IHTTMPMailTransport::Connect failed\n");
            goto HTTPMailPrompt;
        }
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_CONNECTED);
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "GET") == 0)
    {
        char szPath[1024];
 
        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandGET(szPath, 0);
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_GET);
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "GETROOTPROP") == 0)
    {
        int iSelection;
        HTTPMAILROOTPROPTYPE proptype;

        printf("Select a property to retrieve:\n");
        printf("\t(1) Adbar\n\t(2) Contacts\n\t(3) Inbox\n\t(4) Outbox\n\t(5) SentItems");
        printf("\n\t(6) DeletedItems\n\t(7) Drafts\n\t(8) MsgFolderRoot\n\t(9) Sig");
        printf("\nSelection> ");
        scanf("%d", &iSelection);
        fflush(stdin);

        if (iSelection < 1 || iSelection > 9)
        {
            printf("Invalid Selection\n");
            goto HTTPMailPrompt;
        }

        HTTPMAILROOTPROPTYPE    rgProps[] = 
        {
            HTTPMAIL_ROOTPROP_ADBAR,
            HTTPMAIL_ROOTPROP_CONTACTS,
            HTTPMAIL_ROOTPROP_INBOX,
            HTTPMAIL_ROOTPROP_OUTBOX,
            HTTPMAIL_ROOTPROP_SENTITEMS,
            HTTPMAIL_ROOTPROP_DELETEDITEMS,
            HTTPMAIL_ROOTPROP_DRAFTS,
            HTTPMAIL_ROOTPROP_MSGFOLDERROOT,
            HTTPMAIL_ROOTPROP_SIG
        };
        
        LPSTR pszProp = NULL;
        if (SUCCEEDED(g_pHTTPMail->GetRootProperty(rgProps[iSelection - 1], &pszProp)))
        {
            if (pszProp)
                printf("Result: %s\n", pszProp);
        }
        
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "LISTFOLDERS") == 0)
    {
        g_pHTTPMail->ListFolders(0);
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_LISTFOLDERS);
    }
    else if (lstrcmpi(szCommand, "PUT") == 0)
    {
        char szPath[1024];
        char *lpszData = "Outlook Express PUT test";
 
        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandPUT(szPath, lpszData, strlen(lpszData), 0);
    }
    else if (lstrcmpi(szCommand, "POST") == 0)
    {
        char szPath[1024];
        char *lpszData = "Outlook Express POST test";
 
        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandPOST(szPath, lpszData, strlen(lpszData), 0);

    }
    else if (lstrcmpi(szCommand, "PROPFIND") == 0)
    {
        char szPath[1024];

        printf("Enter path ('/' for root)> ");
        scanf("%s", szPath);
        fflush(stdin);

        g_pHTTPMail->CommandPROPFIND(szPath, NULL, 0, 0);
        WaitForCompletion(g_msgHTTPMail, HTTPMAIL_PROPFIND);
        goto HTTPMailPrompt;
    }
    else if (lstrcmpi(szCommand, "DISCONNECT") == 0)
    {
        g_pHTTPMail->Disconnect();
    }
    else if (lstrcmpi(szCommand, "EXIT") == 0)
        return;
    else
        HTTPMailCommandShellHelp();

    // Go back to the prompt
    goto HTTPMailPrompt;
}

void WaitForCompletion(UINT uiMsg, DWORD wparam)
{
    MSG msg;
    while(GetMessage(&msg, NULL, 0, 0))
    {
        if (msg.message == uiMsg && msg.wParam == wparam || msg.wParam == IXP_DISCONNECTED)
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\smtpcall.cpp ===
// --------------------------------------------------------------------------------
// Smtpcall.cpp
// --------------------------------------------------------------------------------
#include "pch.h"
#include "iconsole.h"
#include "smtpcall.h"

// --------------------------------------------------------------------------------
// HrCreateSMTPTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP)
{
    // Locals
    HRESULT             hr;
    CSMTPCallback      *pCallback=NULL;

    // Create callback object
    pCallback = new CSMTPCallback();
    if (NULL == pCallback)
    {
        printf("Memory allocation failure\n");
        return E_OUTOFMEMORY;
    }

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)ppSMTP);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // InitNew
    hr = (*ppSMTP)->InitNew(NULL, pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        printf("Unable to load CLSID_IMNXPORT - IID_ISMTPTransport\n");
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::CSMTPCallback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::~CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::~CSMTPCallback(void)
{
}

// --------------------------------------------------------------------------------
// CSMTPCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_ISMTPCallback
    else if (IID_ISMTPCallback == riid)
        *ppv = (ISMTPCallback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CSMTPCallback::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnError(
        IXPSTATUS               ixpstatus,
        LPIXPRESULT             pIxpResult,
        IInternetTransport     *pTransport)
{
    printf("CSMTPCallback::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnStatus(
        IXPSTATUS               ixpstatus,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;

    pTransport->GetServerInfo(&rServer);

    switch(ixpstatus)
    {
    case IXP_FINDINGHOST:
        printf("Finding '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTING:
        printf("Connecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_SECURING:
        printf("Establishing secure connection to '%s'...\n", rServer.szServerName);
        break;
    case IXP_CONNECTED:
        printf("Connected '%s'\n", rServer.szServerName);
        break;
    case IXP_AUTHORIZING:
        printf("Authorizing '%s'...\n", rServer.szServerName);
        break;
    case IXP_AUTHRETRY:
        printf("Retrying Logon '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTING:
        printf("Disconnecting '%s'...\n", rServer.szServerName);
        break;
    case IXP_DISCONNECTED:
        printf("Disconnected '%s'\n", rServer.szServerName);
        PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, IXP_DISCONNECTED, 0);
        PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_QUIT, 0);
        break;
    }
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnProgress(
        DWORD                   dwIncrement,
        DWORD                   dwCurrent,
        DWORD                   dwMaximum,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnCommand(
        CMDTYPE                 cmdtype,                                            
        LPSTR                   pszLine,
        HRESULT                 hrResponse,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    if (CMD_SEND == cmdtype)
    {
        printf("%s[TX]: %s", rServer.szServerName, pszLine);
    }
    else if (CMD_RESP == cmdtype)
        printf("%s[RX]: %s - %08x\n", rServer.szServerName, pszLine, hrResponse);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnTimeout(
        DWORD                  *pdwTimeout,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnResponse(
        LPSMTPRESPONSE              pResponse)
{
    switch(pResponse->command)
    {
    case SMTP_NONE:
        break;

    case SMTP_BANNER:
        break;

    case SMTP_CONNECTED:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_CONNECTED, 0);
        break;

    case SMTP_SEND_MESSAGE:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_SEND_MESSAGE, 0);
        break;

    case SMTP_EHLO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_EHLO, 0);
        break;

    case SMTP_HELO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_HELO, 0);
        break;

    case SMTP_MAIL:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_MAIL, 0);
        break;

    case SMTP_RCPT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_RCPT, 0);
        break;

    case SMTP_RSET:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_RSET, 0);
        break;

    case SMTP_QUIT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_QUIT, 0);
        break;

    case SMTP_DATA:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_DATA, 0);
        break;

    case SMTP_DOT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_DOT, 0);
        break;

    case SMTP_SEND_STREAM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_SEND_STREAM, 0);
        break;

    case SMTP_CUSTOM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_CUSTOM, 0);
        break;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\rascall.h ===
// --------------------------------------------------------------------------------
// Rascall.h
// --------------------------------------------------------------------------------
#ifndef __RASCALL_H
#define __RASCALL_H

#include "imnxport.h"

HRESULT HrCreateRASTransport(IRASTransport **ppRAS);

// --------------------------------------------------------------------------------
// CRASCallback Implementation
// --------------------------------------------------------------------------------
class CRASCallback : public IRASCallback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CRASCallback(void);
    ~CRASCallback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP OnReconnect(
            LPSTR                   pszCurrentConnectoid,
            LPSTR                   pszNewConnectoid,
		    IRASTransport          *pTransport);

    STDMETHODIMP OnLogonPrompt(
            LPIXPRASLOGON           pRasLogon,
            IRASTransport          *pTransport);

    STDMETHODIMP OnRasDialStatus(
            RASCONNSTATE            rasconnstate, 
            DWORD                   dwError, 
            IRASTransport          *pTransport);

    STDMETHODIMP OnDisconnect(
            LPSTR                   pszCurrentConnectoid,
            boolean                 fConnectionOwner,
		    IRASTransport          *pTransport);
};

#endif // __RASCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\oedump\main.cpp ===
#define DEFINE_STRCONST
#define INITGUID
#define INC_OLE2
#include <windows.h>
#include <initguid.h>

#include <mimeole.h>
#undef OE5_BETA2
#include <msoeapi.h>
#include "main.h"
#include "stdio.h"

static TCHAR        c_szHr[]        = "<HR>",
                    c_szPT_Open[]   = "<XMP>",
                    c_szPT_Close[]  = "</XMP>";

HRESULT ExtractFolder(IStoreFolder *pFolder, LPSTR pszFileName);
HRESULT FindFolder(LPSTR pszFolder, IStoreFolder **ppFolder);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);
                 
void __cdecl main(int argc, char *argv[])
{
    IStoreFolder        *pFolder;
    HRESULT             hr;
    LPSTR               pszFolder,
                        pszFileName;

    if (argc != 3)
        {
        printf( "Usage: oedump <foldername> <filename>\n"
                " - converts a store folder to HTML and dumps to a file");
        return;        
        }

    pszFolder = argv[1];
    pszFileName = argv[2];

    if (FAILED(OleInitialize(NULL)))
		{
		printf("CoInit failed\n\r");
		return;
        }

    
    hr = FindFolder(pszFolder, &pFolder);
    if (!FAILED(hr)) 
        {
        hr = ExtractFolder(pFolder, pszFileName);
        if (FAILED(hr))
            {
            printf(" - err: could not extract folder to '%s'", pszFileName);

            }
        pFolder->Release();
        }
    else
        {
        printf(" - err: could not find folder '%s'", pszFolder);
        }
    OleUninitialize();
    return; 
}



HRESULT ExtractFolder(IStoreFolder *pFolder, LPSTR pszFileName)
{
    HENUMSTORE      hEnum;
    MESSAGEPROPS    rProps;
    HRESULT         hr;
    IMimeMessage    *pMsg; 
    IStream         *pstmOut;
    IStream         *pstm;

    rProps.cbSize = sizeof(MESSAGEPROPS);
    
    if (pFolder==NULL || pszFileName==NULL)
        return E_INVALIDARG;

    if (!FAILED(hr = MimeOleOpenFileStream(pszFileName, CREATE_ALWAYS, GENERIC_WRITE|GENERIC_READ, &pstmOut)))
        {
        if (pFolder->GetFirstMessage(0, 0, -1, &rProps, &hEnum)==S_OK)
            {
            do 
                {
                if (!FAILED(pFolder->OpenMessage(rProps.dwMessageId, IID_IMimeMessage, (void **)&pMsg)))
                    {
                    if (!FAILED(pMsg->GetTextBody(TXT_HTML, IET_BINARY, &pstm, NULL)))
                        {
                        HrCopyStream(pstm, pstmOut, NULL);
                        pstm->Release();
                        }
                    else
                        {
                        if (!FAILED(pMsg->GetTextBody(TXT_PLAIN, IET_BINARY, &pstm, NULL)))
                            {
                            // emit plaintext tags arounnd a non-html message
                            pstmOut->Write(c_szPT_Open, lstrlen(c_szPT_Open), NULL);
                            HrCopyStream(pstm, pstmOut, NULL);
                            pstmOut->Write(c_szPT_Close, lstrlen(c_szPT_Close), NULL);
                            pstm->Release();
                            }
                        }

                    pstmOut->Write(c_szHr, lstrlen(c_szHr), NULL);
                    // dump
                    pMsg->Release();
                    }
                
                rProps.cbSize = sizeof(MESSAGEPROPS);
                }
                while (pFolder->GetNextMessage(hEnum, 0, &rProps)==S_OK);

            pFolder->GetMessageClose(hEnum);
            }

        pstmOut->Commit(0);
        pstmOut->Release();
        }
    return hr;
}


HRESULT FindFolder(LPSTR pszFolder, IStoreFolder **ppFolder)
{
    HRESULT hr;
    IStoreNamespace     *pStore;
    FOLDERPROPS         fp;
    HENUMSTORE          hEnum;
    STOREFOLDERID       dwFldr=0;

    *ppFolder = NULL;

    fp.cbSize = sizeof(FOLDERPROPS);
    hr = CoCreateInstance(CLSID_StoreNamespace, NULL, CLSCTX_INPROC_SERVER, IID_IStoreNamespace, (LPVOID*)&pStore);
    if (!FAILED(hr))
        {
        hr = pStore->Initialize(NULL, 0);
        if (!FAILED(hr))
            {
            if (!FAILED(pStore->GetFirstSubFolder(FOLDERID_ROOT, &fp, &hEnum)))
                {
                do
                    {
                    if (lstrcmpi(fp.szName, pszFolder)==0)
                        {
                        dwFldr = fp.dwFolderId;
                        break;
                        }
                    fp.cbSize = sizeof(FOLDERPROPS);        // msoeapi changes the size!
                    }
                while (pStore->GetNextSubFolder(hEnum, &fp)==S_OK);

                pStore->GetSubFolderClose(hEnum);
                }
            
            if (dwFldr)
                pStore->OpenFolder(dwFldr, 0, ppFolder);
            }
        pStore->Release();
        }

    return (*ppFolder) ? S_OK : E_FAIL;
}


HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        if (pstmIn->Read(buf, sizeof(buf), &cbRead))
            goto exit;

        if (cbRead == 0) break;
        
        if (hr = pstmOut->Write(buf, cbRead, NULL))
            goto exit;

        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:
    if (pcb)
        *pcb = cbTotal;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\oedump\main.h ===
#ifndef _MAIN_H
#define _MAIN_H



#endif //_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\oedump\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendfile.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\moletest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Moletest.rc
//
#define IDD_TEST                        101
#define IDD_MESSAGE                     102
#define IDR_MENU1                       103
#define IDC_TREE                        1000
#define IDB_NEXT                        1001
#define IDB_STOP                        1002
#define IDB_INSERT                      1003
#define IDB_DELETE                      1004
#define IDB_OPEN                        1005
#define IDB_REVERT                      1006
#define IDB_SAVEMSG                     1008
#define IDB_VIEWSOURCE                  1010
#define IDB_PROMOTE                     1011
#define IDB_UNDELETE                    1012
#define IDB_HANDSOFF                    1013
#define IDS_COUNT                       1014
#define IDB_NEWTREE                     1015
#define IDE_EDIT                        1016
#define IDE_STORAGE                     1017
#define IDB_BROWSE                      1018
#define IDE_MESSAGENUM                  1019
#define IDB_GOTOMESSAGE                 1020
#define IDB_TESTHEADERS                 1021
#define IDB_RESET                       1022
#define IDB_TESTMESSAGE                 1023
#define IDC_LIST1                       1030
#define IDC_LIST                        1030
#define IDCB_FORMAT                     1031
#define ID_IMIMEMESSAGETREE_INSERTBODY  40002
#define ID_IMIMEMESSAGETREE_DELETEBODY  40003
#define ID_IMIMEMESSAGETREE_UNDELETEBODY 40004
#define ID_IMIMEMESSAGETREE_SAVEMESSAGE 40005
#define ID_IMIMEMESSAGETREE_SAFE        40006
#define ID_IMIMEMESSAGETREE_PROMOTEBODY 40007
#define ID_IMIMEMESSAGETREE_REVERT      40008
#define ID_IMIMEMESSAGETREE_INITNEW     40009
#define ID_IMIMEMESSAGETREE_HANDSOFFSTORAGE 40010
#define ID_IMIMEMESSAGETREE_SAVETOFILE  40011
#define IDM_SAVEFILE                    40011
#define ID_IMIMEMESSAGETREE_CREATEFROMFILE 40012
#define ID_BATCHTESTING_HEADERS         40013
#define ID_BATCHTESTING_MESSAGES        40014
#define ID_RICHEDIT_SENDTEXT            40015
#define ID_RICHEDIT_REPARSETEXT         40016
#define ID_TESTSTORAGE_OPEN             40017
#define ID_TESTSTORAGE_IMPORTMBX        40018
#define ID_TESTSTORAGE_DOWNLOADPOP3     40019

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40020
#define _APS_NEXT_CONTROL_VALUE         1032
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendfile.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\moletest\moletest.cpp ===
// --------------------------------------------------------------------------------
// Moletest.cpp
// --------------------------------------------------------------------------------
#define DEFINE_STRCONST
#define INITGUID
#include <windows.h>
#include <windowsx.h>
#include <richedit.h>
#include <commctrl.h>
#include <initguid.h>
#include <ole2.h>
#include <stdio.h>
#include <conio.h>
#include "resource.h"
#include <d:\foobar\inc\Mimeole.h>

IMimeOleMalloc *g_pMalloc=NULL;

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void MoleTestHeader(IStorage *pStorage);
void MoleTestBody(IStorage *pStorage);
BOOL CALLBACK MimeOLETest(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK RichStreamShow(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// --------------------------------------------------------------------------------
// Simple (UNSAFE) conversion to UNICODE
// --------------------------------------------------------------------------------
OLECHAR* ConvertToUnicode(char *szA)
{
  static OLECHAR achW[1024]; 

  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, 1024);  
  return achW; 
}

// --------------------------------------------------------------------------------
// Simple (UNSAFE) conversion to ANSI
// --------------------------------------------------------------------------------
char* ConvertToAnsi(OLECHAR FAR* szW)
{
  static char achA[1024]; 
  
  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, 1024, NULL, NULL);  
  return achA; 
} 

// --------------------------------------------------------------------------------
// Moletest entry point
// --------------------------------------------------------------------------------
void main(int argc, char *argv[])
{
    // Locals
    CHAR        szDocFile[MAX_PATH];
    IStorage   *pStorage=NULL;
    HRESULT     hr;
    HINSTANCE   hRichEdit=NULL;


    // Must have a path to a .stg file...
    if (argc != 2)
    {
        printf("Please enter the path and file name that mbxtodoc.exe generated: ");
        scanf("%s", szDocFile);
        fflush(stdin);
    }

    // Otherwise, copy parmaeter
    else
        lstrcpyn(szDocFile, argv[1], sizeof(szDocFile));

    hRichEdit = LoadLibrary("RICHED32.DLL");

    // Init OLE
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        printf("Error - Unable to initialize OLE.\n");
        exit(1);
    }

    // Get IMimeOleMalloc
    hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeOleMalloc, (LPVOID *)&g_pMalloc);
    if (FAILED(hr))
    {
        printf("Error - CoCreateInstance of CLSID_MIMEOLE\\IID_IMimeOleMalloc failed.\n");
        goto exit;
    }

    // Status
    printf("Opening source docfile: %s\n", szDocFile);

    // Get file
/*
    hr = StgOpenStorage(ConvertToUnicode(szDocFile), NULL, STGM_TRANSACTED | STGM_NOSCRATCH | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, &pStorage);
    if (FAILED(hr))
    {
        printf("StgOpenStorage failed\n");
        goto exit;
    }
*/

    DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_TEST), NULL, (DLGPROC)MimeOLETest, (LPARAM)szDocFile);
    //MoleTestBody(pStorage);

exit:
    // Cleanup
    if (hRichEdit)
        FreeLibrary(hRichEdit);
    if (pStorage)
        pStorage->Release();
    if (g_pMalloc)
        g_pMalloc->Release();

    // Un-init OLE
    CoUninitialize();

    // Done
    return;
}

// --------------------------------------------------------------------------------
// This is the IMimeHeader torture test
// --------------------------------------------------------------------------------
void MoleTestHeader(IStorage *pStorage)
{
    // Locals
    IMimeHeader     *pHeader=NULL;
    IEnumSTATSTG    *pEnum=NULL;
    IStream         *pStream=NULL;
    STATSTG          rElement;
    ULONG            i, c;
    HRESULT          hr=S_OK;
    CHAR             szData[50];
    IStream         *pSave=NULL, *pstmHeader=NULL;
    IMimeEnumHeaderLines *pEnumLines=NULL;
    LPSTR            pszData;

    // Status
    printf("Starting IMimeHeader torture test...\n");

    // Create a header object...
    hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeHeader, (LPVOID *)&pHeader);
    if (FAILED(hr))
    {
        printf("Error - CoCreateInstance of CLSID_Mime\\IID_IMimeHeader failed.\n");
        goto exit;
    }

    // Get storage enumerator
    hr = pStorage->EnumElements(0, NULL, 0, &pEnum);
    if (FAILED(hr))
    {
        printf("Error - IStorage::EnumElements failed.\n");
        goto exit;
    }

    // Enumerate
    for(i=0;;i++)
    {
        // Status
        //printf("Message: %d\n", i);

        // Get element
        hr = pEnum->Next(1, &rElement, &c);
        if (FAILED(hr))
            break;
        if (c == 0)
            break;

        // No Name ?
        if (NULL == rElement.pwcsName)
            continue;

        // Open the stream...
        hr = pStorage->OpenStream(rElement.pwcsName, NULL, STGM_SHARE_EXCLUSIVE | STGM_READWRITE, 0, &pStream);
        if (FAILED(hr))
        {
            printf("IStorage::OpenStream failed: (iMsg = %d)\n", i);
            goto nextmsg;
        }

        // Load the header...
        hr = pHeader->Load(pStream);
        if (FAILED(hr))
        {
            printf("IMimeHeader::Load failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

#if 0
        // Test Enumerator
        hr = pHeader->EnumHeaderLines(NULL, &pEnumLines);
        if (FAILED(hr))
            printf("IMimeHeader::EnumLines failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else
        {
            ULONG           cLines;
            //ULONG           x;
            HEADERLINE      rgLine[2];

            while(SUCCEEDED(pEnumLines->Next(2, rgLine, &cLines)) && cLines)
            {
                //for (x=0; x<cLines; x++)
                //    printf("%s: %s\n", prgLine[x].pszHeader, prgLine[x].pszLine);

                g_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
            }

            pEnumLines->Release();
            pEnumLines = NULL;
        }

        // Test Enumerator
        hr = pHeader->EnumHeaderLines("Received", &pEnumLines);
        if (FAILED(hr))
            printf("IMimeHeader::EnumLines failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else
        {
            ULONG           cLines;
            //ULONG           x;
            HEADERLINE      rgLine[2];

            while(SUCCEEDED(pEnumLines->Next(2, rgLine, &cLines)) && cLines)
            {
                //for (x=0; x<cLines; x++);
                //    printf("%s: %s\n", prgLine[x].pszHeader, prgLine[x].pszLine);

                g_pMalloc->FreeHeaderLineArray(cLines, rgLine, FALSE);
            }

            pEnumLines->Release();
            pEnumLines = NULL;
        }

        // Test IMimeHeader Interface
        pHeader->IsContentType(NULL, NULL);
        pHeader->IsContentType(STR_CNT_MESSAGE, NULL);
        pHeader->IsContentType(NULL, STR_SUB_PLAIN);

        // ****************************************************************************************
        // Get a few items...
        if (i == 0)
            pHeader->GetInetProp(NULL, NULL);
        pszData = NULL;
        hr = pHeader->GetInetProp("To", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"To\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // Get a few items...
        pszData = NULL;
        hr = pHeader->GetInetProp("Subject", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"Subject\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // Get a few items... (multi-line header)
        pszData = NULL;
        hr = pHeader->GetInetProp("Received", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"Received\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // Get a few items... (multi-line header)
        pszData = NULL;
        hr = pHeader->GetInetProp("Content-Type", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::GetInetProp(\"Content-Type\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // ****************************************************************************************
        // Prepare a line to set in a bunch of items...
        wsprintf(szData, "<Message@%s>", ConvertToAnsi(rElement.pwcsName));

        // Set a few items...
        if (i == 0)
            pHeader->SetInetProp(NULL, NULL);
        hr = pHeader->SetInetProp("To", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"To\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Get a few items...
        hr = pHeader->SetInetProp("Subject", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"Subject\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Get a few items... (multi-line header)
        hr = pHeader->SetInetProp("Received", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"Received\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Get a few items... (multi-line header)
        hr = pHeader->SetInetProp("Content-Type", "multipart\\related");
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(\"Content-Type\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // ****************************************************************************************
        // Delete a few items
        if (i == 0)
            pHeader->DelInetProp(NULL);
        hr = pHeader->DelInetProp("MIME-Version");
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::DelInetProp(\"MIME-Version\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // Delete a few items
        hr = pHeader->DelInetProp("Content-Disposition");
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
            printf("IMimeHeader::DelInetProp(\"Content-Disposition\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // ****************************************************************************************
        // Get some parameters
        if (i == 0)
        {
            pHeader->SetInetProp(NULL, NULL);
            pHeader->GetInetProp("Content-Type", NULL);
            pHeader->GetInetProp("par:content-type:name", NULL);
        }
        pszData = NULL;
        pHeader->GetInetProp("par:content-type:name", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"name\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Disposition:filename", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"filename\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Type:charset", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"charset\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Type:boundary", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        pszData = NULL;
        hr = pHeader->GetInetProp("par:Content-Type:part", &pszData);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND && hr != MIME_E_NO_DATA)
            printf("IMimeHeader::GetInetProp(...,\"part\") failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else if (pszData)
            g_pMalloc->Free(pszData);

        // ****************************************************************************************
        // Set some parameters
        if (i == 0)
        {
            pHeader->SetInetProp(NULL, NULL);
            pHeader->SetInetProp("Content-Type", NULL);
            pHeader->SetInetProp("par:Content-Type:name", NULL);
        }
        hr = pHeader->SetInetProp("par:Content-Type:name", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"name\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:Content-Disposition:filename", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"filename\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:Content-Type:charset", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"charset\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:content-type:boundary", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->SetInetProp("par:content-type:part", szData);
        if (FAILED(hr))
            printf("IMimeHeader::SetInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->DelInetProp("par:content-type:part");
        if (FAILED(hr))
            printf("IMimeHeader::DelInetProp(...,\"boundary\") failed (HR = %08X): (iMsg = %d)\n", hr, i);

        // ****************************************************************************************
        // Try to save it back
        if (i == 0)
            pHeader->GetSizeMax(NULL);
        //hr = pHeader->GetSizeMax(&uli);
        //if (FAILED(hr))
        //    printf("IMimeHeader::GetSizeMax() failed (HR = %08X): (iMsg = %d)\n", hr, i);

        hr = pHeader->IsDirty();
        if (FAILED(hr))
            printf("IMimeHeader::IsDirty() failed (HR = %08X): (iMsg = %d)\n", hr, i);

        CreateStreamOnHGlobal(NULL, TRUE, &pstmHeader);
        hr = pHeader->Save(pstmHeader, TRUE);
        if (FAILED(hr))
            printf("IMimeHeader::Save() failed (HR = %08X): (iMsg = %d)\n", hr, i);
        pstmHeader->Release();
#endif

nextmsg:
        // Cleanup
        pStream->Release();
        pStream = NULL;

        // Free the name
        CoTaskMemFree(rElement.pwcsName);
    }

exit:
    // Cleanup
    if (pEnum)
        pEnum->Release();
    if (pHeader)
        pHeader->Release();
    if (pStream)
        pStream->Release();
    if (pEnumLines)
        pEnumLines->Release();

    // Done
    return;
}



// --------------------------------------------------------------------------------
// This is the IMimeBody torture test
// --------------------------------------------------------------------------------
void MoleTestBody(IStorage *pStorage)
{
    // Locals
    IMimeMessage            *pMessage=NULL;
    IEnumSTATSTG            *pEnum=NULL;
    IStream                 *pStream=NULL,
                            *pstmTree=NULL;
    STATSTG                  rElement;
    ULONG                    i, c, cbRead, x;
    HRESULT                  hr=S_OK;
    LARGE_INTEGER            liOrigin = {0,0};
    HBODY                    hBody;
    IMimeBody               *pBody=NULL;
    IStream                 *pBodyStream=NULL;
    BYTE                     rgbBuffer[1024];
    FINDBODY                 rFindBody;
    FILETIME                 ft;
    IMimeMessageParts       *pParts=NULL;
    IStream                 *pSave=NULL;
    IDataObject             *pDataObject=NULL;
    IMimeAddressTable       *pAddressTable=NULL;
    LPSTR                    pszData=NULL;
    IMimeMessage            *pCombine=NULL;
    IMimeBody               *pRootBody=NULL;

    // Status
    printf("Starting IMimeBody torture test...\n");

    // Create a header object...
    hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMessage);
    if (FAILED(hr))
    {
        printf("Error - CoCreateInstance of CLSID_Mime\\IID_IMimeBody failed.\n");
        goto exit;
    }

    // Get storage enumerator
    hr = pStorage->EnumElements(0, NULL, 0, &pEnum);
    if (FAILED(hr))
    {
        printf("Error - IStorage::EnumElements failed.\n");
        goto exit;
    }

    // Enumerate
    for(i=0;;i++)
    {
        // Status
        // printf("Message: %d\n", i);

        // Get element
        hr = pEnum->Next(1, &rElement, &c);
        if (FAILED(hr))
            break;
        if (c == 0)
            break;

        // No Name ?
        if (NULL == rElement.pwcsName)
            continue;

        // Open the stream...
        hr = pStorage->OpenStream(rElement.pwcsName, NULL, STGM_SHARE_EXCLUSIVE | STGM_READWRITE, 0, &pStream);
        if (FAILED(hr))
        {
            printf("IStorage::OpenStream failed: (iMsg = %d)\n", i);
            goto nextmsg;
        }

        // Init New the message
        hr = pMessage->InitNew();
        if (FAILED(hr))
        {
            printf("pMessage->InitNew failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Load the header...
        hr = pMessage->BindToMessage(pStream);
        if (FAILED(hr))
        {
            printf("pMessage->BindMessage failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

#if 0
	    hr = pMessage->SplitMessage(64 * 1024, &pParts);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::SplitMessage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else
        {
            hr = pParts->CombineParts(&pCombine);
            if (FAILED(hr))
                MessageBox(NULL, "IMimeMessageParts::CombineParts failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
            else
                pCombine->Release();
            pParts->Release();
        }

        // Test Addresss List
        hr = pMessage->GetAddressList(&pAddressTable);
        if (FAILED(hr))
            printf("IMimeHeader::GetAddressList failed (HR = %08X): (iMsg = %d)\n", hr, i);
        else
        {
            IADDRESSLIST rList;

/*
            hr = pAddressTable->GetViewable(IAT_TO, TRUE, &pszData);
            if (FAILED(hr))
                printf("IMimeAddressList::GetViewable failed (HR = %08X): (iMsg = %d)\n", hr, i);
            else
                g_pMalloc->Free(pszData);
*/

            hr = pAddressTable->GetList(IAT_ALL, &rList);
            if (FAILED(hr) && hr != MIME_E_NO_DATA)
                printf("IMimeAddressList::GetList failed (HR = %08X): (iMsg = %d)\n", hr, i);
            else if (SUCCEEDED(hr))
            {
//                for (x=0; x<rList.cAddresses; x++)
//                    printf("%30s%30s\n", rList.prgAddress[x].pszName, rList.prgAddress[x].pszEmail);
                g_pMalloc->FreeAddressList(&rList);
//                printf("------------------------------------------------------------------------\n");
            }

            pAddressTable->Release();
        }

        // QI for body tree
        hr = pMessage->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *)&pRootBody);
        if (FAILED(hr))
        {
            printf("pMessage->GetRootBody failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        hr = pRootBody->SetInetProp(STR_HDR_CNTTYPE, "text/plain");
        if (FAILED(hr))
            MessageBox(NULL, "pRootBody->SetInetProp failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        // Get the time...
        hr = pRootBody->GetSentTime(&ft);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::GetSentTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        hr = pRootBody->SetSentTime(&ft);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::SetSentTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        hr =pRootBody->GetReceiveTime(&ft);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::GetReceiveTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);

        hr = pMessage->GetTextBody(NULL, NULL, &pSave);
        if (FAILED(hr) && hr != MIME_E_NO_DATA)
            MessageBox(NULL, "IMimeMessage::GetTextBody failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else if (pSave)
            pSave->Release();

        hr = pMessage->GetTextBody("html", NULL, &pSave);
        if (FAILED(hr) && hr != MIME_E_NO_DATA)
            MessageBox(NULL, "IMimeMessage::GetTextBody failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else if (pSave)
            pSave->Release();

        CreateStreamOnHGlobal(NULL, TRUE, &pSave);
        hr = pMessage->SaveMessage(pSave, TRUE);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::GetReceiveTime failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        pSave->Release();

        hr = pMessage->QueryInterface(IID_IDataObject, (LPVOID *)&pDataObject);
        if (FAILED(hr))
            MessageBox(NULL, "IMimeMessage::QueryInterface failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        else
        {
            OleSetClipboard(pDataObject);
            pDataObject->Release();
        }

        // Get Message Source
        pStream->Release();
        pStream = NULL;
        hr = pMessage->GetMessageSource(&pStream);
        if (FAILED(hr))
        {
            printf("IMimeMessageTree::GetMessageSource failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Create body tree stream
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pstmTree);
        if (FAILED(hr))
        {
            printf("CreateStreamOnHGlobal failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // find first/next loop
        ZeroMemory(&rFindBody, sizeof(rFindBody));
        rFindBody.pszCntType = (LPSTR)STR_CNT_TEXT;
        hr = pMessage->FindFirst(&rFindBody, &hBody);
        if (FAILED(hr) && hr != MIME_E_NOT_FOUND)
        {
            printf("pMessage->FindFirst failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }
        else if (SUCCEEDED(hr))
        {
            while(1)
            {
                // Open the body
                hr = pMessage->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
                if (FAILED(hr))
                {
                    printf("pMessage->BindToObject failed (HR = %08X): (iMsg = %d)\n", hr, i);
                    goto nextmsg;
                }

                // Get the body stream...
                if (SUCCEEDED(pBody->GetData(FMT_BINARY, &pBodyStream)))
                {
                    // Seek to end and then begginnging
                    hr = pBodyStream->Seek(liOrigin, STREAM_SEEK_END, NULL);
                    if (FAILED(hr))
                    {
                        printf("pBodyStream->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
                        goto nextmsg;
                    }

                    // Seek to end and then begginnging
                    hr = pBodyStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
                    if (FAILED(hr))
                    {
                        printf("pBodyStream->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
                        goto nextmsg;
                    }

                    // Lets read data from the stream
                    while(1)
                    {
                        // Read block
                        hr = pBodyStream->Read(rgbBuffer, sizeof(rgbBuffer) - 1, &cbRead);
                        if (FAILED(hr))
                        {
                            printf("pBodyStream->Read failed (HR = %08X): (iMsg = %d)\n", hr, i);
                            goto nextmsg;
                        }

                        // Done
                        if (0 == cbRead)
                            break;

//                        rgbBuffer[cbRead] = '\0';
//                        printf("%s", (LPSTR)rgbBuffer);
                    }
                    pBodyStream->Release();
                    pBodyStream = NULL;
//                    printf("\n======================================================================\n");
//                    _getch();
                }

                // Release
                pBody->Release();
                pBody = NULL;

                // Get Next
                if (FAILED(pMessage->FindNext(&rFindBody, &hBody)))
                    break;
            }
        }

        // Save the Tree
        hr = pMessage->SaveTree(pstmTree);
        if (FAILED(hr))
        {
            printf("pMessage->Save failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }
        
        // Commit the stream
        hr = pstmTree->Commit(STGC_DEFAULT);
        if (FAILED(hr))
        {
            printf("pstmTree->Commit failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Rewind it
        hr = pstmTree->Seek(liOrigin, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
        {
            printf("pstmTree->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Init the tree
        hr = pMessage->InitNew();
        if (FAILED(hr))
        {
            printf("pMessage->InitNew failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Load the body tree
        hr = pMessage->LoadTree(pstmTree);
        if (FAILED(hr))
        {
            printf("pMessage->Load failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Rewind message stream
        hr = pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
        if (FAILED(hr))
        {
            printf("pStream->Seek failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }

        // Rebind
        hr = pMessage->BindMessage(pStream);
        if (FAILED(hr))
        {
            printf("pMessage->BindMessage failed (HR = %08X): (iMsg = %d)\n", hr, i);
            goto nextmsg;
        }
#endif

nextmsg:
        // Cleanup
        if (pstmTree)
        {
            pstmTree->Release();
            pstmTree = NULL;
        }
        if (pRootBody)
        {
            pRootBody->Release();
            pRootBody = NULL;
        }
        if (pStream)
        {
            pStream->Release();
            pStream = NULL;
        }
        if (pBody)
        {
            pBody->Release();
            pBody = NULL;
        }
        if (pBodyStream)
        {
            pBodyStream->Release();
            pBodyStream=NULL;
        }

        // Free the name
        CoTaskMemFree(rElement.pwcsName);
    }

exit:
    // Cleanup
    if (pEnum)
        pEnum->Release();
    if (pMessage)
        pMessage->Release();
    if (pstmTree)
        pstmTree->Release();
    if (pStream)
        pStream->Release();

    // Done
    return;
}

void TreeViewInsertBody(HWND hwnd, IMimeMessageTree *pTree, HBODY hBody, HTREEITEM hParent, HTREEITEM hInsertAfter, HTREEITEM *phItem)
{
    // Locals
    IMimeHeader       *pHeader=NULL;
    LPSTR              pszCntType=NULL,
                       pszEncType=NULL,
                       pszFree=NULL,
                       psz=NULL,
                       pszFileName=NULL,
                       pszFName;
    TV_INSERTSTRUCT    tvi;
    HRESULT            hr;
    HTREEITEM          hCurrent, hNew;
    HBODY              hChild;

    // Get Header
    hr = pTree->BindToObject(hBody, IID_IMimeHeader, (LPVOID *)&pHeader);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeMessageTree->BindToObject - IID_IMimeHeader failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Get content type
    hr = pHeader->GetInetProp(STR_HDR_CNTTYPE, &pszCntType);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeHeader->GetContentType failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Get content type
    if (FAILED(pHeader->GetInetProp(STR_HDR_CNTENC, &pszFree)))
        pszEncType = (LPSTR)"Unknown";
    else
        pszEncType = pszFree;

    // Get content type
    if (FAILED(pHeader->GetInetProp(STR_ATT_FILENAME, &pszFileName)))
        pszFName = (LPSTR)"Unknown";
    else
        pszFName = pszFileName;

    // Build content-type string
    psz = (LPSTR)CoTaskMemAlloc(lstrlen(pszCntType) + lstrlen(pszEncType) + lstrlen(pszFName) + 15);

    // Insert
    ZeroMemory(&tvi, sizeof(TV_INSERTSTRUCT));
    tvi.hParent = hParent;
    tvi.hInsertAfter = hInsertAfter;
    tvi.item.mask = TVIF_PARAM | TVIF_TEXT;
    tvi.item.lParam = (LPARAM)hBody;
    tvi.item.cchTextMax = wsprintf(psz, "%s - %s (%s)", pszCntType, pszEncType, pszFName);
    tvi.item.pszText = psz;

    // Insert it
    *phItem = hCurrent = TreeView_InsertItem(hwnd, &tvi);

    // Multipart...
    if (pHeader->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // Get first child...
        hr = pTree->GetBody(BODY_FIRST_CHILD, hBody, &hChild);
        if (FAILED(hr))
        {
            MessageBox(GetParent(hwnd), "IMimeMessageTree->GetBody - BODY_FIRST_CHILD failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
            goto exit;
        }

        // Loop
        while(hChild)
        {
            // Insert it
            TreeViewInsertBody(hwnd, pTree, hChild, hCurrent, TVI_LAST, &hNew);

            // Next
            hr = pTree->GetBody(BODY_NEXT, hChild, &hChild);
            if (FAILED(hr))
                break;
        }
    }

    TreeView_Expand(hwnd, *phItem, TVE_EXPAND);

exit:
    // Cleanup
    if (pHeader)
        pHeader->Release();
    if (pszCntType)
        g_pMalloc->Free(pszCntType);
    if (pszFileName)
        g_pMalloc->Free(pszFileName);
    if (pszFree)
        g_pMalloc->Free(pszFree);
    if (psz)
        CoTaskMemFree(psz);

    // Done
    return;
}

void TreeViewMessage(HWND hwnd, IMimeMessage *pMessage)
{
    // Locals
    IMimeMessageTree  *pTree=NULL;
    HBODY              hBody;
    HRESULT            hr=S_OK; 
    HTREEITEM          hRoot;

    // Delete All
    TreeView_DeleteAllItems(hwnd);

    // QI for body tree
    hr = pMessage->QueryInterface(IID_IMimeMessageTree, (LPVOID *)&pTree);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeMessage->QueryInterface - IID_IMimeMessageTree failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Get the root body object
    hr = pTree->GetBody(BODY_ROOT, NULL, &hBody);
    if (FAILED(hr))
    {
        MessageBox(GetParent(hwnd), "IMimeMessageTree->GetBody - BODY_ROOT failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Insert Body
    TreeViewInsertBody(hwnd, pTree, hBody, TVI_ROOT, TVI_FIRST, &hRoot);

    // Expand all
    TreeView_SelectItem(GetDlgItem(hwnd, IDC_LIST), hRoot);

exit:
    // Cleanup
    if (pTree)
        pTree->Release();

    // Done
    return;
}

DWORD CALLBACK EditStreamInCallback(DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG FAR *pcb)
{
    LPSTREAM pstm=(LPSTREAM)dwCookie;

    if(pstm)
        pstm->Read(pbBuff, cb, (ULONG *)pcb);
    return NOERROR;
}


HRESULT HrRicheditStreamIn(HWND hwndRE, LPSTREAM pstm, ULONG uSelFlags)
{
    EDITSTREAM  es;

    if(!pstm)
        return E_INVALIDARG;

    if(!IsWindow(hwndRE))
        return E_INVALIDARG;
    es.dwCookie = (DWORD)pstm;
    es.pfnCallback=(EDITSTREAMCALLBACK)EditStreamInCallback;
    SendMessage(hwndRE, EM_STREAMIN, uSelFlags, (LONG)&es);
    return NOERROR;
}

BOOL FOpenStorage(HWND hwnd, LPSTR pszFile, IStorage **ppStorage, IEnumSTATSTG **ppEnum)
{
    // Locals
    HRESULT hr;

    // Get file
    hr = StgOpenStorage(ConvertToUnicode(pszFile), NULL, STGM_TRANSACTED | STGM_NOSCRATCH | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, ppStorage);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "StgOpenStorage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    // Get First element
    hr = (*ppStorage)->EnumElements(0, NULL, 0, ppEnum);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "IStorage::EnumElements failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    // Done
    return TRUE;
}

BOOL FOpenMessage(HWND hwnd, IMimeMessage *pMessage, IStorage *pStorage)
{
    HRESULT hr;
    BOOL fResult=FALSE;
    LARGE_INTEGER liOrigin = {0,0};
    CHAR szName[255];
    LPSTREAM pStream=NULL;
    LV_ITEM lvi;
    LPHBODY prgAttach=NULL;
    ULONG cAttach;

    // Get selected string
    ULONG i = ListView_GetNextItem(GetDlgItem(hwnd, IDC_LIST), -1, LVNI_SELECTED);
    if (-1 == i)
        return FALSE;

    // Get the name
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT;
    lvi.iItem = i;
    lvi.pszText = szName;
    lvi.cchTextMax = sizeof(szName);
    ListView_GetItem(GetDlgItem(hwnd, IDC_LIST), &lvi);

    // OpenStream
    hr = pStorage->OpenStream(ConvertToUnicode(szName), NULL, STGM_SHARE_EXCLUSIVE | STGM_READ, 0, &pStream);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "IStorage::OpenStream failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Show Source
    pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    HrRicheditStreamIn(GetDlgItem(hwnd, IDE_EDIT), pStream, SF_TEXT);

    // Load the message
    pStream->Seek(liOrigin, STREAM_SEEK_SET, NULL);
    pMessage->InitNew();
    hr = pMessage->BindToMessage(pStream);
    if (FAILED(hr))
    {
        MessageBox(hwnd, "IMimeMessage::Load failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
        goto exit;
    }

    // Save it back out
#if 0
    pMessage->SetInetProp(HBODY_ROOT, STR_HDR_SUBJECT, "This is a test...");
    pMessage->GetAttached(&cAttach, &prgAttach);
    for (i=0; i<cAttach; i++)
        pMessage->DeleteBody(prgAttach[i]);
    if (prgAttach)
        g_pMalloc->Free(prgAttach);
    pMessage->Commit();
#endif

    // View the message
    TreeViewMessage(GetDlgItem(hwnd, IDC_TREE), pMessage);

    // Success
    fResult = TRUE;

exit:
    // Cleanup
    if (pStream)
        pStream->Release();

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// MimeOLETest
// --------------------------------------------------------------------------------
BOOL CALLBACK MimeOLETest(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    static CHAR          s_szFile[MAX_PATH];
    static IMimeMessage *s_pMessage=NULL;
    static IStorage     *s_pStorage=NULL;
    IMimeBody           *pBody;
    IStream             *pStream;
    HRESULT              hr;
    IEnumSTATSTG        *pEnum=NULL;
    TV_ITEM              tvi;
    ULONG                c;
    STATSTG              rElement;
    HTREEITEM            hItem;
    LV_COLUMN            lvm;
    LV_ITEM              lvi;
    HWND                 hwndC;

    // Handle the message
    switch(uMsg)
    {
    // Initialize
    case WM_INITDIALOG:
        // Create a header object...
        hr = CoCreateInstance(CLSID_MIMEOLE, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&s_pMessage);
        if (FAILED(hr))
        {
            MessageBox(hwnd, "CoCreateInstance - IID_IMimeMessage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
            return FALSE;
        }

        //s_pMessage->TestMe();

        // Formats
        hwndC = GetDlgItem(hwnd, IDCB_FORMAT);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_BINARY");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_BINARY);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_INETCSET");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_INETCSET);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMIT64");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMIT64);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMITUU");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMITUU);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMITQP");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMITQP);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMIT7BIT");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMIT7BIT);
        c = SendMessage(hwndC, CB_ADDSTRING, 0, (LPARAM)"FMT_XMIT8BIT");
        SendMessage(hwndC, CB_SETITEMDATA, c, FMT_XMIT8BIT);
        SendMessage(hwndC, CB_SETCURSEL, 0, 0);

        // To
//        ListView_SetExtendedListViewStyle(GetDlgItem(hwnd, IDC_LIST), LVS_EX_FULLROWSELECT);
        ZeroMemory(&lvm, sizeof(LV_COLUMN));
        lvm.mask = LVCF_WIDTH | LVCF_TEXT;
        lvm.pszText = "MessageID";
        lvm.cchTextMax = lstrlen(lvm.pszText);
        lvm.cx = 200;
        ListView_InsertColumn(GetDlgItem(hwnd, IDC_LIST), 0, &lvm);

        if (lParam)
        {
            // Copy File Name
            lstrcpyn(s_szFile, (LPSTR)lParam, MAX_PATH);

            // Set file name
            SetDlgItemText(hwnd, IDE_STORAGE, s_szFile);

            // Get file
            hr = StgOpenStorage(ConvertToUnicode(s_szFile), NULL, STGM_TRANSACTED | STGM_NOSCRATCH | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, NULL, 0, &s_pStorage);
            if (FAILED(hr))
            {
                MessageBox(hwnd, "StgOpenStorage failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
            }

#if 0
            //MoleTestHeader(s_pStorage);
            MoleTestBody(s_pStorage);
            s_pMessage->Release();
            s_pStorage->Release();
            exit(1);
#endif

            // Get First element
            hr = s_pStorage->EnumElements(0, NULL, 0, &pEnum);
            if (FAILED(hr))
            {
                MessageBox(hwnd, "IStorage::EnumElements failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
            }

            // Enumerate
            ZeroMemory(&lvi, sizeof(lvi));
            lvi.mask = LVIF_TEXT;
            lvi.iItem = 0;
            while(SUCCEEDED(pEnum->Next(1, &rElement, &c)) && c)
            {
                lvi.pszText = ConvertToAnsi(rElement.pwcsName);
                lvi.cchTextMax = lstrlen(lvi.pszText);
                ListView_InsertItem(GetDlgItem(hwnd, IDC_LIST), &lvi);
                CoTaskMemFree(rElement.pwcsName);
                lvi.iItem++;
            }

            // Select first item
            ListView_SetItemState(GetDlgItem(hwnd, IDC_LIST), 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);

            // Release enum
            pEnum->Release();
        }

        // Done
        return FALSE;

    case WM_NOTIFY:
        switch(wParam)
        {
        case IDC_LIST:
            {
                NM_LISTVIEW *pnmv;
                pnmv = (NM_LISTVIEW *)lParam;  

                if (pnmv->uChanged & LVIF_STATE)
                {
                    if (pnmv->uNewState & LVIS_SELECTED && pnmv->uNewState & LVIS_FOCUSED)
                        FOpenMessage(hwnd, s_pMessage, s_pStorage);
                }
            }
            return 1;
        }
        break;

    // Handle Command
    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDB_OPEN:
            hItem = TreeView_GetSelection(GetDlgItem(hwnd, IDC_TREE));
            if (hItem)
            {
                ZeroMemory(&tvi, sizeof(TV_ITEM));
                tvi.mask = TVIF_PARAM | TVIF_HANDLE;
                tvi.hItem = hItem;
                if (TreeView_GetItem(GetDlgItem(hwnd, IDC_TREE), &tvi))
                {
                    hr = s_pMessage->BindToObject((HBODY)tvi.lParam, IID_IMimeBody, (LPVOID *)&pBody);
                    if (FAILED(hr))
                    {
                        MessageBox(hwnd, "IMimeMessageTree::BindToObject failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                        return FALSE;
                    }

                    c = SendMessage(GetDlgItem(hwnd, IDCB_FORMAT), CB_GETCURSEL, 0, 0);
                    if (CB_ERR == c)
                    {
                        pBody->Release();
                        MessageBox(hwnd, "Select an Object Object Format", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                        return FALSE;
                    }

                    hr = pBody->GetData((BODYFORMAT)SendMessage(GetDlgItem(hwnd, IDCB_FORMAT), CB_GETITEMDATA, c, 0), &pStream);
                    if (FAILED(hr))
                    {
                        pBody->Release();
                        MessageBox(hwnd, "IMimeMessageTree::BindToObject failed", "MimeOLE Test", MB_OK | MB_ICONEXCLAMATION);
                        return FALSE;
                    }

                    DialogBoxParam(NULL, MAKEINTRESOURCE(IDD_MESSAGE), NULL, (DLGPROC)RichStreamShow, (LPARAM)pStream);
                    pBody->Release();
                    pStream->Release();
                }
            }
            return 1;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return 1;
        }
        break;

    // Close
    case WM_CLOSE:
        EndDialog(hwnd, IDB_NEXT);
        break;

    // Cleanup
    case WM_DESTROY:
        if (s_pMessage)
            s_pMessage->Release();
        if (s_pStorage)
            s_pStorage->Release();
        break;
    }
    return FALSE;
}

// --------------------------------------------------------------------------------
// RichStreamShow
// --------------------------------------------------------------------------------
BOOL CALLBACK RichStreamShow(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        HrRicheditStreamIn(GetDlgItem(hwnd, IDE_EDIT), (IStream *)lParam, SF_TEXT);
        return FALSE;
    case WM_CLOSE:
        EndDialog(hwnd, IDCANCEL);
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

extern UINT g_msgSMTP;

#endif //_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\main.cpp ===
#define DEFINE_STRCONST
#define INITGUID
#define INC_OLE2
#include <windows.h>
#include <initguid.h>

#include <mimeole.h>
#include "main.h"
#include "trawler.h"
#include "stdio.h"

UINT                g_msgNNTP;
                 
void __cdecl main(int argc, char *argv[])
{
	CTrawler	*pTrawler;

    if (FAILED(OleInitialize(NULL)))
		{
		printf("CoInit failed\n\r");
		return;
        }

	if (HrCreateTrawler(&pTrawler)==S_OK)
		{
		pTrawler->DoTrawl();
		pTrawler->Close();
		pTrawler->Release();
		}

    OleUninitialize();
    return; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\iconsole\smtpcall.h ===
// --------------------------------------------------------------------------------
// Smtpcall.h
// --------------------------------------------------------------------------------
#ifndef __SMTPCALL_H
#define __SMTPCALL_H
#include "imnxport.h"

HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP);

// --------------------------------------------------------------------------------
// CSMTPCallback Implementation
// --------------------------------------------------------------------------------
class CSMTPCallback : public ISMTPCallback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CSMTPCallback(void);
    ~CSMTPCallback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // ISMTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPSMTPRESPONSE              pResponse);
};

#endif // __SMTPCALL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\trawler.cpp ===
// --------------------------------------------------------------------------------
// Trawler.cpp
// --------------------------------------------------------------------------------
#define INC_OLE2
#include "windows.h"
#include "main.h"
#include "stdio.h"
#include "shlwapi.h"
#include "mimeole.h"
#include "trawler.h"

extern UINT                g_msgNNTP;

void WaitForCompletion(UINT uiMsg, DWORD wparam);


HRESULT HrCreateTrawler(CTrawler **ppTrawler)
{
	CTrawler	*pTrawler;
	HRESULT		hr;

	pTrawler = new CTrawler();
	if (!pTrawler)
		return E_OUTOFMEMORY;

	hr = pTrawler->Init();
	if (FAILED(hr))
		goto error;

	*ppTrawler = pTrawler;
	pTrawler->AddRef();

error:
	pTrawler->Release();
	return hr;

}

// --------------------------------------------------------------------------------
// CTrawler::CTrawler
// --------------------------------------------------------------------------------
CTrawler::CTrawler(void)
    {
    m_cRef = 1;
	m_pNNTP = NULL;
	m_pstm = NULL;
    }

// --------------------------------------------------------------------------------
// CTrawler::~CTrawler
// --------------------------------------------------------------------------------
CTrawler::~CTrawler(void)
    {
    }

// --------------------------------------------------------------------------------
// CTrawler::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;
    
    // Bad param
    if (ppv == NULL)
        {
        hr = E_INVALIDARG;
        goto exit;
        }
    
    // Init
    *ppv=NULL;
    
    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    
    // IID_INNTPCallback
    else if (IID_INNTPCallback == riid)
        *ppv = (INNTPCallback *)this;
    
    // If not null, addref it and return
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
        }
    
    // No Interface
    hr = E_NOINTERFACE;
    
exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CTrawler::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTrawler::AddRef(void) 
    {
    return ++m_cRef;
    }

// --------------------------------------------------------------------------------
// CTrawler::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CTrawler::Release(void) 
    {
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
    }


// --------------------------------------------------------------------------------
// CTrawler::Init
// --------------------------------------------------------------------------------
HRESULT CTrawler::Init()
{
    HRESULT          hr;

    // Load the NNTP Transport
    hr = CoCreateInstance(CLSID_INNTPTransport, NULL, CLSCTX_INPROC_SERVER, 
                          IID_INNTPTransport, (LPVOID*)&m_pNNTP);
    if (FAILED(hr))
        {
        Error("Failed to CoCreate Transport Object\n");
        return hr;
        }

    // Initialize the transport
    hr = m_pNNTP->InitNew(NULL, this);
    if (FAILED(hr))
        {
        Error("Unable to initialize the transport\n");
        m_pNNTP->Release();
		m_pNNTP=NULL;
        return hr;
        }

    return S_OK;
}

HRESULT CTrawler::Close()
{
	if (m_pNNTP)
		{
		m_pNNTP->Disconnect();
        WaitForCompletion(g_msgNNTP, NS_DISCONNECTED);
        m_pNNTP->Release();
		m_pNNTP=NULL;
		}

	return S_OK;
}

HRESULT CTrawler::DoTrawl()
{
	char					*pszGroup;
	INETSERVER				rServer={0};

	if (FAILED(LoadIniData()))
		{
		return E_FAIL;
		}


	lstrcpy(rServer.szServerName, m_szServer);
	rServer.dwPort = 119;
	rServer.dwTimeout = 30;

	if (FAILED(m_pNNTP->Connect(&rServer, 0, 0)))
		{
		Error("Cannot connect to server\n\r");
		return E_FAIL;
		}

    WaitForCompletion(g_msgNNTP, NS_CONNECT);

	pszGroup=m_szGroups;
        
    while (*pszGroup)
        {
        if (FAILED(SelectGroup(pszGroup)))
            {
            Error("failed to select group\n\r");
			continue;
            }

        DumpGroup(pszGroup);
        pszGroup+=lstrlen(pszGroup)+1;
        }

	return S_OK;
}


HRESULT CTrawler::SelectGroup(LPSTR lpszGroup)
{
    HRESULT     hr;

    hr = m_pNNTP->CommandGROUP(lpszGroup);
    if (FAILED(hr))
       goto error;

    // Wait for completion
    WaitForCompletion(g_msgNNTP, NS_GROUP);

error:
    return hr;

}


HRESULT CTrawler::DumpGroup(LPSTR pszGroup)
{
    ULONG           c;
    ARTICLEID         rArtId;
    ULONG           uMin;
    char            sz[256];

    uMin = GetPrivateProfileInt(pszGroup, "Last", m_uMin, "trawl.ini");

    for(c=uMin; c<m_uMax; c++)
        {
        printf("Downloading article %d...\n\r", c);        
        rArtId.idType = AID_ARTICLENUM;
        rArtId.dwArticleNum = c;
                
        m_pNNTP->CommandARTICLE(&rArtId);
        WaitForCompletion(g_msgNNTP, NS_ARTICLE);
        }

    wsprintf(sz, "%d", m_uMax);
    WritePrivateProfileString(pszGroup, "Last", sz, "trawl.ini");
    printf("** GROUP DOWNLOAD COMPLETE ** (Last=%d)\n\r", m_uMax);
    return S_OK;
}

HRESULT CTrawler::LoadIniData()
{
	char	szDefault[MAX_PATH];

	if (GetPrivateProfileSection("groups", m_szGroups, sizeof(m_szGroups), "trawl.ini")==0)
		{
		Error("No group list found\n\rPlease add a [group] section to trawl.ini\n\r");
		return E_FAIL;
		}


	GetTempPath(MAX_PATH, szDefault);
	GetPrivateProfileString("setup", "path", szDefault, m_szPath, sizeof(m_szPath), "trawl.ini");

    if (m_szPath[lstrlen(m_szPath)-1]!='\\')
        m_szPath[lstrlen(m_szPath)-1]='\\';

	printf("using path=%s\n\r", m_szPath);

	GetPrivateProfileString("setup", "server", "newsvr", m_szServer, sizeof(m_szServer), "trawl.ini");
	printf("using server='%s'\n\r", m_szServer);

	
	if (GetPrivateProfileSection("types", m_szTypes, sizeof(m_szTypes), "trawl.ini")==0)
		{
		Error("No files types found to search for\n\rPlease add a [types] section to trawl.ini\n\r");
		return E_FAIL;
		}

	return S_OK;
}


HRESULT CTrawler::IsValidType(char *szExt)
{
	char *pszTypes=m_szTypes;

	if (*szExt == '.')
		szExt++;

	while (*pszTypes)
		{
		if (lstrcmp(szExt, pszTypes)==0)
			{
			return S_OK;
			}

        pszTypes+=lstrlen(pszTypes)+1;
		}
	return S_FALSE;
}



// --------------------------------------------------------------------------------
// CTrawler::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnLogonPrompt(LPINETSERVER pInetServer,
                                          IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CTrawler::OnPrompt(HRESULT hrError, LPCTSTR pszText, 
                                           LPCTSTR pszCaption, UINT uType,
                                           IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnError
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pIxpResult,
                                    IInternetTransport *pTransport)
    {
    char                        szBuffer[256];

    wsprintf(szBuffer, "CTrawler::OnError - Status: %d, hrResult: %08x\n", ixpstatus, pIxpResult->hrResult);
	Error(szBuffer);
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnStatus(IXPSTATUS ixpstatus,
                                     IInternetTransport *pTransport)
    {
    INETSERVER                  rServer;
    char                        szBuffer[256];
    
    pTransport->GetServerInfo(&rServer);
    switch(ixpstatus)
        {
        case IXP_FINDINGHOST:
            wsprintf(szBuffer, "Finding '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTING:
            wsprintf(szBuffer, "Connecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_SECURING:
            wsprintf(szBuffer, "Establishing secure connection to '%s'...\n", rServer.szServerName);
            break;
        case IXP_CONNECTED:
            wsprintf(szBuffer, "Connected '%s'\n", rServer.szServerName);
            break;
        case IXP_AUTHORIZING:
            wsprintf(szBuffer, "Authorizing '%s'...\n", rServer.szServerName);
            break;
        case IXP_AUTHRETRY:
            wsprintf(szBuffer, "Retrying Logon '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTING:
            wsprintf(szBuffer, "Disconnecting '%s'...\n", rServer.szServerName);
            break;
        case IXP_DISCONNECTED:
            wsprintf(szBuffer, "Disconnected '%s'\n", rServer.szServerName);
            break;
        }

    ShowMsg(szBuffer, FOREGROUND_GREEN);
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnProgress(DWORD dwIncrement, DWORD dwCurrent, 
                                       DWORD dwMaximum, IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, 
                                      HRESULT hrResponse,
                                      IInternetTransport *pTransport)
    {
    return S_OK;
    }

// --------------------------------------------------------------------------------
// CTrawler::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnTimeout(DWORD *pdwTimeout, 
                                      IInternetTransport *pTransport)
    {
    INETSERVER rServer;
    pTransport->GetServerInfo(&rServer);
    printf("Timeout '%s' !!!\n", rServer.szServerName);
    return S_OK;
    }


// --------------------------------------------------------------------------------
// CTrawler::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CTrawler::OnResponse(LPNNTPRESPONSE pResponse)
    {
    switch(pResponse->state)
        {
        case NS_DISCONNECTED:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_CONNECT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, NS_CONNECT, 0);
            break;

        case NS_AUTHINFO:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_GROUP:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_GROUP_RESP - rGroup.dwFirst  = %d\n"
                       "                rGroup.dwLast   = %d\n"
                       "                rGroup.dwCount  = %d\n"
                       "                rGroup.pszGroup = %s\n\n",
                       pResponse->rGroup.dwFirst, pResponse->rGroup.dwLast, 
                       pResponse->rGroup.dwCount, pResponse->rGroup.pszGroup);
                
                m_uMin = pResponse->rGroup.dwFirst;
                m_uMax = pResponse->rGroup.dwLast;
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEXT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_NEXT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rNext.dwArticleNum, pResponse->rNext.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;
            
        case NS_LAST:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_LAST_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_STAT:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\n"
                       "NS_STAT_RESP - rNext.dwArticleNum = %d\n"
                       "             - rNext.pszMessageId = %s\n\n",
                       pResponse->rLast.dwArticleNum, pResponse->rLast.pszMessageId);
                pResponse->pTransport->ReleaseResponse(pResponse);
                }
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_LIST:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_LIST_DATA_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rList.cLines; i++)
                        printf("%s\n", pResponse->rList.rgszLines[i]);
                    }

                m_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
            
        case NS_LISTGROUP:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_GROUP_SELECTED)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rListGroup.cArticles; i++)
                        printf("%d\n", pResponse->rListGroup.rgArticles[i]);
                    }

                m_pNNTP->ReleaseResponse(pResponse);

                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_DATE:
            if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                {
                printf("\nNS_DATE - %02d/%02d/%04d %02d:%02d:%02d\n\n",
                       pResponse->rDate.wMonth, pResponse->rDate.wDay,
                       pResponse->rDate.wYear, pResponse->rDate.wHour, 
                       pResponse->rDate.wMinute, pResponse->rDate.wSecond);
                }

            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_MODE:
            printf("\nNS_MODE\n\n");
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, pResponse->state, 0);
            break;

        case NS_NEWGROUPS:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_NEWNEWSGROUPS_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rNewgroups.cLines; i++)
                        printf("%s\n", pResponse->rNewgroups.rgszLines[i]);
                    }

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;                       

        case NS_ARTICLE:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_ARTICLE_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, NS_ARTICLE, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    OnArticle(pResponse->rArticle.pszLines, pResponse->rArticle.cbLines, pResponse->fDone);
                    }
                
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, NS_ARTICLE, 0);
                
                m_pNNTP->ReleaseResponse(pResponse);
                }
            break;

        case NS_HEAD:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_HEAD_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    printf("%s", pResponse->rArticle.pszLines);

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_BODY:
            if (pResponse->rIxpResult.uiServerError != IXP_NNTP_BODY_FOLLOWS)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    printf("%s", pResponse->rArticle.pszLines);
                    }
                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_IDLE:
            printf("NS_IDLE\n");
            printf("Why would we ever be here?");
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_HEADERS:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rHeaders.cHeaders; i++)
                        {
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwArticleNum);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszSubject);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszFrom);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszDate);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszMessageId);
                        printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszReferences);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwBytes);
                        printf("%d\n", pResponse->rHeaders.rgHeaders[i].dwLines);
                        if (pResponse->rHeaders.rgHeaders[i].pszXref)
                            printf("%s\n", pResponse->rHeaders.rgHeaders[i].pszXref);

                        printf("\n\n");
                        }
                    }

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;

        case NS_XHDR:
            if ((pResponse->rIxpResult.uiServerError / 100) != 2)
                PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            else
                {
                if (SUCCEEDED(pResponse->rIxpResult.hrResult))
                    {
                    for (UINT i = 0; i < pResponse->rXhdr.cHeaders; i++)
                        {
                        printf("%6d %s\n", pResponse->rXhdr.rgHeaders[i].dwArticleNum,
                               pResponse->rXhdr.rgHeaders[i].pszHeader);
                        }
                    }

                m_pNNTP->ReleaseResponse(pResponse);
                if (pResponse->fDone)
                    PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
                }
            break;
        
        case NS_POST:
            printf("%s\n", pResponse->rIxpResult.pszResponse);
            m_pNNTP->ReleaseResponse(pResponse);
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP, 0, 0);
            break;

        case NS_QUIT:
            PostThreadMessage(GetCurrentThreadId(), g_msgNNTP,0, 0);
            break;
        }
    return S_OK;
    }


HRESULT HrRewindStream(LPSTREAM pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}


void CTrawler::DumpMsg(IMimeMessage *pMsg)
{
    TCHAR       *szExt;
    ULONG       cAttach=0,
                uAttach;
    LPHBODY     rghAttach=0;
    LPSTR       lpszFile=0;
    HBODY       hAttach=0;
    LPMIMEBODY  pBody=0;
    TCHAR       szTemp[MAX_PATH];

    if (FAILED(pMsg->GetAttachments(&cAttach, &rghAttach)))
        goto error;

    if (cAttach==0)
        goto error;

    for (uAttach = 0; uAttach < cAttach; uAttach++)
        {
        hAttach = rghAttach[uAttach];

        if (FAILED(MimeOleGetBodyPropA(pMsg, hAttach, STR_ATT_GENFNAME, NOFLAGS, &lpszFile)))
            continue;   // can't inline this dude...

        szExt = PathFindExtension(lpszFile);

		if (IsValidType(szExt)==S_OK)
            {
            // we can inline
            lstrcpy(szTemp, m_szPath);
            lstrcat(szTemp, lpszFile);

            if (pMsg->BindToObject(hAttach, IID_IMimeBody, (LPVOID *)&pBody)==S_OK)
                {
                ShowMsg(szTemp, FOREGROUND_BLUE);
    
                if (FAILED(pBody->SaveToFile(IET_BINARY, szTemp)))
					Error("Error: could not create file on disk.");
                
				pBody->Release();
                }
            }
        
		// I'm being lazy, I can't be bother writing to code to get the mime allocator, so I'm just not going to 
		// free this string...
		//SafeMimeOleFree(lpszFile);
        }
error:
    return;
}

void CTrawler::OnArticle(LPSTR lpszLines, ULONG cbLines, BOOL fDone)
{
    IMimeMessage    *pMsg;
        
    if (!m_pstm)
		{
		// if we need a new stream let's create one
		MimeOleCreateVirtualStream(&m_pstm);
		}

	if (m_pstm)
        {
        if (!FAILED(m_pstm->Write(lpszLines, cbLines, NULL)))
            {
            if (fDone)
                {
                // if we're done, scan the msg and release and NULL the stream ready
				// for the next article
				if (!FAILED(MimeOleCreateMessage(NULL, &pMsg)))
                    {
                    HrRewindStream(m_pstm);
                    if (!FAILED(pMsg->Load(m_pstm)))
                        DumpMsg(pMsg);
                    pMsg->Release();
                    m_pstm->Release();
                    m_pstm = NULL;
                    }
                }
            }
        }
}



void CTrawler::ShowMsg(LPSTR psz, BYTE fgColor)
{
    HANDLE                      hConsole = INVALID_HANDLE_VALUE;
    CONSOLE_SCREEN_BUFFER_INFO  csbi;
    BOOL                        fChanged = FALSE;
    char                        szBuffer[256];
    DWORD                       dwWritten = 0;

    // Get a handle to the console window
    if (INVALID_HANDLE_VALUE != (hConsole = GetStdHandle(STD_OUTPUT_HANDLE)))
        {
        // Get the current attributes for the console
        if (GetConsoleScreenBufferInfo(hConsole, &csbi))
            {
            // Set the text color to be red on whatever background is currently
            // there
            fChanged = SetConsoleTextAttribute(hConsole, 
                                               (csbi.wAttributes & 0xF0) | fgColor | FOREGROUND_INTENSITY);
            }
        }

    wsprintf(szBuffer, "%s\n\r", psz);
    WriteConsole(hConsole, szBuffer, lstrlen(szBuffer), &dwWritten, NULL);

    // If we changed the screen attributes, then change them back
    if (fChanged)
        SetConsoleTextAttribute(hConsole, csbi.wAttributes);

}


void CTrawler::Error(LPSTR psz)
{
	ShowMsg(psz, FOREGROUND_RED);
}



void WaitForCompletion(UINT uiMsg, DWORD wparam)
{
    MSG msg;
    
    while(GetMessage(&msg, NULL, 0, 0))
        {
        if (msg.message == uiMsg && msg.wParam == wparam || msg.wParam == IXP_DISCONNECTED)
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\build\main.c ===
#include "windows.h"

int CALLBACK WEP(int x)
{

    // Free Global Variables
    FreeGlobalVars();

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\build\makefile.inc ===
$(O)\inetdum.rc : $(R)\resdummy\inetdum.rc
    copy $** $@

$O\*.sbr :
    move $(R)\inc\$O\*.sbr $O
    move $(R)\dll\$O\*.sbr $O
    move $(R)\common\$O\*.sbr $O
    move $(R)\fntcache\$O\*.sbr $O
    move $(R)\imnxport\$O\*.sbr $O
    move $(R)\mimeedit\$O\*.sbr $O
    move $(R)\mimeole\$O\*.sbr $O
    move $(R)\res\$O\*.sbr $O
    move $(R)\exrwlck\$O\*.sbr $O
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\apitest\trawl\trawler.h ===
// --------------------------------------------------------------------------------
// trawler.h
// --------------------------------------------------------------------------------

#ifndef __TRAWLER_H__
#define __TRAWLER_H__

#include "imnxport.h"

#define CCH_MAX 4096

interface IMimeMessage;

class CTrawler : public INNTPCallback
    {
public:
    CTrawler(void);
    ~CTrawler(void);

    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // INNTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPNNTPRESPONSE              pResponse);



	HRESULT Init();
	HRESULT Close();
	HRESULT DoTrawl();

private:
    ULONG			m_cRef,
					m_uMin,
					m_uMax;
	INNTPTransport	*m_pNNTP;
	char			m_szGroups[CCH_MAX],
					m_szTypes[CCH_MAX],
					m_szPath[MAX_PATH],
					m_szServer[MAX_PATH];
	LPSTREAM		m_pstm;

	void ShowMsg(LPSTR psz, BYTE fgColor);
	void Error(LPSTR psz);
	void OnArticle(LPSTR lpszLines, ULONG cbLines, BOOL fDone);
	void DumpMsg(IMimeMessage *pMsg);

	HRESULT LoadIniData();
	HRESULT SelectGroup(LPSTR lpszGroup);
	HRESULT DumpGroup(LPSTR lpszGroup);
	HRESULT IsValidType(char *szExt);

    };


HRESULT HrCreateTrawler(CTrawler **ppTrawler);

#endif // __TRAWLER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\common\attach.cpp ===
/*
 *    a t t a c h . c p p
 *    
 *    Purpose:
 *        Attachment utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */



#include <pch.hxx>
#include "dllmain.h"
#include "resource.h"
#include "error.h"
#include "mimeolep.h"
#include "shellapi.h"
#include "shlobj.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "mimeole.h"
#include "commdlg.h"
#include "demand.h"
#include "saferun.h"

ASSERTDATA

/*
 *  t y p e d e f s
 */

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s 
 */
#define MAX_CHARS_FOR_NUM       20

static const CHAR c_szWebMark[] = "<!-- saved from url=(0022)http://internet.e-mail -->\r\n";
static const WCHAR c_wszWebMark[] = L"<!-- saved from url=(0022)http://internet.e-mail -->\r\n";
/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */
HRESULT HrCleanTempFile(LPATTACHDATA pAttach);
HRESULT HrGetTempFile(IMimeMessage *pMsg, LPATTACHDATA lpAttach);
DWORD AthGetShortPathName(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);

STDAPI HrGetAttachIconByFile(LPWSTR szFilename, BOOL fLargeIcon, HICON *phIcon)
{
    HICON           hIcon = NULL;
    LPWSTR          lpszExt;
    SHFILEINFOW     rShFileInfo;

    if (szFilename)
    {
        // Does the file exist already ?
        if ((UINT)GetFileAttributesWrapW(szFilename) != (UINT)-1)
        {
            // Try to get the icon out of the file
            SHGetFileInfoWrapW(szFilename, 0, &rShFileInfo, sizeof(rShFileInfo), SHGFI_ICON |(fLargeIcon ? 0 : SHGFI_SMALLICON));
            hIcon=rShFileInfo.hIcon;
        }
        else
            if (lpszExt = PathFindExtensionW(szFilename))
            {
                // Lookup the icon for lpszExt
                SHGetFileInfoWrapW(lpszExt, FILE_ATTRIBUTE_NORMAL, &rShFileInfo, sizeof (rShFileInfo), SHGFI_USEFILEATTRIBUTES | SHGFI_ICON | (fLargeIcon ? 0 : SHGFI_SMALLICON));
                hIcon=rShFileInfo.hIcon;
            }
    }

    if (!hIcon)
        hIcon = CopyIcon(LoadIcon (g_hLocRes, MAKEINTRESOURCE (idiDefaultAtt)));

    *phIcon=hIcon;
    return S_OK;
}

STDAPI HrGetAttachIcon(IMimeMessage *pMsg, HBODY hAttach, BOOL fLargeIcon, HICON *phIcon)
{
    // Locals
    HRESULT         hr = S_OK;
    LPWSTR          lpszFile=0;

    if (!phIcon || !hAttach || !pMsg)
        return E_INVALIDARG;

    *phIcon=NULL;

    // Get file name for body part. If get an error, doesn't matter.  Still use
    // a default icon that will be provided through HrGetAttachIconByFile
    MimeOleGetBodyPropW(pMsg, hAttach, PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &lpszFile);
    hr = HrGetAttachIconByFile(lpszFile, fLargeIcon, phIcon);
    SafeMemFree(lpszFile);
    return hr;
}

//
//  GetUIVersion()
//
//  returns the version of shell32
//  3 == win95 gold / NT4
//  4 == IE4 Integ / win98
//  5 == win2k / millennium
//
UINT GetUIVersion()
{
    static UINT s_uiShell32 = 0;

    if (s_uiShell32 == 0)
    {
        HINSTANCE hinst = LoadLibrary("SHELL32.DLL");
        if (hinst)
        {
            DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
            DLLVERSIONINFO dllinfo;

            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if (pfnGetVersion && pfnGetVersion(&dllinfo) == NOERROR)
                s_uiShell32 = dllinfo.dwMajorVersion;
            else
                s_uiShell32 = 3;

            FreeLibrary(hinst);
        }
    }
    return s_uiShell32;
}

STDAPI HrDoAttachmentVerb(HWND hwnd, ULONG uVerb, IMimeMessage *pMsg, LPATTACHDATA pAttach)
{
    HRESULT                 hr = S_OK;
    SHELLEXECUTEINFOW       rShellExec;
    LPSTREAM                lpstmAtt = NULL;
    LPWSTR                  lpszShortName = NULL, 
                            lpszParameters = NULL,
                            lpszExt = NULL;
    DWORD                   dwFlags;
    WCHAR                   szCommand[MAX_PATH];
    HKEY                    hKeyAssoc = NULL;

    AssertSz( uVerb < AV_MAX, "Bad Verb");

    if (uVerb == AV_PROPERTIES)
    {
        AssertSz(FALSE, "AV_PROPERTIES is NYI!!");
        return E_NOTIMPL;
    }
    
    if (!pAttach)
        return E_INVALIDARG;
    
    // Save As - much simpler case
    if (uVerb == AV_SAVEAS)
    {
        hr=HrSaveAttachmentAs(hwnd, pMsg, pAttach);
        goto error;  // done
    }
    
    // If opening attachment, lets verify thsi
    if (uVerb == AV_OPEN)
    {
        // If nVerb is to open the attachment, lets verify that with the user
        hr = IsSafeToRun(hwnd, pAttach->szFileName, TRUE);
        
        if (hr == MIMEEDIT_E_USERCANCEL)    // map mimeedit error to athena error
            hr = hrUserCancel;
        
        if (FAILED(hr))     // user doesn't want to do this
            goto error;
        
        if (hr == MIMEEDIT_S_SAVEFILE)
        {
            hr=HrSaveAttachmentAs(hwnd, pMsg, pAttach);
            // done
            goto error;  
        }
    }
    
    // get temp file
    hr = HrGetTempFile(pMsg, pAttach);
    if (FAILED(hr))
        goto error;
    
    Assert(lstrlenW(pAttach->szTempFile));
    
    // Setup Shell Execute Info Struct
    ZeroMemory (&rShellExec, sizeof (rShellExec));
    rShellExec.cbSize = sizeof (rShellExec);
    rShellExec.fMask = SEE_MASK_NOCLOSEPROCESS;
    rShellExec.hwnd = hwnd;
    rShellExec.nShow = SW_SHOWNORMAL;
    
    // Verb
    if (uVerb == AV_OPEN)
    {
        // Were going to run the file
        hr = VerifyTrust(hwnd, pAttach->szFileName, pAttach->szTempFile);
        if (FAILED(hr))
        {
            hr = hrUserCancel;
            goto error;
        }
        
        rShellExec.lpFile = pAttach->szTempFile;
        
        // If the file does not have an associated type, do an OpenAs.
        // We're not testing the result of AssocQueryKeyW because even if it fails,
        // we want to try to open the file.
        lpszExt = PathFindExtensionW(pAttach->szTempFile);
        AssocQueryKeyW(NULL, ASSOCKEY_CLASS, lpszExt, NULL, &hKeyAssoc);
        if((hKeyAssoc == NULL) && (GetUIVersion() != 5))
            rShellExec.lpVerb = L"OpenAs";
        else
            RegCloseKey(hKeyAssoc);
    }
    
    else if (uVerb == AV_PRINT)
    {
        rShellExec.lpFile = pAttach->szTempFile;
        rShellExec.lpVerb = L"Print";
    }
    
    else if (uVerb == AV_QUICKVIEW)
    {
        UINT        uiSysDirLen;
        const WCHAR c_szSubDir[] = L"\\VIEWERS\\QUIKVIEW.EXE";
        
        // Find out where the viewer lives
        uiSysDirLen = GetSystemDirectoryWrapW(szCommand, ARRAYSIZE(szCommand));
        if (0 == uiSysDirLen || uiSysDirLen >= ARRAYSIZE(szCommand) ||
            uiSysDirLen + ARRAYSIZE(c_szSubDir) > ARRAYSIZE(szCommand))
        {
            hr = E_FAIL;
            goto error;
        }
        
        StrCpyNW(szCommand + uiSysDirLen, c_szSubDir, ARRAYSIZE(szCommand) - uiSysDirLen);
        
        // Alloc for short file name
        ULONG cbShortName = MAX_PATH + lstrlenW(pAttach->szTempFile) + 1;
        if (!MemAlloc ((LPVOID *)&lpszShortName, cbShortName * sizeof (WCHAR)))
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        
        // Alloc a string for the parameters
        ULONG cbParameters = 30 + cbShortName;
        if (!MemAlloc ((LPVOID *)&lpszParameters, cbParameters * sizeof (WCHAR)))
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        
        // Get Short File Name
        if (0 == AthGetShortPathName(pAttach->szTempFile, lpszShortName, cbShortName))
            StrCpyNW(lpszShortName, pAttach->szTempFile, cbShortName);
        
        // Put together the paramenters for QVSTUB.EXE
        Assert(cbParameters > cbShortName);
        StrCpyW(lpszParameters, L"-v -f:");
        StrCatW(lpszParameters, lpszShortName);
        
        // Setup Shellexec
        rShellExec.lpParameters = lpszParameters;
        rShellExec.lpFile = szCommand;
    }
    else
        Assert (FALSE);
    
    // Execute it - even if this fails, we handled it - it will give a good error
    ShellExecuteExWrapW(&rShellExec);
    pAttach->hProcess = rShellExec.hProcess;
    
    
error:
    MemFree(lpszParameters);
    MemFree(lpszShortName);
    return hr;
}

DWORD AthGetShortPathName(LPCWSTR pwszLongPath, LPWSTR pwszShortPath, DWORD cchBuffer)
{
    CHAR    szShortPath[MAX_PATH*2]; // Each Unicode char might go multibyte
    LPSTR   pszLongPath = NULL;
    DWORD   result = 0;

    Assert(pwszLongPath);
    pszLongPath = PszToANSI(CP_ACP, pwszLongPath);

    if (pszLongPath)
    {
        result = GetShortPathName(pszLongPath, szShortPath, ARRAYSIZE(szShortPath));
        if (result)
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szShortPath, lstrlen(szShortPath), pwszShortPath, cchBuffer);

        MemFree(pszLongPath);
    }

    return result;
}

STDAPI HrAttachDataFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, LPATTACHDATA *ppAttach)
{
    LPATTACHDATA    pAttach;
    LPWSTR          pszW;
    IMimeBodyW      *pBody;

    Assert (pMsg && ppAttach && hAttach);

    if (!MemAlloc((LPVOID *)&pAttach, sizeof(ATTACHDATA)))
        return E_OUTOFMEMORY;

    // fill in attachment data
    ZeroMemory(pAttach, sizeof(ATTACHDATA));

    if (pMsg->BindToObject(hAttach, IID_IMimeBodyW, (LPVOID *)&pBody)==S_OK)
    {
        if (pBody->GetDisplayNameW(&pszW)==S_OK)
        {
            StrCpyNW(pAttach->szDisplay, pszW, ARRAYSIZE(pAttach->szDisplay));
            MemFree(pszW);
        }
        ReleaseObj(pBody);
    }
    
    if (MimeOleGetBodyPropW(pMsg, hAttach, PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &pszW)==S_OK)
    {
        if(IsPlatformWinNT() != S_OK)
        {
            CHAR pszFile[MAX_PATH*2];

            WideCharToMultiByte(CP_ACP, 0, pszW, -1, pszFile, ARRAYSIZE(pszFile), NULL, NULL);
            MultiByteToWideChar(CP_ACP, 0, pszFile, -1, pszW, lstrlenW(pszW));
            CleanupFileNameInPlaceW(pszW);
        }

        StrCpyNW(pAttach->szFileName, pszW, ARRAYSIZE(pAttach->szFileName));
        MemFree(pszW);
    }
    
    SideAssert(HrGetAttachIcon(pMsg, hAttach, FALSE, &pAttach->hIcon)==S_OK);
    pAttach->hAttach = hAttach;
    pAttach->fSafe = (IsSafeToRun(NULL, pAttach->szFileName, FALSE) == MIMEEDIT_S_OPENFILE);
    
    *ppAttach = pAttach;
    return S_OK;
}

STDAPI HrAttachDataFromFile(IStream *pstm, LPWSTR pszFileName, LPATTACHDATA *ppAttach)
{
    LPATTACHDATA    pAttach=0;
    LPMIMEBODY      pBody=0;
    HRESULT         hr;
    int             cFileNameLength;

    Assert(ppAttach);

    if (!MemAlloc((LPVOID *)&pAttach, sizeof(ATTACHDATA)))
        return E_OUTOFMEMORY;

    // fill in attachment data
    ZeroMemory(pAttach, sizeof(ATTACHDATA));

    HrGetDisplayNameWithSizeForFile(pszFileName, pAttach->szDisplay, ARRAYSIZE(pAttach->szDisplay));
    StrCpyNW(pAttach->szFileName, pszFileName, ARRAYSIZE(pAttach->szFileName));
    if (!pstm)
    {
        // for new attachments set tempfile to be the same as filename
        // note: if creating from an IStream then pszFileName is not a valid path
        // we can create a tempfile later
        StrCpyNW(pAttach->szTempFile, pszFileName, ARRAYSIZE(pAttach->szTempFile));
    }
    ReplaceInterface(pAttach->pstm, pstm);
    SideAssert(HrGetAttachIconByFile(pszFileName, FALSE, &pAttach->hIcon)==S_OK);
    
    if (ppAttach)
        *ppAttach=pAttach;
    
    return S_OK;
}

STDAPI HrFreeAttachData(LPATTACHDATA pAttach)
{
    if (pAttach)    
    {
        HrCleanTempFile(pAttach);
        ReleaseObj(pAttach->pstm);
        if (pAttach->hIcon)
            DestroyIcon(pAttach->hIcon);
        
        MemFree(pAttach);
    }
    return NOERROR;
}


HRESULT HrCleanTempFile(LPATTACHDATA pAttach)
{
    if (pAttach)
    {
        if (*pAttach->szTempFile && pAttach->hAttach)
        {
            // we only clean the tempfile if hAttach != NULL. Otherwise we assume it's a new attachment
            // and szTempFile points to the source file
            // If the file was launched, don't delete the temp file if the process still has it open
            if (pAttach->hProcess)
            {
                if (WaitForSingleObject (pAttach->hProcess, 0) == WAIT_OBJECT_0)
                    DeleteFileWrapW(pAttach->szTempFile);
            }
            else
                DeleteFileWrapW(pAttach->szTempFile);
        }
        *pAttach->szTempFile = NULL;
        pAttach->hProcess=NULL;
    }
    return NOERROR;
}

HRESULT HrAttachSafetyFromBodyPart(IMimeMessage *pMsg, HBODY hAttach, BOOL *pfSafe)
{
    LPWSTR pszW = NULL;

    Assert (pMsg && pfSafe && hAttach);

    *pfSafe = FALSE;
    if (MimeOleGetBodyPropW(pMsg, hAttach, PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &pszW)==S_OK)
    {
        if(IsPlatformWinNT() != S_OK)
        {
            CHAR pszFile[MAX_PATH*2];

            WideCharToMultiByte(CP_ACP, 0, pszW, -1, pszFile, ARRAYSIZE(pszFile), NULL, NULL);
            MultiByteToWideChar(CP_ACP, 0, pszFile, -1, pszW, lstrlenW(pszW));
            CleanupFileNameInPlaceW(pszW);
        }
        *pfSafe = (IsSafeToRun(NULL, pszW, FALSE) == MIMEEDIT_S_OPENFILE);
        MemFree(pszW);
    }

    return S_OK;
}

STDAPI HrGetDisplayNameWithSizeForFile(LPWSTR pszPathName, LPWSTR pszDisplayName, int cchMaxDisplayName)
{
    HANDLE  hFile;
    DWORD   uFileSize;
    WCHAR   szSize[MAX_CHARS_FOR_NUM+1+3],
            szBuff[MAX_CHARS_FOR_NUM+1];
    LPWSTR  pszFileName = NULL,
            pszFirst;
    int     iSizeLen = 0,
            iLenFirst;

    szSize[0] = L'\0';

    hFile = CreateFileWrapW(pszPathName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        uFileSize = GetFileSize(hFile, NULL);
        CloseHandle(hFile);
        if ((uFileSize != 0xffffffff) && StrFormatByteSizeW(uFileSize, szBuff, ARRAYSIZE(szBuff) - 1))
        {
            StrCpyW(szSize, L" (");
            StrCatW(szSize, szBuff);
            StrCatW(szSize, L")");
        }
    }
    pszFileName = PathFindFileNameW(pszPathName);

    iSizeLen = lstrlenW(szSize);
    if (pszFileName)
        pszFirst = pszFileName;
    else
        pszFirst = pszPathName;

    iLenFirst = lstrlenW(pszFirst);
    StrCpyNW(pszDisplayName, pszFirst, cchMaxDisplayName);

    if (iLenFirst + iSizeLen + 1 > cchMaxDisplayName)
        return E_FAIL;

    StrCpyNW(pszDisplayName + iLenFirst, szSize, cchMaxDisplayName - iLenFirst);
    return S_OK;
}


STDAPI HrSaveAttachmentAs(HWND hwnd, IMimeMessage *pMsg, LPATTACHDATA lpAttach)
{
    HRESULT         hr = S_OK;
    OPENFILENAMEW   ofn;
    WCHAR           szTitle[CCHMAX_STRINGRES],
                    szFilter[CCHMAX_STRINGRES],
                    szFile[MAX_PATH];

    *szFile=0;
    *szFilter=0;
    *szTitle=0;

    Assert (lpAttach->szFileName);
    if (lpAttach->szFileName)
        StrCpyNW(szFile, lpAttach->szFileName, ARRAYSIZE(szFile));

    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    LoadStringWrapW(g_hLocRes, idsFilterAttSave, szFilter, ARRAYSIZE(szFilter));
    ReplaceCharsW(szFilter, L'|', L'\0');
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    LoadStringWrapW(g_hLocRes, idsSaveAttachmentAs, szTitle, ARRAYSIZE(szTitle));
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    // Show SaveAs Dialog
    if (HrAthGetFileNameW(&ofn, FALSE) != S_OK)
    {
        hr = hrUserCancel;
        goto error;
    }
    
    if (lpAttach->hAttach == NULL)
    {
        if (!PathFileExistsW(lpAttach->szFileName))
        {
            hr = hrNotFound;
            goto error;
        }

        // if hAttach == NULL then try and copy the file
        CopyFileWrapW(lpAttach->szFileName, szFile, TRUE);
    }
    else
    {
        // Verify the Attachment's Stream
        hr=HrSaveAttachToFile(pMsg, lpAttach->hAttach, szFile);
        if (FAILED(hr))
            goto error;
    }
error:
    return hr;
}



HRESULT HrGetTempFile(IMimeMessage *pMsg, LPATTACHDATA lpAttach)
{
    HRESULT         hr;
    
    if (*lpAttach->szTempFile)
        return S_OK;
    
    if (!FBuildTempPathW(lpAttach->szFileName, lpAttach->szTempFile, ARRAYSIZE(lpAttach->szTempFile), FALSE))
    {
        hr = E_FAIL;
        goto error;
    }
    
    if (lpAttach->hAttach)
    {
        hr=HrSaveAttachToFile(pMsg, lpAttach->hAttach, lpAttach->szTempFile);
        if (FAILED(hr))
            goto error;
    }
    else
    {
        AssertSz(lpAttach->pstm, "if no hAttach then pstm should be set");
        
        hr = WriteStreamToFileW(lpAttach->pstm, lpAttach->szTempFile, CREATE_ALWAYS, GENERIC_WRITE);
        if (FAILED(hr))
            goto error;
    }
    
error:
    if (FAILED(hr))
    {
        // Null out temp file as we didn't really create it
        *(lpAttach->szTempFile)=0;
    }
    return hr;
}

const BYTE c_rgbUTF[3] = {0xEF, 0xBB, 0xBF};
STDAPI HrSaveAttachToFile(IMimeMessage *pMsg, HBODY hAttach, LPWSTR lpszFileName)
{
    HRESULT         hr;
    LPSTREAM        pstm=NULL,
                    pstmOut=NULL;
    BOOL            fEndian,
                    fUTFEncoded = FALSE;
    BYTE            rgbBOM[2];
    BYTE            rgbUTF[3];
    DWORD           cbRead;

    if (pMsg == NULL || hAttach == NULL)
        IF_FAILEXIT(hr =  E_INVALIDARG);

    // bind to the attachment data
    IF_FAILEXIT(hr=pMsg->BindToObject(hAttach, IID_IStream, (LPVOID *)&pstm));

    // create a file stream
    IF_FAILEXIT(hr = OpenFileStreamW(lpszFileName, CREATE_ALWAYS, GENERIC_WRITE, &pstmOut));

    // if we have an .HTM file, then pre-pend 'mark of the web' comment
    // If we are a unicode file, the BOM will be "0xFFFE"
    // If we are a UTF8 file, the BOM will be "0xEFBBBF"
    if (PathIsHTMLFileW(lpszFileName))
    {
        if (S_OK == HrIsStreamUnicode(pstm, &fEndian))
        {
            // Don't rewind otherwise end up with BOM after 'mark of the web' as well.
            IF_FAILEXIT(hr = pstm->Read(rgbBOM, sizeof(rgbBOM), &cbRead));

            // Since HrIsStreamUnicode succeeded, there should be at least two
            Assert(sizeof(rgbBOM) == cbRead);

            IF_FAILEXIT(hr = pstmOut->Write(rgbBOM, cbRead, NULL));
            IF_FAILEXIT(hr = pstmOut->Write(c_wszWebMark, sizeof(c_wszWebMark)-sizeof(WCHAR), NULL));
        }
        else
        {
            // Check for UTF8 file BOM
            IF_FAILEXIT(hr = pstm->Read(rgbUTF, sizeof(rgbUTF), &cbRead));
            if (sizeof(rgbUTF) == cbRead)
            {
                fUTFEncoded = (0 == memcmp(c_rgbUTF, rgbUTF, sizeof(rgbUTF)));
            }

            // If we are not UTF8 encoded, then rewind, else write out BOM
            if (!fUTFEncoded)
                IF_FAILEXIT(hr = HrRewindStream(pstm));
            else
                IF_FAILEXIT(hr = pstmOut->Write(c_rgbUTF, sizeof(c_rgbUTF), NULL));

            IF_FAILEXIT(hr = pstmOut->Write(c_szWebMark, sizeof(c_szWebMark)-sizeof(CHAR), NULL));

        }
    }
    
    // write out the actual file data
    IF_FAILEXIT(hr = HrCopyStream(pstm, pstmOut, NULL));

exit:
    ReleaseObj(pstm);
    ReleaseObj(pstmOut);
    return hr;
}



/*
 * Why? 
 * 
 * we wrap this as if we don't use NOCHANGEDIR, then things like ShellExec
 * fail if the current directory is nolonger valid. Eg: attach a file from a:\
 * and remove the floppy. Then all ShellExec's fail. So we maintain our own
 * last directory buffer. We should use thread-local for this, as it is possible
 * that two thread could whack the same buffer, it is unlikley that a user action
 * could cause two open file dialogs in the note and the view to open at exactly the
 * same time.
 */

WCHAR   g_wszLastDir[MAX_PATH];

HRESULT SetDefaultSpecialFolderPath()
{
    LPITEMIDLIST    pidl = NULL;
    HRESULT         hr = E_FAIL;

    if (SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl)==S_OK)
    {
        if (SHGetPathFromIDListWrapW(pidl, g_wszLastDir))
            hr = S_OK;
        
        SHFree(pidl);
    }
    return hr;
}

STDAPI HrAthGetFileName(OPENFILENAME *pofn, BOOL fOpen)
{
    BOOL    fRet;
    LPSTR   pszDir = NULL;
    HRESULT hr = S_OK;

    Assert(pofn != NULL);

    // force NOCHANGEDIR
    pofn->Flags |= OFN_NOCHANGEDIR;

    if (pofn->lpstrInitialDir == NULL)
    {
        if (!PathFileExistsW(g_wszLastDir))
            SideAssert(SetDefaultSpecialFolderPath()==S_OK);
    
        IF_NULLEXIT(pszDir = PszToANSI(CP_ACP, g_wszLastDir));
        
        pofn->lpstrInitialDir = pszDir;
    }

    if (fOpen)
        fRet = GetOpenFileName(pofn);
    else
        fRet = GetSaveFileName(pofn);        
    
    if (fRet)
    {
        // store the last path
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pofn->lpstrFile, lstrlen(pofn->lpstrFile), g_wszLastDir, ARRAYSIZE(g_wszLastDir));
        if (!PathIsDirectoryW(g_wszLastDir))
            PathRemoveFileSpecW(g_wszLastDir);
    }
    else
        TraceResult(hr = E_FAIL);

exit:
    MemFree(pszDir);
    
    return hr;
}

STDAPI HrAthGetFileNameW(OPENFILENAMEW *pofn, BOOL fOpen)
{
    BOOL    fRet;

    Assert(pofn != NULL);

    // force NOCHANGEDIR
    pofn->Flags |= OFN_NOCHANGEDIR;

    if (pofn->lpstrInitialDir == NULL)
    {
        if (!PathFileExistsW(g_wszLastDir))
            SideAssert(SetDefaultSpecialFolderPath()==S_OK);
    
        pofn->lpstrInitialDir = g_wszLastDir;
    }

    if (fOpen)
        fRet = GetOpenFileNameWrapW(pofn);
    else
        fRet = GetSaveFileNameWrapW(pofn);        
    
    if (fRet)
    {
        // store the last path
        StrCpyNW(g_wszLastDir, pofn->lpstrFile, ARRAYSIZE(g_wszLastDir));
        if (!PathIsDirectoryW(g_wszLastDir))
            PathRemoveFileSpecW(g_wszLastDir);
    }
    
    return fRet?S_OK:E_FAIL;
}

STDAPI  HrGetLastOpenFileDirectory(int cchMax, LPSTR lpsz)
{
    if (!PathFileExistsW(g_wszLastDir))
        SideAssert(SetDefaultSpecialFolderPath()==S_OK);

    WideCharToMultiByte(CP_ACP, 0, g_wszLastDir, lstrlenW(g_wszLastDir), lpsz, cchMax, NULL, NULL);
    return S_OK;
}

STDAPI  HrGetLastOpenFileDirectoryW(int cchMax, LPWSTR lpsz)
{
    if (!PathFileExistsW(g_wszLastDir))
        SideAssert(SetDefaultSpecialFolderPath()==S_OK);

    StrCpyNW(lpsz, g_wszLastDir, cchMax);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\dll\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#include <initguid.h>
#include <ole2.h>
#include <shlguidp.h>
#define INITGUID
#include "mimeole.h"
#ifdef SMIME_V3
#include "smimepol.h"
#endif // SMIME_V3
#include "mimeolep.h"
#include "mimeedit.h"
#ifndef MAC
#include "imnxport.h"
#endif  // !MAC
#include "stmlock.h"
#ifndef WIN16
#include "ibdylock.h"
#endif // !WIN16
#include "ibdystm.h"
#ifndef MAC
#include "ixpurl.h"
#endif  // !MAC
#include <xmlparser.h>
#include <booktree.h>

#ifdef WIN16
// The BINDNODESTATE type was defined in "booktree.h" file - only for WATCOMC.
#include "ibdylock.h"
#include <olectlid.h>           // IID_IPersistStreamInit
#endif // WIN16

#include <containx.h>
#include <bookbody.h>
#ifndef MAC
#include <mlang.h>
#endif  // !MAC
#include <msoert.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\common\attmenu.h ===
#ifndef _ATTMENU_H
#define _ATTMENU_H

interface IOleCommandTarget;

class CAttMenu
{
public:
    CAttMenu();
    ~CAttMenu();

    ULONG AddRef();
    ULONG Release();

    HRESULT Init(IMimeMessage *pMsg, IFontCache *pFntCache, IOleInPlaceFrame *pFrame, IOleCommandTarget *pHostCmdTarget);
    HRESULT HasAttach();
    HRESULT HasEnabledAttach();
    HRESULT Show(HWND hwnd, LPPOINT ppt, BOOL fRightClick);
    
    HRESULT HasVCard();
    HRESULT LaunchVCard(HWND hwnd);

    static LRESULT ExtSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    HMENU               m_hMenu;
    ULONG               m_cRef,
                        m_uVerb,
                        m_cAttach,
                        m_cVisibleAttach,
                        m_cEnabledAttach;
    BOOL                m_fAllowUnsafe;
    int                 m_cxMaxText;
    HCHARSET            m_hCharset;
    IFontCache          *m_pFntCache;
    IOleInPlaceFrame    *m_pFrame;
    IOleCommandTarget   *m_pHostCmdTarget;
    WNDPROC             m_pfnWndProc;
    IMimeMessage        *m_pMsg;
    BOOL                m_fShowingMenu;
    LPATTACHDATA        m_pAttachVCard;
    HBODY               m_hVCard;
    HBODY               *m_rghAttach;

    HRESULT BuildMenu();
    HRESULT DestroyMenu(HMENU hMenu);
    HRESULT OnMeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpmis);
    HRESULT OnDrawItem(HWND hwnd, LPDRAWITEMSTRUCT lpdis);
    HRESULT OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam);
    HRESULT GetItemTextExtent(HWND hwnd, LPWSTR szDisp, LPSIZE pSize);
    HRESULT SubClassWindow(HWND hwnd, BOOL fOn);
    HRESULT FindItem(int idm, BOOL fByPos, LPATTACHDATA *ppAttach);    
    HRESULT HrSaveAll(HWND hwnd);
    HRESULT ScanForAttachmentCount();
};

typedef CAttMenu *LPATTMENU;

HRESULT SaveAttachmentsWithPath(HWND hwnd, IOleCommandTarget *pCmdTarget, IMimeMessage *pMsg);

#endif // _ATTMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\common\attmenu.cpp ===
/*
 *    a t t m e n u. c p p
 *    
 *    Purpose:
 *        Attachment menu
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include "docobj.h"
#include "resource.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include "mimeole.h"
#include "mimeolep.h"
#include "attmenu.h"
#include "saveatt.h"
#include <icutil.h>
#include "demand.h"

ASSERTDATA

/*
 *  e x t e r n s
 */

/*
 *  t y p e d e f s 
 */

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s 
 */

/*
 *  g l o b a l s 
 */

static const TCHAR  c_szSubThisPtr[]="AttMenu_SubThisPtr";

/*
 *  p r o t o t y p e s
 */



CAttMenu::CAttMenu()
{
    m_hMenu=NULL;
    m_cRef=1;
    m_hCharset=NULL;
    m_pFntCache=NULL;
    m_pFrame=NULL;
    m_pMsg=NULL;
    m_pfnWndProc=NULL;
    m_fShowingMenu=FALSE;
    m_pAttachVCard=NULL;
    m_pHostCmdTarget=NULL;
    m_cAttach = 0;
    m_cVisibleAttach = 0;
    m_cEnabledAttach = 0;
    m_fAllowUnsafe = FALSE;
    m_hVCard = NULL;
    m_rghAttach = NULL;

}

CAttMenu::~CAttMenu()
{
    if (m_hMenu)
        DestroyMenu(m_hMenu);
    HrFreeAttachData(m_pAttachVCard);    
    ReleaseObj(m_pFntCache);
    ReleaseObj(m_pFrame);
    ReleaseObj(m_pMsg);
    ReleaseObj(m_pHostCmdTarget);
    SafeMemFree(m_rghAttach);
}


ULONG CAttMenu::AddRef()
{
    return ++m_cRef;
}

ULONG CAttMenu::Release()
{
    m_cRef--;
    if (m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CAttMenu::Init(IMimeMessage *pMsg, IFontCache *pFntCache, IOleInPlaceFrame *pFrame, IOleCommandTarget *pHostCmdTarget)
{
    if (pMsg==NULL || pFntCache==NULL)
        return E_INVALIDARG;

    ReplaceInterface(m_pFntCache, pFntCache);
    ReplaceInterface(m_pFrame, pFrame);
    ReplaceInterface(m_pMsg, pMsg);
    ReplaceInterface(m_pHostCmdTarget, pHostCmdTarget);
    pMsg->GetCharset(&m_hCharset);
    return ScanForAttachmentCount();
}

HRESULT CAttMenu::Show(HWND hwnd, LPPOINT ppt, BOOL fRightClick)
{
    ULONG           iCmd;
    LPATTACHDATA    lpAttach;
    HRESULT         hr=S_OK;

    // Check Params
    AssertSz (hwnd && ppt, "Null Parameter");

    if (m_fShowingMenu)
        return S_OK;

    if (m_hMenu == NULL)
        {
        hr = BuildMenu();
        if (FAILED(hr))
            goto error;
        }

    Assert (m_hMenu);

    // BUG: If the right edge is off the screen, TrackPopupMenu picks a random point
    // ppt->x = min(GetSystemMetrics(SM_CXSCREEN), ppt->x);

    // set m_uVerb so we can show correct context menu help for Open or Save.
    m_uVerb = fRightClick || (GetAsyncKeyState(VK_CONTROL)&0x8000) ? AV_SAVEAS : AV_OPEN;
    
    m_fShowingMenu=TRUE;
    SubClassWindow(hwnd, TRUE);

    // sheer brillance. We subclass the parent window during the context menu loop so we can steal the
    // owndraw messages and also steal the menu select messages.

    iCmd = (ULONG)TrackPopupMenu (m_hMenu, TPM_RIGHTALIGN | TPM_LEFTBUTTON | TPM_RETURNCMD, ppt->x, ppt->y, 0, hwnd, NULL);

    SubClassWindow(hwnd, FALSE);
    m_fShowingMenu=FALSE;

    if (iCmd<=0)        // nothing selected, bail
        goto error;
    
    if (iCmd == idmSaveAllAttach)
        return HrSaveAll(hwnd);


    hr = FindItem(iCmd, FALSE, &lpAttach);
    if (FAILED(hr))
        goto error;

    hr = HrDoAttachmentVerb(hwnd, m_uVerb, m_pMsg, lpAttach);

error:
    return hr;
}





/*
 * note, we build the attachment menu we hang the lpAttach data off the context menu 
 * which contains all the temp file to delete etc.
 */

HRESULT CAttMenu::BuildMenu()
{
    HRESULT             hr = S_OK;
    MENUITEMINFO        mii={0};
    INT                 iMenu = 0;
    int                 cyMenu, cyMenuMax, cyItem;    
    SIZE                size;
    ULONG               uAttach;
    LPATTACHDATA        pAttach;
    int                 cSafeFiles = 0;

    Assert (!m_hMenu);

    // Create the menu
    m_hMenu = CreatePopupMenu();
    if (!m_hMenu)
        return E_OUTOFMEMORY;

    // figure out where to put menu breaks
    cyMenu = 0;
    cyMenuMax = GetSystemMetrics(SM_CYSCREEN);

    // calculate the rough height of each item, and the maximum width
    // for the attachment name
    GetItemTextExtent(NULL, L"BIGGERMAXATTACHMENTNAME.TXT", &size);
    m_cxMaxText = size.cx;
    cyItem = max(size.cy, GetSystemMetrics(SM_CYSMICON)) + 8;

    mii.cbSize = sizeof(mii); 
    mii.fMask = MIIM_DATA|MIIM_ID|MIIM_TYPE; 
    mii.fType = MFT_OWNERDRAW; 
    mii.wID = 1;

    /*
     * This is weird, but cool. So we assign menu items idms based on idmSaveAttachLast + i
     * where i is the item added. If we're a popup on a menubar, then we ensure that we don't go
     * over the reserved limit. If we're not then we are a context menu. The context menu is called with
     * TPM_RETURNCMD, so the commands are not sent to the owners WM_COMMAND. Therefore over-running this range
     * and going into someone elses idm-space is not an issue.
     */

    for (uAttach=0; uAttach<m_cAttach; uAttach++)
    {
        if (m_rghAttach[uAttach] != m_hVCard)
        {
            hr = HrAttachDataFromBodyPart(m_pMsg, m_rghAttach[uAttach], &pAttach);
            if (!FAILED(hr))
            {
                // for the ownerdraw menus, we simply hang off the attachment pointers, we are guaranteed
                // these to be valid during the lifetime of the menu
                mii.dwItemData = (DWORD_PTR)pAttach; 
                mii.fType = MFT_OWNERDRAW; 
            
                // insert menu breaks as appropriate
                cyMenu += cyItem;
                if (cyMenu >= cyMenuMax)
                {
                    mii.fType |= MFT_MENUBARBREAK;
                    cyMenu = cyItem;
                }

                if (pAttach && !pAttach->fSafe && !m_fAllowUnsafe)
                {
                    mii.fMask |= MIIM_STATE;
                    mii.fState = MFS_DISABLED;
                }
                else
                    cSafeFiles++;

                if (!InsertMenuItem (m_hMenu, iMenu++, TRUE, &mii))
                {
                    MemFree(pAttach);
                    hr = E_FAIL;
                    goto error;
                }
                mii.fMask &= ~MIIM_STATE;
                mii.fState = 0;

                mii.wID++;
            }
        }                
    }

    mii.fType = MFT_SEPARATOR;
    mii.dwItemData=0;
    InsertMenuItem (m_hMenu, iMenu++, TRUE, &mii);

    // we have to owner-draw this menu item as we draw the entire menu in a different font
    // based on the message locale
    mii.fType = MFT_OWNERDRAW;
    mii.dwTypeData = NULL;
    mii.dwItemData = NULL;
    mii.wID = idmSaveAllAttach;
    if (!m_fAllowUnsafe)
    {
        if (!cSafeFiles)
        {
            mii.fMask |= MIIM_STATE;
            mii.fState = MFS_DISABLED;
        }
        m_cEnabledAttach = cSafeFiles;
    }
    InsertMenuItem (m_hMenu, iMenu++, TRUE, &mii);

error:
    // Failed cond
    if (FAILED (hr) && m_hMenu)
        DestroyMenu(m_hMenu);

    // Done
    return hr;
}

HRESULT CAttMenu::DestroyMenu(HMENU hMenu)
{
    ULONG           uItem,
                    cItems;
    LPATTACHDATA    pAttach;

    cItems = GetMenuItemCount(hMenu);
    
    for (uItem = 0; uItem < cItems; uItem++)
    {
        // free the lpAttach hanging off the menu
        if (FindItem(uItem, TRUE, &pAttach)==S_OK)
            HrFreeAttachData(pAttach);
    }

    ::DestroyMenu(hMenu);
    return S_OK;
}



HRESULT CAttMenu::OnMeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpmis)
{
    WORD                cxIcon=(WORD)GetSystemMetrics (SM_CXSMICON), 
                        cyIcon=(WORD)GetSystemMetrics (SM_CYSMICON);
    SIZE                rSize;
    LPATTACHDATA        lpAttach;
    WCHAR               rgch[CCHMAX_STRINGRES];

    Assert(lpmis && hwnd);

    if (lpmis->CtlType == ODT_MENU)
    {
        // Default width and height
        lpmis->itemHeight = cyIcon + 8;
        lpmis->itemWidth = cxIcon + 9;
        
        lpAttach = (LPATTACHDATA)lpmis->itemData;
        if (lpAttach)
        {
            if (FAILED(GetItemTextExtent(hwnd, lpAttach->szDisplay, &rSize)))
                return E_FAIL;
            
            lpmis->itemWidth += min(rSize.cx, m_cxMaxText);
            lpmis->itemHeight = max (rSize.cy, cyIcon) + 8;
            return S_OK;
        }
        
        if (lpmis->itemID == idmSaveAllAttach)
        {
            LoadStringWrapW(g_hLocRes, idsSaveAllAttach, rgch, ARRAYSIZE(rgch));
            if (FAILED(GetItemTextExtent(hwnd, rgch, &rSize)))
                return E_FAIL;
            
            lpmis->itemWidth  = min(rSize.cx, m_cxMaxText) + 9;
            lpmis->itemHeight = max (rSize.cy, cyIcon) + 8;
            return S_OK;
        }
    }
    return E_FAIL;
}

HRESULT CAttMenu::GetItemTextExtent(HWND hwnd, LPWSTR szDisp, LPSIZE pSize)
{
    HDC         hdc;
    HFONT       hFont=0,
                hFontOld;
    HRESULT     hr=E_FAIL;
    
    // I need a DC to measure the size of the menu font
    hdc = GetDC (hwnd);
    if (hdc)
    {
        Assert (m_hCharset!=NULL);
        Assert (m_pFntCache);
        
        // Create the menu font
        m_pFntCache->GetFont(FNT_SYS_MENU, m_hCharset, &hFont);
        if (hFont)
            hFontOld = SelectFont (hdc, hFont);
        
        // Get the size of the text
        hr = GetTextExtentPoint32AthW(hdc, szDisp, lstrlenW(szDisp), pSize, DT_NOPREFIX)?S_OK:S_FALSE;
        
        if (hFont)
            SelectObject (hdc, hFontOld);
        
        ReleaseDC (hwnd, hdc);
    }
    return S_OK;
}

HRESULT CAttMenu::OnDrawItem(HWND hwnd, LPDRAWITEMSTRUCT lpdis)
{
    DWORD           rgbBack, rgbText;
    WORD            dx, x, y, 
                    cxIcon=(WORD) GetSystemMetrics (SM_CXSMICON), 
                    cyIcon=(WORD) GetSystemMetrics (SM_CYSMICON);
    HFONT           hFont = NULL, 
                    hFontOld = NULL;
    LPATTACHDATA    lpAttach;
    RECT            rc;
    LPWSTR          pszDisplay;
    WCHAR           rgch[CCHMAX_STRINGRES];
    HICON           hIcon;
    HCHARSET        hCharset;
            
    AssertSz (lpdis, "Null Parameter");

    // not a menu
    if (lpdis->CtlType != ODT_MENU)
        return E_FAIL;

    if (lpdis->itemID == idmSaveAllAttach)
    {
        if (!LoadStringWrapW(g_hLocRes, idsSaveAllAttach, rgch, ARRAYSIZE(rgch)))
            return E_FAIL;
        
        pszDisplay = rgch;
        hIcon=NULL;
        hCharset = NULL;    // always draw in system font
    }
    else
    {
        lpAttach = (LPATTACHDATA)lpdis->itemData;
        if (!lpAttach)
            return E_FAIL;
        
        hIcon = lpAttach->hIcon;
        pszDisplay = lpAttach->szDisplay;
        hCharset = m_hCharset;  // always draw in localised font
    }
    
    // Determine Colors
    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor (lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
        if (lpdis->itemState & ODS_DISABLED)
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_GRAYTEXT));
        else
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor (lpdis->hDC, GetSysColor(COLOR_MENU));
        if (lpdis->itemState & ODS_DISABLED)
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_GRAYTEXT));
        else
            rgbText = SetTextColor (lpdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
    }
    
    // Clear the item
    ExtTextOutWrapW(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, ETO_OPAQUE, &lpdis->rcItem, NULL, 0, NULL);
    
    dx = 4;
    if (hIcon)
    {
        x = (WORD) lpdis->rcItem.left + dx;
        y = (WORD) lpdis->rcItem.top + (INT)(((lpdis->rcItem.bottom - lpdis->rcItem.top) / 2) - (INT)(cyIcon / 2));
        DrawIconEx(lpdis->hDC, x, y, lpAttach->hIcon, cxIcon, cyIcon, NULL, NULL, DI_NORMAL);
    }
    
    // Create the menu font
    
    m_pFntCache->GetFont(FNT_SYS_MENU, hCharset, &hFont);
    if (hFont)
        hFontOld = (HFONT)SelectObject (lpdis->hDC, hFont);
    
    rc = lpdis->rcItem;
    rc.left += (cxIcon + (2*dx));
    rc.right -= 2*dx;
    DrawTextExWrapW(lpdis->hDC, pszDisplay, lstrlenW(pszDisplay), &rc, DT_END_ELLIPSIS|DT_SINGLELINE|DT_VCENTER|DT_WORDBREAK|DT_NOPREFIX, NULL);
    
    if (hFont)
        SelectObject (lpdis->hDC, hFontOld);
    
    // Reset Text Colors
    SetTextColor (lpdis->hDC, rgbText);
    SetBkColor (lpdis->hDC, rgbBack);
    return S_OK;
}


HRESULT CAttMenu::OnMenuSelect(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LPATTACHDATA    pAttach;
    WCHAR           wszRes[CCHMAX_STRINGRES],
                    wsz[CCHMAX_STRINGRES + ARRAYSIZE(pAttach->szDisplay)];
    
    if (!m_pFrame)
        return E_FAIL;
    
    if (HIWORD(wParam)&MF_OWNERDRAW)
    {
        if (LOWORD(wParam) == idmSaveAllAttach)
        {
            SideAssert(LoadStringWrapW(g_hLocRes, idsSaveAllAttachMH, wszRes, ARRAYSIZE(wszRes)));
            m_pFrame->SetStatusText(wszRes);
            return S_OK;
        }
        
        if (FindItem(LOWORD(wParam), FALSE, &pAttach)==S_OK)
        {
            int iLen;

            // if we're showing the context menu, rather than the save-attachment menu then we offer menuhelp
            // in the Form of 'Opens the attachment'. If a right-click context, do a save
            LoadStringWrapW(g_hLocRes, 
                            (m_uVerb == AV_OPEN) ? idsOpenAttachControl : idsSaveAttachControl, 
                            wszRes, 
                            ARRAYSIZE(wszRes));
            
            // Should be safe from buffer overrun due to limited size of pAttach->szDisplay
            iLen = AthwsprintfW(wsz, ARRAYSIZE(wsz), wszRes, pAttach->szDisplay);
            Assert(iLen < ARRAYSIZE(wsz));
            
                m_pFrame->SetStatusText(wsz);
            return S_OK;
        }
    }
    return S_FALSE;
}

HRESULT CAttMenu::SubClassWindow(HWND hwnd, BOOL fOn)
{
    if (fOn)
    {
        Assert (!m_pfnWndProc);
        SetProp(hwnd, c_szSubThisPtr, (HANDLE)this);
        m_pfnWndProc = (WNDPROC)SetWindowLongPtrAthW(hwnd, GWLP_WNDPROC, (LONG_PTR)ExtSubClassProc);
    }
    else
    {
        Assert (m_pfnWndProc);
        SetWindowLongPtrAthW(hwnd, GWLP_WNDPROC, (LONG_PTR)m_pfnWndProc);
        RemoveProp(hwnd, c_szSubThisPtr);
        m_pfnWndProc=NULL;
    }
    return S_OK;
}


LRESULT CAttMenu::ExtSubClassProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAttMenu    *pAttMenu = (CAttMenu *)GetProp(hwnd, c_szSubThisPtr);
    
    Assert (pAttMenu);
    switch (msg)
    {
    case WM_MEASUREITEM:
        pAttMenu->OnMeasureItem(hwnd, (LPMEASUREITEMSTRUCT)lParam);
        break;
        
    case WM_DRAWITEM:
        pAttMenu->OnDrawItem(hwnd, (LPDRAWITEMSTRUCT)lParam);
        break;
        
    case WM_MENUSELECT:
        pAttMenu->OnMenuSelect(hwnd, wParam, lParam);
        break;
    }
    
    return CallWindowProcWrapW(pAttMenu->m_pfnWndProc, hwnd, msg, wParam, lParam);
}


HRESULT CAttMenu::FindItem(int idm, BOOL fByPos, LPATTACHDATA *ppAttach)
{
    MENUITEMINFO    mii;
    
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask  = MIIM_DATA;
    
    Assert (ppAttach);
    
    if (GetMenuItemInfo(m_hMenu, idm, fByPos, &mii) && mii.dwItemData)
    {
        *ppAttach = (LPATTACHDATA)mii.dwItemData;
        return S_OK;
    }
    return E_FAIL;
}


HRESULT CAttMenu::HasAttach()
{
    return m_cVisibleAttach ? S_OK:S_FALSE;
}

HRESULT CAttMenu::HasEnabledAttach()
{
    return m_cEnabledAttach ? S_OK:S_FALSE;
}

HRESULT CAttMenu::HasVCard()
{
    return  m_hVCard ? S_OK:S_FALSE;
}

HRESULT CAttMenu::LaunchVCard(HWND hwnd)
{
    if (!m_hVCard)
        return E_FAIL;

    if (m_pAttachVCard==NULL &&
        HrAttachDataFromBodyPart(m_pMsg, m_hVCard, &m_pAttachVCard)!=S_OK)
        return E_FAIL;

    return HrDoAttachmentVerb(hwnd, AV_OPEN, m_pMsg, m_pAttachVCard);
}

HRESULT CAttMenu::HrSaveAll(HWND hwnd)
{
    return SaveAttachmentsWithPath(hwnd, m_pHostCmdTarget, m_pMsg);
}


HRESULT SaveAttachmentsWithPath(HWND hwnd, IOleCommandTarget *pCmdTarget, IMimeMessage *pMsg)
{
    VARIANTARG          va;
    WCHAR               rgchPath[MAX_PATH];
    HRESULT             hr;
    BOOL                fAllowUnsafe = FALSE;

    *rgchPath = 0;

    if (pCmdTarget && 
        pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SAVEATTACH_PATH, 0, NULL, &va)==S_OK &&
        va.vt == VT_BSTR && 
        va.bstrVal)
    {
        StrCpyNW(rgchPath, va.bstrVal, ARRAYSIZE(rgchPath));
        SysFreeString(va.bstrVal);
    }
    
    if (pCmdTarget && 
        pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_UNSAFEATTACHMENTS, 0, NULL, &va)==S_OK &&
        va.vt == VT_I4 && va.lVal == 0)
        fAllowUnsafe = TRUE;

    hr = HrSaveAttachments(hwnd, pMsg, rgchPath, ARRAYSIZE(rgchPath), fAllowUnsafe);
    if (hr == S_OK)
    {
        // if successful, then set the save attachment path

        if (pCmdTarget)
        {
            va.bstrVal = SysAllocStringLen(NULL, lstrlenW(rgchPath));
            if (va.bstrVal)
            {
                StrCpyW(va.bstrVal, rgchPath);
                va.vt = VT_BSTR;

                pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SAVEATTACH_PATH, 0, &va, NULL);
                SysFreeString(va.bstrVal);
            }
            else
                TraceResult(hr = E_OUTOFMEMORY);
        }
    }

    return hr;
}

HRESULT CAttMenu::ScanForAttachmentCount()
{
    ULONG       uAttach,
                cAttach=0;
    LPSTR       psz;
    PROPVARIANT pv;
    VARIANTARG  va;

    // we quickly need to determine if there's a Vcard and or/attachments
    // so the preview pane can update the icons. When clicked on, we then defer-load the
    // actual info.

    Assert(m_rghAttach == NULL);
    Assert(m_cVisibleAttach == 0);
    Assert(m_cEnabledAttach == 0);
    Assert(m_cAttach == 0);

    if (m_pHostCmdTarget && 
        m_pHostCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_UNSAFEATTACHMENTS, 0, NULL, &va)==S_OK &&
        va.vt == VT_I4 && va.lVal == 0)
        m_fAllowUnsafe = TRUE;

    if (m_pMsg &&
        m_pMsg->GetAttachments(&cAttach, &m_rghAttach)==S_OK)
    {
        for (uAttach=0; uAttach<cAttach; uAttach++)
        {
            BOOL fSafe = FALSE;

            if (m_hVCard == NULL &&
                MimeOleGetBodyPropA(m_pMsg, m_rghAttach[uAttach], PIDTOSTR(PID_HDR_CNTTYPE), NOFLAGS, &psz)==S_OK)
            {
                // hang onto first v-card
                if (lstrcmpi(psz, "text/x-vcard")==0)
                    m_hVCard = m_rghAttach[uAttach];
                MemFree(psz);
            }
            if (!m_fAllowUnsafe && SUCCEEDED(HrAttachSafetyFromBodyPart(m_pMsg, m_rghAttach[uAttach], &fSafe)) && fSafe)
                m_cEnabledAttach++;
        }
    }

    // we keep the actual attachment count (tells the size of m_rghAttach) and also the 
    // count of 'visible' attachment we want to show
    m_cVisibleAttach = m_cAttach = cAttach;

    if (m_hVCard)
    {
        Assert (cAttach>0);
        m_cVisibleAttach--;
        m_cEnabledAttach--;
    }
    if (m_fAllowUnsafe)   // all visible attachments are enabled if we allow all files
        m_cEnabledAttach = m_cVisibleAttach;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\dll\factory.h ===
// --------------------------------------------------------------------------------
// Factory.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __FACTORY_H
#define __FACTORY_H

// --------------------------------------------------------------------------------
// Forward Decls
// --------------------------------------------------------------------------------
class CClassFactory;

// --------------------------------------------------------------------------------
// Object Flags
// --------------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

// --------------------------------------------------------------------------------
// Object Creation Prototypes
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

// --------------------------------------------------------------------------------
// InetComm ClassFactory
// --------------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    // ----------------------------------------------------------------------------
    // Public Data
    // ----------------------------------------------------------------------------
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;

    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    // ----------------------------------------------------------------------------
    // IUnknown members
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IClassFactory members
    // ----------------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

// --------------------------------------------------------------------------------
// Object Creators
// --------------------------------------------------------------------------------
HRESULT IVirtualStream_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT WebBookContentBody_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT WebBookContentTree_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeAllocator_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeSecurity_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeInternational_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT ISMTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IPOP3Transport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT INNTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IRASTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IIMAPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IHTTPMailTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IPropFindRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IPropPatchRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IRangeList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeMessageParts_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeHeaderTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimePropertySchema_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeBindHost_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IInternetMessageUrl_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IMimeHtmlProtocol_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT MimeEdit_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
HRESULT IHashTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

#endif // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\dll\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include "ixppop3.h"
#include "ixpsmtp.h"
#include "ixpnntp.h"
#include "ixphttpm.h"
#include "ixpras.h"
#include "imap4.h"
#include "range.h"
#include "olealloc.h"
#include "smime.h"
#include "vstream.h"
#include "icoint.h"
#include "internat.h"
#include "partial.h"
#include "ixpurl.h"
#include "docobj.h"
#include "doc.h"
#include "hash.h"
#include "fontcash.h"
#include "objres.h"
#include "propfind.h"

// --------------------------------------------------------------------------------
// Pretty
// --------------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

// --------------------------------------------------------------------------------
// Global Object Info Table
// --------------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_IMimePropertySet,    OBJTYPE1, (PFCREATEINSTANCE)WebBookContentBody_CreateInstance),
    CClassFactory(&CLSID_IMimeBody,           OBJTYPE1, (PFCREATEINSTANCE)WebBookContentBody_CreateInstance),
    CClassFactory(&CLSID_IMimeBodyW,          OBJTYPE1, (PFCREATEINSTANCE)WebBookContentBody_CreateInstance),
    CClassFactory(&CLSID_IMimeMessageTree,    OBJTYPE1, (PFCREATEINSTANCE)WebBookContentTree_CreateInstance),
    CClassFactory(&CLSID_IMimeMessage,        OBJTYPE1, (PFCREATEINSTANCE)WebBookContentTree_CreateInstance),
    CClassFactory(&CLSID_IMimeMessageW,       OBJTYPE1, (PFCREATEINSTANCE)WebBookContentTree_CreateInstance),
    CClassFactory(&CLSID_IMimeAllocator,      OBJTYPE0, (PFCREATEINSTANCE)IMimeAllocator_CreateInstance),
    CClassFactory(&CLSID_IMimeSecurity,       OBJTYPE0, (PFCREATEINSTANCE)IMimeSecurity_CreateInstance),
    CClassFactory(&CLSID_IMimeMessageParts,   OBJTYPE0, (PFCREATEINSTANCE)IMimeMessageParts_CreateInstance),
    CClassFactory(&CLSID_IMimeInternational,  OBJTYPE0, (PFCREATEINSTANCE)IMimeInternational_CreateInstance),
    CClassFactory(&CLSID_IMimeHeaderTable,    OBJTYPE0, (PFCREATEINSTANCE)IMimeHeaderTable_CreateInstance),
    CClassFactory(&CLSID_IMimePropertySchema, OBJTYPE0, (PFCREATEINSTANCE)IMimePropertySchema_CreateInstance),
    CClassFactory(&CLSID_IVirtualStream,      OBJTYPE0, (PFCREATEINSTANCE)IVirtualStream_CreateInstance),
    CClassFactory(&CLSID_IMimeHtmlProtocol,   OBJTYPE1, (PFCREATEINSTANCE)IMimeHtmlProtocol_CreateInstance),
    CClassFactory(&CLSID_ISMTPTransport,      OBJTYPE0, (PFCREATEINSTANCE)ISMTPTransport_CreateInstance),
    CClassFactory(&CLSID_IPOP3Transport,      OBJTYPE0, (PFCREATEINSTANCE)IPOP3Transport_CreateInstance),
    CClassFactory(&CLSID_INNTPTransport,      OBJTYPE0, (PFCREATEINSTANCE)INNTPTransport_CreateInstance),
    CClassFactory(&CLSID_IRASTransport,       OBJTYPE0, (PFCREATEINSTANCE)IRASTransport_CreateInstance),
    CClassFactory(&CLSID_IIMAPTransport,      OBJTYPE0, (PFCREATEINSTANCE)IIMAPTransport_CreateInstance),
    CClassFactory(&CLSID_IRangeList,          OBJTYPE0, (PFCREATEINSTANCE)IRangeList_CreateInstance),
    CClassFactory(&CLSID_MimeEdit,            OBJTYPE1, (PFCREATEINSTANCE)MimeEdit_CreateInstance),
    CClassFactory(&CLSID_IHashTable,          OBJTYPE0, (PFCREATEINSTANCE)IHashTable_CreateInstance),
    CClassFactory(&CLSID_IFontCache,          OBJTYPE1, (PFCREATEINSTANCE)CFontCache::CreateInstance),
    CClassFactory(&CLSID_IMimeObjResolver,    OBJTYPE0, (PFCREATEINSTANCE)CMimeObjResolver::CreateInstance),
#ifndef NOHTTPMAIL
    CClassFactory(&CLSID_IHTTPMailTransport,  OBJTYPE0, (PFCREATEINSTANCE)IHTTPMailTransport_CreateInstance),
    CClassFactory(&CLSID_IPropFindRequest,    OBJTYPE0, (PFCREATEINSTANCE)IPropFindRequest_CreateInstance),
    CClassFactory(&CLSID_IPropPatchRequest,   OBJTYPE0, (PFCREATEINSTANCE)IPropPatchRequest_CreateInstance),
#endif

};
                 
// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            CHECKHR(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TrapError(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::CClassFactory
// --------------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

// --------------------------------------------------------------------------------
// CClassFactory::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TrapError(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TrapError(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CClassFactory::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

// --------------------------------------------------------------------------------
// CClassFactory::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

// --------------------------------------------------------------------------------
// CClassFactory::CreateInstance
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TrapError(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TrapError(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TrapError(CLASS_E_NOAGGREGATION);

    // Create the object...
    CHECKHR(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        CHECKHR(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return hr;
}

// --------------------------------------------------------------------------------
// CClassFactory::LockServer
// --------------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}

// --------------------------------------------------------------------------------
// CreateRASTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateRASTransport(
          /* out */      IRASTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CRASTransport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreateNNTPTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateNNTPTransport(
          /* out */      INNTPTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CNNTPTransport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreateSMTPTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateSMTPTransport(
          /* out */      ISMTPTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CSMTPTransport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreatePOP3Transport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreatePOP3Transport(
          /* out */      IPOP3Transport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = new CPOP3Transport();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CreateIMAPTransport
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateIMAPTransport(
          /* out */      IIMAPTransport **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = (IIMAPTransport *) new CImap4Agent();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// CreateIMAPTransport2
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateIMAPTransport2(
          /* out */      IIMAPTransport2 **ppTransport)
{
    // check params
    if (NULL == ppTransport)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppTransport = (IIMAPTransport2 *) new CImap4Agent();
    if (NULL == *ppTransport)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// CreateRangeList
// --------------------------------------------------------------------------------
IMNXPORTAPI CreateRangeList(
          /* out */      IRangeList **ppRangeList)
{
    // check params
    if (NULL == ppRangeList)
        return TrapError(E_INVALIDARG);

    // Create the object
    *ppRangeList = (IRangeList *) new CRangeList();
    if (NULL == *ppRangeList)
        return TrapError(E_OUTOFMEMORY);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeAllocator_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeAllocator_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMimeAllocator *pNew = new CMimeAllocator();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMimeAllocator *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeSecurity_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeSecurity_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CSMime *pNew = new CSMime();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMimeSecurity *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimePropertySchema_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimePropertySchema_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Out of memory
    if (NULL == g_pSymCache)
        return TrapError(E_OUTOFMEMORY);

    // Create me
    *ppUnknown = ((IUnknown *)((IMimePropertySchema *)g_pSymCache));

    // Increase RefCount
    (*ppUnknown)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeInternational_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeInternational_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Outof memory
    if (NULL == g_pInternat)
        return TrapError(E_OUTOFMEMORY);

    // Assign It
    *ppUnknown = ((IUnknown *)((IMimeInternational *)g_pInternat));

    // Increase RefCount
    (*ppUnknown)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// ISMTPTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT ISMTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CSMTPTransport *pNew = new CSMTPTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, ISMTPTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IPOP3Transport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IPOP3Transport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CPOP3Transport *pNew = new CPOP3Transport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IPOP3Transport *);

    // Done
    return S_OK;
}

#ifndef NOHTTPMAIL

// --------------------------------------------------------------------------------
// IHTTPMailTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IHTTPMailTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CHTTPMailTransport *pNew = new CHTTPMailTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IHTTPMailTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IPropFindRequest_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IPropFindRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CPropFindRequest *pNew = new CPropFindRequest();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IPropFindRequest *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IPropPatchRequest_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IPropPatchRequest_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CPropPatchRequest *pNew = new CPropPatchRequest();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IPropPatchRequest *);

    // Done
    return S_OK;
}

#endif

// --------------------------------------------------------------------------------
// INNTPTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT INNTPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CNNTPTransport *pNew = new CNNTPTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, INNTPTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IRASTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IRASTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CRASTransport *pNew = new CRASTransport();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IRASTransport *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IIMAPTransport_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IIMAPTransport_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CImap4Agent *pNew = new CImap4Agent();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IIMAPTransport *);

    // Done
    return S_OK;
}


// --------------------------------------------------------------------------------
// IRangeList_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IRangeList_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CRangeList *pNew = new CRangeList();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IRangeList *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IVirtualStream_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IVirtualStream_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CVirtualStream *pNew = new CVirtualStream();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IStream *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeMessageParts_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeMessageParts_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMimeMessageParts *pNew = new CMimeMessageParts();
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMimeMessageParts *);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// IMimeHeaderTable_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IMimeHeaderTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    return TrapError(MimeOleCreateHeaderTable((IMimeHeaderTable **)ppUnknown));
}

// --------------------------------------------------------------------------------
// MimeEdit_CreateInstance
// --------------------------------------------------------------------------------
HRESULT MimeEdit_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CDoc *pNew = new CDoc(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}



// --------------------------------------------------------------------------------
// IHashTable_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IHashTable_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CHash *pNew= new CHash(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\dll\dllmain.h ===
// --------------------------------------------------------------------------------
// Dllmain.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

// --------------------------------------------------------------------------------
// Defined later
// --------------------------------------------------------------------------------
class CMimeInternational;
class CMimeAllocator;
class CSMime;
typedef class CMimeActiveUrlCache *LPMHTMLURLCACHE;
typedef class CPropertySymbolCache *LPSYMBOLCACHE;
interface IMLangLineBreakConsole;
interface IFontCache;

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern CRITICAL_SECTION     g_csDllMain;
extern CRITICAL_SECTION     g_csRAS;
extern CRITICAL_SECTION     g_csCounter;
extern CRITICAL_SECTION     g_csMLANG;
extern CRITICAL_SECTION     g_csCSAPI3T1;
extern HINSTANCE            g_hinstMLANG;
extern DWORD                g_dwCompatMode;
extern DWORD                g_dwCounter;     // boundary/cid/mid ratchet
extern LONG                 g_cRef;
extern LONG                 g_cLock;
extern HINSTANCE            g_hInst;
extern HINSTANCE            g_hLocRes;
extern HINSTANCE            g_hinstRAS;
extern HINSTANCE            g_hinstCSAPI3T1;
extern HINSTANCE            g_hCryptoDll;
extern HINSTANCE            g_hAdvApi32;
extern BOOL                 g_fWinsockInit;
extern CMimeInternational  *g_pInternat;
extern DWORD                g_dwSysPageSize;
extern CMimeAllocator *     g_pMoleAlloc;
extern LPSYMBOLCACHE        g_pSymCache;
extern LPMHTMLURLCACHE      g_pUrlCache;  
extern ULONG                g_ulUpperCentury;
extern ULONG                g_ulY2kThreshold;
extern IFontCache          *g_lpIFontCache;

extern HCERTSTORE           g_hCachedStoreMy;
extern HCERTSTORE           g_hCachedStoreAddressBook;


IF_DEBUG(extern DWORD       TAG_SSPI;)

// --------------------------------------------------------------------------------
// IMimeMessage::IDataObject clipboard formats (also CF_TEXT)
// --------------------------------------------------------------------------------
extern UINT		            CF_HTML;
extern UINT                 CF_INETMSG;
extern UINT                 CF_RFC822;

// --------------------------------------------------------------------------------
// String Lengths
// --------------------------------------------------------------------------------
#define CCHMAX_RES          255

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
ULONG DllAddRef(void);
ULONG DllRelease(void);
DWORD DwCounterNext(void);
HRESULT GetTypeLibrary(ITypeLib **ppTypeLib);

HCERTSTORE
WINAPI
OpenCachedHKCUStore(
    IN OUT HCERTSTORE *phStoreCache,
    IN LPCWSTR pwszStore
    );

HCERTSTORE
WINAPI
OpenCachedMyStore();

HCERTSTORE
WINAPI
OpenCachedAddressBookStore();

BOOL fIsNT5();

#endif // __DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\demand2.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**  Creators: jimsch, brimo, t-erikne
**  Created: 5/15/97
**	
**	Copyright (C) Microsoft Corp. 1997
*/

//
// IF YOU #INCLUDE A FILE HERE YOU PROBABLY CONFUSED.
// THIS FILE IS INCLUDED BY LOTS OF PEOPLE.  THINK THRICE
// BEFORE #INCLUDING *ANYTHING* HERE.  MAKE GOOD USE
// OF FORWARD REFS, THIS IS C++.
//

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           ESS_DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           ESS_DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return;     \
           VAR_##name args2;                            \
           return;                                      \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS

#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \

#define LOADER_FUNCTION_VOID(ret, name, args1, args2, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;

#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HINSTANCE g_hInst;

void ESS_InitDemandLoadLibs();
void ESS_FreeDemandLoadLibs();

/////////////////////////////////////
// CRYPT32.DLL

#define _CRYPT32_

BOOL ESS_DemandLoadCrypt32(void);

typedef void *HCERTSTORE;
typedef const struct _CERT_CONTEXT *PCCERT_CONTEXT;
typedef struct _CERT_INFO *PCERT_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCERT_NAME_INFO;
typedef void *HCRYPTMSG;
typedef struct _CMSG_STREAM_INFO *PCMSG_STREAM_INFO;
typedef struct _CERT_RDN_ATTR *PCERT_RDN_ATTR;
typedef struct _CERT_NAME_INFO *PCCERT_NAME_INFO;

LOADER_FUNCTION( BOOL, CryptRegisterOIDFunction,
    (DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll,
     LPCSTR pszOverrideFuncName),
    (dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName),
    NULL, Crypt32)
#define CryptRegisterOIDFunction VAR_CryptRegisterOIDFunction

LOADER_FUNCTION( BOOL, I_CryptUninstallAsn1Module,
    (HCRYPTASN1MODULE hAsn1Module),
    (hAsn1Module),
    NULL, Crypt32)
#define I_CryptUninstallAsn1Module VAR_I_CryptUninstallAsn1Module

LOADER_FUNCTION( BOOL, I_CryptInstallAsn1Module,
    (ASN1module_t pMod, DWORD dwFlags, void *pvReserved),
    (pMod, dwFlags, pvReserved),
    NULL, Crypt32)
#define I_CryptInstallAsn1Module VAR_I_CryptInstallAsn1Module

LOADER_FUNCTION( ASN1encoding_t, I_CryptGetAsn1Encoder,
    (HCRYPTASN1MODULE hAsn1Module),
    (hAsn1Module),
    NULL, Crypt32)
#define I_CryptGetAsn1Encoder VAR_I_CryptGetAsn1Encoder

LOADER_FUNCTION( ASN1decoding_t, I_CryptGetAsn1Decoder,
    (HCRYPTASN1MODULE hAsn1Module),
    (hAsn1Module),
    NULL, Crypt32)
#define I_CryptGetAsn1Decoder VAR_I_CryptGetAsn1Decoder

////////////////////////////////
//  nmasn1.dll

BOOL ESS_DemandLoadNmasn1(void);

LOADER_FUNCTION( ASN1module_t,  ASN1_CreateModule,
    ( ASN1uint32_t nVersion, ASN1encodingrule_e eRule, ASN1uint32_t dwFlags,ASN1uint32_t cPDU, const ASN1GenericFun_t apfnEncoder[], const ASN1GenericFun_t apfnDecoder[], const ASN1FreeFun_t apfnFreeMemory[], const ASN1uint32_t acbStructSize[], ASN1magic_t  nModuleName),
    ( nVersion, eRule, dwFlags,cPDU, apfnEncoder, apfnDecoder, apfnFreeMemory, acbStructSize,  nModuleName),
    NULL, Nmasn1)
#define ASN1_CreateModule VAR_ASN1_CreateModule

LOADER_FUNCTION_VOID( void,  ASN1_CloseModule,
    (ASN1module_t pModule),
    (pModule),
    Nmasn1)
#define ASN1_CloseModule VAR_ASN1_CloseModule

LOADER_FUNCTION( int,  ASN1BEREncObjectIdentifier2,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val),
    (enc, tag, val),
    NULL, Nmasn1)
#define ASN1BEREncObjectIdentifier2 VAR_ASN1BEREncObjectIdentifier2

LOADER_FUNCTION( int,  ASN1BERDecObjectIdentifier2,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecObjectIdentifier2 VAR_ASN1BERDecObjectIdentifier2

LOADER_FUNCTION( int,  ASN1BEREncEndOfContents,
    (ASN1encoding_t enc, ASN1uint32_t LengthOffset),
    (enc, LengthOffset),
    NULL, Nmasn1)
#define ASN1BEREncEndOfContents VAR_ASN1BEREncEndOfContents

LOADER_FUNCTION( int,  ASN1BEREncS32,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t b),
    (enc, tag, b),
    NULL, Nmasn1)
#define ASN1BEREncS32 VAR_ASN1BEREncS32

LOADER_FUNCTION( int,  ASN1BEREncOpenType,
    (ASN1encoding_t enc, ASN1open_t * a),
    (enc, a),
    NULL, Nmasn1)
#define ASN1BEREncOpenType VAR_ASN1BEREncOpenType

LOADER_FUNCTION( int,  ASN1BEREncExplicitTag,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset),
    (enc, tag, pLengthOffset),
    NULL, Nmasn1)
#define ASN1BEREncExplicitTag VAR_ASN1BEREncExplicitTag

LOADER_FUNCTION( int,  ASN1BERDecEndOfContents,
    (ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di),
    (dec, dd, di),
    NULL, Nmasn1)
#define ASN1BERDecEndOfContents VAR_ASN1BERDecEndOfContents

LOADER_FUNCTION( int,  ASN1BERDecS32Val,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecS32Val VAR_ASN1BERDecS32Val

LOADER_FUNCTION( int,  ASN1BERDecOpenType2,
    (ASN1decoding_t dec, ASN1open_t * a),
    (dec, a),
    NULL, Nmasn1)
#define ASN1BERDecOpenType2 VAR_ASN1BERDecOpenType2

LOADER_FUNCTION( int,  ASN1BERDecExplicitTag,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di),
    (dec, tag, dd,di),
    NULL, Nmasn1)
#define ASN1BERDecExplicitTag VAR_ASN1BERDecExplicitTag

LOADER_FUNCTION( int,  ASN1CEREncOctetString,
    (ASN1encoding_t enc, ASN1uint32_t a, ASN1uint32_t b, ASN1octet_t * c),
    (enc, a, b, c),
    NULL, Nmasn1)
#define ASN1CEREncOctetString VAR_ASN1CEREncOctetString

LOADER_FUNCTION( int,  ASN1BERDecOctetString2,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val),
    (dec, tag, val),
    NULL, Nmasn1)
#define ASN1BERDecOctetString2 VAR_ASN1BERDecOctetString2

LOADER_FUNCTION( int,  ASN1BERDecOctetString,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val),
    (dec, tag, val),
    NULL, Nmasn1)
#define ASN1BERDecOctetString VAR_ASN1BERDecOctetString

LOADER_FUNCTION_VOID( void,  ASN1octetstring_free,
    (ASN1octetstring_t * a),
    (a),
    Nmasn1)
#define ASN1octetstring_free VAR_ASN1octetstring_free

LOADER_FUNCTION( int,  ASN1BEREncUTF8String,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value),
    (enc, tag, length, value),
    NULL, Nmasn1)
#define ASN1BEREncUTF8String VAR_ASN1BEREncUTF8String

LOADER_FUNCTION( int,  ASN1BERDecUTF8String,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val),
    (dec, tag, val),
    NULL, Nmasn1)
#define ASN1BERDecUTF8String VAR_ASN1BERDecUTF8String

LOADER_FUNCTION( int,  ASN1BERDecPeekTag,
    (ASN1decoding_t dec, ASN1uint32_t *tag),
    (dec, tag),
    NULL, Nmasn1)
#define ASN1BERDecPeekTag VAR_ASN1BERDecPeekTag

LOADER_FUNCTION_VOID( void,  ASN1utf8string_free,
    (ASN1wstring_t * a),
    (a),
    Nmasn1)
#define ASN1utf8string_free VAR_ASN1utf8string_free

LOADER_FUNCTION( void *,  ASN1DecRealloc,
    (ASN1decoding_t dec, void *ptr, ASN1uint32_t size),
    (dec, ptr, size),
    NULL, Nmasn1)
#define ASN1DecRealloc VAR_ASN1DecRealloc

LOADER_FUNCTION( int,  ASN1BERDecNotEndOfContents,
    (ASN1decoding_t dec, ASN1octet_t *di),
    (dec, di),
    NULL, Nmasn1)
#define ASN1BERDecNotEndOfContents VAR_ASN1BERDecNotEndOfContents

LOADER_FUNCTION_VOID( void,  ASN1Free,
    (void *ptr),
    (ptr),
    Nmasn1)
#define ASN1Free VAR_ASN1Free

LOADER_FUNCTION( ASN1error_e,  ASN1DecSetError,
    (ASN1decoding_t dec, ASN1error_e err),
    (dec, err),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1DecSetError VAR_ASN1DecSetError

LOADER_FUNCTION( int,  ASN1BEREncU32,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t a),
    (enc, tag, a),
    NULL, Nmasn1)
#define ASN1BEREncU32 VAR_ASN1BEREncU32

LOADER_FUNCTION( int,  ASN1CEREncCharString,
    (ASN1encoding_t enc, ASN1uint32_t a, ASN1uint32_t b, ASN1char_t * c),
    (enc, a, b, c),
    NULL, Nmasn1)
#define ASN1CEREncCharString VAR_ASN1CEREncCharString

LOADER_FUNCTION( int,  ASN1CEREncBeginBlk,
    (ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk),
    (enc, eBlkType, ppBlk),
    NULL, Nmasn1)
#define ASN1CEREncBeginBlk VAR_ASN1CEREncBeginBlk

LOADER_FUNCTION( int,  ASN1CEREncNewBlkElement,
    (void *pBlk, ASN1encoding_t *enc2),
    (pBlk, enc2),
    NULL, Nmasn1)
#define ASN1CEREncNewBlkElement VAR_ASN1CEREncNewBlkElement

LOADER_FUNCTION( int,  ASN1CEREncFlushBlkElement,
    (void *pBlk),
    (pBlk),
    NULL, Nmasn1)
#define ASN1CEREncFlushBlkElement VAR_ASN1CEREncFlushBlkElement

LOADER_FUNCTION( int,  ASN1CEREncEndBlk,
    (void *pBlk),
    (pBlk),
    NULL, Nmasn1)
#define ASN1CEREncEndBlk VAR_ASN1CEREncEndBlk

LOADER_FUNCTION( int,  ASN1BERDecU16Val,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecU16Val VAR_ASN1BERDecU16Val

LOADER_FUNCTION( int,  ASN1BERDecZeroCharString,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecZeroCharString VAR_ASN1BERDecZeroCharString

LOADER_FUNCTION_VOID( void,  ASN1ztcharstring_free,
    (ASN1ztcharstring_t a),
    (a),
    Nmasn1)
#define ASN1ztcharstring_free VAR_ASN1ztcharstring_free

LOADER_FUNCTION( int,  ASN1CEREncGeneralizedTime,
    (ASN1encoding_t enc, ASN1uint32_t a, ASN1generalizedtime_t * b),
    (enc, a, b),
    NULL, Nmasn1)
#define ASN1CEREncGeneralizedTime VAR_ASN1CEREncGeneralizedTime

LOADER_FUNCTION( int,  ASN1BEREncNull,
    (ASN1encoding_t enc, ASN1uint32_t tag),
    (enc, tag),
    NULL, Nmasn1)
#define ASN1BEREncNull VAR_ASN1BEREncNull

LOADER_FUNCTION( int,  ASN1BERDecGeneralizedTime,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t * a),
    (dec, tag, a),
    NULL, Nmasn1)
#define ASN1BERDecGeneralizedTime VAR_ASN1BERDecGeneralizedTime

LOADER_FUNCTION( int,  ASN1BERDecNull,
    (ASN1decoding_t dec, ASN1uint32_t tag),
    (dec, tag),
    NULL, Nmasn1)
#define ASN1BERDecNull VAR_ASN1BERDecNull

LOADER_FUNCTION( ASN1error_e,  ASN1_Encode,
    ( ASN1encoding_t pEncoderInfo, void *pDataStruct, ASN1uint32_t nPduNum, ASN1uint32_t dwFlags, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize),
    ( pEncoderInfo, pDataStruct, nPduNum, dwFlags, pbBuf, cbBufSize),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_Encode VAR_ASN1_Encode

LOADER_FUNCTION_VOID( void,  ASN1_FreeEncoded,
    ( ASN1encoding_t pEncoderInfo, void *pBuf),
    ( pEncoderInfo, pBuf),
    Nmasn1)
#define ASN1_FreeEncoded VAR_ASN1_FreeEncoded

LOADER_FUNCTION( ASN1error_e,  ASN1_Decode,
    ( ASN1decoding_t pDecoderInfo, void **ppDataStruct, ASN1uint32_t nPduNum, ASN1uint32_t dwFlags, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize),
    ( pDecoderInfo, ppDataStruct, nPduNum, dwFlags, pbBuf, cbBufSize),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_Decode VAR_ASN1_Decode

LOADER_FUNCTION( ASN1error_e,  ASN1_SetEncoderOption,
    ( ASN1encoding_t pEncoderInfo, ASN1optionparam_t *pOptParam),
    ( pEncoderInfo, pOptParam),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_SetEncoderOption VAR_ASN1_SetEncoderOption

LOADER_FUNCTION( ASN1error_e,  ASN1_GetEncoderOption,
    ( ASN1encoding_t pEncoderInfo, ASN1optionparam_t *pOptParam),
    ( pEncoderInfo, pOptParam),
    ASN1_ERR_INTERNAL, Nmasn1)
#define ASN1_GetEncoderOption VAR_ASN1_GetEncoderOption

LOADER_FUNCTION_VOID( void,  ASN1_FreeDecoded,
    ( ASN1decoding_t pDecoderInfo, void *pDataStruct, ASN1uint32_t nPduNum),
    ( pDecoderInfo, pDataStruct, nPduNum),
    Nmasn1)
#define ASN1_FreeDecoded VAR_ASN1_FreeDecoded

LOADER_FUNCTION( int,  ASN1BEREncOctetString,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val),
    (enc, tag, len, val),
    0, Nmasn1)
#define ASN1BEREncOctetString VAR_ASN1BEREncOctetString

LOADER_FUNCTION( int,  ASN1BEREncCharString,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t a, ASN1char_t * b),
    (enc, tag, a, b),
    0, Nmasn1)
#define ASN1BEREncCharString VAR_ASN1BEREncCharString

LOADER_FUNCTION( int,  ASN1BEREncSX,
    (ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t * a),
    (enc, tag, a),
    0, Nmasn1)
#define ASN1BEREncSX VAR_ASN1BEREncSX

LOADER_FUNCTION( int, ASN1BERDecSXVal,
    (ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *a),
    (dec, tag, a),
    0, Nmasn1)
#define ASN1BERDecSXVal VAR_ASN1BERDecSXVal

LOADER_FUNCTION_VOID( void, ASN1intx_free,
    (ASN1intx_t * a),
    (a),
    Nmasn1)
#define ASN1intx_free VAR_ASN1intx_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\dll\dllmain.cpp ===
// --------------------------------------------------------------------------------
// Dllmain.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include <shfusion.h>
#define DEFINE_STRING_CONSTANTS
#define DEFINE_STRCONST
#define DEFINE_PROPSYMBOLS
#define DEFINE_TRIGGERS
#include "mimeole.h"
#include "symcache.h"
#include "strconst.h"
#include "htmlstr.h"
#include "thorsspi.h"
#include "sicily.h"
#include "ixputil.h"
#include "olealloc.h"
#include "smime.h"
#include "objheap.h"
#include "internat.h"
#include "icoint.h"
#include "msoert.h"
#include "dllmain.h"
#include "mhtmlurl.h"
#include "mlang.h"
#include <lookup.h>
#include "shared.h"
#include "shlwapi.h"
#include "demand.h"
#include "fontcash.h"
#include "util.h"
#include "resource.h"
#include "../imnxport/asynconn.h"

// --------------------------------------------------------------------------------
// Globals - Object count and lock count
// --------------------------------------------------------------------------------
CRITICAL_SECTION    g_csDllMain={0};
CRITICAL_SECTION    g_csRAS={0};
CRITICAL_SECTION    g_csCounter={0};
CRITICAL_SECTION    g_csMLANG={0};
CRITICAL_SECTION    g_csCSAPI3T1={0};
BOOL                g_fAttached = FALSE;
DWORD               g_dwCounter=0;       // boundary/cid/mid ratchet
LONG                g_cRef=0;
LONG                g_cLock=0;
HINSTANCE           g_hInst=NULL;
HINSTANCE           g_hLocRes=NULL;
CMimeInternational *g_pInternat=NULL;
BOOL                g_fWinsockInit=FALSE;
DWORD               g_dwSysPageSize;
UINT                CF_HTML=0;
UINT                CF_INETMSG=0;
UINT                CF_RFC822=0;
CMimeAllocator *    g_pMoleAlloc=NULL;
LPINETCSETINFO      g_pDefBodyCset=NULL;
LPINETCSETINFO      g_pDefHeadCset=NULL;
LPSYMBOLCACHE       g_pSymCache=NULL;
IMalloc            *g_pMalloc=NULL;
HINSTANCE           g_hinstMLANG=NULL;
HINSTANCE           g_hinstRAS=NULL;
HINSTANCE           g_hinstCSAPI3T1=NULL;
LPMHTMLURLCACHE     g_pUrlCache=NULL;
BOOL                g_fCanEditBiDi=FALSE;
DWORD               g_dwCompatMode=0;
IF_DEBUG(DWORD      TAG_SSPI=0);
SYSTEM_INFO         g_SystemInfo={0};
OSVERSIONINFO       g_OSInfo={0};
ULONG               g_ulUpperCentury = 0;
ULONG               g_ulY2kThreshold = 2029;
IFontCache         *g_lpIFontCache=NULL;

HCERTSTORE          g_hCachedStoreMy = NULL;
HCERTSTORE          g_hCachedStoreAddressBook = NULL;
LPSRVIGNORABLEERROR g_pSrvErrRoot = NULL;

BOOL fIsNT5()        { return((g_OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_OSInfo.dwMajorVersion >= 5)); }

// --------------------------------------------------------------------------------
// Debug Globals
// --------------------------------------------------------------------------------
#ifdef DEBUG
DWORD               dwDOUTLevel=0;
DWORD               dwDOUTLMod=0;
DWORD               dwDOUTLModLevel=0;
#endif

#ifdef WIN16
// --------------------------------------------------------------------------------
// From main.c of the build
// --------------------------------------------------------------------------------
extern "C" { void FreeGlobalVars(); };
#endif

#ifdef SMIME_V3
STDAPI EssRegisterServer(void);
BOOL WINAPI EssASNDllMain(HMODULE hInst, ULONG ulReason, LPVOID lpv);
#endif // SMIME_V3

HRESULT GetDllPathName(WCHAR **ppszW);

// These lines should be hardcoded! (YST)
static const TCHAR sc_szLangDll[]         = "INETRES.DLL";

// --------------------------------------------------------------------------------
// GetDllMajorVersion
// --------------------------------------------------------------------------------
STDAPI_(OEDLLVERSION) GetDllMajorVersion(void)
{
    return OEDLL_VERSION_CURRENT;
}

extern BOOL CanEditBiDi(void);
// --------------------------------------------------------------------------------
// InitGlobalVars
// --------------------------------------------------------------------------------
void InitGlobalVars(void)
{
    // Locals
    SYSTEM_INFO rSystemInfo;
    TCHAR szY2kThreshold[16];
    TCHAR rgch[MAX_PATH];
    HKEY hkey = NULL;
    HRESULT hr;
    DWORD cb;

    // Initialize Global Critical Sections
    InitializeCriticalSection(&g_csDllMain);
    InitializeCriticalSection(&g_csRAS);
    InitializeCriticalSection(&g_csCounter);
    InitializeCriticalSection(&g_csMLANG);
    InitializeCriticalSection(&g_csCSAPI3T1);
    g_fAttached = TRUE;

    // This for the winsock multi-thread hostname lookup
    InitLookupCache();

    // Get System & OS Info
    GetPCAndOSTypes(&g_SystemInfo, &g_OSInfo);
    g_dwSysPageSize = g_SystemInfo.dwPageSize;

    // Create OLE Task Memory Allocator
    CoGetMalloc(1, &g_pMalloc);
    Assert(g_pMalloc);

    // Create our global allocator
    g_pMoleAlloc = new CMimeAllocator;
    Assert(g_pMoleAlloc);
    
    // Security Initialize
    SecurityInitialize();

    // Initialize Demand-loaded Libs
    InitDemandLoadedLibs();

    // INit crit sect
    g_pSymCache = new CPropertySymbolCache;
    Assert(g_pSymCache);

    // Initialize the Symbol Table
    SideAssert(SUCCEEDED(g_pSymCache->Init()));

    // Init Body Object Heap
    InitObjectHeaps();

    // Init International
    InitInternational();

    // Init ActiveUrl Cache
    g_pUrlCache = new CMimeActiveUrlCache;
    Assert(g_pUrlCache);

    // Check if the system can edit Bidi documents
    g_fCanEditBiDi = CanEditBiDi();
    
    // Register clipboard formats
    CF_HTML = RegisterClipboardFormat(STR_CF_HTML);
    Assert(CF_HTML != 0);
    CF_INETMSG = RegisterClipboardFormat(STR_CF_INETMSG);
    Assert(CF_INETMSG != 0);
    CF_RFC822 = RegisterClipboardFormat(STR_CF_RFC822);
    Assert(CF_RFC822 != 0);

    // --- Calculate Y2K cut off information
    // See http://officeweb/specs/excel/CYu/nty2k.htm
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REG_Y2K_THRESHOLD, 0, KEY_READ, &hkey))
    {
        cb = sizeof(szY2kThreshold);
        if(ERROR_SUCCESS == RegQueryValueEx(hkey, "1", NULL, NULL, (LPBYTE)szY2kThreshold, &cb))
        {
            g_ulY2kThreshold = (ULONG)StrToInt(szY2kThreshold);
        }
        RegCloseKey(hkey);
    }

    g_ulUpperCentury = g_ulY2kThreshold / 100;
    g_ulY2kThreshold %= 100;

    // Create the Font Cache Object

    if (NULL == g_lpIFontCache)
    {
        hr = CFontCache::CreateInstance(NULL, (IUnknown **)&g_lpIFontCache);        
        
        if(SUCCEEDED(hr))
        {
            lstrcpy(rgch, c_szExplorerRegPath);
            lstrcat(rgch, "\\International");
            hr = g_lpIFontCache->Init(HKEY_CURRENT_USER, rgch, 0);            
        }
        
        if(FAILED(hr))
        {
            AthMessageBox(HWND_DESKTOP, MAKEINTRESOURCE(IDS_APPNAME), MAKEINTRESOURCE(idsFontCacheError),
                NULL, MB_OK | MB_ICONSTOP);
        }
    }
}

// --------------------------------------------------------------------------------
// FreeGlobalVars
// --------------------------------------------------------------------------------
void FreeGlobalVars(void)
{
    // Server ignorable errors
    if(g_pSrvErrRoot)
        FreeSrvErr(g_pSrvErrRoot);

    // Cache stores
    if (g_hCachedStoreMy)
        CertCloseStore(g_hCachedStoreMy, 0);
    if (g_hCachedStoreAddressBook)
        CertCloseStore(g_hCachedStoreAddressBook, 0);

    // Release ActiveUrlCache
    Assert(g_pUrlCache);
    SafeRelease(g_pUrlCache);

    // Free Address Info Heap (must be before release of g_pSymCache)
    FreeObjectHeaps();

    // Release Symbol CAche
    Assert(g_pSymCache);
    SafeRelease(g_pSymCache);

    // Unload RAS Dll
    EnterCriticalSection(&g_csRAS);
    SafeFreeLibrary(g_hinstRAS);
    LeaveCriticalSection(&g_csRAS);

    // Uninitialize Security
    SSPIUninitialize();
    UnloadSecurity();

    // Unload S/MIME
    CSMime::UnloadAll();

    // Must be before UnInitializeWinsock()
    DeInitLookupCache();

    // Cleanup Winsock
    if (g_fWinsockInit)
        UnInitializeWinsock();

    // Free libraries that demand.cpp loaded
    FreeDemandLoadedLibs();

    // Free CSAPI3T1
    EnterCriticalSection(&g_csCSAPI3T1);
    SafeFreeLibrary(g_hinstCSAPI3T1);
    LeaveCriticalSection(&g_csCSAPI3T1);

    // Free mlang lib
    EnterCriticalSection(&g_csMLANG);
    SafeFreeLibrary(g_hinstMLANG);
    LeaveCriticalSection(&g_csMLANG);

    // Release Font Cache
    SafeRelease(g_lpIFontCache);

    // Release g_pInternat
    Assert(g_pInternat);
    SafeRelease(g_pInternat);

    // Free INETRES.DLL (g_hLocRes)
    SafeFreeLibrary(g_hLocRes);

    // Delete Global Critical Sections
    g_fAttached = FALSE;
    DeleteCriticalSection(&g_csCSAPI3T1);
    DeleteCriticalSection(&g_csMLANG);
    DeleteCriticalSection(&g_csCounter);
    DeleteCriticalSection(&g_csRAS);
    DeleteCriticalSection(&g_csDllMain);

    // Release Global Memory allocator
    SafeRelease(g_pMoleAlloc);
    
    // Release Global Memory allocator
    SafeRelease(g_pMalloc); 
    
    //Don't SafeRelease() anything after here, as the allocator has been Released()

#ifdef WIN16
    // Need uninitialize it to clean the ole garbage.
    CoUninitialize();
#endif // WIN16
}

#ifndef WIN16
// --------------------------------------------------------------------------------
// Win32 Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
         SHFusionInitialize(NULL);
#ifdef DEBUG
        dwDOUTLevel=GetPrivateProfileInt("Debug", "ICLevel", 0, "athena.ini");
        dwDOUTLMod=GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
        dwDOUTLModLevel=GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
        TAG_SSPI = GetDebugTraceTagMask("InetCommSSPI", TAG_SSPI);
#endif
        g_hInst = hInst;
        g_hLocRes = LoadLangDll(g_hInst, c_szInetResDll, fIsNT5());
        if(g_hLocRes == NULL)
        {
            Assert(FALSE);
            return FALSE;
        }
        InitGlobalVars();        
        SideAssert(DisableThreadLibraryCalls(hInst));

#ifdef SMIME_V3
        if (!EssASNDllMain(hInst, dwReason, lpReserved)) {
            return FALSE;
        }
#endif // SMIME_V3
        break;

    case DLL_PROCESS_DETACH:
#ifdef SMIME_V3
        if (!EssASNDllMain(hInst, dwReason, lpReserved)) {
            return FALSE;
        }
#endif // SMIME_V3
        FreeGlobalVars();
        SHFusionUninitialize();
        break;
    }

    // Done
    return TRUE;
}

#else
// --------------------------------------------------------------------------------
// Win16 Dll Entry Point
// --------------------------------------------------------------------------------
BOOL FAR PASCAL LibMain (HINSTANCE hDll, WORD wDataSeg, WORD cbHeapSize, LPSTR lpszCmdLine)
{
    // Win16 specific
    CoInitialize(NULL);

    // Set global instance handle
    g_hInst = hDll;

    // Initialize Global Variables
    InitGlobalVars();

#ifdef DEBUG
    dwDOUTLevel=GetPrivateProfileInt("Debug", "ICLevel", 0, "athena.ini");
    dwDOUTLMod=GetPrivateProfileInt("Debug", "Mod", 0, "athena.ini");
    dwDOUTLModLevel=GetPrivateProfileInt("Debug", "ModLevel", 0, "athena.ini");
#endif

    // Done
    return TRUE;
}
#endif // !WIN16

// --------------------------------------------------------------------------------
// DwCounterNext
// --------------------------------------------------------------------------------
DWORD DwCounterNext(void)
{
    EnterCriticalSection(&g_csCounter);
    DWORD dwCounter = g_dwCounter++;
    LeaveCriticalSection(&g_csCounter);
    return dwCounter;
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    TraceCall("DllAddRef");
    return (ULONG)InterlockedIncrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    TraceCall("DllRelease");
    return (ULONG)InterlockedDecrement(&g_cRef);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    // Tracing
    TraceCall("DllCanUnloadNow");

    if(!g_fAttached)   // critacal sections was deleted (or not created): we defently can be unloaded
        return S_OK;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Trace This
    // DebugTrace("DllCanUnloadNow: %s - Reference Count: %d, LockServer Count: %d\n", __FILE__, g_cRef, g_cLock);

    // Can We Unload
    HRESULT hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// RegTypeLib
// --------------------------------------------------------------------------------
__inline HRESULT RegTypeLib(HINSTANCE hInstRes)
{
    AssertSz(hInstRes,    "[ARGS] RegTypeLib: NULL hInstRes");
    
    HRESULT     hr = E_FAIL;
    CHAR        szDll[MAX_PATH];
    WCHAR       wszDll[MAX_PATH];

    GetModuleFileName(hInstRes, szDll, ARRAYSIZE(szDll));

    // Convert the module path to Wide-String
    if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szDll, -1, wszDll, ARRAYSIZE(wszDll)))
    {
        ITypeLib   *pTypeLib;

        hr = LoadTypeLib(wszDll, &pTypeLib);
        if (SUCCEEDED(hr))
        {
            // Register the typelib
            hr = RegisterTypeLib(pTypeLib, wszDll, NULL);
            pTypeLib->Release();
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllRegisterServer");

#ifdef SMIME_V3
    //  Register the ESS routines
    hr = EssRegisterServer();
    if (FAILED(hr)) {
        return hr;
    }
#endif // SMIME_V3

    // CallRegInstall and RegTypeLib are in staticRT/shared.cpp
    if (SUCCEEDED(hr = CallRegInstall(g_hInst, g_hInst, c_szReg, NULL)))
        return RegTypeLib(g_hInst);
    else
        return hr;

}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("DllUnregisterServer");

    // UnRegister
    IF_FAILEXIT(hr = CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL));

exit:
    // Done
    return hr;
}

HRESULT GetTypeLibrary(ITypeLib **ppTypeLib)
{
    HRESULT     hr;
    WCHAR       *pszModuleW=0;

    hr = GetDllPathName(&pszModuleW);
    if (!FAILED(hr))
        {
        hr = LoadTypeLib(pszModuleW, ppTypeLib);
        SafeMemFree(pszModuleW);
        }
    return hr;
}

HRESULT GetDllPathName(WCHAR **ppszW)
{
    HRESULT     hr;
    TCHAR       rgch[MAX_PATH];
    WCHAR       *pszModuleW=0;

    *ppszW=NULL;

    if (!GetModuleFileName(g_hInst, rgch, sizeof(rgch)/sizeof(TCHAR)))
        return E_FAIL;
   
    *ppszW = PszToUnicode(CP_ACP, rgch);
    return *ppszW ? S_OK : E_OUTOFMEMORY;
}


HCERTSTORE
WINAPI
OpenCachedHKCUStore(
    IN OUT HCERTSTORE *phStoreCache,
    IN LPCWSTR pwszStore
    )
{
    HCERTSTORE hStore;

    // This caching optimization is only supported on WXP

    if (g_OSInfo.dwPlatformId != VER_PLATFORM_WIN32_NT ||
            g_OSInfo.dwMajorVersion < 5 ||
            (g_OSInfo.dwMajorVersion == 5 && g_OSInfo.dwMinorVersion < 1))
    {
        return CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            NULL,
            CERT_SYSTEM_STORE_CURRENT_USER |
                CERT_STORE_MAXIMUM_ALLOWED_FLAG,
            (const void *) pwszStore
            );
    }

    hStore = *phStoreCache;
    if (NULL == hStore) {
        hStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            0,
            NULL,
            CERT_SYSTEM_STORE_CURRENT_USER |
                CERT_STORE_MAXIMUM_ALLOWED_FLAG |
                CERT_STORE_SHARE_CONTEXT_FLAG,
            (const void *) pwszStore
            );

        if (hStore) {
            HCERTSTORE hPrevStore;

            CertControlStore(
                hStore,
                0,                  // dwFlags
                CERT_STORE_CTRL_AUTO_RESYNC,
                NULL                // pvCtrlPara
                );

            hPrevStore = InterlockedCompareExchangePointer(
                phStoreCache, hStore, NULL);

            if (hPrevStore) {
                CertCloseStore(hStore, 0);
                hStore = hPrevStore;
            }
        }
    }

    if (hStore)
        hStore = CertDuplicateStore(hStore);

    return hStore;
}

HCERTSTORE
WINAPI
OpenCachedMyStore()
{
    return OpenCachedHKCUStore(&g_hCachedStoreMy, L"My");
}

HCERTSTORE
WINAPI
OpenCachedAddressBookStore()
{
    return OpenCachedHKCUStore(&g_hCachedStoreAddressBook, L"AddressBook");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\demand2.cpp ===
// --------------------------------------------------------------------------------
// Demand.cpp
// Written By: jimsch, brimo, t-erikne (bastardized by sbailey)
// --------------------------------------------------------------------------------
// W4 stuff
#ifdef SMIME_V3
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------

#include <windows.h>
//#include "myassert.h"
#define AssertSz(a, b)
#define Assert(a)
#define IMPLEMENT_LOADER_FUNCTIONS
#include "crypttls.h"
#include "ess.h"
#include "demand2.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        AssertSz(0, VAR_##fn" failed to load"); \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    Assert(VAR_##fn != NULL); \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
static HMODULE s_hCrypt = 0;
static HMODULE s_hNmasn1 = 0;

static CRITICAL_SECTION g_csDefLoad = {0};

// --------------------------------------------------------------------------------
// InitDemandLoadedLibs
// --------------------------------------------------------------------------------
void ESS_InitDemandLoadLibs(void)
{
    InitializeCriticalSection(&g_csDefLoad);
}

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void ESS_FreeDemandLoadLibs(void)
{
    EnterCriticalSection(&g_csDefLoad);
    if (s_hCrypt)       FreeLibrary(s_hCrypt);
    if (s_hNmasn1)    FreeLibrary(s_hNmasn1);

    LeaveCriticalSection(&g_csDefLoad);
    DeleteCriticalSection(&g_csDefLoad);
}


// --------------------------------------------------------------------------------
// DemandLoadCrypt32
// --------------------------------------------------------------------------------
BOOL ESS_DemandLoadCrypt32(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary("CRYPT32.DLL");
        AssertSz((BOOL)s_hCrypt, TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CryptRegisterOIDFunction);
            GET_PROC_ADDR(s_hCrypt, I_CryptUninstallAsn1Module);
            GET_PROC_ADDR(s_hCrypt, I_CryptInstallAsn1Module);
            GET_PROC_ADDR(s_hCrypt, I_CryptGetAsn1Encoder);
            GET_PROC_ADDR(s_hCrypt, I_CryptGetAsn1Decoder);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

BOOL FIsMsasn1Loaded()
{
    static int  fTested = FALSE;

    if (!fTested) {
        ESS_DemandLoadNmasn1();
        fTested = TRUE;
    }

    return s_hNmasn1 != 0;
}

// --------------------------------------------------------------------------------
// DemandLoadNmasn1
// --------------------------------------------------------------------------------
BOOL ESS_DemandLoadNmasn1(void)
{
    BOOL                fRet = TRUE;

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hNmasn1) {
        s_hNmasn1 = LoadLibrary("MSAsn1.DLL");
        AssertSz((BOOL)s_hNmasn1, TEXT("LoadLibrary failed on MSAsn1.DLL"));

        if (0 == s_hNmasn1)
            fRet = FALSE;
        else {
            GET_PROC_ADDR(s_hNmasn1, ASN1_CreateModule);
            GET_PROC_ADDR(s_hNmasn1, ASN1_CloseModule);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncObjectIdentifier2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecObjectIdentifier2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncEndOfContents);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncS32);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncOpenType);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncExplicitTag);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecEndOfContents);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecS32Val);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecOpenType2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecExplicitTag);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncOctetString);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecOctetString2);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecOctetString);
            GET_PROC_ADDR(s_hNmasn1, ASN1octetstring_free);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncUTF8String);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecUTF8String);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecPeekTag);
            GET_PROC_ADDR(s_hNmasn1, ASN1utf8string_free);
            GET_PROC_ADDR(s_hNmasn1, ASN1DecRealloc);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecNotEndOfContents);
            GET_PROC_ADDR(s_hNmasn1, ASN1Free);
            GET_PROC_ADDR(s_hNmasn1, ASN1DecSetError);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncU32);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncCharString);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncBeginBlk);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncNewBlkElement);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncFlushBlkElement);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncEndBlk);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecU16Val);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecZeroCharString);
            GET_PROC_ADDR(s_hNmasn1, ASN1ztcharstring_free);
            GET_PROC_ADDR(s_hNmasn1, ASN1CEREncGeneralizedTime);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncNull);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecGeneralizedTime);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecNull);
            GET_PROC_ADDR(s_hNmasn1, ASN1_Encode);
            GET_PROC_ADDR(s_hNmasn1, ASN1_FreeEncoded);
            GET_PROC_ADDR(s_hNmasn1, ASN1_Decode);
            GET_PROC_ADDR(s_hNmasn1, ASN1_SetEncoderOption);
            GET_PROC_ADDR(s_hNmasn1, ASN1_GetEncoderOption);
            GET_PROC_ADDR(s_hNmasn1, ASN1_FreeDecoded);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncOctetString);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncCharString);
            GET_PROC_ADDR(s_hNmasn1, ASN1BEREncSX);
            GET_PROC_ADDR(s_hNmasn1, ASN1BERDecSXVal);
            GET_PROC_ADDR(s_hNmasn1, ASN1intx_free);
        }
    }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//	File:		debug.cpp
//
//	Contents:	Debug sub system APIs implementation
//
//
//	03/20/96    kevinr      wrote it
//  04/17/96    kevinr      added OSS init
//  05-Sep-1997 pberkman    added sub-system debug.
//
//----------------------------------------------------------------------------
#ifdef SMIME_V3

#if DBG

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <memory.h>
#include <string.h>
#include <process.h>
#include <time.h>
#include <crtdbg.h>
#include <asn1code.h>

//#include "regtest.h"          // JLS

#include "dbgdef.h"

// set DEBUG_MASK=0x26
LPSTR pszDEBUG_MASK = "DEBUG_MASK";
#define DEBUG_MASK_DELAY_FREE_MEM   _CRTDBG_DELAY_FREE_MEM_DF /* 0x02 */
#define DEBUG_MASK_CHECK_ALWAYS     _CRTDBG_CHECK_ALWAYS_DF   /* 0x04 */
#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */
#define DEBUG_MASK_MEM \
(DEBUG_MASK_DELAY_FREE_MEM | DEBUG_MASK_CHECK_ALWAYS | DEBUG_MASK_LEAK_CHECK)


// from asn1code.h:
//      #define DEBUGPDU     0x02 /* produce tracing output */
//      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
// set OSS_DEBUG_MASK=0x02        
// set OSS_DEBUG_MASK=0x10        - only print decoder errors
LPSTR pszOSS_DEBUG_MASK = "OSS_DEBUG_MASK";

// receives trace output
LPSTR pszOSS_DEBUG_TRACEFILE = "OSS_DEBUG_TRACEFILE";

static char  *pszDEBUG_PRINT_MASK   = "DEBUG_PRINT_MASK";
static char  *pszDefualtSSTag       = "ISPU";

static DBG_SS_TAG sSSTags[]         = __DBG_SS_TAGS;

#if 0 // JLS
// 
//+-------------------------------------------------------------------------
//
//  Pithy stubs to create stdcall proc from cdecl
//
//--------------------------------------------------------------------------
void*
_stdcall
scMalloc( size_t size)
{
    return malloc(size);
}

void*
_stdcall
scRealloc( void *memblock, size_t size)
{
    return realloc(memblock, size);
}

void
_stdcall
scFree( void *memblock)
{
    free(memblock);
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgGetDebugFlags
//
//  Synopsis:  Get the debug flags.
//
//  Returns:   the debug flags
//
//--------------------------------------------------------------------------
int
WINAPI
DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv( pszDEBUG_MASK))
        iDebugFlags = strtol( pszEnvVar, &p, 16);

    return iDebugFlags;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessAttach
//
//  Synopsis:  Handle process attach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessAttach()
{
    int     tmpFlag;

#ifdef _DEBUG

    tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );    // get current
    tmpFlag |=  DbgGetDebugFlags();     // enable flags
    tmpFlag &= ~_CRTDBG_CHECK_CRT_DF;   // disable CRT block checking
    _CrtSetDbgFlag( tmpFlag);           // set new value
#endif

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgProcessDetach
//
//  Synopsis:  Handle process detach.
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgProcessDetach()
{
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgInitOSS
//
//  Synopsis:  Do OSS init for debug.
//
//  Returns:   TRUE
//
//  Note:      Always FRONT_ALIGN encoding
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DbgInitOSS(
        OssGlobal   *pog)
{
    char    *pszEnvVar;
    char    *p;

    // from asn1code.h:
    //      #define DEBUGPDU 0x02     /* produce tracing output */
    //      #define DEBUG_ERRORS 0x10 /* print decoder errors to output */
    // set OSS_DEBUG_MASK=0x02
    // set OSS_DEBUG_MASK=0x10        - only print decoder errors
    if (pszEnvVar = getenv( pszOSS_DEBUG_MASK)) {
        unsigned long ulEnvVar;
        ulEnvVar = strtoul( pszEnvVar, &p, 16) & (DEBUGPDU | DEBUG_ERRORS);
        if ( ulEnvVar)
            ossSetDecodingFlags( pog, ulEnvVar | RELAXBER);
        if ( DEBUGPDU & ulEnvVar)
            ossSetEncodingFlags( pog, DEBUGPDU | FRONT_ALIGN);
        else
            ossSetEncodingFlags( pog, FRONT_ALIGN);
    } else {
        ossSetDecodingFlags( pog, DEBUG_ERRORS | RELAXBER);
        ossSetEncodingFlags( pog, FRONT_ALIGN);
    }

    if (pszEnvVar = getenv( pszOSS_DEBUG_TRACEFILE))
        ossOpenTraceFile( pog, pszEnvVar);

#ifdef _DEBUG
    if (DbgGetDebugFlags() & DEBUG_MASK_MEM) {
        pog->mallocp = scMalloc;
        pog->reallocp = scRealloc;
        pog->freep = scFree;
    }
#else
    pog->mallocp = scMalloc;
    pog->reallocp = scRealloc;
    pog->freep = scFree;
#endif
    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:  DebugDllMain
//
//  Synopsis:  Initialize the debug DLL
//
//  Returns:   TRUE
//
//--------------------------------------------------------------------------
BOOL
WINAPI
DebugDllMain(
        HMODULE hInst,
        ULONG   ulReason,
        LPVOID  lpReserved)
{
    BOOL    fRet = TRUE;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        fRet = DbgProcessAttach();
        //        fRet &= RegTestInit();        // JLS
        break;

    case DLL_PROCESS_DETACH:
        fRet = DbgProcessDetach();
        //        RegTestCleanup();             // JLS
        break;

    default:
        break;
    }

  return fRet;
}


const char *DbgGetSSString(DWORD dwSubSystemId)
{
    DBG_SS_TAG  *psSS;

    psSS = &sSSTags[0];

    while (psSS->dwSS > 0)
    {
        if ((psSS->dwSS & dwSubSystemId) > 0)
        {
            if (psSS->pszTag)
            {
                return(psSS->pszTag);
            }

            return(pszDefualtSSTag);
        }

        psSS++;
    }

    return(pszDefualtSSTag);
}

static BOOL DbgIsSSActive(DWORD dwSSIn)
{
    char    *pszEnvVar;
    DWORD   dwEnv;

    dwEnv = 0;

    if (pszEnvVar = getenv(pszDEBUG_PRINT_MASK))
    {
        dwEnv = (DWORD)strtol(pszEnvVar, NULL, 16);
    }


    return((dwEnv & dwSSIn) > 0);
}

//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{
    va_list arglist;
    CHAR    ach1[1024];
    CHAR    ach2[1080];
    int     cch;
    HANDLE  hStdOut;
    DWORD   cb;
    DWORD   dwErr;

    dwErr = GetLastError();

    if (!(DbgIsSSActive(dwSubSystemId)))
    {
        SetLastError(dwErr);
        return(0);
    }

    _try 
    {
        va_start(arglist, lpFmt);

        _vsnprintf( ach1, sizeof(ach1), lpFmt, arglist);

        va_end(arglist);

        cch = wsprintf(ach2,"%s: %s", DbgGetSSString(dwSubSystemId), ach1);

        hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

        if (hStdOut != INVALID_HANDLE_VALUE)
        {
            WriteConsole( hStdOut, ach2, strlen(ach2), &cb, NULL);
        }

        OutputDebugString(ach2);

    } _except( EXCEPTION_EXECUTE_HANDLER) 
    {
        // return failure
        cch = 0;
    }
    SetLastError(dwErr);
    return cch;
}
#else  // !0 // JLS
int WINAPIV DbgPrintf(DWORD dwSubSystemId, LPCSTR lpFmt, ...)
{
    return 0;
}
#endif // 0 JLS


#endif // DBG
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\ess.h ===
#ifndef _ESS_Module_H_
#define _ESS_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1objectidentifier2_t ObjectIdentifier;

typedef ObjectIdentifier ContentType;

typedef ASN1int32_t Version;
#define Version_v0 0
#define Version_v1 1
#define Version_v2 2
#define Version_v3 3

typedef ASN1intx_t HUGEINTEGER;

typedef HUGEINTEGER SerialNumber;

typedef SerialNumber CertificateSerialNumber;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef OCTETSTRING SubjectKeyIdentifier;

typedef NOCOPYANY GeneralNames;

typedef ASN1octetstring_t ContentIdentifier;

typedef ASN1int32_t AllOrFirstTier;
#define AllOrFirstTier_allReceipts 0
#define AllOrFirstTier_firstTierRecipients 1

typedef ASN1octetstring_t MsgSigDigest;

typedef ObjectIdentifier SecurityPolicyIdentifier;

typedef ASN1uint16_t SecurityClassification;
#define SecurityClassification_unmarked 0
#define SecurityClassification_unclassified 1
#define SecurityClassification_restricted 2
#define SecurityClassification_confidential 3
#define SecurityClassification_secret 4
#define SecurityClassification_top_secret 5

typedef ASN1octetstring_t Hash;

typedef NOCOPYANY PolicyInformation;

typedef struct SigningCertificate_policies {
    ASN1uint32_t count;
    PolicyInformation *value;
} SigningCertificate_policies;

typedef struct SigningCertificate_certs {
    ASN1uint32_t count;
    struct ESSCertID *value;
} SigningCertificate_certs;

typedef struct MLReceiptPolicy_inAdditionTo {
    ASN1uint32_t count;
    GeneralNames *value;
} MLReceiptPolicy_inAdditionTo;

typedef struct MLReceiptPolicy_insteadOf {
    ASN1uint32_t count;
    GeneralNames *value;
} MLReceiptPolicy_insteadOf;

typedef struct ReceiptsFrom_receiptList {
    ASN1uint32_t count;
    GeneralNames *value;
} ReceiptsFrom_receiptList;

typedef struct ReceiptRequest_receiptsTo {
    ASN1uint32_t count;
    GeneralNames *value;
} ReceiptRequest_receiptsTo;

typedef struct IssuerAndSerialNumber {
    NOCOPYANY issuer;
    SerialNumber serialNumber;
} IssuerAndSerialNumber;

typedef struct ReceiptsFrom {
    ASN1choice_t choice;
    union {
#	define allOrFirstTier_chosen 1
	AllOrFirstTier allOrFirstTier;
#	define receiptList_chosen 2
	ReceiptsFrom_receiptList receiptList;
    } u;
} ReceiptsFrom;

typedef struct Receipt {
    Version version;
    ContentType contentType;
    ContentIdentifier signedContentIdentifier;
    OCTETSTRING originatorSignatureValue;
} Receipt;
#define Receipt_PDU 0
#define SIZE_ESS_Module_PDU_0 sizeof(Receipt)

typedef struct ContentHints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define contentDescription_present 0x80
    ASN1wstring_t contentDescription;
    ObjectIdentifier contentType;
} ContentHints;
#define ContentHints_PDU 1
#define SIZE_ESS_Module_PDU_1 sizeof(ContentHints)

typedef struct ContentReference {
    ContentType contentType;
    ContentIdentifier signedContentIdentifier;
    ASN1octetstring_t originatorSignatureValue;
} ContentReference;
#define ContentReference_PDU 2
#define SIZE_ESS_Module_PDU_2 sizeof(ContentReference)

typedef struct ESSPrivacyMark {
    ASN1choice_t choice;
    union {
#	define utf8String_chosen 1
	ASN1wstring_t utf8String;
#	define pString_chosen 2
	ASN1ztcharstring_t pString;
    } u;
} ESSPrivacyMark;

typedef struct SecurityCategories {
    ASN1uint32_t count;
    struct SecurityCategory *value;
} SecurityCategories;

typedef struct SecurityCategory {
    ObjectIdentifier type;
    NOCOPYANY value;
} SecurityCategory;

typedef struct EquivalentLabels {
    ASN1uint32_t count;
    struct ESSSecurityLabel *value;
} EquivalentLabels;
#define EquivalentLabels_PDU 3
#define SIZE_ESS_Module_PDU_3 sizeof(EquivalentLabels)

typedef struct MLExpansionHistory {
    ASN1uint32_t count;
    struct MLData *value;
} MLExpansionHistory;
#define MLExpansionHistory_PDU 4
#define SIZE_ESS_Module_PDU_4 sizeof(MLExpansionHistory)

typedef struct EntityIdentifier {
    ASN1choice_t choice;
    union {
#	define subjectKeyIdentifier_chosen 1
	SubjectKeyIdentifier subjectKeyIdentifier;
#	define EntityIdentifier_issuerAndSerialNumber_chosen 2
	IssuerAndSerialNumber issuerAndSerialNumber;
    } u;
} EntityIdentifier;

typedef struct MLReceiptPolicy {
    ASN1choice_t choice;
    union {
#	define none_chosen 1
#	define insteadOf_chosen 2
	MLReceiptPolicy_insteadOf insteadOf;
#	define inAdditionTo_chosen 3
	MLReceiptPolicy_inAdditionTo inAdditionTo;
    } u;
} MLReceiptPolicy;

typedef struct SigningCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SigningCertificate_certs certs;
#   define policies_present 0x80
    SigningCertificate_policies policies;
} SigningCertificate;
#define SigningCertificate_PDU 5
#define SIZE_ESS_Module_PDU_5 sizeof(SigningCertificate)

typedef struct ESSCertID {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Hash certHash;
#   define issuerSerial_present 0x80
    IssuerAndSerialNumber issuerSerial;
} ESSCertID;

typedef struct SMimeEncryptCerts {
    ASN1uint32_t count;
    struct SMimeEncryptCert *value;
} SMimeEncryptCerts;
#define SMimeEncryptCerts_PDU 6
#define SIZE_ESS_Module_PDU_6 sizeof(SMimeEncryptCerts)

typedef struct SMIMECapabilities {
    ASN1uint32_t count;
    struct SMIMECapability *value;
} SMIMECapabilities;

typedef struct SMIMECapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectIdentifier capabilityID;
#   define parameters_present 0x80
    ASN1open_t parameters;
} SMIMECapability;

typedef struct OtherKeyAttribute {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectIdentifier keyAttrId;
#   define keyAttr_present 0x80
    ASN1open_t keyAttr;
} OtherKeyAttribute;

typedef struct ReceiptRequest {
    ContentIdentifier signedContentIdentifier;
    ReceiptsFrom receiptsFrom;
    ReceiptRequest_receiptsTo receiptsTo;
} ReceiptRequest;
#define ReceiptRequest_PDU 7
#define SIZE_ESS_Module_PDU_7 sizeof(ReceiptRequest)

typedef struct ESSSecurityLabel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define security_classification_present 0x80
    SecurityClassification security_classification;
    SecurityPolicyIdentifier security_policy_identifier;
#   define privacy_mark_present 0x40
    ESSPrivacyMark privacy_mark;
#   define security_categories_present 0x20
    SecurityCategories security_categories;
} ESSSecurityLabel;
#define ESSSecurityLabel_PDU 9
#define SIZE_ESS_Module_PDU_9 sizeof(ESSSecurityLabel)

typedef struct MLData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityIdentifier mailListIdentifier;
    ASN1generalizedtime_t expansionTime;
#   define mlReceiptPolicy_present 0x80
    MLReceiptPolicy mlReceiptPolicy;
} MLData;

typedef struct SMimeEncryptCert {
    Hash hash;
    SMIMECapabilities capabilities;
} SMimeEncryptCert;

typedef struct RecipientKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectKeyIdentifier subjectKeyIdentifier;
#   define date_present 0x80
    ASN1generalizedtime_t date;
#   define other_present 0x40
    OtherKeyAttribute other;
} RecipientKeyIdentifier;

typedef struct SMIMEEncryptionKeyPreference {
    ASN1choice_t choice;
    union {
#	define SMIMEEncryptionKeyPreference_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define recipientKeyId_chosen 2
	RecipientKeyIdentifier recipientKeyId;
#	define subjectAltKeyIdentifier_chosen 3
	SubjectKeyIdentifier subjectAltKeyIdentifier;
    } u;
} SMIMEEncryptionKeyPreference;
#define SMIMEEncryptionKeyPreference_PDU 8
#define SIZE_ESS_Module_PDU_8 sizeof(SMIMEEncryptionKeyPreference)

extern ASN1int32_t ub_receiptsTo;
extern ASN1objectidentifier_t id_aa_receiptRequest;
extern ASN1objectidentifier_t id_aa_contentIdentifier;
extern ASN1objectidentifier_t id_ct_receipt;
extern ASN1objectidentifier_t id_aa_contentHint;
extern ASN1objectidentifier_t id_aa_msgSigDigest;
extern ASN1objectidentifier_t id_aa_contentReference;
extern ASN1objectidentifier_t id_aa_securityLabel;
extern ASN1int32_t ub_integer_options;
extern ASN1int32_t ub_privacy_mark_length;
extern ASN1int32_t ub_security_categories;
extern ASN1objectidentifier_t id_aa_equivalentLabels;
extern ASN1objectidentifier_t id_aa_mlExpandHistory;
extern ASN1int32_t ub_ml_expansion_history;
extern ASN1objectidentifier_t id_aa_signingCertificate;

extern ASN1module_t ESS_Module;
extern void ASN1CALL ESS_Module_Startup(void);
extern void ASN1CALL ESS_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _ESS_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\essasn.cpp ===
#ifdef SMIME_V3
#include	<windows.h>
//#include        "oss\global.hxx"
//#include        "oss\ossconv.h"
#include        "mimeole.h"
extern "C" {
#include        "ess.h"
}
#include        "essOut.h"
#include        "pkiasn1.h"
#include        "crypttls.h"
#include        "msoert.h"

#include        "demand2.h"

#define wcslen my_wcslen
extern int my_wcslen(LPCWSTR pwsz);

//
//

HCRYPTASN1MODULE  ICM_hAsn1Module;

typedef struct {
    LPSTR       szOID;
    LPSTR       szFunc;
} OIDFunction;

static const OIDFunction EssEncodeExFuncTable[] = {
    {szOID_SMIME_Content_Hints, "EssContentHintEncodeEx"},
    {szOID_SMIME_Receipt_Request, "EssReceiptRequestEncodeEx"},
    {szOID_SMIME_ContentType_Receipt, "EssReceiptEncodeEx"},
    {szOID_SMIME_Security_Label, "EssSecurityLabelEncodeEx"},
    {szOID_SMIME_MLExpansion_History, "EssMLHistoryEncodeEx"},
    {szOID_SMIME_Encryption_Key_Preference, "EssKeyExchPreferenceEncodeEx"},
    {szOID_SMIME_Signing_Certificate, "EssSignCertificateEncodeEx"},
};
const int EssEncodeExFuncCount = (sizeof(EssEncodeExFuncTable)/
                                  sizeof(EssEncodeExFuncTable[0]));

static const OIDFunction EssDecodeExFuncTable[] = {
    {szOID_SMIME_Content_Hints, "EssContentHintDecodeEx"},
    {szOID_SMIME_Receipt_Request, "EssReceiptRequestDecodeEx"},
    {szOID_SMIME_ContentType_Receipt, "EssReceiptDecodeEx"},
    {szOID_SMIME_Security_Label, "EssSecurityLabelDecodeEx"},
    {szOID_SMIME_MLExpansion_History, "EssMLHistoryDecodeEx"},
    {szOID_SMIME_Encryption_Key_Preference, "EssKeyExchPreferenceDecodeEx"},
    {szOID_SMIME_Signing_Certificate, "EssSignCertificateDecodeEx"},
};
const int EssDecodeExFuncCount = (sizeof(EssDecodeExFuncTable)/
                                  sizeof(EssDecodeExFuncTable[0]));


STDAPI EssRegisterServer(void)
{
    HRESULT     hr;
    int         i;

    // M00BUG -- need to put in a path for inetcomm.dll!!!!!

    for (i=0; i<EssEncodeExFuncCount; i++) {
        if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                      CRYPT_OID_ENCODE_OBJECT_EX_FUNC,
                                      EssEncodeExFuncTable[i].szOID,
                                      L"inetcomm.dll",
                                      EssEncodeExFuncTable[i].szFunc)) {
            goto InstallError;
        }
    }
        
    for (i=0; i<EssDecodeExFuncCount; i++) {
        if (!CryptRegisterOIDFunction(X509_ASN_ENCODING,
                                      CRYPT_OID_DECODE_OBJECT_EX_FUNC,
                                      EssDecodeExFuncTable[i].szOID,
                                      L"inetcomm.dll",
                                      EssDecodeExFuncTable[i].szFunc)) {
            goto InstallError;
        }
    }
        
    hr = S_OK;
CommonReturn:
    return hr;

InstallError:
    hr = E_FAIL;
    goto CommonReturn;
}

STDAPI EssUnRegisterServer(void)
{
    return S_OK;
}

BOOL WINAPI
EssASNDllMain(HMODULE hInst, ULONG ulReason, LPVOID lpv)
{
    BOOL        fRet;
    
    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        ESS_InitDemandLoadLibs();
        break;

    case DLL_PROCESS_DETACH:
        if (ICM_hAsn1Module != NULL) {
            I_CryptUninstallAsn1Module(ICM_hAsn1Module);
            ESS_Module_Cleanup();
        }
        ESS_FreeDemandLoadLibs();
        break;
    }

    fRet = TRUE;
    return fRet;
}

#if 0
///////////////////////////////// STOLEN FUNCTIONS ///////////////////////////
//
//  The following functions were taken from the wincert.cpp file in the
//      ISPU tree.  If possible we should get these exported from crypt32.
//
///////////////////////////////////////////////////////////////////////////////

#define INFO_LEN_ALIGN(a) a

//+-------------------------------------------------------------------------
//  Set/Get Encoded Object Identifier string
//--------------------------------------------------------------------------
//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL OssX509SetObjId(
        IN LPCSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (OssConvToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void OssX509GetObjId(
        IN ObjectID *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    OssConvFromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//#define OssX509SetEncodedObjId(pszObjId, pOss) \
//            I_CryptSetOssEncodedOID(pszObjId, (OssEncodedOID *) (pOss))

//#define OssX509GetEncodedObjId(pOss, dwFlags, \
//                ppszObjId, ppbExtra, plRemainExtra) \
//            I_CryptGetOssEncodedOID((OssEncodedOID *) (pOss), dwFlags, \
//                ppszObjId, ppbExtra, plRemainExtra)

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void OssX509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pOss
        )
{
    OssUtilSetAny(pInfo, (OpenType *) pOss);
}
inline void OssX509GetAny(
        IN NOCOPYANY *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    OssUtilGetAny((OpenType *) pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void OssX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
inline void OssX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    OssUtilGetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


#if 0
//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_ENTRY
//--------------------------------------------------------------------------
BOOL OssX509SetAltNameEntry(
        IN PCERT_ALT_NAME_ENTRY pInfo,
        OUT GeneralName *pOss,
        IN DWORD dwEntryIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;

    // Assumption: OSS choice == dwAltNameChoice
    // OssX509GetAltNameEntry has asserts to verify
    pOss->choice = (unsigned short) pInfo->dwAltNameChoice;

    *pdwErrLocation = 0;

    switch (pInfo->dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        if (!OssX509SetEncodedObjId(pInfo->pOtherName->pszObjId,
                &pOss->u.otherName.type))
            goto ErrorReturn;
        OssX509SetAny(&pInfo->pOtherName->Value, &pOss->u.otherName.value);
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        OssX509SetAny(&pInfo->DirectoryName, &pOss->u.directoryName);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        if (!OssX509SetUnicodeConvertedToIA5(pInfo->pwszRfc822Name,
                &pOss->u.rfc822Name, dwEntryIndex, pdwErrLocation))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        OssX509SetOctetString(&pInfo->IPAddress, &pOss->u.iPAddress);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        if (!OssX509SetEncodedObjId(pInfo->pszRegisteredID, &pOss->u.registeredID))
            goto ErrorReturn;
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
    default:
        SetLastError((DWORD) E_INVALIDARG);
        goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void OssX509FreeAltNameEntry(
        IN GeneralName *pOss
        )
{
    switch (pOss->choice) {
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        OssX509FreeUnicodeConvertedToIA5(&pOss->u.rfc822Name);
        break;
    default:
        break;
    }
}

BOOL OssX509GetAltNameEntry(
        IN GeneralName *pOss,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_ENTRY pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    DWORD dwAltNameChoice;

    assert(otherName_chosen == CERT_ALT_NAME_OTHER_NAME);
    assert(rfc822Name_chosen == CERT_ALT_NAME_RFC822_NAME);
    assert(dNSName_chosen == CERT_ALT_NAME_DNS_NAME);
    assert(x400Address_chosen == CERT_ALT_NAME_X400_ADDRESS);
    assert(directoryName_chosen == CERT_ALT_NAME_DIRECTORY_NAME);
    assert(ediPartyName_chosen == CERT_ALT_NAME_EDI_PARTY_NAME);
    assert(uniformResourceLocator_chosen == CERT_ALT_NAME_URL);
    assert(iPAddress_chosen == CERT_ALT_NAME_IP_ADDRESS);
    assert(registeredID_chosen == CERT_ALT_NAME_REGISTERED_ID);


    dwAltNameChoice = pOss->choice;
    if (*plRemainExtra >= 0)
        pInfo->dwAltNameChoice = dwAltNameChoice;
    switch (dwAltNameChoice) {
    case CERT_ALT_NAME_OTHER_NAME:
        {
            LONG lAlignExtra;
            PCERT_OTHER_NAME pOtherName;

            lAlignExtra = INFO_LEN_ALIGN(sizeof(CERT_OTHER_NAME));
            *plRemainExtra -= lAlignExtra;
            if (*plRemainExtra >= 0) {
                pOtherName = (PCERT_OTHER_NAME) *ppbExtra;
                pInfo->pOtherName = pOtherName;
                *ppbExtra += lAlignExtra;
            } else
                pOtherName = NULL;

            OssX509GetEncodedObjId(&pOss->u.otherName.type, dwFlags,
                &pOtherName->pszObjId, ppbExtra, plRemainExtra);
            OssX509GetAny(&pOss->u.otherName.value, dwFlags,
                &pOtherName->Value, ppbExtra, plRemainExtra);
        }
        break;
    case CERT_ALT_NAME_DIRECTORY_NAME:
        OssX509GetAny(&pOss->u.directoryName, dwFlags,
            &pInfo->DirectoryName, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_RFC822_NAME:
    case CERT_ALT_NAME_DNS_NAME:
    case CERT_ALT_NAME_URL:
        OssX509GetIA5ConvertedToUnicode(&pOss->u.rfc822Name, dwFlags,
            &pInfo->pwszRfc822Name, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_IP_ADDRESS:
        OssX509GetOctetString(&pOss->u.iPAddress, dwFlags,
            &pInfo->IPAddress, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_REGISTERED_ID:
        OssX509GetEncodedObjId(&pOss->u.registeredID, dwFlags,
            &pInfo->pszRegisteredID, ppbExtra, plRemainExtra);
        break;
    case CERT_ALT_NAME_X400_ADDRESS:
    case CERT_ALT_NAME_EDI_PARTY_NAME:
        break;
    default:
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CERT_ALT_NAME_INFO
//--------------------------------------------------------------------------
BOOL OssX509SetAltNames(
        IN PCERT_ALT_NAME_INFO pInfo,
        OUT AltNames *pOss,
        IN DWORD dwIndex,
        OUT DWORD *pdwErrLocation
        )
{
    BOOL fResult;
    DWORD i;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pOssEntry;

    *pdwErrLocation = 0;

    cEntry = pInfo->cAltEntry;
    pEntry = pInfo->rgAltEntry;
    pOss->count = cEntry;
    pOss->value = NULL;
    if (cEntry > 0) {
        pOssEntry =
            (GeneralName *) PkiZeroAlloc(cEntry * sizeof(GeneralName));
        if (pOssEntry == NULL)
            goto ErrorReturn;
        pOss->value = pOssEntry;
    }

    // Array of AltName entries
    for (i = 0; i < cEntry; i++, pEntry++, pOssEntry++) {
        if (!OssX509SetAltNameEntry(pEntry, pOssEntry,
                (dwIndex << 8) | i, pdwErrLocation))
            goto ErrorReturn;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

void OssX509FreeAltNames(
        OUT AltNames *pOss
        )
{
    if (pOss->value) {
        DWORD cEntry = pOss->count;
        GeneralName *pOssEntry = pOss->value;
        for ( ; cEntry > 0; cEntry--, pOssEntry++)
            OssX509FreeAltNameEntry(pOssEntry);
        PkiFree(pOss->value);
    }
}

BOOL OssX509GetAltNames(
        IN AltNames *pOss,
        IN DWORD dwFlags,
        OUT PCERT_ALT_NAME_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    DWORD cEntry;
    PCERT_ALT_NAME_ENTRY pEntry;
    GeneralName *pOssEntry;

    cEntry = pOss->count;
    lAlignExtra = INFO_LEN_ALIGN(cEntry * sizeof(CERT_ALT_NAME_ENTRY));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        pInfo->cAltEntry = cEntry;
        pEntry = (PCERT_ALT_NAME_ENTRY) *ppbExtra;
        pInfo->rgAltEntry = pEntry;
        *ppbExtra += lAlignExtra;
    } else
        pEntry = NULL;

    // Array of AltName entries
    pOssEntry = pOss->value;
    for (; cEntry > 0; cEntry--, pEntry++, pOssEntry++) {
        if (!OssX509GetAltNameEntry(pOssEntry, dwFlags,
                    pEntry, ppbExtra, plRemainExtra))
                return FALSE;
    }
    return TRUE;
}
#endif // 0

//+-------------------------------------------------------------------------
//  Function:  GetPog
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized OssGlobal data structure
//--------------------------------------------------------------------------
static inline POssGlobal GetPog(void)
{
    return I_CryptGetOssGlobal(hX509OssGlobal);
}

#endif // 0

//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static inline ASN1encoding_t GetEncoder(void)
{
    if (ICM_hAsn1Module == NULL) {
        ESS_Module_Startup();
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(ESS_Module, 0, NULL))) {
            return NULL;
        }
    }
    return I_CryptGetAsn1Encoder(ICM_hAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    if (ICM_hAsn1Module == NULL) {
        ESS_Module_Startup();
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(ESS_Module, 0, NULL))) {
            return NULL;
        }
    }
    return I_CryptGetAsn1Decoder(ICM_hAsn1Module);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the OssX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoEncodeEx(
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(GetEncoder(), pdunum, pvOssInfo, dwFlags,
                               pEncodePara, pvEncoded, pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Decode into an OSS formatted info structure. Call the callback
//  function to convert into the 'C' data structure. If
//  CRYPT_DECODE_ALLOC_FLAG is set, call the callback twice. First,
//  to get the length of the 'C' data structure. Then after allocating,
//  call again to update the 'C' data structure.
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoDecodeAndAllocEx(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return PkiAsn1DecodeAndAllocInfoEx(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
inline void OssX509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pOss
        )
{
    PkiAsn1SetAny(pInfo, pOss);
}
inline void OssX509GetAny(
        IN NOCOPYANY *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetAny(pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
inline void OssX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
inline void OssX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


#define OssX509SetEncodedObjId(pszObjId, pOss) \
                PkiAsn1ToObjectIdentifier(pszObjId, &(pOss)->count, (pOss)->value)
// I_CryptSetEncodedOID(pszObjId, pOss)


#define OssX509GetEncodedObjId(pOss, dwFlags, \
                ppszObjId, ppbExtra, plRemainExtra) \
                PkiAsn1FromObjectIdentifier((pOss)->count, (pOss)->value, \
                                            ppszObjId, ppbExtra, plRemainExtra)

//            I_CryptGetEncodedOID(pOss, dwFlags, \
//                ppszObjId, ppbExtra, plRemainExtra)

BOOL
WINAPI
I_CryptSetEncodedOID(
        IN LPSTR pszObjId,
        OUT ASN1encodedOID_t *pEncodedOid
        );

void I_CryptGetEncodedOID(
        IN ASN1encodedOID_t *pEncodedOid,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );



inline BOOL
WINAPI
PkiAsn1SetUTF8String(LPCWSTR pwsz, ASN1wstring_t * pAsn1String)
{
    pAsn1String->length = my_wcslen(pwsz);
    pAsn1String->value = (LPWSTR) pwsz;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get UTF8 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetUTF8String(
        IN ASN1wstring_t *putf8String,
        IN DWORD dwFlags,
        OUT LPWSTR *pwszPrivacyMark,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG  lRemainExtra = *plRemainExtra;
    ULONG ulSize = putf8String->length * sizeof(WCHAR);

    lRemainExtra -= (sizeof(WCHAR) + ulSize); 
    if (lRemainExtra < 0) {
        ;
    }
    else {
        LPBYTE pbExtra = *ppbExtra;
        *pwszPrivacyMark = (LPWSTR) pbExtra;
        memcpy(pbExtra, putf8String->value, ulSize);
        pbExtra += ulSize;
        (* ((LPWSTR) pbExtra) ) = '\0'; // null terminate the wsz.
        pbExtra += sizeof(WCHAR);
        *ppbExtra = pbExtra;
    }
    *plRemainExtra = lRemainExtra;
}

#define OssX509GetEncodedUTF8String(putf8String, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra) \
        PkiAsn1GetUTF8String(putf8String, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra)

                                    
//+-------------------------------------------------------------------------
//  Get PString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetPString(
        IN ASN1ztcharstring_t *pPString,
        IN DWORD dwFlags,
        OUT LPWSTR *pwszPrivacyMark,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG  lRemainExtra = *plRemainExtra;
    INT   cwch = MultiByteToWideChar(CP_ACP, 0, *pPString, -1, NULL, 0);
    ULONG ulSize = cwch * sizeof(WCHAR);

    if (cwch != 0) {
        lRemainExtra -= ulSize; 
        if (lRemainExtra < 0) {
            ;
        }
        else {
            *pwszPrivacyMark = (LPWSTR) *ppbExtra;
            cwch = MultiByteToWideChar(CP_ACP, 0, *pPString, -1, (LPWSTR) *ppbExtra, cwch);
            *ppbExtra += ulSize;
        }
        *plRemainExtra = lRemainExtra;
    }
}

#define OssX509GetEncodedPString(PString, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra) \
        PkiAsn1GetPString(PString, dwFlags, pwszPrivacyMark, ppbExtra, plRemainExtra)



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

////    EssContentHintEncodeEx
//
//  Description:
//      This function is used to encode the ContentHint attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssContentHintEncodeEx(IN DWORD dwCertEncodingType,
                                   IN LPCSTR lpszStructType,
                                   IN PSMIME_CONTENT_HINTS pInfo,
                                   IN DWORD dwFlags,
                                   IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                   OUT OPTIONAL void *pvEncoded,
                                   IN OUT DWORD *pcbEncoded
                                   )
{
    BOOL                fResult;
    ContentHints        OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    if (pInfo->pszDescription != NULL) {
        OssInfo.bit_mask |= contentDescription_present;
        OssInfo.contentDescription.length = wcslen(pInfo->pszDescription)*2;
        OssInfo.contentDescription.value = pInfo->pszDescription;
    }
    OssInfo.contentType.count = sizeof(OssInfo.contentType.value)/sizeof(OssInfo.contentType.value[0]);
    if (!OssX509SetEncodedObjId(pInfo->pszOIDContent, &OssInfo.contentType)) {
        goto ErrorReturn;
    }

    fResult = OssInfoEncodeEx(ContentHints_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssContentHintDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_CONTENT_HINTS        pInfo = (PSMIME_CONTENT_HINTS) pvStructInfo;
    ContentHints *              pOssInfo = (ContentHints *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_CONTENT_HINTS);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_CONTENT_HINTS);
    }
    else {
        pbExtra = NULL;
    }

    // decode the content-hint description.
    if (pOssInfo->bit_mask & contentDescription_present) {
        OssX509GetEncodedUTF8String(&pOssInfo->contentDescription, dwFlags,
                                    (pInfo == NULL) ? NULL : &pInfo->pszDescription,
                                    &pbExtra, &lRemainExtra);
    }

    // decode the content-hint oid.
    OssX509GetEncodedObjId(&pOssInfo->contentType, dwFlags, &pInfo->pszOIDContent, 
                           &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssContentHintDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssContentHintDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(ContentHints_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssContentHintDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}


////    EssReceiptRequestEncodeEx
//
//  Description:
//      This function is used to encode the ReceiptRequest attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssReceiptRequestEncodeEx(IN DWORD dwCertEncodingType,
                                   IN LPCSTR lpszStructType,
                                   IN PSMIME_RECEIPT_REQUEST pInfo,
                                   IN DWORD dwFlags,
                                   IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                   OUT OPTIONAL void *pvEncoded,
                                   IN OUT DWORD *pcbEncoded
                                   )
{
    BOOL                fResult;
    DWORD               i;
    ReceiptRequest      OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    //  ContentIdentifier
    OssInfo.signedContentIdentifier.length = pInfo->ContentIdentifier.cbData;
    OssInfo.signedContentIdentifier.value = pInfo->ContentIdentifier.pbData;

    // Receipts From
    if (pInfo->ReceiptsFrom.cNames > 0) {
        OssInfo.receiptsFrom.choice = receiptList_chosen;
        OssInfo.receiptsFrom.u.receiptList.count = pInfo->ReceiptsFrom.cNames;
        OssInfo.receiptsFrom.u.receiptList.value = 
            (NOCOPYANY *) malloc(pInfo->ReceiptsFrom.cNames * sizeof(NOCOPYANY));
        if (OssInfo.receiptsFrom.u.receiptList.value == NULL) {
            goto ErrorReturn;
        }
        for (i=0; i<pInfo->ReceiptsFrom.cNames; i++) {
            OssX509SetAny(&pInfo->ReceiptsFrom.rgNames[i],
                          &OssInfo.receiptsFrom.u.receiptList.value[i]);
        }
    }
    else {
        OssInfo.receiptsFrom.choice = allOrFirstTier_chosen;
        OssInfo.receiptsFrom.u.allOrFirstTier = pInfo->ReceiptsFrom.AllOrFirstTier;
    }

    // Receipts To

    OssInfo.receiptsTo.count = (USHORT) pInfo->cReceiptsTo;
    OssInfo.receiptsTo.value = 
            (NOCOPYANY *) malloc(pInfo->cReceiptsTo * sizeof(NOCOPYANY));
    if (OssInfo.receiptsTo.value == NULL) {
        goto ErrorReturn;
    }
    
    for (i=0; i<pInfo->cReceiptsTo; i++) {
        OssX509SetAny(&pInfo->rgReceiptsTo[i],
                      &OssInfo.receiptsTo.value[i]);
    }

    fResult = OssInfoEncodeEx(ReceiptRequest_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    if (OssInfo.receiptsFrom.u.receiptList.value != NULL) {
        free(OssInfo.receiptsFrom.u.receiptList.value);
    }
    if (OssInfo.receiptsTo.value != NULL) {
        free(OssInfo.receiptsTo.value);
    }
    
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssReceiptRequestDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_RECEIPT_REQUEST      pInfo = (PSMIME_RECEIPT_REQUEST) pvStructInfo;
    ReceiptRequest *            pOssInfo = (ReceiptRequest *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_RECEIPT_REQUEST);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_RECEIPT_REQUEST);
        memset(pInfo, 0, sizeof(SMIME_RECEIPT_REQUEST));
    }
    else {
        pbExtra = NULL;
        pInfo = NULL;
    }

    //
    //  ContentIdentifier
    //

    if (pOssInfo->signedContentIdentifier.length > 0) {
        lRemainExtra -= pOssInfo->signedContentIdentifier.length;
        if (lRemainExtra >= 0) {
            pInfo->ContentIdentifier.cbData = 
                pOssInfo->signedContentIdentifier.length;
            pInfo->ContentIdentifier.pbData = pbExtra;
            memcpy(pbExtra, pOssInfo->signedContentIdentifier.value,
                   pOssInfo->signedContentIdentifier.length);
            pbExtra += pOssInfo->signedContentIdentifier.length;
        }
    }

    //
    //  ReceiptsFrom
    //

    if (pOssInfo->receiptsFrom.choice == receiptList_chosen) {
        cb = pOssInfo->receiptsFrom.u.receiptList.count * sizeof(CERT_NAME_BLOB);
        lRemainExtra -= cb;
            
        if (lRemainExtra >= 0) {
            pInfo->ReceiptsFrom.cNames = pOssInfo->receiptsFrom.u.receiptList.count;
            pInfo->ReceiptsFrom.rgNames = (CERT_NAME_BLOB *) pbExtra;
            pbExtra += cb;
        }

        for (i=0; i<pOssInfo->receiptsFrom.u.receiptList.count; i++) {
            OssX509GetAny(&pOssInfo->receiptsFrom.u.receiptList.value[i], dwFlags,
                          (pInfo == NULL) ? NULL : &pInfo->ReceiptsFrom.rgNames[i],
                          &pbExtra, &lRemainExtra);
        }
    }
    else {
        if (pInfo != NULL) {
            pInfo->ReceiptsFrom.AllOrFirstTier = 
                pOssInfo->receiptsFrom.u.allOrFirstTier;
        }
    }

    //  ReceiptsTo

    cb = pOssInfo->receiptsTo.count * sizeof(CERT_NAME_BLOB);
    lRemainExtra -= cb;
    if (lRemainExtra >= 0) {
        pInfo->cReceiptsTo = pOssInfo->receiptsTo.count;
        pInfo->rgReceiptsTo = (CERT_NAME_BLOB *) pbExtra;
        pbExtra += cb;
    }
    
    for (i=0; i<pOssInfo->receiptsTo.count; i++) {
        OssX509GetAny(&pOssInfo->receiptsTo.value[i], dwFlags,
                      (pInfo == NULL) ? NULL : &pInfo->rgReceiptsTo[i], 
                      &pbExtra, &lRemainExtra);
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssReceiptRequestDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssReceiptRequestDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(ReceiptRequest_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssReceiptRequestDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}


////////////////////////////// Receipt Content Type ///////////////////////////////////

////    EssReceiptEncodeEx
//
//  Description:
//      This function is used to encode the Receipt content type found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssReceiptEncodeEx(IN DWORD dwCertEncodingType,
                               IN LPCSTR lpszStructType,
                               IN PSMIME_RECEIPT pInfo,
                               IN DWORD dwFlags,
                               IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                               OUT OPTIONAL void *pvEncoded,
                               IN OUT DWORD *pcbEncoded
                               )
{
    BOOL                fResult;
    DWORD               i;
    Receipt             OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    //  Version number
    OssInfo.version = pInfo->Version;

    //  ContentType
    OssInfo.contentType.count = sizeof(OssInfo.contentType.value)/sizeof(OssInfo.contentType.value[0]);
    fResult = OssX509SetEncodedObjId(pInfo->pszOIDContent, &OssInfo.contentType);
    if (!fResult) {
        goto ErrorReturn;
    }
    
    //  ContentIdentifier
    OssInfo.signedContentIdentifier.length = pInfo->ContentIdentifier.cbData;
    OssInfo.signedContentIdentifier.value = pInfo->ContentIdentifier.pbData;

    //  Originator signature

    OssX509SetOctetString(&pInfo->OriginatorSignature, 
                          &OssInfo.originatorSignatureValue);

    //  Do the actual encoding

    fResult = OssInfoEncodeEx(Receipt_PDU, &OssInfo, dwFlags, pEncodePara, 
                              pvEncoded, pcbEncoded);
CommonReturn:
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssReceiptDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                       PCRYPT_DECODE_PARA pDecodePara,
                                       void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_RECEIPT              pInfo = (PSMIME_RECEIPT) pvStructInfo;
    Receipt *                   pOssInfo = (Receipt *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_RECEIPT);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_RECEIPT);
        memset(pInfo, 0, sizeof(SMIME_RECEIPT));
    }
    else {
        pbExtra = NULL;
    }

    //
    //  VersionNumber
    //

    if (pInfo != NULL) {
        pInfo->Version = pOssInfo->version;
    }

    //  ContentType
    #pragma prefast(suppress:11, "&pInfo->pszOIDContent is OK when pInfo is NULL");
    OssX509GetEncodedObjId(&pOssInfo->contentType, dwFlags, &pInfo->pszOIDContent, 
                           &pbExtra, &lRemainExtra);

    //
    //  ContentIdentifier
    //

    if (pOssInfo->signedContentIdentifier.length > 0) {
        lRemainExtra -= pOssInfo->signedContentIdentifier.length;
        if (lRemainExtra >= 0) {
            pInfo->ContentIdentifier.cbData = 
                pOssInfo->signedContentIdentifier.length;
            pInfo->ContentIdentifier.pbData = pbExtra;
            memcpy(pbExtra, pOssInfo->signedContentIdentifier.value,
                   pOssInfo->signedContentIdentifier.length);
            pbExtra += pOssInfo->signedContentIdentifier.length;
        }
    }

    //
    //  Originator signature
    //
    #pragma prefast(suppress:11, "&pInfo->OriginatorSignature is OK when pInfo is NULL");
    OssX509GetOctetString(&pOssInfo->originatorSignatureValue, dwFlags,
                          &pInfo->OriginatorSignature, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssReceiptDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssReceiptDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(Receipt_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssReceiptDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}


////////////////////////////// ML Expansion History /////////////////////////////////

////    EssMLHistoryEncodeEx
//
//  Description:
//      This function is used to encode the MLHistory content type found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssMLHistoryEncodeEx(IN DWORD dwCertEncodingType,
                                 IN LPCSTR lpszStructType,
                                 IN PSMIME_ML_EXPANSION_HISTORY pInfo,
                                 IN DWORD dwFlags,
                                 IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                 OUT OPTIONAL void *pvEncoded,
                                 IN OUT DWORD *pcbEncoded
                                 )
{
    BOOL                fResult;
    DWORD               i;
    DWORD               i1;
    MLExpansionHistory  OssInfo;
    MLData *            pData;
    PSMIME_MLDATA       pMLData;

    memset(&OssInfo, 0, sizeof(OssInfo));

    //  Move over the count
    OssInfo.count = (USHORT) pInfo->cMLData;
    pData = OssInfo.value = (MLData *) malloc(OssInfo.count * sizeof(MLData));
    if (pData == NULL) {
        goto ErrorReturn;
    }
    memset(OssInfo.value, 0, OssInfo.count*sizeof(MLData));

    //    Assert(none_chosen == SMIME_MLPOLICY_NONE);
    //    Assert(insteadOf_chosen == SMIME_MLPOLICY_INSTEAD_OF);
    //    Assert(inAdditionTo_chosen == SMIME_MLPOLICY_IN_ADDITION_TO);

    pMLData = pInfo->rgMLData;
    for (i=0; i<OssInfo.count; i++, pData++, pMLData++) {
        if (pMLData->dwChoice == SMIME_MLDATA_SUBJECT_KEY_IDENTIFIER) {
            pData->mailListIdentifier.choice = subjectKeyIdentifier_chosen;

            PkiAsn1SetOctetString(&pMLData->SubjectKeyIdentifier,
                          &pData->mailListIdentifier.u.subjectKeyIdentifier);
        }
        else {
            pData->mailListIdentifier.choice = EntityIdentifier_issuerAndSerialNumber_chosen;
            PkiAsn1SetHugeInteger(&pMLData->u.SerialNumber,
                          &pData->mailListIdentifier.u.issuerAndSerialNumber.serialNumber);
            PkiAsn1SetAny(&pMLData->u.Issuer,
                          &pData->mailListIdentifier.u.issuerAndSerialNumber.issuer);
        }
        
        PkiAsn1ToGeneralizedTime(&pMLData->ExpansionTime, &pData->expansionTime);
        
        if (pMLData->dwPolicy != SMIME_MLPOLICY_NO_CHANGE) {
            pData->bit_mask |= mlReceiptPolicy_present;
            pData->mlReceiptPolicy.choice = (USHORT) pMLData->dwPolicy;
            if (pData->mlReceiptPolicy.choice != SMIME_MLPOLICY_NONE) {
                pData->mlReceiptPolicy.u.insteadOf.count = pMLData->cNames;
                pData->mlReceiptPolicy.u.insteadOf.value = (GeneralNames *)
                    malloc(pData->mlReceiptPolicy.u.insteadOf.count * sizeof(GeneralNames));
                if (pData->mlReceiptPolicy.u.insteadOf.value == NULL) {
                    goto ErrorReturn;
                }
                for (i1=0; i1<pData->mlReceiptPolicy.u.insteadOf.count; i1++) {
                    OssX509SetAny(&pMLData->rgNames[i1],
                                  &pData->mlReceiptPolicy.u.insteadOf.value[i1]);
                }
            }
        }
    }

    //  Do the actual encoding

    fResult = OssInfoEncodeEx(MLExpansionHistory_PDU, &OssInfo, dwFlags, pEncodePara, 
                              pvEncoded, pcbEncoded);
CommonReturn:
    if (OssInfo.value != NULL) {
        for (pData = OssInfo.value, i=0; i<OssInfo.count; i++, pData++) {
            PkiAsn1FreeHugeInteger(pData->mailListIdentifier.u.issuerAndSerialNumber.serialNumber);
            if (pData->mlReceiptPolicy.u.insteadOf.value != NULL) {
                free(pData->mlReceiptPolicy.u.insteadOf.value);
            }
        }
        free(OssInfo.value);
    }
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssMLHistoryDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                       PCRYPT_DECODE_PARA pDecodePara,
                                       void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    DWORD                       i1;
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    MLData *                    pData;
    PSMIME_ML_EXPANSION_HISTORY pInfo = (PSMIME_ML_EXPANSION_HISTORY) pvStructInfo;
    PSMIME_MLDATA               pMLData;
    MLExpansionHistory *        pOssInfo = (MLExpansionHistory *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_ML_EXPANSION_HISTORY);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_ML_EXPANSION_HISTORY);
        memset(pInfo, 0, sizeof(SMIME_ML_EXPANSION_HISTORY));
    }
    else {
        pbExtra = NULL;
        pInfo = NULL;
    }

    lRemainExtra -= pOssInfo->count * sizeof(SMIME_MLDATA);
    if (lRemainExtra >= 0) {
        pInfo->cMLData = pOssInfo->count;
        pMLData = pInfo->rgMLData = (PSMIME_MLDATA) pbExtra;
        pbExtra += pOssInfo->count * sizeof(SMIME_MLDATA);
    }

    for (i=0, pData = pOssInfo->value; i<pOssInfo->count; i++, pData++) {
        if (pData->mailListIdentifier.choice == subjectKeyIdentifier_chosen) {
            pData->mailListIdentifier.choice = subjectKeyIdentifier_chosen;
            PkiAsn1GetOctetString(&pData->mailListIdentifier.u.subjectKeyIdentifier,
                                  dwFlags, &pMLData->SubjectKeyIdentifier, 
                                  &pbExtra, &lRemainExtra);
        }
        else {
            pData->mailListIdentifier.choice = EntityIdentifier_issuerAndSerialNumber_chosen;
            PkiAsn1GetHugeInteger(pData->mailListIdentifier.u.issuerAndSerialNumber.serialNumber,
                               dwFlags, &pMLData->u.SerialNumber, 
                               &pbExtra, &lRemainExtra);
            PkiAsn1GetAny(&pData->mailListIdentifier.u.issuerAndSerialNumber.issuer,
                          dwFlags, &pMLData->u.Issuer, 
                          &pbExtra, &lRemainExtra);
        }
        
        if (lRemainExtra >= 0) {
            PkiAsn1FromGeneralizedTime(&pData->expansionTime, &pMLData->ExpansionTime);
        }            
        if (pData->bit_mask & mlReceiptPolicy_present) {
            if (lRemainExtra >= 0) {
                pMLData->dwPolicy = pData->mlReceiptPolicy.choice;
            }

            if (pData->mlReceiptPolicy.choice != none_chosen) {
                lRemainExtra -= pData->mlReceiptPolicy.u.insteadOf.count * sizeof(GeneralNames);
                if (lRemainExtra >= 0) {
                    pMLData->cNames = pData->mlReceiptPolicy.u.insteadOf.count;
                    pMLData->rgNames = (CERT_NAME_BLOB *) pbExtra;
                    pbExtra += pMLData->cNames * sizeof(CERT_NAME_BLOB);
                }
                for (i1=0; i1<pData->mlReceiptPolicy.u.insteadOf.count; i1++) {
                    OssX509GetAny(&pData->mlReceiptPolicy.u.insteadOf.value[i1],
                                  dwFlags, &pMLData->rgNames[i1], &pbExtra,
                                  &lRemainExtra);
                }
            }
        }
        else if (lRemainExtra >= 0) {
            pMLData->dwPolicy = SMIME_MLPOLICY_NO_CHANGE;
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssMLHistoryDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssMLHistoryDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(MLExpansionHistory_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssMLHistoryDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}

/////////////////////////////////////////////////////////////////////////////

////    EssSecurityLabelEncodeEx
//
//  Description:
//      This function is used to encode the SecurityLabel attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Security_Label
//      pInfo                   - external passed structure with Security Label
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssSecurityLabelEncodeEx(IN DWORD dwCertEncodingType,
                                   IN LPCSTR lpszStructType,
                                   IN PSMIME_SECURITY_LABEL pInfo,
                                   IN DWORD dwFlags,
                                   IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                   OUT OPTIONAL void *pvEncoded,
                                   IN OUT DWORD *pcbEncoded
                                   )
{
    BOOL                fResult;
    DWORD               i;
    ESSSecurityLabel    OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    OssInfo.security_policy_identifier.count = sizeof(OssInfo.security_policy_identifier.value)/sizeof(OssInfo.security_policy_identifier.value[0]);
    if (!OssX509SetEncodedObjId(pInfo->pszObjIdSecurityPolicy,
                         &OssInfo.security_policy_identifier)) {
        goto ErrorReturn;
    }
    
    if (pInfo->fHasClassification) {
        OssInfo.bit_mask |= security_classification_present;
        OssInfo.security_classification = (USHORT) pInfo->dwClassification;
    }

    if (pInfo->wszPrivacyMark != NULL) {
        OssInfo.bit_mask |= privacy_mark_present;
        OssInfo.privacy_mark.choice = utf8String_chosen;
        PkiAsn1SetUTF8String(pInfo->wszPrivacyMark, &OssInfo.privacy_mark.u.utf8String);
    }

    if (pInfo->cCategories != 0) {
        OssInfo.bit_mask |= security_categories_present;
        OssInfo.security_categories.count = (USHORT) pInfo->cCategories;
        OssInfo.security_categories.value = (SecurityCategory *)
            malloc(OssInfo.security_categories.count * sizeof(SecurityCategory));
        for (i=0; i<pInfo->cCategories; i++) {
            OssInfo.security_categories.value[i].type.count = sizeof(OssInfo.security_categories.value[0].type.value)/sizeof(OssInfo.security_categories.value[0].type.value[0]);
            if (!OssX509SetEncodedObjId(pInfo->rgCategories[i].pszObjId,
                                 &OssInfo.security_categories.value[i].type)) {
                goto ErrorReturn;
            }
            OssX509SetAny(&pInfo->rgCategories[i].Value,
                          &OssInfo.security_categories.value[i].value);
        }
    }

    fResult = OssInfoEncodeEx(ESSSecurityLabel_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    if (OssInfo.security_categories.value != NULL) {
        free(OssInfo.security_categories.value);
    }
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
}

////    

STDAPI_(BOOL) EssSecurityLabelDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    DWORD                       cb;
    DWORD                       i;
    LONG                        lRemainExtra = *plRemainExtra;
    CRYPT_ATTRIBUTE_TYPE_VALUE * pattr;
    LPBYTE                      pbExtra;
    PSMIME_SECURITY_LABEL       pInfo = (PSMIME_SECURITY_LABEL) pvStructInfo;
    ESSSecurityLabel *          pOssInfo = (ESSSecurityLabel *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_SECURITY_LABEL);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_SECURITY_LABEL);
        memset(pInfo, 0, sizeof(*pInfo));
    }
    else {
        pbExtra = NULL;
        pInfo = NULL;
    }

    if (lRemainExtra >= 0) {
        pInfo->pszObjIdSecurityPolicy = (LPSTR) pbExtra;
    }
    OssX509GetEncodedObjId(&pOssInfo->security_policy_identifier, dwFlags,
                    (pInfo == NULL) ? NULL : &pInfo->pszObjIdSecurityPolicy, 
                    &pbExtra, &lRemainExtra);

    if ((pInfo != NULL) &&
        (pOssInfo->bit_mask & security_classification_present)) {
        pInfo->dwClassification = pOssInfo->security_classification;
        pInfo->fHasClassification = TRUE;
    }

    if (pOssInfo->bit_mask & privacy_mark_present) {
        if (utf8String_chosen == pOssInfo->privacy_mark.choice) {
            OssX509GetEncodedUTF8String(&pOssInfo->privacy_mark.u.utf8String, dwFlags,
                                        (pInfo == NULL) ? NULL : &pInfo->wszPrivacyMark,
                                        &pbExtra, &lRemainExtra);
        }
        else if (pString_chosen == pOssInfo->privacy_mark.choice) {            
            Assert(NULL != pOssInfo->privacy_mark.u.pString);
            OssX509GetEncodedPString(&pOssInfo->privacy_mark.u.pString, dwFlags,
                                        (pInfo == NULL) ? NULL : &pInfo->wszPrivacyMark,
                                        &pbExtra, &lRemainExtra);
        }
        else {
            return FALSE; // unknown privacy_mark encoding...
        }
    }

    if (pOssInfo->bit_mask & security_categories_present) {
        cb = pOssInfo->security_categories.count *
            sizeof(CRYPT_ATTRIBUTE_TYPE_VALUE);
        lRemainExtra -= cb;

        if (lRemainExtra >= 0) {
            pInfo->cCategories = pOssInfo->security_categories.count;
            pattr = pInfo->rgCategories = (CRYPT_ATTRIBUTE_TYPE_VALUE *) pbExtra;
            pbExtra += cb;
        }
        else {
            pattr = NULL;
        }

        for (i=0; i<pOssInfo->security_categories.count; i++, pattr++) {
            OssX509GetEncodedObjId(&pOssInfo->security_categories.value[i].type,
                            dwFlags, (pattr == NULL) ? NULL : &pattr->pszObjId,
                            &pbExtra, &lRemainExtra);
            OssX509GetAny(&pOssInfo->security_categories.value[i].value,
                          dwFlags, (pattr == NULL) ? NULL : &pattr->Value,
                          &pbExtra, &lRemainExtra);
        }
    }

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssSecurityLabelDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Security Label decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssSecurityLabelDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(ESSSecurityLabel_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssSecurityLabelDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}

///////////////////////////////////////////////////////////////////////

BOOL DH_ImportPublicKeyInfoEx(HCRYPTPROV hprov, DWORD dwCertEncodingType,
                              PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID algId,
                              DWORD dwFlags,
                              void * pvAuxInfo, HCRYPTKEY * phKey)
{
    DWORD                       cb;
    int                         cbBlob;
    DWORD                       cbKey;
    BOOL                        fRet = FALSE;
    HRESULT                     hr;
    LPBYTE                      pb;
    CRYPT_UINT_BLOB *           pblob = NULL;
    LPBYTE                      pbBlob = NULL;
    DHPUBKEY *                  pdhPubKey;
    PCERT_DSS_PARAMETERS        pDssParameters = NULL;
    PUBLICKEYSTRUC *            pKeyBlob;

    hr = HrDecodeObject(pInfo->Algorithm.Parameters.pbData,
                        pInfo->Algorithm.Parameters.cbData,
                        X509_DSS_PARAMETERS, 0, &cb, (LPVOID*) &pDssParameters);
    if (FAILED(hr)) {
        goto Exit;
    }

    cbKey = pDssParameters->p.cbData;
    if (0 == cbKey) {
        goto Exit;
    }
    
    cbBlob = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + 3*cbKey;

    pbBlob = (LPBYTE) malloc(cbBlob);

    pKeyBlob = (PUBLICKEYSTRUC *) pbBlob;
    pKeyBlob->bType = PUBLICKEYBLOB;
    pKeyBlob->bVersion = CUR_BLOB_VERSION;
    pKeyBlob->aiKeyAlg = CALG_DH_EPHEM;
    
    pdhPubKey = (DHPUBKEY *) &pKeyBlob[1];
    pdhPubKey->magic = 0x33484400;
    pdhPubKey->bitlen = cbKey*8;

    pb = (LPBYTE) &pdhPubKey[1];
    memcpy(pb, pDssParameters->p.pbData, cbKey);
    pb += cbKey;
    
    //    memcpy(pb, pDssParameters->q.pbData, pDssParameters->q.cbData);
    //    pb += pDssParameters->q.cbData;
    
    memcpy(pb, pDssParameters->g.pbData, cbKey);
    pb += cbKey;
    
    memcpy(pb, pInfo->PublicKey.pbData, cbKey);
    pb += cbKey;

    Assert(cbBlob == (pb - pbBlob));
    
    //    memcpy(pb, &seed, sizeof(seed));
    

    if (!CryptImportKey(hprov, pbBlob, cbBlob, NULL, 0, phKey)) {
        goto Exit;
    }

    fRet = TRUE;
Exit:
    if (pblob != NULL)          LocalFree(pblob);
    if (pbBlob != NULL)         free(pbBlob);
    if (pDssParameters != NULL) LocalFree(pDssParameters);
    return fRet;
}
#endif // SMIME_V3

////////////////////////////////////////////////////////////////////////////////

////    EssContentHintEncodeEx
//
//  Description:
//      This function is used to encode the ContentHint attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssKeyExchPreferenceEncodeEx(IN DWORD dwCertEncodingType,
                                         IN LPCSTR lpszStructType,
                                         IN PSMIME_ENC_KEY_PREFERENCE pInfo,
                                         IN DWORD dwFlags,
                                         IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                         OUT OPTIONAL void *pvEncoded,
                                         IN OUT DWORD *pcbEncoded)
{
    BOOL                                fResult;
    SMIMEEncryptionKeyPreference        OssInfo;
    
    memset(&OssInfo, 0, sizeof(OssInfo));

    switch (pInfo->RecipientId.dwIdChoice) {
    case CERT_ID_ISSUER_SERIAL_NUMBER:
        OssInfo.choice = SMIMEEncryptionKeyPreference_issuerAndSerialNumber_chosen;
        PkiAsn1SetHugeInteger(&pInfo->RecipientId.IssuerSerialNumber.SerialNumber,
                              &OssInfo.u.issuerAndSerialNumber.serialNumber);
        PkiAsn1SetAny(&pInfo->RecipientId.IssuerSerialNumber.Issuer,
                      &OssInfo.u.issuerAndSerialNumber.issuer);
        break;

    case CERT_ID_KEY_IDENTIFIER:
        OssInfo.choice = recipientKeyId_chosen;
        OssX509SetOctetString(&pInfo->RecipientId.KeyId,
                              &OssInfo.u.recipientKeyId.subjectKeyIdentifier);
        if ((pInfo->Date.dwLowDateTime != 0) || (pInfo->Date.dwHighDateTime != 0)) {
            
            PkiAsn1ToGeneralizedTime(&pInfo->Date, &OssInfo.u.recipientKeyId.date);
        }
        if (pInfo->pOtherAttr != NULL) {
            if (!OssX509SetEncodedObjId(pInfo->pOtherAttr->pszObjId,
                                        &OssInfo.u.recipientKeyId.other.keyAttrId)) {
                goto ErrorReturn;
            }

            if (pInfo->pOtherAttr->Value.cbData != 0) {
                OssInfo.u.recipientKeyId.other.bit_mask |= keyAttr_present;
                PkiAsn1SetAny(&pInfo->pOtherAttr->Value,
                              &OssInfo.u.recipientKeyId.other.keyAttr);
            }
        }
        break;

    case CERT_ID_SHA1_HASH:
        OssInfo.choice = subjectAltKeyIdentifier_chosen;
        OssX509SetOctetString(&pInfo->RecipientId.HashId,
                              &OssInfo.u.subjectAltKeyIdentifier);
        break;

    default:
        goto ErrorReturn;
    }

    fResult = OssInfoEncodeEx(SMIMEEncryptionKeyPreference_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}


STDAPI_(BOOL) EssKeyExchPreferenceDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_ENC_KEY_PREFERENCE   pInfo = (PSMIME_ENC_KEY_PREFERENCE) pvStructInfo;
    SMIMEEncryptionKeyPreference *  pOssInfo = (SMIMEEncryptionKeyPreference *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_ENC_KEY_PREFERENCE);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_ENC_KEY_PREFERENCE);
    }
    else {
        pbExtra = NULL;
    }

    switch (pOssInfo->choice) {
    case SMIMEEncryptionKeyPreference_issuerAndSerialNumber_chosen:
        if (pInfo != NULL) {
            pInfo->RecipientId.dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
        }
        PkiAsn1GetHugeInteger(pOssInfo->u.issuerAndSerialNumber.serialNumber,
                              dwFlags, (pInfo == NULL) ? NULL :
                               &pInfo->RecipientId.IssuerSerialNumber.SerialNumber,
                              &pbExtra, &lRemainExtra);
        PkiAsn1GetAny(&pOssInfo->u.issuerAndSerialNumber.issuer, dwFlags,
                      (pInfo == NULL) ? NULL :
                                &pInfo->RecipientId.IssuerSerialNumber.Issuer,
                      &pbExtra, &lRemainExtra);
        break;

    case recipientKeyId_chosen:
        if (pInfo != NULL) {
            pInfo->RecipientId.dwIdChoice = CERT_ID_KEY_IDENTIFIER;
        }
        OssX509GetOctetString(&pOssInfo->u.recipientKeyId.subjectKeyIdentifier,
                              dwFlags, &pInfo->RecipientId.KeyId,
                              &pbExtra, &lRemainExtra);
        if ((lRemainExtra >= 0) &&
            (pOssInfo->u.recipientKeyId.bit_mask & date_present)) {
            PkiAsn1FromGeneralizedTime(&pOssInfo->u.recipientKeyId.date,
                                       &pInfo->Date);
        }

        if (pOssInfo->u.recipientKeyId.bit_mask & other_present) {
            OssX509GetEncodedObjId(&pOssInfo->u.recipientKeyId.other.keyAttrId,
                                   dwFlags, (pInfo == NULL) ? NULL :
                                        &pInfo->pOtherAttr->pszObjId, 
                                   &pbExtra, &lRemainExtra);
            if (pOssInfo->u.recipientKeyId.other.bit_mask & keyAttr_present) {
                PkiAsn1GetAny(&pOssInfo->u.recipientKeyId.other.keyAttr,
                              dwFlags, (pInfo == NULL) ? NULL :
                              &pInfo->pOtherAttr->Value, &pbExtra, &lRemainExtra);
            }
        }
        break;

    case subjectAltKeyIdentifier_chosen:
        if (pInfo != NULL) {
            pInfo->RecipientId.dwIdChoice = CERT_ID_SHA1_HASH;
        }
        OssX509GetOctetString(&pOssInfo->u.subjectAltKeyIdentifier, dwFlags,
                              &pInfo->RecipientId.HashId, &pbExtra, &lRemainExtra);
        break;

    default:
        return FALSE;
    }
     
    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssKeyExchPreferenceDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssKeyExchPreferenceDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(SMIMEEncryptionKeyPreference_PDU, pbEncoded,
                                   cbEncoded, dwFlags, pDecodePara, 
                                   EssKeyExchPreferenceDecodeExCallback,
                                   pvStructInfo, pcbStructInfo);
}

////    EssSignCertificateEncodeEx
//
//  Description:
//      This function is used to encode the ContentHint attribute found in
//      some S/MIME messages.  Defintion of this object may be found in
//      draft-ietf-smime-ess
//
//  Parameters:
//      dwCertEncodingType      - should be ASN_X509_ENCODE
//      lpszStructType          - should be szOID_Content_Hints
//      pInfo                   - external passed structure with content hints
//      dwFlags                 - control flags
//      pEncodePara             - allocation functions
//      pvEncoded               - Return encoded bytes here
//      pcbEncoded              - Return size of encoded object
//

STDAPI_(BOOL) EssSignCertificateEncodeEx(IN DWORD dwCertEncodingType,
                                       IN LPCSTR lpszStructType,
                                       IN PSMIME_SIGNING_CERTIFICATE pInfo,
                                       IN DWORD dwFlags,
                                       IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
                                       OUT OPTIONAL void *pvEncoded,
                                       IN OUT DWORD *pcbEncoded)
{
    BOOL                fResult;
    SigningCertificate  OssInfo;

    memset(&OssInfo, 0, sizeof(OssInfo));

    fResult = OssInfoEncodeEx(SigningCertificate_PDU, &OssInfo, dwFlags,
                              pEncodePara, pvEncoded, pcbEncoded);
    //CommonReturn:
    return fResult;

#if 0
ErrorReturn:
    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        *((void **) pvEncoded) = NULL;
    }
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;
#endif // 0
}


STDAPI_(BOOL) EssSignCertificateDecodeExCallback(void *pvOssInfo, DWORD dwFlags,
                                           PCRYPT_DECODE_PARA pDecodePara,
                                           void *pvStructInfo, LONG *plRemainExtra)
{
    LONG                        lRemainExtra = *plRemainExtra;
    LPBYTE                      pbExtra;
    PSMIME_CONTENT_HINTS        pInfo = (PSMIME_CONTENT_HINTS) pvStructInfo;
    ContentHints *              pOssInfo = (ContentHints *) pvOssInfo;

    //  Remove space of base object
    lRemainExtra -= sizeof(SMIME_CONTENT_HINTS);

    if (lRemainExtra >= 0) {
        pbExtra = (BYTE *) pInfo + sizeof(SMIME_CONTENT_HINTS);
    }
    else {
        pbExtra = NULL;
    }

    OssX509GetEncodedObjId(&pOssInfo->contentType, dwFlags, &pInfo->pszOIDContent, 
                           &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    return TRUE;
}

////    EssSignCertificateDecodeEx
//
//  Description:
//
//  Parameter:
//      dwCertEncodingType      in - 
//      lpszStructType          in - 
//      pbEncoded               in - ASN encoded structure to be parsed
//      cbEncoded               in - size of pbEncoded
//      dwFlags                 in -
//      pDecodePara             in - Allocation parameters
//      pvStructInfo            out - Returned Content Hints decoded
//      pcbStructInfo           in/out - sizeof pvStructInfo
//

STDAPI_(BOOL) EssSignCertificateDecodeEx(IN DWORD dwCertEncodingType, IN LPCSTR lpszStructType,
                       IN const BYTE *pbEncoded, IN DWORD cbEncoded,
                       IN DWORD dwFlags, IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
                       OUT OPTIONAL void *pvStructInfo, IN OUT DWORD *pcbStructInfo)
{
    return OssInfoDecodeAndAllocEx(SigningCertificate_PDU, pbEncoded, cbEncoded,
                                   dwFlags, pDecodePara, 
                                   EssSignCertificateDecodeExCallback, pvStructInfo,
                                   pcbStructInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\ess.cpp ===
#include <windows.h>
#include <windows.h>
#include "msber.h"
#include "crypttls.h"
#include "demand2.h"
#include "ess.h"
#include "msber.inl"

ASN1module_t ESS_Module = NULL;

static int ASN1CALL ASN1Enc_SigningCertificate_policies(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_policies *val);
static int ASN1CALL ASN1Enc_SigningCertificate_certs(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_certs *val);
static int ASN1CALL ASN1Enc_MLReceiptPolicy_inAdditionTo(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val);
static int ASN1CALL ASN1Enc_MLReceiptPolicy_insteadOf(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val);
static int ASN1CALL ASN1Enc_ReceiptsFrom_receiptList(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom_receiptList *val);
static int ASN1CALL ASN1Enc_ReceiptRequest_receiptsTo(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val);
static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Enc_ReceiptsFrom(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom *val);
static int ASN1CALL ASN1Enc_Receipt(ASN1encoding_t enc, ASN1uint32_t tag, Receipt *val);
static int ASN1CALL ASN1Enc_ContentHints(ASN1encoding_t enc, ASN1uint32_t tag, ContentHints *val);
static int ASN1CALL ASN1Enc_ContentReference(ASN1encoding_t enc, ASN1uint32_t tag, ContentReference *val);
static int ASN1CALL ASN1Enc_ESSPrivacyMark(ASN1encoding_t enc, ASN1uint32_t tag, ESSPrivacyMark *val);
static int ASN1CALL ASN1Enc_SecurityCategories(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategories *val);
static int ASN1CALL ASN1Enc_SecurityCategory(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategory *val);
static int ASN1CALL ASN1Enc_EquivalentLabels(ASN1encoding_t enc, ASN1uint32_t tag, EquivalentLabels *val);
static int ASN1CALL ASN1Enc_MLExpansionHistory(ASN1encoding_t enc, ASN1uint32_t tag, MLExpansionHistory *val);
static int ASN1CALL ASN1Enc_EntityIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EntityIdentifier *val);
static int ASN1CALL ASN1Enc_MLReceiptPolicy(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy *val);
static int ASN1CALL ASN1Enc_SigningCertificate(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate *val);
static int ASN1CALL ASN1Enc_ReceiptRequest(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest *val);
static int ASN1CALL ASN1Enc_ESSSecurityLabel(ASN1encoding_t enc, ASN1uint32_t tag, ESSSecurityLabel *val);
static int ASN1CALL ASN1Enc_MLData(ASN1encoding_t enc, ASN1uint32_t tag, MLData *val);
static int ASN1CALL ASN1Enc_ESSCertID(ASN1encoding_t enc, ASN1uint32_t tag, ESSCertID *val);
static int ASN1CALL ASN1Enc_SMimeEncryptCerts(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCerts *val);
static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Enc_SMimeEncryptCert(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCert *val);
static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Enc_SMIMEEncryptionKeyPreference(ASN1encoding_t enc, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val);
static int ASN1CALL ASN1Dec_SigningCertificate_policies(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_policies *val);
static int ASN1CALL ASN1Dec_SigningCertificate_certs(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_certs *val);
static int ASN1CALL ASN1Dec_MLReceiptPolicy_inAdditionTo(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val);
static int ASN1CALL ASN1Dec_MLReceiptPolicy_insteadOf(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val);
static int ASN1CALL ASN1Dec_ReceiptsFrom_receiptList(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom_receiptList *val);
static int ASN1CALL ASN1Dec_ReceiptRequest_receiptsTo(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val);
static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Dec_ReceiptsFrom(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom *val);
static int ASN1CALL ASN1Dec_Receipt(ASN1decoding_t dec, ASN1uint32_t tag, Receipt *val);
static int ASN1CALL ASN1Dec_ContentHints(ASN1decoding_t dec, ASN1uint32_t tag, ContentHints *val);
static int ASN1CALL ASN1Dec_ContentReference(ASN1decoding_t dec, ASN1uint32_t tag, ContentReference *val);
static int ASN1CALL ASN1Dec_ESSPrivacyMark(ASN1decoding_t dec, ASN1uint32_t tag, ESSPrivacyMark *val);
static int ASN1CALL ASN1Dec_SecurityCategories(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategories *val);
static int ASN1CALL ASN1Dec_SecurityCategory(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategory *val);
static int ASN1CALL ASN1Dec_EquivalentLabels(ASN1decoding_t dec, ASN1uint32_t tag, EquivalentLabels *val);
static int ASN1CALL ASN1Dec_MLExpansionHistory(ASN1decoding_t dec, ASN1uint32_t tag, MLExpansionHistory *val);
static int ASN1CALL ASN1Dec_EntityIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EntityIdentifier *val);
static int ASN1CALL ASN1Dec_MLReceiptPolicy(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy *val);
static int ASN1CALL ASN1Dec_SigningCertificate(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate *val);
static int ASN1CALL ASN1Dec_ReceiptRequest(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest *val);
static int ASN1CALL ASN1Dec_ESSSecurityLabel(ASN1decoding_t dec, ASN1uint32_t tag, ESSSecurityLabel *val);
static int ASN1CALL ASN1Dec_MLData(ASN1decoding_t dec, ASN1uint32_t tag, MLData *val);
static int ASN1CALL ASN1Dec_ESSCertID(ASN1decoding_t dec, ASN1uint32_t tag, ESSCertID *val);
static int ASN1CALL ASN1Dec_SMimeEncryptCerts(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCerts *val);
static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val);
static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val);
static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Dec_SMimeEncryptCert(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCert *val);
static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Dec_SMIMEEncryptionKeyPreference(ASN1decoding_t dec, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val);
static void ASN1CALL ASN1Free_SigningCertificate_policies(SigningCertificate_policies *val);
static void ASN1CALL ASN1Free_SigningCertificate_certs(SigningCertificate_certs *val);
static void ASN1CALL ASN1Free_MLReceiptPolicy_inAdditionTo(MLReceiptPolicy_inAdditionTo *val);
static void ASN1CALL ASN1Free_MLReceiptPolicy_insteadOf(MLReceiptPolicy_insteadOf *val);
static void ASN1CALL ASN1Free_ReceiptsFrom_receiptList(ReceiptsFrom_receiptList *val);
static void ASN1CALL ASN1Free_ReceiptRequest_receiptsTo(ReceiptRequest_receiptsTo *val);
static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val);
static void ASN1CALL ASN1Free_ReceiptsFrom(ReceiptsFrom *val);
static void ASN1CALL ASN1Free_Receipt(Receipt *val);
static void ASN1CALL ASN1Free_ContentHints(ContentHints *val);
static void ASN1CALL ASN1Free_ContentReference(ContentReference *val);
static void ASN1CALL ASN1Free_ESSPrivacyMark(ESSPrivacyMark *val);
static void ASN1CALL ASN1Free_SecurityCategories(SecurityCategories *val);
static void ASN1CALL ASN1Free_SecurityCategory(SecurityCategory *val);
static void ASN1CALL ASN1Free_EquivalentLabels(EquivalentLabels *val);
static void ASN1CALL ASN1Free_MLExpansionHistory(MLExpansionHistory *val);
static void ASN1CALL ASN1Free_EntityIdentifier(EntityIdentifier *val);
static void ASN1CALL ASN1Free_MLReceiptPolicy(MLReceiptPolicy *val);
static void ASN1CALL ASN1Free_SigningCertificate(SigningCertificate *val);
static void ASN1CALL ASN1Free_ReceiptRequest(ReceiptRequest *val);
static void ASN1CALL ASN1Free_ESSSecurityLabel(ESSSecurityLabel *val);
static void ASN1CALL ASN1Free_MLData(MLData *val);
static void ASN1CALL ASN1Free_ESSCertID(ESSCertID *val);
static void ASN1CALL ASN1Free_SMimeEncryptCerts(SMimeEncryptCerts *val);
static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val);
static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val);
static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val);
static void ASN1CALL ASN1Free_SMimeEncryptCert(SMimeEncryptCert *val);
static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val);
static void ASN1CALL ASN1Free_SMIMEEncryptionKeyPreference(SMIMEEncryptionKeyPreference *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[10] = {
    (ASN1EncFun_t) ASN1Enc_Receipt,
    (ASN1EncFun_t) ASN1Enc_ContentHints,
    (ASN1EncFun_t) ASN1Enc_ContentReference,
    (ASN1EncFun_t) ASN1Enc_EquivalentLabels,
    (ASN1EncFun_t) ASN1Enc_MLExpansionHistory,
    (ASN1EncFun_t) ASN1Enc_SigningCertificate,
    (ASN1EncFun_t) ASN1Enc_SMimeEncryptCerts,
    (ASN1EncFun_t) ASN1Enc_ReceiptRequest,
    (ASN1EncFun_t) ASN1Enc_SMIMEEncryptionKeyPreference,
    (ASN1EncFun_t) ASN1Enc_ESSSecurityLabel,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[10] = {
    (ASN1DecFun_t) ASN1Dec_Receipt,
    (ASN1DecFun_t) ASN1Dec_ContentHints,
    (ASN1DecFun_t) ASN1Dec_ContentReference,
    (ASN1DecFun_t) ASN1Dec_EquivalentLabels,
    (ASN1DecFun_t) ASN1Dec_MLExpansionHistory,
    (ASN1DecFun_t) ASN1Dec_SigningCertificate,
    (ASN1DecFun_t) ASN1Dec_SMimeEncryptCerts,
    (ASN1DecFun_t) ASN1Dec_ReceiptRequest,
    (ASN1DecFun_t) ASN1Dec_SMIMEEncryptionKeyPreference,
    (ASN1DecFun_t) ASN1Dec_ESSSecurityLabel,
};
static const ASN1FreeFun_t freefntab[10] = {
    (ASN1FreeFun_t) ASN1Free_Receipt,
    (ASN1FreeFun_t) ASN1Free_ContentHints,
    (ASN1FreeFun_t) ASN1Free_ContentReference,
    (ASN1FreeFun_t) ASN1Free_EquivalentLabels,
    (ASN1FreeFun_t) ASN1Free_MLExpansionHistory,
    (ASN1FreeFun_t) ASN1Free_SigningCertificate,
    (ASN1FreeFun_t) ASN1Free_SMimeEncryptCerts,
    (ASN1FreeFun_t) ASN1Free_ReceiptRequest,
    (ASN1FreeFun_t) ASN1Free_SMIMEEncryptionKeyPreference,
    (ASN1FreeFun_t) ASN1Free_ESSSecurityLabel,
};
static const ULONG sizetab[10] = {
    SIZE_ESS_Module_PDU_0,
    SIZE_ESS_Module_PDU_1,
    SIZE_ESS_Module_PDU_2,
    SIZE_ESS_Module_PDU_3,
    SIZE_ESS_Module_PDU_4,
    SIZE_ESS_Module_PDU_5,
    SIZE_ESS_Module_PDU_6,
    SIZE_ESS_Module_PDU_7,
    SIZE_ESS_Module_PDU_8,
    SIZE_ESS_Module_PDU_9,
};

/* forward declarations of values: */
extern ASN1uint32_t id_aa_receiptRequest_elems[9];
extern ASN1uint32_t id_aa_contentIdentifier_elems[9];
extern ASN1uint32_t id_ct_receipt_elems[9];
extern ASN1uint32_t id_aa_contentHint_elems[9];
extern ASN1uint32_t id_aa_msgSigDigest_elems[9];
extern ASN1uint32_t id_aa_contentReference_elems[9];
extern ASN1uint32_t id_aa_securityLabel_elems[9];
extern ASN1uint32_t id_aa_equivalentLabels_elems[9];
extern ASN1uint32_t id_aa_mlExpandHistory_elems[9];
extern ASN1uint32_t id_aa_signingCertificate_elems[9];
/* definitions of value components: */
static const struct ASN1objectidentifier_s id_aa_receiptRequest_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_receiptRequest_list[8]), 2 },
    { NULL, 1 }
};
static const struct ASN1objectidentifier_s id_aa_contentIdentifier_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_contentIdentifier_list[8]), 2 },
    { NULL, 7 }
};
static const struct ASN1objectidentifier_s id_ct_receipt_list[9] = {
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_ct_receipt_list[8]), 1 },
    { NULL, 1 }
};
static const struct ASN1objectidentifier_s id_aa_contentHint_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_contentHint_list[8]), 2 },
    { NULL, 4 }
};
static const struct ASN1objectidentifier_s id_aa_msgSigDigest_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_msgSigDigest_list[8]), 2 },
    { NULL, 5 }
};
static const struct ASN1objectidentifier_s id_aa_contentReference_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_contentReference_list[8]), 2 },
    { NULL, 10 }
};
static const struct ASN1objectidentifier_s id_aa_securityLabel_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_securityLabel_list[8]), 2 },
    { NULL, 2 }
};
static const struct ASN1objectidentifier_s id_aa_equivalentLabels_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_equivalentLabels_list[8]), 2 },
    { NULL, 9 }
};
static const struct ASN1objectidentifier_s id_aa_mlExpandHistory_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_mlExpandHistory_list[8]), 2 },
    { NULL, 3 }
};
static const struct ASN1objectidentifier_s id_aa_signingCertificate_list[9] = {
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[1]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[2]), 2 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[3]), 840 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[4]), 113549 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[5]), 1 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[6]), 9 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[7]), 16 },
    { (ASN1objectidentifier_t) &(id_aa_signingCertificate_list[8]), 2 },
    { NULL, 12 }
};
/* definitions of values: */
ASN1int32_t ub_receiptsTo = 16;
ASN1objectidentifier_t id_aa_receiptRequest = (ASN1objectidentifier_t) id_aa_receiptRequest_list;
ASN1objectidentifier_t id_aa_contentIdentifier = (ASN1objectidentifier_t) id_aa_contentIdentifier_list;
ASN1objectidentifier_t id_ct_receipt = (ASN1objectidentifier_t) id_ct_receipt_list;
ASN1objectidentifier_t id_aa_contentHint = (ASN1objectidentifier_t) id_aa_contentHint_list;
ASN1objectidentifier_t id_aa_msgSigDigest = (ASN1objectidentifier_t) id_aa_msgSigDigest_list;
ASN1objectidentifier_t id_aa_contentReference = (ASN1objectidentifier_t) id_aa_contentReference_list;
ASN1objectidentifier_t id_aa_securityLabel = (ASN1objectidentifier_t) id_aa_securityLabel_list;
ASN1int32_t ub_integer_options = 256;
ASN1int32_t ub_privacy_mark_length = 128;
ASN1int32_t ub_security_categories = 64;
ASN1objectidentifier_t id_aa_equivalentLabels = (ASN1objectidentifier_t) id_aa_equivalentLabels_list;
ASN1objectidentifier_t id_aa_mlExpandHistory = (ASN1objectidentifier_t) id_aa_mlExpandHistory_list;
ASN1int32_t ub_ml_expansion_history = 64;
ASN1objectidentifier_t id_aa_signingCertificate = (ASN1objectidentifier_t) id_aa_signingCertificate_list;

void ASN1CALL ESS_Module_Startup(void)
{
    if (ESS_Module == NULL) {
        ESS_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 10, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x737365);
    }
}

void ASN1CALL ESS_Module_Cleanup(void)
{
    ASN1_CloseModule(ESS_Module);
    ESS_Module = NULL;
}

static int ASN1CALL ASN1Enc_SigningCertificate_policies(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_policies *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SigningCertificate_policies(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_policies *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        PolicyInformation *value = (PolicyInformation *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;     
        else
            return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SigningCertificate_policies(SigningCertificate_policies *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_SigningCertificate_certs(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate_certs *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ESSCertID(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SigningCertificate_certs(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate_certs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        ESSCertID * value = (ESSCertID *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if (value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_ESSCertID(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SigningCertificate_certs(SigningCertificate_certs *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_ESSCertID(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_MLReceiptPolicy_inAdditionTo(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000002, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLReceiptPolicy_inAdditionTo(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_inAdditionTo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000002, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames *value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
	    if (value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLReceiptPolicy_inAdditionTo(MLReceiptPolicy_inAdditionTo *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_MLReceiptPolicy_insteadOf(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLReceiptPolicy_insteadOf(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy_insteadOf *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames *value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLReceiptPolicy_insteadOf(MLReceiptPolicy_insteadOf *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_ReceiptsFrom_receiptList(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom_receiptList *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000001, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptsFrom_receiptList(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom_receiptList *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000001, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames *value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptsFrom_receiptList(ReceiptsFrom_receiptList *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_ReceiptRequest_receiptsTo(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptRequest_receiptsTo(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest_receiptsTo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        GeneralNames * value = (GeneralNames *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptRequest_receiptsTo(ReceiptRequest_receiptsTo *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val)
{
    ASN1intx_free(&(val)->serialNumber);
}

static int ASN1CALL ASN1Enc_ReceiptsFrom(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptsFrom *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncS32(enc, 0x80000000, (val)->u.allOrFirstTier))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ReceiptsFrom_receiptList(enc, 0, &(val)->u.receiptList))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptsFrom(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptsFrom *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecS32Val(dec, 0x80000000, &(val)->u.allOrFirstTier))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_ReceiptsFrom_receiptList(dec, 0, &(val)->u.receiptList))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptsFrom(ReceiptsFrom *val)
{
    switch ((val)->choice) {
    case 2:
        ASN1Free_ReceiptsFrom_receiptList(&(val)->u.receiptList);
        break;
    }
}

static int ASN1CALL ASN1Enc_Receipt(ASN1encoding_t enc, ASN1uint32_t tag, Receipt *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signedContentIdentifier).length, ((val)->signedContentIdentifier).value))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->originatorSignatureValue).length, ((val)->originatorSignatureValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Receipt(ASN1decoding_t dec, ASN1uint32_t tag, Receipt *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->signedContentIdentifier))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->originatorSignatureValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Receipt(Receipt *val)
{
    ASN1octetstring_free(&(val)->signedContentIdentifier);
}

static int ASN1CALL ASN1Enc_ContentHints(ASN1encoding_t enc, ASN1uint32_t tag, ContentHints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->contentDescription).length, ((val)->contentDescription).value))
	    return 0;
    }
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentHints(ASN1decoding_t dec, ASN1uint32_t tag, ContentHints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0xc) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecUTF8String(dd, 0xc, &(val)->contentDescription))
	    return 0;
    }
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentHints(ContentHints *val)
{
    if ((val)->o[0] & 0x80) {
        ASN1utf8string_free(&(val)->contentDescription);
    }
}

static int ASN1CALL ASN1Enc_ContentReference(ASN1encoding_t enc, ASN1uint32_t tag, ContentReference *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signedContentIdentifier).length, ((val)->signedContentIdentifier).value))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->originatorSignatureValue).length, ((val)->originatorSignatureValue).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentReference(ASN1decoding_t dec, ASN1uint32_t tag, ContentReference *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->signedContentIdentifier))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->originatorSignatureValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentReference(ContentReference *val)
{
    ASN1octetstring_free(&(val)->signedContentIdentifier);
    ASN1octetstring_free(&(val)->originatorSignatureValue);
}

static int ASN1CALL ASN1Enc_ESSPrivacyMark(ASN1encoding_t enc, ASN1uint32_t tag, ESSPrivacyMark *val)
{
    ASN1uint32_t t;
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->u.utf8String).length, ((val)->u.utf8String).value))
	    return 0;
	break;
    case 2:
	t = lstrlenA((val)->u.pString);
	if (!ASN1DEREncCharString(enc, 0x13, t, (val)->u.pString))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ESSPrivacyMark(ASN1decoding_t dec, ASN1uint32_t tag, ESSPrivacyMark *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0xc:
	(val)->choice = 1;
	if (!ASN1BERDecUTF8String(dec, 0xc, &(val)->u.utf8String))
	    return 0;
	break;
    case 0x13:
	(val)->choice = 2;
	if (!ASN1BERDecZeroCharString(dec, 0x13, &(val)->u.pString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ESSPrivacyMark(ESSPrivacyMark *val)
{
    switch ((val)->choice) {
    case 1:
        ASN1utf8string_free(&(val)->u.utf8String);
        break;
    case 2:
        ASN1ztcharstring_free((val)->u.pString);
        break;
    }
}

static int ASN1CALL ASN1Enc_SecurityCategories(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategories *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SecurityCategory(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCategories(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategories *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        SecurityCategory *value = (SecurityCategory *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1Dec_SecurityCategory(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCategories(SecurityCategories *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_SecurityCategory(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_SecurityCategory(ASN1encoding_t enc, ASN1uint32_t tag, SecurityCategory *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x80000000, &(val)->type))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecurityCategory(ASN1decoding_t dec, ASN1uint32_t tag, SecurityCategory *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x80000000, &(val)->type))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType2(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecurityCategory(SecurityCategory *val)
{
}

static int ASN1CALL ASN1Enc_EquivalentLabels(ASN1encoding_t enc, ASN1uint32_t tag, EquivalentLabels *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ESSSecurityLabel(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EquivalentLabels(ASN1decoding_t dec, ASN1uint32_t tag, EquivalentLabels *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        ESSSecurityLabel *value = (ESSSecurityLabel *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
		    return 0;
	}
	if (!ASN1Dec_ESSSecurityLabel(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EquivalentLabels(EquivalentLabels *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_ESSSecurityLabel(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_MLExpansionHistory(ASN1encoding_t enc, ASN1uint32_t tag, MLExpansionHistory *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_MLData(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLExpansionHistory(ASN1decoding_t dec, ASN1uint32_t tag, MLExpansionHistory *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        MLData *value = (MLData *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_MLData(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLExpansionHistory(MLExpansionHistory *val)
{
    ASN1uint32_t i;
    for (i = 0; i < (val)->count; i++) {
	ASN1Free_MLData(&(val)->value[i]);
    }
    if ((val)->count)
	ASN1Free((val)->value);
}

static int ASN1CALL ASN1Enc_EntityIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EntityIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EntityIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EntityIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x4:
	(val)->choice = 1;
	if (!ASN1BERDecOctetString2(dec, 0x4, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    case 0x10:
	(val)->choice = 2;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EntityIdentifier(EntityIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
        break;
    case 2:
        ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
        break;
    }
}

static int ASN1CALL ASN1Enc_MLReceiptPolicy(ASN1encoding_t enc, ASN1uint32_t tag, MLReceiptPolicy *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncNull(enc, 0x80000000))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_MLReceiptPolicy_insteadOf(enc, 0, &(val)->u.insteadOf))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MLReceiptPolicy_inAdditionTo(enc, 0, &(val)->u.inAdditionTo))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MLReceiptPolicy(ASN1decoding_t dec, ASN1uint32_t tag, MLReceiptPolicy *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecNull(dec, 0x80000000))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_MLReceiptPolicy_insteadOf(dec, 0, &(val)->u.insteadOf))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1Dec_MLReceiptPolicy_inAdditionTo(dec, 0, &(val)->u.inAdditionTo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MLReceiptPolicy(MLReceiptPolicy *val)
{
    switch ((val)->choice) {
    case 2:
        ASN1Free_MLReceiptPolicy_insteadOf(&(val)->u.insteadOf);
        break;
    case 3:
        ASN1Free_MLReceiptPolicy_inAdditionTo(&(val)->u.inAdditionTo);
        break;
    }
}

static int ASN1CALL ASN1Enc_SigningCertificate(ASN1encoding_t enc, ASN1uint32_t tag, SigningCertificate *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_SigningCertificate_certs(enc, 0, &(val)->certs))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SigningCertificate_policies(enc, 0, &(val)->policies))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SigningCertificate(ASN1decoding_t dec, ASN1uint32_t tag, SigningCertificate *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_SigningCertificate_certs(dd, 0, &(val)->certs))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_SigningCertificate_policies(dd, 0, &(val)->policies))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SigningCertificate(SigningCertificate *val)
{
    ASN1Free_SigningCertificate_certs(&(val)->certs);
    if ((val)->o[0] & 0x80) {
        ASN1Free_SigningCertificate_policies(&(val)->policies);
    }
}

static int ASN1CALL ASN1Enc_ESSCertID(ASN1encoding_t enc, ASN1uint32_t tag, ESSCertID *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->certHash).length, ((val)->certHash).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->issuerSerial))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ESSCertID(ASN1decoding_t dec, ASN1uint32_t tag, ESSCertID *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->certHash))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_IssuerAndSerialNumber(dd, 0, &(val)->issuerSerial))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ESSCertID(ESSCertID *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->certHash);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_IssuerAndSerialNumber(&(val)->issuerSerial);
	}
    }
}

static int ASN1CALL ASN1Enc_SMimeEncryptCerts(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCerts *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SMimeEncryptCert(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMimeEncryptCerts(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCerts *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        SMimeEncryptCert *value = (SMimeEncryptCert *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_SMimeEncryptCert(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMimeEncryptCerts(SMimeEncryptCerts *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SMimeEncryptCert(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SMimeEncryptCert(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SMIMECapabilities(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SMIMECapability(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapabilities(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapabilities *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
        SMIMECapability *value = (SMIMECapability *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value));
        if(value)
            val->value = value;
        else
            return 0;
	}
	if (!ASN1Dec_SMIMECapability(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapabilities(SMIMECapabilities *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SMIMECapability(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SMIMECapability(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SMIMECapability(ASN1encoding_t enc, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->capabilityID))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMECapability(ASN1decoding_t dec, ASN1uint32_t tag, SMIMECapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->capabilityID))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMIMECapability(SMIMECapability *val)
{
    if ((val)->o[0] & 0x80) {
        //        ASN1open_free(&(val)->parameters);
    }
}

static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->keyAttrId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->keyAttrId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val)
{
    if ((val)->o[0] & 0x80) {
        //        ASN1open_free(&(val)->keyAttr);
    }
}

static int ASN1CALL ASN1Enc_ReceiptRequest(ASN1encoding_t enc, ASN1uint32_t tag, ReceiptRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->signedContentIdentifier).length, ((val)->signedContentIdentifier).value))
	return 0;
    if (!ASN1Enc_ReceiptsFrom(enc, 0, &(val)->receiptsFrom))
	return 0;
    if (!ASN1Enc_ReceiptRequest_receiptsTo(enc, 0, &(val)->receiptsTo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReceiptRequest(ASN1decoding_t dec, ASN1uint32_t tag, ReceiptRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->signedContentIdentifier))
	return 0;
    if (!ASN1Dec_ReceiptsFrom(dd, 0, &(val)->receiptsFrom))
	return 0;
    if (!ASN1Dec_ReceiptRequest_receiptsTo(dd, 0, &(val)->receiptsTo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReceiptRequest(ReceiptRequest *val)
{
    ASN1octetstring_free(&(val)->signedContentIdentifier);
    ASN1Free_ReceiptsFrom(&(val)->receiptsFrom);
    ASN1Free_ReceiptRequest_receiptsTo(&(val)->receiptsTo);
}

static int ASN1CALL ASN1Enc_ESSSecurityLabel(ASN1encoding_t enc, ASN1uint32_t tag, ESSSecurityLabel *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x2, (val)->security_classification))
	    return 0;
    }
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->security_policy_identifier))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ESSPrivacyMark(enc, 0, &(val)->privacy_mark))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_SecurityCategories(enc, 0, &(val)->security_categories))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ESSSecurityLabel(ASN1decoding_t dec, ASN1uint32_t tag, ESSSecurityLabel *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	switch (t) {
	case 0x2:
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecU16Val(dd, 0x2, &(val)->security_classification))
		return 0;
	    break;
	case 0x6:
	    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->security_policy_identifier))
		return 0;
	    break;
	case 0x13:
        case 0x0c:
	    (val)->o[0] |= 0x40;
	    if (!ASN1Dec_ESSPrivacyMark(dd, 0, &(val)->privacy_mark))
		return 0;
	    break;
	case 0x11:
	    (val)->o[0] |= 0x20;
	    if (!ASN1Dec_SecurityCategories(dd, 0, &(val)->security_categories))
		return 0;
	    break;
	default:
	    ASN1DecSetError(dd, ASN1_ERR_CORRUPT);
	    return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ESSSecurityLabel(ESSSecurityLabel *val)
{
    if ((val)->o[0] & 0x40) {
        ASN1Free_ESSPrivacyMark(&(val)->privacy_mark);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_SecurityCategories(&(val)->security_categories);
    }
}

static int ASN1CALL ASN1Enc_MLData(ASN1encoding_t enc, ASN1uint32_t tag, MLData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EntityIdentifier(enc, 0, &(val)->mailListIdentifier))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->expansionTime))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MLReceiptPolicy(enc, 0, &(val)->mlReceiptPolicy))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MLData(ASN1decoding_t dec, ASN1uint32_t tag, MLData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_EntityIdentifier(dd, 0, &(val)->mailListIdentifier))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->expansionTime))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000 || t == 0x80000001 || t == 0x80000002) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_MLReceiptPolicy(dd, 0, &(val)->mlReceiptPolicy))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MLData(MLData *val)
{
    ASN1Free_EntityIdentifier(&(val)->mailListIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_MLReceiptPolicy(&(val)->mlReceiptPolicy);
    }
}

static int ASN1CALL ASN1Enc_SMimeEncryptCert(ASN1encoding_t enc, ASN1uint32_t tag, SMimeEncryptCert *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->hash).length, ((val)->hash).value))
	return 0;
    if (!ASN1Enc_SMIMECapabilities(enc, 0, &(val)->capabilities))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SMimeEncryptCert(ASN1decoding_t dec, ASN1uint32_t tag, SMimeEncryptCert *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->hash))
	return 0;
    if (!ASN1Dec_SMIMECapabilities(dd, 0, &(val)->capabilities))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SMimeEncryptCert(SMimeEncryptCert *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->hash);
	ASN1Free_SMIMECapabilities(&(val)->capabilities);
    }
}

static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectKeyIdentifier).length, ((val)->subjectKeyIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->subjectKeyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->subjectKeyIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_SMIMEEncryptionKeyPreference(ASN1encoding_t enc, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0x80000000, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RecipientKeyIdentifier(enc, 0x80000001, &(val)->u.recipientKeyId))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncOctetString(enc, 0x80000002, ((val)->u.subjectAltKeyIdentifier).length, ((val)->u.subjectAltKeyIdentifier).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SMIMEEncryptionKeyPreference(ASN1decoding_t dec, ASN1uint32_t tag, SMIMEEncryptionKeyPreference *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0x80000000, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_RecipientKeyIdentifier(dec, 0x80000001, &(val)->u.recipientKeyId))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecOctetString(dec, 0x80000002, &(val)->u.subjectAltKeyIdentifier))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SMIMEEncryptionKeyPreference(SMIMEEncryptionKeyPreference *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1Free_RecipientKeyIdentifier(&(val)->u.recipientKeyId);
	    break;
	case 3:
	    ASN1octetstring_free(&(val)->u.subjectAltKeyIdentifier);
	    break;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\essmime.cpp ===
#ifdef SMIME_V3
#include <windows.h>
#include <mimeole.h>
#include <essout.h>

#include        "demand.h"
#include        "crypttls.h"
#include        "demand2.h"

extern CRYPT_DECODE_PARA       CryptDecodeAlloc;
#define szOID_MSFT_ATTR_SEQUENCE        "1.3.6.1.4.1.311.16.1.1"

/////////////////////////////////////////////////////////////////////////

typedef struct {
    DWORD               cNames;
    CERT_NAME_BLOB *    rgNames;
} ReceiptNames;

HRESULT SetNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD       cb;
    DWORD       i;
    LPBYTE      pb;
    
    if (pnames->rgNames != NULL) {
        free(pnames->rgNames);
        pnames->rgNames = NULL;
        pnames->cNames = 0;
    }

    for (i=0, cb=cNames*sizeof(CERT_NAME_BLOB); i<cNames; i++) {
        cb += rgNames[i].cbData;
    }

    pnames->rgNames = (CERT_NAME_BLOB *) malloc(cb);
    if (pnames->rgNames == NULL) {
        return E_OUTOFMEMORY;
    }

    pb = (LPBYTE) &pnames->rgNames[cNames];
    for (i=0; i<cNames; i++) {
        pnames->rgNames[i].pbData = pb;
        pnames->rgNames[i].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
        pb += rgNames[i].cbData;
    }

    pnames->cNames = cNames;
    return S_OK;
}

HRESULT MergeNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD               cb;
    DWORD               i;
    DWORD               i1;
    LPBYTE              pb;
    CERT_NAME_BLOB *    p;

    for (i=0, cb=0; i<pnames->cNames; i++) {
        cb += pnames->rgNames[i].cbData;
    }

    for (i=0; i<cNames; i++) {
        cb += rgNames[i].cbData;
    }

    p = (CERT_NAME_BLOB *) malloc(cb + (pnames->cNames + cNames) * 
                                  sizeof(CERT_NAME_BLOB));
    if (p == NULL) {
        return E_OUTOFMEMORY;
    }

    pb = (LPBYTE) &p[pnames->cNames + cNames];
    for (i=0, i1=0; i<pnames->cNames; i++, i1++) {
        p[i1].pbData = pb;
        p[i1].cbData = pnames->rgNames[i].cbData;
        memcpy(pb, pnames->rgNames[i].pbData, pnames->rgNames[i].cbData);
        pb += pnames->rgNames[i].cbData;
    }

    for (i=0; i<pnames->cNames; i++, i1++) {
        p[i1].pbData = pb;
        p[i1].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
        pb += rgNames[i].cbData;
    }

    free(pnames->rgNames);
    pnames->rgNames = p;
    pnames->cNames = i1;
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////

MIMEOLEAPI MimeOleCreateReceipt(IMimeMessage * pMsgSrc, PCX509CERT pCertToSign, 
                                HWND hwndDlg, IMimeMessage ** ppMessage,
                                const CERT_ALT_NAME_INFO * pMyNames)
{
    DWORD                       cb;
    DWORD                       cLayers;
    DWORD                       dwReceiptsFrom;
    BOOL                        fSkipAddress = FALSE;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       i1;
    DWORD                       i2;
    DWORD                       iAttr;
    DWORD                       iLayer;
    PCRYPT_ATTRIBUTES           pattrs = NULL;
    IMimeBody *                 pbody = NULL;
    LPBYTE                      pbReceiptReq = NULL;
    IMimeAddressTable *         pmatbl = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeMessage *              pmm = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    LPSTREAM                    pstm = NULL;
    ReceiptNames          receiptsTo = {0, NULL};
    PROPVARIANT *               rgpvAuthAttr = NULL;
    PROPVARIANT                 var;

    //
    //  Get the Layer Count
    //  Get the Authenticated Attributes
    //  Decode Receipt Request
    //  Set ReceiptsFrom from the request
    //  For Each layer
    //          is mlExpansion in this layer? No -- Skip to next layer
    //          Receipt for First Tier only? Yes - return S_FALSE
    //          Policy override on mlExpansion?
    //              None - return S_FALSE
    //              insteadOf - set ReceiptsFrom from mlExpansion History
    //              inAdditionTo - add to ReceiptsFrom
    //  Is my name in ReceiptsFrom list? No -- return S_FALSE
    //  Setup new IMimeMessage
    //  Attach receipt body
    //  Address from Receipt Request
    //  return S_OK

    //  Obtain the body of the message

    hr = pMsgSrc->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pbody);
    if (FAILED(hr)) {
        goto CommonExit;
    }
    
    // Get the set of authenticated attributes on all layers of S/MIME in the
    //  message.

    hr = pbody->GetOption(OID_SECURITY_SIGNATURE_COUNT, &var);
    if (FAILED(hr)) {
        goto GeneralFail;
    }
    cLayers = var.ulVal;

    hr = pbody->GetOption(OID_SECURITY_AUTHATTR_RG, &var);
    if (FAILED(hr)) {
        goto CommonExit;
    }
    rgpvAuthAttr = var.capropvar.pElems;

    //  Create a stream object to hold the receipt and put the receipt into the
    //  stream -- this supplies the body of the receipt message.

    hr = MimeOleCreateVirtualStream(&pstm);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pbody->GetOption(OID_SECURITY_RECEIPT, &var);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pstm->Write(var.blob.pBlobData, var.blob.cbSize, NULL);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    //
    //  Walk through each layer of authenticated attributes processing the
    //  two relevant attributes.
    //
    
    for (iLayer=0; iLayer<cLayers; iLayer++) {
        if (rgpvAuthAttr[iLayer].blob.cbSize == 0) {
            continue;
        }

        //
        //  Decode the attributes at this layer of S/MIME
        //

        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_MSFT_ATTR_SEQUENCE,
                                 rgpvAuthAttr[iLayer].blob.pBlobData, 
                                 rgpvAuthAttr[iLayer].blob.cbSize, 
                                 CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                                 &pattrs, &cb)) {
            goto GeneralFail;
        }

        //
        //  Walk through each attribute looking for
        //      if innermost layer - the receipt request
        //      else - a Mail List expansion history
        //
        
        for (iAttr=0; iAttr<pattrs->cAttr; iAttr++) {
            if (iLayer==0) {
                if (strcmp(pattrs->rgAttr[iAttr].pszObjId,
                           szOID_SMIME_Receipt_Request) == 0) {
                    //
                    // Crack the contents of the receipt request
                    //
                
                    if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                             szOID_SMIME_Receipt_Request,
                                             pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                             pattrs->rgAttr[iAttr].rgValue[0].cbData,
                                             CRYPT_DECODE_ALLOC_FLAG,
                                             &CryptDecodeAlloc, &preq, &cb)) {
                        goto GeneralFail;
                    }

                    //
                    //  Initialize the ReceiptsTo list
                    //

                    if (preq->cReceiptsTo != 0) {
                        SetNames(&receiptsTo, preq->cReceiptsTo, preq->rgReceiptsTo);
                    }

                    //  Who are receipts from?
                
                    dwReceiptsFrom = preq->ReceiptsFrom.AllOrFirstTier;
                }
                else if (strcmp(pattrs->rgAttr[iAttr].pszObjId,
                                szOID_RSA_messageDigest) == 0) {
                    ;
                }
            }
            else if ((iLayer != 0) && (strcmp(pattrs->rgAttr[iAttr].pszObjId,
                                              szOID_SMIME_MLExpansion_History) == 0)) {
                //
                //  If receipts are from first tier only and we see this attribute
                //      we are not first tier by definition.
                //
                
                if (dwReceiptsFrom == SMIME_RECEIPTS_FROM_FIRST_TIER) {
                    hr = S_FALSE;
                    goto CommonExit;
                }

                PSMIME_ML_EXPANSION_HISTORY     pmlhist = NULL;
                
                //
                //  Crack the attribute
                //
                
                if (!CryptDecodeObjectEx(X509_ASN_ENCODING, 
                                         szOID_SMIME_MLExpansion_History,
                                         pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                         pattrs->rgAttr[iAttr].rgValue[0].cbData,
                                         CRYPT_ENCODE_ALLOC_FLAG,
                                         &CryptDecodeAlloc, &pmlhist, &cb)) {
                    goto GeneralFail;
                }

                PSMIME_MLDATA     pMLData = &pmlhist->rgMLData[pmlhist->cMLData-1];

                switch( pMLData->dwPolicy) {
                    //  No receipt is to be returned
                case SMIME_MLPOLICY_NONE:
                    hr = S_FALSE;
                    free(pmlhist);
                    goto CommonExit;

                    //  Return receipt to a new list
                case SMIME_MLPOLICY_INSTEAD_OF:
                    SetNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;
                        
                case SMIME_MLPOLICY_IN_ADDITION_TO:
                    MergeNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;

                case SMIME_MLPOLICY_NO_CHANGE:
                    break;
                        
                default:
                    free(pmlhist);
                    goto GeneralFail;
                }

                free(pmlhist);
                break;
            }
        }

        free(pattrs);
        pattrs = NULL;
    }

    //
    //  Am I on the ReceiptsFrom List --
    //
    
    if (preq->ReceiptsFrom.cNames != 0) {
        BOOL    fFoundMe = FALSE;
        
        for (i=0; !fFoundMe && (i<preq->ReceiptsFrom.cNames); i++) {
            CERT_ALT_NAME_INFO *    pname = NULL;

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                     preq->ReceiptsFrom.rgNames[i].pbData,
                                     preq->ReceiptsFrom.rgNames[i].cbData,
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptDecodeAlloc, &pname, &cb)) {
                goto GeneralFail;
            }

            for (i1=0; i1<pname->cAltEntry; i1++) {
                for (i2=0; i2<pMyNames->cAltEntry; i2++) {
                    if (pname->rgAltEntry[i1].dwAltNameChoice !=
                        pMyNames->rgAltEntry[i1].dwAltNameChoice) {
                        continue;
                    }
                    
                    switch (pname->rgAltEntry[i1].dwAltNameChoice) {
                    case CERT_ALT_NAME_RFC822_NAME:
                        if (lstrcmpW(pname->rgAltEntry[i1].pwszRfc822Name,
                                    pMyNames->rgAltEntry[i1].pwszRfc822Name) == 0) {
                            fFoundMe = TRUE;
                            goto FoundMe;
                        }
                    }
                }
            }

        FoundMe:
            free(pname);
        }

        if (!fFoundMe) {
            hr = S_FALSE;
            goto CommonExit;
        }
    }

    hr = MimeOleCreateMessage(NULL, &pmm);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    hr = pmb->SetData(IET_BINARY, "OID", szOID_SMIME_ContentType_Receipt,
                      IID_IStream, pstm);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    //
    //  Address the receipt back to the receipients
    //

    hr = pmm->GetAddressTable(&pmatbl);
    if (FAILED(hr)) {
        goto CommonExit;
    }

    for (i=0; i<receiptsTo.cNames; i++) {
        CERT_ALT_NAME_INFO *    pname = NULL;
        
        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                 receiptsTo.rgNames[i].pbData,
                                 receiptsTo.rgNames[i].cbData,
                                 CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptDecodeAlloc, &pname, &cb)) {
            goto GeneralFail;
        }

        for (i1=0; i1<pname->cAltEntry; i1++) {
            char        cch;
            char        rgch[256];
            
            if (pname->rgAltEntry[i1].dwAltNameChoice == CERT_ALT_NAME_RFC822_NAME) {
                cch = WideCharToMultiByte(CP_ACP, 0,
                                          pname->rgAltEntry[i1].pwszRfc822Name,
                                          -1, rgch, sizeof(rgch), NULL, NULL);
                if (cch > 0) {
                    hr = pmatbl->AppendRfc822(IAT_TO, IET_UNICODE,
                                              rgch);
                    if (FAILED(hr)) {
                        goto CommonExit;
                    }
                }
                break;
            }
        }

        if (i1 == pname->cAltEntry) {
            fSkipAddress = TRUE;
        }
    }

#ifdef DEBUG
    {
        LPSTREAM        pstmTmp = NULL;
        hr = MimeOleCreateVirtualStream(&pstmTmp);
        pmm->Save(pstmTmp, TRUE);
        pstmTmp->Release();
    }
#endif // DEBUG

    hr = S_OK;
    *ppMessage = pmm;
    pmm->AddRef();
    
CommonExit:
    CoTaskMemFree(var.blob.pBlobData);
    if (preq != NULL)           free(preq);
    if (pbReceiptReq != NULL)   CoTaskMemFree(pbReceiptReq);
    if (rgpvAuthAttr != NULL)   CoTaskMemFree(rgpvAuthAttr);
    if (pattrs != NULL)         free(pattrs);
    if (pstm != NULL)           pstm->Release();
    if (pmatbl != NULL)         pmatbl->Release();
    if (pmb != NULL)            pmb->Release();
    if (pmm != NULL)            pmm->Release();
    if (pbody != NULL)          pbody->Release();
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto CommonExit;
}
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\essout.h ===
///////////////////////////////////////////////////////////////////////////


typedef interface ISMimePolicy ISMimePolicy;

#define SMIME_POLICY_EDIT_UI            0x00000001

EXTERN_C const IID IID_ISMimePolicy;
MIDL_INTERFACE("744dffc0-63f4-11d2-8a52-0080c76b34c6")
ISMimePolicy : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE GetInfo(
             /* OUT */ DWORD * pdwFlags,
             /* OUT */ DWORD * pcClassifications) = 0;
    virtual HRESULT STDMETHODCALLTYPE EnumClassifications(
             /* OUT */ LPWSTR  rgwch,
             /* OUT */ DWORD * pcb, 
             /* OUT */ DWORD * dwValue,
             /* IN  */ DWORD i) = 0;
    virtual HRESULT STDMETHODCALLTYPE EditUI(
             /* IN     */  HWND hwnd,
             /* IN/OUT */  DWORD * pdwClassification,
             /* IN/OUT */  LPWSTR * pwszPrivacyMark,
             /* IN/OUT */  LPBYTE * ppbLabel,
             /* IN/OUT */  DWORD  * pcbLabel) = 0;
   virtual HRESULT STDMETHODCALLTYPE CheckEdits(
             /* IN */     HWND hwnd,
             /* IN */     DWORD dwClassification,
             /* IN */     LPCWSTR wszPrivacyLabel,
             /* IN/OUT */ LPBYTE * ppbLabel,
             /* IN/OUT */ DWORD *  pcbLabel) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\ossconv.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossconv.cpp
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  Functions:  OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//              OssConvToAttribute
//              OssConvToAlgorithmIdentifier
//              OssConvFromAlgorithmIdentifier
//
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-04.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//              03-May-96   kevinr  merged from wincrmsg
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//  These are the old 4.0 versions of these routines.
#define atol StrToInt

char * __cdecl _ltoa(long l, char * psz, int) {wnsprintf(psz, 10, "%d", l); return psz; }

/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1951
#define YEARLAST                2050
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        unsigned short cMax = *pCount;
        unsigned long *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (unsigned long)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        unsigned long *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN short mindiff,
    IN ossBoolean utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = mindiff > 0 ? mindiff : -mindiff;
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        if (mindiff > 0)
            *((_int64 *) pFileTime) += *((_int64 *) &ftmDiff);
        else
            *((_int64 *) pFileTime) -= *((_int64 *) &ftmDiff);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pOssTime->year   = t.wYear % 100;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year > MAGICYEAR ?
                    (1900 + pOssTime->year) : (2000 + pOssTime->year);
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pOssTime->year   = t.wYear;
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->millisec = t.wMilliseconds;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pOssTime->year;
    t.wMonth  = pOssTime->month;
    t.wDay    = pOssTime->day;
    t.wHour   = pOssTime->hour;
    t.wMinute = pOssTime->minute;
    t.wSecond = pOssTime->second;
    t.wMilliseconds = pOssTime->millisec;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pOssTime->mindiff,
        pOssTime->utc
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pOssTime, 0, sizeof(*pOssTime));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = OSS_GENERALIZED_TIME_CHOICE;
        pOssTime->year   = t.wYear;
    } else {
        *pwChoice = OSS_UTC_TIME_CHOICE;
        pOssTime->year = t.wYear % 100;
    }
    pOssTime->month  = t.wMonth;
    pOssTime->day    = t.wDay;
    pOssTime->hour   = t.wHour;
    pOssTime->minute = t.wMinute;
    pOssTime->second = t.wSecond;
    pOssTime->utc    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    )
{
    if (OSS_UTC_TIME_CHOICE == wChoice)
        return OssConvFromUTCTime(pOssTime, pFileTime);
    else
        return OssConvFromGeneralizedTime(pOssTime, pFileTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\ossutil.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:       ossutil.cpp
//
//  Contents:   OSS ASN.1 compiler utility helper functions.
//
//  Functions:  OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilGetBitString
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfoEx
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#if 0 // JLS
//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)OssUtilAlloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}
#endif // 0 // JLS

//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssLength;
            pInfo->pbData = OssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) OssLength;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, OssValue, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

#if 0 // JLS
//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BUGBUG: BYTE reversal::
//   - this only needs to be done for little endian
//   - this needs to be fixed in the OSS compiler
//
//  For OssUtilSetInteger, OssUtilFreeInteger must be called to free
//  the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppOssValue = OssUtilAllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pOssLength = 0;
            return FALSE;
        }
    } else
        *ppOssValue = NULL;
    *pOssLength = pInfo->cbData;
    return TRUE;
}

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        )
{
    // Only for BYTE reversal
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    OssUtilGetOctetString(OssLength, pOssValue, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        OssUtilReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by OSS before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//  OssUtilFreeHugeUINT has been #define'd to OssUtilFreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) OssUtilAlloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pOssLength = cb;
    *ppOssValue = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (OssLength > 1 && *pOssValue == 0) {
        pOssValue++;
        OssLength--;
    }
    OssUtilGetHugeInteger(
        OssLength,
        pOssValue,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        )
{
    if (pInfo->cbData) {
        *ppOssValue = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pOssBitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppOssValue = NULL;
        *pOssBitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (OssBitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = OssBitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pOssValue;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) OssBitLength / 8;
        cUnusedBits = OssBitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pOssValue, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pOssLength = 0;
        *ppOssValue = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pOssLength = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) OssUtilAlloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppOssValue = psz;
    *pOssLength = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pOssLength = 0;
InvalidIA5:
    *ppOssValue = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        )
{
    OssUtilFree(pOssValue);
}

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pOssValue,
        OssLength,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pOssValue, OssLength,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) OssLength * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pOssValue, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}
#endif // 0 // JLS

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    pOss->encoded = pInfo->pbData;
    pOss->length = pInfo->cbData;
}

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pOss->length;
            pInfo->pbData = (BYTE *) pOss->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pOss->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pOss->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    DWORD cbEncoded;
    OssBuf OssEncoded;
    int OssStatus;
    unsigned char *value;

    if (NULL == pvEncoded || (dwFlags & CRYPT_ENCODE_ALLOC_FLAG))
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    OssEncoded.length = cbEncoded;
    if (cbEncoded == 0)
        value = NULL;
    else
        value = (unsigned char *) pvEncoded;
    OssEncoded.value = value;

    ossSetEncodingRules(Pog, OSS_DER);
    OssStatus = ossEncode(
        Pog,
        pdunum,
        pvOssInfo,
        &OssEncoded);
    cbEncoded = OssEncoded.length;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        PFN_CRYPT_ALLOC pfnAlloc;
        BYTE *pbEncoded;

        if (0 != OssStatus || 0 == cbEncoded) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OssError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            ossFreeBuf(Pog, OssEncoded.value);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbEncoded, OssEncoded.value, cbEncoded);
        *((BYTE **) pvEncoded) = pbEncoded;
        ossFreeBuf(Pog, OssEncoded.value);
        goto SuccessReturn;
    } else if (value == NULL && OssEncoded.value) {
        // Length only calculation with a throw away allocation
        ossFreeBuf(Pog, OssEncoded.value);
        if (pvEncoded && 0 == OssStatus) {
            // Upon entry *pcbEncoded == 0
            goto LengthError;
        }
    }

    if (0 != OssStatus) {
        // For MORE_BUF:: redo as a length only calculation
        if (OssStatus == MORE_BUF && pvEncoded &&
                OssUtilEncodeInfoEx(
                Pog,
                pdunum,
                pvOssInfo,
                0,                  // dwFlags
                NULL,               // pEncodePara
                NULL,               // pbEncoded
                &cbEncoded))
            goto LengthError;
        else {
            cbEncoded = 0;
            goto OssError;
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

#if 0 // JLS
//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        Pog,
        pdunum,
        pvOssInfo,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}
#endif // 0 // JLS


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        )
{
    BOOL fResult;
    OssBuf OssEncoded;
    int OssStatus;

    OssEncoded.length = cbEncoded;
    OssEncoded.value = (unsigned char *) pbEncoded;

    ossSetEncodingRules(Pog, OSS_BER);
    *ppvOssInfo = NULL;
    if (0 != (OssStatus = ossDecode(
                Pog,
                &pdunum,
                &OssEncoded,
                ppvOssInfo)))
        goto OssError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvOssInfo = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(OssError, CRYPT_E_OSS_ERROR + OssStatus)
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        )
{
    if (pvOssInfo) {
        ossFreePDU(Pog, pdunum, pvOssInfo);
    }
}

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvOssInfo,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvOssInfo,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvOssInfo = NULL;

    if (!OssUtilDecodeAndAllocInfo(
            Pog,
            pdunum,
            pbEncoded,
            cbEncoded,
            &pvOssInfo
            )) goto OssDecodeError;

    fResult = OssUtilAllocStructInfoEx(
        pvOssInfo,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    OssUtilFreeInfo(Pog, pdunum, pvOssInfo);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OssDecodeError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\pkialloc.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkialloc.cpp
//
//  Contents:   PKI Allocation Functions
//
//  Functions:  PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------
#ifdef SMIME_V3

#include <windows.h>
#include "pkialloc.h"
#include <dbgdef.h>

#ifndef offsetof
#define offsetof(a, b) ((size_t) &(((a *) 0)->b))
#endif

// This macro for _WIN64, but works for Win32 too
#define LOWDWORD(l) 		((DWORD)((DWORD_PTR) (l) & 0xffffffff))

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = malloc(cbBytes)))
#else
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}


// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;

#if DBG
    pv = malloc(cbBytes);
#else
    pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes);
#endif
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}


// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    else
        memset(pv, 0, cbBytes);
#else
    // LPTR (OR includes ZEROINIT)
    pv = (LPVOID) LocalAlloc(LPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
#endif
    return pv;
}

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    )
{
    LPVOID pv;
#if DBG
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
#else
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes)))
#endif
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    )
{
    if (pv)
#if DBG
        free(pv);
#else
        LocalFree((HLOCAL)pv);
#endif
}

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbSize)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL) pv);
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_ENCODE_PARA PkiEncodePara = {
    LOWDWORD(offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(PkiEncodePara.pfnFree)),
    (PFN_CRYPT_ALLOC) PkiNonzeroAlloc,
    PkiFree
};


//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
          		  pEncodePara->cbSize >= LOWDWORD(offsetof(CRYPT_ENCODE_PARA, pfnAlloc) +
                sizeof(pEncodePara->pfnAlloc)) &&
            pEncodePara->pfnAlloc)
        return pEncodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= LOWDWORD(offsetof(CRYPT_ENCODE_PARA, pfnFree) +
                sizeof(pEncodePara->pfnFree)) &&
            pEncodePara->pfnFree)
        return pEncodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_DECODE_PARA PkiDecodePara = {
   LOWDWORD(offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(PkiDecodePara.pfnFree)),
    (PFN_CRYPT_ALLOC) PkiNonzeroAlloc,
    PkiFree
};

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= LOWDWORD(offsetof(CRYPT_DECODE_PARA, pfnAlloc) +
                sizeof(pDecodePara->pfnAlloc)) &&
            pDecodePara->pfnAlloc)
        return pDecodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= LOWDWORD(offsetof(CRYPT_DECODE_PARA, pfnFree) +
                sizeof(pDecodePara->pfnFree)) &&
            pDecodePara->pfnFree)
        return pDecodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG

    extern int WINAPIV DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);

#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)


#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msber.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_BER_H__
#define __MS_BER_H__

#include <msasn1.h>

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncRemoveZeroBits(ASN1uint32_t *, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSkip(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
extern ASN1_PUBLIC int ASN1API ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t LengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed);
extern ASN1_PUBLIC int ASN1API ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut);
extern ASN1_PUBLIC int ASN1API ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal);
extern ASN1_PUBLIC void ASN1API ASN1BEREoid_free(ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val);

/* CER variant of BER */

extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t, ASN1utctime_t *);

extern ASN1_PUBLIC int ASN1API ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2);
extern ASN1_PUBLIC int ASN1API ASN1CEREncFlushBlkElement(void *pBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncEndBlk(void *pBlk);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *);

extern ASN1_PUBLIC int ASN1API ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *);

#ifdef __cplusplus
}
#endif

#endif // __MS_BER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\pkiasn1.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkiasn1.cpp
//
//  Contents:   PKI ASN.1 support functions.
//
//  Functions:  PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1Decode
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfoEx
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//
//  According to the <draft-ietf-pkix-ipki-part1-04.txt> :
//      For UTCTime. Where YY is greater than 50, the year shall
//      be interpreted as 19YY. Where YY is less than or equal to
//      50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------
#ifdef SMIME_V3
#include <windows.h>
#include "msasn1.h"
#include "msber.h"
#include "utf8.h"
#include "crypttls.h"

#include "demand2.h"
#include "pkiasn1.h"
//#include "pkialloc.h"
//#include "global.hxx"
#include <dbgdef.h>
#define assert(a)

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define MSASN1_SUPPORTS_NOCOPY

#define wcslen my_wcslen
extern int my_wcslen(LPCWSTR pwsz)
{
    int i = 0;
    while (*pwsz++ != 0) i += 1;
    return i;
}



//
// UTCTime in X.509 certs are represented using a 2-digit year
// field (yuk! but true).
//
// According to IETF draft, YY years greater than this are
// to be interpreted as 19YY; YY years less than this are 20YY. Sigh.
//
#define MAGICYEAR               50

#define YEARFIRST               1951
#define YEARLAST                2050
#define YEARFIRSTGENERALIZED    2050

inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    Asn1Err = ASN1_Encode(
        pEnc,
        pvAsn1Info,
        id,
        ASN1ENCODE_ALLOCATEBUFFER,
        NULL,                       // pbBuf
        0                           // cbBufSize
        );

    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded = pEnc->buf;
        *pcbEncoded = pEnc->len;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            if (pbEncoded)
                Asn1Err = ASN1_ERR_OVERFLOW;
            else
                Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
            PkiAsn1FreeEncoded(pEnc, pEnc->buf);
        }
    } else {
        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_SETBUFFER,
            pbEncoded,
            cbEncoded
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
        } else if (ASN1_ERR_OVERFLOW == Asn1Err) {
            // Re-do as length only calculation
            Asn1Err = PkiAsn1Encode2(
                pEnc,
                pvAsn1Info,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (ASN1_SUCCESS == Asn1Err)
                Asn1Err = ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        (BYTE *) pbEncoded,
        cbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err))
        Asn1Err = ASN1_SUCCESS;
    else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        *ppbEncoded,
        *pcbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded += pDec->len;
        *pcbEncoded -= pDec->len;
    } else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ASN1optionparam_s OptParam;

    OptParam.eOption = ASN1OPT_CHANGE_RULE;
    OptParam.eRule = eRule;

    return ASN1_SetEncoderOption(pEnc, &OptParam);
}

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ASN1error_e Asn1Err;
    ASN1encodingrule_e eRule;
    ASN1optionparam_s OptParam;
    OptParam.eOption = ASN1OPT_GET_RULE;

    Asn1Err = ASN1_GetEncoderOption(pEnc, &OptParam);
    if (ASN1_SUCCEEDED(Asn1Err))
        eRule = OptParam.eRule;
    else
        eRule = ASN1_BER_RULE_DER;

    return eRule;
}


//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            )
{
    PBYTE	pbOut;
    PBYTE	pbSrc;
    PBYTE	pbDst;
    DWORD	cb;

    if (NULL == (pbOut = (PBYTE)PkiAsn1Alloc(cbIn)))
        return NULL;

    for (pbSrc = pbIn, pbDst = pbOut + cbIn - 1, cb = cbIn; cb > 0; cb--)
        *pbDst-- = *pbSrc++;
    return pbOut;
}


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1Length;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) Asn1Length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1Value, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  For PkiAsn1SetHugeInteger, PkiAsn1FreeHugeInteger must be called to free
//  the allocated Asn1Value.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData > 0) {
        if (NULL == (*ppAsn1Value = PkiAsn1AllocAndReverseBytes(
                pInfo->pbData, pInfo->cbData))) {
            *pAsn1Length = 0;
            return FALSE;
        }
    } else
        *ppAsn1Value = NULL;
    *pAsn1Length = pInfo->cbData;
    return TRUE;
}

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        )
{
    // Only for BYTE reversal
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Since bytes need to be reversed, always need to do a copy (dwFlags = 0)
    PkiAsn1GetOctetString(Asn1Length, pAsn1Value, 0,
        pInfo, ppbExtra, plRemainExtra);
    if (*plRemainExtra >= 0 && pInfo->cbData > 0)
        PkiAsn1ReverseBytes(pInfo->pbData, pInfo->cbData);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing. Note, any extra leading
//  0x00's are removed by ASN1 before ASN.1 encoding.
//
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated Asn1Value.
//  PkiAsn1FreeHugeUINT has been #define'd to PkiAsn1FreeHugeInteger.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    BOOL fResult;
    DWORD cb = pInfo->cbData;
    BYTE *pb;
    DWORD i;

    if (cb > 0) {
        if (NULL == (pb = (BYTE *) PkiAsn1Alloc(cb + 1)))
            goto ErrorReturn;
        *pb = 0x00;
        for (i = 0; i < cb; i++)
            pb[1 + i] = pInfo->pbData[cb - 1 - i];
        cb++;
    } else
        pb = NULL;
    fResult = TRUE;
CommonReturn:
    *pAsn1Length = cb;
    *ppAsn1Value = pb;
    return fResult;
ErrorReturn:
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}


void
WINAPI
PkiAsn1GetHugeUINT(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    // Check for and advance past a leading 0x00.
    if (Asn1Length > 1 && *pAsn1Value == 0) {
        pAsn1Value++;
        Asn1Length--;
    }
    PkiAsn1GetHugeInteger(
        Asn1Length,
        pAsn1Value,
        dwFlags,
        pInfo,
        ppbExtra,
        plRemainExtra
        );
}

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        )
{
    if (pInfo->cbData) {
        *ppAsn1Value = pInfo->pbData;
        assert(pInfo->cUnusedBits <= 7);
        *pAsn1BitLength = pInfo->cbData * 8 - pInfo->cUnusedBits;
    } else {
        *ppAsn1Value = NULL;
        *pAsn1BitLength = 0;
    }
}

static const BYTE rgbUnusedAndMask[8] =
    {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG && 0 == (Asn1BitLength % 8)) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = Asn1BitLength / 8;
            pInfo->cUnusedBits = 0;
            pInfo->pbData = pAsn1Value;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
        DWORD cUnusedBits;
    
        lData = (LONG) Asn1BitLength / 8;
        cUnusedBits = Asn1BitLength % 8;
        if (cUnusedBits) {
            cUnusedBits = 8 - cUnusedBits;
            lData++;
        }
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                pInfo->cUnusedBits = cUnusedBits;
                memcpy(pbExtra, pAsn1Value, lData);
                if (cUnusedBits)
                    *(pbExtra + lData - 1) &= rgbUnusedAndMask[cUnusedBits];
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length;
    lAlignExtra = INFO_LEN_ALIGN(lData + 1);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        *(pbExtra + lData) = 0;
        *ppsz = (LPSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        )
{
    BOOL fResult;
    LPSTR psz = NULL;
    int cchUTF8;
    int cchWideChar;
    int i;

    cchWideChar = wcslen(pwsz);
    if (cchWideChar == 0) {
        *pAsn1Length = 0;
        *ppAsn1Value = 0;
        return TRUE;
    }
    // Check that the input string contains valid IA5 characters
    for (i = 0; i < cchWideChar; i++) {
        if (pwsz[i] > 0x7F) {
            SetLastError((DWORD) CRYPT_E_INVALID_IA5_STRING);
            *pAsn1Length = (unsigned int) i;
            goto InvalidIA5;
        }
    }

    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        NULL,       // lpUTF8Str
        0           // cchUTF8
        );

    if (cchUTF8 <= 0)
        goto ErrorReturn;
    if (NULL == (psz = (LPSTR) PkiAsn1Alloc(cchUTF8)))
        goto ErrorReturn;
    cchUTF8 = WideCharToUTF8(
        pwsz,
        cchWideChar,
        psz,
        cchUTF8
        );
    *ppAsn1Value = psz;
    *pAsn1Length = cchUTF8;
    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    *pAsn1Length = 0;
InvalidIA5:
    *ppAsn1Value = NULL;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        )
{
    PkiAsn1Free(pAsn1Value);
}

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    int cchWideChar;

    cchWideChar = UTF8ToWideChar(
        (LPSTR) pAsn1Value,
        Asn1Length,
        NULL,                   // lpWideCharStr
        0                       // cchWideChar
        );
    if (cchWideChar > 0)
        lData = cchWideChar * sizeof(WCHAR);
    else
        lData = 0;
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            UTF8ToWideChar(pAsn1Value, Asn1Length,
                (LPWSTR) pbExtra, cchWideChar);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;

    lData = (LONG) Asn1Length * sizeof(WCHAR);
    lAlignExtra = INFO_LEN_ALIGN(lData + sizeof(WCHAR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if (lData > 0)
            memcpy(pbExtra, pAsn1Value, lData);
        memset(pbExtra + lData, 0, sizeof(WCHAR));
        *ppwsz = (LPWSTR) pbExtra;
        pbExtra += lAlignExtra;
    }
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        )
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    pAsn1->encoded = pInfo->pbData;
    pAsn1->length = pInfo->cbData;
}

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifndef MSASN1_SUPPORTS_NOCOPY
    dwFlags &= ~CRYPT_DECODE_NOCOPY_FLAG;
#endif
    if (dwFlags & CRYPT_DECODE_NOCOPY_FLAG) {
        if (*plRemainExtra >= 0) {
            pInfo->cbData = pAsn1->length;
            pInfo->pbData = (BYTE *) pAsn1->encoded;
        }
    } else {
        LONG lRemainExtra = *plRemainExtra;
        BYTE *pbExtra = *ppbExtra;
        LONG lAlignExtra;
        LONG lData;
    
        lData = (LONG) pAsn1->length;
        lAlignExtra = INFO_LEN_ALIGN(lData);
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            if (lData > 0) {
                pInfo->pbData = pbExtra;
                pInfo->cbData = (DWORD) lData;
                memcpy(pbExtra, pAsn1->encoded, lData);
            } else
                memset(pInfo, 0, sizeof(*pInfo));
            pbExtra += lAlignExtra;
        }
        *plRemainExtra = lRemainExtra;
        *ppbExtra = pbExtra;
    }
}


//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        BYTE *pbEncoded;
        BYTE *pbAllocEncoded;
        PFN_CRYPT_ALLOC pfnAlloc;

        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode(
            pEnc,
            pvAsn1Info,
            id,
            &pbEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            *((void **) pvEncoded) = NULL;
            goto Asn1EncodeError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbAllocEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            PkiAsn1FreeEncoded(pEnc, pbEncoded);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        *((BYTE **) pvEncoded) = pbAllocEncoded;
        PkiAsn1FreeEncoded(pEnc, pbEncoded);
    } else {
        cbEncoded = *pcbEncoded;
        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode2(
            pEnc,
            pvAsn1Info,
            id,
            (BYTE *) pvEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            if (ASN1_ERR_OVERFLOW == Asn1Err)
                goto LengthError;
            else
                goto Asn1EncodeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
SET_ERROR(LengthError, ERROR_MORE_DATA)
SET_ERROR_VAR(Asn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        pEnc,
        id,
        pvAsn1Info,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Decode(
            pDec,
            ppvAsn1Info,
            id,
            pbEncoded,
            cbEncoded
            )))
        goto Asn1DecodeError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvAsn1Info = NULL;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvAsn1Info,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvAsn1Info,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeCallbackError)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvAsn1Info = NULL;

    if (!PkiAsn1DecodeAndAllocInfo(
            pDec,
            id,
            pbEncoded,
            cbEncoded,
            &pvAsn1Info
            )) goto Asn1DecodeError;

    fResult = PkiAsn1AllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    PkiAsn1FreeInfo(pDec, id, pvAsn1Info);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1DecodeError)
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        ASN1uint16_t cMax = *pCount;
        ASN1uint32_t *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul = 0;
            while (my_isdigit(ch = *psz++)) {
                *pul = (*pul * 10) + (ch - '0');
            }
            pul++;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR * ppszObjId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;
    LPSTR pszObjId = NULL;

    if (ppbExtra != NULL) {
        pszObjId = (LPSTR) *ppbExtra;
    }

    lRemain = (LONG) *plRemainExtra;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        ASN1uint32_t *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *ppszObjId = (LPSTR) *ppbExtra; 
        *ppbExtra = (LPBYTE) pszObjId;
        *plRemainExtra = lRemain;
    } else {
        *plRemainExtra = lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Adjust FILETIME for timezone.
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
static BOOL AdjustFileTime(
    IN OUT LPFILETIME pFileTime,
    IN ASN1int16_t mindiff,
    IN ASN1bool_t utc
    )
{
    if (utc || mindiff == 0)
        return TRUE;

    BOOL fResult;
    SYSTEMTIME stmDiff;
    FILETIME ftmDiff;
    short absmindiff;

    memset(&stmDiff, 0, sizeof(stmDiff));
    // Note: FILETIME is 100 nanoseconds interval since January 1, 1601
    stmDiff.wYear   = 1601;
    stmDiff.wMonth  = 1;
    stmDiff.wDay    = 1;

    absmindiff = mindiff > 0 ? mindiff : -mindiff;
    stmDiff.wHour = absmindiff / 60;
    stmDiff.wMinute = absmindiff % 60;
    if (stmDiff.wHour >= 24) {
        stmDiff.wDay += stmDiff.wHour / 24;
        stmDiff.wHour %= 24;
    }

    // Note, FILETIME is only 32 bit aligned. __int64 is 64 bit aligned.
    if ((fResult = SystemTimeToFileTime(&stmDiff, &ftmDiff))) {
        unsigned __int64 uTime;
        unsigned __int64 uDiff;

        memcpy(&uTime, pFileTime, sizeof(uTime));
        memcpy(&uDiff, &ftmDiff, sizeof(uDiff));

        if (mindiff > 0)
            uTime += uDiff;
        else
            uTime -= uDiff;

        memcpy(pFileTime, &uTime, sizeof(*pFileTime));
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear > YEARLAST)
        goto YearRangeError;

    pAsn1Time->year   = (ASN1uint8_t) (t.wYear % 100);
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->universal = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
TRACE_ERROR(YearRangeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year > MAGICYEAR ?
                    (1900 + pAsn1Time->year) : (2000 + pAsn1Time->year);
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    memset(pAsn1Time, 0, sizeof(*pAsn1Time));
    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    pAsn1Time->year   = t.wYear;
    pAsn1Time->month  = (ASN1uint8_t) t.wMonth;
    pAsn1Time->day    = (ASN1uint8_t) t.wDay;
    pAsn1Time->hour   = (ASN1uint8_t) t.wHour;
    pAsn1Time->minute = (ASN1uint8_t) t.wMinute;
    pAsn1Time->second = (ASN1uint8_t) t.wSecond;
    pAsn1Time->millisecond = 0; // t.wMilliseconds;
    pAsn1Time->universal    = TRUE;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;
    memset(&t, 0, sizeof(t));

    t.wYear   = pAsn1Time->year;
    t.wMonth  = pAsn1Time->month;
    t.wDay    = pAsn1Time->day;
    t.wHour   = pAsn1Time->hour;
    t.wMinute = pAsn1Time->minute;
    t.wSecond = pAsn1Time->second;
    t.wMilliseconds = pAsn1Time->millisecond;

    if (!SystemTimeToFileTime(&t, pFileTime))
        goto SystemTimeToFileTimeError;
    fRet = AdjustFileTime(
        pFileTime,
        pAsn1Time->diff,
        pAsn1Time->universal
        );
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SystemTimeToFileTimeError)
}


//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    )
{
    BOOL        fRet;
    SYSTEMTIME  t;

    if (!FileTimeToSystemTime(pFileTime, &t))
        goto FileTimeToSystemTimeError;
    if (t.wYear < YEARFIRST || t.wYear >= YEARFIRSTGENERALIZED) {
        *pwChoice = PKI_ASN1_GENERALIZED_TIME_CHOICE;
        memset(pGeneralTime, 0, sizeof(*pGeneralTime));
        pGeneralTime->year   = t.wYear;
        pGeneralTime->month  = (ASN1uint8_t) t.wMonth;
        pGeneralTime->day    = (ASN1uint8_t) t.wDay;
        pGeneralTime->hour   = (ASN1uint8_t) t.wHour;
        pGeneralTime->minute = (ASN1uint8_t) t.wMinute;
        pGeneralTime->second = (ASN1uint8_t) t.wSecond;
        pGeneralTime->universal    = TRUE;
    } else {
        *pwChoice = PKI_ASN1_UTC_TIME_CHOICE;
        memset(pUtcTime, 0, sizeof(*pUtcTime));
        pUtcTime->year = (ASN1uint8_t) (t.wYear % 100);
        pUtcTime->month  = (ASN1uint8_t) t.wMonth;
        pUtcTime->day    = (ASN1uint8_t) t.wDay;
        pUtcTime->hour   = (ASN1uint8_t) t.wHour;
        pUtcTime->minute = (ASN1uint8_t) t.wMinute;
        pUtcTime->second = (ASN1uint8_t) t.wSecond;
        pUtcTime->universal    = TRUE;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *pwChoice = 0;
    memset(pGeneralTime, 0, sizeof(*pGeneralTime));
    memset(pUtcTime, 0, sizeof(*pUtcTime));
    goto CommonReturn;
TRACE_ERROR(FileTimeToSystemTimeError)
}


//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    if (PKI_ASN1_UTC_TIME_CHOICE == wChoice) {
        return PkiAsn1FromUTCTime(pUtcTime, pFileTime);
    } else
        return PkiAsn1FromGeneralizedTime(pGeneralTime, pFileTime);
}
#endif // SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\utf8.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       utf8.cpp
//
//  Contents:   WideChar to/from UTF8 APIs
//
//  Functions:  WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------
#ifdef SMIME_V3
#include <windows.h>
#include <dbgdef.h>
#include "utf8.h"

#define wcslen my_wcslen
int my_wcslen(LPCWSTR pwsz);

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    )
{
    int cchRemainUTF8;

    if (cchUTF8 < 0)
        goto InvalidParameter;
    cchRemainUTF8 = cchUTF8;

    if (cchWideChar < 0)
        cchWideChar = wcslen(lpWideCharStr) + 1;

    while (cchWideChar--) {
        WCHAR wch = *lpWideCharStr++;
        if (wch <= 0x7F) {
            // 7 bits
            cchRemainUTF8 -= 1;
            if (cchRemainUTF8 >= 0)
                *lpUTF8Str++ = (char) wch;
        } else if (wch <= 0x7FF) {
            // 11 bits
            cchRemainUTF8 -= 2;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xC0 | ((wch >> 6) & 0x1F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        } else {
            // 16 bits
            cchRemainUTF8 -= 3;
            if (cchRemainUTF8 >= 0) {
                *lpUTF8Str++ = (char) (0xE0 | ((wch >> 12) & 0x0F));
                *lpUTF8Str++ = (char) (0x80 | ((wch >> 6) & 0x3F));
                *lpUTF8Str++ = (char) (0x80 | (wch & 0x3F));
            }
        }
    }

    if (cchRemainUTF8 >= 0)
        cchUTF8 = cchUTF8 - cchRemainUTF8;
    else if (cchUTF8 == 0)
        cchUTF8 = -cchRemainUTF8;
    else {
        cchUTF8 = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchUTF8;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    )
{
    int cchRemainWideChar;

    if (cchWideChar < 0)
        goto InvalidParameter;
    cchRemainWideChar = cchWideChar;

    if (cchUTF8 < 0)
        cchUTF8 = strlen(lpUTF8Str) + 1;

    while (cchUTF8--) {
        char ch = *lpUTF8Str++;
        WCHAR wch;
        if (0 == (ch & 0x80))
            // 7 bits, 1 byte
            wch = (WCHAR) ch;
        else if (0xC0 == (ch & 0xE0)) {
            // 11 bits, 2 bytes
            char ch2;

            if (--cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x1F) << 6) | ((WCHAR) ch2 & 0x3F);
        } else if (0xE0 == (ch & 0xF0)) {
            // 16 bits, 3 bytes
            char ch2;
            char ch3;
            cchUTF8 -= 2;
            if (cchUTF8 < 0)
                goto InvalidParameter;
            ch2 = *lpUTF8Str++;
            ch3 = *lpUTF8Str++;
            if (0x80 != (ch2 & 0xC0) || 0x80 != (ch3 & 0xC0))
                goto InvalidParameter;
            wch = (((WCHAR) ch & 0x0F) << 12) | (((WCHAR) ch2 & 0x3F) << 6) |
                ((WCHAR) ch3 & 0x3F);
        } else
            goto InvalidParameter;

        if (--cchRemainWideChar >= 0)
            *lpWideCharStr++ = wch;
    }

    if (cchRemainWideChar >= 0)
        cchWideChar = cchWideChar - cchRemainWideChar;
    else if (cchWideChar == 0)
        cchWideChar = -cchRemainWideChar;
    else {
        cchWideChar = 0;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }
    return cchWideChar;

InvalidParameter:
    SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
}
#endif //SMIME_V3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptFreeTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptUninstallOssGlobal
//              I_CryptGetOssGlobal
//
//              I_CryptInstallAsn1Module
//              I_CryptUninstallAsn1Module
//              I_CryptGetAsn1Encoder
//              I_CryptGetAsn1Decoder
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "msasn1.h"
#include "ossglobl.h"
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed OssGlobal table
typedef DWORD HCRYPTOSSGLOBAL;

// Pointer to OssGlobal. Returned by I_CryptGetOssGlobal()
typedef  OssGlobal  *POssGlobal;

// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to free a thread local storage entry.
//  Optionally, calls the callback for each thread having a non-NULL pvTls.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptFreeTls(
    IN HCRYPTTLS hCryptTls,
    IN OPTIONAL PFN_CRYPT_FREE pfnFree
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//
//  Note, at DLL_PROCESS_DETACH, I_CryptFreeTls should be called instead.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an OssGlobal entry. Iterate
//  through the threads and frees their allocated copy of OssGlobal.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    )
{
    return (HCRYPTASN1MODULE) I_CryptInstallOssGlobal(
        pvCtlTbl, dwFlags, pvReserved);
}
#else

HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return I_CryptUninstallOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1encoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
#ifdef OSS_CRYPT_ASN1
__inline
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    )
{
    return (ASN1decoding_t) I_CryptGetOssGlobal((HCRYPTOSSGLOBAL) hAsn1Module);
}
#else

ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#endif  // OSS_CRYPT_ASN1

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#ifdef __cplusplus
extern "C" {
#endif

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#ifdef ASN1LIB
#define ASN1_PUBLIC     __declspec(dllexport)
#elif defined(ASN1C)
#define ASN1_PUBLIC     
#else
#define ASN1_PUBLIC     __declspec(dllimport)
#endif
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
    ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
    ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    ASN1char_t *value;
}
    ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    ASN1char16_t *value;
}
    ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    ASN1char32_t *value;
}
    ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    WCHAR *value;
}
    ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
    *ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
    ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    ASN1octet_t  *value;
}
    ASN1encodedOID_t;

typedef struct tagASN1stringtableentry_t
{
    ASN1char32_t lower;
    ASN1char32_t upper;
    ASN1uint32_t value;
}
    ASN1stringtableentry_t;

typedef struct tagASN1stringtable_t
{
    ASN1uint32_t length;
    ASN1stringtableentry_t *values;
}
    ASN1stringtable_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        void           *encoded;
        void           *value;
    };
}
    ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
    ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
    ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_PER_RULE_ALIGNED       = 0x0001,
    ASN1_PER_RULE_UNALIGNED     = 0x0002, // not supported
    ASN1_PER_RULE               = ASN1_PER_RULE_ALIGNED | ASN1_PER_RULE_UNALIGNED,

    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
    ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1PerEncFun_t)(ASN1encoding_t enc, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1PerDecFun_t)(ASN1decoding_t enc, void *data);
typedef struct tagASN1PerFunArr_t
{
    const ASN1PerEncFun_t *apfnEncoder;
    const ASN1PerDecFun_t *apfnDecoder;
}
    ASN1PerFunArr_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)(ASN1encoding_t enc, ASN1uint32_t tag, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)(ASN1decoding_t enc, ASN1uint32_t tag, void *data);
typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
    ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)(void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    const ASN1FreeFun_t    *apfnFreeMemory;
    const ASN1uint32_t     *acbStructSize;
    union
    {
        ASN1PerFunArr_t     PER;
        ASN1BerFunArr_t     BER;
    };
}
    *ASN1module_t;


struct ASN1encoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/* ------ public basic ASN.1 API ------ */

extern ASN1_PUBLIC ASN1module_t ASN1API ASN1_CreateModule
(
    ASN1uint32_t            nVersion,
    ASN1encodingrule_e      eRule,
    ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
    ASN1uint32_t            cPDU,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseModule
(
    ASN1module_t        pModule
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateEncoder
(
    ASN1module_t        pModule,
    ASN1encoding_t     *ppEncoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Encode
(
    ASN1encoding_t      pEncoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder
(
    ASN1encoding_t      pEncoderInfo
);


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoder
(
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Decode
(
    ASN1decoding_t      pDecoderInfo,
    void              **ppDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseDecoder
(
    ASN1decoding_t      pDecoderInfo
);


extern ASN1_PUBLIC void ASN1API ASN1_FreeEncoded
(
    ASN1encoding_t      pEncoderInfo,
    void               *pBuf
);

extern ASN1_PUBLIC void ASN1API ASN1_FreeDecoded
(
    ASN1decoding_t      pDecoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum
);


/* ------ public advanced ASN.1 API ------ */

typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101, 

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
    ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
    ASN1optionparam_t, ASN1optionparam_s;


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);


/* ------ internal ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);
extern ASN1_PUBLIC void ASN1API ASN1utf8string_free(ASN1wstring_t *);

extern ASN1_PUBLIC void * ASN1API ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size);
extern ASN1_PUBLIC void * ASN1API ASN1DecRealloc(ASN1decoding_t dec, void *ptr, ASN1uint32_t size);
extern ASN1_PUBLIC void   ASN1API ASN1Free(void *ptr);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err);
extern ASN1_PUBLIC ASN1error_e ASN1API ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err);

extern ASN1_PUBLIC void ASN1API ASN1intx_sub(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_uoctets(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_free(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_add(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);

extern ASN1_PUBLIC void ASN1API ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName );

extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);

extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1bitstring_cmp(ASN1bitstring_t *, ASN1bitstring_t *, int);
extern ASN1_PUBLIC int ASN1API ASN1octetstring_cmp(ASN1octetstring_t *, ASN1octetstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1charstring_cmp(ASN1charstring_t *, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1char16string_cmp(ASN1char16string_t *, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1char32string_cmp(ASN1char32string_t *, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1ztcharstring_cmp(ASN1ztcharstring_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1ztchar16string_cmp(ASN1ztchar16string_t, ASN1ztchar16string_t);
extern ASN1_PUBLIC int ASN1API ASN1open_cmp(ASN1open_t *, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime_cmp(ASN1generalizedtime_t *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime_cmp(ASN1utctime_t *, ASN1utctime_t *);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

typedef enum tagASN1real_e
{
    eReal_Normal,
    eReal_PlusInfinity,
    eReal_MinusInfinity
}
    ASN1real_e;

typedef struct tagASN1real_t
{
    ASN1real_e type;
    ASN1intx_t mantissa;
    ASN1uint32_t base;
    ASN1intx_t exponent;
}
    ASN1real_t;

typedef struct tagASN1external_t
{
#   define ASN1external_data_value_descriptor_o 0
    ASN1octet_t o[1];
    struct ASN1external_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1external_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1external_identification_context_negotiation_o 3
            struct ASN1external_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
        } u;
    } identification;
    ASN1objectdescriptor_t data_value_descriptor;
    struct ASN1external_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1external_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1external_t;

typedef struct ASN1external_identification_s ASN1external_identification_t;
typedef struct ASN1external_identification_context_negotiation_s ASN1external_identification_context_negotiation_t;
typedef struct ASN1external_data_value_s ASN1external_data_value_t;

typedef struct tagASN1embeddedpdv_t
{
    struct ASN1embeddedpdv_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_identification_syntaxes_o 0
            struct ASN1embeddedpdv_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1embeddedpdv_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1embeddedpdv_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1embeddedpdv_identification_context_negotiation_o 3
            struct ASN1embeddedpdv_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1embeddedpdv_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1embeddedpdv_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1embeddedpdv_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1embeddedpdv_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1embeddedpdv_t;

typedef struct ASN1embeddedpdv_identification_s ASN1embeddedpdv_identification_t;
typedef struct ASN1embeddedpdv_identification_syntaxes_s ASN1embeddedpdv_identification_syntaxes_t;
typedef struct ASN1embeddedpdv_identification_context_negotiation_s ASN1embeddedpdv_identification_context_negotiation_t;
typedef struct ASN1embeddedpdv_data_value_s ASN1embeddedpdv_data_value_t;

typedef struct tagASN1characterstring_t
{
    struct ASN1characterstring_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_identification_syntaxes_o 0
            struct ASN1characterstring_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1characterstring_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1characterstring_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1characterstring_identification_context_negotiation_o 3
            struct ASN1characterstring_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1characterstring_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1characterstring_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1characterstring_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1characterstring_data_value_encoded_o 1
            ASN1octetstring_t encoded;
        } u;
    } data_value;
} ASN1characterstring_t;

typedef struct ASN1characterstring_identification_s ASN1characterstring_identification_t;
typedef struct ASN1characterstring_identification_syntaxes_s ASN1characterstring_identification_syntaxes_t;
typedef struct ASN1characterstring_identification_context_negotiation_s ASN1characterstring_identification_context_negotiation_t;
typedef struct ASN1characterstring_data_value_s ASN1characterstring_data_value_t;


extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);


#ifdef __cplusplus
}
#endif

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msber.inl ===
/* DER variant of BER */

__inline int ASN1API ASN1DEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    return ASN1CEREncGeneralizedTime(enc, tag, val);
}
__inline int ASN1API ASN1DEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    return ASN1CEREncUTCTime(enc, tag, val);
}

__inline int ASN1API ASN1DEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk)
{
    return ASN1CEREncBeginBlk(enc, eBlkType, ppBlk);
}
__inline int ASN1API ASN1DEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2)
{
    return ASN1CEREncNewBlkElement(pBlk, enc2);
}
__inline int ASN1API ASN1DEREncFlushBlkElement(void *pBlk)
{
    return ASN1CEREncFlushBlkElement(pBlk);
}
__inline int ASN1API ASN1DEREncEndBlk(void *pBlk)
{
    return ASN1CEREncEndBlk(pBlk);
}

__inline int ASN1API ASN1DEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    return ASN1BEREncCharString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    return ASN1BEREncChar16String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    return ASN1BEREncChar32String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncBitString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncZeroMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, tag, len, val);
}

__inline int ASN1API ASN1DEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
__inline int ASN1API ASN1CEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msper.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_PER_H__
#define __MS_PER_H__

#include <msasn1.h>

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1PEREncZero(ASN1encoding_t enc, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBit(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitVal(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitIntx(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmallBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctets(ASN1encoding_t enc, ASN1uint32_t noctets, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmall(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedUIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedLength(ASN1uint32_t *len, ASN1encoding_t enc, ASN1uint32_t nitems);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmented(ASN1encoding_t enc, ASN1uint32_t nitems, ASN1octet_t *val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier(ASN1encoding_t enc, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier2(ASN1encoding_t enc, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncDouble(ASN1encoding_t enc, double d);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlushFragmentedToParent(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1PEREncAlignment(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncMultibyteString(ASN1encoding_t enc, ASN1char_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncGeneralizedTime(ASN1encoding_t enc, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUTCTime(ASN1encoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckExtensions(ASN1uint32_t nbits, ASN1octet_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecBit(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN32Val(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN16Val(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN8Val(ASN1decoding_t dec, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNXVal(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmented(ASN1decoding_t dec, ASN1uint32_t *nitems, ASN1octet_t **val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1PERDecAlignment(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBits(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecDouble(ASN1decoding_t dec, double *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBitIntx(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedUIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedLength(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier2(ASN1decoding_t dec, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecMultibyteString(ASN1decoding_t dec, ASN1char_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecGeneralizedTime(ASN1decoding_t dec, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTCTime(ASN1decoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipBits(ASN1decoding_t dec, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipFragmented(ASN1decoding_t dec, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmall(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions);

extern ASN1_PUBLIC int ASN1API ASN1PEREncInteger(ASN1encoding_t enc, ASN1int32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecInteger(ASN1decoding_t dec, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedInteger(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedInteger(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedShort(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedShort(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBoolean(ASN1encoding_t enc, ASN1bool_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBoolean(ASN1decoding_t dec, ASN1bool_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitClear(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitSet(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoiceEx(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoiceEx(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncComplexChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);
extern ASN1_PUBLIC int ASN1API ASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);

/* unconstrained */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_NoSize(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_NoSize(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr);

/* fixed-array */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

/* unbounded */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

typedef int (ASN1CALL *ASN1iterator_encfn) (ASN1encoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_decfn) (ASN1decoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_freefn) (ASN1iterator_t *);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_NoSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_NoSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_VarSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_VarSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC void ASN1API ASN1PERFreeSeqOf(ASN1iterator_t **val, ASN1iterator_freefn pfnIterator);

extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtensionFragmented(ASN1decoding_t dec);
__inline int ASN1PERDecExtensionBit(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1PERDecBit(dec, val);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableCharString(ASN1uint32_t nchars, ASN1char_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar16String(ASN1uint32_t nchars, ASN1char16_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar32String(ASN1uint32_t nchars, ASN1char32_t *val, ASN1stringtable_t *table);

extern ASN1_PUBLIC int ASN1API ASN1PEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t nchars, WCHAR *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t nchars, WCHAR **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8StringEx(ASN1decoding_t dec, ASN1uint32_t *nchars, WCHAR **val);

extern ASN1_PUBLIC int ASN1API ASN1PEREncExternal(ASN1encoding_t enc, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdv(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdvOpt(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterString(ASN1encoding_t enc, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterStringOpt(ASN1encoding_t enc, ASN1characterstring_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecExternal(ASN1decoding_t dec, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdv(ASN1decoding_t dec, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdvOpt(ASN1decoding_t dec, ASN1embeddedpdv_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterString(ASN1decoding_t dec, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterStringOpt(ASN1decoding_t dec, ASN1characterstring_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);

#ifdef __cplusplus
}
#endif

#endif // __MS_PER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG

    extern int WINAPIV DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);

#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)


#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\utf8.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       utf8.h
//
//  Contents:   WideChar (UNICODE) to/from UTF8 APIs
//
//  APIs:       WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#ifndef __UTF8_H__
#define __UTF8_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    );

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\pkiasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkiasn1.h
//
//  Contents:   PKI ASN.1 support functions.
//
//  APIs:       PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1FreeEncoded
//              PkiAsn1Encode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//              PkiAsn1FreeDecoded
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//              PkiAsn1EncodedOidToDotVal
//              PkiAsn1FreeDotVal
//              PkiAsn1DotValToEncodedOid
//              PkiAsn1FreeEncodedOid
//
//              PkiAsn1Alloc
//              PkiAsn1Free
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1FreeHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1FreeInfo
//              PkiAsn1EncodeInfoEx
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIASN1_H__
#define __PKIASN1_H__

#include <msber.h>
#include <msasn1.h>
#include <winerror.h>
#include <pkialloc.h>

#ifdef OSS_CRYPT_ASN1
#include "asn1hdr.h"
#include "asn1code.h"
#include "ossglobl.h"
#include "pkioss.h"
#include "ossutil.h"
#include "ossconv.h"
#endif  // OSS_CRYPT_ASN1

#ifndef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 > Asn1Err)
        return CRYPT_E_OSS_ERROR + 0x100 + (-Asn1Err -1000);
    else
        return CRYPT_E_OSS_ERROR + 0x200 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ASN1_FreeEncoded(pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rule functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    );

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    );

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    LPSTR pszDotVal = NULL;
    if (ASN1BEREoid2DotVal(pDec, pEncodedOid, &pszDotVal))
        return pszDotVal;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ASN1Free(pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    return ASN1BERDotVal2Eoid(pEnc, pszDotVal, pEncodedOid);
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ASN1_FreeEncoded(pEnc, pEncodedOid->value);
}

//+-------------------------------------------------------------------------
//  PkiAsn1 allocation and free functions
//--------------------------------------------------------------------------
#define PkiAsn1Alloc    PkiNonzeroAlloc
#define PkiAsn1Free     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );


inline void WINAPI
PkiAsn1SetOctetString(IN PCRYPT_DATA_BLOB pInfo,
                      OUT ASN1octetstring_t * pAsn1)
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    pAsn1->length = pInfo->cbData;
    pAsn1->value = pInfo->pbData;
}

//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

inline void WINAPI
PkiAsn1GetOctetString(
                      IN ASN1octetstring_t * pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
                      )
{
    PkiAsn1GetOctetString(pAsn1->length, pAsn1->value, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  PkiAsn1FreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

inline BOOL WINAPI
PkiAsn1SetHugeInteger(
                      IN PCRYPT_INTEGER_BLOB pInfo,
                      OUT ASN1intx_t * pAsn1)
{
    return PkiAsn1SetHugeInteger(pInfo, &pAsn1->length, &pAsn1->value);
}
            

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        );

inline void WINAPI
PkiAsn1FreeHugeInteger(ASN1intx_t asn1)
{
    PkiAsn1FreeHugeInteger(asn1.value);
}
 
void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

inline void
WINAPI
PkiAsn1GetHugeInteger(
                      ASN1intx_t asn1,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeInteger(asn1.length, asn1.value, dwFlags, pInfo, ppbExtra,
                          plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1intx_t * pAsn1);

#define PkiAsn1FreeHugeUINT     PkiAsn1FreeHugeInteger

void
WINAPI
PkiAsn1GetHugeUINT(
                   IN ASN1intx_t pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        );

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        );

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR * ppszObjId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    );

#define PKI_ASN1_UTC_TIME_CHOICE            1
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    2

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    );

#else 

//+=========================================================================
// The following map to the OSS ASN1 routines
//==========================================================================

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 <= Asn1Err && 1000 > Asn1Err)
        return CRYPT_E_OSS_ERROR + Asn1Err;
    else if (0 > Asn1Err)
        return CRYPT_E_OSS_ERROR + 0x100 + (-Asn1Err -1000);
    else
        return CRYPT_E_OSS_ERROR + 0x200 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT OPTIONAL DWORD *pcbEncoded = NULL
    )
{
    return (ASN1error_e) PkiOssEncode(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ossFreeBuf((OssGlobal *) pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssEncode2(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        pbEncoded,
        cbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode2(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ossFreePDU((OssGlobal *) pDec, (int) id, pvAsn1Info);
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ossEncodingRules ossRules;
    if (ASN1_BER_RULE_BER == eRule)
        ossRules = OSS_BER;
    else
        ossRules = OSS_DER;

    return (ASN1error_e) ossSetEncodingRules((OssGlobal *) pEnc, ossRules);
}

__inline
ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ossEncodingRules ossRules;
    ossRules = ossGetEncodingRules((OssGlobal *) pEnc);
    if (OSS_BER == ossRules)
        return ASN1_BER_RULE_BER;
    else
        return ASN1_BER_RULE_DER;
}

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID OssEncodedOid;
    OssBuf dotOid;
    memset(&dotOid, 0, sizeof(dotOid));

    OssEncodedOid.length = pEncodedOid->length;
    OssEncodedOid.value = pEncodedOid->value;
    if (0 == ossEncodedOidToDotVal((OssGlobal *) pDec, &OssEncodedOid,
            &dotOid))
        return (LPSTR) dotOid.value;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ossFreeBuf((OssGlobal *) pDec, pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID eoid;
    memset(&eoid, 0, sizeof(eoid));
    if (0 == ossDotValToEncodedOid((OssGlobal *) pEnc, pszDotVal, &eoid)) {
        pEncodedOid->length = eoid.length;
        pEncodedOid->value = eoid.value;
        return 1;
    } else {
        pEncodedOid->length = 0;
        pEncodedOid->value = NULL;
        return 0;
    }
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ossFreeBuf((OssGlobal *) pEnc, pEncodedOid->value);
}

#define PkiAsn1Alloc OssUtilAlloc
#define PkiAsn1Free OssUtilFree
#define PkiAsn1ReverseBytes OssUtilReverseBytes
#define PkiAsn1AllocAndReverseBytes OssUtilAllocAndReverseBytes
#define PkiAsn1GetOctetString OssUtilGetOctetString
#define PkiAsn1SetHugeInteger OssUtilSetHugeInteger
#define PkiAsn1FreeHugeInteger OssUtilFreeHugeInteger
#define PkiAsn1GetHugeInteger OssUtilGetHugeInteger
#define PkiAsn1SetHugeUINT OssUtilSetHugeUINT
#define PkiAsn1FreeHugeUINT OssUtilFreeHugeInteger
#define PkiAsn1GetHugeUINT OssUtilGetHugeUINT
#define PkiAsn1SetBitString OssUtilSetBitString
#define PkiAsn1GetBitString OssUtilGetBitString
#define PkiAsn1GetIA5String OssUtilGetIA5String
#define PkiAsn1SetUnicodeConvertedToIA5String OssUtilSetUnicodeConvertedToIA5String
#define PkiAsn1FreeUnicodeConvertedToIA5String OssUtilFreeUnicodeConvertedToIA5String
#define PkiAsn1GetIA5StringConvertedToUnicode OssUtilGetIA5StringConvertedToUnicode
#define PkiAsn1GetBMPString OssUtilGetBMPString
#define PkiAsn1SetAny OssUtilSetAny
#define PkiAsn1GetAny OssUtilGetAny

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfo(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return OssUtilDecodeAndAllocInfo(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    OssUtilFreeInfo(
        (OssGlobal *) pDec,
        (int) id,
        pvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilAllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilDecodeAndAllocInfoEx(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

#define PkiAsn1ToObjectIdentifier OssConvToObjectIdentifier
#define PkiAsn1FromObjectIdentifier OssConvFromObjectIdentifier
#define PkiAsn1ToUTCTime OssConvToUTCTime
#define PkiAsn1FromUTCTime OssConvFromUTCTime
#define PkiAsn1ToGeneralizedTime OssConvToGeneralizedTime
#define PkiAsn1FromGeneralizedTime OssConvFromGeneralizedTime


__inline
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pGeneralTime,
    OUT UTCTime *pUtcTime
    )
{
    return OssConvToChoiceOfTime(
        pFileTime,
        pwChoice,
        pGeneralTime
        );
}

#define PKI_ASN1_UTC_TIME_CHOICE            OSS_UTC_TIME_CHOICE
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    OSS_GENERALIZED_TIME_CHOICE

__inline
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pGeneralTime,
    IN UTCTime *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    return OssConvFromChoiceOfTime(
        wChoice,
        pGeneralTime,
        pFileTime
        );
}

#endif  // OSS_CRYPT_ASN1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\certprot.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       certprot.h
//
//  Contents:   Certificate Protection APIs
//
//  APIs:       I_CertProtectFunction
//              I_CertSrvProtectFunction
//
//  History:    27-Nov-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CERTPROT_H__
#define __CERTPROT_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Calls the services process to do a protected certificate function,
//  such as, add or delete a protected root certificate.
//
//  CryptMemFree must be called to free the returned *ppbOut.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );

#define CERT_PROT_INIT_ROOTS_FUNC_ID            1
#define CERT_PROT_PURGE_LM_ROOTS_FUNC_ID        2
#define CERT_PROT_ADD_ROOT_FUNC_ID              3
#define CERT_PROT_DELETE_ROOT_FUNC_ID           4
#define CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID  5


//+-------------------------------------------------------------------------
//  CERT_PROT_INIT_ROOTS_FUNC_ID
//
//  Initialize the protected list of CurrentUser roots. Note, no UI.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_PURGE_LM_ROOTS_FUNC_ID
//  
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//
//  Note, no UI. Purging can be disabled by setting the
//  CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG in the registry's ProtectedRootFlags
//  value.
//
//  No IN/OUT parameters.
//
//  Even if purging is disabled, the protected list of roots is still
//  initialized.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ADD_ROOT_FUNC_ID
//  
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized certificate context to be added. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_ROOT_FUNC_ID
//  
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  certificate's SHA1 hash property. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID
//  
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

typedef void __RPC_FAR * (__RPC_USER *PFN_CERT_PROT_MIDL_USER_ALLOC)(
    IN size_t cb
    );
typedef void (__RPC_USER *PFN_CERT_PROT_MIDL_USER_FREE)(
    IN void __RPC_FAR *pv
    );

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

typedef DWORD (WINAPI *PFN_CERT_SRV_PROTECT_FUNCTION)(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs: 
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs: 
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\utf8.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       utf8.h
//
//  Contents:   WideChar (UNICODE) to/from UTF8 APIs
//
//  APIs:       WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#ifndef __UTF8_H__
#define __UTF8_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    );

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\crtem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crtem.h
//
//  Contents:   'C' Run Time Emulation Definitions
//
//  History:	03-Jun-96   philh   created
//--------------------------------------------------------------------------

#ifndef __CRTEM_H__
#define __CRTEM_H__


///////////////////////////////////////////////////////////////////////
//
// Definitions that help reduce our dependence on the C runtimes
//
#define wcslen(sz)      lstrlenW(sz)            // yes it IS implemented by Win95

#define strlen(sz)      lstrlenA(sz)
#define strcpy(s1,s2)   lstrcpyA(s1,s2)
#define strcmp(s1,s2)   lstrcmpA(s1,s2)
#define _stricmp(s1,s2)  lstrcmpiA(s1,s2)
#define strcat(s1,s2)   lstrcatA(s1,s2)


///////////////////////////////////////////////////////////////////////
//
// C runtime excluders that we only use in non-debug builds
//

////////////////////////////////////////////
//
// enable intrinsics that we can
//
#if !DBG

    #ifdef __cplusplus
        #ifndef _M_PPC
            #pragma intrinsic(memcpy)
            #pragma intrinsic(memcmp)
            #pragma intrinsic(memset)
        #endif
    #endif

////////////////////////////////////////////
//
// memory management
//
#define malloc(cb)          ((void*)LocalAlloc(LPTR, cb))
#define free(pv)            (LocalFree((HLOCAL)pv))
#define realloc(pv, cb)     ((void*)LocalReAlloc((HLOCAL)pv, cb, LMEM_MOVEABLE))

#endif  // !DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\crypthlp.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       crypthlp.h
//
//  Contents:   Misc internal crypt/certificate helper APIs
//
//  APIs:       I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              I_CryptGetFileVersion
//              I_CertSyncStore
//
//  History:    01-Jun-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTHLP_H__
#define __CRYPTHLP_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  HCRYPTPROVs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    );

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    );

//+-------------------------------------------------------------------------
//  crypt32.dll release version numbers
//--------------------------------------------------------------------------
#define IE4_CRYPT32_DLL_VER_MS          ((    5 << 16) | 101 )
#define IE4_CRYPT32_DLL_VER_LS          (( 1670 << 16) |   1 )

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    );

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\ossconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossconv.h
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  APIs:       OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//
//--------------------------------------------------------------------------

#ifndef __OSSCONV_H__
#define __OSSCONV_H__

#include "asn1hdr.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    );

#define OSS_UTC_TIME_CHOICE             1
#define OSS_GENERALIZED_TIME_CHOICE     2

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptGetOssGlobal
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed OssGlobal table
typedef DWORD HCRYPTOSSGLOBAL;

// Pointer to OssGlobal. Returned by I_CryptGetOssGlobal()
typedef  OssGlobal  *POssGlobal;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH or DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\ossutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossutil.h
//
//  Contents:   OSS ASN.1 compiler utility functions.
//
//  APIs: 
//              OssUtilAlloc
//              OssUtilFree
//              OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilFreeHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilGetBitString
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilEncodeInfoEx
//              OssUtilDecodeAndAllocInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __OSSUTIL_H__
#define __OSSUTIL_H__

#include <wincrypt.h>
#include <pkialloc.h>

#include "asn1hdr.h"
#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  OssUtil allocation and free functions
//--------------------------------------------------------------------------
#define OssUtilAlloc    PkiNonzeroAlloc
#define OssUtilFree     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BUGBUG: BYTE reversal::
//   - this only needs to be done for little endian
//   - this needs to be fixed in the OSS compiler
//
//  OssUtilFreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        );

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

#define OssUtilFreeHugeUINT     OssUtilFreeHugeInteger

void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        );

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        );

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        );

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        );

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_OSS_UTIL_DECODE_EX_CALLBACK)(
    IN void *pvOssInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


////////////////////////////////////////////////////////// 4.0 routines

BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
;

BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
;

#ifdef __cplusplus
}       // Balance extern "C" above
#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\ess\oss\unicode.h ===
#ifndef __ECM_UNICODE_H__
#define __ECM_UNICODE_H__

// necessary defns -- remove?
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>

#include <shfusion.h>

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI FIsWinNT(void);
BOOL WINAPI FIsWinNT5(VOID);
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW, char ** pszMB, int *pcbConverted);
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB);
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB);

LPWSTR WINAPI MkWStr(char * szMB);
void WINAPI FreeWStr(LPWSTR wsz);


BOOL WINAPI wstr2guid(const WCHAR *pwszIn, GUID *pgOut);
BOOL WINAPI guid2wstr(const GUID *pgIn, WCHAR *pwszOut);

// The following is also needed for non-x86 due to a bug in advapi32 for
// CryptAcquireContextW.
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

BOOL WINAPI CryptEnumProvidersU(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR pwszProvName,
    DWORD *pcbProvName
    );

// The following is also needed for non-x86 due to the fact that the
// A/W versions of the ListView_ functions do not exist.
// (these are implemented in ispu\common\unicode\commctrl.cpp)

int WINAPI ListView_InsertItemU(
    HWND hwnd,
    const LPLVITEMW pitem
    );

void WINAPI ListView_SetItemTextU(
    HWND hwnd,
    int i,
    int iSubItem,
    LPCWSTR pszText
    );

int WINAPI ListView_InsertColumnU(
    HWND hwnd,
    int i,
    const LPLVCOLUMNW plvC);

BOOL WINAPI ListView_GetItemU(
    HWND hwnd,
    LPLVITEMW pitem
    );


LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
    );

//
//  the following api's handle the problem with impersinating another user
//  and having the HKEY_CURRENT_USER opened to an incorrect user's SID.
//
LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    );

LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    );

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to only open
// HKEY_USERS\.Default if the current user is the LocalSystem SID.
#define REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG     0x1

LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    );

BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    );


#ifdef _M_IX86


// Reg.cpp
LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegDeleteKeyU(
    HKEY hKey,
    LPCWSTR lpSubKey
   );

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   );

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG WINAPI RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );

// File.cpp
HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
WINAPI
DeleteFileU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
CopyFileU(
          LPCWSTR lpwExistingFileName,
          LPCWSTR lpwNewFileName,
          BOOL bFailIfExists
          );

BOOL
WINAPI
MoveFileExU(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags);

DWORD
WINAPI
GetFileAttributesU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
SetFileAttributesU(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

DWORD
WINAPI
GetCurrentDirectoryU(
    DWORD nBufferLength,
    LPWSTR lpBuffer);

BOOL
WINAPI
CreateDirectoryU(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

UINT
WINAPI
GetWindowsDirectoryU(
    LPWSTR lpBuffer,
    UINT uSize
    );

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    );

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );


// capi.cpp
BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags
    );

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType
    );

// Ole.cpp
RPC_STATUS RPC_ENTRY UuidToStringU(
    UUID *  Uuid,
    WCHAR * *  StringUuid
   );

// nt.cpp
BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
   );

BOOL WINAPI GetComputerNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
   );

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName    // address of module name to return handle for
   );

// user.cpp
int WINAPI LoadStringU(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax
   );

DWORD WINAPI FormatMessageU(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
   );

BOOL WINAPI SetWindowTextU(
    HWND hWnd,
    LPCWSTR lpString
   );

int WINAPI DialogBoxParamU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam
    );

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount
   );

BOOL WINAPI SetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString
    );

int WINAPI MessageBoxU(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

int WINAPI LCMapStringU(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest
    );

int WINAPI GetDateFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate
    );

int WINAPI GetTimeFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime
    );

BOOL WINAPI WinHelpU(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );

LRESULT WINAPI SendMessageU(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG WINAPI
SendDlgItemMessageU(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LPWSTR
WINAPI
GetCommandLineU(void);

BOOL
WINAPI
IsBadStringPtrU(IN LPWSTR lpsz, UINT ucchMax);

void
WINAPI
OutputDebugStringU(IN LPWSTR lpwsz);

int
WINAPI
DrawTextU(
    HDC     hDC,
    LPCWSTR lpString,
    int     nCount,
    LPRECT  lpRect,
    UINT    uFormat
);

// event.cpp
HANDLE
WINAPI
CreateEventU(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName);

HANDLE
WINAPI
RegisterEventSourceU(
                    LPCWSTR lpUNCServerName,
                    LPCWSTR lpSourceName);

HANDLE
WINAPI
OpenEventU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HANDLE
WINAPI
CreateMutexU(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName);

HANDLE
WINAPI
OpenMutexU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HFONT
WINAPI
CreateFontIndirectU(CONST LOGFONTW *lplf);

#else

#define RegQueryValueExU        RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW
#define RegOpenKeyExU           RegOpenKeyExW
#define RegConnectRegistryU     RegConnectRegistryW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define DeleteFileU             DeleteFileW
#define CopyFileU               CopyFileW
#define GetFileAttributesU      GetFileAttributesW
#define SetFileAttributesU      SetFileAttributesW
#define GetCurrentDirectoryU    GetCurrentDirectoryW
#define CreateDirectoryU        CreateDirectoryW
#define GetWindowsDirectoryU    GetWindowsDirectoryW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetComputerNameU        GetComputerNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define FormatMessageU          FormatMessageW
#define SetWindowTextU          SetWindowTextW
#define DialogBoxParamU         DialogBoxParamW
#define GetDlgItemTextU         GetDlgItemTextW
#define SetDlgItemTextU         SetDlgItemTextW
#define MessageBoxU     MessageBoxW
#define LCMapStringU            LCMapStringW
#define GetDateFormatU          GetDateFormatW
#define GetTimeFormatU          GetTimeFormatW
#define WinHelpU                WinHelpW
#define SendMessageU            SendMessageW
#define SendDlgItemMessageU     SendDlgItemMessageW
#define IsBadStringPtrU         IsBadStringPtrW
#define OutputDebugStringU      OutputDebugStringW
#define GetCommandLineU         GetCommandLineW
#define DrawTextU               DrawTextW

#define CreateEventU            CreateEventW
#define RegisterEventSourceU    RegisterEventSourceW
#define OpenEventU              OpenEventW
#define CreateMutexU            CreateMutexW
#define OpenMutexU              OpenMutexW

#define CreateFontIndirectU     CreateFontIndirectW

#endif // _M_IX86

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\exrwlck\exrwlck.cpp ===
//
// This file contains test implmentations of reader and writer locks.
// These are intended to be used with the template class in rw.h so that
// different implementations can be plugged in and tested.
// 
// The semantics of the read/write classes should be as follows : 
//	Functions CAN NOT be recursively called,
//	Multiple Readers should be able to enter the lock 
//	Only a single writer may execute at a time.
//


#ifndef WIN16


#include	<windows.h>
#include	<limits.h>

#define Assert(x)	// Just define a dummy Assert, so we don't get
                    // compilation errors from exrwlck.h

#include	"exrwlck.h"

#ifdef	DEBUG
#ifndef	_VALIDATE
#define	_VALIDATE( f )	if( (f) ) ; else DebugBreak() 
#endif
#else
#ifndef	_VALIDATE
#define	_VALIDATE( f ) 
#endif
#endif

long	const	BlockValue = (-LONG_MAX) / 2; 
                            // Large in magnitude, negative value.  Used to 
                            // indicate a waiting writer in cReadLock


CExShareLock::CExShareLock( ) : cReadLock( 0  ), cOutRdrs( 0 )	{
    InitializeCriticalSection( &critWriters ) ;
    hWaitingWriters = CreateSemaphore( NULL, 0, 1, NULL ) ;
    hWaitingReaders = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
}

CExShareLock::~CExShareLock( ) {
    CloseHandle( hWaitingWriters ) ;
    CloseHandle( hWaitingReaders ) ;
    DeleteCriticalSection( &critWriters ) ;
}


void
CExShareLock::ShareLock( ) {
    long	sign = InterlockedIncrement( &cReadLock ) ;
    if( sign > 0 ) {
        return ;
    }	else 	{
        // There must be a writer in the lock.  Wait for him to leave.
        // The InterlockedIncrement recorded our presence so that the writer
        // can later release the correct number of threads.
        WaitForSingleObject( hWaitingReaders, INFINITE ) ;
    }
}

void
CExShareLock::ShareUnlock( ) {
    //
    // Leave the lock.  The return value will be negative if there is a writer
    // waiting.
    BOOL fWriterWaiting = InterlockedDecrement( &cReadLock ) < 0 ;

    if( fWriterWaiting ) {
        //
        // The following increment occurs when there is writer waiting, but
        // readers own the lock.  So although cReadLock is temporarily inaccurate
        // about the number of readers waiting for the lock, it is not inaccurate 
        // when it matters in WriteUnlock (which assumes a writer owns the lock.)
        //
        long junk = InterlockedIncrement( &cReadLock ) ;	// restore the value in cReadLock, so that we
                                                // end up with an accurate count of readers waiting
                                                // for entry.  

        long sign = InterlockedDecrement( &cOutRdrs ) ;	// Make sure we don't lose track of the 
                                                // number for readers who have left the lock.
        //
        // Are we the last reader out of the lock ?
        //
        if( sign == 0 ) {
            //
            // Definately the last reader out !
            //
            ReleaseSemaphore( hWaitingWriters, 1, &junk ) ;
        }
    }
}

void
CExShareLock::ExclusiveLock( ) {
    // Only one writer allowed to try for the lock at a time.
    //
    EnterCriticalSection( &critWriters ) ;

    //
    // Need to track the number of readers who leave the lock while we 
    // are trying to grab it.
    //
    cOutRdrs = 0 ;
    // Grab the lock 
 	long	oldsign = InterlockedExchange( &cReadLock, BlockValue ) ;
    // How many readers left while we grabbed the lock ??
    long	oldval = InterlockedExchange( &cOutRdrs, oldsign ) ;

    //
    // Accurately track all the readers who left the lock.
    //
    long	cursign = 1 ;	// Initialize to 1 so that if while loop not executed
                            // following if statement works correctly.
    while( oldval++ ) 
        cursign = InterlockedDecrement( &cOutRdrs ) ; 

    //
    // Do we own the lock ?  Only if there were no readers, or they have all left already.
    //
    if( oldsign == 0 || cursign == 0 ) {
        // We have the lock
    }	else	{
        // Wait for a reader to signal us.
        WaitForSingleObject( hWaitingWriters, INFINITE ) ;
    }
}



void
CExShareLock::ExclusiveUnlock( ) 	{

    // Estimate how many readers are waiting for the lock
    long	cWaiting = cReadLock - BlockValue ;

    // This Exchange allows any readers who have just arrived to grab the lock.
    // Also, it accounts for cWaiting of the blocked readers.
    long	cNewWaiting = InterlockedExchange( &cReadLock, cWaiting ) - BlockValue ;
    
    // cNewWaiting is the EXACT number of blocked readers - we will increment cReadLock
    // until we have accounted for the difference between our estimate and the correct
    // number !
    long	cTotal = cNewWaiting ;	// Save cNewWaiting for later use
    while( cNewWaiting-- > cWaiting ) 
        InterlockedIncrement( &cReadLock ) ;

    if( cTotal > 0 ) {
        long	junk = 0 ;
        ReleaseSemaphore( hWaitingReaders, cTotal, &junk ) ;	// let all those readers go!
    }
    // Let the next writer take his shot at the lock!
    LeaveCriticalSection( &critWriters ) ;
}


BOOL
CExShareLock::SharedToExclusive( )	{

    // tbd - implement this!
    return( FALSE ) ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\fntcache\fontcash.cpp ===
#include "pch.hxx"
#include "shlwapi.h"
#include "fontcash.h"
#include "strconst.h"
#include "inetreg.h"
#include "oleutil.h"
#include "msoedbg.h"
#include <tchar.h>
#include <wingdi.h>
#include "demand.h"


HRESULT CreateFontCacheEntry(FONTCACHEENTRY **ppNewEntry)
{
    HRESULT hr = S_OK;
    FONTCACHEENTRY* pNew;

    if (!MemAlloc((LPVOID *)&pNew, sizeof(FONTCACHEENTRY)))
        hr = E_OUTOFMEMORY;
    else
        {
        pNew->uiCodePage = 0;
        pNew->szFaceName[0] = TCHAR(0);
        for (int i = 0; i < FNT_SYS_LAST; i++)
            pNew->rgFonts[i] = 0;
        }
    *ppNewEntry = pNew;
    return S_OK;
}

void FreeFontsInEntry(FONTCACHEENTRY *pEntry)
{
    for (int i = 0; i < FNT_SYS_LAST; i++)
        if (pEntry->rgFonts[i])
            {
            DeleteObject(pEntry->rgFonts[i]);
            pEntry->rgFonts[i] = 0;
            }
}

HRESULT FreeFontCacheEntry(FONTCACHEENTRY *pEntry)
{
    Assert(pEntry);

    FreeFontsInEntry(pEntry);
    MemFree(pEntry);

    return S_OK;
}


// =================================================================================
// Font Cache Implementation
// =================================================================================

CFontCache::CFontCache(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter),
            m_pAdviseRegistry(NULL), m_pFontEntries(NULL), 
            m_pSysCacheEntry(NULL), m_bISO_2022_JP_ESC_SIO_Control(false),
            m_uiSystemCodePage(0)
{
    InitializeCriticalSection(&m_rFontCritSect);
    InitializeCriticalSection(&m_rAdviseCritSect);
}

//***************************************************
CFontCache::~CFontCache()
{
    if (m_pAdviseRegistry)
        m_pAdviseRegistry->Release();

    if (m_pFontEntries)
        m_pFontEntries->Release();

    if (m_pSysCacheEntry)
        FreeFontCacheEntry(m_pSysCacheEntry);

    DeleteCriticalSection(&m_rFontCritSect);
    DeleteCriticalSection(&m_rAdviseCritSect);
}

//***************************************************
HRESULT CFontCache::InitSysFontEntry()
{
    // Locals
    NONCLIENTMETRICS    ncm;
    CHARSETINFO         rCharsetInfo={0};
    UINT                nACP;
    HRESULT             hr = S_OK;
    LOGFONT             rSysLogFonts;

    Assert(m_pSysCacheEntry);

    // Get system ansi code page
    nACP = GetACP();
    m_pSysCacheEntry->uiCodePage = nACP;
    m_uiSystemCodePage = nACP;

    // Get the charset for the current ANSI code page
    TranslateCharsetInfo((DWORD *)IntToPtr(MAKELONG(nACP, 0)), &rCharsetInfo, TCI_SRCCODEPAGE);

    // Get icon font metrics
    if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &rSysLogFonts, 0))
        {
        lstrcpy(m_pSysCacheEntry->szFaceName, rSysLogFonts.lfFaceName);

        // Reset lfCharset depending on the current ansi code page
        rSysLogFonts.lfCharSet = (BYTE) rCharsetInfo.ciCharset;

        //$HACK - This code is necessary to work around a bug in Windows.
        //        If the icon font has never been changed from the default,
        //        SystemParametersInfo returns the wrong height.  We need
        //        to select the font into a DC and get the textmetrics to
        //        determine the correct height.  (EricAn)        
        HFONT hFont;
        if (hFont = CreateFontIndirect(&rSysLogFonts))
            {
            HDC hdc;
            if (hdc = GetDC(NULL))
                {
                TEXTMETRIC tm;
                HFONT hFontOld = SelectFont(hdc, hFont);
                GetTextMetrics(hdc, &tm);
                rSysLogFonts.lfHeight = -(tm.tmHeight - tm.tmInternalLeading);
                SelectFont(hdc, hFontOld);
                ReleaseDC(NULL, hdc);
                }
            DeleteObject(hFont);
            }
        if (m_pSysCacheEntry->rgFonts[FNT_SYS_ICON] == 0)
            m_pSysCacheEntry->rgFonts[FNT_SYS_ICON] = CreateFontIndirect(&rSysLogFonts);

        // Bold Icon Font
        if (m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_BOLD] == 0)
            {
            LONG lOldWeight = rSysLogFonts.lfWeight;
            rSysLogFonts.lfWeight = (rSysLogFonts.lfWeight < 700) ? 700 : 1000;
            m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_BOLD] = CreateFontIndirect(&rSysLogFonts);
            rSysLogFonts.lfWeight = lOldWeight;
            }

        if (m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_STRIKEOUT] == 0)
            {
            rSysLogFonts.lfStrikeOut = TRUE;
            m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_STRIKEOUT] = CreateFontIndirect(&rSysLogFonts);
            }
        }
    else
        {
        AssertSz (FALSE, "SystemParametersInfo (SPI_GETICONTITLELOGFONT) - Failed ---.");
        hr = E_FAIL;
        goto Exit;
        }
 
    if (m_pSysCacheEntry->rgFonts[FNT_SYS_MENU] == 0)
        {
#ifndef WIN16   // WIN16FF - SPI_GETNONCLIENTMETRICS
        // Prepare to get icon metrics
        ncm.cbSize = sizeof(ncm);
    
        // Get system menu font
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
            {
            CopyMemory((LPBYTE)&rSysLogFonts, (LPBYTE)&ncm.lfMenuFont, sizeof(LOGFONT));
            m_pSysCacheEntry->rgFonts[FNT_SYS_MENU] = CreateFontIndirect(&rSysLogFonts);
            }
        else
            {
            AssertSz (FALSE, "SystemParametersInfo (SPI_GETNONCLIENTMETRICS) - Failed ---.");
            hr = E_FAIL;
            goto Exit;
            }
#else
        m_pSysCacheEntry->rgFonts[FNT_SYS_MENU] = m_pSysCacheEntry->rgFonts[FNT_SYS_ICON];
#endif
        }
Exit:
    return hr;
}

//***************************************************
HRESULT CFontCache::GetSysFont(FNTSYSTYPE fntType, HFONT *phFont)
{
    // check params
    Assert(fntType < FNT_SYS_LAST);
    Assert(m_pSysCacheEntry);

    EnterCriticalSection(&m_rFontCritSect);

    // System Font
    if (m_pSysCacheEntry->rgFonts[fntType] == NULL)
        // This call might fail, but we can return NULL fonts, so is OK
        (void)InitSysFontEntry();

    // Done
    *phFont = m_pSysCacheEntry->rgFonts[fntType];

    LeaveCriticalSection(&m_rFontCritSect);

    return ((*phFont) ? S_OK : E_FAIL);
}

//***************************************************
HRESULT CFontCache::FreeResources()
{
    m_pFontEntries->ClearList();
    FreeFontsInEntry(m_pSysCacheEntry);

    return S_OK;
}

//***************************************************
HRESULT CFontCache::InitResources()
{
    DWORD dummyCookie = 0;

#ifdef DEBUG
    DWORD cCount;
    m_pFontEntries->GetCount(&cCount);
    Assert(cCount == 0);
#endif

    HRESULT hr = InitSysFontEntry();

    return hr;
}

//***************************************************
void CFontCache::SendPostChangeNotifications()
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)==S_OK)
        {
            pCurr->OnPostFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
}

//***************************************************
void CFontCache::SendPreChangeNotifications()
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)==S_OK)
        {
            pCurr->OnPreFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
}


//************************************
// IFontCache interface implementation
//************************************
HRESULT CFontCache::Init(HKEY hkey, LPCSTR pszIntlKey, DWORD dwFlags)
{
    HRESULT hr;
    DWORD   dummyCookie, dw, cb;
    HKEY    hTopkey;

    if (m_pSysCacheEntry)
        return E_UNEXPECTED;

    EnterCriticalSection(&m_rFontCritSect);
    EnterCriticalSection(&m_rAdviseCritSect);

    hr = IUnknownList_CreateInstance(&m_pAdviseRegistry);
    if (FAILED(hr))
        goto Exit;
    hr = m_pAdviseRegistry->Init(NULL, 0, 0);
    if (FAILED(hr))
        goto Exit;
    
    hr = IVoidPtrList_CreateInstance(&m_pFontEntries);
    if (FAILED(hr))
        goto Exit;

    hr = m_pFontEntries->Init(NULL, 0, (IVPL_FREEITEMFUNCTYPE)(&FreeFontCacheEntry), 0);
    if (FAILED(hr))
        goto Exit;

    hr = CreateFontCacheEntry(&m_pSysCacheEntry);
    if (FAILED(hr))
        goto Exit;

    hr = InitResources();
    if (FAILED(hr))
        goto Exit;

    m_hkey = hkey;
    lstrcpyn(m_szIntlKeyPath, pszIntlKey, ARRAYSIZE(m_szIntlKeyPath));
    if (RegOpenKeyEx(m_hkey, m_szIntlKeyPath, NULL, KEY_READ, &hTopkey) == ERROR_SUCCESS)
        {
        cb = sizeof(dw);
        if (RegQueryValueEx(hTopkey, c_szISO2022JPControl, NULL, NULL, (LPBYTE)&dw, &cb) == ERROR_SUCCESS)
            m_bISO_2022_JP_ESC_SIO_Control = (BOOL) dw;
        else
            m_bISO_2022_JP_ESC_SIO_Control = false;
        RegCloseKey(hTopkey);
        }
    else
        m_bISO_2022_JP_ESC_SIO_Control = false;

Exit:
    LeaveCriticalSection(&m_rAdviseCritSect);
    LeaveCriticalSection(&m_rFontCritSect);

    return hr;
}

//***************************************************
HRESULT CFontCache::GetFont(FNTSYSTYPE fntType, HCHARSET hCharset, HFONT *phFont)
{
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = 0;
    FONTCACHEENTRY  *pCurrEntry = NULL;
    DWORD           cookie = 0;

    // check params
    Assert(fntType < FNT_SYS_LAST);

    Assert(m_pSysCacheEntry);

    if (hCharset == NULL)
        return GetSysFont(fntType, phFont);

    *phFont = 0;

    /* get CodePage from HCHARSET */
    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
    uiCodePage = (CP_JAUTODETECT == CsetInfo.cpiWindows) ? 932 : CsetInfo.cpiWindows;
    if ( uiCodePage == CP_KAUTODETECT )
        uiCodePage = 949 ;

    // Don't want to duplicate the system codepage in the list.
    if (m_pSysCacheEntry && (uiCodePage == m_uiSystemCodePage))
        return GetSysFont(fntType, phFont);

    EnterCriticalSection(&m_rFontCritSect);
    
    // Check to see if code page is in cache
    while (SUCCEEDED(m_pFontEntries->GetNext(LD_FORWARD, (LPVOID *)&pCurrEntry, &cookie)))
        if (pCurrEntry->uiCodePage == uiCodePage)
            break;

    // If code page not in cache, add it
    if (NULL == pCurrEntry)
        {
        if (FAILED(CreateFontCacheEntry(&pCurrEntry)))
            goto ErrorExit;
        if (FAILED(m_pFontEntries->AddItem(pCurrEntry, &cookie)))
            goto ErrorExit;
        pCurrEntry->uiCodePage = uiCodePage;
        }

    // See if desired font is available for code page. If not, create code page
    if (0 == pCurrEntry->rgFonts[fntType])
        {
        // Locals
        LOGFONT lf;
        TCHAR  szFaceName[LF_FACESIZE] = { TCHAR(0) } ;
        BYTE bGDICharset;

        // Get logfont for charset
        if (0 == GetObject(m_pSysCacheEntry->rgFonts[fntType], sizeof (LOGFONT), &lf))
            goto ErrorExit;

        if (FAILED(SetGDIAndFaceNameInLF(uiCodePage, CsetInfo.cpiWindows, &lf)))
            goto ErrorExit;

        // Create the font
        if ((CP_UNICODE == uiCodePage) || IsValidCodePage(uiCodePage))
            pCurrEntry->rgFonts[fntType] = CreateFontIndirect(&lf);
        else
            goto ErrorExit;
        }

    *phFont = pCurrEntry->rgFonts[fntType];

    LeaveCriticalSection(&m_rFontCritSect);

    return S_OK;

ErrorExit:
    LeaveCriticalSection(&m_rFontCritSect);
    return GetSysFont(fntType, phFont);
}

//***************************************************
HRESULT CFontCache::OnOptionChange()
{
    HRESULT hr;
    
    EnterCriticalSection(&m_rAdviseCritSect);
    SendPreChangeNotifications();
    EnterCriticalSection(&m_rFontCritSect);

    FreeResources();
    // Even if this fails, still need to send notifications
    InitResources();

    LeaveCriticalSection(&m_rFontCritSect);    
    SendPostChangeNotifications();
    LeaveCriticalSection(&m_rAdviseCritSect);    

    return S_OK;
}

//***************************************************
HRESULT CFontCache::GetJP_ISOControl(BOOL *pfUseSIO)
{
    // 0 means use ESC, 1 means use SIO
    *pfUseSIO = m_bISO_2022_JP_ESC_SIO_Control;

    return S_OK;
}

//******************************************
// IConnectionPoint interface implementation
//
// The only functions we care about right now
// are the Advise and Unadvise functions. The
// others return E_NOTIMPL
//******************************************
HRESULT CFontCache::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)        
{
    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->AddItem(pUnkSink, pdwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
HRESULT CFontCache::Unadvise(DWORD dwCookie)        
{
    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->RemoveItem(dwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
HRESULT CFontCache::GetConnectionInterface(IID *pIID)        
{
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFontCache::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    *ppCPC = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFontCache::EnumConnections(IEnumConnections **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFontCache::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CFontCache::PrivateQueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IFontCache))
        *lplpObj = (LPVOID)(IFontCache *)this;
    else if (IsEqualIID(riid, IID_IConnectionPoint))
        *lplpObj = (LPVOID)(IConnectionPoint *)this;
    else
        {
        *lplpObj = NULL;
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}



//***************************************************
// szFaceName is assumed to be from LOGFONT->lfFaceName
HRESULT CFontCache::SetFaceNameFromReg(UINT uiCodePage, LPTSTR szFaceName)
{
    HKEY    hkey, hTopkey;
    DWORD   cb, dw, i = 0;
    TCHAR   szName[LF_FACESIZE];

    szFaceName[0] = TCHAR(0);

    if (RegOpenKeyEx(m_hkey, m_szIntlKeyPath, NULL, KEY_READ, &hTopkey) == ERROR_SUCCESS)
        {
        cb = sizeof(szName);
        while (ERROR_NO_MORE_ITEMS != RegEnumKeyEx(hTopkey, i++, szName, &cb, 0, NULL, NULL, NULL))
            {
            UINT uiTempCodePage = StrToInt(szName);
            if (uiTempCodePage == uiCodePage)
                {
                if (RegOpenKeyEx(hTopkey, szName, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
                    {
                    cb = sizeof(TCHAR)*LF_FACESIZE;
                    RegQueryValueEx(hkey, REGSTR_VAL_PROP_FONT, NULL, NULL, (LPBYTE)szFaceName, &cb);

                    RegCloseKey(hkey);
                    break;
                    }
                }
            cb = sizeof(szName);
            }
        RegCloseKey(hTopkey);
        }

    if (TCHAR(0) == szFaceName[0])
        return E_FAIL;

    return S_OK;
}

// =================================================================================
// EnumFontFamExProc
// =================================================================================
INT CALLBACK EnumFontFamExProc (ENUMLOGFONTEX   *lpelfe,	
                                NEWTEXTMETRICEX *lpntme, 
                                INT              FontType,
                                LPARAM           lParam)
{
    // Check Param
    Assert (lpelfe && lpntme && lParam);

    // Lets take the first font we get
    lstrcpyn ((LPTSTR)lParam, lpelfe->elfLogFont.lfFaceName, LF_FACESIZE);

    // End the enumeration by return 0
    return 0;
}

//***************************************************
// szFaceName is assumed to be from LOGFONT->lfFaceName
HRESULT CFontCache::SetFaceNameFromGDI(BYTE bGDICharSet, LPTSTR szFaceName)
{
    HDC     hdc;
    LOGFONT rSysLogFont;

    // I know these charsets support Arial
    if (bGDICharSet == ANSI_CHARSET    || bGDICharSet == EASTEUROPE_CHARSET ||
        bGDICharSet == RUSSIAN_CHARSET || bGDICharSet == BALTIC_CHARSET     ||
        bGDICharSet == GREEK_CHARSET   || bGDICharSet == TURKISH_CHARSET)
        {
        lstrcpy(szFaceName, _T("Arial"));
        goto Exit;
        }

    if (0 == GetObject(m_pSysCacheEntry->rgFonts[FNT_SYS_ICON], sizeof (LOGFONT), &rSysLogFont))
        {
        lstrcpyn(szFaceName, rSysLogFont.lfFaceName, LF_FACESIZE);
        if (TCHAR(0) != szFaceName[0])
            goto Exit;
        }

    // Get an hdc from the hwnd
    hdc = GetDC (NULL);

    // EnumFontFamilies
    EnumFontFamiliesEx(hdc, &rSysLogFont, (FONTENUMPROC)EnumFontFamExProc, (LPARAM)szFaceName, 0);

    // Done
    ReleaseDC (NULL, hdc);

Exit:
    return (0 != *szFaceName) ? S_OK : E_FAIL;
}

//***************************************************
// szFaceName is assumed to be from LOGFONT->lfFaceName
HRESULT CFontCache::SetFaceNameFromCPID(UINT cpID, LPTSTR szFaceName)
{
    CODEPAGEINFO CodePageInfo ;

    /* get CodePageInfo from HCHARSET */
    MimeOleGetCodePageInfo(cpID,&CodePageInfo);
    if ( CodePageInfo.szVariableFont[0] != '\0' )
        lstrcpyn(szFaceName, CodePageInfo.szVariableFont, LF_FACESIZE);
    else
        lstrcpyn(szFaceName, CodePageInfo.szFixedFont, LF_FACESIZE);

    if (szFaceName[0] == '\0')
        return E_FAIL;
    
    return S_OK;
}

//***************************************************
HRESULT CFontCache::SetGDIAndFaceNameInLF(UINT uiCodePage, CODEPAGEID cpID, LOGFONT *lpLF)
{
    HRESULT     hr = S_OK;
    BOOL        fDoLastChance = false;
    CHARSETINFO rCharsetInfo;

    if (FAILED(SetFaceNameFromReg(uiCodePage, lpLF->lfFaceName)))
        if (FAILED(SetFaceNameFromCPID(cpID, lpLF->lfFaceName)))
            fDoLastChance = true;

    if ( TranslateCharsetInfo((LPDWORD) IntToPtr(uiCodePage), &rCharsetInfo, TCI_SRCCODEPAGE))
        lpLF->lfCharSet = (BYTE) rCharsetInfo.ciCharset;
    else
        lpLF->lfCharSet = DEFAULT_CHARSET;

    if (fDoLastChance)
        hr = SetFaceNameFromGDI(lpLF->lfCharSet, lpLF->lfFaceName);

    return hr;
}

//***************************************************
HRESULT CFontCache::CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CFontCache *pNew = new CFontCache(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = (IFontCache*)pNew;

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\davprops.h ===
// --------------------------------------------------------------------------------
// davprops.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------


#ifndef _DAVPROPS_H__
#define _DAVPROPS_H__

#define PROP_DAV(name, value)      HMELE_DAV_##name,
#define PROP_HTTP(name, value)     HMELE_HTTPMAIL_##name,
#define PROP_HOTMAIL(name, value)  HMELE_HOTMAIL_##name,
#define PROP_MAIL(name, value)     HMELE_MAIL_##name,
#define PROP_CONTACTS(name, value) HMELE_CONTACTS_##name,

enum HMELE
{
    HMELE_UNKNOWN = 0,
    #include "davdef.h"
    HMELE_LAST
};

#endif // _DAVPROPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\davparse.h ===
#ifndef __DAVPARSE_H_
#define __DAVPARSE_H_

#include "davprops.h"

#define DAV_STR_LEN(name) \
    c_szwDAV##name, ulDAV##name##Len

typedef struct tagHMDICTINFO
{
    DWORD       dwNamespaceID;
    const char* pszName;
} HMDICTINFO, *LPHMDICTINFO;

EXTERN_C const HMDICTINFO rgHTTPMailDictionary[];

class CXMLNamespace
{
public:
    CXMLNamespace(CXMLNamespace *pParent = NULL);

    ULONG AddRef(void);
    ULONG Release(void);
private:
    ~CXMLNamespace(void);

    // unimplemented
    CXMLNamespace(const CXMLNamespace& other);
    CXMLNamespace& operator=(const CXMLNamespace& other);

public:
    HRESULT Init(
            const WCHAR *pwcNamespace,
            ULONG ulNsLen,
            const WCHAR* pwcPrefix,
            ULONG ulPrefix);

    HRESULT SetNamespace(const WCHAR *pwcNamespace, ULONG ulNsLen);
    HRESULT SetPrefix(const WCHAR *pwcPrefix, ULONG ulPrefix);

    DWORD MapPrefix(
                const WCHAR *pwcPrefix, 
                ULONG ulPrefixLen)
    {
        return _MapPrefix(pwcPrefix, ulPrefixLen);
    }

    void SetParent(CXMLNamespace* pParent)
    {
        SafeRelease(m_pParent);
        m_pParent = pParent;
        if (m_pParent)
            m_pParent->AddRef();
    }

    CXMLNamespace* GetParent(void)
    {
        if (m_pParent)
            m_pParent->AddRef();
        
        return m_pParent;
    }

private:
    DWORD _MapPrefix(const WCHAR *pwcPrefix, ULONG ulPrefixLen, BOOL *pbFoundDefault = NULL);

private:
    ULONG           m_cRef;
    CXMLNamespace   *m_pParent;
    WCHAR           *m_pwcPrefix;
    ULONG           m_ulPrefixLen;
    DWORD           m_dwNsID;
};

HMELE XMLElementToID(
            const WCHAR *pwcText,
            ULONG ulLen,
            ULONG ulNamespaceLen,
            CXMLNamespace *pNamespace);
    
#endif // __DAVPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\asynconn.h ===
/*
 *    asynconn.h
 *    
 *    Purpose:
 *        prototypes for the async connection class
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Apr 96: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#ifndef __ASYNCONN_H__
#define __ASYNCONN_H__

#include "thorsspi.h"

interface ILogFile;

typedef struct tagRECVBUFQ * PRECVBUFQ;
typedef struct tagRECVBUFQ {
    PRECVBUFQ   pNext;
    int         cbLen;
    char        szBuf[1];
} RECVBUFQ;
        
// this is structure for server's ignorable errors
typedef struct _SRVIGNORABLEERROR 
{
    TCHAR *pchServerName;
    HRESULT hrError;
    struct _SRVIGNORABLEERROR * pLeft;
    struct _SRVIGNORABLEERROR * pRight;
} SRVIGNORABLEERROR, *LPSRVIGNORABLEERROR;

void FreeSrvErr(LPSRVIGNORABLEERROR pSrvErr);

// This interface takes the place of any call to AtheMessageBox in asynconn.cpp. The
// user of the CAsyncConn class must provide an implementation of this interface.
interface IAsyncConnPrompt : IUnknown
{
    // This method works very much like MessageBox. It is expected that the implementor
    // of this method will display a MessageBox. For example:
    //
    // int CPOP3AsyncConnPrompt::OnPrompt(HRESULT hrError, 
    //                                    LPCTSTR pszText, 
    //                                    LPCTSTR pszCaption, 
    //                                    UINT    uType)
    // {
    //     Assert(pszText && pszCaption);
    //     return MessageBox(m_hwnd, pszText, pszCaption, uType);
    // }
    //
    // The user can compare against the hrError if they want to display their own
    // error messages for the corresponding HRESULT.
    // 
    virtual int OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType) PURE;
};

typedef enum {
    AS_DISCONNECTED,
    AS_RECONNECTING,
    AS_LOOKUPINPROG,
    AS_LOOKUPDONE,
    AS_CONNECTING,
    AS_CONNECTED,
    AS_HANDSHAKING,
} ASYNCSTATE;

typedef enum {
    AE_NONE,
    AE_LOOKUPDONE,
    AE_CONNECTDONE,
    AE_RECV,
    AE_SENDDONE,
    AE_CLOSE,
    AE_WRITE,
    AE_TIMEOUT
} ASYNCEVENT;

interface IAsyncConnCB : IUnknown
{
    virtual void  OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae) = 0;
};

class CAsyncConnNotify : public IAsyncConnCB
{
public:
    CAsyncConnNotify(HWND hwnd, UINT msg) 
    { 
        m_hwnd = hwnd;
        m_msg = msg; 
        m_cRef = 1; 
    }
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP_(ULONG) AddRef(void)  
    { 
        return ++m_cRef; 
    }
    STDMETHODIMP_(ULONG) Release(void) 
    { 
        if (--m_cRef == 0) 
            { 
            delete this; 
            return 0; 
            } 
        return m_cRef; 
    }
    virtual void  OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae) 
    {
#ifndef WIN16
        PostMessage(m_hwnd, m_msg, MAKEWPARAM(asOld, asNew), (LPARAM)ae);
#else
        PostMessage(m_hwnd, m_msg, (WPARAM)ae, MAKELPARAM(asOld, asNew));
#endif // !WIN16
    }

private:
    ULONG m_cRef;
    HWND  m_hwnd;
    UINT  m_msg;
};

class CAsyncConn
{
public:
    CAsyncConn(ILogFile *pLogFile, IAsyncConnCB *pCB, IAsyncConnPrompt *pPrompt);
    ~CAsyncConn();

    // ISocketCB methods
    virtual ULONG AddRef(void);
    virtual ULONG Release(void);
    virtual void  OnNotify(UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT HrInit(char *szServer, int iDefaultPort, BOOL fSecure = FALSE, DWORD dwTimeout=0);
    HRESULT Connect();
    HRESULT Close();
    HRESULT ReadLine(char **ppszBuf, int *pcbRead);
    HRESULT ReadLines(char **ppszBuf, int *pcbRead, int *pcLines);
    HRESULT ReadBytes(char **ppszBuf, int cbBytesWanted, int *pcbRead);
    HRESULT SendBytes(const char *pszBuf, int cbBuf, int *pcbSent, BOOL fStuffDots=FALSE, CHAR *pchPrev=NULL);
    HRESULT SendStream(LPSTREAM pStream, int *pcbSent, BOOL fStuffDots=FALSE);
#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif
#endif // WIN16
    int     GetLastError() { return m_iLastError; }
    int     GetConnectStatusString();

    ULONG   UlGetSendByteCount(VOID);

    void StartWatchDog(void);
    void StopWatchDog(void);
    void OnWatchDogTimer(void);

    HRESULT SetWindow(void);
    HRESULT ResetWindow(void);
    
    HRESULT TryNextSecurityPkg();

private:
    void    ChangeState(ASYNCSTATE asNew, ASYNCEVENT ae);
    HRESULT HrStuffDots(CHAR *pchPrev, LPSTR pszIn, INT cbIn, LPSTR *ppszOut, INT *pcbOut);
    HRESULT AsyncConnect();
    HRESULT OnLookupDone(int iLastError);
    HRESULT OnConnect();
    HRESULT OnClose(ASYNCSTATE asNew);
    HRESULT OnRead();
    HRESULT OnDataAvail(LPSTR szRecv, int iRecv, BOOL fIncomplete);
    HRESULT OnWrite();
    HRESULT IReadLines(char **ppszBuf, int *pcbRead, int *pcLines, BOOL fOne);
    HRESULT ReadAllBytes(char **ppszBuf, int *pcbRead);
    HRESULT OnSSLError();
    HRESULT OnRecvHandshakeData();

    void   CleanUp();    
    void   EnterPausedState();
    void   LeavePausedState();
    HWND   CreateWnd();
    static LRESULT CALLBACK SockWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

private:
    ULONG            m_cRef;
    CHAR             m_chPrev;
    BOOL             m_fStuffDots;
    ULONG            m_cbSent;
    SOCKET           m_sock;
    BOOL             m_fLookup;
    ASYNCSTATE       m_state;
    SOCKADDR_IN      m_sa;
    BOOL             m_fCachedAddr;
    BOOL             m_fRedoLookup;
    LPSTR            m_pszServer;
    u_short          m_iDefaultPort;
    int              m_iLastError;
    CRITICAL_SECTION m_cs;
    ILogFile *       m_pLogFile;
    IAsyncConnCB *   m_pCB;
    IAsyncConnPrompt *m_pPrompt;
    DWORD            m_cbQueued;
    char *           m_lpbQueued;
    char *           m_lpbQueueCur;
    LPSTREAM         m_pStream;
    PRECVBUFQ        m_pRecvHead;
    PRECVBUFQ        m_pRecvTail;
    int              m_iRecvOffset;
    BOOL             m_fNeedRecvNotify;
    HWND             m_hwnd;
    BOOL             m_fNegotiateSecure;
    BOOL             m_fSecure;
    CtxtHandle       m_hContext;
    int              m_iCurSecPkg;
    LPSTR            m_pbExtra;
    int              m_cbExtra;

    // For Timeout Handling
    DWORD            m_dwLastActivity;
    DWORD            m_dwTimeout;
    UINT_PTR         m_uiTimer;
#ifdef DEBUG
    int              m_cLock;
#endif
    BOOL             m_fPaused;
    DWORD            m_dwEventMask;
};

#endif // __ASYNCONN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\fntcache\list.h ===
#ifndef _LIST_H
#define _LIST_H

#include "msoedbg.h"
// =================================================================================
// CNode class definition and implementation
// =================================================================================
template<class Value_T>
class CNode   
{
private:
    CNode<Value_T> *m_pNext,
                   *m_pPrev; 
    Value_T         m_pValue;

public:
    CNode<Value_T>(): m_pNext(NULL), m_pPrev(NULL), m_pValue(0) {}

    CNode<Value_T>* GetNext() {return m_pNext;}
    CNode<Value_T>* GetPrev() {return m_pPrev;}

    void SetNext(CNode<Value_T> *pNext) {m_pNext = pNext;}
    void SetPrev(CNode<Value_T> *pPrev) {m_pPrev = pPrev;}

    Value_T GetValue() {return m_pValue;}

    static HRESULT CreateNode(CNode<Value_T> **ppNode, Value_T value);
};

//***************************************************
template<class Value_T>
HRESULT CNode<Value_T>::CreateNode(CNode<Value_T> **ppNode, Value_T value)
{
    HRESULT hr = S_OK;

    CNode<Value_T> *pNode = new CNode<Value_T>;
    if (NULL == pNode)
        {
        hr = E_OUTOFMEMORY;
        goto Exit;
        }
    
    pNode->m_pValue = value;

Exit:
    *ppNode = pNode;
    return hr;
}

// =================================================================================
// CList template class
// Basic list for keeping some class Value_T
// Value_T must have AddRef and Release defined
// =================================================================================

template<class Value_T>
class CList
{
private:
    CNode<Value_T> *m_pHead;
    ULONG           m_cCount;

public:
    CList<Value_T>();
    ~CList<Value_T>();
    void ClearList();

    ULONG GetCount() {return m_cCount;}

    HRESULT AddValue(Value_T value, DWORD *pdwCookie);
    HRESULT RemoveValue(DWORD dwCookie);
    HRESULT GetNext(Value_T *value, DWORD *pdwCookie);
};

// =================================================================================
// CList function implementaions
// =================================================================================
template<class Value_T>
CList<Value_T>::CList<Value_T>(): m_pHead(NULL), m_cCount(0)
{
}

//***************************************************
template<class Value_T>
CList<Value_T>::~CList<Value_T>()
{
    ClearList();
}

//***************************************************
template<class Value_T>
void CList<Value_T>::ClearList()
{
    CNode<Value_T> *pNext;
                        
    while (m_pHead)
        {
        pNext = m_pHead->GetNext();
        (m_pHead->GetValue())->Release();
        delete m_pHead;
        m_pHead = pNext;
        }
    m_cCount = 0;
}

//***************************************************
template<class Value_T>
HRESULT CList<Value_T>::AddValue(Value_T value, DWORD *pdwCookie)
{
    CNode<Value_T> *pNode = NULL;

    HRESULT hr = CNode<Value_T>::CreateNode(&pNode, value);
    if (SUCCEEDED(hr))
        {
        value->AddRef();
        m_cCount++;
        if (m_pHead)
            {
            m_pHead->SetPrev(pNode);
            pNode->SetNext(m_pHead);
            }
        m_pHead = pNode;
        *pdwCookie = reinterpret_cast<DWORD>(pNode);
        }
    else
        *pdwCookie = 0;
    return hr;
}


//***************************************************
template<class Value_T>
HRESULT CList<Value_T>::RemoveValue(DWORD dwCookie)
{
    CNode<Value_T>  *pCurr = reinterpret_cast< CNode<Value_T>* >(dwCookie);
    CNode<Value_T>  *pPrev = pCurr->GetPrev(),
                    *pNext = pCurr->GetNext();

    Assert(pCurr);

    if (pPrev)
        pPrev->SetNext(pNext);
    else
        m_pHead = pNext;

    if (pNext)
        pNext->SetPrev(pPrev);

    (pCurr->GetValue())->Release();
    delete pCurr;
    m_cCount--;

    return S_OK;
}

//***************************************************
// *pdwCookie must equal 0 for first time.
template<class Value_T>
HRESULT CList<Value_T>::GetNext(Value_T *pValue, DWORD* pdwCookie)
{
    CNode<Value_T> *pNode = reinterpret_cast< CNode<Value_T>* >(*pdwCookie);
    if (0 == m_cCount)
        return E_FAIL;

    if (pNode)
        {
        pNode = pNode->GetNext();
        if (!pNode)
            {
            *pdwCookie = 0;
            *pValue = 0;
            return E_FAIL;
            }
        }
    else
        pNode = m_pHead;


    if (pNode)
        {
        *pValue = pNode->GetValue();
        *pdwCookie = reinterpret_cast<DWORD>(pNode);
        (*pValue)->AddRef();
        }
    else
        {
        *pValue = NULL;
        *pdwCookie = 0;
        }
    return S_OK;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\fntcache\fontcash.h ===
#ifndef _FONTCASH_H
#define _FONTCASH_H

#include "privunk.h"
#include "mimeole.h"
#include "msoert.h"
#include <ocidl.h>

typedef struct FONTCACHEENTRY_tag 
{
    UINT            uiCodePage;
    TCHAR           szFaceName[LF_FACESIZE];
    HFONT           rgFonts[FNT_SYS_LAST];
} FONTCACHEENTRY, *PFONTCACHEENTRY;

// =================================================================================
// Font Cache Definition
// =================================================================================
class CFontCache :  public CPrivateUnknown, 
                    public IFontCache, 
                    public IConnectionPoint
{
private:
    HRESULT InitResources();
    HRESULT FreeResources();

    void SendPostChangeNotifications();
    void SendPreChangeNotifications();

    HRESULT InitSysFontEntry();
    HRESULT GetSysFont(FNTSYSTYPE fntType, HFONT *phFont);

    HRESULT SetGDIAndFaceNameInLF(UINT uiCodePage, CODEPAGEID cpID, LOGFONT *lpLF);
    HRESULT SetFaceNameFromCPID(UINT cpID, LPTSTR szFaceName);
    HRESULT SetFaceNameFromGDI(BYTE bGDICharSet, LPTSTR szFaceName);
    HRESULT SetFaceNameFromReg(UINT uiCodePage, LPTSTR szFaceName);

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    IUnknownList       *m_pAdviseRegistry;
    IVoidPtrList       *m_pFontEntries;
    FONTCACHEENTRY      *m_pSysCacheEntry;
    HKEY                m_hkey;
    TCHAR               m_szIntlKeyPath[1024];
    CRITICAL_SECTION    m_rFontCritSect,
                        m_rAdviseCritSect;
    BOOL                m_bISO_2022_JP_ESC_SIO_Control;
    UINT                m_uiSystemCodePage;

public:
    CFontCache(IUnknown *pUnkOuter=NULL);
    virtual ~CFontCache();
    
    // IUnknown members
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // IFontCache functions
    virtual HRESULT STDMETHODCALLTYPE Init(HKEY hkey, LPCSTR pszIntlKey, DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE GetFont(
                    FNTSYSTYPE fntType, 
                    HCHARSET hCharset,
                    HFONT *phFont);

    virtual HRESULT STDMETHODCALLTYPE OnOptionChange();

    virtual HRESULT STDMETHODCALLTYPE GetJP_ISOControl(BOOL *pfUseSIO);

    // IConnectionPoint functions
    virtual HRESULT STDMETHODCALLTYPE GetConnectionInterface(IID *pIID);        

    virtual HRESULT STDMETHODCALLTYPE GetConnectionPointContainer(
                    IConnectionPointContainer **ppCPC);

    virtual HRESULT STDMETHODCALLTYPE Advise(IUnknown *pUnkSink, DWORD *pdwCookie);        

    virtual HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwCookie);        

    virtual HRESULT STDMETHODCALLTYPE EnumConnections(IEnumConnections **ppEnum);

    static HRESULT CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\asynconn.cpp ===
/*
 *    asynconn.cpp
 *    
 *    Purpose:
 *        implementation of the async connection class
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Apr 96: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#include <pch.hxx>
#include <process.h>
#include "imnxport.h"
#include "dllmain.h"
#include "asynconn.h"
#include "thorsspi.h"
#include "resource.h"
#include "strconst.h"
#include "lookup.h"
#include <demand.h>
#include <shlwapi.h>

ASSERTDATA

#define STREAM_BUFSIZE  8192
#define FLOGSESSION  (m_pLogFile && TRUE /* profile setting to enable logging should be here */)

// These are the notification messages that we register for the asynchronous
// socket operations that we use.
#define SPM_WSA_SELECT          (WM_USER + 1)

// Async Timer Message used for doing Timeouts
#define SPM_ASYNCTIMER          (WM_USER + 3)

#ifdef DEBUG
#define EnterCS(_pcs)                   \
            {                           \
            EnterCriticalSection(_pcs); \
            m_cLock++;                  \
            IxpAssert(m_cLock > 0);     \
            }
#define LeaveCS(_pcs)                   \
            {                           \
            m_cLock--;                  \
            IxpAssert(m_cLock >= 0);    \
            LeaveCriticalSection(_pcs); \
            }
#else
#define EnterCS(_pcs)                   \
            EnterCriticalSection(_pcs);
#define LeaveCS(_pcs)                   \
            LeaveCriticalSection(_pcs);
#endif

BOOL FEndLine(char *psz, int iLen);

static const char s_szConnWndClass[] = "ThorConnWndClass";

extern LPSRVIGNORABLEERROR g_pSrvErrRoot;

// This function try to find server and ignorable error, assigned to this server
// if not found then add to list and set ignorable error to S_OK

LPSRVIGNORABLEERROR FindOrAddServer(TCHAR * pchServerName, LPSRVIGNORABLEERROR pSrvErr, LPSRVIGNORABLEERROR  *ppSrv)
{
    int i = 0;

    // if we already had entry in tree then recurse search
    if(pSrvErr)
    {
        i = lstrcmpi(pchServerName, pSrvErr->pchServerName);
        if(i > 0)
        {
            pSrvErr->pRight = FindOrAddServer(pchServerName, pSrvErr->pRight, ppSrv);
            return(pSrvErr);
        }
        else if(i < 0)
        {
            pSrvErr->pLeft = FindOrAddServer(pchServerName, pSrvErr->pLeft, ppSrv);
            return(pSrvErr);
        }
        else
        {
            *ppSrv = pSrvErr;
            return(pSrvErr);
        }
    }

    // if we don't have node, create it
    i = lstrlen(pchServerName);

    // if server name is empty return
    if(i == 0)
        return(NULL);


    // Allocate memory for structure
    if (!MemAlloc((LPVOID*)&pSrvErr, sizeof(SRVIGNORABLEERROR)))
        return(NULL);

    pSrvErr->pRight = NULL;
    pSrvErr->pLeft = NULL;
    pSrvErr->hrError = S_OK;

    if (!MemAlloc((LPVOID*)&(pSrvErr->pchServerName), i+1))
    {
        MemFree(pSrvErr);
        return(NULL);
    }

    lstrcpy(pSrvErr->pchServerName, pchServerName);

    *ppSrv = pSrvErr;

    return(pSrvErr);
}

void FreeSrvErr(LPSRVIGNORABLEERROR pSrvErr)
{
    // if structure NULL return immediately
    if(!pSrvErr)
        return;

    FreeSrvErr(pSrvErr->pRight);
    FreeSrvErr(pSrvErr->pLeft);

    if(pSrvErr->pchServerName)
    {
        MemFree(pSrvErr->pchServerName);
        pSrvErr->pchServerName = NULL;
    }

    MemFree(pSrvErr);
    pSrvErr = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// 
// PUBLIC METHODS - these need to be synchronized as they are accessed by the
//                  owning thread and the asynchronous socket pump thread.
//
/////////////////////////////////////////////////////////////////////////////

CAsyncConn::CAsyncConn(ILogFile *pLogFile, IAsyncConnCB *pCB, IAsyncConnPrompt *pPrompt)
{
    m_cRef = 1;
    m_chPrev = '\0';
    m_fStuffDots = FALSE;
    m_sock = INVALID_SOCKET;
    m_fLookup = FALSE;
    m_state = AS_DISCONNECTED;
    m_fCachedAddr = FALSE;
    m_fRedoLookup = FALSE;
    m_pszServer = NULL;
    m_iDefaultPort = 0;
    m_iLastError = 0;
    InitializeCriticalSection(&m_cs);
    m_pLogFile = pLogFile;
    if (m_pLogFile)
        m_pLogFile->AddRef();
    Assert(pCB);
    m_pCB = pCB;
    m_cbQueued = 0;
    m_lpbQueued = m_lpbQueueCur = NULL;
    m_pStream = NULL;
    m_pRecvHead = m_pRecvTail = NULL;
    m_iRecvOffset = 0;
    m_fNeedRecvNotify = FALSE;
    m_hwnd = NULL;
    m_fNegotiateSecure = FALSE;
    m_fSecure = FALSE;
    ZeroMemory(&m_hContext, sizeof(m_hContext));
    m_iCurSecPkg = 0; // current security package being tried
    m_pbExtra = NULL;
    m_cbExtra = 0;
    m_cbSent = 0;
    m_pPrompt = pPrompt;
    m_dwLastActivity = 0;
    m_dwTimeout = 0;
    m_uiTimer = 0;
#ifdef DEBUG
    m_cLock = 0;
#endif
    m_fPaused = FALSE;
    m_dwEventMask = 0;
}

CAsyncConn::~CAsyncConn()
{
    DOUT("CAsyncConn::~CAsyncConn %lx: m_cRef = %d", this, m_cRef);

    // Bug #22622 - We need to make sure there isn't a timer pending
    StopWatchDog();

    Assert(!m_fLookup);
    SafeMemFree(m_pszServer);
    SafeRelease(m_pLogFile);
    CleanUp();
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);
    DeleteCriticalSection(&m_cs);
#ifdef DEBUG
    IxpAssert(m_cLock == 0);
#endif
}

ULONG CAsyncConn::AddRef(void)
{
    ULONG cRefNew;

    EnterCS(&m_cs);
    DOUT("CAsyncConn::AddRef %lx ==> %d", this, m_cRef+1);
    cRefNew = ++m_cRef;
    LeaveCS(&m_cs);

    return cRefNew;
}

ULONG CAsyncConn::Release(void)
{
    ULONG cRefNew;

    EnterCS(&m_cs);
    DOUT("CAsyncConn::Release %lx ==> %d", this, m_cRef-1);
    cRefNew = --m_cRef;
    LeaveCS(&m_cs);

    if (cRefNew == 0)
        delete this;
    return cRefNew;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::HrInit
//
//   Allocates recv buffer, sets servername, servicename, and port
//
HRESULT CAsyncConn::HrInit(char *szServer, int iDefaultPort, BOOL fSecure, DWORD dwTimeout)
{
    HRESULT hr = NOERROR;

    EnterCS(&m_cs);

    if (!m_hwnd && !CreateWnd())
        {
        hr = E_FAIL;
        goto error;
        }

    if (m_state != AS_DISCONNECTED)
        {
        hr = IXP_E_ALREADY_CONNECTED;
        goto error;
        }

    Assert(szServer);

    // if nothing has changed, then use the current settings
    if (m_pszServer && 
        !lstrcmpi(m_pszServer, szServer) && 
        (iDefaultPort == m_iDefaultPort) && 
        (fSecure == m_fNegotiateSecure))
        goto error;

    m_fCachedAddr = FALSE;
    m_fRedoLookup = FALSE;
    SafeMemFree(m_pszServer);
    if (!MemAlloc((LPVOID*)&m_pszServer, lstrlen(szServer)+1))
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }
    lstrcpy(m_pszServer, szServer);

    Assert(iDefaultPort > 0);
    m_iDefaultPort = (u_short) iDefaultPort;
    m_fNegotiateSecure = fSecure;

    // If dwTimeout == 0, no timeout detection will be installed.
    m_dwTimeout = dwTimeout;

error:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::SetWindow
//
//  creates a window used by async. winsock. ResetWindow()
//	must be called before invoking this function, so as to avoid
//  window handle leakage.
//
HRESULT CAsyncConn::SetWindow(void)
{
    HRESULT hr = NOERROR;

    EnterCS(&m_cs);

    if (NULL != m_hwnd && IsWindow(m_hwnd) && 
            GetWindowThreadProcessId(m_hwnd, NULL) == GetCurrentThreadId())
        {
            // no need to create the new window for this thread
            goto error;
        }
    else if (NULL != m_hwnd && IsWindow(m_hwnd))
        {
            // leaks one window handle; the previous worker thread 
            // didn't call ResetWindow().
            Assert(FALSE);
        }

    if (!CreateWnd())
        {
           hr = E_FAIL;
           goto error;
        }

    if (m_sock != INVALID_SOCKET)
        {
        if (SOCKET_ERROR == WSAAsyncSelect(m_sock, m_hwnd, SPM_WSA_SELECT, FD_READ|FD_WRITE|FD_CLOSE))
            {
            m_iLastError = WSAGetLastError();
            hr = IXP_E_CONN;
            goto error;
            }
        }

error:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ResetWindow
//
//   closes the window used by async. winsock
//
HRESULT CAsyncConn::ResetWindow(void)
{
    HRESULT hr = NOERROR;

    EnterCS(&m_cs);

    if ((NULL == m_hwnd) || (FALSE == IsWindow(m_hwnd)))
        goto error;

    if (GetWindowThreadProcessId(m_hwnd, NULL) == GetCurrentThreadId())
        {
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);
        m_hwnd = NULL;
        }
    else
        {
        // A caller forgot to call ResetWindow. Only the owner thread can destroy
        // the window.
        Assert(FALSE);
        }

error:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::Connect
//
//   starts the name lookup and connection process
//
HRESULT CAsyncConn::Connect()
{
    HRESULT hr;
    HANDLE  hThreadLookup;
    BOOL    fNotify = FALSE;
    BOOL    fAsync = FALSE;

    EnterCS(&m_cs);

    if (m_state != AS_DISCONNECTED && m_state != AS_RECONNECTING)
        {
        hr = IXP_E_ALREADY_CONNECTED;
        goto error;
        }

    Assert(m_pszServer);

    if (FLOGSESSION) 
        {
        char szBuffer[512], lb[256];
        if (LoadString(g_hLocRes, idsNlogIConnect, lb, 256)) 
            {
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), lb, m_pszServer, m_iDefaultPort);
            m_pLogFile->DebugLog(szBuffer);
            }
        }

    ZeroMemory(&m_sa, sizeof(m_sa));
    m_sa.sin_port = htons(m_iDefaultPort);
    m_sa.sin_family = AF_INET;
    m_sa.sin_addr.s_addr = inet_addr(m_pszServer);

    if (m_sa.sin_addr.s_addr != -1)
        // server name is dotted decimal, so no need to look it up
        fAsync = TRUE;
    else
        {
        // Start a name lookup on a separate thread because WinSock caches the DNS server in TLS.
        // The separate thread enables us to connect to a LAN DNS and a RAS DNS in the same session.

        hr = LookupHostName(m_pszServer, m_hwnd, &(m_sa.sin_addr.s_addr), &m_fCachedAddr, m_fRedoLookup);
        if (SUCCEEDED(hr))
            {
            m_fLookup = fNotify = !m_fCachedAddr;
            fAsync = m_fCachedAddr;
            }
        else
            {
            m_iLastError = WSAENOBUFS;
            hr = IXP_E_CONN;
            }
        }

error:
    LeaveCS(&m_cs);
    if (fAsync)
        hr = AsyncConnect();
    if (fNotify)
        ChangeState(AS_LOOKUPINPROG, AE_NONE);
    return hr;
}

void CAsyncConn::StartWatchDog(void)
{
    if (m_dwTimeout < 5) m_dwTimeout =  30;
    m_dwLastActivity = GetTickCount();
    Assert(m_hwnd);
    StopWatchDog();
    m_uiTimer = SetTimer(m_hwnd, SPM_ASYNCTIMER, 5000, NULL);
}

void CAsyncConn::StopWatchDog(void)
{
    if (m_uiTimer)
    {
        KillTimer(m_hwnd, SPM_ASYNCTIMER);
        m_uiTimer = 0;
    }
}

void CAsyncConn::OnWatchDogTimer(void)
{
    BOOL        fNotify = FALSE;
    ASYNCSTATE  as;

    EnterCS(&m_cs);
    if (((GetTickCount() - m_dwLastActivity) / 1000) >= m_dwTimeout)
        {
        fNotify = TRUE;
        as = m_state;
        }
    LeaveCS(&m_cs);

    if (fNotify)
        ChangeState(as, AE_TIMEOUT);        
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::Close
//
//   closes the connection
//
HRESULT CAsyncConn::Close()
{
    BOOL fNotify = FALSE;
    BOOL fClose = FALSE;

    EnterCS(&m_cs);
    if (m_fLookup)
        {
        CancelLookup(m_pszServer, m_hwnd);
        m_fLookup = FALSE;
        fNotify = TRUE;
        }
    fClose = (m_sock != INVALID_SOCKET);
    LeaveCS(&m_cs);

    if (fNotify)
        ChangeState(AS_DISCONNECTED, AE_LOOKUPDONE);

    if (fClose)
        OnClose(AS_DISCONNECTED);

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ReadLine
//
// Purpose: retrieves a single complete line from the buffered data
//
// Args:    ppszBuf - pointer to receive allocated buffer, caller must free
//          pcbRead - pointer to receive line length
//
// Returns: NOERROR - a complete line was read
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//
// Comments:
//  If IXP_E_INCOMPLETE is returned, the caller will recieve an AE_RECV event
//  the next time a complete line is available.
//
HRESULT CAsyncConn::ReadLine(char **ppszBuf, int *pcbRead)
{
    HRESULT     hr;
    int         iLines;

    EnterCS(&m_cs);

    hr = IReadLines(ppszBuf, pcbRead, &iLines, TRUE);

    LeaveCS(&m_cs);
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ReadLines
//
// Purpose: retrieves all available complete lines from the buffered data
//
// Args:    ppszBuf - pointer to receive allocated buffer, caller must free
//          pcbRead - pointer to receive line length
//          pcLines - pointer to receive number or lines read
//
// Returns: NOERROR - a complete line was read
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//
// Comments:
//  If IXP_E_INCOMPLETE is returned or if there is extra data buffered after the
//  the last complete line, the caller will recieve an AE_RECV event
//  the next time a complete line is available.
//
HRESULT CAsyncConn::ReadLines(char **ppszBuf, int *pcbRead, int *pcLines)
{
    HRESULT     hr;

    EnterCS(&m_cs);

    hr = IReadLines(ppszBuf, pcbRead, pcLines, FALSE);

    LeaveCS(&m_cs);
    return hr;    
}



/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ReadBytes
//
// Purpose:
//   This function returns up to the number of bytes requested, from the
// current head buffer.
//
// Arguments:
//   char **ppszBuf [out] - this function returns a pointer to an allocated
//     buffer, if successful. It is the caller's responsibility to MemFree
//     this buffer.
//   int cbBytesWanted [in] - the number of bytes requested by the caller.
//      The requested number of bytes may be returned, or less.
//   int *pcbRead [out] - the number of bytes returned in ppszBuf.
//
// Returns: NOERROR - success. Either the remainder of the current buffer
//                    was returned, or the number of bytes asked for.
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//          E_INVALIDARG - NULL arguments
//
// Comments:
//  If the caller wishes to receive an AE_RECV event the next time data has
// been received from the server, he must either call ReadLines (once), or
// he must continue to call ReadBytes or ReadLine until IXP_E_INCOMPLETE is
// returned.
//
HRESULT CAsyncConn::ReadBytes(char **ppszBuf, int cbBytesWanted, int *pcbRead)
{
    int iNumBytesToReturn, i;
    char *pResult, *p;
    HRESULT hrResult;
    BOOL bResult;

    // Check arguments
    if (NULL == ppszBuf || NULL == pcbRead) {
        AssertSz(FALSE, "Check your arguments, buddy");
        return E_INVALIDARG;
    }

    // Initialize variables
    *ppszBuf = NULL;
    *pcbRead = 0;
    hrResult = NOERROR;

    EnterCS(&m_cs);

    if (NULL == m_pRecvHead) {
        hrResult = IXP_E_INCOMPLETE;
        goto exit;
    }

    // Get a buffer to return the results in and fill it in
    iNumBytesToReturn = min(m_pRecvHead->cbLen - m_iRecvOffset, cbBytesWanted);
    bResult = MemAlloc((void **)&pResult, iNumBytesToReturn + 1); // Leave room for null-term
    if (FALSE == bResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }
    CopyMemory(pResult, m_pRecvHead->szBuf + m_iRecvOffset, iNumBytesToReturn);
    *(pResult + iNumBytesToReturn) = '\0'; // Null-terminate the buffer
    // The null-term should never be read, but doing so allows us to return a
    // buffer for when 0 bytes are requested, instead of returning a NULL pointer.

    // Advance our position in the current buffer
    m_iRecvOffset += iNumBytesToReturn;
    if (m_iRecvOffset >= m_pRecvHead->cbLen) {
        PRECVBUFQ pTemp;

        Assert(m_iRecvOffset == m_pRecvHead->cbLen);

        // This buffer's done, advance to the next buffer in the chain
        pTemp = m_pRecvHead;
        m_pRecvHead = m_pRecvHead->pNext;
        if (NULL == m_pRecvHead)
            m_pRecvTail = NULL;
        m_iRecvOffset = 0;
        MemFree(pTemp);
    }

    // Search and destroy nulls: apparently some servers can send these,
    // and most parsing code can't handle it
    for (i = 0, p = pResult; i < iNumBytesToReturn; i++, p++)
        if (*p == '\0')
            *p = ' ';

exit:
    // This is the only time we reset the AE_RECV trigger
    if (IXP_E_INCOMPLETE == hrResult)
        m_fNeedRecvNotify = TRUE;

    LeaveCS(&m_cs);

    if (NOERROR == hrResult) {
        *ppszBuf = pResult;
        *pcbRead = iNumBytesToReturn;
    }
    return hrResult;
} // ReadBytes



/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::UlGetSendByteCount
//
ULONG CAsyncConn::UlGetSendByteCount(VOID)
{
    return m_cbSent;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::HrStuffDots
//
//   Makes sure that leading dots are stuffed
//
#define CB_STUFF_GROW 256
HRESULT CAsyncConn::HrStuffDots(CHAR *pchPrev, LPSTR pszIn, INT cbIn, LPSTR *ppszOut,
    INT *pcbOut)
    {
    // Locals
    HRESULT hr=S_OK;
    int     iIn=0;
    int     iOut=0;
    LPSTR   pszOut=NULL;
    int     cbOut=NULL;

    // Invalid Arg
    Assert(pchPrev);
    Assert(pszIn);
    Assert(cbIn);
    Assert(ppszOut);
    Assert(pcbOut);

    // Set cbOut
    cbOut = cbIn;

    // Allocate
    CHECKHR(hr = HrAlloc((LPVOID *)&pszOut, cbIn));

    // Setup Loop
    while (iIn < cbIn)
        {
        // Need a realloc
        if (iOut + 3 > cbOut)
            {
            // Allocate a buffer
            CHECKHR(hr = HrRealloc((LPVOID *)&pszOut, cbOut + CB_STUFF_GROW));

            // Set cbAlloc
            cbOut += CB_STUFF_GROW;
            }

        // Dot at the start of a line...
        if ('.' == pszIn[iIn] && ('\0' == *pchPrev || '\r' == *pchPrev || '\n' == *pchPrev))
            {
            // Write this dot across
            pszOut[iOut++] = pszIn[iIn++];

            // Stuff the dot
            pszOut[iOut++] = '.';

            // Set pchPrev
            *pchPrev = '.';
            }
        else
            {
            // Remember Previous Character
            *pchPrev = pszIn[iIn];

            // Write
            pszOut[iOut++] = pszIn[iIn++];
            }
        }

    // Set Source
    *ppszOut = pszOut;
    *pcbOut = iOut;

exit:
    return(hr);
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::SendBytes
//
//   sends data to the socket
//
HRESULT CAsyncConn::SendBytes(const char *pszIn, int cbIn, int *pcbSent, 
    BOOL fStuffDots /* FALSE */, CHAR *pchPrev /* NULL */)
{
    HRESULT hr;
    int     iSent=0;
    int     iSentTotal=0;
    LPSTR   pszBuf=NULL;
    LPSTR   pszFree=NULL;
    LPSTR   pszFree2=NULL;
    LPSTR   pszSource=(LPSTR)pszIn;
    LPSTR   pszStuffed=NULL;
    int     cbStuffed;
    int     cbBuf;
    int     cbSource=cbIn;

    EnterCS(&m_cs);
    
    Assert(pszSource && cbSource);
#ifdef DEBUG
    if (m_cbQueued)
        DebugBreak();
#endif
//    Assert(!m_cbQueued);
    Assert(!m_lpbQueued);
    Assert(!m_lpbQueueCur);

    if (m_state < AS_CONNECTED)
        {
        hr = IXP_E_NOT_CONNECTED;
        goto error;
        }

    if (fStuffDots)
        {
        if (FAILED(HrStuffDots(pchPrev, pszSource, cbSource, &pszStuffed, &cbStuffed)))
            {
            hr = E_FAIL;
            goto error;
            }

        pszSource = pszStuffed;
        cbSource = cbStuffed;
        }

    if (m_fSecure)
        {
        SECURITY_STATUS scRet;
        scRet = EncryptData(&m_hContext, (LPVOID)pszSource, cbSource, (LPVOID*)&pszBuf, &cbBuf);
        if (scRet != ERROR_SUCCESS)
            {
            hr = E_FAIL;
            goto error;
            }
        pszFree = pszBuf;
        }
    else
        {
        pszBuf = (LPSTR)pszSource;
        cbBuf = cbSource;
        }

    while (cbBuf && ((iSent = send(m_sock, pszBuf, cbBuf, 0)) != SOCKET_ERROR))
        {
        iSentTotal += iSent;
        pszBuf += iSent;
        cbBuf -= iSent;
        }

    if (cbBuf)
        {
        m_iLastError = WSAGetLastError();
        hr = IXP_E_CONN_SEND;
        if (WSAEWOULDBLOCK == m_iLastError)
            {
            if (MemAlloc((LPVOID*)&m_lpbQueued, cbBuf))
                {
                m_cbQueued = cbBuf;
                m_lpbQueueCur = m_lpbQueued;
                CopyMemory(m_lpbQueued, pszBuf, cbBuf);
                hr = IXP_E_WOULD_BLOCK;
                }
            else
                hr = E_OUTOFMEMORY;
            }
        }
    else
        hr = NOERROR;

error:
    *pcbSent = iSentTotal;
    LeaveCS(&m_cs);
    if (pszFree)
        g_pMalloc->Free(pszFree);
    if (pszStuffed)
        g_pMalloc->Free(pszStuffed);
    return hr;        
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::SendStream
//
//   sends data to the socket
//
HRESULT CAsyncConn::SendStream(LPSTREAM pStream, int *pcbSent, BOOL fStuffDots /* FALSE */)
{
    HRESULT hr;
    char    rgb[STREAM_BUFSIZE];  //$REVIEW - should we heap allocate this instead?
    DWORD   cbRead;
    int     iSent, iSentTotal = 0;

    EnterCS(&m_cs);

    Assert(pStream && pcbSent);
    Assert(!m_cbQueued);
    Assert(!m_lpbQueued);
    Assert(!m_lpbQueueCur);
    Assert(!m_pStream);

    if (m_state < AS_CONNECTED)
        {
        hr = IXP_E_NOT_CONNECTED;
        goto error;
        }

    HrRewindStream(pStream);

    m_chPrev = '\0';
    m_fStuffDots = fStuffDots;

    while (SUCCEEDED(hr = pStream->Read(rgb, STREAM_BUFSIZE, &cbRead)) && cbRead) 
        {
        hr = SendBytes(rgb, cbRead, &iSent, m_fStuffDots, &m_chPrev);
        iSentTotal += iSent;
        if (FAILED(hr))
            {
            if (WSAEWOULDBLOCK == m_iLastError)
                {
                // hang onto the stream
                m_pStream = pStream;
                m_pStream->AddRef();
                }
            break;
            }
        }

error:
    *pcbSent = iSentTotal;
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnNotify
//
//   called for network events that we have registered interest in
//
void CAsyncConn::OnNotify(UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD       dwLookupThreadId;
    SOCKET      sock;
    ASYNCSTATE  state;

    EnterCS(&m_cs);
    sock = m_sock;
    state = m_state;
    LeaveCS(&m_cs);

    switch (msg)
        {
        case SPM_WSA_GETHOSTBYNAME:
            EnterCS(&m_cs);
            m_sa.sin_addr.s_addr = (ULONG)lParam;
            m_iLastError = (int)wParam;
            if (FLOGSESSION)
                {
                char szBuffer[512];
                if (m_iLastError)
                    {
                    char lb[256];
                    if (LoadString(g_hLocRes, idsErrConnLookup, lb, 256)) 
                        {
                        wsprintf(szBuffer, lb, m_iLastError);
                        m_pLogFile->DebugLog(szBuffer);
                        }
                    }
                else
                    {
                    wsprintf(szBuffer, 
                             "srv_name = \"%.200s\" srv_addr = %.200s\r\n", 
                             m_pszServer,
                             inet_ntoa(m_sa.sin_addr)); 
                    m_pLogFile->DebugLog(szBuffer);
                    }
                }
            LeaveCS(&m_cs);
            OnLookupDone((int)wParam);
            break;

        case SPM_WSA_SELECT:
            if (wParam == (WPARAM)sock)
                {
                EnterCS(&m_cs);
                m_iLastError = WSAGETSELECTERROR(lParam);
                if (m_iLastError && FLOGSESSION)
                    {
                    char szBuffer[256], lb[256];
                    if (LoadString(g_hLocRes, idsErrConnSelect, lb, 256)) 
                        {
                        wsprintf(szBuffer, lb, WSAGETSELECTEVENT(lParam), m_iLastError);
                        m_pLogFile->DebugLog(szBuffer);
                        }
                    }
                if (m_fPaused)
                    {
                    m_dwEventMask |= WSAGETSELECTEVENT(lParam);
                    LeaveCS(&m_cs);
                    break;
                    }
                LeaveCS(&m_cs);
                switch (WSAGETSELECTEVENT(lParam))
                    {
                    case FD_CONNECT:
                        OnConnect();
                        break;
                    case FD_CLOSE:
                        if (AS_HANDSHAKING == state)
                            OnSSLError();
                        else
                            OnClose(AS_DISCONNECTED);
                        break;
                    case FD_READ:
                        OnRead();
                        break;
                    case FD_WRITE:
                        OnWrite();
                        break;
                    }
                }
            else
                DOUTL(2, 
                      "Got notify for old socket = %x, evt = %x, err = %x", 
                      wParam, 
                      WSAGETSELECTEVENT(lParam), 
                      WSAGETSELECTERROR(lParam));
            break;
        }
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::GetConnectStatusString
//
//   returns the string ID for the status
//
int CAsyncConn::GetConnectStatusString() 
{ 
    return idsNotConnected + (m_state - AS_DISCONNECTED); 
}

/////////////////////////////////////////////////////////////////////////////
// 
// PRIVATE METHODS
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::AsyncConnect
//
//   starts the connection process
//
HRESULT CAsyncConn::AsyncConnect()
{
    HRESULT hr = NOERROR;
    BOOL    fConnect = FALSE;

    EnterCS(&m_cs);
    if (!(AS_DISCONNECTED == m_state || AS_RECONNECTING == m_state || AS_LOOKUPDONE == m_state))
        {
        hr = IXP_E_INVALID_STATE;
        goto exitCS;
        }
    Assert(m_sa.sin_addr.s_addr != -1);

    if (m_sock == INVALID_SOCKET) 
        {
        if ((m_sock = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) 
            {
            m_iLastError = WSAGetLastError();
            hr = IXP_E_CONN;
            goto exitCS;
            }
        }

    if (SOCKET_ERROR == WSAAsyncSelect(m_sock, m_hwnd, SPM_WSA_SELECT, FD_CONNECT))
        {
        m_iLastError = WSAGetLastError();
        hr = IXP_E_CONN;
        goto exitCS;
        }
    LeaveCS(&m_cs);

    ChangeState(AS_CONNECTING, AE_NONE);

    EnterCS(&m_cs);
    if (connect(m_sock, (struct sockaddr *)&m_sa, sizeof(m_sa)) == SOCKET_ERROR)
        {
        m_iLastError = WSAGetLastError();
        if (WSAEWOULDBLOCK == m_iLastError)
            {
            // this is the expected result
            m_iLastError = 0;
            }
        else
            {
            if (FLOGSESSION)
                {
                char szBuffer[256], lb[256];
                if (LoadString(g_hLocRes, idsNlogErrConnError, lb, 256)) 
                    {
                    wsprintf(szBuffer, lb, m_iLastError);
                    m_pLogFile->DebugLog(szBuffer);
                    }
                }
            }
        }
    else
        {
        Assert(m_iLastError == 0);
        fConnect = TRUE;
        }
    LeaveCS(&m_cs);

    if (m_iLastError)
        {
        ChangeState(AS_DISCONNECTED, AE_NONE);
        return IXP_E_CONN;
        }
    else if (fConnect)
        OnConnect();

    return NOERROR;

exitCS:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnLookupDone
//
//   called once an async database lookup finishes
//
HRESULT CAsyncConn::OnLookupDone(int iLastError)
{
    ASYNCSTATE as;

    EnterCS(&m_cs);
    Assert(AS_LOOKUPINPROG == m_state);
    m_fLookup = FALSE;
    LeaveCS(&m_cs);

    if (iLastError)
        ChangeState(AS_DISCONNECTED, AE_LOOKUPDONE);
    else
        {
        ChangeState(AS_LOOKUPDONE, AE_LOOKUPDONE);
        AsyncConnect();
        }

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnConnect
//
//   called once a connection is established
//
HRESULT CAsyncConn::OnConnect()
{
    BOOL fConnect = FALSE;

    EnterCS(&m_cs);

    Assert(AS_CONNECTING == m_state);

    if (!m_iLastError)
        {
        BOOL fTrySecure = m_fNegotiateSecure && FIsSecurityEnabled();
        if (SOCKET_ERROR == WSAAsyncSelect(m_sock, m_hwnd, SPM_WSA_SELECT, FD_READ|FD_WRITE|FD_CLOSE))
            {
            m_iLastError = WSAGetLastError();
            LeaveCS(&m_cs);
            return IXP_E_CONN;
            }
        LeaveCS(&m_cs);
        if (fTrySecure)
            TryNextSecurityPkg();
        else
            ChangeState(AS_CONNECTED, AE_CONNECTDONE);
        }
    else
        {
        LeaveCS(&m_cs);
        ChangeState(AS_DISCONNECTED, AE_CONNECTDONE);
        EnterCS(&m_cs);
        if (m_fCachedAddr && !m_fRedoLookup)
            {
            // maybe our cached address went bad - try one more time
            m_fRedoLookup = TRUE;
            fConnect = TRUE;
            }
        LeaveCS(&m_cs);
        if (fConnect)
            Connect();
        return IXP_E_CONN;
        }
    return NOERROR;                
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnClose
//
//   called when a connection is dropped
//
HRESULT CAsyncConn::OnClose(ASYNCSTATE asNew)
{
    MSG msg;

    EnterCS(&m_cs);
    // unregister and clean up the socket    
    Assert(m_sock != INVALID_SOCKET);
    closesocket(m_sock);
    m_sock = INVALID_SOCKET;
    if (FLOGSESSION && m_pszServer) 
        {
        char szBuffer[256], lb[256];
        if (LoadString(g_hLocRes, idsNlogErrConnClosed, lb, 256)) 
            {
            wsprintf(szBuffer, lb, m_pszServer);
            m_pLogFile->DebugLog(szBuffer);
            }
        }

    while (PeekMessage(&msg, m_hwnd, SPM_WSA_SELECT, SPM_WSA_GETHOSTBYNAME, PM_REMOVE))
        {
        DOUTL(2, "Flushing pending socket messages...");
        }
    LeaveCS(&m_cs);
    
    ChangeState(asNew, AE_CLOSE);
    EnterCS(&m_cs);
    CleanUp();
    LeaveCS(&m_cs);
    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnRead
//
//   called when an FD_READ notification is received
//
HRESULT CAsyncConn::OnRead()
{
    HRESULT hr;
    int     iRecv;
    char    szRecv[STREAM_BUFSIZE];

    EnterCS(&m_cs);
    if (m_state < AS_CONNECTED)
        {
        Assert(FALSE);
        LeaveCS(&m_cs);
        return IXP_E_NOT_CONNECTED;
        }

    iRecv = recv(m_sock, szRecv, sizeof(szRecv), 0);
    m_iLastError = WSAGetLastError();
    LeaveCS(&m_cs);

    if (SOCKET_ERROR == iRecv)
        {
        hr = IXP_E_CONN_RECV;
        }
    else if (iRecv == 0)
        {
        // this means the server has disconnected us.
        //$TODO - not sure what we should do here
        hr = IXP_E_NOT_CONNECTED;
        }
    else
        {
        hr = OnDataAvail(szRecv, iRecv, FALSE);
        }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnDataAvail
//
//   called when there is incoming data to be queued
//
HRESULT CAsyncConn::OnDataAvail(LPSTR pszRecv, int iRecv, BOOL fIncomplete)
{
    HRESULT     hr = NOERROR;
    BOOL        fNotify = FALSE, fHandshake = FALSE, fClose = FALSE;
    PRECVBUFQ   pNew;
    int         iQueue = 0;
    LPSTR       pszFree = NULL;
    ASYNCSTATE  as;

    EnterCS(&m_cs);

    if (m_state < AS_CONNECTED)
        {
        Assert(FALSE);
        hr = IXP_E_NOT_CONNECTED;
        goto error;
        }

    if (m_fSecure)
        {
        SECURITY_STATUS scRet;
        int             cbEaten = 0;

        if (m_cbExtra)
            {
            Assert(m_pbExtra);
            // there's data left over from the last call to DecryptData
            if (MemAlloc((LPVOID*)&pszFree, m_cbExtra + iRecv))
                {
                // combine the extra and new buffers
                CopyMemory(pszFree, m_pbExtra, m_cbExtra);
                CopyMemory(pszFree + m_cbExtra, pszRecv, iRecv);
                pszRecv = pszFree;
                iRecv += m_cbExtra;
                MemFree(m_pbExtra);
                m_pbExtra = NULL;
                m_cbExtra = 0;
                }
            else
                {
                hr = E_OUTOFMEMORY;
                goto error;
                }
            }
        scRet = DecryptData(&m_hContext, pszRecv, iRecv, &iQueue, &cbEaten);
        if (scRet == ERROR_SUCCESS || scRet == SEC_E_INCOMPLETE_MESSAGE)
            {
            if (cbEaten != iRecv)
                {
                // we need to save away the extra bytes until we receive more data
                Assert(cbEaten < iRecv);
                DOUTL(2, "cbEaten = %d, iRecv = %d, cbExtra = %d", cbEaten, iRecv, iRecv - cbEaten);
                if (MemAlloc((LPVOID*)&m_pbExtra, iRecv - cbEaten))
                    {
                    m_cbExtra = iRecv - cbEaten;
                    CopyMemory(m_pbExtra, pszRecv + cbEaten, m_cbExtra);
                    }
                else
                    {
                    hr = E_OUTOFMEMORY;
                    goto error;
                    }
                }
            if (scRet == SEC_E_INCOMPLETE_MESSAGE)
                goto error;
            }
        else
            {
            // security error, so disconnect.
            fClose = TRUE;
            hr = E_FAIL;
            goto error;
            }
        }
    else
        iQueue = iRecv;

    if (MemAlloc((LPVOID*)&pNew, sizeof(RECVBUFQ) + iQueue - sizeof(char)))
        {
        pNew->pNext = NULL;
        pNew->cbLen = iQueue;
        CopyMemory(pNew->szBuf, pszRecv, iQueue);
        if (m_pRecvTail)
            {
            m_pRecvTail->pNext = pNew;
            if ((AS_CONNECTED == m_state) && m_fNeedRecvNotify)
                fNotify = FEndLine(pszRecv, iQueue);
            }
        else
            {
            Assert(!m_pRecvHead);
            m_pRecvHead = pNew;
            if (AS_CONNECTED == m_state)
                {
                fNotify = FEndLine(pszRecv, iQueue);
                if (!fNotify)
                    m_fNeedRecvNotify = TRUE;
                }
            }
        m_pRecvTail = pNew;
        hr = NOERROR;
        }
    else
        {
        //$TODO - we should disconnect here and notify the caller
        hr = E_OUTOFMEMORY;
        }

    // notify the owner that there is at least one line of data available
    if (fNotify)
        {
        m_fNeedRecvNotify = FALSE;
        as = m_state;
        }
    else if (AS_HANDSHAKING == m_state && SUCCEEDED(hr) && !fIncomplete)
        {
        Assert(!m_fSecure);
        fHandshake = TRUE;
        }

    LeaveCS(&m_cs);

    if (fNotify)
        ChangeState(as, AE_RECV);
    else if (fHandshake)
        OnRecvHandshakeData();

    EnterCS(&m_cs);

error:
    LeaveCS(&m_cs);
    SafeMemFree(pszFree);
    if (fClose)
        Close();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnWrite
//
//   called when an FD_WRITE notification is received
//
HRESULT CAsyncConn::OnWrite()
{
    int         iSent;
    ASYNCEVENT  ae;
    ASYNCSTATE  as;

    EnterCS(&m_cs);

    m_cbSent = 0;

    if (m_state < AS_CONNECTED)
        {
        Assert(FALSE);
        LeaveCS(&m_cs);
        return IXP_E_NOT_CONNECTED;
        }

    if (m_cbQueued)
        {
        // send some more data from the queued buffer    
        while (m_cbQueued && ((iSent = send(m_sock, m_lpbQueueCur, m_cbQueued, 0)) != SOCKET_ERROR))
            {
            m_cbSent += iSent;
            m_lpbQueueCur += iSent;
            m_cbQueued -= iSent;
            }
        if (m_cbQueued)
            {
            m_iLastError = WSAGetLastError();
            if (WSAEWOULDBLOCK != m_iLastError)
                {
                //$TODO - handle this error somehow
                Assert(FALSE);
                }
            }
        else
            {
            MemFree(m_lpbQueued);
            m_lpbQueued = m_lpbQueueCur = NULL;
            }
        }

    if (m_pStream && !m_cbQueued)
        {
        char    rgb[STREAM_BUFSIZE];  //$REVIEW - should we heap allocate this instead?
        DWORD   cbRead;
        HRESULT hr;

        // send some more data from the queued stream
        while (SUCCEEDED(hr = m_pStream->Read(rgb, STREAM_BUFSIZE, &cbRead)) && cbRead) 
            {
            hr = SendBytes(rgb, cbRead, &iSent, m_fStuffDots, &m_chPrev);
            if (FAILED(hr))
                {
                if (WSAEWOULDBLOCK != m_iLastError)
                    {
                    //$TODO - handle this error somehow, probably free the stream
                    Assert(FALSE);
                    }
                break;
                }
            else
                m_cbSent += iSent;
            }
        if (!cbRead)
            {
            m_pStream->Release();
            m_pStream = NULL;
            }
        }
    
    as = m_state;
    if (!m_cbQueued)
        ae = AE_SENDDONE;
    else
        ae = AE_WRITE;

    LeaveCS(&m_cs);

    ChangeState(as, ae);
    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ChangeState
//
//   changes the connection state, notifies the owner
//
void CAsyncConn::ChangeState(ASYNCSTATE asNew, ASYNCEVENT ae)
{
    ASYNCSTATE      asOld;
    IAsyncConnCB   *pCB;

    EnterCS(&m_cs);
    asOld = m_state;
    m_state = asNew;
    m_dwLastActivity = GetTickCount();
    pCB = m_pCB;
    // pCB->AddRef(); $BUGBUG - we REALLY need to handle this, but IMAP4 doesn't call close before it's destructor
#ifdef DEBUG
    IxpAssert(m_cLock == 1);
#endif
    LeaveCS(&m_cs);

    pCB->OnNotify(asOld, asNew, ae);
    // pCB->Release();
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::IReadLines
//
// Purpose: retrieves one or all available complete lines from the buffer
//
// Args:    ppszBuf - pointer to receive allocated buffer, caller must free
//          pcbRead - pointer to receive line length
//          pcLines - pointer to receive number or lines read
//          fOne    - TRUE if only reading one line
//
// Returns: NOERROR - a complete line was read
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//
// Comments:
//  If IXP_E_INCOMPLETE is returned or if there is extra data buffered after the
//  the last complete line, the caller will recieve an AE_RECV event
//  the next time a complete line is available.
//
HRESULT CAsyncConn::IReadLines(char **ppszBuf, int *pcbRead, int *pcLines, BOOL fOne)
{
    HRESULT     hr;
    int         iRead = 0, iScan = 0, iLines = 0;
    char *      pszBuf = NULL;
    char *      psz;
    int         iOffset, iLeft;
    PRECVBUFQ   pRecv;
    BOOL        fFound = FALSE;

    if (!m_pRecvHead)
        {
        hr = IXP_E_INCOMPLETE;
        goto error;
        }

    pRecv = m_pRecvHead;
    iOffset = m_iRecvOffset;
    while (pRecv)
        {
        psz = pRecv->szBuf + iOffset;
        iLeft = pRecv->cbLen - iOffset;
        while (iLeft--)
            {
            iScan++;
            if (*psz++ == '\n')
                {
                iRead = iScan;
                iLines++;
                if (fOne)
                    {
#if 0
                    // One-eyed t-crash fix
                    while (iLeft > 0 && (*psz == '\r' || *psz == '\n'))
                        {
                        iLeft--;
                        iScan++;
                        psz++;
                        iRead++;
                        }
#endif
                    break;
                    }
                }
            }
        if (iLines && fOne)
            break;
        iOffset = 0;
        pRecv = pRecv->pNext;
        }

    if (iLines)
        {
        int iCopy = 0, cb;
        if (!MemAlloc((LPVOID*)&pszBuf, iRead + 1))
            {
            hr = E_OUTOFMEMORY;
            goto error;
            }
        while (iCopy < iRead)
            {
            cb = min(iRead-iCopy, m_pRecvHead->cbLen - m_iRecvOffset);
            CopyMemory(pszBuf + iCopy, m_pRecvHead->szBuf + m_iRecvOffset, cb);
            iCopy += cb;
            if (cb == (m_pRecvHead->cbLen - m_iRecvOffset))
                {
                PRECVBUFQ pTemp = m_pRecvHead;
                m_pRecvHead = m_pRecvHead->pNext;
                if (!m_pRecvHead)
                    m_pRecvTail = NULL;
                m_iRecvOffset = 0;
                MemFree(pTemp);
                }
            else
                {
                Assert(iCopy == iRead);    
                m_iRecvOffset += cb;
                }
            }

        for (iScan = 0, psz = pszBuf; iScan < iCopy; iScan++, psz++)
            if (*psz == 0)
                *psz = ' ';

        pszBuf[iCopy] = 0;
        hr = NOERROR;
        }
    else
        hr = IXP_E_INCOMPLETE;

    // set the flag to notify when a complete line is received
    if ((IXP_E_INCOMPLETE == hr) || (m_pRecvHead && !fOne))
        m_fNeedRecvNotify = TRUE;

error:
    *ppszBuf = pszBuf;
    *pcbRead = iRead;
    *pcLines = iLines;
    return hr;    
}

HRESULT CAsyncConn::ReadAllBytes(char **ppszBuf, int *pcbRead)
{
    HRESULT     hr = S_OK;
    int         iRead = 0, iCopy = 0, cb;
    char *      pszBuf = NULL;
    int         iOffset;
    PRECVBUFQ   pTemp;

    if (!m_pRecvHead)
        {
        hr = IXP_E_INCOMPLETE;
        goto error;
        }

    // calculate how much to copy
    pTemp = m_pRecvHead;
    iOffset = m_iRecvOffset;
    while (pTemp)
        {
        iCopy += pTemp->cbLen - iOffset;
        iOffset = 0;
        pTemp = pTemp->pNext;
        }

    if (!MemAlloc((LPVOID*)&pszBuf, iCopy))
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }

    while (m_pRecvHead)
        {
        cb = m_pRecvHead->cbLen - m_iRecvOffset;
        CopyMemory(pszBuf + iRead, m_pRecvHead->szBuf + m_iRecvOffset, cb);
        iRead += cb;
        pTemp = m_pRecvHead;
        m_pRecvHead = m_pRecvHead->pNext;
        if (!m_pRecvHead)
            m_pRecvTail = NULL;
        m_iRecvOffset = 0;
        MemFree(pTemp);
        }

    Assert(!m_pRecvHead && !m_iRecvOffset);

error:
    *ppszBuf = pszBuf;
    *pcbRead = iRead;
    return hr;
}

HWND CAsyncConn::CreateWnd()
{    
    WNDCLASS wc;

    if (!GetClassInfo(g_hLocRes, s_szConnWndClass, &wc))
        {
        wc.style            = 0;
        wc.lpfnWndProc      = CAsyncConn::SockWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hLocRes;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = s_szConnWndClass;
        RegisterClass(&wc);
        }

    m_hwnd = CreateWindowEx(0,
                            s_szConnWndClass,
                            s_szConnWndClass,
                            WS_POPUP,
                            CW_USEDEFAULT,    
                            CW_USEDEFAULT,    
                            CW_USEDEFAULT,    
                            CW_USEDEFAULT,    
                            NULL,
                            NULL,
                            g_hLocRes,
                            (LPVOID)this);
    return m_hwnd;
}

LRESULT CALLBACK CAsyncConn::SockWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAsyncConn *pThis = (CAsyncConn*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (msg)
        {
        case WM_TIMER:
            Assert(pThis);
            if (SPM_ASYNCTIMER == wParam && pThis)
                pThis->OnWatchDogTimer();
        break;

        case WM_NCCREATE:
            pThis = (CAsyncConn*)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);            
            break;

        case WM_NCDESTROY:
            pThis->m_hwnd = NULL;
            break;

        case SPM_WSA_SELECT:
        case SPM_WSA_GETHOSTBYNAME:
            pThis->OnNotify(msg, wParam, lParam);
            return 0;
        }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HRESULT CAsyncConn::TryNextSecurityPkg()
{
    HRESULT         hr = NOERROR;
    SecBuffer       OutBuffer;
    SECURITY_STATUS sc;

    EnterCS(&m_cs);
    sc = InitiateSecConnection(m_pszServer,
                               FALSE,
                               &m_iCurSecPkg,
                               &m_hContext,
                               &OutBuffer);
    LeaveCS(&m_cs);

    if (SEC_I_CONTINUE_NEEDED == sc)
        {
        if (FLOGSESSION)
            {
            char szBuffer[256], lb[256];
            if (LoadString(g_hLocRes, idsNegotiatingSSL, lb, 256)) 
                {
                EnterCS(&m_cs);
                wsprintf(szBuffer, lb, s_SecProviders[m_iCurSecPkg].pszName);
                m_pLogFile->DebugLog(szBuffer);
                LeaveCS(&m_cs);
                }
            }
        ChangeState(AS_HANDSHAKING, AE_CONNECTDONE);
        if (OutBuffer.cbBuffer && OutBuffer.pvBuffer)
            {
            int iSent;
            hr = SendBytes((char *)OutBuffer.pvBuffer, OutBuffer.cbBuffer, &iSent);
            g_FreeContextBuffer(OutBuffer.pvBuffer);
            }
        else
            {
            AssertSz(0, "Preventing a NULL, 0 sized call to send");
            }
        }
    else
        {
        // we can't connect securely, so error out and disconnect
        Close();
        }
    return hr;
}

HRESULT CAsyncConn::OnSSLError()
{
    HRESULT hr = NOERROR;
    BOOL    fReconnect;

    EnterCS(&m_cs);
    if (m_iCurSecPkg + 1 < g_cSSLProviders)
        {
        m_iCurSecPkg++;
        fReconnect = TRUE;
        }
    else
        {
        m_iCurSecPkg = 0;
        fReconnect = FALSE;
        }
    LeaveCS(&m_cs);

    if (fReconnect)
        {
        OnClose(AS_RECONNECTING);
        Connect();
        }
    else
        OnClose(AS_DISCONNECTED);

    return hr;
}

HRESULT CAsyncConn::OnRecvHandshakeData()
{
    HRESULT         hr;
    LPSTR           pszBuf;
    int             cbRead, cbEaten;
    SECURITY_STATUS sc;
    SecBuffer       OutBuffer;

    if (SUCCEEDED(hr = ReadAllBytes(&pszBuf, &cbRead)))
        {
        EnterCS(&m_cs);
        sc = ContinueHandshake(m_iCurSecPkg, &m_hContext, pszBuf, cbRead, &cbEaten, &OutBuffer);
        LeaveCS(&m_cs);
        // if there's a response to send, then do it
        if (OutBuffer.cbBuffer && OutBuffer.pvBuffer)
            {
            int iSent;
            hr = SendBytes((char *)OutBuffer.pvBuffer, OutBuffer.cbBuffer, &iSent);
            g_FreeContextBuffer(OutBuffer.pvBuffer);
            }
        if (sc == SEC_E_OK)
            {
            HRESULT hrCert;

            EnterCS(&m_cs);
            m_fSecure = TRUE;

            LPSRVIGNORABLEERROR pIgnorerror = NULL;
            g_pSrvErrRoot = FindOrAddServer(m_pszServer, g_pSrvErrRoot, &pIgnorerror);

            hrCert = ChkCertificateTrust(&m_hContext, m_pszServer);
            LeaveCS(&m_cs);

            if (hrCert && (!pIgnorerror || (hrCert != pIgnorerror->hrError)))
                {
                TCHAR   szError[CCHMAX_RES + CCHMAX_RES],
                        szPrompt[CCHMAX_RES],
                        szCaption[CCHMAX_RES];
                IAsyncConnPrompt *pPrompt;
                DWORD dw;
                const DWORD cLineWidth = 64;

                LoadString(g_hLocRes, idsSecurityErr, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hLocRes, idsInvalidCert, szError, ARRAYSIZE(szError));
                LoadString(g_hLocRes, idsIgnoreSecureErr, szPrompt, ARRAYSIZE(szPrompt));

                lstrcat(szError, c_szCRLFCRLF);
                dw = lstrlen(szError);
                if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | cLineWidth,
                                   NULL, hrCert, 0, szError+dw, ARRAYSIZE(szError)-dw, NULL))
                {
                    TCHAR szErrNum[16];

                    wsprintf(szErrNum, "0x%x", hrCert);
                    lstrcat(szError, szErrNum);
                }

                Assert(lstrlen(szError) + lstrlen(szPrompt) + lstrlen("\r\n\r\n") < ARRAYSIZE(szError));
                lstrcat(szError, c_szCRLFCRLF);
                lstrcat(szError, szPrompt);

                EnterCS(&m_cs);
                pPrompt = m_pPrompt;
                if (pPrompt)
                    pPrompt->AddRef();
                LeaveCS(&m_cs);
            
                EnterPausedState();
                if (pPrompt && IDYES == pPrompt->OnPrompt(hrCert, szError, szCaption, MB_YESNO | MB_ICONEXCLAMATION  | MB_SETFOREGROUND))
                    {
                    // Set ignorable error 
                    if(pIgnorerror)
                        pIgnorerror->hrError =  hrCert;

                    ChangeState(AS_CONNECTED, AE_CONNECTDONE);
                    if (cbEaten < cbRead)
                        {
                        // there were bytes left over, so hold onto them
                        hr = OnDataAvail(pszBuf + cbEaten, cbRead - cbEaten, sc == SEC_E_INCOMPLETE_MESSAGE);
                        }
                    LeavePausedState();
                    }
                else
                    Close();
        
                if (pPrompt)
                    pPrompt->Release();

                MemFree(pszBuf);
                return hr;
                }

            ChangeState(AS_CONNECTED, AE_CONNECTDONE);
            }
        else if (sc != SEC_I_CONTINUE_NEEDED && sc != SEC_E_INCOMPLETE_MESSAGE)
            {
            // unexpected error - we should reset the socket and try the next package
            DOUTL(2, "unexpected error from ContinueHandshake() - closing socket.");
            return OnSSLError();
            }
        else
            {
            Assert(sc == SEC_I_CONTINUE_NEEDED || sc == SEC_E_INCOMPLETE_MESSAGE);
            // stay inside the handshake loop, waiting for more data to arrive
            }
        if (cbEaten < cbRead)
            {
            // there were bytes left over, so hold onto them
            hr = OnDataAvail(pszBuf + cbEaten, cbRead - cbEaten, sc == SEC_E_INCOMPLETE_MESSAGE);
            }
        MemFree(pszBuf);
        }
    return hr;
}

void CAsyncConn::CleanUp()
{
    PRECVBUFQ pRecv = m_pRecvHead, pTemp;
    SafeMemFree(m_lpbQueued);
    m_lpbQueueCur = NULL;
    m_cbQueued = 0;
    SafeMemFree(m_pbExtra);
    m_cbExtra = 0;
    SafeRelease(m_pStream);
    while (pRecv)
        {
        pTemp = pRecv;
        pRecv = pRecv->pNext;
        MemFree(pTemp);
        }
    m_pRecvHead = m_pRecvTail = NULL;
    m_iRecvOffset = 0;
    m_iLastError = 0;
    m_fNeedRecvNotify = FALSE;
    m_fSecure = FALSE;
    m_fPaused = FALSE;
}

void CAsyncConn::EnterPausedState()
{
    EnterCS(&m_cs);
    m_fPaused = TRUE;
    m_dwEventMask = 0;
    StopWatchDog();
    LeaveCS(&m_cs);
}

void CAsyncConn::LeavePausedState()
{
    DWORD dwEventMask;

    EnterCS(&m_cs);
    m_fPaused = FALSE;
    dwEventMask = m_dwEventMask;
    LeaveCS(&m_cs);

    if (dwEventMask & FD_CLOSE)
        Close();
    else
        { 
        if (dwEventMask & FD_READ)
            OnRead();
        if (dwEventMask & FD_WRITE)
            OnWrite();
        }
}

/////////////////////////////////////////////////////////////////////////////
// 
// UTILITY FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
BOOL FEndLine(char *psz, int iLen)
{
    while (iLen--)
        {
        if (*psz++ == '\n')
            return TRUE;
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\davparse.cpp ===
#include <pch.hxx>
#include "davparse.h"
#include "strconst.h"
#include "shlwapi.h"

#define DEFINE_DAVSTRS
#include "davstrs.h"
#undef DEFINE_DAVSTRS

typedef struct tagELEINFO
{
    const WCHAR     *pwcTagName;
    ULONG           ulLen;
    HMELE           eleID;
} ELEINFO, *LPELEINFO;

typedef struct tagNAMESPACEINFO
{
    const WCHAR     *pszwNamespace;
    DWORD           dwLen;
    DWORD           dwNamespaceID;
} NAMESPACEINFO, *LPNAMESPACEINFO;

static const ELEINFO c_rgDavElements[] =
{
#define PROP_DAV(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_DAV_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgHTTPMailElements[] =
{
#define PROP_HTTP(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_HTTPMAIL_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgHotMailElements[] =
{
#define PROP_HOTMAIL(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_HOTMAIL_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgMailElements[] =
{
#define PROP_MAIL(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_MAIL_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgContactElements[] =
{
#define PROP_CONTACTS(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_CONTACTS_##prop },
#include "davdef.h"
};

const HMDICTINFO rgHTTPMailDictionary[] =
{
#define PROP_DAV(prop, value)      { DAVNAMESPACE_DAV, c_szDAV##prop },
#define PROP_HTTP(prop, value)     { DAVNAMESPACE_HTTPMAIL, c_szDAV##prop },
#define PROP_HOTMAIL(prop, value)  { DAVNAMESPACE_HOTMAIL, c_szDAV##prop },
#define PROP_MAIL(prop, value)     { DAVNAMESPACE_MAIL, c_szDAV##prop },
#define PROP_CONTACTS(prop, value) { DAVNAMESPACE_CONTACTS, c_szDAV##prop },

    { DAVNAMESPACE_UNKNOWN, NULL }, // HMELE_UNKNOWN
#include "davdef.h"
};

static NAMESPACEINFO c_rgNamespaceInfo[] =
{
    { DAV_STR_LEN(DavNamespace), DAVNAMESPACE_DAV },
    { DAV_STR_LEN(HTTPMailNamespace), DAVNAMESPACE_HTTPMAIL },
    { DAV_STR_LEN(HotMailNamespace), DAVNAMESPACE_HOTMAIL },
    { DAV_STR_LEN(MailNamespace), DAVNAMESPACE_MAIL },
    { DAV_STR_LEN(ContactsNamespace), DAVNAMESPACE_CONTACTS }
};

CXMLNamespace::CXMLNamespace(CXMLNamespace *pParent) : 
    m_cRef(1),
    m_pParent(NULL),
    m_pwcPrefix(NULL),
    m_ulPrefixLen(0),
    m_dwNsID(DAVNAMESPACE_UNKNOWN)
{
    if (NULL != pParent)
        SetParent(pParent);
}

CXMLNamespace::~CXMLNamespace(void)
{
    SafeRelease(m_pParent);
    SafeMemFree(m_pwcPrefix);
}

ULONG CXMLNamespace::AddRef(void)
{
    return (++m_cRef);
}

ULONG CXMLNamespace::Release(void)
{
    if (0 == --m_cRef)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CXMLNamespace::Init(
                        const WCHAR *pwcNamespace,
                        ULONG ulNSLen,
                        const WCHAR* pwcPrefix,
                        ULONG ulPrefixLen)
{
    HRESULT         hr = S_OK;
    
    if (FAILED(hr = SetPrefix(pwcPrefix, ulPrefixLen)))
        goto exit;

    hr = SetNamespace(pwcNamespace, ulNSLen);

exit:
    return hr;
}

HRESULT CXMLNamespace::SetNamespace(const WCHAR *pwcNamespace, ULONG ulLen)
{
    DWORD           dwIndex;
    LPNAMESPACEINFO pnsi = NULL;

    // determine if the namespace is known
    for (dwIndex = 0; dwIndex < ARRAYSIZE(c_rgNamespaceInfo); ++dwIndex)
    {
        pnsi = &c_rgNamespaceInfo[dwIndex];

        if ((ulLen == c_rgNamespaceInfo[dwIndex].dwLen) &&  (0 == StrCmpNW(pwcNamespace, c_rgNamespaceInfo[dwIndex].pszwNamespace, ulLen)))
        {
            m_dwNsID = c_rgNamespaceInfo[dwIndex].dwNamespaceID;
            break;
        }
    }

    return S_OK;
}

HRESULT CXMLNamespace::SetPrefix(const WCHAR *pwcPrefix, ULONG ulLen)
{
    HRESULT hr = S_OK;

    SafeMemFree(m_pwcPrefix);
    m_ulPrefixLen = 0;

    if (pwcPrefix && ulLen > 0)
    {
        // duplicate the prefix, and add it to the map
        if (!MemAlloc((void **)&m_pwcPrefix, sizeof(WCHAR) * ulLen))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        CopyMemory(m_pwcPrefix, pwcPrefix, sizeof(WCHAR) * ulLen);
        m_ulPrefixLen = ulLen;
    }
exit:
    return hr;
}

DWORD CXMLNamespace::_MapPrefix(
                        const WCHAR *pwcPrefix, 
                        ULONG ulPrefixLen, 
                        BOOL *pbFoundDefaultNamespace)
{
    BOOL    bFoundDefault = FALSE;
    DWORD   dwNsID = DAVNAMESPACE_UNKNOWN;
    
    if ((ulPrefixLen > 0) && (ulPrefixLen == m_ulPrefixLen) && (0 == StrCmpNW(pwcPrefix, m_pwcPrefix, ulPrefixLen)))
    {
        dwNsID = m_dwNsID;
        goto exit;
    }

    // look for a match in the parent.
    if (m_pParent)
        dwNsID = m_pParent->_MapPrefix(pwcPrefix, ulPrefixLen, &bFoundDefault);

    // if we are a default namespace, and either we didn't find a match in the parent, or
    // we found a default namespace match in the parent, this becomes the namespace
    if ((NULL == m_pwcPrefix) && (DAVNAMESPACE_UNKNOWN == dwNsID || bFoundDefault))
    {
        dwNsID = m_dwNsID;
        bFoundDefault = TRUE; // may not be true if !bFoundInParent
    }

exit:
    if (NULL != pbFoundDefaultNamespace)
        *pbFoundDefaultNamespace = bFoundDefault;
    
    return dwNsID;
}


static BOOL GetNamespace(
                const WCHAR *pwcNamespace,
                ULONG ulNsLen,
                CXMLNamespace *pNamespace,
                const ELEINFO **pprgEleInfo,
                DWORD *pdwInfoLength)
{
    if (NULL == pNamespace || NULL == pprgEleInfo || NULL == pdwInfoLength)
        return FALSE;
    
    BOOL bResult = TRUE;
    switch (pNamespace->MapPrefix(pwcNamespace, ulNsLen))
    {
        case DAVNAMESPACE_DAV:
            *pprgEleInfo = c_rgDavElements;
            *pdwInfoLength = ARRAYSIZE(c_rgDavElements);
            break;
    
        case DAVNAMESPACE_HTTPMAIL:
            *pprgEleInfo = c_rgHTTPMailElements;
            *pdwInfoLength = ARRAYSIZE(c_rgHTTPMailElements);
            break;
        
        case DAVNAMESPACE_HOTMAIL:
            *pprgEleInfo = c_rgHotMailElements;
            *pdwInfoLength =  ARRAYSIZE(c_rgHotMailElements);
            break;

        case DAVNAMESPACE_MAIL :
            *pprgEleInfo = c_rgMailElements;
            *pdwInfoLength =  ARRAYSIZE(c_rgMailElements);
            break;

        case DAVNAMESPACE_CONTACTS:
            *pprgEleInfo = c_rgContactElements;
            *pdwInfoLength = ARRAYSIZE(c_rgContactElements);
            break;

        default:
            *pprgEleInfo = NULL;
            *pdwInfoLength = 0;
            bResult = FALSE;
            break;
    }

    return bResult;
}

HMELE SearchNamespace(const WCHAR *pwcText, ULONG ulLen, const ELEINFO *prgEleInfo, DWORD cInfo)
{
    HMELE       hmEle = HMELE_UNKNOWN;
    ULONG       ulLeft = 0;
    ULONG       ulRight = cInfo - 1;
    ULONG       ulCur;
    int         iCompare;

    while (ulLeft <= ulRight)
    {
        ulCur = ulLeft + ((ulRight - ulLeft) / 2);
        iCompare = StrCmpNW(pwcText, prgEleInfo[ulCur].pwcTagName, min(ulLen, prgEleInfo[ulCur].ulLen));   
    
        if (0 == iCompare)
        {
            // if the lengths are the same, it's really a match
            if (ulLen == prgEleInfo[ulCur].ulLen)
            {
                hmEle = prgEleInfo[ulCur].eleID;
                break;
            }
            // if the lengths aren't the same, figure out which string is longer
            else if (ulLen > prgEleInfo[ulCur].ulLen)
                iCompare = 1;
            else
                iCompare = -1;
        }

        if (iCompare < 0)
        {
            if (ulCur > 0)
                ulRight = ulCur - 1;
            else
                break;
        }
        else
            ulLeft = ulCur + 1;
    }

    return hmEle;
}

HMELE XMLElementToID(
            const WCHAR *pwcText,
            ULONG ulLen,
            ULONG ulNamespaceLen,
            CXMLNamespace *pNamespace)
{
    HMELE           hmEle = HMELE_UNKNOWN;
    const ELEINFO   *pEleInfo = NULL;
    DWORD           cInfo = 0;
    ULONG           ulNameLen = ulLen;


    // if the lengths are the same, there is either no namespace
    // or no tagname. either way, we aren't going to find a match.
    if ((NULL == pwcText) || (NULL == pNamespace))
        goto exit;

    // if a namespace was specified, subtract it out of the tag name length
    if (0 < ulNamespaceLen)
        ulNameLen -= (ulNamespaceLen + 1);

    // null terminate the namespace string while we figure out if
    // the namespace is known
    if (GetNamespace(pwcText, ulNamespaceLen, pNamespace, &pEleInfo, &cInfo))
        hmEle = SearchNamespace(&pwcText[ulNamespaceLen + 1], ulNameLen, pEleInfo, cInfo);
    
exit:
    return hmEle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\davdef.h ===
// Elements in the DAV namespace

#ifndef PROP_DAV
#define PROP_DAV(name, value)
#endif
#ifndef PROP_HTTP
#define PROP_HTTP(name, value)
#endif
#ifndef PROP_HOTMAIL
#define PROP_HOTMAIL(name, value)
#endif
#ifndef PROP_MAIL
#define PROP_MAIL(name, value)
#endif
#ifndef PROP_CONTACTS
#define PROP_CONTACTS(name, value)
#endif

PROP_DAV(ALLPROP, allprop)
PROP_DAV(DISPLAYNAME, displayname)
PROP_DAV(GETCONTENTLENGTH, getcontentlength)
PROP_DAV(HASSUBS, hassubs)
PROP_DAV(HREF, href)
PROP_DAV(ID, id)
PROP_DAV(ISFOLDER, isfolder)
PROP_DAV(ISHIDDEN, ishidden)
PROP_DAV(LOCATION, location)
PROP_DAV(MULTISTATUS, multistatus)
PROP_DAV(NOSUBS, nosubs)
PROP_DAV(PROP, prop)
PROP_DAV(PROPFIND, propfind)
PROP_DAV(PROPSTAT, propstat)
PROP_DAV(RESPONSE, response)
PROP_DAV(STATUS, status)
PROP_DAV(TARGET, target)
PROP_DAV(VISIBLECOUNT, visiblecount)

// Elements in the HTTPMail namespace

PROP_HTTP(ANSWERED, answered)
PROP_HTTP(CALENDAR, calendar)
PROP_HTTP(CONTACTS, contacts)
PROP_HTTP(DELETEDITEMS, deleteditems)
PROP_HTTP(DRAFT, draft)
PROP_HTTP(DRAFTS, drafts)
PROP_HTTP(FLAG, flag)
PROP_HTTP(INBOX, inbox)
PROP_HTTP(MSGFOLDERROOT, msgfolderroot)
PROP_HTTP(OUTBOX, outbox)
PROP_HTTP(READ, read)
PROP_HTTP(SENDMSG, sendmsg)
PROP_HTTP(SENTITEMS, sentitems)
PROP_HTTP(SPECIAL, special)
PROP_HTTP(UNREADCOUNT, unreadcount)

// Elements in the HotMail namespace
// These should be in the alphabetical order of their tags.
PROP_HOTMAIL(ADBAR, adbar)
PROP_HOTMAIL(MAXPOLLINGINTERVAL, maxpoll)
PROP_HOTMAIL(MODIFIED, modified)
PROP_HOTMAIL(SIG, sig)

// Elements in the Mail namespace
PROP_MAIL(BCC, bcc)
PROP_MAIL(CC, cc)
PROP_MAIL(DATE, date)
PROP_MAIL(FROM, from)
PROP_MAIL(HASATTACHMENT, hasattachment)
PROP_MAIL(PRIORITY, priority)
PROP_MAIL(RECEIVED, received)
PROP_MAIL(SUBJECT, subject)
PROP_MAIL(TO, to)

PROP_CONTACTS(BDAY, bday)
PROP_CONTACTS(CN, cn)
PROP_CONTACTS(FRIENDLYCOUNTRYNAME, co)
PROP_CONTACTS(CONTACT, contact)
PROP_CONTACTS(FACSIMILETELEPHONENUMBER, facsimiletelephonenumber)
PROP_CONTACTS(GIVENNAME, givenName)
PROP_CONTACTS(GROUP, group)
PROP_CONTACTS(HOMECITY, homeCity)
PROP_CONTACTS(HOMECOUNTRY, homeCountry)
PROP_CONTACTS(HOMEFAX, homeFax)
PROP_CONTACTS(HOMEPHONE, homePhone)
PROP_CONTACTS(HOMEPOSTALCODE, homePostalCode)
PROP_CONTACTS(HOMESTATE, homeState)
PROP_CONTACTS(HOMESTREET, homeStreet)
PROP_CONTACTS(L, l)
PROP_CONTACTS(MAIL, mail)
PROP_CONTACTS(MOBILE, mobile)
PROP_CONTACTS(NICKNAME, nickname)
PROP_CONTACTS(O, o)
PROP_CONTACTS(OTHERTELEPHONE, otherTelephone)
PROP_CONTACTS(PAGER, pager)
PROP_CONTACTS(POSTALCODE, postalcode)
PROP_CONTACTS(SN, sn)
PROP_CONTACTS(ST, st)
PROP_CONTACTS(STREET, street)
PROP_CONTACTS(TELEPHONENUMBER, telephoneNumber)

// undefine the macros
#undef PROP_DAV
#undef PROP_HTTP
#undef PROP_HOTMAIL
#undef PROP_MAIL
#undef PROP_CONTACTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\imap4.h ===
//***************************************************************************
// IMAP4 Protocol Class Header File(CImap4Agent)
// Written by Raymond Cheng, 3/21/96
//
// This class allows its callers to use IMAP4 client commands without concern
// for the actual command syntax and without having to parse the response
// from the IMAP4 server (which may contain information unrelated to the
// original command).
//
// Given a server, this class makes a connection to the IMAP server when it
// is first required, and retains this connection (periodically sending NoOps
// if necessary) until this class is destroyed. Thus, for online usage, this
// class should be retained throughout the entire session with the user. For
// disconnected or offline operation, this class should be retained for only
// as long as it takes to download new mail and synchronize the cache. After
// these operations are complete, this class should be destroyed (which
// closes the connection) before continuing with the user's mail session.
//***************************************************************************

#ifndef __IMAP4Protocol_H
#define __IMAP4Protocol_H



//---------------------------------------------------------------------------
// CImap4Agent Required Includes
//---------------------------------------------------------------------------
#include "imnxport.h"
#include "ASynConn.h"
#include "ixpbase.h"
#include "sicily.h"


//---------------------------------------------------------------------------
// CImap4Agent Forward Declarations
//---------------------------------------------------------------------------
class CImap4Agent;
interface IMimeInternational;


//---------------------------------------------------------------------------
// CImap4Agent Constants and Defines
//---------------------------------------------------------------------------
const int CMDLINE_BUFSIZE = 512; // For command lines sent to IMAP server
const int RESPLINE_BUFSIZE = 2048; // For lines received from IMAP server
const int NUM_TAG_CHARS = 4;

const boolean DONT_USE_UIDS = FALSE;
const boolean USE_UIDS = TRUE;

const BOOL USE_LAST_RESPONSE = TRUE;
const BOOL DONT_USE_LAST_RESPONSE = FALSE;

// IMAP-defined Transaction ID's
const DWORD tidDONT_CARE = 0; // Means that transaction ID is unimportant or unavailable

#define DEFAULT_CBHANDLER NULL // Pass this as a IIMAPCallback ptr if you wish to substitute
                               // the default CB Handler (and make it clear to the reader)
#define MAX_AUTH_TOKENS 32


//---------------------------------------------------------------------------
// CImap4Agent Data Types
//---------------------------------------------------------------------------

// The following are IMAP-specific HRESULTs.
// When this is ready to roll in, these values will be migrated to Errors.h
// Assert(FALSE) (placeholder)
enum IMAP_HRESULT {
    hrIMAP_S_FOUNDLITERAL = 0,
    hrIMAP_S_NOTFOUNDLITERAL,
    hrIMAP_S_QUOTED,
    hrIMAP_S_ATOM,
    hrIMAP_S_NIL_NSTRING
}; // IMAP_HRESULTS


enum IMAP_COMMAND {
    icNO_COMMAND, // This indicates there are no cmds currently in progress
    icLOGIN_COMMAND,
    icCAPABILITY_COMMAND,
    icSELECT_COMMAND,
    icEXAMINE_COMMAND,
    icCREATE_COMMAND,
    icDELETE_COMMAND,
    icRENAME_COMMAND,
    icSUBSCRIBE_COMMAND,
    icUNSUBSCRIBE_COMMAND,
    icLIST_COMMAND,
    icLSUB_COMMAND,
    icAPPEND_COMMAND,
    icCLOSE_COMMAND,
    icEXPUNGE_COMMAND,
    icSEARCH_COMMAND,
    icFETCH_COMMAND,
    icSTORE_COMMAND,
    icCOPY_COMMAND,
    icLOGOUT_COMMAND,
    icNOOP_COMMAND,
    icAUTHENTICATE_COMMAND,
    icSTATUS_COMMAND,
    icIDLE_COMMAND,
    icALL_COMMANDS
}; // IMAP_COMMAND



enum IMAP_RESPONSE_ID {
    irNONE, // This represents an unknown IMAP response
    irOK_RESPONSE,
    irNO_RESPONSE,
    irBAD_RESPONSE,
    irCMD_CONTINUATION,
    irPREAUTH_RESPONSE,
    irBYE_RESPONSE,
    irCAPABILITY_RESPONSE,
    irLIST_RESPONSE,
    irLSUB_RESPONSE,
    irSEARCH_RESPONSE,
    irFLAGS_RESPONSE,
    irEXISTS_RESPONSE,
    irRECENT_RESPONSE,
    irEXPUNGE_RESPONSE,
    irFETCH_RESPONSE,
    irSTATUS_RESPONSE,
    irALERT_RESPONSECODE,
    irPARSE_RESPONSECODE,
    irPERMANENTFLAGS_RESPONSECODE,
    irREADWRITE_RESPONSECODE,
    irREADONLY_RESPONSECODE,
    irTRYCREATE_RESPONSECODE,
    irUIDVALIDITY_RESPONSECODE,
    irUNSEEN_RESPONSECODE
}; // IMAP_RESPONSE_ID



// States of the receiver FSM
enum IMAP_RECV_STATE {
    irsUNINITIALIZED,
    irsNOT_CONNECTED,
    irsSVR_GREETING,
    irsIDLE,
    irsLITERAL,
    irsFETCH_BODY
}; // IMAP_RECV_STATE



enum IMAP_SEND_EVENT {
    iseSEND_COMMAND, // New command is available to be sent. Does nothing right now.
    iseSENDDONE, // Indicates receipt of AE_SENDDONE from CAsyncConn - we can send at will
    iseCMD_CONTINUATION, // Indicates server has given permission to send our literal
    iseUNPAUSE // Indicates that currently paused command may be unpaused
}; // IMAP_SEND_EVENT


enum IMAP_LINEFRAG_TYPE {
    iltLINE,
    iltLITERAL,
    iltRANGELIST,
    iltPAUSE,
    iltSTOP,
    iltLAST
}; // IMAP_LINEFRAG_TYPE



enum IMAP_LITERAL_STORETYPE {
    ilsSTRING,
    ilsSTREAM
}; // IMAP_LITERAL_STORETYPE



enum IMAP_PROTOCOL_STATUS {
    ipsNotConnected,
    ipsConnected,
    ipsAuthorizing,
    ipsAuthorized
}; // IMAP_PROTOCOL_STATUS



// The following is used to track what state the server SHOULD be in
enum SERVERSTATE {ssNotConnected, ssConnecting, ssNonAuthenticated,
    ssAuthenticated, ssSelected};



const DWORD INVALID_UID = 0;


// Holds fragments of a command/response line to/from the IMAP server
typedef struct tagIMAPLineFragment {
    IMAP_LINEFRAG_TYPE iltFragmentType; // We get/send lines and literals to/from IMAP svr
    IMAP_LITERAL_STORETYPE ilsLiteralStoreType; // Literals are stored as strings or streams
    DWORD dwLengthOfFragment;
    union {
        char *pszSource;
        LPSTREAM pstmSource;
        IRangeList *prlRangeList;
    } data;
    struct tagIMAPLineFragment *pilfNextFragment;
    struct tagIMAPLineFragment *pilfPrevFragment; // NB: I DO NOT update this after line is fully constructed
} IMAP_LINE_FRAGMENT;



// Points to first fragment in queue of fragments
typedef struct tagIMAPLineFragmentQueue {
    IMAP_LINE_FRAGMENT *pilfFirstFragment;  // Points to head of queue (this advances during transmission)
    IMAP_LINE_FRAGMENT *pilfLastFragment;   // Points to tail of queue for quick enqueuing
} IMAP_LINEFRAG_QUEUE;
const IMAP_LINEFRAG_QUEUE ImapLinefragQueue_INIT = {NULL, NULL};


enum AUTH_STATE {
    asUNINITIALIZED = 0,
    asWAITFOR_CONTINUE,
    asWAITFOR_CHALLENGE,
    asWAITFOR_AUTHENTICATION,
    asCANCEL_AUTHENTICATION
}; // enum AUTH_STATE

enum AUTH_EVENT {
    aeStartAuthentication = 0,
    aeOK_RESPONSE,
    aeBAD_OR_NO_RESPONSE,
    aeCONTINUE,
    aeABORT_AUTHENTICATION
}; // enum AUTH_EVENT

typedef struct tagAuthStatus {
    AUTH_STATE asCurrentState;
    BOOL fPromptForCredentials;
    int iCurrentAuthToken; // Ordinal (NOT index) of current auth token
    int iNumAuthTokens;    // Num of auth mechanisms advertised by svr (rgpszAuthTokens)
    LPSTR rgpszAuthTokens[MAX_AUTH_TOKENS]; // Array of ptrs to auth mech strings
    SSPICONTEXT rSicInfo;          // Data used for logging onto a sicily server
    LPSSPIPACKAGE pPackages;      // Array of installed security packages
    ULONG cPackages;           // Number of installed security packages (pPackages)
} AUTH_STATUS;


//***************************************************************************
// CIMAPCmdInfo Class:
// This class contains information about an IMAP command, such as a queue
// of line fragments which constitute the actual command, the tag of the
// command, and the transaction ID used to identify the command to the
// CImap4Agent user.
//***************************************************************************
class CIMAPCmdInfo {
public:
    // Constructor, Destructor
    CIMAPCmdInfo(CImap4Agent *pImap4Agent, IMAP_COMMAND icCmd,
        SERVERSTATE ssMinimumStateArg, WPARAM wParamArg,
        LPARAM lParamArg, IIMAPCallback *pCBHandlerArg);
    ~CIMAPCmdInfo(void);

    // Module variables
    IMAP_COMMAND icCommandID; // IMAP command currently in progress
    SERVERSTATE ssMinimumState; // Minimum server state for this cmd
    boolean fUIDRangeList; // TRUE if a UID rangelist is involved, FALSE by default
    char szTag[NUM_TAG_CHARS+1]; // Tag of currently executing command
    IMAP_LINEFRAG_QUEUE *pilqCmdLineQueue;
    WPARAM wParam;  // User-supplied number which identifies this transaction
    LPARAM lParam;  // User-supplied number which identifies this transaction
    IIMAPCallback *pCBHandler; // User-supplied CB handler (NULL means use default CB handler)
    CIMAPCmdInfo *piciNextCommand;

private:
    CImap4Agent *m_pImap4Agent;
}; // CIMAPCmdInfo





//---------------------------------------------------------------------------
// CImap4Agent Class Definition
//---------------------------------------------------------------------------
class CImap4Agent :
    public IIMAPTransport2,
    public CIxpBase
{
    friend CIMAPCmdInfo;

public:
    //***********************************************************************
    // Public Section
    //***********************************************************************
    
    // Constructor/Destructor
    CImap4Agent(void);
    ~CImap4Agent(void);

    HRESULT STDMETHODCALLTYPE SetWindow(void);
    HRESULT STDMETHODCALLTYPE ResetWindow(void);

    // IUnknown Methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // IASyncConnCB Method
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // Administration Functions
    HRESULT STDMETHODCALLTYPE InitNew(LPSTR pszLogFilePath, IIMAPCallback *pCBHandler);
    HRESULT STDMETHODCALLTYPE HandsOffCallback(void);
    HRESULT STDMETHODCALLTYPE SetDefaultCBHandler(IIMAPCallback *pCBHandler);

    // Utility Functions
    HRESULT STDMETHODCALLTYPE NewIRangeList(IRangeList **pprlNewRangeList);

    // IIMAPTransport functions
    // IMAP Client Commands, in same order of definition as in RFC-1730
    // Not all commands are available, as some commands are used exclusively
    // inside this class and thus need not be exported.
    HRESULT STDMETHODCALLTYPE Capability(DWORD *pdwCapabilityFlags);
    HRESULT STDMETHODCALLTYPE Select(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Examine(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Create(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Delete(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Rename(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName, LPSTR lpszNewMailboxName);
    HRESULT STDMETHODCALLTYPE Subscribe(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Unsubscribe(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);

    HRESULT STDMETHODCALLTYPE List(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszMailboxNameReference, LPSTR lpszMailboxNamePattern);
    HRESULT STDMETHODCALLTYPE Lsub(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszMailboxNameReference, LPSTR lpszMailboxNamePattern);
    
    HRESULT STDMETHODCALLTYPE Append(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszMailboxName, LPSTR lpszMessageFlags, FILETIME ftMessageDateTime,
        LPSTREAM lpstmMessageToSave);
    HRESULT STDMETHODCALLTYPE Close(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);
    HRESULT STDMETHODCALLTYPE Expunge(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);
    
    HRESULT STDMETHODCALLTYPE Search(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszSearchCriteria, boolean bReturnUIDs, IRangeList *pMsgRange,
        boolean bUIDRangeList);    
    HRESULT STDMETHODCALLTYPE Fetch(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        IRangeList *pMsgRange, boolean bUIDMsgRange, LPSTR lpszFetchArgs);
    HRESULT STDMETHODCALLTYPE Store(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        IRangeList *pMsgRange, boolean bUIDRangeList, LPSTR lpszStoreArgs);
    HRESULT STDMETHODCALLTYPE Copy(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        IRangeList *pMsgRange, boolean bUIDRangeList, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Status(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR pszMailboxName, LPSTR pszStatusCmdArgs);
    HRESULT STDMETHODCALLTYPE Noop(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);

    DWORD GenerateMsgSet(LPSTR lpszDestination, DWORD dwSizeOfDestination,
        DWORD *pMsgID, DWORD cMsgID);

    // Message Sequence Number to UID member functions - the caller may use
    // these functions to map from MSN's to UID's, if the caller uses UIDs
    // to refer to messages. If the caller uses MSN's, there is no need to
    // invoke the following functions.
    HRESULT STDMETHODCALLTYPE ResizeMsgSeqNumTable(DWORD dwSizeOfMbox);
    HRESULT STDMETHODCALLTYPE UpdateSeqNumToUID(DWORD dwMsgSeqNum, DWORD dwUID);
    HRESULT STDMETHODCALLTYPE RemoveSequenceNum(DWORD dwDeletedMsgSeqNum);
    HRESULT STDMETHODCALLTYPE MsgSeqNumToUID(DWORD dwMsgSeqNum, DWORD *pdwUID);
    HRESULT STDMETHODCALLTYPE GetMsgSeqNumToUIDArray(DWORD **ppdwMsgSeqNumToUIDArray,
        DWORD *pdwNumberOfElements);
    HRESULT STDMETHODCALLTYPE GetHighestMsgSeqNum(DWORD *pdwHighestMSN);
    HRESULT STDMETHODCALLTYPE ResetMsgSeqNumToUID(void);


    // IInternetTransport functions
    HRESULT STDMETHODCALLTYPE GetServerInfo(LPINETSERVER pInetServer);
    IXPTYPE STDMETHODCALLTYPE GetIXPType(void);
    HRESULT STDMETHODCALLTYPE IsState(IXPISSTATE isstate);
    HRESULT STDMETHODCALLTYPE InetServerFromAccount(IImnAccount *pAccount,
        LPINETSERVER pInetServer);
    HRESULT STDMETHODCALLTYPE Connect(LPINETSERVER pInetServer,
        boolean fAuthenticate, boolean fCommandLogging);
    HRESULT STDMETHODCALLTYPE Disconnect(void);
    HRESULT STDMETHODCALLTYPE DropConnection(void);
    HRESULT STDMETHODCALLTYPE GetStatus(IXPSTATUS *pCurrentStatus);

    // IIMAPTransport2 functions
    HRESULT STDMETHODCALLTYPE SetDefaultCP(DWORD dwTranslateFlags, UINT uiCodePage);
    HRESULT STDMETHODCALLTYPE MultiByteToModifiedUTF7(LPCSTR pszSource,
        LPSTR *ppszDestination, UINT uiSourceCP, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE ModifiedUTF7ToMultiByte(LPCSTR pszSource,
        LPSTR *ppszDestination, UINT uiDestinationCP, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE SetIdleMode(DWORD dwIdleFlags);
    HRESULT STDMETHODCALLTYPE EnableFetchEx(DWORD dwFetchExFlags);


protected:
    // CIxpBase [pure] virtual functions
    void OnDisconnected(void);
    void ResetBase(void);
    void DoQuit(void);
    void OnEnterBusy(void);
    void OnLeaveBusy(void);



private:
    //***********************************************************************
    // Private Section
    //***********************************************************************



    //---------------------------------------------------------------------------
    // Module Data Types
    //---------------------------------------------------------------------------


    //---------------------------------------------------------------------------
    // Module Variables
    //---------------------------------------------------------------------------
    SERVERSTATE m_ssServerState; // Tracks server state to catch bad usage of module
    DWORD m_dwCapabilityFlags; // Bit-flags indicate capabilities supported by
                               // both us and the server
    char m_szLastResponseText[RESPLINE_BUFSIZE]; // Holds human-readable text of
                                                 // last server response
    LONG m_lRefCount; // Reference count for this module
    IIMAPCallback *m_pCBHandler; // Object containing all callbacks for this class

    IMAP_RECV_STATE m_irsState; // State of receiver FSM
    boolean m_bFreeToSend; // Set to TRUE by send subsystem when hrWouldBlock returned
    boolean m_fIDLE; // Set to TRUE when server has accepted our IDLE command
    IMAP_LINEFRAG_QUEUE m_ilqRecvQueue; // Received fragments placed here until ready to parse

    // Critical Sections: to avoid deadlock, if more than one CS must be entered, enter them
    // in the order listed below. Note that CIxpBase::m_cs should always be entered FIRST.
    CRITICAL_SECTION m_csTag;       // Protects static szCurrentTag var in GenerateCommandTag()
    CRITICAL_SECTION m_csSendQueue; // Protects command send queue
    CRITICAL_SECTION m_csPendingList; // Protects list of pending commands

    IMAP_LINE_FRAGMENT *m_pilfLiteralInProgress; // Literals in progress live here until finished
    DWORD m_dwLiteralInProgressBytesLeft;        // This tells us when we're finished
    FETCH_BODY_PART m_fbpFetchBodyPartInProgress; // Allows us to persist data during body part download
    DWORD m_dwAppendStreamUploaded; // Num bytes already uploaded during APPEND, for progress
    DWORD m_dwAppendStreamTotal; // Size of stream uploaded during APPEND, for progress indication

    boolean m_bCurrentMboxReadOnly; // For debugging purposes (verify proper access requests)

    CIMAPCmdInfo *m_piciSendQueue; // Queue of commands waiting to be sent
    CIMAPCmdInfo *m_piciPendingList; // List of commands pending server response
    CIMAPCmdInfo *m_piciCmdInSending; // The command in m_piciSendQueue currently being sent to server

    IMimeInternational *m_pInternational; // MIME object for international conversions
    DWORD m_dwTranslateMboxFlags;
    UINT m_uiDefaultCP;
    AUTH_STATUS m_asAuthStatus;

    // Message Sequence Number to UID mapping variables
    DWORD *m_pdwMsgSeqNumToUID;
    DWORD m_dwSizeOfMsgSeqNumToUID;
    DWORD m_dwHighestMsgSeqNum;

    DWORD m_dwFetchFlags;


    //---------------------------------------------------------------------------
    // Internal Module Functions
    //---------------------------------------------------------------------------

    // IMAP Response-Parsing Functions
    HRESULT ParseSvrResponseLine (IMAP_LINE_FRAGMENT **ppilfLine,
        boolean *lpbTaggedResponse, LPSTR lpszTagFromSvr,
        IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseStatusResponse (LPSTR lpszStatusResponseLine,
        IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseResponseCode(LPSTR lpszResponseCode);
    HRESULT ParseSvrMboxResponse (IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR lpszSvrMboxResponseLine, IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseMsgStatusResponse (IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR lpszMsgResponseLine, IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseListLsubResponse(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR lpszListResponse, IMAP_RESPONSE_ID irListLsubID);
    IMAP_MBOXFLAGS ParseMboxFlag(LPSTR lpszFlagToken);
    HRESULT ParseFetchResponse (IMAP_LINE_FRAGMENT **ppilfLine,
        DWORD dwMsgSeqNum, LPSTR lpszFetchResp);
    HRESULT ParseSearchResponse(LPSTR lpszSearchResponse);
    HRESULT ParseMsgFlagList(LPSTR lpszStartOfFlagList,
        IMAP_MSGFLAGS *lpmfMsgFlags, LPDWORD lpdwNumBytesRead);
    void parseCapability (LPSTR lpszCapabilityToken);
    void AddAuthMechanism(LPSTR pszAuthMechanism);
    HRESULT ParseMboxStatusResponse(IMAP_LINE_FRAGMENT **ppilfLine, LPSTR pszStatusResponse);
    HRESULT ParseEnvelope(FETCH_CMD_RESULTS_EX *pEnvResults, IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppCurrent);
    HRESULT ParseIMAPAddresses(IMAPADDR **ppiaResults, IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppCurrent);
    void DowngradeFetchResponse(FETCH_CMD_RESULTS *pfcrOldFetchStruct,
        FETCH_CMD_RESULTS_EX *pfcreNewFetchStruct);


    // IMAP String-Conversion Functions
    HRESULT QuotedToString(LPSTR *ppszDestinationBuf, LPDWORD pdwSizeOfDestination,
        LPSTR *ppCurrentSrcPos);
    HRESULT AStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppszDestination, LPDWORD pdwSizeOfDestination, LPSTR *ppCurrentSrcPos);
    inline boolean isTEXT_CHAR(char c);
    inline boolean isATOM_CHAR(char c);
    HRESULT NStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppszDestination, LPDWORD pdwLengthOfDestination, LPSTR *ppCurrentSrcPos);
    HRESULT NStringToStream(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTREAM *ppstmResult, LPSTR *ppCurrentSrcPos);
    HRESULT AppendSendAString(CIMAPCmdInfo *piciCommand, LPSTR lpszCommandLine,
        LPSTR *ppCmdLinePos, DWORD dwSizeOfCommandLine, LPCSTR lpszSource,
        BOOL fPrependSpace = TRUE);
    HRESULT StringToQuoted(LPSTR lpszDestination, LPCSTR lpszSource,
        DWORD dwSizeOfDestination, LPDWORD lpdwNumCharsWritten);
    inline boolean isPrintableUSASCII(BOOL fUnicode, LPCSTR pszIn);
    inline boolean isIMAPModifiedBase64(const char c);
    inline boolean isEqualUSASCII(BOOL fUnicode, LPCSTR pszIn, const char c);
    inline void SetUSASCIIChar(BOOL fUnicode, LPSTR pszOut, char cUSASCII);
    HRESULT NonUSStringToModifiedUTF7(UINT uiCurrentACP, LPCSTR pszStartOfNonUSASCII,
        int iLengthOfNonUSASCII, LPSTR *ppszOut, LPINT piNumCharsWritten);
    HRESULT UnicodeToUSASCII(LPSTR *ppszUSASCII, LPCWSTR pwszUnicode,
        DWORD dwSrcLenInBytes, LPDWORD pdwUSASCIILen);
    HRESULT ASCIIToUnicode(LPWSTR *ppwszUnicode, LPCSTR pszASCII, DWORD dwSrcLen);
    HRESULT _MultiByteToModifiedUTF7(LPCSTR pszSource, LPSTR *ppszDestination);
    HRESULT _ModifiedUTF7ToMultiByte(LPCSTR pszSource, LPSTR *ppszDestination);
    HRESULT ConvertString(UINT uiSourceCP, UINT uiDestCP, LPCSTR pszSource, int *piSrcLen,
        LPSTR *ppszDest, int *piDestLen, int iOutputExtra);
    HRESULT HandleFailedTranslation(BOOL fUnicode, BOOL fToUTF7, LPCSTR pszSource, LPSTR *ppszDest);

    // IMAP Command Construction Function
    void GenerateCommandTag(LPSTR lpszTag);
    HRESULT OneArgCommand(LPCSTR lpszCommandVerb, LPSTR lpszMboxName,
        IMAP_COMMAND icCommandID, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT NoArgCommand(LPCSTR lpszCommandVerb, IMAP_COMMAND icCommandID,
        SERVERSTATE ssMinimumState, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT TwoArgCommand(LPCSTR lpszCommandVerb, LPCSTR lpszFirstArg,
        LPCSTR lpszSecondArg, IMAP_COMMAND icCommandID,
        SERVERSTATE ssMinimumState, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT RangedCommand(LPCSTR lpszCommandVerb, boolean bUIDPrefix,
        IRangeList *pMsgRange, boolean bUIDRangeList, boolean bAStringCmdArgs,
        LPSTR lpszCmdArgs, IMAP_COMMAND icCommandID, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT TwoMailboxCommand(LPCSTR lpszCommandVerb, LPSTR lpszFirstMbox,
        LPSTR lpszSecondMbox, IMAP_COMMAND icCommandID, SERVERSTATE ssMinimumState,
        WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);
    void AppendMsgRange(LPSTR *ppDest, const DWORD idStartOfRange,
        const DWORD idEndOfRange, boolean bSuppressComma);
    void EnterIdleMode(void);


    // IMAP Fragment Manipulation Functions
    void EnqueueFragment(IMAP_LINE_FRAGMENT *pilfSourceFragment,
        IMAP_LINEFRAG_QUEUE *pilqLineFragQueue);
    void InsertFragmentBeforePause(IMAP_LINE_FRAGMENT *pilfSourceFragment,
        IMAP_LINEFRAG_QUEUE *pilqLineFragQueue);
    IMAP_LINE_FRAGMENT *DequeueFragment(IMAP_LINEFRAG_QUEUE *pilqLineFraqQueue);
    boolean NextFragmentIsLiteral(IMAP_LINEFRAG_QUEUE *pilqLineFragQueue);
    void FreeFragment(IMAP_LINE_FRAGMENT **ppilfFragment);


    // IMAP Receiver Functions
    void AddPendingCommand(CIMAPCmdInfo *piciNewCommand);
    CIMAPCmdInfo *RemovePendingCommand(LPSTR pszTag);
    WORD FindTransactionID (WPARAM *pwParam, LPARAM *plParam,
        IIMAPCallback **ppCBHandler, IMAP_COMMAND icTarget1,
        IMAP_COMMAND icTarget2 = icNO_COMMAND);
    void ProcessServerGreeting(char *pszResponseLine, DWORD dwNumBytesReceived);
    void OnCommandCompletion(LPSTR szTag, HRESULT hrCompletionResult,
        IMAP_RESPONSE_ID irCompletionResponse);
    void CheckForCompleteResponse(LPSTR pszResponseLine, DWORD dwNumBytesRead,
        IMAP_RESPONSE_ID *pirParseResult);
    void AddBytesToLiteral(LPSTR pszResponseBuf, DWORD dwNumBytesRead);
    HRESULT ProcessResponseLine(void);
    void GetTransactionID(WPARAM *pwParam, LPARAM *plParam,
        IIMAPCallback **ppCBHandler, IMAP_RESPONSE_ID irResponseType);
    HRESULT PrepareForLiteral(DWORD dwSizeOfLiteral);
    void PrepareForFetchBody(DWORD dwMsgSeqNum, DWORD dwSizeOfLiteral, LPSTR pszBodyTag);
    BOOL isFetchResponse(IMAP_LINEFRAG_QUEUE *pilqCurrentResponse, LPDWORD pdwMsgSeqNum);
    BOOL isFetchBodyLiteral(IMAP_LINE_FRAGMENT *pilfCurrent, LPSTR pszStartOfLiteralSize,
        LPSTR *ppszBodyTag);
    void DispatchFetchBodyPart(LPSTR pszResponseBuf, DWORD dwNumBytesRead,
        BOOL fFreeBodyTagAtEnd);
    void UploadStreamProgress(DWORD dwBytesUploaded);

    
    // IMAP Authentication Functions
    HRESULT GetAccountInfo(void);
    void LoginUser(void);
    void ReLoginUser(void);
    void AuthenticateUser(AUTH_EVENT aeEvent, LPSTR pszServerData, DWORD dwSizeOfData);
    HRESULT TryAuthMethod(BOOL fNextAuthMethod, UINT *puiFailureTextID);
    HRESULT CancelAuthentication(void);
    void FreeAuthStatus(void);

    // IMAP Send Functions
    CIMAPCmdInfo *DequeueCommand(void);
    void ProcessSendQueue(IMAP_SEND_EVENT iseEvent);
    HRESULT SendCmdLine(CIMAPCmdInfo *piciCommand, DWORD dwFlags,
        LPCSTR lpszCommandText, DWORD dwCmdLineLength);
    HRESULT SendLiteral(CIMAPCmdInfo *piciCommand, LPSTREAM pstmLiteral,
        DWORD dwSizeOfStream);
    HRESULT SendRangelist(CIMAPCmdInfo *piciCommand, IRangeList *pRangeList,
        boolean bUIDRangeList);
    HRESULT SendPause(CIMAPCmdInfo *piciCommand);
    HRESULT SendStop(CIMAPCmdInfo *piciCommand);
    HRESULT SubmitIMAPCommand(CIMAPCmdInfo *picfCommand);
    void GetNextCmdToSend(void);
    boolean isValidNonWaitingCmdSequence(void);
    boolean CanStreamCommand(IMAP_COMMAND icCommandID);
    void CompressCommand(CIMAPCmdInfo *pici);


    // Miscellaneous Helper Functions
    void OnIMAPError(HRESULT hrResult, LPSTR pszFailureText,
        BOOL bIncludeLastResponse, LPSTR pszDetails = NULL);
    void FreeAllData(HRESULT hrTerminatedCmdResult);
    void OnIMAPResponse(IIMAPCallback *pCBHandler, IMAP_RESPONSE *pirIMAPResponse);
    void FreeFetchResponse(FETCH_CMD_RESULTS_EX *pcreFreeMe);
    void FreeIMAPAddresses(IMAPADDR *piaFreeMe);

}; // CIMAP4 Class


#endif // #ifdef __IMAP4Protocol_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpbase.cpp ===
// --------------------------------------------------------------------------------
// Ixpbase.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "ixpbase.h"
#include "imnact.h"
#include "ixputil.h"
#include "sicily.h"
#include "resource.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// CIxpBase::CIxpBase
// --------------------------------------------------------------------------------
CIxpBase::CIxpBase(IXPTYPE ixptype) : m_ixptype(ixptype)
{
    m_fBusy = FALSE;
    m_status = IXP_DISCONNECTED;
    m_cRef = 1;
    m_pszResponse = NULL;
    m_uiResponse = 0;
    m_hrResponse = S_OK;
    m_pLogFile = NULL;
    m_pSocket = NULL;
    m_pCallback = NULL;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    m_fConnectAuth = FALSE;
    m_fConnectTLS = FALSE;
    m_fCommandLogging = FALSE;
    m_fAuthenticated = FALSE;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::~CIxpBase
// --------------------------------------------------------------------------------
CIxpBase::~CIxpBase(void)
{
    Reset();
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::Reset
// --------------------------------------------------------------------------------
void CIxpBase::Reset(void)
{
    EnterCriticalSection(&m_cs);
    m_fBusy = FALSE;
    m_status = IXP_DISCONNECTED;
    SafeMemFree(m_pszResponse);
    m_uiResponse = 0;
    m_hrResponse = S_OK;
    SafeRelease(m_pLogFile);
    if (NULL != m_pSocket) 
    {
        m_pSocket->Close();
        SafeRelease(m_pSocket);
    }
    SafeRelease(m_pCallback);
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    m_fConnectAuth = FALSE;
    m_fConnectTLS = FALSE;
    m_fCommandLogging = FALSE;
    m_fAuthenticated = FALSE;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::IsState(IXPISSTATE isstate) 
{
    // Locals
    HRESULT hr=S_FALSE;

    // Thread Safety
	EnterCriticalSection(&m_cs);

#if 0
    // Initialized
    if (NULL == m_pSocket || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }
#endif

    // Handle IsType
    switch(isstate)
    {
    // Are we connected
    case IXP_IS_CONNECTED:
        hr =  (IXP_DISCONNECTED == m_status) ? S_FALSE : S_OK;
        break;

    // Are we busy
    case IXP_IS_BUSY:
        hr = (TRUE == m_fBusy) ? S_OK : S_FALSE;
        break;

    // Are we busy
    case IXP_IS_READY:
        hr = (FALSE == m_fBusy) ? S_OK : S_FALSE;
        break;

    // Have we been authenticated yet
    case IXP_IS_AUTHENTICATED:
        hr = (TRUE == m_fAuthenticated) ? S_OK : S_FALSE;
        break;

    // Unhandled ixpistype
    default:
        IxpAssert(FALSE);
        break;
    }

    // Thread Safety
	LeaveCriticalSection(&m_cs);

    // Done
	return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::OnPrompt
// --------------------------------------------------------------------------------
int CIxpBase::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType)
{
    // $$BUGBUG$$ Need to return an error
    if (NULL == m_pCallback)
        return TrapError(IXP_E_NOT_INIT);

    // Call the callback
    return m_pCallback->OnPrompt(hrError, pszText, pszCaption, uType, this);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnError
// --------------------------------------------------------------------------------
void CIxpBase::OnError(HRESULT hrResult, LPSTR pszProblem)
{
    // Locals
    IXPRESULT rIxpResult;

    // No Callback
    if (NULL == m_pCallback)
        return;

    // Zero It
    ZeroMemory(&rIxpResult, sizeof(IXPRESULT));

	// Save current state
    rIxpResult.hrResult = hrResult;
    rIxpResult.pszResponse = PszDupA(m_pszResponse);
    rIxpResult.uiServerError = m_uiResponse;
    rIxpResult.hrServerError = m_hrResponse;
    rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rIxpResult.pszProblem = PszDupA(pszProblem);


    if (m_pLogFile && pszProblem)
    {
        // Locals
        char szErrorTxt[1024];

        // Build the Error
        wsprintf(szErrorTxt, "ERROR: \"%.900s\", hr=%lu", pszProblem, hrResult);

        // Write the error
        m_pLogFile->WriteLog(LOGFILE_DB, szErrorTxt);
    }

    // Tell the watchdog to take a nap
    m_pSocket->StopWatchDog();

    // Give to callback
    m_pCallback->OnError(m_status, &rIxpResult, this);

    // Start the watchdog and wait for normal socket activity
    m_pSocket->StartWatchDog();

    // Free stuff
    SafeMemFree(rIxpResult.pszResponse);
    SafeMemFree(rIxpResult.pszProblem);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnStatus
// --------------------------------------------------------------------------------
void CIxpBase::OnStatus(IXPSTATUS ixpstatus)
{
    // Save new Status
    m_status = ixpstatus;

    if (IXP_AUTHORIZED == ixpstatus)
        m_fAuthenticated = TRUE;
    else if (IXP_DISCONNECTED == ixpstatus || IXP_DISCONNECTING == ixpstatus)
        m_fAuthenticated = FALSE;

    // Give Status to callback
    if (m_pCallback)
        m_pCallback->OnStatus(ixpstatus, this);

    // If we're informing caller that we're authorized, head immediately to IXP_CONNECTED
    // UNLESS m_status is changed: this indicates state change (eg, disconnect) during callback
    if (IXP_AUTHORIZED == ixpstatus && IXP_AUTHORIZED == m_status) 
    {
        m_status = IXP_CONNECTED;
        if (m_pCallback)
            m_pCallback->OnStatus(IXP_CONNECTED, this);
    }
}

// --------------------------------------------------------------------------------
// CIxpBase::HrEnterBusy
// --------------------------------------------------------------------------------
HRESULT CIxpBase::HrEnterBusy(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Initialized
    if (NULL == m_pSocket || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Not Ready
    if (TRUE == m_fBusy)
    {
        hr = TrapError(IXP_E_BUSY);
        goto exit;
    }

    // Start WatchDog
    m_pSocket->StartWatchDog();

    // Busy
    m_fBusy = TRUE;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::LeaveBusy
// --------------------------------------------------------------------------------
void CIxpBase::LeaveBusy(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Start WatchDog
    if (NULL != m_pSocket)
    {
        m_pSocket->StopWatchDog();
    }

    // Busy
    m_fBusy = FALSE;

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::HandsOffCallback(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No current callback
    if (NULL == m_pCallback)
    {
        hr = TrapError(S_FALSE);
        goto exit;
    }

    // Release it
    SafeRelease(m_pCallback);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::OnInitNew
// --------------------------------------------------------------------------------
HRESULT CIxpBase::OnInitNew(LPSTR pszProtocol, LPSTR pszLogFilePath, DWORD dwShareMode,
                            ITransportCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pCallback || NULL == pszProtocol)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not connected
    if (IXP_DISCONNECTED != m_status)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    // release current objects
    Reset();
    ResetBase();

    // open log file
    if (pszLogFilePath)
    {
        // create the log file
        CreateLogFile(g_hInst, pszLogFilePath, pszProtocol, DONT_TRUNCATE, &m_pLogFile, dwShareMode);
    }

    // Create the socket
    m_pSocket = new CAsyncConn(m_pLogFile, (IAsyncConnCB *)this, (IAsyncConnPrompt *)this);
    if (NULL == m_pSocket)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

	// Add Ref callback
	m_pCallback = pCallback;
	m_pCallback->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::GetServerInfo(LPINETSERVER pInetServer)
{
    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Copy Server information
    CopyMemory(pInetServer, &m_rServer, sizeof(INETSERVER));

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CIxpBase::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::Disconnect(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No socket...
    if (NULL == m_pSocket)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Not connected
    if (IXP_DISCONNECTED == m_status)
    {
        hr = TrapError(IXP_E_NOT_CONNECTED);
        goto exit;
    }

    // Disconnecting
    OnStatus(IXP_DISCONNECTING);

    // State
    DoQuit();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::DropConnection(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No socket...
    if (NULL == m_pSocket)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Already IXP_DISCONNECTED
    if (IXP_DISCONNECTED != m_status)
    {
        // State
        OnStatus(IXP_DISCONNECTING);

        // Done
        CHECKHR(hr = m_pSocket->Close());
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           fAlwaysPromptPassword=FALSE;

    // check params
    if (NULL == pAccount || NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // ZeroInit
    ZeroMemory(pInetServer, sizeof(INETSERVER));

    // Get the account name
    hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, pInetServer->szAccount, ARRAYSIZE(pInetServer->szAccount));
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_INVALID_ACCOUNT);
        goto exit;
    }

    // Get the RAS connectoid
    if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, pInetServer->szConnectoid, ARRAYSIZE(pInetServer->szConnectoid))))
        *pInetServer->szConnectoid = '\0';

    // Connection Type
    Assert(sizeof(pInetServer->rasconntype) == sizeof(DWORD));
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, (DWORD *)&pInetServer->rasconntype)))
        pInetServer->rasconntype = RAS_CONNECT_LAN;

    // Connection Flags

    // IXP_SMTP
    if (IXP_SMTP == m_ixptype)
    {
        // Locals
        SMTPAUTHTYPE authtype;

        // Get Server Name
        hr = pAccount->GetPropSz(AP_SMTP_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
        if (FAILED(hr))
        {
            hr = TrapError(IXP_E_INVALID_ACCOUNT);
            goto exit;
        }

        // SSL
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        pAccount->GetPropDw(AP_SMTP_SSL, (DWORD *)&pInetServer->fSSL);

        // Sicily
        Assert(sizeof(authtype) == sizeof(DWORD));
        if (FAILED(pAccount->GetPropDw(AP_SMTP_USE_SICILY, (DWORD *)&authtype)))
            authtype = SMTP_AUTH_NONE;

        if (SMTP_AUTH_NONE != authtype)
        {
            pInetServer->dwFlags |= ISF_QUERYAUTHSUPPORT;
        }
        
        // SMTP_AUTH_USE_POP3ORIMAP_SETTINGS
        if (SMTP_AUTH_USE_POP3ORIMAP_SETTINGS == authtype)
        {
            // Locals
            DWORD dwServers;
            DWORD dw;
            BOOL fIMAP;

            // Get Server Types
            if (FAILED(pAccount->GetServerTypes(&dwServers)))
            {
                hr = TrapError(IXP_E_INVALID_ACCOUNT);
                goto exit;
            }

            // fIMAP
            fIMAP = (ISFLAGSET(dwServers, SRV_IMAP)) ? TRUE : FALSE;

            // Using DPA
            if (SUCCEEDED(pAccount->GetPropDw(fIMAP ? AP_IMAP_USE_SICILY : AP_POP3_USE_SICILY, &dw)) && dw)
                pInetServer->fTrySicily = TRUE;

            // Get default username and password
            pAccount->GetPropSz(fIMAP ? AP_IMAP_USERNAME : AP_POP3_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));
            if (FAILED(pAccount->GetPropDw(fIMAP ? AP_IMAP_PROMPT_PASSWORD : AP_POP3_PROMPT_PASSWORD, &fAlwaysPromptPassword)) ||
                FALSE == fAlwaysPromptPassword)
            {
                pAccount->GetPropSz(fIMAP ? AP_IMAP_PASSWORD : AP_POP3_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));
            }
            if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
                pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;
        }

        // SMTP_AUTH_USE_SMTP_SETTINGS
        else if (SMTP_AUTH_USE_SMTP_SETTINGS == authtype)
        {
            pInetServer->fTrySicily = TRUE;
            pAccount->GetPropSz(AP_SMTP_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));
            if (FAILED(pAccount->GetPropDw(AP_SMTP_PROMPT_PASSWORD, &fAlwaysPromptPassword)) ||
                FALSE == fAlwaysPromptPassword)
            {
                pAccount->GetPropSz(AP_SMTP_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));
            }
            if (fAlwaysPromptPassword)
                pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;
        }

        // Handle Authenticatin type
        else if (SMTP_AUTH_SICILY == authtype)
            pInetServer->fTrySicily = TRUE;

        // Port
        if (FAILED(pAccount->GetPropDw(AP_SMTP_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = DEFAULT_SMTP_PORT;

        // Timeout
        pAccount->GetPropDw(AP_SMTP_TIMEOUT, &pInetServer->dwTimeout);
        if (0 == pInetServer->dwTimeout)
            pInetServer->dwTimeout = 30;

        // Use STARTTLS?
        if ((FALSE != pInetServer->fSSL) && (DEFAULT_SMTP_PORT == pInetServer->dwPort))
            pInetServer->dwFlags|=ISF_SSLONSAMEPORT;
    }

    // IXP_POP3
    else if (IXP_POP3 == m_ixptype)
    {
        // Get Server Name
        hr = pAccount->GetPropSz(AP_POP3_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
        if (FAILED(hr))
        {
            hr = TrapError(IXP_E_INVALID_ACCOUNT);
            goto exit;
        }

        // Password
        if (FAILED(pAccount->GetPropDw(AP_POP3_PROMPT_PASSWORD, &fAlwaysPromptPassword)) || 
            FALSE == fAlwaysPromptPassword)
            pAccount->GetPropSz(AP_POP3_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));

        // SSL
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        pAccount->GetPropDw(AP_POP3_SSL, (DWORD *)&pInetServer->fSSL);

        // Sicily
        Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
        pAccount->GetPropDw(AP_POP3_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);

        if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
            pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;

        // Port
        if (FAILED(pAccount->GetPropDw(AP_POP3_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = 110;

        // User Name
        pAccount->GetPropSz(AP_POP3_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));

        // Timeout
        pAccount->GetPropDw(AP_POP3_TIMEOUT, &pInetServer->dwTimeout);
    }

    // IXP_IMAP
    else if (IXP_IMAP == m_ixptype)
    {
        // User name, password and server
        hr = pAccount->GetPropSz(AP_IMAP_USERNAME, pInetServer->szUserName,
            ARRAYSIZE(pInetServer->szUserName));
        if (FAILED(hr))
            pInetServer->szUserName[0] = '\0'; // If this is incorrect, we will re-prompt user

        hr = pAccount->GetPropDw(AP_IMAP_PROMPT_PASSWORD, &fAlwaysPromptPassword);
        if (FAILED(hr) || FALSE == fAlwaysPromptPassword)
            {
            hr = pAccount->GetPropSz(AP_IMAP_PASSWORD, pInetServer->szPassword,
                ARRAYSIZE(pInetServer->szPassword));
            if (FAILED(hr))
                pInetServer->szPassword[0] = '\0'; // If this is incorrect, we will re-prompt user
            }

        if (FAILED(hr = pAccount->GetPropSz(AP_IMAP_SERVER, pInetServer->szServerName,
            ARRAYSIZE(pInetServer->szServerName))))
            goto exit; // We NEED to have a server name, so fail this function
        Assert(*pInetServer->szServerName);

        // Da port
        if (FAILED(hr = pAccount->GetPropDw(AP_IMAP_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = 143; // Default port number

        // Convert DWORD to boolean
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        hr = pAccount->GetPropDw(AP_IMAP_SSL, (DWORD *)&pInetServer->fSSL);
        if (FAILED(hr))
            pInetServer->fSSL = FALSE; // Default this value

        Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
        hr = pAccount->GetPropDw(AP_IMAP_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);
        if (FAILED(hr))
            pInetServer->fTrySicily = FALSE; // Default this value

        if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
            pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;

        // Get the timeout
        hr = pAccount->GetPropDw(AP_IMAP_TIMEOUT, &pInetServer->dwTimeout);
        if (FAILED(hr))
            pInetServer->dwTimeout = 30; // Default this value

        // If we've reached this point, we may have a failed HRESULT, but since we
        // must have defaulted the value, we should return success.
        hr = S_OK;
    }

    // IXP_NNTP
    else if (IXP_NNTP == m_ixptype)
    {
        // Get the server name
        hr = pAccount->GetPropSz(AP_NNTP_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
        if (FAILED(hr))
        {
            hr = TrapError(IXP_E_INVALID_ACCOUNT);
            goto exit;
        }

        // Password
        if (FAILED(pAccount->GetPropDw(AP_NNTP_PROMPT_PASSWORD, &fAlwaysPromptPassword)) ||
            FALSE == fAlwaysPromptPassword)
            pAccount->GetPropSz(AP_NNTP_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));
        
        // SSL
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        pAccount->GetPropDw(AP_NNTP_SSL, (DWORD *)&pInetServer->fSSL);

        // Sicily
        Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
        pAccount->GetPropDw(AP_NNTP_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);

        if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
            pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;

        // Port
        if (FAILED(pAccount->GetPropDw(AP_NNTP_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = 119;

        // User Name
        pAccount->GetPropSz(AP_NNTP_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));

        // Timeout
        pAccount->GetPropDw(AP_NNTP_TIMEOUT, &pInetServer->dwTimeout);
    }

    // Fix timeout
    if (pInetServer->dwTimeout < 30)
        pInetServer->dwTimeout = 30;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fSecureSocket = FALSE;
    BOOL            fConnectTLS = FALSE;
    
    // check params
    if (NULL == pInetServer || FIsEmptyA(pInetServer->szServerName) || pInetServer->dwPort == 0)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // not init
    if (NULL == m_pSocket || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // busy
    if (IXP_DISCONNECTED != m_status)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    // Initialize Winsock
    CHECKHR(hr = HrInitializeWinsock());

    // invalid sicily params
    if (pInetServer->fTrySicily && !FIsSicilyInstalled())
    {
        hr = TrapError(IXP_E_LOAD_SICILY_FAILED);
        goto exit;
    }

    // Copy Server information
    CopyMemory(&m_rServer, pInetServer, sizeof(INETSERVER));

    // Reset current
    ResetBase();

    // Do we really want to connect to SMTP securely
    if (FALSE != m_rServer.fSSL)
    {
        // Do we want to connect to SMTP via a secure socket?
        fSecureSocket = (0 == (m_rServer.dwFlags & ISF_SSLONSAMEPORT));

        // Do we want to use STARTTLS to get the secure connection?
        fConnectTLS = (0 != (m_rServer.dwFlags & ISF_SSLONSAMEPORT));

        Assert(fSecureSocket != fConnectTLS);
    }
    
    // Get connection info needed to init async socket
    hr = m_pSocket->HrInit(m_rServer.szServerName, m_rServer.dwPort, fSecureSocket, m_rServer.dwTimeout);
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_SOCKET_INIT_ERROR);
        goto exit;
    }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_SOCKET_CONNECT_ERROR);
        goto exit;
    }

    // Were busy
    m_fBusy = TRUE;

    // Start WatchDog
    m_pSocket->StartWatchDog();

    // Authenticate
    m_fConnectAuth = fAuthenticate;
    m_fConnectTLS = fConnectTLS;
    m_fCommandLogging = fCommandLogging;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CIxpBase::GetIXPType(void)
{
    return m_ixptype;
}

// --------------------------------------------------------------------------------
// CIxpBase::OnConnected
// --------------------------------------------------------------------------------
void CIxpBase::OnConnected(void)
{
    OnStatus(IXP_CONNECTED);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnDisconnected
// --------------------------------------------------------------------------------
void CIxpBase::OnDisconnected(void)
{
    LeaveBusy();
    OnStatus(IXP_DISCONNECTED);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnNotify
// --------------------------------------------------------------------------------
void CIxpBase::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    switch(ae)
    {
    // --------------------------------------------------------------------------------
    case AE_LOOKUPDONE:
        if (AS_DISCONNECTED == asNew)
        {
            char szFmt[CCHMAX_STRINGRES];
            char szFailureText[CCHMAX_STRINGRES];

            LoadString(g_hLocRes, idsHostNotFoundFmt, szFmt, ARRAYSIZE(szFmt));
            wsprintf(szFailureText, szFmt, m_rServer.szServerName);
            OnError(IXP_E_CANT_FIND_HOST, szFailureText);
            OnDisconnected();
        }
        else
            OnStatus(IXP_CONNECTING);
        break;

    // --------------------------------------------------------------------------------
    case AE_CONNECTDONE:
        if (AS_DISCONNECTED == asNew)
        {
            char szFailureText[CCHMAX_STRINGRES];

            LoadString(g_hLocRes, idsFailedToConnect, szFailureText,
                ARRAYSIZE(szFailureText));
            OnError(IXP_E_FAILED_TO_CONNECT, szFailureText);
            OnDisconnected();
        }
        else if (AS_HANDSHAKING == asNew)
        {
            OnStatus(IXP_SECURING);
        }
        else
            OnConnected();
        break;

    // --------------------------------------------------------------------------------
    case AE_TIMEOUT:
        // Tell the watch dog to take nap
        m_pSocket->StopWatchDog();

        // Provide the client with a change to continue, or abort
        if (m_pCallback && m_pCallback->OnTimeout(&m_rServer.dwTimeout, this) == S_OK)
        {
            // Start the watchdog and wait for normal socket activity
            m_pSocket->StartWatchDog();
        }

        // Otherwise, if we are connected
        else
        {
            // Drop the connection now
            DropConnection();
        }
        break;

    // --------------------------------------------------------------------------------
    case AE_CLOSE:
        if (AS_RECONNECTING != asNew && IXP_AUTHRETRY != m_status)
        {
            if (IXP_DISCONNECTING != m_status && IXP_DISCONNECTED  != m_status)
            {
                char szFailureText[CCHMAX_STRINGRES];

                if (AS_HANDSHAKING == asOld)
                {
                    LoadString(g_hLocRes, idsFailedToConnectSecurely, szFailureText,
                        ARRAYSIZE(szFailureText));
                    OnError(IXP_E_SECURE_CONNECT_FAILED, szFailureText);
                }
                else
                {
                    LoadString(g_hLocRes, idsUnexpectedTermination, szFailureText,
                        ARRAYSIZE(szFailureText));
                    OnError(IXP_E_CONNECTION_DROPPED, szFailureText);
                }
            }
            OnDisconnected();
        }
        break;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
}

// ------------------------------------------------------------------------------------
// CIxpBase::HrReadLine
// ------------------------------------------------------------------------------------
HRESULT CIxpBase::HrReadLine(LPSTR *ppszLine, INT *pcbLine, BOOL *pfComplete)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    IxpAssert(ppszLine && pcbLine && pfComplete);

    // Init
    *ppszLine = NULL;
    *pcbLine = 0;

    // Read the line
    hr = m_pSocket->ReadLine(ppszLine, pcbLine);

    // Incomplete line - wait for next AE_RECV
    if (IXP_E_INCOMPLETE == hr)
    {
        hr = S_OK;
        *pfComplete = FALSE;
        goto exit;
    }

    // Otherwise, if failure...
    else if (FAILED(hr))
    {
        hr = TrapError(IXP_E_SOCKET_READ_ERROR);
        goto exit;
    }

    // Complete
    *pfComplete = TRUE;

    // Log it
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_RX, (*ppszLine));

    // StripCRLF
    StripCRLF((*ppszLine), (ULONG *)pcbLine);

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CIxpBase::HrSendLine
// ------------------------------------------------------------------------------------
HRESULT CIxpBase::HrSendLine(LPSTR pszLine)
{
    // Locals
    HRESULT     hr=S_OK;
    int         iSent;

    // Check Params
    Assert(m_pSocket && pszLine && pszLine[lstrlen(pszLine)-1] == '\n');

    // Reset Last Response
    SafeMemFree(m_pszResponse);
    m_hrResponse = S_OK;
    m_uiResponse = 0;

    // Add Detail
    if (m_fCommandLogging && m_pCallback)
        m_pCallback->OnCommand(CMD_SEND, pszLine, S_OK, this);

    // Log it
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_TX, pszLine);

    // Send it
    hr = m_pSocket->SendBytes(pszLine, lstrlen(pszLine), &iSent);
    if (FAILED(hr) && hr != IXP_E_WOULD_BLOCK)
    {
        hr = TrapError(IXP_E_SOCKET_WRITE_ERROR);
        goto exit;
    }

    // Success
    hr = S_OK;

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CIxpBase::HrSendCommand
// ------------------------------------------------------------------------------------
HRESULT CIxpBase::HrSendCommand(LPSTR pszCommand, LPSTR pszParameters, BOOL fDoBusy)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszLine=NULL;

    // check params
    if (NULL == pszCommand)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Busy...
    if (fDoBusy)
    {
        CHECKHR(hr = HrEnterBusy());
    }

    // Allocate if parameters
    if (pszParameters)
    {
        // Allocate Command Line
        pszLine = PszAlloc(lstrlen(pszCommand) + lstrlen(pszParameters) + 5);
        if (NULL == pszLine)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        // Make Line
        wsprintf (pszLine, "%s %s\r\n", pszCommand, pszParameters);

        // Send
        CHECKHR(hr = HrSendLine(pszLine));
    }

    // Ohterwise, just send the command
    else
    {
        Assert(pszCommand[lstrlen(pszCommand)-1] == '\n');
        CHECKHR(hr = HrSendLine(pszCommand));
    }

exit:
    // Failure
    if (fDoBusy && FAILED(hr))
        LeaveBusy();

    // Cleanup
    SafeMemFree(pszLine);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}



// --------------------------------------------------------------------------------
// CIxpBase::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::GetStatus(IXPSTATUS *pCurrentStatus)
{
    if (NULL == pCurrentStatus)
        return E_INVALIDARG;

    *pCurrentStatus = m_status;
    return S_OK;
} // GetStatus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\davstrs.h ===
#ifdef DEFINE_DAVSTRS

#define DAVSTR(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[] = L#value; \
    EXTERN_C const ULONG ulDAV##name##Len = (ARRAYSIZE(c_szwDAV##name) - 1); \
    EXTERN_C const char c_szDAV##name[] = #value;

#define STRCONST(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[] = L##value; \
    EXTERN_C const ULONG ulDAV##name##Len = (ARRAYSIZE(c_szwDAV##name) - 1); \
    EXTERN_C const char c_szDAV##name[] = value;

#else // DEFINE_DAVSTRS

#define DAVSTR(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[]; \
    EXTERN_C const ULONG ulDAV##name##Len; \
    EXTERN_C const char c_szDAV##name[];

#define STRCONST(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[]; \
    EXTERN_C const ULONG ulDAV##name##Len; \
    EXTERN_C const char c_szDAV##name[];

#endif // DEFINE_DAVSTRS

#define PROP_DAV(name, value)      DAVSTR(name, value)
#define PROP_HTTP(name, value)     DAVSTR(name, value)
#define PROP_HOTMAIL(name, value)  DAVSTR(name, value)
#define PROP_MAIL(name, value)     DAVSTR(name, value)
#define PROP_CONTACTS(name, value) DAVSTR(name, value)

#include "davdef.h"

// Namespaces

STRCONST(DavNamespace, "DAV:")
STRCONST(HotMailNamespace, "http://schemas.microsoft.com/hotmail/")
STRCONST(HTTPMailNamespace, "urn:schemas:httpmail:")
STRCONST(MailNamespace, "urn:schemas:mailheader:")
STRCONST(ContactsNamespace, "urn:schemas:contacts:")

// Special Folders
STRCONST(InboxSpecialFolder,          "inbox");
STRCONST(DeletedItemsSpecialFolder,   "deleteditems");
STRCONST(DraftsSpecialFolder,         "drafts");
STRCONST(OutboxSpecialFolder,         "outbox");
STRCONST(SentItemsSpecialFolder,      "sentitems");
STRCONST(ContactsSpecialFolder,       "contacts");
STRCONST(CalendarSpecialFolder,       "calendar");
STRCONST(MsnPromoSpecialFolder,       "msnpromo");
STRCONST(BulkMailSpecialFolder,       "bulkmail");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpbase.h ===
// --------------------------------------------------------------------------------
// Ixpbase.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPBASE_H
#define __IXPBASE_H

// ------------------------------------------------------------------------------------
// Depends
// ------------------------------------------------------------------------------------
#include "imnxport.h"
#include "asynconn.h"

// --------------------------------------------------------------------------------
// CIxpBase
// --------------------------------------------------------------------------------
class CIxpBase : public IInternetTransport, public IAsyncConnCB, public IAsyncConnPrompt
{

protected:
    BOOL                m_fBusy;          // Are we in the busy state
    IXPSTATUS           m_status;         // Status of the transport
    ULONG               m_cRef;           // Reference Count
    LPSTR               m_pszResponse;    // Last Server Response String
    UINT                m_uiResponse;     // Server Response Error
    HRESULT             m_hrResponse;     // Server Response Error
    ILogFile           *m_pLogFile;       // Logfile Object
    CAsyncConn         *m_pSocket;        // Socket Object
    ITransportCallback *m_pCallback;      // Transport callback object
    INETSERVER          m_rServer;        // Internet Server information
    BOOL                m_fConnectAuth;   // Proceed with user auth
    BOOL                m_fConnectTLS;    // Proceed with TLS encryption
    BOOL                m_fCommandLogging;// Do ITransportCallback::OnCommand
    BOOL                m_fAuthenticated; // Has the user been authenticated successfully...
    IXPTYPE             m_ixptype;        // Transport type
    CRITICAL_SECTION    m_cs;             // Thread Safety

protected:
    HRESULT HrSendLine(LPSTR pszLine);
    HRESULT HrReadLine(LPSTR *ppszLine, INT *pcbLine, BOOL *pfComplete);
    HRESULT HrSendCommand(LPSTR pszCommand, LPSTR pszParameters, BOOL fDoBusy=TRUE);
    HRESULT OnInitNew(LPSTR pszProtocol, LPSTR pszLogFilePath, DWORD dwShareMode, ITransportCallback *pCallback);
    void Reset(void);
    HRESULT HrEnterBusy(void);
    void OnStatus(IXPSTATUS ixpstatus);
    void OnError(HRESULT hrResult, LPSTR pszProblem=NULL);
    void LeaveBusy(void);
    virtual void ResetBase(void) PURE;
    virtual void DoQuit(void) PURE;
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void) PURE;
    virtual void OnLeaveBusy(void) PURE;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CIxpBase(IXPTYPE ixptype);
    virtual ~CIxpBase(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnPrompt methods
    // ----------------------------------------------------------------------------
    int OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    virtual void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    virtual STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    virtual STDMETHODIMP Disconnect(void);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);
};

#endif // __IXPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\imap4.cpp ===
//***************************************************************************
// IMAP4 Protocol Class Implementation (CImap4Agent)
// Written by Raymond Cheng, 3/21/96
//
// This class allows its callers to use IMAP4 client commands without having
// to parse incidental responses from the IMAP4 server (which may contain
// information unrelated to the original command). For instance, during a
// SEARCH command, the IMAP server may issue EXISTS and RECENT responses to
// indicate the arrival of new mail.
//
// The user of this class first creates a connection by calling
// Connect. It is the caller's responsibility to ensure that the
// connection is not severed due to inactivity (autologout). The caller
// can guard against this by periodically sending Noop's.
//***************************************************************************

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include <iert.h>
#include "IMAP4.h"
#include "range.h"
#include "dllmain.h"
#include "resource.h"
#include "mimeole.h"
#include <shlwapi.h>
#include "strconst.h"
#include "demand.h"

// I chose the IInternetTransport from IIMAPTransport instead
// of CIxpBase, because I override some of CIxpBase's IInternetTransport
// implementations, and I want CImap4Agent's versions to take priority.
#define THIS_IInternetTransport ((IInternetTransport *) (IIMAPTransport *) this)


//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------
// *** Stolen from msgout.cpp! Find out how we can SHARE ***
// Assert(FALSE); // Placeholder
// The following is used to allow us to output dates in IMAP-compliant fashion
static LPSTR lpszMonthsOfTheYear[] =
{
    "Filler",
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 
};


const int TAG_BUFSIZE = NUM_TAG_CHARS + 1;
const int MAX_RESOURCESTRING = 512;


// IMAP Stuff
const char cCOMMAND_CONTINUATION_PREFIX = '+';
const char cUNTAGGED_RESPONSE_PREFIX = '*';
const char cSPACE = ' ';

const char c_szIMAP_MSG_ANSWERED[] = "Answered";
const char c_szIMAP_MSG_FLAGGED[] = "Flagged";
const char c_szIMAP_MSG_DELETED[] = "Deleted";
const char c_szIMAP_MSG_DRAFT[] = "Draft";
const char c_szIMAP_MSG_SEEN[] = "Seen";

const char c_szDONE[] = "DONE\r\n";


// *** Unless you can guarantee that g_szSPACE and c_szCRLF stay
// *** US-ASCII, I'll use these. Assert(FALSE); (placeholder)
// const char c_szCRLF[] = "\r\n";
// const char g_szSpace[] = " ";

const boolean TAGGED = TRUE;
const boolean UNTAGGED = FALSE;
const BOOL fFREE_BODY_TAG = TRUE;
const BOOL fDONT_FREE_BODY_TAG = FALSE;
const BOOL tamNEXT_AUTH_METHOD = TRUE;
const BOOL tamCURRENT_AUTH_METHOD = FALSE;
const BOOL rcASTRING_ARG = TRUE;
const BOOL rcNOT_ASTRING_ARG = FALSE;

// For use with SendCmdLine
const DWORD sclAPPEND_TO_END        = 0x00000000; // This option happens by default
const DWORD sclINSERT_BEFORE_PAUSE  = 0x00000001;
const DWORD sclAPPEND_CRLF          = 0x00000002;

const DWORD dwLITERAL_THRESHOLD = 128; // On the conservative side

const MBOX_MSGCOUNT mcMsgCount_INIT = {FALSE, 0L, FALSE, 0L, FALSE, 0L};
const FETCH_BODY_PART FetchBodyPart_INIT = {0, NULL, 0, 0, 0, FALSE, NULL, 0, 0};
const AUTH_STATUS AuthStatus_INIT = {asUNINITIALIZED, FALSE, 0, 0, {0}, {0}, NULL, 0};


//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------


//***************************************************************************
// Function: CImap4Agent (Constructor)
//***************************************************************************
CImap4Agent::CImap4Agent (void) : CIxpBase(IXP_IMAP)
{
    DOUT("CImap4Agent - CONSTRUCTOR");
    
    // Initialize module variables
    m_ssServerState = ssNotConnected;
    m_dwCapabilityFlags = 0;
    *m_szLastResponseText = '\0';
    DllAddRef();
    m_lRefCount = 1;
    m_pCBHandler = NULL;
    m_irsState = irsUNINITIALIZED;
    m_bFreeToSend = TRUE;
    m_fIDLE = FALSE;
    m_ilqRecvQueue = ImapLinefragQueue_INIT;

    InitializeCriticalSection(&m_csTag);
    InitializeCriticalSection(&m_csSendQueue);
    InitializeCriticalSection(&m_csPendingList);

    m_pilfLiteralInProgress = NULL;
    m_dwLiteralInProgressBytesLeft = 0;
    m_fbpFetchBodyPartInProgress = FetchBodyPart_INIT;
    m_dwAppendStreamUploaded = 0;
    m_dwAppendStreamTotal = 0;

    m_bCurrentMboxReadOnly = TRUE;

    m_piciSendQueue = NULL;
    m_piciPendingList = NULL;
    m_piciCmdInSending = NULL;

    m_pInternational = NULL;
    m_dwTranslateMboxFlags = IMAP_MBOXXLATE_DEFAULT;
    m_uiDefaultCP = GetACP(); // Must be default CP because we shipped like this
    m_asAuthStatus = AuthStatus_INIT;

    m_pdwMsgSeqNumToUID = NULL;
    m_dwSizeOfMsgSeqNumToUID = 0;
    m_dwHighestMsgSeqNum = 0;

    m_dwFetchFlags = 0;
} // CImap4Agent



//***************************************************************************
// Function: ~CImap4Agent (Destructor)
//***************************************************************************
CImap4Agent::~CImap4Agent(void)
{
    DOUT("CImap4Agent - DESTRUCTOR");

    Assert(0 == m_lRefCount);

    DropConnection(); // Ignore return result, since there's nothing we can do
    FreeAllData(E_FAIL); // General failure result, if cmds pending while destructor invoked

    DeleteCriticalSection(&m_csTag);
    DeleteCriticalSection(&m_csSendQueue);
    DeleteCriticalSection(&m_csPendingList);

    if (NULL != m_pInternational)
        m_pInternational->Release();

    if (NULL != m_pCBHandler)
        m_pCBHandler->Release();

    DllRelease();
} // ~CImap4Agent



//***************************************************************************
// Function: QueryInterface
//
// Purpose:
//   Read the Win32SDK OLE Programming References (Interfaces) about the
// IUnknown::QueryInterface function for details. This function returns a
// pointer to the requested interface.
//
// Arguments:
//   REFIID iid [in] - an IID identifying the interface to return.
//   void **ppvObject [out] - if successful, this function returns a pointer
//     to the requested interface in this argument.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppvObject);

    // Init variables, check the arguments
    hrResult = E_NOINTERFACE;
    if (NULL == ppvObject) {
        hrResult = E_INVALIDARG;
        goto exit;
    }

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid) {
        // Choose the IIMAPTransport path to IUnknown over the other 3 paths
        // (all through CIxpBase) because this guarantees that CImap4Agent
        // provides the IUnknown implementation.
        *ppvObject = (IUnknown *) (IIMAPTransport *) this;
        ((IUnknown *) (IIMAPTransport *) this)->AddRef();
    }

    if (IID_IInternetTransport == iid) {
        *ppvObject = THIS_IInternetTransport;
        (THIS_IInternetTransport)->AddRef();
    }

    if (IID_IIMAPTransport == iid) {
        *ppvObject = (IIMAPTransport *) this;
        ((IIMAPTransport *) this)->AddRef();
    }

    if (IID_IIMAPTransport2 == iid) {
        *ppvObject = (IIMAPTransport2 *) this;
        ((IIMAPTransport2 *) this)->AddRef();
    }

    // Return success if we managed to snag an interface
    if (NULL != *ppvObject)
        hrResult = S_OK;

exit:
    return hrResult;
} // QueryInterface



//***************************************************************************
// Function: AddRef
//
// Purpose:
//   This function should be called whenever someone makes a copy of a
// pointer to this object. It bumps the reference count so that we know
// there is one more pointer to this object, and thus we need one more
// release before we delete ourselves.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CImap4Agent::AddRef(void)
{
    Assert(m_lRefCount > 0);

    m_lRefCount += 1;

    DOUT ("CImap4Agent::AddRef, returned Ref Count=%ld", m_lRefCount);
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release
//
// Purpose:
//   This function should be called when a pointer to this object is to
// go out of commission. It knocks the reference count down by one, and
// automatically deletes the object if we see that nobody has a pointer
// to this object.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CImap4Agent::Release(void)
{
    Assert(m_lRefCount > 0);
    
    m_lRefCount -= 1;
    DOUT("CImap4Agent::Release, returned Ref Count = %ld", m_lRefCount);

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release



//***************************************************************************
// Function: InitNew
//
// Purpose:
//   This function initializes the CImap4Agent class. This function
// must be the next function called after instantiating the CImap4Agent class.
//
// Arguments:
//   LPSTR pszLogFilePath [in] - path to a log file (where all input and
//     output is logged), if the caller wishes to log IMAP transactions.
//   IIMAPCallback *pCBHandler [in] - pointer to a IIMAPCallback object.
//     This object allows the CImap4Agent class to report all IMAP response
//     results to its user.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::InitNew(LPSTR pszLogFilePath, IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(ssNotConnected == m_ssServerState);
    Assert(irsUNINITIALIZED == m_irsState);

    Assert(NULL != pCBHandler);

    pCBHandler->AddRef();
    m_pCBHandler = pCBHandler;
    m_irsState = irsNOT_CONNECTED;

    hrResult = MimeOleGetInternat(&m_pInternational);
    if (FAILED(hrResult))
        return hrResult;

    return CIxpBase::OnInitNew("IMAP", pszLogFilePath, FILE_SHARE_READ,
        (ITransportCallback *)pCBHandler);
} // InitNew



//***************************************************************************
// Function: SetDefaultCBHandler
//
// Purpose: This function changes the current default IIMAPCallback handler
//   to the given one.
//
// Arguments:
//   IIMAPCallback *pCBHandler [in] - a pointer to the new callback handler.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetDefaultCBHandler(IIMAPCallback *pCBHandler)
{
    Assert(NULL != pCBHandler);
    if (NULL == pCBHandler)
        return E_INVALIDARG;

    if (NULL != m_pCBHandler)
        m_pCBHandler->Release();

    if (NULL != m_pCallback)
        m_pCallback->Release();

    m_pCBHandler = pCBHandler;
    m_pCBHandler->AddRef();
    m_pCallback = pCBHandler;
    m_pCallback->AddRef();
    return S_OK;
} // SetDefaultCBHandler



//***************************************************************************
// Function: SetWindow
//
// Purpose:
//   This function creates the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetWindow(void)
{
    Assert(NULL != m_pSocket);
    return m_pSocket->SetWindow();
} // SetWindow



//***************************************************************************
// Function: ResetWindow
//
// Purpose:
//   This function closes the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ResetWindow(void)
{
    Assert(NULL != m_pSocket);
    return m_pSocket->ResetWindow();
} // ResetWindow



//***************************************************************************
// Function: Connect
//
// Purpose:
//   This function is called to establish a connection with the IMAP server,
// get its capabilities, and to authenticate the user.
//
// Arguments:
//   See explanation in imnxport.idl.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Connect(LPINETSERVER pInetServer,
                                               boolean fAuthenticate,
                                               boolean fCommandLogging)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(ssAuthenticated > m_ssServerState);
    Assert(irsUNINITIALIZED < m_irsState);

    // We do not accept all combinations of argument: the caller cannot
    // perform his own authentication, and thus we MUST be responsible for
    // this. Even if PREAUTH is expected, we expect fAuthenticate to be TRUE.
    if (FALSE == fAuthenticate) {
        AssertSz(FALSE, "Current IIMAPTransport interface requires that fAuthenticate be TRUE.");
        return E_FAIL;
    }

    // Neither can we call the OnCommand callback
    if (fCommandLogging) {
        AssertSz(FALSE, "Current IIMAPTransport interface requires that fCommandLogging be FALSE.");
        return E_FAIL;
    }

    // Does user want us to always prompt for his password? Prompt him here to avoid
    // inactivity timeouts while the prompt is up. Do not prompt if password supplied.
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pInetServer->szPassword[0]) {
        if (NULL != m_pCallback)
            hrResult = m_pCallback->OnLogonPrompt(pInetServer, THIS_IInternetTransport);

        if (NULL == m_pCallback || S_OK != hrResult)
            return IXP_E_USER_CANCEL;
    }

    // If we reach this point, we need to establish a connection to IMAP server
    Assert(ssNotConnected == m_ssServerState);
    Assert(irsNOT_CONNECTED == m_irsState);

    hrResult = CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
    if (SUCCEEDED(hrResult)) {
        m_irsState = irsSVR_GREETING;
        m_ssServerState = ssConnecting;
    }

    return hrResult;
} // Connect



//***************************************************************************
// Function: ReLoginUser
//
// Purpose:
//   This function is called to re-attempt user authentication after a
// failed attempt. It calls ITransportCallback::OnLogonPrompt to allow
// the user to provide the correct logon information.
//***************************************************************************
void CImap4Agent::ReLoginUser(void)
{
    HRESULT hrResult;
    char szFailureText[MAX_RESOURCESTRING];

    AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");

    if (NULL == m_pCallback) {
        // We can't do a damned thing, drop connection (this can happen due to HandsOffCallback)
        DropConnection();
        return;
    }

    // Init variables
    szFailureText[0] = '\0';

    // First, put us in IXP_AUTHRETRY mode so that OnStatus is not called
    // for changes to the connection status
    OnStatus(IXP_AUTHRETRY);

    // OK, connection status is no longer being reported to the user
    // Ask the user for his stinking password
    hrResult = m_pCallback->OnLogonPrompt(&m_rServer, THIS_IInternetTransport);
    if (FAILED(hrResult) || S_FALSE == hrResult) {
        AssertSz(SUCCEEDED(hrResult), "OnLogonPrompt is supposed to return S_OK or S_FALSE!");

        DropConnection();
        goto exit;
    }

    // If we've reached this point, user hit the "OK" button
    // Check if we're still connected to the IMAP server
    if (irsNOT_CONNECTED < m_irsState) {
        // Still connected! Just try to authenticate
        LoginUser();
    }
    else {
        // Connect to server. We'll authenticate after connection established
        hrResult = Connect(&m_rServer, (boolean) !!m_fConnectAuth, (boolean) !!m_fCommandLogging);
        if (FAILED(hrResult))
            LoadString(g_hLocRes, idsConnectError, szFailureText,
                ARRAYSIZE(szFailureText));
    }

exit:
    if (FAILED(hrResult)) {
        // Terminate login procedure and notify user
        OnIMAPError(hrResult, szFailureText, DONT_USE_LAST_RESPONSE);
    }
} // ReLoginUser



//***************************************************************************
// Function: Disconnect
//
// Purpose:
//    This function issues a LOGOUT command to the IMAP server and waits for
// the server to process the LOGOUT command before dropping the connection.
// This allows any currently executing commands to complete their execution.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Disconnect(void)
{
    return CIxpBase::Disconnect();
} // Disconnect



//***************************************************************************
// Function: DropConnection
//
// Purpose:
//   This function issues a LOGOUT command to the IMAP server (if we
// currently have nothing in the send queue), then drops the connection
// before logout command completes.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::DropConnection(void)
{
    Assert(m_lRefCount >= 0); // This function is called during destruction

    // You have to be connected to send a LOGOUT: ignore authorization states
    if (IXP_CONNECTED != m_status)
        goto exit; // Just close the CAsyncConn class

    // We send a logout command IF WE CAN, just as a courtesy. Our main goal
    // is to drop the connection, NOW.

    // If no commands in our send queue, send Logout command. Note that this
    // is no guarantee that CASyncConn is idle, but at least there's a chance
    if (NULL == m_piciCmdInSending ||
        (m_fIDLE && icIDLE_COMMAND == m_piciCmdInSending->icCommandID &&
        iltPAUSE == m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment->iltFragmentType)) {
        HRESULT hrLogoutResult;
        const char cszLogoutCmd[] = "ZZZZ LOGOUT\r\n";
        char sz[sizeof(cszLogoutCmd) + sizeof(c_szDONE)]; // Bigger than I need, but who cares
        int iNumBytesSent, iStrLen;

        // Construct logout or done+logout string
        if (m_fIDLE) {
            lstrcpy(sz, c_szDONE);
            lstrcpy(sz + sizeof(c_szDONE) - 1, cszLogoutCmd);
            iStrLen = sizeof(c_szDONE) + sizeof(cszLogoutCmd) - 2;
        }
        else {
            lstrcpy(sz, cszLogoutCmd);
            iStrLen = sizeof(cszLogoutCmd) - 1;
        }
        Assert(iStrLen == lstrlen(sz));

        hrLogoutResult = m_pSocket->SendBytes(sz, iStrLen, &iNumBytesSent);
        Assert(SUCCEEDED(hrLogoutResult));
        Assert(iNumBytesSent == iStrLen);
        if (m_pLogFile)
            m_pLogFile->WriteLog(LOGFILE_TX, "Dropping connection, LOGOUT sent");
    }
    else {
        if (m_pLogFile)
            m_pLogFile->WriteLog(LOGFILE_TX, "Dropping connection, LOGOUT not sent");
    } // else

exit:
    // Drop our connection, with status indication
    return CIxpBase::DropConnection();
} // DropConnection



//***************************************************************************
// Function: ProcessServerGreeting
//
// Purpose:
//   This function is invoked when the receiver state machine is in
// irsSVR_GREETING and a response line is received from the server. This
// function takes a server greeting line (issued immediately when a
// connection is established with the IMAP server) and parses it to
// determine if: a) We are pre-authorized, and therefore do not need to
// login, b) We have been refused the connection, or c) We must login.
//
// Arguments:
//   char *pszResponseLine [in] - the server greeting issued upon connection.
//   DWORD dwNumBytesReceived [in] - length of pszResponseLine string.
//***************************************************************************
void CImap4Agent::ProcessServerGreeting(char *pszResponseLine,
                                        DWORD dwNumBytesReceived)
{
    HRESULT hrResult;
    IMAP_RESPONSE_ID irResult;
    char szFailureText[MAX_RESOURCESTRING];
    BOOL bUseLastResponse;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != pszResponseLine);

    // Initialize variables
    szFailureText[0] = '\0';
    hrResult = E_FAIL;
    bUseLastResponse = FALSE;

    // Whatever happens next, we no longer expect server greeting - change state
    m_irsState = irsIDLE;

    // We have some kind of server response, so leave the busy state
    AssertSz(m_fBusy, "Check your logic: we should be busy until we get svr greeting!");
    LeaveBusy();

    // Server response is either OK, BYE or PREAUTH - find out which
    CheckForCompleteResponse(pszResponseLine, dwNumBytesReceived, &irResult);

    // Even if above fn fails, irResult should be valid (eg, irNONE)
    switch (irResult) {
        case irPREAUTH_RESPONSE:
            // We were pre-authorized by the server! Login is complete.
            // Send capability command
            Assert(ssAuthenticated == m_ssServerState);
            hrResult = NoArgCommand("CAPABILITY", icCAPABILITY_COMMAND,
                ssNonAuthenticated, 0, 0, DEFAULT_CBHANDLER);
            break;
    
        case irBYE_RESPONSE:
            // Server blew us off (ie, issued BYE)! Login failed.
            Assert(ssNotConnected == m_ssServerState);
            hrResult = IXP_E_IMAP_CONNECTION_REFUSED;
            LoadString(g_hLocRes, idsSvrRefusesConnection, szFailureText,
                ARRAYSIZE(szFailureText));
            bUseLastResponse = TRUE;
            break;
        
        case irOK_RESPONSE: {
            // Server response was "OK". We need to log in.
            Assert(ssConnecting == m_ssServerState);
            m_ssServerState = ssNonAuthenticated;

            // Send capability command - on its completion, we'll authenticate
            hrResult = NoArgCommand("CAPABILITY", icCAPABILITY_COMMAND,
                ssNonAuthenticated, 0, 0, DEFAULT_CBHANDLER);
            break;
        } // case hrIMAP_S_OK_RESPONSE

        default:
            // Has server gone absolutely LOOPY?
            AssertSz(FALSE, "What kind of server greeting is this?");
            hrResult = E_FAIL;
            LoadString(g_hLocRes, idsUnknownIMAPGreeting, szFailureText,
                ARRAYSIZE(szFailureText));
            bUseLastResponse = TRUE;
            break;
    } // switch(hrResult)

    if (FAILED(hrResult)) {
        if ('\0' == szFailureText[0]) {
            LoadString(g_hLocRes, idsFailedIMAPCmdSend, szFailureText,
                ARRAYSIZE(szFailureText));
        }

        // Terminate login procedure and notify user
        OnIMAPError(hrResult, szFailureText, bUseLastResponse);
        DropConnection();
    }
} // ProcessServerGreeting



//***************************************************************************
// Function: LoginUser
//
// Purpose:
//   This function is responsible for kickstarting the login process.
//
// Returns:
//   Nothing, because any errors are reported via CmdCompletionNotification
// callback to the user. Any errors encountered in this function will be
// encountered during command transmittal, and so there's nothing further we
// can do... may as well end the login process here.
//***************************************************************************
void CImap4Agent::LoginUser(void)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(ssNotConnected != m_ssServerState);
    AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");

    // Put us in Authentication mode
    OnStatus(IXP_AUTHORIZING);

    // Check first if we're already authenticated (eg, by PREAUTH greeting)
    if (ssAuthenticated <= m_ssServerState) {
        // We were preauthed. Notify user that login is complete
        OnStatus(IXP_AUTHORIZED);
        return;
    }

    // Use the old "Login" trick (cleartext passwords and all)
    hrResult = TwoArgCommand("LOGIN", m_rServer.szUserName, m_rServer.szPassword,
        icLOGIN_COMMAND, ssNonAuthenticated, 0, 0, DEFAULT_CBHANDLER);

    if (FAILED(hrResult)) {
        char szFailureText[MAX_RESOURCESTRING];

        // Could not send cmd: terminate login procedure and notify user
        LoadString(g_hLocRes, idsFailedIMAPCmdSend, szFailureText,
            ARRAYSIZE(szFailureText));
        OnIMAPError(hrResult, szFailureText, DONT_USE_LAST_RESPONSE);
        DropConnection();
    }
} // LoginUser



//***************************************************************************
// Function: AuthenticateUser
//
// Purpose:
//   This function handles our behaviour during non-cleartext (SSPI)
// authentication. It is very heavily based on CPOP3Transport::ResponseAUTH.
// Note that due to server interpretation problems during testing, I decided
// that BAD and NO responses will be treated as the same thing for purposes
// of authentication.
//
// Arguments:
//   AUTH_EVENT aeEvent [in] - the authentication event currently occuring.
//     This can be something like aeCONTINUE, for instance.
//   LPSTR pszServerData [in] - any data from the server associated with the
//     current authentication event. Set to NULL if no data is applicable.
//   DWORD dwSizeOfData [in] - the size of the buffer pointed to by
//     pszServerData.
//***************************************************************************
void CImap4Agent::AuthenticateUser(AUTH_EVENT aeEvent, LPSTR pszServerData,
                                   DWORD dwSizeOfData)
{
    HRESULT hrResult;
    UINT uiFailureTextID;
    BOOL fUseLastResponse;

    // Initialize variables
    hrResult = S_OK;
    uiFailureTextID = 0;
    fUseLastResponse = FALSE;

    // Suspend the watchdog for this entire function
    LeaveBusy();

    // Handle the events for which the current state is unimportant
    if (aeBAD_OR_NO_RESPONSE == aeEvent && asUNINITIALIZED < m_asAuthStatus.asCurrentState) {
        BOOL fTryNextAuthPkg;

        // Figure out whether we should try the next auth pkg, or re-try current
        if (asWAITFOR_CHALLENGE == m_asAuthStatus.asCurrentState ||
            asWAITFOR_AUTHENTICATION == m_asAuthStatus.asCurrentState)
            fTryNextAuthPkg = tamCURRENT_AUTH_METHOD;
        else
            fTryNextAuthPkg = tamNEXT_AUTH_METHOD;

        // Send the AUTHENTICATE command
        hrResult = TryAuthMethod(fTryNextAuthPkg, &uiFailureTextID);
        if (FAILED(hrResult))
            // No more auth methods to try: disconnect and end session
            fUseLastResponse = TRUE;
        else {
            // OK, wait for server response
            m_asAuthStatus.asCurrentState = asWAITFOR_CONTINUE;
            if (tamCURRENT_AUTH_METHOD == fTryNextAuthPkg)
                m_asAuthStatus.fPromptForCredentials = TRUE;
        }

        goto exit;
    }
    else if (aeABORT_AUTHENTICATION == aeEvent) {
        // We received an unknown tagged response from the server: bail
        hrResult = E_FAIL;
        uiFailureTextID = idsIMAPAbortAuth;
        fUseLastResponse = TRUE;
        goto exit;
    }


    // Now, process auth events based on our current state
    switch (m_asAuthStatus.asCurrentState) {
        case asUNINITIALIZED: {
            BOOL fResult;

            // Check conditions
            if (aeStartAuthentication != aeEvent) {
                AssertSz(FALSE, "You can only start authentication in this state");
                break;
            }
            Assert(NULL == pszServerData && 0 == dwSizeOfData);

            // Put us in Authentication mode
            OnStatus(IXP_AUTHORIZING);

            // Check first if we're already authenticated (eg, by PREAUTH greeting)
            if (ssAuthenticated <= m_ssServerState) {
                // We were preauthed. Notify user that login is complete
                OnStatus(IXP_AUTHORIZED);
                break;
            }

            // Initialize SSPI
            fResult = FIsSicilyInstalled();
            if (FALSE == fResult) {
                hrResult = E_FAIL;
                uiFailureTextID = idsIMAPSicilyInitFail;
                break;
            }

            hrResult = SSPIGetPackages(&m_asAuthStatus.pPackages,
                &m_asAuthStatus.cPackages);
            if (FAILED(hrResult)) {
                uiFailureTextID = idsIMAPSicilyPkgFailure;
                break;
            }

            // Send AUTHENTICATE command
            Assert(0 == m_asAuthStatus.iCurrentAuthToken);
            hrResult = TryAuthMethod(tamNEXT_AUTH_METHOD, &uiFailureTextID);
            if (FAILED(hrResult))
                break;

            m_asAuthStatus.asCurrentState = asWAITFOR_CONTINUE;
        } // case asUNINITIALIZED
            break; // case asUNINITIALIZED


        case asWAITFOR_CONTINUE: {
            SSPIBUFFER Negotiate;

            if (aeCONTINUE != aeEvent) {
                AssertSz(FALSE, "What am I supposed to do with this auth-event in this state?");
                break;
            }

            // Server wants us to continue: send negotiation string
            hrResult = SSPILogon(&m_asAuthStatus.rSicInfo, m_asAuthStatus.fPromptForCredentials, SSPI_BASE64,
                m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken-1], &m_rServer, m_pCBHandler);
            if (FAILED(hrResult)) {
                // Suppress error reportage - user may have hit cancel
                hrResult = CancelAuthentication();
                break;
            }

            if (m_asAuthStatus.fPromptForCredentials) {
                m_asAuthStatus.fPromptForCredentials = FALSE; // Don't prompt again
            }

            hrResult = SSPIGetNegotiate(&m_asAuthStatus.rSicInfo, &Negotiate);
            if (FAILED(hrResult)) {
                // Suppress error reportage - user may have hit cancel
                // Or the command was killed (with the connection)
                // Only cancel if we still have a pending command...
                if(m_piciCmdInSending)
                    hrResult = CancelAuthentication();
                break;
            }

            // Append CRLF to negotiation string
            Negotiate.szBuffer[Negotiate.cbBuffer - 1] = '\r';
            Negotiate.szBuffer[Negotiate.cbBuffer] = '\n';
            Negotiate.szBuffer[Negotiate.cbBuffer + 1] = '\0';
            Negotiate.cbBuffer += 2;
            Assert(Negotiate.cbBuffer <= sizeof(Negotiate.szBuffer));
            Assert(Negotiate.szBuffer[Negotiate.cbBuffer - 1] == '\0');

            hrResult = SendCmdLine(m_piciCmdInSending, sclINSERT_BEFORE_PAUSE,
                Negotiate.szBuffer, Negotiate.cbBuffer - 1);
            if (FAILED(hrResult))
                break;

            m_asAuthStatus.asCurrentState = asWAITFOR_CHALLENGE;
        } // case asWAITFOR_CONTINUE
            break; // case asWAITFOR_CONTINUE


        case asWAITFOR_CHALLENGE: {
            SSPIBUFFER rChallenge, rResponse;
            int iChallengeLen;

            if (aeCONTINUE != aeEvent) {
                AssertSz(FALSE, "What am I supposed to do with this auth-event in this state?");
                break;
            }

            // Server has given us a challenge: respond to challenge
            SSPISetBuffer(pszServerData, SSPI_STRING, 0, &rChallenge);

            hrResult = SSPIResponseFromChallenge(&m_asAuthStatus.rSicInfo, &rChallenge, &rResponse);
            if (FAILED(hrResult)) {
                // Suppress error reportage - user could have hit cancel
                hrResult = CancelAuthentication();
                break;
            }

            // Append CRLF to response string
            rResponse.szBuffer[rResponse.cbBuffer - 1] = '\r';
            rResponse.szBuffer[rResponse.cbBuffer] = '\n';
            rResponse.szBuffer[rResponse.cbBuffer + 1] = '\0';
            rResponse.cbBuffer += 2;
            Assert(rResponse.cbBuffer <= sizeof(rResponse.szBuffer));
            Assert(rResponse.szBuffer[rResponse.cbBuffer - 1] == '\0');

            hrResult = SendCmdLine(m_piciCmdInSending, sclINSERT_BEFORE_PAUSE,
                rResponse.szBuffer, rResponse.cbBuffer - 1);
            if (FAILED(hrResult))
                break;

            if (FALSE == rResponse.fContinue)
                m_asAuthStatus.asCurrentState = asWAITFOR_AUTHENTICATION;
        } // case asWAITFOR_CHALLENGE
            break; // case asWAITFOR_CHALLENGE


        case asWAITFOR_AUTHENTICATION:

            // If OK response, do nothing
            if (aeOK_RESPONSE != aeEvent) {
                AssertSz(FALSE, "What am I supposed to do with this auth-event in this state?");
                break;
            }
            break; // case asWAITFOR_AUTHENTICATION


        case asCANCEL_AUTHENTICATION:
            AssertSz(aeBAD_OR_NO_RESPONSE == aeEvent, "I cancelled an authentication and didn't get BAD");
            break; // case asCANCEL_AUTHENTICATION


        default:
            AssertSz(FALSE, "Invalid or unhandled state?");
            break; // Default case
    } // switch (aeEvent)

exit:
    if (FAILED(hrResult)) {
        char szFailureText[MAX_RESOURCESTRING];
        char szFailureFmt[MAX_RESOURCESTRING/4];
        char szGeneral[MAX_RESOURCESTRING/4]; // Ack, how big could the word, "General" be?
        LPSTR p, pszAuthPkg;

        LoadString(g_hLocRes, idsIMAPAuthFailedFmt, szFailureFmt, ARRAYSIZE(szFailureFmt));
        if (0 == m_asAuthStatus.iCurrentAuthToken) {
            LoadString(g_hLocRes, idsGeneral, szGeneral, ARRAYSIZE(szGeneral));
            pszAuthPkg = szGeneral;
        }
        else
            pszAuthPkg = m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken-1];

        p = szFailureText;
        p += wsprintf(szFailureText, szFailureFmt, pszAuthPkg);
        if (0 != uiFailureTextID)
            LoadString(g_hLocRes, uiFailureTextID, p,
                ARRAYSIZE(szFailureText) - (DWORD) (p - szFailureText));
        OnIMAPError(hrResult, szFailureText, fUseLastResponse);
        
        DropConnection();
    }
    // Reawaken the watchdog, if required
    else if (FALSE == m_fBusy &&
        (NULL != m_piciPendingList || NULL != m_piciCmdInSending)) {
        hrResult = HrEnterBusy();
        Assert(SUCCEEDED(hrResult));
    }
} // AuthenticateUser



//***************************************************************************
// Function: TryAuthMethod
//
// Purpose:
//   This function sends out an AUTHENTICATE command to the server with the
// appropriate authentication method. The caller can choose which method is
// more appropriate: he can re-try the current authentication method, or
// move on to the next authentication command which is supported by both
// server and client.
//
// Arguments:
//   BOOL fNextAuthMethod [in] - TRUE if we should attempt to move on to
//     the next authentication package. FALSE if we should re-try the
//     current authentication package.
//   UINT *puiFailureTextID [out] - in case of failure, (eg, no more auth
//     methods to try), this function returns a string resource ID here which
//     describes the error.
//
// Returns:
//   HRESULT indicating success or failure. Expected failure codes include:
//     IXP_E_IMAP_AUTH_NOT_POSSIBLE - indicates server does not support
//       any auth packages which are recognized on this computer.
//     IXP_E_IMAP_OUT_OF_AUTH_METHODS - indicates that one or more auth
//       methods were attempted, and no more auth methods are left to try.
//***************************************************************************
HRESULT CImap4Agent::TryAuthMethod(BOOL fNextAuthMethod, UINT *puiFailureTextID)
{
    BOOL fFoundMatch;
    HRESULT hrResult;
    char szBuffer[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    int iStartingAuthToken;
    LPSTR p;

    Assert(m_lRefCount > 0);

    // Initialize variables
    hrResult = S_OK;
    piciCommand = NULL;

    // Only accept cmds if server is in proper state
    if (ssNonAuthenticated != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    // If we've already tried an auth pkg, free its info
    if (0 != m_asAuthStatus.iCurrentAuthToken)
        SSPIFreeContext(&m_asAuthStatus.rSicInfo);

    // Find the next auth token (returned by svr) that we support on this computer
    fFoundMatch = FALSE;
    iStartingAuthToken = m_asAuthStatus.iCurrentAuthToken;
    while (fFoundMatch == FALSE &&
        m_asAuthStatus.iCurrentAuthToken < m_asAuthStatus.iNumAuthTokens &&
        fNextAuthMethod) {
        ULONG ul = 0;

        // Current m_asAuthStatus.iCurrentAuthToken serves as idx to NEXT auth token
        // Compare current auth token with all installed packages
        for (ul = 0; ul < m_asAuthStatus.cPackages; ul++) {
            if (0 == lstrcmpi(m_asAuthStatus.pPackages[ul].pszName,
                m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken])) {
                fFoundMatch = TRUE;
                break;
            } // if
        } // for

        // Update this to indicate the current auth token ORDINAL (not idx)
        m_asAuthStatus.iCurrentAuthToken += 1;
    } // while

    if (FALSE == fFoundMatch && fNextAuthMethod) {
        // Could not find next authentication method match-up
        if (0 == iStartingAuthToken) {
            *puiFailureTextID = idsIMAPAuthNotPossible;
            return IXP_E_IMAP_AUTH_NOT_POSSIBLE;
        }
        else {
            *puiFailureTextID = idsIMAPOutOfAuthMethods;
            return IXP_E_IMAP_OUT_OF_AUTH_METHODS;
        }
    }

    // OK, m_asAuthStatus.iCurrentAuthToken should now point to correct match
    piciCommand = new CIMAPCmdInfo(this, icAUTHENTICATE_COMMAND, ssNonAuthenticated,
        0, 0, NULL);
    if (NULL == piciCommand) {
        *puiFailureTextID = idsMemory;
        return E_OUTOFMEMORY;
    }

    // Construct command line
    p = szBuffer;
    p += wsprintf(szBuffer, "%s %s %.300s\r\n", piciCommand->szTag, "AUTHENTICATE",
        m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken-1]);

    // Send command
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szBuffer, (DWORD) (p - szBuffer));
    if (FAILED(hrResult))
        goto SendError;

    // Insert a pause, so we can perform challenge/response
    hrResult = SendPause(piciCommand);
    if (FAILED(hrResult))
        goto SendError;

    // Transmit command and register with IMAP response parser    
    hrResult = SubmitIMAPCommand(piciCommand);

SendError:
    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // TryAuthMethod



//***************************************************************************
// Function: CancelAuthentication
//
// Purpose:
//   This function cancels the authentication currently in progress,
// typically due to a failure result from a Sicily function. It sends a "*"
// to the server and puts us into cancellation mode.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::CancelAuthentication(void)
{
    HRESULT hrResult;

    hrResult = SendCmdLine(m_piciCmdInSending, sclINSERT_BEFORE_PAUSE, "*\r\n", 3);
    m_asAuthStatus.asCurrentState = asCANCEL_AUTHENTICATION;
    return hrResult;
} // CancelAuthentication



//***************************************************************************
// Function: OnCommandCompletion
//
// Purpose:
//   This function is called whenever we have received a tagged response line
// terminating the current command in progress, whether or not the command
// result was successful or not. This function notifies the user of the
// command's results, and handles other tasks such as updating our internal
// mirror of the server state and calling notification functions.
//
// Arguments:
//   LPSTR szTag [in] - the tag found in the tagged response line. This will
//     be used to compare with a list of commands in progress when we allow
//     multiple simultaneous commands, but is not currently used.
//   HRESULT hrCompletionResult [in] - the HRESULT returned by the IMAP line
//     parsing functions, eg, S_OK or IXP_E_IMAP_SVR_SYNTAXERR.
//   IMAP_RESPONSE_ID irCompletionResponse [in] - identifies the status response
//     of the tagged response line (OK/NO/BAD).
//***************************************************************************
void CImap4Agent::OnCommandCompletion(LPSTR szTag, HRESULT hrCompletionResult,
                                      IMAP_RESPONSE_ID irCompletionResponse)
{
    CIMAPCmdInfo *piciCompletedCmd;
    boolean bSuppressCompletionNotification;

    Assert(m_lRefCount > 0);
    Assert(NULL != szTag);
    Assert(NULL != m_piciPendingList || NULL != m_piciCmdInSending);

    bSuppressCompletionNotification = FALSE;

    // ** STEP ONE: Identify the corresponding command for given tagged response
    // Search the pending-command chain for the given tag
    piciCompletedCmd = RemovePendingCommand(szTag);
    if (NULL == piciCompletedCmd) {
        BOOL fLeaveBusy = FALSE;

        // Couldn't find in pending list, check the command in sending
        EnterCriticalSection(&m_csSendQueue);
        if (NULL != m_piciCmdInSending &&
            0 == lstrcmp(szTag, m_piciCmdInSending->szTag)) {
            piciCompletedCmd = DequeueCommand();
            fLeaveBusy = TRUE;
        }
        else {
            AssertSz(FALSE, "Could not find cmd corresponding to tagged response!");
        }
        LeaveCriticalSection(&m_csSendQueue);

        // Now we're out of &m_csSendQueue, call LeaveBusy (needs m_cs). Avoids deadlock.
        if (fLeaveBusy)
            LeaveBusy(); // This needs CIxpBase::m_cs, so having &m_csSendQueue may deadlock
    }

    // Did we find a command which matches the given tag?
    if (NULL == piciCompletedCmd)
        return; // $REVIEW: Should probably return an error to user
                // $REVIEW: I don't think I need to bother to pump the send queue


    
	// ** STEP TWO: Perform end-of-command actions
    // Translate hrCompletionResult depending on response received
    switch (irCompletionResponse) {
        case irOK_RESPONSE:
            Assert(S_OK == hrCompletionResult);
            break;

        case irNO_RESPONSE:
            Assert(S_OK == hrCompletionResult);
            hrCompletionResult = IXP_E_IMAP_TAGGED_NO_RESPONSE;
            break;

        case irBAD_RESPONSE:
            Assert(S_OK == hrCompletionResult);
            hrCompletionResult = IXP_E_IMAP_BAD_RESPONSE;
            break;

        default:
            // If none of the above, hrResult had better be failure
            Assert(FAILED(hrCompletionResult));
            break;
    }

    // Perform any actions which follow the successful (or unsuccessful)
    // completion of an IMAP command
    switch (piciCompletedCmd->icCommandID) {
        case icAUTHENTICATE_COMMAND: {
            AUTH_EVENT aeEvent;

            // We always suppress completion notification for this command,
            // because it is sent by internal code (not by the user)
            bSuppressCompletionNotification = TRUE;

            if (irOK_RESPONSE == irCompletionResponse)
                aeEvent = aeOK_RESPONSE;
            else if (irNO_RESPONSE == irCompletionResponse ||
                     irBAD_RESPONSE == irCompletionResponse)
                aeEvent = aeBAD_OR_NO_RESPONSE;
            else
                aeEvent = aeABORT_AUTHENTICATION;

            AuthenticateUser(aeEvent, NULL, 0);

            if (SUCCEEDED(hrCompletionResult)) {
                m_ssServerState = ssAuthenticated;
                AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");
                OnStatus(IXP_AUTHORIZED);
            }

            // Make sure we were paused
            Assert(iltPAUSE == piciCompletedCmd->pilqCmdLineQueue->
                pilfFirstFragment->iltFragmentType);
        } // case icAUTHENTICATE_COMMAND
            break; // case icAUTHENTICATE_COMMAND

        case icLOGIN_COMMAND:
            // We always suppress completion notification for this command,
            // because it is sent by internal code (not by the user)
            bSuppressCompletionNotification = TRUE;

            if (SUCCEEDED(hrCompletionResult)) {
                m_ssServerState = ssAuthenticated;
                AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");
                OnStatus(IXP_AUTHORIZED);
            }
            else {
                char szFailureText[MAX_RESOURCESTRING];

                Assert(ssAuthenticated > m_ssServerState);
                LoadString(g_hLocRes, idsFailedLogin, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(IXP_E_IMAP_LOGINFAILURE, szFailureText, USE_LAST_RESPONSE);
                ReLoginUser(); // Re-attempt login
            } // else
            
            break; // case icLOGIN_COMMAND

        case icCAPABILITY_COMMAND:
            // We always suppress completion notification for this command
            // because it is sent by internal code (not by the user)
            bSuppressCompletionNotification = TRUE;
            
            if (SUCCEEDED(hrCompletionResult)) {
                AssertSz(m_fConnectAuth, "Now just HOW does IIMAPTransport user do auth?");
                if (m_rServer.fTrySicily)
                    AuthenticateUser(aeStartAuthentication, NULL, 0);
                else
                    LoginUser();
            }
            else {
                char szFailureText[MAX_RESOURCESTRING];

                // Stop login process and report error to caller
                LoadString(g_hLocRes, idsIMAPFailedCapability, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(hrCompletionResult, szFailureText, USE_LAST_RESPONSE);
                DropConnection();
            }

            break; // case icCAPABILITY_COMMAND


        case icSELECT_COMMAND:
        case icEXAMINE_COMMAND:
            if (SUCCEEDED(hrCompletionResult))
                m_ssServerState = ssSelected;
            else
                m_ssServerState = ssAuthenticated;

            break; // case icSELECT_COMMAND and icEXAMINE_COMMAND

        case icCLOSE_COMMAND:
            // $REVIEW: Should tagged NO response also go to ssAuthenticated?
            if (SUCCEEDED(hrCompletionResult)) {
                m_ssServerState = ssAuthenticated;
                ResetMsgSeqNumToUID();
            }

            break; // case icCLOSE_COMMAND

        case icLOGOUT_COMMAND:
            // We always suppress completion notification for this command
            bSuppressCompletionNotification = TRUE; // User can't send logout: it's sent internally

            // Drop the connection (without status indication) regardless of
            // whether LOGOUT succeeded or failed
            Assert(SUCCEEDED(hrCompletionResult)); // Debug-only detection of hanky-panky
            m_pSocket->Close();
            ResetMsgSeqNumToUID(); // Just in case, SHOULD be handled by OnDisconnected,FreeAllData

            break; // case icLOGOUT_COMMAND;

        case icIDLE_COMMAND:
            bSuppressCompletionNotification = TRUE; // User can't send IDLE: it's sent internally
            m_fIDLE = FALSE; // We are now out of IDLE mode
            break; // case icIDLE_COMMAND

        case icAPPEND_COMMAND:
            m_dwAppendStreamUploaded = 0;
            m_dwAppendStreamTotal = 0;
            break; // case icAPPEND_COMMAND
    } // switch (piciCompletedCmd->icCommandID)


    // ** STEP THREE: Perform notifications.    
    // Notify the user that this command has completed, unless we're told to
    // suppress it (usually done to treat the multi-step login process as
    // one operation).
    if (FALSE == bSuppressCompletionNotification) {
        IMAP_RESPONSE irIMAPResponse;

        irIMAPResponse.wParam = piciCompletedCmd->wParam;
        irIMAPResponse.lParam = piciCompletedCmd->lParam;
        irIMAPResponse.hrResult = hrCompletionResult;
        irIMAPResponse.lpszResponseText = m_szLastResponseText;
        irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
        OnIMAPResponse(piciCompletedCmd->pCBHandler, &irIMAPResponse);
    }

    // Delete CIMAPCmdInfo object
    // Note that deleting a CIMAPCmdInfo object automatically flushes its send queue
    delete piciCompletedCmd;

    // Finally, pump the send queue, if another cmd is available
    if (NULL != m_piciSendQueue)
        ProcessSendQueue(iseSEND_COMMAND);
    else if (NULL == m_piciPendingList &&
        m_ssServerState >= ssAuthenticated && irsIDLE == m_irsState)
        // Both m_piciSendQueue and m_piciPendingList are empty: send IDLE cmd
        EnterIdleMode();
} // OnCommandCompletion



//***************************************************************************
// Function: CheckForCompleteResponse
//
// Purpose:
//   Given a response line (which isn't part of a literal), this function
// checks the end of the line to see if a literal is coming. If so, then we
// prepare the receiver FSM for it. Otherwise, this constitutes the end
// of an IMAP response, so we may parse as required.
//
// Arguments:
//   LPSTR pszResponseLine [in] - this points to the response line sent to
//     us by the IMAP server.
//   DWORD dwNumBytesRead [in] - the length of pszResponseLine.
//   IMAP_RESPONSE_ID *pirParseResult [out] - if the function determines that
//     we can parse the response, the parse result is stored here (eg,
//     irOK_RESPONSE). Otherwise, irNONE is written to the pointed location.
//***************************************************************************
void CImap4Agent::CheckForCompleteResponse(LPSTR pszResponseLine,
                                           DWORD dwNumBytesRead,
                                           IMAP_RESPONSE_ID *pirParseResult)
{
    HRESULT hrResult;
    boolean bTagged;
    IMAP_LINE_FRAGMENT *pilfLine;
    LPSTR psz;
    BOOL fLiteral = FALSE;

    Assert(m_lRefCount > 0);
    Assert(NULL != pszResponseLine);
    Assert(NULL == m_pilfLiteralInProgress);
    Assert(0 == m_dwLiteralInProgressBytesLeft);
    Assert(NULL != pirParseResult);
    Assert(irsIDLE == m_irsState || irsSVR_GREETING == m_irsState);

    *pirParseResult = irNONE;

    // This is a LINE (not literal), so we're OK to nuke CRLF at end
    Assert(dwNumBytesRead >= 2); // All lines must have at least CRLF
    *(pszResponseLine + dwNumBytesRead - 2) = '\0';

    // Create line fragment    
    pilfLine = new IMAP_LINE_FRAGMENT;
    pilfLine->iltFragmentType = iltLINE;
    pilfLine->ilsLiteralStoreType = ilsSTRING;
    pilfLine->dwLengthOfFragment = dwNumBytesRead - 2; // Subtract nuked CRLF
    pilfLine->data.pszSource = pszResponseLine;
    pilfLine->pilfNextFragment = NULL;
    pilfLine->pilfPrevFragment = NULL;

    EnqueueFragment(pilfLine, &m_ilqRecvQueue);

    // Now check last char in line (exclude CRLF) to see if a literal is forthcoming
    psz = pszResponseLine + dwNumBytesRead -
        min(dwNumBytesRead, 3); // Points to '}' if literal is coming
    if ('}' == *psz) {
        LPSTR pszLiteral;

        // IE5 bug #30672: It is valid for a line to end in "}" and not be a literal.
        // We must confirm that there are digits and an opening brace "{" to detect a literal
        pszLiteral = psz;
        while (TRUE) {
            pszLiteral -= 1;

            if (pszLiteral < pszResponseLine)
                break;

            if ('{' == *pszLiteral) {
                fLiteral = TRUE;
                psz = pszLiteral;
                break;
            }
            else if (*pszLiteral < '0' || *pszLiteral > '9')
                // Assert(FALSE) (placeholder)
                // *** Consider using isdigit or IsDigit? ***
                break; // This is not a literal
        }
    }

    if (FALSE == fLiteral) {
        char szTag[NUM_TAG_CHARS+1];
        // No literal is forthcoming. This is a complete line, so let's parse

        // Get ptr to first fragment, then nuke receive queue so we can
        // continue to receive response lines while parsing this one
        pilfLine = m_ilqRecvQueue.pilfFirstFragment;
        m_ilqRecvQueue = ImapLinefragQueue_INIT;

        // Parse line. Note that parsing code is responsible for advancing
        // pilfLine so that it points to the current fragment being parsed.
        // Fragments which have been fully processed should be freed by
        // the parsing code (except for the last fragment)
        hrResult = ParseSvrResponseLine(&pilfLine, &bTagged, szTag, pirParseResult);

        // Flush rest of recv queue, regardless of parse result
        while (NULL != pilfLine) {
            IMAP_LINE_FRAGMENT *pilfTemp;

            pilfTemp = pilfLine->pilfNextFragment;
            FreeFragment(&pilfLine);
            pilfLine = pilfTemp;
        }
        
        if (bTagged)
            OnCommandCompletion(szTag, hrResult, *pirParseResult);
        else if (FAILED(hrResult)) {
            IMAP_RESPONSE irIMAPResponse;
            IIMAPCallback *pCBHandler;

            // Report untagged response failures via ErrorNotification callback
            GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                &pCBHandler, *pirParseResult);
            irIMAPResponse.hrResult = hrResult;
            irIMAPResponse.lpszResponseText = m_szLastResponseText;
            irIMAPResponse.irtResponseType = irtERROR_NOTIFICATION;

            // Log it
            if (m_pLogFile) {
                char szErrorTxt[64];

                wsprintf(szErrorTxt, "PARSE ERROR: hr=%lu", hrResult);
                m_pLogFile->WriteLog(LOGFILE_DB, szErrorTxt);
            }

            OnIMAPResponse(pCBHandler, &irIMAPResponse);
        }
    }
    else {
        DWORD dwLengthOfLiteral, dwMsgSeqNum;
        LPSTR pszBodyTag;

        if ('{' != *psz) {
            Assert(FALSE); // What is this?
            return; // Nothing we can do, we obviously can't get size of literal
        }
        else
            dwLengthOfLiteral = StrToUint(psz + 1);

        // Prepare either for FETCH body, or a regular literal
        if (isFetchResponse(&m_ilqRecvQueue, &dwMsgSeqNum) &&
            isFetchBodyLiteral(pilfLine, psz, &pszBodyTag)) {
            // Prepare (tombstone) literal first, because it puts us in literal mode
            hrResult = PrepareForLiteral(0);

            // This will override literal mode, putting us in fetch body part mode
            // Ignore PrepareForLiteral failure: if we don't, we interpret EACH LINE of
            // the fetch body as an IMAP response line.
            PrepareForFetchBody(dwMsgSeqNum, dwLengthOfLiteral, pszBodyTag);
        }
        else
            hrResult = PrepareForLiteral(dwLengthOfLiteral);

        Assert(SUCCEEDED(hrResult)); // Not much else we can do
    } // else: handles case where a literal is coming after this line
} // CheckForCompleteResponse



//***************************************************************************
// Function: PrepareForLiteral
//
// Purpose:
//   This function prepares the receiver code to receive a literal from the
// IMAP server.
//
// Arguments:
//   DWORD dwSizeOfLiteral [in] - the size of the incoming literal as
//     reported by the IMAP server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::PrepareForLiteral(DWORD dwSizeOfLiteral)
{
    IMAP_LINE_FRAGMENT *pilfLiteral;
    HRESULT hrResult;

    // Initialize variables
    hrResult = S_OK;

    // Construct line fragment of type iltLITERAL
    Assert(NULL == m_pilfLiteralInProgress);
    pilfLiteral = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfLiteral)
        return E_OUTOFMEMORY;

    pilfLiteral->iltFragmentType = iltLITERAL;
    pilfLiteral->dwLengthOfFragment = dwSizeOfLiteral;
    pilfLiteral->pilfNextFragment = NULL;
    pilfLiteral->pilfPrevFragment = NULL;

    // Allocate string or stream to hold literal, depending on its size
    if (pilfLiteral->dwLengthOfFragment > dwLITERAL_THRESHOLD) {
        // Literal is big, so store it as stream (large literals often represent
        // data which we return to the user as a stream, eg, message bodies)
        pilfLiteral->ilsLiteralStoreType = ilsSTREAM;
        hrResult = MimeOleCreateVirtualStream(&pilfLiteral->data.pstmSource);
    }
    else {
        BOOL bResult;

        // Literal is small. Store it as a string rather than a stream, since
        // CImap4Agent functions probably expect it as a string, anyways.
        pilfLiteral->ilsLiteralStoreType = ilsSTRING;
        bResult = MemAlloc((void **) &pilfLiteral->data.pszSource,
            pilfLiteral->dwLengthOfFragment + 1); // Room for null-term
        if (FALSE == bResult)
            hrResult = E_OUTOFMEMORY;
        else {
            hrResult = S_OK;
            *(pilfLiteral->data.pszSource) = '\0'; // Null-terminate the string
        }
    }

    if (FAILED(hrResult))
        delete pilfLiteral; // Failure means no data.pstmSource or data.pszSource to dealloc
    else {
        // Set up receive FSM to receive the proper number of bytes for literal
        m_pilfLiteralInProgress = pilfLiteral;
        m_dwLiteralInProgressBytesLeft = dwSizeOfLiteral;
        m_irsState = irsLITERAL;
    }

    return hrResult;
} // PrepareForLiteral



//***************************************************************************
// Function: isFetchResponse
//
// Purpose:
//   This function determines if the given IMAP line fragment queue holds
// a FETCH response. If so, its message sequence number may be returned to
// the caller.
//
// Arguments:
//   IMAP_LINEFRAG_QUEUE *pilqCurrentResponse [in] - a line fragment queue
//     which may or may not hold a FETCH response.
//   LPDWORD pdwMsgSeqNum [out] - if pilqCurrentResponse points to a FETCH
//     response, its message sequence number is returned here. This argument
//     may be NULL if the user does not care.
//
// Returns:
//   TRUE if pilqCurrentResponse held a FETCH response. Otherwise, FALSE.
//***************************************************************************
BOOL CImap4Agent::isFetchResponse(IMAP_LINEFRAG_QUEUE *pilqCurrentResponse,
                                  LPDWORD pdwMsgSeqNum)
{
    LPSTR pszMsgSeqNum;

    Assert(NULL != pilqCurrentResponse);
    Assert(NULL != pilqCurrentResponse->pilfFirstFragment);
    Assert(iltLINE == pilqCurrentResponse->pilfFirstFragment->iltFragmentType);

    if (NULL != pdwMsgSeqNum)
        *pdwMsgSeqNum = 0; // At least it won't be random

    pszMsgSeqNum = pilqCurrentResponse->pilfFirstFragment->data.pszSource;
    // Advance pointer to the message sequence number
    if ('*' != *pszMsgSeqNum)
        return FALSE; // We only handle tagged responses

    pszMsgSeqNum += 1;
    if (cSPACE != *pszMsgSeqNum)
        return FALSE;

    pszMsgSeqNum += 1;
    if (*pszMsgSeqNum >= '0' && *pszMsgSeqNum <= '9') {
        LPSTR pszEndOfNumber;
        int iResult;

        pszEndOfNumber = StrChr(pszMsgSeqNum, cSPACE); // Find the end of the number
        if (NULL == pszEndOfNumber)
            return FALSE; // This ain't no FETCH response

        iResult = StrCmpNI(pszEndOfNumber + 1, "FETCH ", 6);
        if (0 == iResult) {
            if (NULL != pdwMsgSeqNum)
                *pdwMsgSeqNum = StrToUint(pszMsgSeqNum);
            return TRUE;
        }
    }

    // If we hit this point, it wasn't a FETCH response
    return FALSE;
} // isFetchResponse



//***************************************************************************
// Function: isFetchBodyLiteral
//
// Purpose:
//   This function is called when the caller knows he has a FETCH response,
// and when the FETCH response is about to send a literal. This function will
// determine whether the literal about to be sent contains a message body
// part (like RFC822), or whether the literal is something else (like an
// nstring sent as a literal inside a BODYSTRUCTURE).
//
// Arguments:
//   IMAP_LINE_FRAGMENT *pilfCurrent [in] - a pointer to the current line
//     fragment received from the server. It is used by this function to
//     rewind past any literals we may have received in the "section" of
//     the BODY "msg_att" (see RFC2060 formal syntax).
//   LPSTR pszStartOfLiteralSize [in] - a pointer to the start of the '{'
//     character which indicates that a literal is coming (eg, {123}
//     indicates a literal of size 123 is coming, and pszStartOfLiteralSize
//     would point to the '{' in this case).
//   LPSTR *ppszBodyTag [out] - if the literal about to be sent contains a
//     message body part, a dup of the tag (eg, "RFC822" or "BODY[2.2]") is
//     returned to the caller here. It is the caller's responsibility to
//     MemFree this tag. THIS TAG WILL NOT CONTAIN ANY SPACES. Thus even though
//     the server may return "BODY[HEADER.FIELDS (foo bar)]", this function
//     only returns "BODY[HEADER.FIELDS".
//
// Returns:
//   TRUE if the literal about to be sent contains a message body part.
// FALSE otherwise.
//***************************************************************************
BOOL CImap4Agent::isFetchBodyLiteral(IMAP_LINE_FRAGMENT *pilfCurrent,
                                     LPSTR pszStartOfLiteralSize,
                                     LPSTR *ppszBodyTag)
{
    LPSTR pszStartOfLine;
    LPSTR pszStartOfFetchAtt;
    LPSTR pszMostRecentSpace;
    int iNumDelimiters;
    BOOL fBodySection = FALSE;

    Assert(NULL != pilfCurrent);
    Assert(NULL != pszStartOfLiteralSize);
    Assert(pszStartOfLiteralSize >= pilfCurrent->data.pszSource &&
           pszStartOfLiteralSize < (pilfCurrent->data.pszSource + pilfCurrent->dwLengthOfFragment));
    Assert(NULL != ppszBodyTag);

    // Initialize variables
    *ppszBodyTag = NULL;
    Assert('{' == *pszStartOfLiteralSize);

    // Get pointer to current msg_att: we only care about RFC822* or BODY[...]. ENVELOPE ({5} doesn't count
    iNumDelimiters = 0;
    pszStartOfLine = pilfCurrent->data.pszSource;
    pszStartOfFetchAtt = pszStartOfLiteralSize;
    pszMostRecentSpace = pszStartOfLiteralSize;
    while (iNumDelimiters < 2) {
        // Check if we have recoiled to the start of current string buffer
        if (pszStartOfFetchAtt <= pszStartOfLine) {
            // We need to recoil to previous string buffer. It is likely that a literal
            // is in the way, and it is likely that this literal belongs to HEADER.FIELDS
            // (but this can also happen inside an ENVELOPE)

            // Skip literals and anything else that's not a line
            do {
                pilfCurrent = pilfCurrent->pilfPrevFragment;
            } while (NULL != pilfCurrent && iltLINE != pilfCurrent->iltFragmentType);

            if (NULL == pilfCurrent || 0 == pilfCurrent->dwLengthOfFragment) {
                // This ain't no FETCH BODY, near as I can tell
                Assert(iNumDelimiters < 2);
                break;
            }
            else {
                // Reset string pointers
                Assert(iltLINE == pilfCurrent->iltFragmentType &&
                    ilsSTRING == pilfCurrent->ilsLiteralStoreType);
                pszStartOfLine = pilfCurrent->data.pszSource;

                // Note that pszStartOfFetchAtt will recoil past literal size decl ("{123}")
                // That's OK because it won't contain any of the delimiters we're looking for
                pszStartOfFetchAtt = pszStartOfLine + pilfCurrent->dwLengthOfFragment; // Points to null-term
                pszMostRecentSpace = pszStartOfFetchAtt; // Points to null-term (that's OK)
            }
        }

        // Set pszMostRecentSpace before pszStartOfFetchAtt decrement so pszMostRecentSpace
        // isn't set to the space BEFORE the fetch body tag
        if (cSPACE == *pszStartOfFetchAtt)
            pszMostRecentSpace = pszStartOfFetchAtt;
        
        pszStartOfFetchAtt -= 1;

        // Check for nested brackets (should not be allowed)
        Assert(']' != *pszStartOfFetchAtt || fBodySection == FALSE);

        // Disable delimiter-counting if we're in the middle of RFC2060 formal syntax "section"
        // because the HEADER.FIELDS (...) section contains spaces and parentheses
        if (']' == *pszStartOfFetchAtt)
            fBodySection = TRUE;
        else if ('[' == *pszStartOfFetchAtt)
            fBodySection = FALSE;

        if (FALSE == fBodySection && (cSPACE == *pszStartOfFetchAtt || '(' == *pszStartOfFetchAtt))
            iNumDelimiters += 1;
    }

    if (iNumDelimiters < 2)
        return FALSE; // This isn't a body tag

    Assert(2 == iNumDelimiters);
    Assert(cSPACE == *pszStartOfFetchAtt || '(' == *pszStartOfFetchAtt);
    pszStartOfFetchAtt += 1; // Make it point to the start of the tag
    if (0 == StrCmpNI(pszStartOfFetchAtt, "RFC822", 6) ||
        0 == StrCmpNI(pszStartOfFetchAtt, "BODY[", 5)) {
        int iSizeOfBodyTag;
        BOOL fResult;

        Assert(pszMostRecentSpace >= pszStartOfLine && (NULL == pilfCurrent ||
               pszMostRecentSpace <= pszStartOfLine + pilfCurrent->dwLengthOfFragment));
        Assert(pszStartOfFetchAtt >= pszStartOfLine && (NULL == pilfCurrent ||
               pszStartOfFetchAtt <= pszStartOfLine + pilfCurrent->dwLengthOfFragment));
        Assert(pszMostRecentSpace >= pszStartOfFetchAtt);

        // Return a duplicate of the body tag, up until the first space +1 for null-term
        iSizeOfBodyTag = (int) (pszMostRecentSpace - pszStartOfFetchAtt + 1);
        fResult = MemAlloc((void **)ppszBodyTag, iSizeOfBodyTag);
        if (FALSE == fResult)
            return FALSE;

        CopyMemory(*ppszBodyTag, pszStartOfFetchAtt, iSizeOfBodyTag);
        *(*ppszBodyTag + iSizeOfBodyTag - 1) = '\0'; // Null-terminate the body tag dup
        return TRUE;
    }

    // If we reached this point, this is not a body tag
    return FALSE;
} // isFetchBodyLiteral



//***************************************************************************
// Function: PrepareForFetchBody
//
// Purpose:
//   This function prepares the receiver code to receive a literal which
// contains a message body part. This literal will always be part of a FETCH
// response from the IMAP server.
//
// Arguments:
//   DWORD dwMsgSeqNum [in] - the message sequence number of the FETCH
//     response currently being received from the IMAP server.
//   DWORD dwSizeOfLiteral [in] - the size of the literal about to be received
//     from the server.
//   LPSTR pszBodyTag [in] - a pointer to a dup of the IMAP msg_att (eg,
//     "RFC822" or "BODY[2.2]") which identifies the current literal. Look up
//     msg_att in RFC2060's formal syntax section for details. This dup will
//     be MemFree'ed when it is no longer needed.
//***************************************************************************
void CImap4Agent::PrepareForFetchBody(DWORD dwMsgSeqNum, DWORD dwSizeOfLiteral,
                                      LPSTR pszBodyTag)
{
    Assert(0 == m_dwLiteralInProgressBytesLeft);
    
    m_fbpFetchBodyPartInProgress.dwMsgSeqNum = dwMsgSeqNum;
    m_fbpFetchBodyPartInProgress.pszBodyTag = pszBodyTag;
    m_fbpFetchBodyPartInProgress.dwTotalBytes = dwSizeOfLiteral;
    m_fbpFetchBodyPartInProgress.dwSizeOfData = 0;
    m_fbpFetchBodyPartInProgress.dwOffset = 0;
    m_fbpFetchBodyPartInProgress.fDone = 0;
    m_fbpFetchBodyPartInProgress.pszData = NULL;
    // Leave the cookies alone, so they persist throughout FETCH response

    m_dwLiteralInProgressBytesLeft = dwSizeOfLiteral;
    m_irsState = irsFETCH_BODY;
} // PrepareForFetchBody



//***************************************************************************
// Function: AddBytesToLiteral
//
// Purpose:
//   This function is called whenever we receive an AE_RECV from the IMAP
// server while the receiver FSM is in irsLITERAL mode. The caller is
// expected to call CASyncConn::ReadBytes and update the literal byte-count.
// This function just handles the buffer-work.
//
// Arguments:
//   LPSTR pszResponseBuf [in] - the buffer of data returned via
//     CASyncConn::ReadBytes.
//   DWORD dwNumBytesRead [in] - the size of the buffer pointed to by
//     CASyncConn::ReadBytes.
//***************************************************************************
void CImap4Agent::AddBytesToLiteral(LPSTR pszResponseBuf, DWORD dwNumBytesRead)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pszResponseBuf);

    if (NULL == m_pilfLiteralInProgress) {
        AssertSz(FALSE, "I'm still in irsLITERAL state, but I'm not set up to recv literals!");
        m_irsState = irsIDLE;
        goto exit;
    }

    // Find out if this literal will be stored as a string or stream (this
    // decision was made in CheckForCompleteResponse using size of literal).
    Assert(iltLITERAL == m_pilfLiteralInProgress->iltFragmentType);
    if (ilsSTREAM == m_pilfLiteralInProgress->ilsLiteralStoreType) {
        HRESULT hrResult;
        ULONG ulNumBytesWritten;

        // Store literal as stream
        hrResult = (m_pilfLiteralInProgress->data.pstmSource)->Write(pszResponseBuf,
            dwNumBytesRead, &ulNumBytesWritten);
        Assert(SUCCEEDED(hrResult) && ulNumBytesWritten == dwNumBytesRead);
    }
    else {
        LPSTR pszLiteralStartPoint;

        // Concatenate literal to literal in progress
        // $REVIEW: Perf enhancement - CALCULATE insertion point
        pszLiteralStartPoint = m_pilfLiteralInProgress->data.pszSource +
            lstrlen(m_pilfLiteralInProgress->data.pszSource);
        Assert(pszLiteralStartPoint + dwNumBytesRead <=
            m_pilfLiteralInProgress->data.pszSource +
            m_pilfLiteralInProgress->dwLengthOfFragment);
        CopyMemory(pszLiteralStartPoint, pszResponseBuf, dwNumBytesRead);
        *(pszLiteralStartPoint + dwNumBytesRead) = '\0'; // Null-terminate
    }

    // Check for end-of-literal
    if (0 == m_dwLiteralInProgressBytesLeft) {
        // We now have the complete literal! Queue it up and move on
        EnqueueFragment(m_pilfLiteralInProgress, &m_ilqRecvQueue);
        m_irsState = irsIDLE;
        m_pilfLiteralInProgress = NULL;
    }

exit:
    SafeMemFree(pszResponseBuf);
} // AddBytesToLiteral



//***************************************************************************
// Function: DispatchFetchBodyPart
//
// Purpose:
//   This function is called whenever receive a packet which is part of a
// message body part of a FETCH response. This packet is dispatched to the
// caller in this function via the OnResponse(irtFETCH_BODY) callback. If
// the message body part is finished, this function also restores the
// receiver code to receive lines so that the FETCH response may be completed.
//
// Arguments:
//   LPSTR pszResponseBuf [in] - a pointer to the packet which is part of
//     the message body part of the current FETCH response.
//   DWORD dwNumBytesRead [in] - the size of the data pointed to by
//     pszResponseBuf.
//   BOOL fFreeBodyTagAtEnd [in] - TRUE if
//     m_fbpFetchBodyPartInProgress.pszBodyTag points to a string dup, in
//     which case it must be MemFree'ed when the message body part is
//     finished. FALSE if the pszBodyTag member must not be MemFree'ed.
//***************************************************************************
void CImap4Agent::DispatchFetchBodyPart(LPSTR pszResponseBuf,
                                        DWORD dwNumBytesRead,
                                        BOOL fFreeBodyTagAtEnd)
{
    IMAP_RESPONSE irIMAPResponse;

    AssertSz(0 != m_fbpFetchBodyPartInProgress.dwMsgSeqNum,
        "Are you sure you're set up to receive a Fetch Body Part?");

    // Update the FETCH body part structure
    m_fbpFetchBodyPartInProgress.dwSizeOfData = dwNumBytesRead;
    m_fbpFetchBodyPartInProgress.pszData = pszResponseBuf;
    m_fbpFetchBodyPartInProgress.fDone =
        (m_fbpFetchBodyPartInProgress.dwOffset + dwNumBytesRead >=
        m_fbpFetchBodyPartInProgress.dwTotalBytes);

    // Send an IMAP response callback for this body part
    irIMAPResponse.wParam = 0;
    irIMAPResponse.lParam = 0;    
    irIMAPResponse.hrResult = S_OK;
    irIMAPResponse.lpszResponseText = NULL; // Not relevant
    irIMAPResponse.irtResponseType = irtFETCH_BODY;
    irIMAPResponse.irdResponseData.pFetchBodyPart = &m_fbpFetchBodyPartInProgress;
    AssertSz(S_OK == irIMAPResponse.hrResult,
        "Make sure fDone is TRUE if FAILED(hrResult))");
    OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

    // Update the next buffer's offset
    m_fbpFetchBodyPartInProgress.dwOffset += dwNumBytesRead;

    // Check for end of body part
    if (m_fbpFetchBodyPartInProgress.dwOffset >=
        m_fbpFetchBodyPartInProgress.dwTotalBytes) {

        Assert(0 == m_dwLiteralInProgressBytesLeft);
        Assert(TRUE == m_fbpFetchBodyPartInProgress.fDone);
        Assert(m_fbpFetchBodyPartInProgress.dwOffset == m_fbpFetchBodyPartInProgress.dwTotalBytes);
        if (fFreeBodyTagAtEnd)
            MemFree(m_fbpFetchBodyPartInProgress.pszBodyTag);

        // Enqueue the tombstone literal, if fetch body nstring was sent as literal
        if (NULL != m_pilfLiteralInProgress) {
            EnqueueFragment(m_pilfLiteralInProgress, &m_ilqRecvQueue);
            m_pilfLiteralInProgress = NULL;
        }

        // Zero the fetch body part structure, but leave the cookies
        PrepareForFetchBody(0, 0, NULL);
        m_irsState = irsIDLE; // Overrides irsFETCH_BODY set by PrepareForFetchBody
    }
    else {
        Assert(FALSE == m_fbpFetchBodyPartInProgress.fDone);
    }
} // DispatchFetchBodyPart



//***************************************************************************
// Function: UploadStreamProgress
//
// Purpose:
//   This function sends irtAPPEND_PROGRESS responses to the callback so
// that the IIMAPTransport user can report the progress of an APPEND command.
//
// Arguments:
//   DWORD dwBytesUploaded [in] - number of bytes just uploaded to the
//     server. This function retains a running count of bytes uploaded.
//***************************************************************************
void CImap4Agent::UploadStreamProgress(DWORD dwBytesUploaded)
{
    APPEND_PROGRESS ap;
    IMAP_RESPONSE irIMAPResponse;

    // Check if we should report APPEND upload progress. We report if we are currently executing
    // APPEND and the CRLF is waiting to be sent
    if (NULL == m_piciCmdInSending || icAPPEND_COMMAND != m_piciCmdInSending->icCommandID ||
        NULL == m_piciCmdInSending->pilqCmdLineQueue)
        return;
    else {
        IMAP_LINE_FRAGMENT *pilf = m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment;

        // It's an APPEND command with non-empty linefrag queue, now check that next
        // linefrag fits description for linefrag after msg body
        if (NULL == pilf || iltLINE != pilf->iltFragmentType ||
            ilsSTRING != pilf->ilsLiteralStoreType || 2 != pilf->dwLengthOfFragment ||
            '\r' != pilf->data.pszSource[0] || '\n' != pilf->data.pszSource[1] ||
            NULL != pilf->pilfNextFragment)
            return;
    }

    // Report current progress of message upload
    m_dwAppendStreamUploaded += dwBytesUploaded;
    ap.dwUploaded = m_dwAppendStreamUploaded;
    ap.dwTotal = m_dwAppendStreamTotal;
    Assert(0 != ap.dwTotal);
    Assert(ap.dwTotal >= ap.dwUploaded);

    irIMAPResponse.wParam = m_piciCmdInSending->wParam;
    irIMAPResponse.lParam = m_piciCmdInSending->lParam;
    irIMAPResponse.hrResult = S_OK;
    irIMAPResponse.lpszResponseText = NULL;
    irIMAPResponse.irtResponseType = irtAPPEND_PROGRESS;
    irIMAPResponse.irdResponseData.papAppendProgress = &ap;
    OnIMAPResponse(m_piciCmdInSending->pCBHandler, &irIMAPResponse);
} // UploadStreamProgress



//***************************************************************************
// Function: OnNotify
//
// Purpose: This function is required for the IAsyncConnCB which we derive
//   from (callback for CAsyncConn class). This function acts on CASyncConn
//   state changes and events.
//***************************************************************************
void CImap4Agent::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    char szLogFileLine[128];

    // Check refcount, but exception is that we can get AE_CLOSE. CImap4Agent's
    // destructor calls CASyncConn's Close() member, which generates one last
    // message, the event AE_CLOSE, with m_lRefCount == 0.
    Assert(m_lRefCount > 0 || (0 == m_lRefCount && AE_CLOSE == ae));

    // Record AsyncConn event/state-change in log file
    wsprintf(szLogFileLine, "OnNotify: asOld = %d, asNew = %d, ae = %d",
        asOld, asNew, ae);
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_DB, szLogFileLine);

    // Check for disconnect
    if (AS_DISCONNECTED == asNew) {
        m_irsState = irsNOT_CONNECTED;
        m_ssServerState = ssNotConnected;
        m_fIDLE = FALSE;
        m_bFreeToSend = TRUE;
    }

    // Act on async event
    switch (ae) {
        case AE_RECV: {
            HRESULT hrResult;

            // Process response lines until no more lines (hrIncomplete result)
            do {
                hrResult = ProcessResponseLine();
            } while (SUCCEEDED(hrResult));

            // If error is other than IXP_E_INCOMPLETE, drop connection
            if (IXP_E_INCOMPLETE != hrResult) {
                char szFailureText[MAX_RESOURCESTRING];

                // Looks fatal, better warn the user that disconnection is imminent
                LoadString(g_hLocRes, idsIMAPSocketReadError, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(hrResult, szFailureText, DONT_USE_LAST_RESPONSE);
                
                // What else can we do but drop the connection?
                DropConnection();
            } // if error other than IXP_E_INCOMPLETE
            break;
        } // case AE_RECV

        case AE_SENDDONE:
            UploadStreamProgress(m_pSocket->UlGetSendByteCount());

            // Received AE_SENDDONE from CAsyncConn class. We are free to send more data
            m_bFreeToSend = TRUE;
            ProcessSendQueue(iseSENDDONE); // Informs them that they may start sending again
            break;

        case AE_WRITE:
            UploadStreamProgress(m_pSocket->UlGetSendByteCount());
            break;
        
        default:
            CIxpBase::OnNotify(asOld, asNew, ae);
            break; // case default
    } // switch (ae)
} // OnNotify



//***************************************************************************
// Function: ProcessResponseLine
//
// Purpose:
//   This functions handles the AE_RECV event of the OnNotify() callback.
// It gets a response line from the server (if available) and dispatches
// the line to the proper recipient based on the state of the receiver FSM.
//
// Returns:
//   HRESULT indicating success or failure of CAsyncConn line retrieval.
// hrIncomplete (an error code) is returned if no more complete lines can
// be retrieved from CAsyncConn's buffer.
//***************************************************************************
HRESULT CImap4Agent::ProcessResponseLine(void)
{
    HRESULT hrASyncResult;
    char *pszResponseBuf;
    int cbRead;

    Assert(m_lRefCount > 0);

    // We are always in one of two modes: line mode, or byte mode. Figure out which.
    if (irsLITERAL != m_irsState && irsFETCH_BODY != m_irsState) {
        // We're in line mode. Get response line from server
        hrASyncResult = m_pSocket->ReadLine(&pszResponseBuf, &cbRead);
        if (FAILED(hrASyncResult))
            return hrASyncResult;

        // Record received line in log file
        if (m_pLogFile)
            m_pLogFile->WriteLog(LOGFILE_RX, pszResponseBuf);
    } // if-line mode
    else {
        // We're in literal mode. Get as many bytes as we can.
        hrASyncResult = m_pSocket->ReadBytes(&pszResponseBuf,
            m_dwLiteralInProgressBytesLeft, &cbRead);
        if (FAILED(hrASyncResult))
            return hrASyncResult;

        // Update our byte count
        Assert((DWORD)cbRead <= m_dwLiteralInProgressBytesLeft);
        m_dwLiteralInProgressBytesLeft -= cbRead;

        // Make note of received blob in log file
        if (m_pLogFile) {
            char szLogLine[CMDLINE_BUFSIZE];

            wsprintf(szLogLine, "Buffer (literal) of length %i", cbRead);
            m_pLogFile->WriteLog(LOGFILE_RX, szLogLine);
        }
    } // else-not line mode
    
    // Process it
    switch (m_irsState) {
        case irsUNINITIALIZED:
            AssertSz(FALSE, "Attempted to use Imap4Agent class without initializing");
            SafeMemFree(pszResponseBuf);
            break;

        case irsNOT_CONNECTED:
            AssertSz(FALSE, "Received response from server when not connected");
            SafeMemFree(pszResponseBuf);
            break;

        case irsSVR_GREETING:
            ProcessServerGreeting(pszResponseBuf, cbRead);
            break;

        case irsIDLE: {
            IMAP_RESPONSE_ID irParseResult;

            CheckForCompleteResponse(pszResponseBuf, cbRead, &irParseResult);
            
            // Check for unsolicited BYE response, and notify user of error
            // Solicited BYE responses (eg, during LOGOUT cmd) can be ignored
            if (irBYE_RESPONSE == irParseResult &&
                IXP_AUTHRETRY != m_status &&
                IXP_DISCONNECTING != m_status &&
                IXP_DISCONNECTED  != m_status) {
                char szFailureText[MAX_RESOURCESTRING];

                // Looks like an unsolicited BYE response to me
                // Drop connection to avoid IXP_E_CONNECTION_DROPPED err
                DropConnection();

                // Report to user (sometimes server provides useful error text)
                LoadString(g_hLocRes, idsIMAPUnsolicitedBYE, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(IXP_E_IMAP_UNSOLICITED_BYE, szFailureText,
                    USE_LAST_RESPONSE);
            }
        } // case irsIDLE
            break;

        case irsLITERAL:
            AddBytesToLiteral(pszResponseBuf, cbRead);
            break;

        case irsFETCH_BODY:
            DispatchFetchBodyPart(pszResponseBuf, cbRead, fFREE_BODY_TAG);
            SafeMemFree(pszResponseBuf);
            break;

        default:
            AssertSz(FALSE, "Unhandled receiver state in ProcessResponseLine()");
            SafeMemFree(pszResponseBuf);
            break;
    } // switch (m_irsState)

    return hrASyncResult;
} // ProcessResponseLine



//***************************************************************************
// Function: ProcessSendQueue
//
// Purpose:
//   This function is responsible for all transmissions from the client to
// the IMAP server. It is called when certain events occur, such as the
// receipt of the AE_SENDDONE event in OnNotify().
//
// Arguments:
//   IMAP_SEND_EVENT iseEvent [in] - the send event which just occurred,
//     such as iseSEND_COMMAND (used to initiate a command) or
//     iseCMD_CONTINUATION (when command continuation response received from
//     the IMAP server).
//***************************************************************************
void CImap4Agent::ProcessSendQueue(IMAP_SEND_EVENT iseEvent)
{
    boolean bFreeToSendLiteral, bFreeToUnpause;
    IMAP_LINE_FRAGMENT *pilfNextFragment;

    Assert(m_lRefCount > 0);
    Assert(ssNotConnected < m_ssServerState);
    Assert(irsNOT_CONNECTED < m_irsState);

    // Initialize variables
    bFreeToSendLiteral = FALSE;
    bFreeToUnpause = FALSE;

    // Peek at current fragment
    EnterCriticalSection(&m_cs); // Reserve this NOW to avoid deadlock
    EnterCriticalSection(&m_csSendQueue);
    GetNextCmdToSend();
    if (NULL != m_piciCmdInSending)
        pilfNextFragment = m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment;
    else
        pilfNextFragment = NULL;

    // Act on the IMAP send event posted to us
    switch (iseEvent) {
        case iseSEND_COMMAND:
        case iseSENDDONE:
            // We don't have to do anything special for these events
            break;

        case iseCMD_CONTINUATION:
            // Received command continuation from IMAP server. We are free to send literal
            bFreeToSendLiteral = TRUE;
            Assert(NULL != pilfNextFragment &&
                iltLITERAL == pilfNextFragment->iltFragmentType);
            break;

        case iseUNPAUSE:
            bFreeToUnpause = TRUE;
            IxpAssert(NULL != pilfNextFragment &&
                iltPAUSE == pilfNextFragment->iltFragmentType);
            break;

        default:
            AssertSz(FALSE, "Received unknown IMAP send event");
            break;
    }


    // Send as many fragments as we can. We must stop sending if:
    //   a) Any AsyncConn send command returns hrWouldBlock.
    //   b) The send queue is empty
    //   c) Next fragment is a literal and we don't have cmd continuation from svr
    //   d) We are at a iltPAUSE fragment, and we don't have the go-ahead to unpause
    //   e) We are at a iltSTOP fragment.
    while (TRUE == m_bFreeToSend && NULL != pilfNextFragment &&
          ((iltLITERAL != pilfNextFragment->iltFragmentType) || TRUE == bFreeToSendLiteral) &&
          ((iltPAUSE != pilfNextFragment->iltFragmentType) || TRUE == bFreeToUnpause) &&
          (iltSTOP != pilfNextFragment->iltFragmentType))
    {
        HRESULT hrResult;
        int iNumBytesSent;
        IMAP_LINE_FRAGMENT *pilf;

        // We are free to send the next fragment, whether it's a line, literal or rangelist
        // Put us into busy mode to enable the watchdog timer
        if (FALSE == m_fBusy) {
            hrResult = HrEnterBusy();
            Assert(SUCCEEDED(hrResult));
            // In retail, we want to try to continue even if HrEnterBusy failed.
        }

        // Send next fragment (have to check if stored as a string or a stream)
        pilfNextFragment = pilfNextFragment->pilfNextFragment; // Peek at next frag
        pilf = DequeueFragment(m_piciCmdInSending->pilqCmdLineQueue); // Get current frag
        if (iltPAUSE == pilf->iltFragmentType) {
            hrResult = S_OK; // Do nothing
        }
        else if (iltSTOP == pilf->iltFragmentType) {
            AssertSz(FALSE, "What are we doing trying to process a STOP?");
            hrResult = S_OK; // Do nothing
        }
        else if (iltRANGELIST == pilf->iltFragmentType) {
            AssertSz(FALSE, "All rangelists should have been coalesced!");
            hrResult = S_OK; // Do nothing
        }
        else if (ilsSTRING == pilf->ilsLiteralStoreType) {
            hrResult = m_pSocket->SendBytes(pilf->data.pszSource,
                pilf->dwLengthOfFragment, &iNumBytesSent);

            // Record sent line in log file
            if (m_pLogFile) {
                // Hide the LOGIN command from logfile, for security reasons
                if (icLOGIN_COMMAND != m_piciCmdInSending->icCommandID)
                    m_pLogFile->WriteLog(LOGFILE_TX, pilf->data.pszSource);
                else
                    m_pLogFile->WriteLog(LOGFILE_TX, "LOGIN command sent");
            }
        }
        else if (ilsSTREAM == pilf->ilsLiteralStoreType) {
            char szLogLine[128];

            // No need to rewind stream - CAsyncConn::SendStream does it for us
            hrResult = m_pSocket->SendStream(pilf->data.pstmSource, &iNumBytesSent);

            // Record stream size in log file
            wsprintf(szLogLine, "Stream of length %lu", pilf->dwLengthOfFragment);
            if (m_pLogFile)
                m_pLogFile->WriteLog(LOGFILE_TX, szLogLine);

            // Record stream size for progress indication
            if (icAPPEND_COMMAND == m_piciCmdInSending->icCommandID) {
                m_dwAppendStreamUploaded = 0;
                m_dwAppendStreamTotal = pilf->dwLengthOfFragment;
                UploadStreamProgress(iNumBytesSent);
            }
        }
        else {
            AssertSz(FALSE, "What is in my send queue?");
            hrResult = S_OK; // Ignore it and try to continue
        }

        // Clean up variables after the send
        bFreeToSendLiteral = FALSE; // We've used up the cmd continuation
        bFreeToUnpause = FALSE; // We've used this up, too
        FreeFragment(&pilf);

        // Handle errors in sending.
        // If either send command returns hrWouldBlock, this means we cannot send
        // more data until we receive an AE_SENDDONE event from CAsyncConn.
        if (IXP_E_WOULD_BLOCK == hrResult) {
            m_bFreeToSend = FALSE;
            hrResult = S_OK; // $REVIEW: TEMPORARY until EricAn makes hrWouldBlock a success code
        }
        else if (FAILED(hrResult)) {
            IMAP_RESPONSE irIMAPResponse;
            char szFailureText[MAX_RESOURCESTRING];

            // Send error: Report this command as terminated
            irIMAPResponse.wParam = m_piciCmdInSending->wParam;
            irIMAPResponse.lParam = m_piciCmdInSending->lParam;
            irIMAPResponse.hrResult = hrResult;
            LoadString(g_hLocRes, idsFailedIMAPCmdSend, szFailureText,
                ARRAYSIZE(szFailureText));
            irIMAPResponse.lpszResponseText = szFailureText;
            irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
            OnIMAPResponse(m_piciCmdInSending->pCBHandler, &irIMAPResponse);
        }


        // Are we finished with the current command?
        if (NULL == pilfNextFragment || FAILED(hrResult)) {
            CIMAPCmdInfo *piciFinishedCmd;

            // Dequeue current command from send queue
            piciFinishedCmd = DequeueCommand();
            if (NULL != piciFinishedCmd) {
                if (SUCCEEDED(hrResult)) {
                    // We successfully finished sending current command. Put it in
                    // list of commands waiting for a server response
                    AddPendingCommand(piciFinishedCmd);
                    Assert(NULL == pilfNextFragment);
                }
                else {
                    // Failed commands don't deserve to live
                    delete piciFinishedCmd;
                    pilfNextFragment = NULL; // No longer valid

                    // Drop out of busy mode
                    AssertSz(m_fBusy, "Check your logic, I'm calling LeaveBusy "
                        "although not in a busy state!");
                    LeaveBusy();
                }
            }
            else {
                // Hey, someone pulled the rug out!
                AssertSz(FALSE, "I had this cmd... and now it's GONE!");
            }
        } // if (NULL == pilfNextFragment || FAILED(hrResult))


        // If we finished sending current cmd, set us up to send next command
        if (NULL == pilfNextFragment && NULL != m_piciSendQueue) {
            GetNextCmdToSend();
            if (NULL != m_piciCmdInSending)
                pilfNextFragment = m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment;
        }

    } // while

    LeaveCriticalSection(&m_csSendQueue);
    LeaveCriticalSection(&m_cs);
} // ProcessSendQueue



//***************************************************************************
// Function: GetNextCmdToSend
//
// Purpose:
//   This function leaves a pointer to the next command to send, in
// m_piciCmdInSending. If m_piciCmdInSending is already non-NULL (indicating
// a command in progress), then this function does nothing. Otherwise, this
// function chooses the next command from m_piciSendQueue using a set of
// rules described within.
//***************************************************************************
void CImap4Agent::GetNextCmdToSend(void)
{
    CIMAPCmdInfo *pici;

    // First check if we're connected
    if (IXP_CONNECTED != m_status &&
        IXP_AUTHORIZING != m_status &&
        IXP_AUTHRETRY != m_status &&
        IXP_AUTHORIZED != m_status &&
        IXP_DISCONNECTING != m_status) {
        Assert(NULL == m_piciCmdInSending);
        return;
    }

    // Check if we're already in the middle of sending a command
    if (NULL != m_piciCmdInSending)
        return;

    // Loop through the send queue looking for next eligible candidate to send
    pici = m_piciSendQueue;
    while (NULL != pici) {
        IMAP_COMMAND icCurrentCmd;

        // For a command to be sent, it must meet the following criteria:
        // (1) The server must be in the correct server state. Authenticated cmds such
        //     as SELECT must wait until non-Authenticated cmds like LOGIN are complete.
        // (2) Commands for which we want to guarantee proper wParam, lParam for their
        //     untagged responses cannot be streamed. See CanStreamCommand for details.
        // (3) If the command is NON-UID FETCH/STORE/SEARCH or COPY, then all pending
        //     cmds must be NON-UID FETCH/STORE/SEARCH.

        icCurrentCmd = pici->icCommandID;
        if (m_ssServerState >= pici->ssMinimumState && CanStreamCommand(icCurrentCmd)) {
            if ((icFETCH_COMMAND == icCurrentCmd || icSTORE_COMMAND == icCurrentCmd ||
                icSEARCH_COMMAND == icCurrentCmd || icCOPY_COMMAND == icCurrentCmd) &&
                FALSE == pici->fUIDRangeList) {
                if (isValidNonWaitingCmdSequence())
                    break; // This command is good to go
            }
            else
                break; // This command is good to go
        }

        // Advance ptr to next command
        pici = pici->piciNextCommand;
    } // while

    // If we found a command, coalesce its iltLINE and iltRANGELIST elements
    if (NULL != pici) {
        CompressCommand(pici);
        m_piciCmdInSending = pici;
    }
} // GetNextCmdToSend



//***************************************************************************
// Function: CanStreamCommand
//
// Purpose:
//   This function determines whether or not the given command can be
// streamed. All commands can be streamed except for the following:
// SELECT, EXAMINE, LIST, LSUB and SEARCH.
//
// SELECT and EXAMINE cannot be streamed because it doesn't make much sense
// to allow that.
// LIST, LSUB and SEARCH cannot be streamed because we want to guarantee
// that we can identify the correct wParam, lParam and pCBHandler when we call
// OnResponse for their untagged responses.
//
// Arguments:
//   IMAP_COMMAND icCommandID [in] - the command which you would like to send
//     to the server.
//
// Returns:
//   TRUE if the given command may be sent. FALSE if you cannot send the
// given command at this time (try again later).
//***************************************************************************
boolean CImap4Agent::CanStreamCommand(IMAP_COMMAND icCommandID)
{
    boolean fResult;
    WORD wNumberOfMatches;

    fResult = TRUE;
    wNumberOfMatches = 0;
    switch (icCommandID) {
        // We don't stream any of the following commands

        case icSELECT_COMMAND:
        case icEXAMINE_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL,
                icSELECT_COMMAND, icEXAMINE_COMMAND);
            break;

        case icLIST_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL, icLIST_COMMAND);
            break;

        case icLSUB_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL, icLSUB_COMMAND);
            break;

        case icSEARCH_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL, icSEARCH_COMMAND);
            break;
    } //switch

    if (wNumberOfMatches > 0)
        fResult = FALSE;

    return fResult;
} // CanStreamCommand



//***************************************************************************
// Function: isValidNonWaitingCmdSequence
//
// Purpose:
//   This function is called whenever we would like to send a FETCH, STORE,
// SEARCH or COPY command (all NON-UID) to the server. These commands are
// subject to waiting rules as discussed in section 5.5 of RFC2060.
//
// Returns:
//   TRUE if the non-UID FETCH/STORE/SEARCH/COPY command can be sent at
// this time. FALSE if the command cannot be sent at this time (try again
// later).
//***************************************************************************
boolean CImap4Agent::isValidNonWaitingCmdSequence(void)
{
    CIMAPCmdInfo *pici;
    boolean fResult;

    // Loop through the list of pending commands
    pici = m_piciPendingList;
    fResult = TRUE;
    while (NULL != pici) {
        IMAP_COMMAND icCurrentCmd;

        // non-UID FETCH/STORE/SEARCH/COPY can only execute if the only
        // pending commands are non-UID FETCH/STORE/SEARCH.
        icCurrentCmd = pici->icCommandID;
        if (icFETCH_COMMAND != icCurrentCmd &&
            icSTORE_COMMAND != icCurrentCmd &&
            icSEARCH_COMMAND != icCurrentCmd ||
            pici->fUIDRangeList) {
            fResult = FALSE;
            break;
        }

        // Advance pointer to next command
        pici = pici->piciNextCommand;
    } // while

    return fResult;
} // isValidNonWaitingCmdSequence



//***************************************************************************
// Function: CompressCommand
//
// Purpose: This function walks through the given command's linefrag queue
//   and combines all sequential iltLINE and iltRANGELIST linefrag elements
//   into a single iltLINE element for transmitting purposes. The reason we
//   have to combine these is because I had a pipe dream once that CImap4Agent
//   would auto-detect EXPUNGE responses and modify all iltRANGELIST elements
//   in m_piciSendQueue to reflect the new msg seq num reality. Who knows,
//   it might even come true some day.
//
//   When it does come true, this function can still exist: once a command
//   enters m_piciCmdInSending, it is too late to modify its rangelist.
//
// Arguments:
//   CIMAPCmdInfo *pici [in] - pointer to the IMAP command to compress.
//***************************************************************************
void CImap4Agent::CompressCommand(CIMAPCmdInfo *pici)
{
    IMAP_LINE_FRAGMENT *pilfCurrent, *pilfStartOfRun, *pilfPreStartOfRun;
    HRESULT hrResult;

    // Codify assumptions
    Assert(NULL != pici);
    Assert(5 == iltLAST); // If this changes, update this function

    // Initialize variables
    hrResult = S_OK;
    pilfCurrent = pici->pilqCmdLineQueue->pilfFirstFragment;
    pilfStartOfRun = pilfCurrent;
    pilfPreStartOfRun = NULL; // Points to linefrag element before pilfStartOfRun
    while (1) {
        if (NULL == pilfCurrent || 
            (iltLINE != pilfCurrent->iltFragmentType &&
            iltRANGELIST != pilfCurrent->iltFragmentType)) {
            // We've hit a non-coalescable linefrag, coalesce previous run
            // We only coalesce runs which are greater than one linefrag element
            if (NULL != pilfStartOfRun && pilfCurrent != pilfStartOfRun->pilfNextFragment) {
                IMAP_LINE_FRAGMENT *pilf, *pilfSuperLine;
                CByteStream bstmCmdLine;

                // Run length > 1, coalesce the entire run
                pilf = pilfStartOfRun;
                while (pilf != pilfCurrent) {
                    if (iltLINE == pilf->iltFragmentType) {
                        hrResult = bstmCmdLine.Write(pilf->data.pszSource,
                            pilf->dwLengthOfFragment, NULL);
                        if (FAILED(hrResult))
                            goto exit;
                    }
                    else {
                        LPSTR pszMsgRange;
                        DWORD dwLengthOfString;

                        // Convert rangelist to string
                        Assert(iltRANGELIST == pilf->iltFragmentType);
                        hrResult = pilf->data.prlRangeList->
                            RangeToIMAPString(&pszMsgRange, &dwLengthOfString);
                        if (FAILED(hrResult))
                            goto exit;

                        hrResult = bstmCmdLine.Write(pszMsgRange, dwLengthOfString, NULL);
                        MemFree(pszMsgRange);
                        if (FAILED(hrResult))
                            goto exit;

                        // Append a space behind the rangelist
                        hrResult = bstmCmdLine.Write(g_szSpace, 1, NULL);
                        if (FAILED(hrResult))
                            goto exit;
                    } // else

                    pilf = pilf->pilfNextFragment;
                } // while (pilf != pilfCurrent)

                // OK, now we've coalesced the run data into a stream
                // Create a iltLINE fragment to hold the super-string
                pilfSuperLine = new IMAP_LINE_FRAGMENT;
                if (NULL == pilfSuperLine) {
                    hrResult = E_OUTOFMEMORY;
                    goto exit;
                }
                pilfSuperLine->iltFragmentType = iltLINE;
                pilfSuperLine->ilsLiteralStoreType = ilsSTRING;
                hrResult = bstmCmdLine.HrAcquireStringA(&pilfSuperLine->dwLengthOfFragment,
                    &pilfSuperLine->data.pszSource, ACQ_DISPLACE);
                if (FAILED(hrResult)) {
                    delete pilfSuperLine;
                    goto exit;
                }

                // OK, we've created the uber-line, now link it into list
                pilfSuperLine->pilfNextFragment = pilfCurrent;
                pilfSuperLine->pilfPrevFragment = pilfPreStartOfRun;
                Assert(pilfPreStartOfRun == pilfStartOfRun->pilfPrevFragment);
                if (NULL == pilfPreStartOfRun)
                    // Insert at head of queue
                    pici->pilqCmdLineQueue->pilfFirstFragment = pilfSuperLine;
                else
                    pilfPreStartOfRun->pilfNextFragment = pilfSuperLine;

                // Special case: if pilfCurrent is NULL, pilfSuperLine is new last frag
                if (NULL == pilfCurrent)
                    pici->pilqCmdLineQueue->pilfLastFragment = pilfSuperLine;

                // Free the old run of linefrag elements
                pilf = pilfStartOfRun;
                while(pilf != pilfCurrent) {
                    IMAP_LINE_FRAGMENT *pilfNext;

                    pilfNext = pilf->pilfNextFragment;
                    FreeFragment(&pilf);
                    pilf = pilfNext;
                } // while(pilf != pilfCurrent)
            } // if run length > 1

            // Start collecting line fragments for next coalescing run
            if (NULL != pilfCurrent) {
                pilfStartOfRun = pilfCurrent->pilfNextFragment;
                pilfPreStartOfRun = pilfCurrent;
            } // if
        } // if current linefrag is non-coalescable

        // Advance to next line fragment
        if (NULL != pilfCurrent)
            pilfCurrent = pilfCurrent->pilfNextFragment;
        else
            break; // Our work here is done
    } // while (NULL != pilfCurrent)

exit:
    AssertSz(SUCCEEDED(hrResult), "Could not compress an IMAP command");
} // CompressCommand



//***************************************************************************
// Function: SendCmdLine
//
// Purpose:
//   This function enqueues an IMAP line fragment (as opposed to an IMAP
// literal fragment) on the send queue of the given CIMAPCmdInfo structure.
// The insertion point can either be in front 
// All IMAP commands are constructed in full before being submitted to the
// send machinery, so this function does not actually transmit anything.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//   DWORD dwFlags [in] - various options:
//     sclINSERT_BEFORE_PAUSE: line fragment will be inserted before the
//                             first iltPAUSE fragment in the queue. It is the
//                             caller's responsibility to ensure that a iltPAUSE
//                             fragment exists.
//     sclAPPEND_TO_END: (DEFAULT CASE, there is no flag for this) line fragment
//                             will be appended to the end of the queue.
//     sclAPPEND_CRLF:  Appends CRLF to contents of lpszCommandText when
//                      constructing the line fragment.
//
//   LPCSTR lpszCommandText [in] - a pointer to the line fragment to enqueue.
//     The first line fragment of all commands should include a tag. This
//     function does not provide command tags, and does not append CRLF to
//     the end of each line by default (see sclAPPEND_CRLF above).
//   DWORD dwCmdLineLength [in] - the length of the text pointed to by
//     lpszCommandText.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendCmdLine(CIMAPCmdInfo *piciCommand, DWORD dwFlags,
                                 LPCSTR lpszCommandText, DWORD dwCmdLineLength)
{
    IMAP_LINE_FRAGMENT *pilfLine;
    BOOL bResult;
    BOOL fAppendCRLF;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);
    Assert(NULL != lpszCommandText);

    // Create and fill out a line fragment element
    fAppendCRLF = !!(dwFlags & sclAPPEND_CRLF);
    pilfLine = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfLine)
        return E_OUTOFMEMORY;

    pilfLine->iltFragmentType = iltLINE;
    pilfLine->ilsLiteralStoreType = ilsSTRING;
    pilfLine->dwLengthOfFragment = dwCmdLineLength + (fAppendCRLF ? 2 : 0);
    pilfLine->pilfNextFragment = NULL;
    pilfLine->pilfPrevFragment = NULL;
    bResult = MemAlloc((void **)&pilfLine->data.pszSource,
        pilfLine->dwLengthOfFragment + 1); // Room for null-term
    if (FALSE == bResult) {
        delete pilfLine;
        return E_OUTOFMEMORY;
    }
    CopyMemory(pilfLine->data.pszSource, lpszCommandText, dwCmdLineLength);
    if (fAppendCRLF)
        lstrcpy(pilfLine->data.pszSource + dwCmdLineLength, c_szCRLF);
    else
        *(pilfLine->data.pszSource + dwCmdLineLength) = '\0'; // Null-terminate the line

    // Queue it up
    if (dwFlags & sclINSERT_BEFORE_PAUSE) {
        InsertFragmentBeforePause(pilfLine, piciCommand->pilqCmdLineQueue);
        ProcessSendQueue(iseSEND_COMMAND); // Pump send queue in this case
    }
    else
        EnqueueFragment(pilfLine, piciCommand->pilqCmdLineQueue);

    return S_OK;
} // SendCmdLine



//***************************************************************************
// Function: SendLiteral
//
// Purpose:
//   This function enqueues an IMAP literal fragment (as opposed to an IMAP
// line fragment) on the send queue of the given CIMAPCmdInfo structure.
// All IMAP commands are constructed in full before being submitted to the
// send machinery, so this function does not actually transmit anything.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//   LPSTREAM pstmLiteral [in] - a pointer to the stream containing the
//     literal to be sent.
//   DWORD dwSizeOfStream [in] - the size of the stream.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendLiteral(CIMAPCmdInfo *piciCommand,
                                 LPSTREAM pstmLiteral, DWORD dwSizeOfStream)
{
    IMAP_LINE_FRAGMENT *pilfLiteral;

    Assert(m_lRefCount > 0);
    Assert(NULL != pstmLiteral);

    // Create and fill out a fragment structure for the literal
    pilfLiteral = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfLiteral)
        return E_OUTOFMEMORY;

    pilfLiteral->iltFragmentType = iltLITERAL;
    pilfLiteral->ilsLiteralStoreType = ilsSTREAM;
    pilfLiteral->dwLengthOfFragment = dwSizeOfStream;
    pstmLiteral->AddRef(); // We're about to make a copy of this
    pilfLiteral->data.pstmSource = pstmLiteral;
    pilfLiteral->pilfNextFragment = NULL;
    pilfLiteral->pilfPrevFragment = NULL;

    // Queue it up to send out when we receive command continuation from svr
    EnqueueFragment(pilfLiteral, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendLiteral



//***************************************************************************
// Function: SendRangelist
//
// Purpose:
//   This function enqueues a rangelist on the send queue of the given
// CIMAPCmdInfo structure. All IMAP commands are constructed in full before
// being submitted to the send machinery, so this function does not actually
// transmit anything. The reason for storing rangelists is so that if the
// rangelist represents a message sequence number range, we can resequence it
// if we receive EXPUNGE responses before the command is transmitted.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//   IRangeList *prlRangeList [in] - rangelist which will be converted to an
//     IMAP message set during command transmission.
//   boolean bUIDRangeList [in] - TRUE if rangelist represents a UID message
//     set, FALSE if it represents a message sequence number message set.
//     UID message sets are not subject to resequencing after an EXPUNGE
//     response is received from the server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendRangelist(CIMAPCmdInfo *piciCommand,
                                   IRangeList *prlRangeList, boolean bUIDRangeList)
{
    IMAP_LINE_FRAGMENT *pilfRangelist;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);
    Assert(NULL != prlRangeList);

    // Create and fill out a rangelist element
    pilfRangelist = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfRangelist)
        return E_OUTOFMEMORY;

    pilfRangelist->iltFragmentType = iltRANGELIST;
    pilfRangelist->ilsLiteralStoreType = ilsSTRING;
    pilfRangelist->dwLengthOfFragment = 0;
    pilfRangelist->pilfNextFragment = NULL;
    pilfRangelist->pilfPrevFragment = NULL;
    prlRangeList->AddRef();
    pilfRangelist->data.prlRangeList = prlRangeList;

    // Queue it up
    EnqueueFragment(pilfRangelist, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendRangelist



//***************************************************************************
// Function: SendPause
//
// Purpose:
//   This function enqueues a pause on the send queue of the given
// CIMAPCmdInfo structure. All IMAP commands are constructed in full before
// being submitted to the send machinery, so this function does not actually
// transmit anything. A pause is used to freeze the send queue until we signal
// it to proceed again. It is used in commands which involve bi-directional
// communication, such as AUTHENTICATE or the IDLE extension.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendPause(CIMAPCmdInfo *piciCommand)
{
    IMAP_LINE_FRAGMENT *pilfPause;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);

    // Create and fill out a pause element
    pilfPause = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfPause)
        return E_OUTOFMEMORY;

    pilfPause->iltFragmentType = iltPAUSE;
    pilfPause->ilsLiteralStoreType = ilsSTRING;
    pilfPause->dwLengthOfFragment = 0;
    pilfPause->pilfNextFragment = NULL;
    pilfPause->pilfPrevFragment = NULL;
    pilfPause->data.pszSource = NULL;

    // Queue it up
    EnqueueFragment(pilfPause, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendPause



//***************************************************************************
// Function: SendStop
//
// Purpose:
//   This function enqueues a STOP on the send queue of the given
// CIMAPCmdInfo structure. All IMAP commands are constructed in full before
// being submitted to the send machinery, so this function does not actually
// transmit anything. A STOP is used to freeze the send queue until that
// command is removed from the send queue by tagged command completion.
// Currently only used in the IDLE command, because we don't want to send
// any commands until the server indicates that we are out of IDLE mode.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendStop(CIMAPCmdInfo *piciCommand)
{
    IMAP_LINE_FRAGMENT *pilfStop;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);

    // Create and fill out a stop element
    pilfStop = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfStop)
        return E_OUTOFMEMORY;

    pilfStop->iltFragmentType = iltSTOP;
    pilfStop->ilsLiteralStoreType = ilsSTRING;
    pilfStop->dwLengthOfFragment = 0;
    pilfStop->pilfNextFragment = NULL;
    pilfStop->pilfPrevFragment = NULL;
    pilfStop->data.pszSource = NULL;

    // Queue it up
    EnqueueFragment(pilfStop, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendStop



//***************************************************************************
// Function: ParseSvrResponseLine
//
// Purpose:
//   Given a line, this function classifies the line
// as an untagged response, a command continuation, or a tagged response.
// Depending on the classification, the line is then dispatched to helper
// functions to parse and act on the line.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - IMAP line fragment to parse.
//     The given pointer is updated so that it always points to the last
//     IMAP line fragment processed. The caller need only free this fragment.
//     All previous fragments will have already been freed.
//   boolean *lpbTaggedResponse [out] - sets to TRUE if response is tagged.
//   LPSTR lpszTagFromSvr [out] - returns tag here if response was tagged.
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise returns irNONE.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseSvrResponseLine (IMAP_LINE_FRAGMENT **ppilfLine,
                                           boolean *lpbTaggedResponse,
                                           LPSTR lpszTagFromSvr,
                                           IMAP_RESPONSE_ID *pirParseResult)
{
    LPSTR p, lpszSvrResponseLine;
    HRESULT hrResult;
    
    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpbTaggedResponse);
    Assert(NULL != lpszTagFromSvr);
    Assert(NULL != pirParseResult);

    *lpbTaggedResponse = FALSE; // Assume untagged response to start
    *pirParseResult = irNONE;

    // Make sure we have a line fragment, not a literal
    if (iltLINE != (*ppilfLine)->iltFragmentType) {
        AssertSz(FALSE, "I was passed a literal to parse!");
        return IXP_E_IMAP_RECVR_ERROR;
    }
    else
        lpszSvrResponseLine = (*ppilfLine)->data.pszSource;

    // Determine if server response was command continuation, untagged or tagged
    // Look at first character of response line to figure it out
    hrResult = S_OK;
    p = lpszSvrResponseLine + 1;
    switch(*lpszSvrResponseLine) {

        case cCOMMAND_CONTINUATION_PREFIX:
            if (NULL != m_piciCmdInSending &&
                icAUTHENTICATE_COMMAND == m_piciCmdInSending->icCommandID) {
                LPSTR pszStartOfData;
                DWORD dwLengthOfData;

                if ((*ppilfLine)->dwLengthOfFragment <= 2) {
                    pszStartOfData = NULL;
                    dwLengthOfData = 0;
                }
                else {
                    pszStartOfData = p + 1;
                    dwLengthOfData = (*ppilfLine)->dwLengthOfFragment - 2;
                }
                AuthenticateUser(aeCONTINUE, pszStartOfData, dwLengthOfData);
            }
            else if (NULL != m_piciCmdInSending &&
                icIDLE_COMMAND == m_piciCmdInSending->icCommandID) {
                // Leave busy mode, as we may be sitting idle for some time
                LeaveBusy();
                m_fIDLE = TRUE; // We are now in IDLE mode

                // Check if any commands are waiting to be sent
                if ((NULL != m_piciCmdInSending) && (NULL != m_piciCmdInSending->piciNextCommand))
                    ProcessSendQueue(iseUNPAUSE); // Let's get out of IDLE
            }
            else {
                // Literal continuation response
                // Save response text - assume space follows "+", no big deal if it doesn't
                lstrcpyn(m_szLastResponseText, p + 1, RESPLINE_BUFSIZE);
                ProcessSendQueue(iseCMD_CONTINUATION); // Go ahead and send the literal
            }

            break; // case cCOMMAND_CONTINUATION_PREFIX


        case cUNTAGGED_RESPONSE_PREFIX:
            if (cSPACE == *p) {
                // Server response fits spec'd form, parse as untagged response

                p += 1; // Advance p to point to next word

                // Untagged responses can be status, server/mailbox status or
                // message status responses.

                // Check for message status responses, first, by seeing
                // if first char of next word is a number
                // *** Consider using isdigit or IsDigit? ***
                // Assert(FALSE) (placeholder)
                if (*p >= '0' && *p <= '9')
                    hrResult = ParseMsgStatusResponse(ppilfLine, p, pirParseResult);
                else {
                    // It wasn't a msg status response, try status response
                    hrResult = ParseStatusResponse(p, pirParseResult);

                    // Check for error. The only error we ignore in this case is
                    // IXP_E_IMAP_UNRECOGNIZED_RESP, since this only means we
                    // should try to parse as a server/mailbox response
                    if (FAILED(hrResult) &&
                        IXP_E_IMAP_UNRECOGNIZED_RESP != hrResult)
                        break;

                    if (irNONE == *pirParseResult)
                        // It wasn't a status response, check if it's server/mailbox resp
                        hrResult = ParseSvrMboxResponse(ppilfLine, p, pirParseResult);
                }
            } // if(cSPACE == *p)
            else
                // Must be a garbled response line
                hrResult = IXP_E_IMAP_SVR_SYNTAXERR;

            break; // case cUNTAGGED_RESPONSE_PREFIX

        default:
            // Assume it's a tagged response

            // Check if response line is big enough to hold one of our tags
            if ((*ppilfLine)->dwLengthOfFragment <= NUM_TAG_CHARS) {
                hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;
                break;
            }

            // Skip past tag and check for the space
            p = lpszSvrResponseLine + NUM_TAG_CHARS;
            if (cSPACE == *p) {
                // Server response fits spec'd form, parse status response
                *p = '\0'; // Null-terminate at the tag, so we can retrieve it
                
                // Inform caller that this response was tagged, and return tag
                *lpbTaggedResponse = TRUE;
                lstrcpyn(lpszTagFromSvr, lpszSvrResponseLine, TAG_BUFSIZE);

                // Now process and return status response
                hrResult = ParseStatusResponse(p + 1, pirParseResult);
            }
            else
                // Must be a garbled response line
                hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

            break; // case DEFAULT (assumed to be tagged)
    } // switch (*lpszSvrResponseLine)


    // If an error occurred, return contents of the last processed fragment
    if (FAILED(hrResult))
        lstrcpyn(m_szLastResponseText, (*ppilfLine)->data.pszSource,
            sizeof(m_szLastResponseText));

    return hrResult;
} // ParseSvrResponseLine



//***************************************************************************
// Function: ParseStatusResponse
//
// Purpose:
//   This function parses and acts on Status Responses (section 7.1 of
// RFC-1730) (ie, OK/NO/BAD/PREAUTH/BYE). Response codes (eg, ALERT,
// TRYCREATE) are dispatched to a helper function, ParseResponseCode, for
// processing. The human-readable text associated with the response is
// stored in the module variable, m_szLastResponseText.
//
// Arguments:
//   LPSTR lpszStatusResponseLine [in] - a pointer to the text which possibly
//     represents a status response. The text should not include the first
//     part of the line, which identifies the response as tagged ("0000 ")
//     or untagged ("* ").
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise does not write a value out. The caller
//     must initialize this variable to irNONE before calling this function.
//
// Returns:
//   HRESULT indicating success or failure. If this function identifies the
// response as a status response, it returns S_OK. If it cannot recognize
// the response, it returns IXP_E_IMAP_UNRECOGNIZED_RESP. If we recognize
// the response but not the response CODE, it returns
// IXP_S_IMAP_UNRECOGNIZED_RESP (success code because we don't want
// to ever send an error to user based on unrecognized response code).
//***************************************************************************
HRESULT CImap4Agent::ParseStatusResponse (LPSTR lpszStatusResponseLine,
                                          IMAP_RESPONSE_ID *pirParseResult)
{
    HRESULT hrResult;
    LPSTR lpszResponseText;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszStatusResponseLine);
    Assert(NULL != pirParseResult);
    Assert(irNONE == *pirParseResult);

    hrResult = S_OK;

    // We can distinguish between all status responses by looking at second char
    // First, determine that string is at least 1 character long
    if ('\0' == *lpszStatusResponseLine)
        return IXP_E_IMAP_UNRECOGNIZED_RESP; // It's not a status response that we understand

    lpszResponseText = lpszStatusResponseLine;
    switch (*(lpszStatusResponseLine+1)) {
        int iResult;
    
        case 'k':
        case 'K': // Possibly the "OK" Status response
            iResult = StrCmpNI(lpszStatusResponseLine, "OK ", 3);
            if (0 == iResult) {
                // Definitely an "OK" status response
                *pirParseResult = irOK_RESPONSE;
                lpszResponseText += 3;                
            }           
            break; // case 'K' for possible "OK"
        
        case 'o':
        case 'O': // Possibly the "NO" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "NO ", 3);
            if (0 == iResult) {
                // Definitely a "NO" response
                *pirParseResult = irNO_RESPONSE;
                lpszResponseText += 3;
            }
            break; // case 'O' for possible "NO"

        case 'a':
        case 'A': // Possibly the "BAD" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "BAD ", 4);
            if (0 == iResult) {
                // Definitely a "BAD" response
                *pirParseResult = irBAD_RESPONSE;
                lpszResponseText += 4;
            }
            break; // case 'A' for possible "BAD"

        case 'r':
        case 'R': // Possibly the "PREAUTH" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "PREAUTH ", 8);
            if (0 == iResult) {
                // Definitely a "PREAUTH" response:
                // PREAUTH is issued only as a greeting - check for proper context
                // If improper context, ignore PREAUTH response
                if (ssConnecting == m_ssServerState) {
                    *pirParseResult = irPREAUTH_RESPONSE;
                    lpszResponseText += 8;
                    m_ssServerState = ssAuthenticated;                    
                }                
            }
            break; // case 'R' for possible "PREAUTH"

        case 'y':
        case 'Y': // Possibly the "BYE" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "BYE ", 4);
            if (0 == iResult) {
                // Definitely a "BYE" response:
                // Set server state to not connected
                *pirParseResult = irBYE_RESPONSE;
                lpszResponseText += 4;
                m_ssServerState = ssNotConnected;                
            }
            break; // case 'Y' for possible "BYE"
    } // switch (*(lpszStatusResponseLine+1))

    // If we recognized the command, proceed to process the response code
    if (SUCCEEDED(hrResult) && irNONE != *pirParseResult) {
        // We recognized the command, so lpszResponseText points to resp_text
        // as defined in RFC-1730. Look for optional response code
        if ('[' == *lpszResponseText) {
            HRESULT hrResponseCodeResult;

            hrResponseCodeResult = ParseResponseCode(lpszResponseText + 1);
            if (FAILED(hrResponseCodeResult))
                hrResult = hrResponseCodeResult;
        }
        else
            // No response code, record response text for future retrieval
            lstrcpyn(m_szLastResponseText, lpszResponseText,
                sizeof(m_szLastResponseText));
    }

    // If we didn't recognize the command, translate hrResult
    if (SUCCEEDED(hrResult) && irNONE == *pirParseResult)
        hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

    return hrResult;

} // ParseStatusResponse



//***************************************************************************
// Function: ParseResponseCode
//
// Purpose:
//   This function parses and acts on the response code which may be
// returned with a status response (eg, PERMANENTFLAGS or ALERT). It is
// called by ParseStatusResponse upon detection of a response code. This
// function saves the human-readable text of the response code to
// m_szLastResponseLine.
//
// Arguments:
//   LPSTR lpszResponseCode [in] - a pointer to the response code portion
//     of a response line, omitting the opening bracket ("[").
//
// Returns:
//   HRESULT indicating success or failure. If we cannot recognize the
// response code, we return IXP_S_IMAP_UNRECOGNIZED_RESP.
//***************************************************************************
HRESULT CImap4Agent::ParseResponseCode(LPSTR lpszResponseCode)
{
    HRESULT hrResult;
    WORD wHashValue;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszResponseCode);

    hrResult = IXP_S_IMAP_UNRECOGNIZED_RESP;

    switch (*lpszResponseCode) {
        int iResult;

        case 'A':
        case 'a': // Possibly the "ALERT" response code
            iResult = StrCmpNI(lpszResponseCode, "ALERT] ", 7);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;

                // Definitely the "ALERT" response code:
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = lpszResponseCode + 7;
                irIMAPResponse.irtResponseType = irtSERVER_ALERT;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

                hrResult = S_OK;
                break;
            }

            // *** FALL THROUGH *** to default case

        case 'P':
        case 'p': // Possibly the "PARSE" or "PERMANENTFLAGS" response code
            iResult = StrCmpNI(lpszResponseCode, "PERMANENTFLAGS ", 15);
            if (0 == iResult) {
                IMAP_MSGFLAGS PermaFlags;
                LPSTR p;
                DWORD dwNumBytesRead;

                // Definitely the "PERMANENTFLAGS" response code:                
                // Parse flag list
                p = lpszResponseCode + 15; // p now points to start of flag list
                hrResult = ParseMsgFlagList(p, &PermaFlags, &dwNumBytesRead);
                if (SUCCEEDED(hrResult)) {
                    IMAP_RESPONSE irIMAPResponse;
                    IIMAPCallback *pCBHandler;

                    // Record response text
                    p += dwNumBytesRead + 3; // p now points to response text
                    lstrcpyn(m_szLastResponseText, p, sizeof(m_szLastResponseText));

                    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                        &pCBHandler, irPERMANENTFLAGS_RESPONSECODE);
                    irIMAPResponse.hrResult = S_OK;
                    irIMAPResponse.lpszResponseText = m_szLastResponseText;
                    irIMAPResponse.irtResponseType = irtPERMANENT_FLAGS;
                    irIMAPResponse.irdResponseData.imfImapMessageFlags = PermaFlags;
                    OnIMAPResponse(pCBHandler, &irIMAPResponse);
                }
                break;
            } // end of PERMANENTFLAGS response code

            iResult = StrCmpNI(lpszResponseCode, "PARSE] ", 7);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;

                // Definitely the "PARSE" response code:
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = lpszResponseCode + 7;
                irIMAPResponse.irtResponseType = irtPARSE_ERROR;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

                hrResult = S_OK;
                break;
            } // end of PARSE response code

            // *** FALL THROUGH *** to default case

        case 'R':
        case 'r': // Possibly "READ-ONLY" or "READ-WRITE" response
            iResult = StrCmpNI(lpszResponseCode, "READ-WRITE] ", 12);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "READ-WRITE" response code:
                hrResult = S_OK;
               
                // Record this for enforcement purposes
                m_bCurrentMboxReadOnly = FALSE;

                // Record response text for future reference
                lstrcpyn(m_szLastResponseText, lpszResponseCode + 12,
                    sizeof(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irREADWRITE_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtREADWRITE_STATUS;
                irIMAPResponse.irdResponseData.bReadWrite = TRUE;
                OnIMAPResponse(pCBHandler, &irIMAPResponse);

                break;
            } // end of READ-WRITE response
            
            iResult = StrCmpNI(lpszResponseCode, "READ-ONLY] ", 11);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "READ-ONLY" response code:
                hrResult = S_OK;
               
                // Record this for enforcement purposes
                m_bCurrentMboxReadOnly = TRUE;

                // Record response text for future reference
                lstrcpyn(m_szLastResponseText, lpszResponseCode + 11,
                    sizeof(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irREADONLY_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtREADWRITE_STATUS;
                irIMAPResponse.irdResponseData.bReadWrite = FALSE;
                OnIMAPResponse(pCBHandler, &irIMAPResponse);

                break;
            } // end of READ-ONLY response

            // *** FALL THROUGH *** to default case

        case 'T':
        case 't': // Possibly the "TRYCREATE" response
            iResult = StrCmpNI(lpszResponseCode, "TRYCREATE] ", 11);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "TRYCREATE" response code:
                hrResult = S_OK;
               
                lstrcpyn(m_szLastResponseText, lpszResponseCode + 11,
                    sizeof(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irTRYCREATE_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtTRYCREATE;
                OnIMAPResponse(pCBHandler, &irIMAPResponse);
                break;
            }

            // *** FALL THROUGH *** to default case

        case 'U':
        case 'u': // Possibly the "UIDVALIDITY" or "UNSEEN" response codes
            iResult = StrCmpNI(lpszResponseCode, "UIDVALIDITY ", 12);
            if (0 == iResult) {
                LPSTR p, lpszEndOfNumber;
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "UIDVALIDITY" response code:
                hrResult = S_OK;
               
                // Return value to our caller so they can determine sync issues                
                p = lpszResponseCode + 12; // p points to UID number
                lpszEndOfNumber = StrChr(p, ']'); // Find closing bracket
                if (NULL == lpszEndOfNumber) {
                    hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                    break;
                }

                *lpszEndOfNumber = '\0'; // Null-terminate the number
                AssertSz(cSPACE == *(lpszEndOfNumber+1), "Flakey Server?");

                lstrcpyn(m_szLastResponseText, lpszEndOfNumber + 2,
                    sizeof(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irUIDVALIDITY_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtUIDVALIDITY;
                irIMAPResponse.irdResponseData.dwUIDValidity = StrToUint(p);
                OnIMAPResponse(pCBHandler, &irIMAPResponse);
                break;
            } // end of UIDVALIDITY response code

            iResult = StrCmpNI(lpszResponseCode, "UNSEEN ", 7);
            if (0 == iResult) {
                LPSTR p, lpszEndOfNumber;
                IMAP_RESPONSE irIMAPResponse;
                MBOX_MSGCOUNT mcMsgCount;

                // Definitely the "UNSEEN" response code:
                hrResult = S_OK;
               
                // Record the returned number for reference during new mail DL
                p = lpszResponseCode + 7; // p now points to first unseen msg num
                lpszEndOfNumber = StrChr(p, ']'); // Find closing bracket
                if (NULL == lpszEndOfNumber) {
                    hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                    break;
                }

                *lpszEndOfNumber = '\0'; // Null-terminate the number

                // Store response code for notification after command completion
                mcMsgCount = mcMsgCount_INIT;
                mcMsgCount.dwUnseen = StrToUint(p);
                mcMsgCount.bGotUnseenResponse = TRUE;
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant here
                irIMAPResponse.irtResponseType = irtMAILBOX_UPDATE;
                irIMAPResponse.irdResponseData.pmcMsgCount = &mcMsgCount;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

                AssertSz(cSPACE == *(lpszEndOfNumber+1), "Flakey Server?");

                lstrcpyn(m_szLastResponseText, lpszEndOfNumber + 2,
                    sizeof(m_szLastResponseText));
                break;
            } // end of UNSEEN response code

            // *** FALL THROUGH *** to default case

        default:
            lstrcpyn(m_szLastResponseText, lpszResponseCode, sizeof(m_szLastResponseText));
            break; // Default case: response code not recognized
    } // switch(*lpszResponseCode)

    return hrResult;

} // ParseResponseCode



//***************************************************************************
// Function: ParseSvrMboxResponse
//
// Purpose:
//   This function parses and acts on Server and Mailbox Status Responses
// from the IMAP server (see section 7.2 of RFC-1730) (eg, CAPABILITY and
// SEARCH responses).
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the IMAP line
//     fragment to parse. It is used to retrieve the literals sent with the
//     response. This pointer is updated so that it always points to the last
//     processed fragment. The caller need only free the last fragment. All
//     other fragments will already be freed when this function returns.
//   LPSTR lpszSvrMboxResponseLine [in] - a pointer to the svr/mbox response
//     line, omitting the first part of the line which identifies the response
//     as tagged ("0001 ") or untagged ("* ").
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise does not write a value out. The caller
//     must initialize this variable to irNONE before calling this function.
//
// Returns:
//   HRESULT indicating success or failure. If the response is not recognized,
// this function returns IXP_E_IMAP_UNRECOGNIZED_RESP.
//***************************************************************************
HRESULT CImap4Agent::ParseSvrMboxResponse (IMAP_LINE_FRAGMENT **ppilfLine,
                                           LPSTR lpszSvrMboxResponseLine,
                                           IMAP_RESPONSE_ID *pirParseResult)
{
    LPSTR pszTok;
    HRESULT hrResult;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpszSvrMboxResponseLine);
    Assert(NULL != pirParseResult);
    Assert(irNONE == *pirParseResult);

    hrResult = S_OK;

    // We can ID all svr/mbox status responses by looking at second char
    // First, determine that the line is at least 1 character long
    if ('\0' == *lpszSvrMboxResponseLine)
        return IXP_E_IMAP_UNRECOGNIZED_RESP; // It's not a svr/mbox response

    switch (*(lpszSvrMboxResponseLine+1)) {
        int iResult;

        case 'a':
        case 'A': // Possibly the "CAPABILITY" response
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "CAPABILITY ", 11);
            if (0 == iResult) {
                LPSTR p;

                // Definitely a "CAPABILITY" response
                *pirParseResult = irCAPABILITY_RESPONSE;

                // Search for and record known capabilities, discard unknowns
                p = lpszSvrMboxResponseLine + 11; // p points to first cap. token

                pszTok = p;
                p = StrTokEx(&pszTok, g_szSpace); // p now points to next token
                while (NULL != p) {
                    parseCapability(p); // Record capabilities which we recognize
                    p = StrTokEx(&pszTok, g_szSpace); // Grab next capability token
                }
            } // if(0 == iResult)
            break; // case 'A' for possible "CAPABILITY"

        case 'i':
        case 'I': // Possibly the "LIST" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "LIST ", 5);
            if (0 == iResult) {
                // Definitely a "LIST" response
                *pirParseResult = irLIST_RESPONSE;
                hrResult = ParseListLsubResponse(ppilfLine,
                    lpszSvrMboxResponseLine + 5, irLIST_RESPONSE);
            } // if (0 == iResult)
            break; // case 'I' for possible "LIST"

        case 's':
        case 'S': // Possibly the "LSUB" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "LSUB ", 5);
            if (0 == iResult) {
                // Definitely a "LSUB" response:
                *pirParseResult = irLSUB_RESPONSE;
                hrResult = ParseListLsubResponse(ppilfLine,
                    lpszSvrMboxResponseLine + 5, irLSUB_RESPONSE);
            } // if (0 == iResult)
            break; // case 'S' for possible "LSUB"

        case 'e':
        case 'E': // Possibly the "SEARCH" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "SEARCH", 6);
            if (0 == iResult) {
                // Definitely a "SEARCH" response:
                *pirParseResult = irSEARCH_RESPONSE;

                // Response can be "* SEARCH" or "* SEARCH <nums>". Check for null case
                if (cSPACE == *(lpszSvrMboxResponseLine + 6))
                    hrResult = ParseSearchResponse(lpszSvrMboxResponseLine + 7);
            }
            break; // case 'E' for possible "SEARCH"

        case 'l':
        case 'L': // Possibly the "FLAGS" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "FLAGS ", 6);
            if (0 == iResult) {
                IMAP_MSGFLAGS FlagsResult;
                DWORD dwThrowaway;

                // Definitely a "FLAGS" response:
                *pirParseResult = irFLAGS_RESPONSE;

                // Parse flag list
                hrResult = ParseMsgFlagList(lpszSvrMboxResponseLine + 6,
                    &FlagsResult, &dwThrowaway);

                if (SUCCEEDED(hrResult)) {
                    IMAP_RESPONSE irIMAPResponse;
                    IIMAPCallback *pCBHandler;

                    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                        &pCBHandler, irFLAGS_RESPONSE);
                    irIMAPResponse.hrResult = S_OK;
                    irIMAPResponse.lpszResponseText = NULL; // Not relevant
                    irIMAPResponse.irtResponseType = irtAPPLICABLE_FLAGS;
                    irIMAPResponse.irdResponseData.imfImapMessageFlags = FlagsResult;
                    OnIMAPResponse(pCBHandler, &irIMAPResponse);
                }
            } // if (0 == iResult)
            break; // Case 'L' for possible "FLAGS" response

        case 't':
        case 'T': // Possibly the "STATUS" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "STATUS ", 7);
            if (0 == iResult) {
                // Definitely a "STATUS" response
                *pirParseResult = irSTATUS_RESPONSE;
                hrResult = ParseMboxStatusResponse(ppilfLine,
                    lpszSvrMboxResponseLine + 7);
            } // if (0 == iResult)
            break; // Case 'T' for possible "STATUS" response

    } // case(*(lpszSvrMboxResponseLine+1))

    // Did we recognize the response? Return error if we didn't
    if (irNONE == *pirParseResult && SUCCEEDED(hrResult))
        hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

    return hrResult;

} // ParseSvrMboxResponse



//***************************************************************************
// Function: ParseMsgStatusResponse
//
// Purpose:
//   This function parses and acts on Message Status Responses from the IMAP
// server (see section 7.3 of RFC-1730) (eg, FETCH and EXISTS responses).
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the IMAP line
//     fragment to parse. It is used to retrieve the literals sent with the
//     response. This pointer is updated so that it always points to the last
//     processed fragment. The caller need only free the last fragment. All
//     other fragments will already be freed when this function returns.
//   LPSTR lpszMsgResponseLine [in] - pointer to response line, starting at
//     the number argument.
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise does not write a value out. The caller
//     must initialize this variable to irNONE before calling this function.
//
// Returns:
//   HRESULT indicating success or failure. If the response is not recognized,
// this function returns IXP_E_IMAP_UNRECOGNIZED_RESP.
//***************************************************************************
HRESULT CImap4Agent::ParseMsgStatusResponse (IMAP_LINE_FRAGMENT **ppilfLine,
                                             LPSTR lpszMsgResponseLine,
                                             IMAP_RESPONSE_ID *pirParseResult)
{
    HRESULT hrResult;
    WORD wHashValue;
    DWORD dwNumberArg;
    LPSTR p;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpszMsgResponseLine);
    Assert(NULL != pirParseResult);
    Assert(irNONE == *pirParseResult);

    hrResult = S_OK;

    // First, fetch the number argument
    p = StrChr(lpszMsgResponseLine, cSPACE); // Find the end of the number
    if (NULL == p)
        return IXP_E_IMAP_SVR_SYNTAXERR;

    dwNumberArg = StrToUint(lpszMsgResponseLine);
    p += 1; // p now points to start of message response identifier

    switch (*p) {
        int iResult;

        case 'E':
        case 'e': // Possibly the "EXISTS" or "EXPUNGE" response
            iResult = lstrcmpi(p, "EXISTS");
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                MBOX_MSGCOUNT mcMsgCount;

                // Definitely the "EXISTS" response:
                *pirParseResult = irEXISTS_RESPONSE;

                // Record mailbox size for notification at completion of command
                mcMsgCount = mcMsgCount_INIT;
                mcMsgCount.dwExists = dwNumberArg;
                mcMsgCount.bGotExistsResponse = TRUE;
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant here
                irIMAPResponse.irtResponseType = irtMAILBOX_UPDATE;
                irIMAPResponse.irdResponseData.pmcMsgCount = &mcMsgCount;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
                break;
            }

            iResult = lstrcmpi(p, "EXPUNGE");
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;

                // Definitely the "EXPUNGE" response: Inform caller via callback
                *pirParseResult = irEXPUNGE_RESPONSE;

                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant
                irIMAPResponse.irtResponseType = irtDELETED_MSG;
                irIMAPResponse.irdResponseData.dwDeletedMsgSeqNum = dwNumberArg;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
                break;
            }

            break; // Case 'E' or 'e' for possible "EXISTS" or "EXPUNGE" response


        case 'R':
        case 'r': // Possibly the "RECENT" response
            iResult = lstrcmpi(p, "RECENT");
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                MBOX_MSGCOUNT mcMsgCount;

                // Definitely the "RECENT" response:
                *pirParseResult = irRECENT_RESPONSE;
                
                // Record number for future reference
                mcMsgCount = mcMsgCount_INIT;
                mcMsgCount.dwRecent = dwNumberArg;
                mcMsgCount.bGotRecentResponse = TRUE;
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant here
                irIMAPResponse.irtResponseType = irtMAILBOX_UPDATE;
                irIMAPResponse.irdResponseData.pmcMsgCount = &mcMsgCount;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
            }

            break; // Case 'R' or 'r' for possible "RECENT" response


        case 'F':
        case 'f': // Possibly the "FETCH" response
            iResult = StrCmpNI(p, "FETCH ", 6);
            if (0 == iResult) {
                // Definitely the "FETCH" response
                *pirParseResult = irFETCH_RESPONSE;

                p += 6;
                hrResult = ParseFetchResponse(ppilfLine, dwNumberArg, p);
            } // if (0 == iResult)
            break; // Case 'F' or 'f' for possible "FETCH" response
    } // switch(*p)

    // Did we recognize the response? Return error if we didn't
    if (irNONE == *pirParseResult && SUCCEEDED(hrResult))
        hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

    return hrResult;

} // ParseMsgStatusResponse



//***************************************************************************
// Function: ParseListLsubResponse
//
// Purpose:
//   This function parses LIST and LSUB responses and invokes the
// ListLsubResponseNotification() callback to inform the user.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since literals may be sent with LIST
//     responses. This pointer is always updated to point to the fragment
//     currently in use, so that the caller may free the last one himself.
//   LPSTR lpszListResponse [in] - actually can be LIST or LSUB, but I don't
//     want to have to type "ListLsub" all the time. This points into the
//     middle of the LIST/LSUB response, where the mailbox_list begins (see
//     RFC1730, Formal Syntax). In other words, the caller should skip past
//     the initial "* LIST " or "* LSUB ", and so this ptr should point to
//     a "(".
//   IMAP_RESPONSE_ID irListLsubID [in] - either irLIST_RESPONSE or
//     irLSUB_RESPONSE. This information is required so that we can retrieve
//     the transaction ID associated with the response.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseListLsubResponse(IMAP_LINE_FRAGMENT **ppilfLine,
                                           LPSTR lpszListResponse,
                                           IMAP_RESPONSE_ID irListLsubID)
{
    LPSTR p, lpszClosingParenthesis, pszTok;
    HRESULT hrResult = S_OK;
    HRESULT hrTranslateResult = E_FAIL;
    IMAP_MBOXFLAGS MboxFlags;
    char cHierarchyChar;
    IMAP_RESPONSE irIMAPResponse;
    IIMAPCallback *pCBHandler;
    IMAP_LISTLSUB_RESPONSE *pillrd;
    LPSTR pszDecodedMboxName = NULL;
    LPSTR pszMailboxName = NULL;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpszListResponse);
    Assert(irLIST_RESPONSE == irListLsubID ||
           irLSUB_RESPONSE == irListLsubID);

    // We received an untagged LIST/LSUB response
    // lpszListResponse = <flag list> <hierarchy char> <mailbox name>
    if ('(' != *lpszListResponse)
        return IXP_E_IMAP_SVR_SYNTAXERR; // We expect an opening parenthesis
                
    p = lpszListResponse + 1; // p now points to start of first flag token
                
    // Find position of closing parenthesis. I don't like the
    // lack of efficiency, but I can fix this later. Assert(FALSE) (placeholder)
    lpszClosingParenthesis = StrChr(p, ')');
    if (NULL == lpszClosingParenthesis)
        return IXP_E_IMAP_SVR_SYNTAXERR; // We expect a closing parenthesis

    // Now process each mailbox flag returned by LIST/LSUB
    *lpszClosingParenthesis = '\0'; // Null-terminate flag list
    MboxFlags = IMAP_MBOX_NOFLAGS;
    pszTok = p;
    p = StrTokEx(&pszTok, g_szSpace); // Null-terminate first flag token
    while (NULL != p) {
        MboxFlags |= ParseMboxFlag(p);
        p = StrTokEx(&pszTok, g_szSpace); // Grab next flag token
    }
        
    // Next, grab the hierarchy character, and advance p
    // Server either sends (1) "<quoted char>" or (2) NIL
    p = lpszClosingParenthesis + 1; // p now points past flag list
    if (cSPACE == *p) {
        LPSTR pszHC = NULL;
        DWORD dwLengthOfHC;

        p += 1; // p now points to start of hierarchy char spec
        
        hrResult = NStringToString(ppilfLine, &pszHC, &dwLengthOfHC, &p);
        if (FAILED(hrResult))
            return hrResult;

        if (hrIMAP_S_NIL_NSTRING == hrResult)
            cHierarchyChar = '\0'; // Got a "NIL" for hierarchy char
        else if (hrIMAP_S_QUOTED == hrResult) {
            if (1 != dwLengthOfHC)
                return IXP_E_IMAP_SVR_SYNTAXERR; // We should only exactly ONE char back!
            else
                cHierarchyChar = pszHC[0];
        }
        else {
            // It's a literal, or something else unexpected
            MemFree(pszHC);
            return IXP_E_IMAP_SVR_SYNTAXERR;
        }
        MemFree(pszHC);

        // p now points past the closing quote (thanks to NStringToString)
    }
    else
        return IXP_E_IMAP_SVR_SYNTAXERR;


    if (cSPACE != *p)
        return IXP_E_IMAP_SVR_SYNTAXERR;


    // Grab the mailbox name - assume size of lpszListResponse is
    // whatever p has already uncovered. We expect nothing past
    // this point, so we should be safe.
    p += 1;
    hrResult = AStringToString(ppilfLine, &pszMailboxName, NULL, &p);
    if (FAILED(hrResult))
        return hrResult;

    // Convert the mailbox name from UTF7 to MultiByte and remember the result
    hrTranslateResult = _ModifiedUTF7ToMultiByte(pszMailboxName, &pszDecodedMboxName);
    if (FAILED(hrTranslateResult)) {
        hrResult = hrTranslateResult;
        goto error;
    }

    // Make sure the command line is finished (debug only)
    Assert('\0' == *p);

    // Notify the caller of our findings
    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
        &pCBHandler, irListLsubID);
    irIMAPResponse.hrResult = hrTranslateResult; // Could be IXP_S_IMAP_VERBATIM_MBOX
    irIMAPResponse.lpszResponseText = NULL; // Not relevant
    irIMAPResponse.irtResponseType = irtMAILBOX_LISTING;

    pillrd = &irIMAPResponse.irdResponseData.illrdMailboxListing;
    pillrd->pszMailboxName = pszDecodedMboxName;
    pillrd->imfMboxFlags = MboxFlags;
    pillrd->cHierarchyChar = cHierarchyChar;
    
    OnIMAPResponse(pCBHandler, &irIMAPResponse);

error:
    if (NULL != pszDecodedMboxName)
        MemFree(pszDecodedMboxName);

    if (NULL != pszMailboxName)
        MemFree(pszMailboxName);

    return hrResult;
} // ParseListLsubResponse



//***************************************************************************
// Function: ParseMboxFlag
//
// Purpose:
//   Given a mailbox_list flag (see RFC1730, Formal Syntax), this function
// returns the IMAP_MBOX_* value which corresponds to that mailbox flag.
// For instance, given the string, "\Noinferiors", this function returns
// IMAP_MBOX_NOINFERIORS.
//
// Arguments:
//   LPSTR lpszFlagToken [in] - a null-terminated string representing a
// mailbox_list flag.
//
// Returns:
//   IMAP_MBOXFLAGS value. If flag is unrecognized, IMAP_MBOX_NOFLAGS is
// returned.
//***************************************************************************
IMAP_MBOXFLAGS CImap4Agent::ParseMboxFlag(LPSTR lpszFlagToken)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszFlagToken);

    // We can identify the mailbox flags we know about by looking at the
    // fourth character of the flag name. $REVIEW: you don't have to check
    // the initial backslash, during lstrcmpi call in switch statement

    // First, check that there are at least three characters
    if ('\\' != *lpszFlagToken ||
        '\0' == *(lpszFlagToken + 1) ||
        '\0' == *(lpszFlagToken + 2))
        return IMAP_MBOX_NOFLAGS;

    switch (*(lpszFlagToken + 3)) {
        int iResult;

        case 'R':
        case 'r': // Possible "\Marked" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Marked");
            if (0 == iResult)
                return IMAP_MBOX_MARKED; // Definitely the \Marked flag

            break; // case 'r': // Possible "\Marked" flag

        case 'I':
        case 'i': // Possible "\Noinferiors" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Noinferiors");
            if (0 == iResult)
                return IMAP_MBOX_NOINFERIORS; // Definitely the \Noinferiors flag

            break; // case 'i': // Possible "\Noinferiors" flag

        case 'S':
        case 's': // Possible "\Noselect" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Noselect");
            if (0 == iResult)
                return IMAP_MBOX_NOSELECT; // Definitely the \Noselect flag

            break; // case 's': // Possible "\Noselect" flag

        case 'M':
        case 'm': // Possible "\Unmarked" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Unmarked");
            if (0 == iResult)
                return IMAP_MBOX_UNMARKED;

            break; // case 'm': // Possible "\Unmarked" flag
    } // switch (*(lpszFlagToken + 3))

    return IMAP_MBOX_NOFLAGS;
} // ParseMboxFlag



//***************************************************************************
// Function: ParseFetchResponse
//
// Purpose:
//   This function parses FETCH responses and calls the
// UpdateMsgNotification() callback to inform the user.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since literals may be sent with FETCH
//     responses. This pointer is always updated to point to the fragment
//     currently in use, so that the caller may free the last one himself.
//   DWORD dwMsgSeqNum [in] - message sequence number of this fetch resp.
//   LPSTR lpszFetchResp [in] - a pointer to the portion of the fetch
//     response after "<num> FETCH " (the msg_att portion of a message_data
//     item. See RFC1730 formal syntax).
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseFetchResponse (IMAP_LINE_FRAGMENT **ppilfLine,
                                         DWORD dwMsgSeqNum, LPSTR lpszFetchResp)
{
    LPSTR p;
    FETCH_CMD_RESULTS_EX fetchResults;
	FETCH_CMD_RESULTS    fcrOldFetchStruct;
    IMAP_RESPONSE irIMAPResponse;
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(0 != dwMsgSeqNum);
    Assert(NULL != lpszFetchResp);

    // Initialize variables
    ZeroMemory(&fetchResults, sizeof(fetchResults));

    p = lpszFetchResp;
    if ('(' != *p) {
        hrResult = IXP_E_IMAP_SVR_SYNTAXERR; // We expect opening parenthesis
        goto exit;
    }


    // Parse each FETCH response tag (eg, RFC822, FLAGS, etc.)
    hrResult = S_OK;
    do {
        // We'll identify FETCH tags based on the first character of tag
        p += 1; // Advance p to first char
        switch (*p) {
            int iResult;

            case 'b':
            case 'B':
            case 'r':
            case 'R':
                iResult = StrCmpNI(p, "RFC822.SIZE ", 12);
                if (0 == iResult) {
                    // Definitely the RFC822.SIZE tag:
                    // Read the nstring into a stream
                    p += 12; // Advance p to point to number

                    fetchResults.bRFC822Size = TRUE;
                    fetchResults.dwRFC822Size = StrToUint(p);

                    // Advance p to point past number
                    while ('0' <= *p && '9' >= *p)
                        p += 1;

                    break; // case 'r' or 'R': Possible RFC822.SIZE tag
                } // if (0 == iResult) for RFC822.HEADER

                if (0 == StrCmpNI(p, "RFC822", 6) || 0 == StrCmpNI(p, "BODY[", 5)) {
                    LPSTR pszBodyTag;
                    LPSTR pszBody;
                    DWORD dwLengthOfBody;
                    IMAP_LINE_FRAGMENT *pilfBodyTag = NULL; // Line fragment containing the body tag

                    // Find the body tag. We null-terminate all body tags after first space
                    pszBodyTag = p;
                    p = StrChr(p + 6, cSPACE);
                    if (NULL == p) {
                        hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                        goto exit;
                    }

                    *p = '\0'; // Null-terminate the body tag
                    p += 1; // Advance p to point to nstring

                    // Check if this is BODY[HEADER.FIELDS: this is the only tag that can
                    // include spaces and literals. We must skip past all of these.
                    if (0 == lstrcmpi("BODY[HEADER.FIELDS", pszBodyTag)) {

                        // Advance p until we find a ']'
                        while ('\0' != *p && ']' != *p) {
                            p += 1;

                            // Check for end of this string buffer
                            if ('\0' == *p) {
                                if (NULL == pilfBodyTag)
                                    pilfBodyTag = *ppilfLine; // Retain for future reference

                                // Advance to next fragment, discarding any literals that we find
                                do {
                                    if (NULL == (*ppilfLine)->pilfNextFragment) {
                                        // No more runway! Couldn't find ']'. Free all data and bail
                                        hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                                        while (NULL != pilfBodyTag && pilfBodyTag != *ppilfLine) {
                                            IMAP_LINE_FRAGMENT *pilfDead;

                                            pilfDead = pilfBodyTag;
                                            pilfBodyTag = pilfBodyTag->pilfNextFragment;
                                            FreeFragment(&pilfDead);
                                        }
                                        goto exit;
                                    }
                                    else
                                        *ppilfLine = (*ppilfLine)->pilfNextFragment;
                                } while (iltLINE != (*ppilfLine)->iltFragmentType);
                                
                                p = (*ppilfLine)->data.pszSource;
                            }
                        }

                        // Terminate HEADER.FIELDS chain but keep it around because we may need pszBodyTag
                        if (NULL != pilfBodyTag && NULL != (*ppilfLine)->pilfPrevFragment)
                            (*ppilfLine)->pilfPrevFragment->pilfNextFragment = NULL;

                        Assert(']' == *p);
                        Assert(cSPACE == *(p+1));
                        p += 2; // This should point us to the body nstring
                    }

                    // Read the nstring into a string
                    hrResult = NStringToString(ppilfLine, &pszBody, &dwLengthOfBody, &p);
                    if (FAILED(hrResult))
                        goto exit;

                    // If literal, it's already been handled. If NIL or string, report it to user
                    if (hrIMAP_S_QUOTED == hrResult || hrIMAP_S_NIL_NSTRING == hrResult) {
                        PrepareForFetchBody(dwMsgSeqNum, dwLengthOfBody, pszBodyTag);
                        m_dwLiteralInProgressBytesLeft = 0; // Override this
                        DispatchFetchBodyPart(pszBody, dwLengthOfBody, fDONT_FREE_BODY_TAG);
                        Assert(irsIDLE == m_irsState);
                    }

                    // Free any chains associated with HEADER.FIELDS
                    while (NULL != pilfBodyTag) {
                        IMAP_LINE_FRAGMENT *pilfDead;

                        pilfDead = pilfBodyTag;
                        pilfBodyTag = pilfBodyTag->pilfNextFragment;
                        FreeFragment(&pilfDead);
                    }

                    MemFree(pszBody);
                    break;
                } // if FETCH body tag like RFC822* or BODY[*

                // If not recognized, flow through (long way) to default case

            case 'u':
            case 'U':
                iResult = StrCmpNI(p, "UID ", 4);
                if (0 == iResult) {
                    LPSTR lpszUID;

                    // Definitely the UID tag
                    // First, find the end of the number (and verify it)
                    p += 4; // p now points to start of UID
                    lpszUID = p;
                    while ('\0' != *p && *p >= '0' && *p <= '9') // $REVIEW: isDigit?
                        p += 1;

                    // OK, we found end of number, and verified number is all digits
                    fetchResults.bUID = TRUE;
                    fetchResults.dwUID = StrToUint(lpszUID);

                    break; // case 'u' or 'U': Possible UID tag
                } // if (0 == iResult)

                // If not recognized, flow through (long way) to default case

            case 'f':
            case 'F':
                iResult = StrCmpNI(p, "FLAGS ", 6);
                if (0 == iResult) {
                    DWORD dwNumBytesRead;

                    // Definitely a FLAGS response: Parse the list
                    p += 6;
                    hrResult = ParseMsgFlagList(p, &fetchResults.mfMsgFlags,
                        &dwNumBytesRead);
                    if (FAILED(hrResult))
                        goto exit;

                    fetchResults.bMsgFlags = TRUE;
                    p += dwNumBytesRead + 1; // Advance p past end of flag list

                    break; // case 'f' or 'F': Possible FLAGS tag
                } // if (0 == iResult)

                // If not recognized, flow through to default case

            case 'i':
            case 'I':
                iResult = StrCmpNI(p, "INTERNALDATE ", 13);
                if (0 == iResult) {
                    LPSTR lpszEndOfDate;

                    // Definitely an INTERNALDATE response: convert to FILETIME
                    p += 13;
                    if ('\"' == *p)
                        p += 1; // Advance past the opening double-quote
                    else {
                        AssertSz(FALSE, "Server error: date_time starts without double-quote!");
                    }

                    lpszEndOfDate = StrChr(p, '\"'); // Find closing double-quote
                    if (NULL == lpszEndOfDate) {
                        AssertSz(FALSE, "Server error: date_time ends without double-quote!");
                        hrResult = IXP_E_IMAP_SVR_SYNTAXERR; // Can't continue, don't know where to go from
                        goto exit;
                    }

                    // Null-terminate end of date, for MimeOleInetDateToFileTime's sake
                    *lpszEndOfDate = '\0';

                    hrResult = MimeOleInetDateToFileTime(p, &fetchResults.ftInternalDate);
                    if (FAILED(hrResult))
                        goto exit;

                    p = lpszEndOfDate + 1;
                    fetchResults.bInternalDate = TRUE;
                    break; // case 'i' or 'I': Possible INTERNALDATE tag
                } // (0 == iResult)

                // If not recognized, flow through to default case

            case 'e':
            case 'E':
                iResult = StrCmpNI(p, "ENVELOPE ", 9);
                if (0 == iResult) {
                    // Definitely an envelope: parse each field!
                    p += 9;
                    hrResult = ParseEnvelope(&fetchResults, ppilfLine, &p);
                    if (FAILED(hrResult))
                        goto exit;

                    fetchResults.bEnvelope = TRUE;
                    break;
                }

                // If not recognized, flow through to default case

            default:
                // Unrecognized FETCH tag!
                // $REVIEW: We should skip past the data based on common-sense
                // rules. For now, just flip out. Be sure that above rules flow
                // through to here if unrecognized cmd
                Assert(FALSE);
                goto exit;
                break; // default case
        } // switch (*lpszFetchResp)

        // If *p is a space, we have another FETCH tag coming
    } while (cSPACE == *p);

    // Check if we ended on a closing parenthesis (as we always should)
    if (')' != *p) {
        hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
        goto exit;
    }

    // Check that there's no stuff afterwards (debug only - retail ignores)
    Assert('\0' == *(p+1));

exit:
    // Finished parsing the FETCH response. Call the UPDATE callback
    fetchResults.dwMsgSeqNum = dwMsgSeqNum;
    // Persist the cookies from body part in progress
    fetchResults.lpFetchCookie1 = m_fbpFetchBodyPartInProgress.lpFetchCookie1;
    fetchResults.lpFetchCookie2 = m_fbpFetchBodyPartInProgress.lpFetchCookie2;

    irIMAPResponse.wParam = 0;
    irIMAPResponse.lParam = 0;    
    irIMAPResponse.hrResult = hrResult;
    irIMAPResponse.lpszResponseText = NULL; // Not relevant

    if (IMAP_FETCHEX_ENABLE & m_dwFetchFlags)
    {
        irIMAPResponse.irtResponseType = irtUPDATE_MSG_EX;
        irIMAPResponse.irdResponseData.pFetchResultsEx = &fetchResults;
    }
    else
    {
        DowngradeFetchResponse(&fcrOldFetchStruct, &fetchResults);

        irIMAPResponse.irtResponseType = irtUPDATE_MSG;
        irIMAPResponse.irdResponseData.pFetchResults = &fcrOldFetchStruct;
    }
    OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

    m_fbpFetchBodyPartInProgress = FetchBodyPart_INIT;
    FreeFetchResponse(&fetchResults);
    return hrResult;
} // ParseFetchResponse



//***************************************************************************
// Function: ParseSearchResponse
//
// Purpose:
//   This function parses SEARCH responses and calls the
// SearchResponseNotification() callback to inform the user.
//
// Arguments:
//   LPSTR lpszFetchResp [in] - a pointer to the data of the search response.
//     This means that the "* SEARCH" portion should be omitted.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseSearchResponse(LPSTR lpszSearchResponse)
{
    LPSTR p, pszTok;
    IMAP_RESPONSE irIMAPResponse;
    IIMAPCallback *pCBHandler;
    CRangeList *pSearchResults;

    Assert(m_lRefCount > 0);
    Assert(NULL != lpszSearchResponse);

    // First, check for the situation where there are 0 responses
    p = lpszSearchResponse;
    while ('\0' != *p && ('0' > *p || '9' < *p))
        p += 1; // Keep going until we hit a digit

    if ('\0' == *p)
        return S_OK;

    // Create CRangeList object
    pSearchResults = new CRangeList;
    if (NULL == pSearchResults)
        return E_OUTOFMEMORY;

    // Parse search responses
    pszTok = lpszSearchResponse;
    p = StrTokEx(&pszTok, g_szSpace);
    while (NULL != p) {
        DWORD dw;
        
        dw = StrToUint(p);
        if (0 != dw) {
            HRESULT hrResult;

            hrResult = pSearchResults->AddSingleValue(dw);
            Assert(SUCCEEDED(hrResult));
        }
        else {
            // Discard unusable results
            AssertSz(FALSE, "Hmm, this server is into kinky search responses.");
        }

        p = StrTokEx(&pszTok, g_szSpace); // p now points to next number. $REVIEW: Use Opie's fstrtok!
    }

    // Notify user of search response.
    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
        &pCBHandler, irSEARCH_RESPONSE);
    irIMAPResponse.hrResult = S_OK;
    irIMAPResponse.lpszResponseText = NULL; // Not relevant
    irIMAPResponse.irtResponseType = irtSEARCH;
    irIMAPResponse.irdResponseData.prlSearchResults = (IRangeList *) pSearchResults;
    OnIMAPResponse(pCBHandler, &irIMAPResponse);

    pSearchResults->Release();
    return S_OK;
} // ParseSearchResponse



//***************************************************************************
// Function: ParseMboxStatusResponse
//
// Purpose:
//   This function parses an untagged STATUS response and calls the default
// CB handler with an irtMAILBOX_STATUS callback.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since literals may be sent with STATUS
//     responses. This pointer is always updated to point to the fragment
//     currently in use, so that the caller may free the last one himself.
//   LPSTR pszStatusResponse [in] - a pointer to the STATUS response, after
//     the "<tag> STATUS " portion (should point to the mailbox parameter).
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseMboxStatusResponse(IMAP_LINE_FRAGMENT **ppilfLine,
                                             LPSTR pszStatusResponse)
{
    LPSTR p, pszDecodedMboxName;
    LPSTR pszMailbox;
    HRESULT hrTranslateResult = E_FAIL;
    HRESULT hrResult;
    IMAP_STATUS_RESPONSE isrResult;
    IMAP_RESPONSE irIMAPResponse;

    // Initialize variables
    p = pszStatusResponse;
    ZeroMemory(&isrResult, sizeof(isrResult));
    pszDecodedMboxName = NULL;
    pszMailbox = NULL;

    // Get the name of the mailbox
    hrResult = AStringToString(ppilfLine, &pszMailbox, NULL, &p);
    if (FAILED(hrResult))
        goto exit;

    // Convert the mailbox name from UTF7 to MultiByte and remember the result
    hrTranslateResult = _ModifiedUTF7ToMultiByte(pszMailbox, &pszDecodedMboxName);
    if (FAILED(hrTranslateResult)) {
        hrResult = hrTranslateResult;
        goto exit;
    }

    // Advance to first status tag
    Assert(cSPACE == *p);
    p += 1;
    Assert('(' == *p);

    // Loop through all status attributes
    while ('\0' != *p && ')' != *p) {
        LPSTR pszTag, pszTagValue;
        DWORD dwTagValue;

        // Get pointers to tag and tag value
        Assert('(' == *p || cSPACE == *p);
        p += 1;
        pszTag = p;
        while ('\0' != *p && cSPACE != *p && ')' != *p)
            p += 1;

        Assert(cSPACE == *p); // We expect space, then tag value
        if (cSPACE == *p) {
            p += 1;
            Assert(*p >= '0' && *p <= '9');
            pszTagValue = p;
            dwTagValue = StrToUint(p);
        }

        // Advance us past number to next tag in prep for next loop iteration
        while ('\0' != *p && cSPACE != *p && ')' != *p)
            p += 1;

        switch (*pszTag) {
            int iResult;

            case 'm':
            case 'M': // Possibly the "MESSAGES" attribute
                iResult = StrCmpNI(pszTag, "MESSAGES ", 9);
                if (0 == iResult) {
                    // Definitely the "MESSAGES" tag
                    isrResult.fMessages = TRUE;
                    isrResult.dwMessages = dwTagValue;
                } // if (0 == iResult)
                break; // case 'M' for possible "MESSAGES"

            case 'r':
            case 'R': // Possibly the "RECENT" attribute
                iResult = StrCmpNI(pszTag, "RECENT ", 7);
                if (0 == iResult) {
                    // Definitely the "RECENT" tag
                    isrResult.fRecent = TRUE;
                    isrResult.dwRecent = dwTagValue;
                } // if (0 == iResult)
                break; // case 'R' for possible "RECENT"

            case 'u':
            case 'U': // Possibly UIDNEXT, UIDVALIDITY or UNSEEN
                // Check for the 3 possible tags in order of expected popularity
                iResult = StrCmpNI(pszTag, "UNSEEN ", 7);
                if (0 == iResult) {
                    // Definitely the "UNSEEN" tag
                    isrResult.fUnseen = TRUE;
                    isrResult.dwUnseen = dwTagValue;
                } // if (0 == iResult)

                iResult = StrCmpNI(pszTag, "UIDVALIDITY ", 12);
                if (0 == iResult) {
                    // Definitely the "UIDVALIDITY" tag
                    isrResult.fUIDValidity = TRUE;
                    isrResult.dwUIDValidity = dwTagValue;
                } // if (0 == iResult)

                iResult = StrCmpNI(pszTag, "UIDNEXT ", 8);
                if (0 == iResult) {
                    // Definitely the "UIDNEXT" tag
                    isrResult.fUIDNext = TRUE;
                    isrResult.dwUIDNext = dwTagValue;
                } // if (0 == iResult)
                break; // case 'U' for possible UIDNEXT, UIDVALIDITY or UNSEEN
        } // switch (*p)
    } // while ('\0' != *p)
    Assert(')' == *p);

    // Call the callback with our new-found information
    isrResult.pszMailboxName = pszDecodedMboxName;
    irIMAPResponse.wParam = 0;
    irIMAPResponse.lParam = 0;
    irIMAPResponse.hrResult = hrTranslateResult; // Could be IXP_S_IMAP_VERBATIM_MBOX
    irIMAPResponse.lpszResponseText = NULL; // Not relevant here
    irIMAPResponse.irtResponseType = irtMAILBOX_STATUS;
    irIMAPResponse.irdResponseData.pisrStatusResponse = &isrResult;
    OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

exit:
    if (NULL != pszDecodedMboxName)
        MemFree(pszDecodedMboxName);

    if (NULL != pszMailbox)
        MemFree(pszMailbox);

    return hrResult;
} // ParseMboxStatusResponse



//***************************************************************************
// Function: ParseEnvelope
//
// Purpose:
//   This function parses the ENVELOPE tag returned via a FETCH response.
//
// Arguments:
//   FETCH_CMD_RESULTS_EX *pEnvResults [out] - the results of parsing the
//     ENVELOPE tag are outputted to this structure. It is the caller's
//     responsibility to call FreeFetchResponse when finished with the data.
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current IMAP
//     response fragment. This is advanced to the next fragment in the chain
//     as necessary (due to literals). On function exit, this will point
//     to the new current response fragment so the caller may continue parsing
//     as usual.
//   LPSTR *ppCurrent [in/out] - a pointer to the first '(' after the ENVELOPE
//     tag. On function exit, this pointer is updated to point past the ')'
//     after the ENVELOPE tag so the caller may continue parsing as usual.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseEnvelope(FETCH_CMD_RESULTS_EX *pEnvResults,
                                   IMAP_LINE_FRAGMENT **ppilfLine,
                                   LPSTR *ppCurrent)
{
    HRESULT hrResult;
    LPSTR   p;
    LPSTR   pszTemp;

    TraceCall("CImap4Agent::ParseEnvelope");

    p = *ppCurrent;
    if ('(' != *p)
    {
        hrResult = TraceResult(IXP_E_IMAP_SVR_SYNTAXERR);
        goto exit;
    }

    // (1) Parse the envelope date (ignore error)
    p += 1;
    hrResult = NStringToString(ppilfLine, &pszTemp, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = MimeOleInetDateToFileTime(pszTemp, &pEnvResults->ftENVDate);
    MemFree(pszTemp);
    TraceError(hrResult); // Record but otherwise ignore error

    // (2) Get the "Subject" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = NStringToString(ppilfLine, &pEnvResults->pszENVSubject, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (3) Get the "From" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVFrom, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (4) Get the "Sender" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVSender, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (5) Get the "Reply-To" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVReplyTo, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (6) Get the "To" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVTo, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (7) Get the "Cc" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVCc, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (8) Get the "Bcc" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVBcc, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (9) Get the "InReplyTo" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = NStringToString(ppilfLine, &pEnvResults->pszENVInReplyTo, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (10) Get the "MessageID" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = NStringToString(ppilfLine, &pEnvResults->pszENVMessageID, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Read in closing parenthesis
    Assert(')' == *p);
    p += 1;

exit:
    *ppCurrent = p;
    return hrResult;
} // ParseEnvelope



//***************************************************************************
// Function: ParseIMAPAddresses
//
// Purpose:
//   This function parses a LIST of "address" constructs as defined in RFC2060
// formal syntax. There is no formal syntax token for this LIST, but an example
// can be found in the "env_from" token in RFC2060's formal syntax. This
// function would be called to parse "env_from".
//
// Arguments:
//   IMAPADDR **ppiaResults [out] - a pointer to a chain of IMAPADDR structures
//     is returned here.
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current IMAP
//     response fragment. This is advanced to the next fragment in the chain
//     as necessary (due to literals). On function exit, this will point
//     to the new current response fragment so the caller may continue parsing
//     as usual.
//   LPSTR *ppCurrent [in/out] - a pointer to the first '(' after the ENVELOPE
//     tag. On function exit, this pointer is updated to point past the ')'
//     after the ENVELOPE tag so the caller may continue parsing as usual.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseIMAPAddresses(IMAPADDR **ppiaResults,
                                        IMAP_LINE_FRAGMENT **ppilfLine,
                                        LPSTR *ppCurrent)
{
    HRESULT     hrResult = S_OK;
    BOOL        fResult;
    IMAPADDR   *piaCurrent;
    LPSTR       p;

    TraceCall("CImap4Agent::ParseIMAPAddresses");

    // Initialize output
    *ppiaResults = NULL;
    p = *ppCurrent;

    // ppCurrent either points to an address list, or "NIL"
    if ('(' != *p)
    {
        int iResult;

        // Check for "NIL"
        iResult = StrCmpNI(p, "NIL", 3);
        if (0 == iResult) {
            hrResult = S_OK;
            p += 3; // Skip past NIL
        }
        else
            hrResult = TraceResult(IXP_E_IMAP_SVR_SYNTAXERR);

        goto exit;
    }
    else
        p += 1; // Skip opening parenthesis

    // Loop over all addresses
    piaCurrent = NULL;
    while ('\0' != *p && ')' != *p) {

        // Skip any whitespace
        while (cSPACE == *p)
            p += 1;

        // Skip opening parenthesis
        Assert('(' == *p);
        p += 1;

        // Allocate a structure to hold current address
        if (NULL == piaCurrent) {
            fResult = MemAlloc((void **)ppiaResults, sizeof(IMAPADDR));
            piaCurrent = *ppiaResults;
        }
        else {
            fResult = MemAlloc((void **)&piaCurrent->pNext, sizeof(IMAPADDR));
            piaCurrent = piaCurrent->pNext;
        }

        if (FALSE == fResult)
        {
            hrResult = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        ZeroMemory(piaCurrent, sizeof(IMAPADDR));

        // (1) Parse addr_name (see RFC2060)
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszName, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // (2) Parse addr_adl (see RFC2060)
        Assert(cSPACE == *p);
        p += 1;
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszADL, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // (3) Parse addr_mailbox (see RFC2060)
        Assert(cSPACE == *p);
        p += 1;
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszMailbox, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // (4) Parse addr_host (see RFC2060)
        Assert(cSPACE == *p);
        p += 1;
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszHost, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // Skip closing parenthesis
        Assert(')' == *p);
        p += 1;

    } // while

    // Read past closing parenthesis
    Assert(')' == *p);
    p += 1;

exit:
    if (FAILED(hrResult))
    {
        FreeIMAPAddresses(*ppiaResults);
        *ppiaResults = NULL;
    }

    *ppCurrent = p;
    return hrResult;
} // ParseIMAPAddresses



//***************************************************************************
// Function: DowngradeFetchResponse
//
// Purpose:
//   For IIMAPTransport users who do not enable FETCH_CMD_RESULTS_EX structures
// via IIMAPTransport2::EnableFetchEx, we have to continue to report FETCH
// results using FETCH_CMD_RESULTS. This function copies the relevant data
// from a FETCH_CMD_RESULTS_EX structure to FETCH_CMD_RESULTS. Too bad IDL
// doesn't support inheritance in structures...
//
// Arguments:
//   FETCH_CMD_RESULTS *pcfrOldFetchStruct [out] - points to destination for
//     data contained in pfcreNewFetchStruct.
//   FETCH_CMD_RESULTS_EX *pfcreNewFetchStruct [in] - points to source data
//     which is to be transferred to pfcrOldFetchStruct.
//***************************************************************************
void CImap4Agent::DowngradeFetchResponse(FETCH_CMD_RESULTS *pfcrOldFetchStruct,
                                         FETCH_CMD_RESULTS_EX *pfcreNewFetchStruct)
{
    pfcrOldFetchStruct->dwMsgSeqNum = pfcreNewFetchStruct->dwMsgSeqNum;
    pfcrOldFetchStruct->bMsgFlags = pfcreNewFetchStruct->bMsgFlags;
    pfcrOldFetchStruct->mfMsgFlags = pfcreNewFetchStruct->mfMsgFlags;

    pfcrOldFetchStruct->bRFC822Size = pfcreNewFetchStruct->bRFC822Size;
    pfcrOldFetchStruct->dwRFC822Size = pfcreNewFetchStruct->dwRFC822Size;

    pfcrOldFetchStruct->bUID = pfcreNewFetchStruct->bUID;
    pfcrOldFetchStruct->dwUID = pfcreNewFetchStruct->dwUID;

    pfcrOldFetchStruct->bInternalDate = pfcreNewFetchStruct->bInternalDate;
    pfcrOldFetchStruct->ftInternalDate = pfcreNewFetchStruct->ftInternalDate;

    pfcrOldFetchStruct->lpFetchCookie1 = pfcreNewFetchStruct->lpFetchCookie1;
    pfcrOldFetchStruct->lpFetchCookie2 = pfcreNewFetchStruct->lpFetchCookie2;
} // DowngradeFetchResponse



//***************************************************************************
// Function: QuotedToString
//
// Purpose:
//   This function, given a "quoted" (see RFC1730, Formal Syntax), converts
// it to a regular string, that is, a character array without any escape
// characters or delimiting double quotes. For instance, the quoted,
// "\"FUNKY\"\\MAN!!!!" would be converted to "FUNKY"\MAN!!!!.
//
// Arguments:
//   LPSTR *ppszDestination [out] - the translated quoted is returned as
//     a regular string in this destination buffer. It is the caller's
//     responsibility to MemFree this buffer when finished with it.
//   LPDWORD pdwLengthOfDestination [out] - the length of *ppszDestination is
//     returned here. Pass NULL if not interested.
//   LPSTR *ppCurrentSrcPos [in/out] - this is a ptr to a ptr to the quoted,
//     including opening and closing double-quotes. The function returns
//     a pointer to the end of the quoted so that the caller may continue
//     parsing the response line.
//
// Returns:
//   HRESULT indicating success or failure. If successful, returns
// hrIMAP_S_QUOTED.
//***************************************************************************
HRESULT CImap4Agent::QuotedToString(LPSTR *ppszDestination,
                                    LPDWORD pdwLengthOfDestination,
                                    LPSTR *ppCurrentSrcPos)
{
    LPSTR lpszSourceBuf, lpszUnescapedSequence;
    CByteStream bstmQuoted;
    int iUnescapedSequenceLen;
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppszDestination);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);   

    lpszSourceBuf = *ppCurrentSrcPos;
    if ('\"' != *lpszSourceBuf)
        return IXP_E_IMAP_SVR_SYNTAXERR; // Need opening double-quote

    // Walk through string, translating escape characters as we go
    lpszSourceBuf += 1;
    lpszUnescapedSequence = lpszSourceBuf;
    while('\"' != *lpszSourceBuf && '\0' != *lpszSourceBuf) {
        if ('\\' == *lpszSourceBuf) {
            char cEscaped;

            // Escape character found, get next character
            iUnescapedSequenceLen = (int) (lpszSourceBuf - lpszUnescapedSequence);
            lpszSourceBuf += 1;

            switch(*lpszSourceBuf) {
                case '\\':
                    cEscaped = '\\';
                    break;

                case '\"':
                    cEscaped = '\"';
                    break;

                default:
                    // (Includes case '\0':)
                    // This isn't a spec'ed escape char!
                    // Return syntax error, but consider robust course of action $REVIEW
                    Assert(FALSE);
                    return IXP_E_IMAP_SVR_SYNTAXERR;
            } // switch(*lpszSourceBuf)

            // First, flush unescaped sequence leading up to escape sequence
            if (iUnescapedSequenceLen > 0) {
                hrResult = bstmQuoted.Write(lpszUnescapedSequence,
                    iUnescapedSequenceLen, NULL);
                if (FAILED(hrResult))
                    return hrResult;
            }

            // Append escaped character
            hrResult = bstmQuoted.Write(&cEscaped, 1, NULL);
            if (FAILED(hrResult))
                return hrResult;

            // Set us up to find next unescaped sequence
            lpszUnescapedSequence = lpszSourceBuf + 1;
        } // if ('\' == *lpszSourceBuf)
        else if (FALSE == isTEXT_CHAR(*lpszSourceBuf))
            return IXP_E_IMAP_SVR_SYNTAXERR;

        lpszSourceBuf += 1;
    } // while not closing quote or end of string

    // Flush any remaining unescaped sequences
    iUnescapedSequenceLen = (int) (lpszSourceBuf - lpszUnescapedSequence);
    if (iUnescapedSequenceLen > 0) {
        hrResult = bstmQuoted.Write(lpszUnescapedSequence, iUnescapedSequenceLen, NULL);
        if (FAILED(hrResult))
            return hrResult;
    }

    *ppCurrentSrcPos = lpszSourceBuf + 1; // Update user's ptr to point PAST quoted
    if ('\0' == *lpszSourceBuf)
        return IXP_E_IMAP_SVR_SYNTAXERR; // Quoted str ended before closing quote!
    else {
        hrResult = bstmQuoted.HrAcquireStringA(pdwLengthOfDestination,
            ppszDestination, ACQ_DISPLACE);
        if (FAILED(hrResult))
            return hrResult;
        else
            return hrIMAP_S_QUOTED;
    }
} // Convert QuotedToString



//***************************************************************************
// Function: AStringToString
//
// Purpose:
//   This function, given an astring (see RFC1730, Formal Syntax), converts
// it to a regular string, that is, a character array without any escape
// characters or delimiting double quotes or literal size specifications.
// As specified in RFC1730, an astring may be expressed as an atom, a
// quoted, or a literal.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since astrings can be sent as literals.
//     This pointer is always updated to point to the fragment currently in
//     use, so that the caller may free the last one himself.
//   LPSTR *ppszDestination [out] - the translated astring is returned as a
//     regular string in this destination buffer. It is the caller's
//     responsibility to MemFree the returned buffer when finished with it.
//   LPDWORD pdwLengthOfDestination [in] - the length of *ppszDestination.
//     Pass NULL if not interested.
//   LPSTR *ppCurrentSrcPos [in/out] - this is a ptr to a ptr to the astring,
//     including opening and closing double-quotes if it's a quoted, or the
//     literal size specifier (ie, {#}) if it's a literal. A pointer to the
//     end of the astring is returned to the caller, so that they may
//     continue parsing the response line.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     hrIMAP_S_FOUNDLITERAL - a literal was found and copied to destination
//     hrIMAP_S_QUOTED - a quoted was found and copied to destination
//     hrIMAP_S_ATOM - an atom was found and copied to destination
//***************************************************************************
HRESULT CImap4Agent::AStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
                                     LPSTR *ppszDestination,
                                     LPDWORD pdwLengthOfDestination,
                                     LPSTR *ppCurrentSrcPos)
{
    LPSTR pSrc;

    // Check args
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != ppszDestination);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);

    // Identify astring as atom, quoted or literal
    pSrc = *ppCurrentSrcPos;
    switch(*pSrc) {
        case '{': {
            IMAP_LINE_FRAGMENT *pilfLiteral, *pilfLine;

            // It's a literal
            // $REVIEW: We ignore the literal size spec and anything after it. Should we?
            pilfLiteral = (*ppilfLine)->pilfNextFragment;
            if (NULL == pilfLiteral)
                return IXP_E_IMAP_INCOMPLETE_LINE;

            Assert(iltLITERAL == pilfLiteral->iltFragmentType);
            if (ilsSTRING == pilfLiteral->ilsLiteralStoreType) {
                if (ppszDestination)
                    *ppszDestination = PszDupA(pilfLiteral->data.pszSource);
                if (pdwLengthOfDestination)
                    *pdwLengthOfDestination = lstrlen(pilfLiteral->data.pszSource);
            }
            else {
                HRESULT hrResult;
                LPSTREAM pstmSource = pilfLiteral->data.pstmSource;

                // Append a null-terminator to stream
                hrResult = pstmSource->Write(c_szEmpty, 1, NULL);
                if (FAILED(hrResult))
                    return hrResult;

                // Copy stream into a memory block
                hrResult = HrStreamToByte(pstmSource, (LPBYTE *)ppszDestination,
                    pdwLengthOfDestination);
                if (FAILED(hrResult))
                    return hrResult;

                if (pdwLengthOfDestination)
                    *pdwLengthOfDestination -= 1; // includes null-term, so decrease by 1
            }


            // OK, now set up next line so caller may continue parsing the response
            pilfLine = pilfLiteral->pilfNextFragment;
            if (NULL == pilfLine)
                return IXP_E_IMAP_INCOMPLETE_LINE;

            // Update user's pointer into the source line
            Assert(iltLINE == pilfLine->iltFragmentType);
            *ppCurrentSrcPos = pilfLine->data.pszSource;

            // Clean up and exit
            FreeFragment(&pilfLiteral);
            FreeFragment(ppilfLine);
            *ppilfLine = pilfLine; // Update this ptr so it always points to LAST fragment

            return hrIMAP_S_FOUNDLITERAL;
        } // case AString == LITERAL

        case '\"':
            // It's a QUOTED STING, convert it to regular string
            return QuotedToString(ppszDestination, pdwLengthOfDestination,
                ppCurrentSrcPos);

        default: {
            DWORD dwLengthOfAtom;

            // It's an atom: find the end of the atom
            while (isATOM_CHAR(*pSrc))
                pSrc += 1;

            // Copy the atom into a buffer for the user
            dwLengthOfAtom = (DWORD) (pSrc - *ppCurrentSrcPos);
            if (ppszDestination) {
                BOOL fResult;

                fResult = MemAlloc((void **)ppszDestination, dwLengthOfAtom + 1);
                if (FALSE == fResult)
                    return E_OUTOFMEMORY;

                CopyMemory(*ppszDestination, *ppCurrentSrcPos, dwLengthOfAtom);
                (*ppszDestination)[dwLengthOfAtom] = '\0';
            }

            if (pdwLengthOfDestination)
                *pdwLengthOfDestination = dwLengthOfAtom;

            // Update user's pointer
            *ppCurrentSrcPos = pSrc;
            return hrIMAP_S_ATOM;
        } // case AString == ATOM
    } // switch(*pSrc)
} // AStringToString



//***************************************************************************
// Function: isTEXT_CHAR
//
// Purpose:
//   This function identifies characters which are TEXT_CHARs as defined in
// RFC1730's Formal Syntax section.
//
// Returns:
//   This function returns TRUE if the given character fits the definition.
//***************************************************************************
inline boolean CImap4Agent::isTEXT_CHAR(char c)
{
    // $REVIEW: signed/unsigned char, 8/16-bit char issues with 8th bit check
    // Assert(FALSE);
    if (c != (c & 0x7F) || // 7-bit
        '\0' == c ||
        '\r' == c ||
        '\n' == c)
        return FALSE;
    else
        return TRUE;
} // isTEXT_CHAR
    


//***************************************************************************
// Function: isATOM_CHAR
//
// Purpose:
//   This function identifies characters which are ATOM_CHARs as defined in
// RFC1730's Formal Syntax section.
//
// Returns:
//   This function returns TRUE if the given character fits the definition.
//***************************************************************************
inline boolean CImap4Agent::isATOM_CHAR(char c)
{
    // $REVIEW: signed/unsigned char, 8/16-bit char issues with 8th bit check
    // Assert(FALSE);
    if (c != (c & 0x7F) || // 7-bit
        '\0' == c ||       // At this point, we know it's a CHAR
        '(' == c ||        // Explicit atom_specials char
        ')' == c ||        // Explicit atom_specials char
        '{' == c ||        // Explicit atom_specials char
        cSPACE == c ||     // Explicit atom_specials char
        c < 0x1f ||        // Check for CTL
        0x7f == c ||       // Check for CTL
        '%' == c ||        // Check for list_wildcards
        '*' == c ||        // Check for list_wildcards
        '\\' == c ||       // Check for quoted_specials
        '\"' == c)         // Check for quoted_specials
        return FALSE;
    else
        return TRUE;
} // isATOM_CHAR



//***************************************************************************
// Function: NStringToString
//
// Purpose:
//   This function, given an nstring (see RFC1730, Formal Syntax), converts
// it to a regular string, that is, a character array without any escape
// characters or delimiting double quotes or literal size specifications.
// As specified in RFC1730, an nstring may be expressed as a quoted,
// a literal, or "NIL".
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since nstrings can be sent as literals.
//     This pointer is always updated to point to the fragment currently in
//     use, so that the caller may free the last one himself.
//   LPSTR *ppszDestination [out] - the translated nstring is returned as
//     a regular string in this destination buffer. It is the caller's
//     responsibility to MemFree this buffer when finished with it.
//   LPDWORD pdwLengthOfDestination [out] - the length of *ppszDestination is
//     returned here. Pass NULL if not interested.
//   LPSTR *ppCurrentSrcPos [in/out] - this is a ptr to a ptr to the nstring,
//     including opening and closing double-quotes if it's a quoted, or the
//     literal size specifier (ie, {#}) if it's a literal. A pointer to the
//     end of the nstring is returned to the caller, so that they may
//     continue parsing the response line.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     hrIMAP_S_FOUNDLITERAL - a literal was found and copied to destination
//     hrIMAP_S_QUOTED - a quoted was found and copied to destination
//     hrIMAP_S_NIL_NSTRING - "NIL" was found.
//***************************************************************************
HRESULT CImap4Agent::NStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
                                     LPSTR *ppszDestination,
                                     LPDWORD pdwLengthOfDestination,
                                     LPSTR *ppCurrentSrcPos)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != ppszDestination);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);

    // nstrings are almost exactly like astrings, but nstrings cannot
    // have any value other than "NIL" expressed as an atom.
    hrResult = AStringToString(ppilfLine, ppszDestination, pdwLengthOfDestination,
        ppCurrentSrcPos);

    // If AStringToString found an ATOM, the only acceptable response is "NIL"
    if (hrIMAP_S_ATOM == hrResult) {
        if (0 == lstrcmpi("NIL", *ppszDestination)) {
            **ppszDestination = '\0'; // Blank str in case someone tries to use it
            if (pdwLengthOfDestination)
                *pdwLengthOfDestination = 0;

            return hrIMAP_S_NIL_NSTRING;
        }
        else {
            MemFree(*ppszDestination);
            *ppszDestination = NULL;
            if (pdwLengthOfDestination)
                *pdwLengthOfDestination = 0;

            return IXP_E_IMAP_SVR_SYNTAXERR;
        }
    }
    else
        return hrResult;
} // NStringToString




//***************************************************************************
// Function: NStringToStream
//
// Purpose:
//   This function is performs exactly the same job as NStringToString, but
// places the result in a stream, instead. This function should be used when
// the caller expects potentially LARGE results.
//
// Arguments:
//   Similar to NStringToString (minus string buffer output args), plus:
//   LPSTREAM *ppstmResult [out] - A stream is created for the caller, and
//     the translated nstring is written as a regular string to the stream
//     and returned via this argument. The returned stream is not rewound
//     on exit.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     hrIMAP_S_FOUNDLITERAL - a literal was found and copied to destination
//     hrIMAP_S_QUOTED - a quoted was found and copied to destination
//     hrIMAP_S_NIL_NSTRING - "NIL" was found.
//***************************************************************************
HRESULT CImap4Agent::NStringToStream(IMAP_LINE_FRAGMENT **ppilfLine,
                                     LPSTREAM *ppstmResult,
                                     LPSTR *ppCurrentSrcPos)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != ppstmResult);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);

    // Check if this nstring is a literal
    if ('{' == **ppCurrentSrcPos) {
        IMAP_LINE_FRAGMENT *pilfLine, *pilfLiteral;

        // Yup, it's a literal! Write the literal to a stream
        // $REVIEW: We ignore the literal size spec and anything after it. Should we?
        pilfLiteral = (*ppilfLine)->pilfNextFragment;
        if (NULL == pilfLiteral)
            return IXP_E_IMAP_INCOMPLETE_LINE;

        Assert(iltLITERAL == pilfLiteral->iltFragmentType);
        if (ilsSTRING == pilfLiteral->ilsLiteralStoreType) {
            HRESULT hrStreamResult;
            ULONG ulNumBytesWritten;

            // Literal is stored as string. Create stream and write to it
            hrStreamResult = MimeOleCreateVirtualStream(ppstmResult);
            if (FAILED(hrStreamResult))
                return hrStreamResult;

            hrStreamResult = (*ppstmResult)->Write(pilfLiteral->data.pszSource,
                pilfLiteral->dwLengthOfFragment, &ulNumBytesWritten);
            if (FAILED(hrStreamResult))
                return hrStreamResult;

            Assert(ulNumBytesWritten == pilfLiteral->dwLengthOfFragment);
        }
        else {
            // Literal is stored as stream. Just AddRef() and return ptr
            (pilfLiteral->data.pstmSource)->AddRef();
            *ppstmResult = pilfLiteral->data.pstmSource;
        }

        // No need to null-terminate streams

        // OK, now set up next line fragment so caller may continue parsing response
        pilfLine = pilfLiteral->pilfNextFragment;
        if (NULL == pilfLine)
            return IXP_E_IMAP_INCOMPLETE_LINE;

        // Update user's pointer into the source line
        Assert(iltLINE == pilfLine->iltFragmentType);
        *ppCurrentSrcPos = pilfLine->data.pszSource;

        // Clean up and exit
        FreeFragment(&pilfLiteral);
        FreeFragment(ppilfLine);
        *ppilfLine = pilfLine; // Update this ptr so it always points to LAST fragment

        return hrIMAP_S_FOUNDLITERAL;
    }
    else {
        HRESULT hrResult, hrStreamResult;
        ULONG ulLiteralLen, ulNumBytesWritten;
        LPSTR pszLiteralSrc;

        // Not a literal. Translate NString to string (in-place).
        // Add 1 to destination size calculation for null-terminator
        hrResult = NStringToString(ppilfLine, &pszLiteralSrc,
            &ulLiteralLen, ppCurrentSrcPos);
        if (FAILED(hrResult))
            return hrResult;

        // Create stream to hold result
        hrStreamResult = MimeOleCreateVirtualStream(ppstmResult);
        if (FAILED(hrStreamResult)) {
            MemFree(pszLiteralSrc);
            return hrStreamResult;
        }

        // Write the result to the stream
        hrStreamResult = (*ppstmResult)->Write(pszLiteralSrc, ulLiteralLen,
            &ulNumBytesWritten);
        MemFree(pszLiteralSrc);
        if (FAILED(hrStreamResult))
            return hrStreamResult;

        Assert(ulLiteralLen == ulNumBytesWritten); // Debug-only paranoia
        return hrResult;
    }
} // NStringToStream



//***************************************************************************
// Function: ParseMsgFlagList
//
// Purpose:
//   Given a flag_list (see RFC1730, Formal Syntax section), this function
// returns the IMAP_MSG_* bit-flags which correspond to the flags in the
// list. For instance, given the flag list, "(\Answered \Draft)", this
// function returns IMAP_MSG_ANSWERED | IMAP_MSG_DRAFT. Any unrecognized
// flags are ignored.
//
// Arguments:
//   LPSTR lpszStartOfFlagList [in/out] - a pointer the start of a flag_list,
//     including opening and closing parentheses. This function does not
//     explicitly output anything to this string, but it does MODIFY the
//     string by null-terminating spaces and the closing parenthesis.
//   IMAP_MSGFLAGS *lpmfMsgFlags [out] - IMAP_MSGFLAGS value corresponding
//     to the given flag list. If the given flag list is empty, this
//     function returns IMAP_MSG_NOFLAGS.
//   LPDWORD lpdwNumBytesRead [out] - the number of bytes between the
//     opening parenthesis and the closing parenthesis of the flag list.
//     Adding this number to the address of the start of the flag list
//     yields a pointer to the closing parenthesis.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseMsgFlagList(LPSTR lpszStartOfFlagList,
                                      IMAP_MSGFLAGS *lpmfMsgFlags,
                                      LPDWORD lpdwNumBytesRead)
{
    LPSTR p, lpszEndOfFlagList, pszTok;

    Assert(m_lRefCount > 0);
    Assert(NULL != lpszStartOfFlagList);
    Assert(NULL != lpmfMsgFlags);
    Assert(NULL != lpdwNumBytesRead);

    p = lpszStartOfFlagList;
    if ('(' != *p)
        // Opening parenthesis was not found
        return IXP_E_IMAP_SVR_SYNTAXERR;

    // Look for closing parenthesis Assert(FALSE); // *** $REVIEW: C-RUNTIME ALERT
    lpszEndOfFlagList = StrChr(p, ')');
    if (NULL == lpszEndOfFlagList)
        // Closing parenthesis was not found
        return IXP_E_IMAP_SVR_SYNTAXERR;

    
    *lpdwNumBytesRead = (DWORD) (lpszEndOfFlagList - lpszStartOfFlagList);
    *lpszEndOfFlagList = '\0'; // Null-terminate flag list
    *lpmfMsgFlags = IMAP_MSG_NOFLAGS; // Initialize output
    pszTok = lpszStartOfFlagList + 1;
    p = StrTokEx(&pszTok, g_szSpace); // Get ptr to first token

    while (NULL != p) {
        // We'll narrow the search down for the flag by looking at its
        // first letter. Although there's a conflict between \Deleted and
        // \Draft, this is the best way for case-insensitive search
        // (first non-conflicting letter is five characters in!)    

        // First, check that there is at least one character
        if ('\\' == *p) {
            p += 1;
            switch (*p) {
                int iResult;

                case 'a':
                case 'A': // Possible "Answered" flag
                    iResult = lstrcmpi(p, c_szIMAP_MSG_ANSWERED);
                    if (0 == iResult)
                        *lpmfMsgFlags |= IMAP_MSG_ANSWERED; // Definitely the \Answered flag
                    break;

                case 'f':
                case 'F': // Possible "Flagged" flag
                    iResult = lstrcmpi(p, c_szIMAP_MSG_FLAGGED);
                    if (0 == iResult)
                        *lpmfMsgFlags |= IMAP_MSG_FLAGGED; // Definitely the \Flagged flag
                    break;

                case 'd':
                case 'D': // Possible "Deleted" or "Draft" flags
                    // "Deleted" is more probable, so check it first
                    iResult = lstrcmpi(p, c_szIMAP_MSG_DELETED);
                    if (0 == iResult) {
                        *lpmfMsgFlags |= IMAP_MSG_DELETED; // Definitely the \Deleted flag
                        break;
                    }

                    iResult = lstrcmpi(p, c_szIMAP_MSG_DRAFT);
                    if (0 == iResult) {
                        *lpmfMsgFlags |= IMAP_MSG_DRAFT; // Definitely the \Draft flag
                        break;
                    }

                    break;

                case 's':
                case 'S': // Possible "Seen" flags
                    iResult = lstrcmpi(p, c_szIMAP_MSG_SEEN);
                    if (0 == iResult)
                        *lpmfMsgFlags |= IMAP_MSG_SEEN; // Definitely the \Seen flag

                    break;
            } // switch(*p)
        } // if ('\\' == *p)

        p = StrTokEx(&pszTok, g_szSpace); // Grab next token
    } // while (NULL != p)

    return S_OK; // If we hit this point, we're all done
} // ParseMsgFlagList



//****************************************************************************
// Function: AppendSendAString
//
// Purpose:
//   This function is intended to be used by a caller who is constructing a
// command line which contains IMAP astrings (see RFC1730 Formal Syntax).
// This function takes a regular C string and converts it to an IMAP astring,
// appending it to the end of the command line under construction.
//
// An astring may take the form of an atom, a quoted, or a literal. For
// performance reasons (both conversion and network), I don't see any reason
// we should ever output an atom. Thus, this function returns either a quoted
// or a literal.
//
// Although IMAP's most expressive form of astring is the literal, it can
// result in costly network handshaking between client and server, and
// thus should be avoided unless required. Another consideration to use
// in deciding to use literal/quoted is size of the string. Most IMAP servers
// will have some internal limit to the maximum length of a line. To avoid
// exceeding this limit, it is wise to encode large strings as literals
// (where large typically means 1024 bytes).
//
// If the function converts the C string to a quoted, it appends it to the
// end of the partially-constructed command line. If it must send as a literal,
// it enqueues the partially-constructed command line in the send queue of the
// command-in-progress, enqueues the literal as well, then creates a new line
// fragment so the caller may continue constructing the command. The caller's
// pointer to the end of the command line is reset so that the user may
// append the next argument without concern of whether the C string
// was sent as a quoted or a literal. Although the caller may pretend
// that he's constructing a command line simply by appending to it, when this
// function returns, he caller may not be appending to the same string buffer.
// (Not that the caller should care.)
//
// This function prepends a SPACE by default, so this function may be called
// as many times in a row as desired. Each astring will be separated by a
// space.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - a pointer to the command currently under
//     construction. This argument is needed so we can enqueue command
//     fragments to the command's send queue.
//   LPSTR lpszCommandLine [in] - a pointer to a partially constructed
//     command line suitable for passing to SendCmdLine (which supplies the
//     tag). For instance, this argument could point to a string, "SELECT".
//   LPSTR *ppCmdLinePos [in/out] - a pointer to the end of the command
//     line. If this function converts the C string to a quoted, the quoted
//     is appended to lpszCommandLine, and *ppCmdLinePos is updated to point
//     to the end of the quoted. If the C string is converted to a literal,
//     lpszCommandLine is made blank (null-terminated), and *ppCmdLinePos
//     is reset to the start of the line. In either case, the user should
//     continue to construct the command line using the updated *ppCmdLinePos
//     pointer, and send lpszCommandLine as usual to SendCmdLine.
//   DWORD dwSizeOfCommandLine [in] - size of the command line buffer, for
//     buffer overflow-checking purposes.
//   LPSTR lpszSource [in] - pointer to the source string.
//   BOOL fPrependSpace [in] - TRUE if we should prepend a space, FALSE if no
//     space should be prepended. Usually TRUE unless this AString follows
//     a rangelist.
//
// Returns:
//   HRESULT indicating success or failure. In particular, there are two
// success codes (which the caller need not act on):
//
//   hrIMAP_S_QUOTED - indicates that the source string was successfully
//     converted to a quoted, and has been appended to lpszCommandLine.
//     *ppCmdLinePos has been updated to point to the end of the new line
//     should the caller wish to continue appending arguments.
//   hrIMAP_S_FOUNDLITERAL - indicates that the source string was
//     sent as a literal. The command line has been blanked, and the user
//     may continue constructing the command line with his *ppCmdLinePos ptr.
//****************************************************************************
HRESULT CImap4Agent::AppendSendAString(CIMAPCmdInfo *piciCommand,
                                       LPSTR lpszCommandLine, LPSTR *ppCmdLinePos,
                                       DWORD dwSizeOfCommandLine, LPCSTR lpszSource,
                                       BOOL fPrependSpace)
{
    HRESULT hrResult;
    DWORD dwMaxQuotedSize;
    DWORD dwSizeOfQuoted;

    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);
    Assert(NULL != lpszCommandLine);
    Assert(NULL != ppCmdLinePos);
    Assert(NULL != *ppCmdLinePos);
    Assert(0 != dwSizeOfCommandLine);
    Assert(NULL != lpszSource);
    Assert(*ppCmdLinePos < lpszCommandLine + dwSizeOfCommandLine);


    // Assume quoted string at start. If we have to send as literal, then too
    // bad, the quoted conversion work is wasted.

    // Prepend a space if so directed by user
    if (fPrependSpace) {
        **ppCmdLinePos = cSPACE;
        *ppCmdLinePos += 1;
    }

    dwMaxQuotedSize = min(dwLITERAL_THRESHOLD,
        (DWORD) (lpszCommandLine + dwSizeOfCommandLine - *ppCmdLinePos));
    hrResult = StringToQuoted(*ppCmdLinePos, lpszSource, dwMaxQuotedSize,
        &dwSizeOfQuoted);

    // Always check for buffer overflow
    Assert(*ppCmdLinePos + dwSizeOfQuoted < lpszCommandLine + dwSizeOfCommandLine);
    
    if (SUCCEEDED(hrResult)) {
        Assert(hrIMAP_S_QUOTED == hrResult);

        // Successfully converted to quoted,
        *ppCmdLinePos += dwSizeOfQuoted; // Advance user's ptr into cmd line
    }
    else {
        BOOL bResult;
        DWORD dwLengthOfLiteral;
        DWORD dwLengthOfLiteralSpec;
        IMAP_LINE_FRAGMENT *pilfLiteral;

        // OK, couldn't convert to quoted (buffer overflow? 8-bit char?)
        // Looks like it's literal time. We SEND this puppy.

        // Find out length of literal, append to command line and send
        dwLengthOfLiteral = lstrlen(lpszSource); // Yuck, but I'm betting most Astrings are quoted
        dwLengthOfLiteralSpec = wsprintf(*ppCmdLinePos, "{%lu}\r\n", dwLengthOfLiteral);
        Assert(*ppCmdLinePos + dwLengthOfLiteralSpec < lpszCommandLine + dwSizeOfCommandLine);
        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, lpszCommandLine,
            (DWORD) (*ppCmdLinePos + dwLengthOfLiteralSpec - lpszCommandLine)); // Send entire command line
        if (FAILED(hrResult))
            return hrResult;

        // Queue the literal up - send FSM will wait for cmd continuation
        pilfLiteral = new IMAP_LINE_FRAGMENT;
        pilfLiteral->iltFragmentType = iltLITERAL;
        pilfLiteral->ilsLiteralStoreType = ilsSTRING;
        pilfLiteral->dwLengthOfFragment = dwLengthOfLiteral;        
        pilfLiteral->pilfNextFragment = NULL;
        pilfLiteral->pilfPrevFragment = NULL;
        bResult = MemAlloc((void **) &pilfLiteral->data.pszSource, dwLengthOfLiteral + 1);
        if (FALSE == bResult) {
            delete pilfLiteral;
            return E_OUTOFMEMORY;
        }
        lstrcpy(pilfLiteral->data.pszSource, lpszSource);

        EnqueueFragment(pilfLiteral, piciCommand->pilqCmdLineQueue);

        // Done with sending cmd line w/ literal. Blank out old cmd line and rewind ptr
        *ppCmdLinePos = lpszCommandLine;
        *lpszCommandLine = '\0';
        
        hrResult = hrIMAP_S_FOUNDLITERAL;
    } // else: convert AString to Literal

    return hrResult;
} // AppendSendAString



//****************************************************************************
// Function: StringToQuoted
//
// Purpose:
//   This function converts a regular C string to an IMAP quoted (see RFC1730
// Formal Syntax).
//
// Arguments:
//   LPSTR lpszDestination [out] - the output buffer where the quoted should
//     be placed.
//   LPSTR lpszSource [in] - the source string.
//   DWORD dwSizeOfDestination [in] - the size of the output buffer,
//     lpszDestination. Note that in the worst case, the size of the output
//     buffer must be at least one character larger than the quoted actually
//     needs. This is because before translating a character from source to
//     destination, the loop checks if there is enough room for the worst
//     case, a quoted_special, which needs 2 bytes.
//   LPDWORD lpdwNumCharsWritten [out] - the number of characters written
//     to the output buffer, not including the null-terminator. Adding this
//     value to lpszDestination will result in a pointer to the end of the
//     quoted.
//
// Returns:
//   HRESULT indicating success or failure. In particular, this function
// returns hrIMAP_S_QUOTED if it was successful in converting the source
// string to a quoted. If not, the function returns E_FAIL.
//****************************************************************************
HRESULT CImap4Agent::StringToQuoted(LPSTR lpszDestination, LPCSTR lpszSource,
                                    DWORD dwSizeOfDestination,
                                    LPDWORD lpdwNumCharsWritten)
{
    LPCSTR p;
    DWORD dwNumBytesWritten;

    Assert(NULL != lpszDestination);
    Assert(NULL != lpszSource);

    // Initialize return value
    *lpdwNumCharsWritten = 0;

    if (dwSizeOfDestination >= 3)
        dwSizeOfDestination -= 2; // Leave room for closing quote and null-term at end
    else {
        Assert(FALSE); // Smallest quoted is 3 chars ('\"\"\0')
        return IXP_E_IMAP_BUFFER_OVERFLOW;
    }

    p = lpszSource;
    *lpszDestination = '\"'; // Start us off with an opening quote
    lpszDestination += 1;
    dwNumBytesWritten = 1;
    // Keep looping until we hit source null-term, or until we don't have
    // enough room in destination for largest output (2 chars for quoted_special)
    dwSizeOfDestination -= 1; // This ensures always room for quoted_special
    while (dwNumBytesWritten < dwSizeOfDestination && '\0' != *p) {

        if (FALSE == isTEXT_CHAR(*p))
            return E_FAIL; // Quoted's can only represent TEXT_CHAR's

        if ('\\' == *p || '\"' == *p) {
            *lpszDestination = '\\'; // Prefix with escape character
            lpszDestination += 1;
            dwNumBytesWritten += 1;
        } // if quoted_special

        *lpszDestination = *p;
        lpszDestination += 1;
        dwNumBytesWritten += 1;
        p += 1;
    } // while ('\0' != *p)

    *lpszDestination = '\"'; // Install closing quote
    *(lpszDestination + 1) = '\0'; // Null-terminate the string
    *lpdwNumCharsWritten = dwNumBytesWritten + 1; // Incl closing quote in size

    if ('\0' == *p)
        return hrIMAP_S_QUOTED;
    else
        return IXP_E_IMAP_BUFFER_OVERFLOW; // Buffer overflow
} // StringToQuoted



//***************************************************************************
// Function: GenerateCommandTag
//
// Purpose:
//   This function generates a unique tag so that a command issuer may
// identify his command to the IMAP server (and so that the server response
// may be identified with the command). It is a simple base-36 (alphanumeric)
// counter which increments a static 4-digit base-36 number on each call.
// (Digits are 0,1,2,3,4,6,7,8,9,A,B,C,...,Z).
//
// Returns:
//   No return value. This function always succeeds.
//***************************************************************************
void CImap4Agent::GenerateCommandTag(LPSTR lpszTag)
{
    static char szCurrentTag[NUM_TAG_CHARS+1] = "ZZZZ";
    LPSTR p;
    boolean bWraparound;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszTag);

    EnterCriticalSection(&m_csTag);

    // Increment current tag
    p = szCurrentTag + NUM_TAG_CHARS - 1; // p now points to last tag character
    do {
        bWraparound = FALSE;
        *p += 1;
        
        // Increment from '9' should jump to 'A'
        if (*p > '9' && *p < 'A')
            *p = 'A';
        else if (*p > 'Z') {
            // Increment from 'Z' should wrap around to '0'
            *p = '0';
            bWraparound = TRUE;
            p -= 1; // Advance pointer to more significant character
        }
    } while (TRUE == bWraparound && szCurrentTag <= p);

    LeaveCriticalSection(&m_csTag);

    // Return result to caller
    lstrcpyn(lpszTag, szCurrentTag, TAG_BUFSIZE);
} // GenerateCommandTag



//***************************************************************************
// Function NoArgCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command>.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "CREATE".
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icCREATE_COMMAND.
//   SERVERSTATE ssMinimumState [in] - minimum server state required for
//     the given command. Used for debug purposes only.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - wParam and lParam form a unique ID assigned by the
//     caller to this IMAP command and its responses. Can be anything, but
//     note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::NoArgCommand(LPCSTR lpszCommandVerb,
                                  IMAP_COMMAND icCommandID,
                                  SERVERSTATE ssMinimumState,
                                  WPARAM wParam, LPARAM lParam,
                                  IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    char szBuffer[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    DWORD dwCmdLineLen;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(icNO_COMMAND != icCommandID);

    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less
    if (ssMinimumState > m_ssServerState &&
        (ssConnecting != m_ssServerState || ssMinimumState > ssAuthenticated)) {
        // Forgive the NOOP command, due to bug #31968 (err msg build-up if svr drops conn)
        AssertSz(icNOOP_COMMAND == icCommandID,
            "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssMinimumState,
        wParam, lParam, pCBHandler);
    dwCmdLineLen = wsprintf(szBuffer, "%s %s\r\n", piciCommand->szTag, lpszCommandVerb);

    // Send command to server
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szBuffer, dwCmdLineLen);
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // NoArgCommand



//***************************************************************************
// Function OneArgCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command> <astring>. This currently includes SELECT, EXAMINE,
// CREATE, DELETE, SUBSCRIBE and UNSUBSCRIBE. Since all of these commands
// require the server to be in Authorized state, I don't bother asking for
// a minimum SERVERSTATE argument.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "CREATE".
//   LPSTR lpszMboxName [in] - a C string representing the argument for the
//     command. It is automatically converted to an IMAP astring.
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icCREATE_COMMAND.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::OneArgCommand(LPCSTR lpszCommandVerb, LPSTR lpszMboxName,
                                   IMAP_COMMAND icCommandID,
                                   WPARAM wParam, LPARAM lParam,
                                   IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    char szBuffer[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    LPSTR p, pszUTF7MboxName;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(NULL != lpszMboxName);
    Assert(icNO_COMMAND != icCommandID);

    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always TRUE in this case)
    if (ssAuthenticated > m_ssServerState && ssConnecting != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    // Initialize variables
    pszUTF7MboxName = NULL;

    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssAuthenticated,
        wParam, lParam, pCBHandler);

    // Construct command line
    p = szBuffer;
    p += wsprintf(szBuffer, "%s %s", piciCommand->szTag, lpszCommandVerb);

    // Convert mailbox name to UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszMboxName, &pszUTF7MboxName);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
    hrResult = AppendSendAString(piciCommand, szBuffer, &p, sizeof(szBuffer), pszUTF7MboxName);
    if (FAILED(hrResult))
        goto error;

    // Send command
    p += wsprintf(p, "\r\n"); // Append CRLF
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szBuffer, (DWORD) (p - szBuffer));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser    
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    if (NULL != pszUTF7MboxName)
        MemFree(pszUTF7MboxName);

    return hrResult;
} // OneArgCommand



//***************************************************************************
// Function TwoArgCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command> <astring> <astring>.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "CREATE".
//   LPCSTR lpszFirstArg [in] - a C string representing the first argument for
//     the command. It is automatically converted to an IMAP astring.
//   LPCSTR lpszSecondArg [in] - a C string representing the first argument
//     for the command. It is automatically converted to an IMAP astring.
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icCREATE_COMMAND.
//   SERVERSTATE ssMinimumState [in] - minimum server state required for
//     the given command. Used for debug purposes only.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::TwoArgCommand(LPCSTR lpszCommandVerb,
                                   LPCSTR lpszFirstArg,
                                   LPCSTR lpszSecondArg,
                                   IMAP_COMMAND icCommandID,
                                   SERVERSTATE ssMinimumState,
                                   WPARAM wParam, LPARAM lParam,
                                   IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    CIMAPCmdInfo *piciCommand;
    char szCommandLine[CMDLINE_BUFSIZE];
    LPSTR p;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(NULL != lpszFirstArg);
    Assert(NULL != lpszSecondArg);
    Assert(icNO_COMMAND != icCommandID);

    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less
    if (ssMinimumState > m_ssServerState &&
        (ssConnecting != m_ssServerState || ssMinimumState > ssAuthenticated)) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }
    
    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssMinimumState,
        wParam, lParam, pCBHandler);

    // Send command to server, wait for response
    p = szCommandLine;
    p += wsprintf(szCommandLine, "%s %s", piciCommand->szTag, lpszCommandVerb);

    // Don't worry about buffer overflow, long strings will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
        sizeof(szCommandLine), lpszFirstArg);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about buffer overflow, long strings will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
        sizeof(szCommandLine), lpszSecondArg);
    if (FAILED(hrResult))
        goto error;

    p += wsprintf(p, "\r\n"); // Append CRLF
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, (DWORD) (p - szCommandLine));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // TwoArgCommand



//***************************************************************************
// Function: RangedCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command> <msg range> <string>.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation. It is the caller's responsiblity to construct
// a string with proper IMAP syntax.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "SEARCH".
//   boolean bUIDPrefix [in] - TRUE if the command verb should be prefixed with
//     UID, as in the case of "UID SEARCH".
//   IRangeList *pMsgRange [in] - the message range for this command. The
//     caller can pass NULL for this argument to omit the range, but ONLY
//     if the pMsgRange represents a UID message range.
//   boolean bUIDRangeList [in] - TRUE if pMsgRange represents a UID range,
//     FALSE if pMsgRange represents a message sequence number range. Ignored
//     if pMsgRange is NULL.
//   boolean bAStringCmdArgs [in] - TRUE if lpszCmdArgs should be sent as
//     an ASTRING, FALSE if lpszCmdArgs should be sent
//   LPCSTR lpszCmdArgs [in] - a C string representing the remaining argument
//     for the command. It is the caller's responsibility to ensure that
//     this string is proper IMAP syntax.
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icSEARCH_COMMAND.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::RangedCommand(LPCSTR lpszCommandVerb,
                                   boolean bUIDPrefix,
                                   IRangeList *pMsgRange,
                                   boolean bUIDRangeList,
                                   boolean bAStringCmdArgs,
                                   LPSTR lpszCmdArgs,
                                   IMAP_COMMAND icCommandID,
                                   WPARAM wParam, LPARAM lParam,
                                   IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    CIMAPCmdInfo *piciCommand;
    char szCommandLine[CMDLINE_BUFSIZE];
    DWORD dwCmdLineLen;
    BOOL fAStringPrependSpace = TRUE;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(NULL != lpszCmdArgs);
    AssertSz(NULL != pMsgRange || TRUE == bUIDRangeList ||
        icSEARCH_COMMAND == icCommandID, "Only UID cmds or SEARCH can omit msg range");
    Assert(icNO_COMMAND != icCommandID);

    // All ranged commands require selected state
    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always FALSE in this case)
    if (ssSelected > m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssSelected,
        wParam, lParam, pCBHandler);
    if (NULL == piciCommand) {
        hrResult = E_OUTOFMEMORY;
        goto error;
    }
    piciCommand->fUIDRangeList = bUIDRangeList;

    // Construct command tag and verb, append to command-line queue
    dwCmdLineLen = wsprintf(szCommandLine,
        bUIDPrefix ? "%s UID %s " : "%s %s ",
        piciCommand->szTag, lpszCommandVerb);

    // Special case: if SEARCH command, UID rangelist requires "UID" in front of range
    if (icSEARCH_COMMAND == icCommandID && NULL != pMsgRange && bUIDRangeList)
        dwCmdLineLen += wsprintf(szCommandLine + dwCmdLineLen, "UID ");

    if (NULL != pMsgRange) {
        Assert(dwCmdLineLen + 1 < sizeof(szCommandLine)); // Check for overflow
        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, dwCmdLineLen);
        if (FAILED(hrResult))
            goto error;

        // Add message range to command-line queue, if it exists
        hrResult = SendRangelist(piciCommand, pMsgRange, bUIDRangeList);
        if (FAILED(hrResult))
            goto error;

        pMsgRange = NULL; // If we get to this point, MemFree of rangelist will be handled
        fAStringPrependSpace = FALSE; // Rangelist automatically APPENDS space
        dwCmdLineLen = 0;
    }

    // Now append the command-line arguments (remember to append CRLF)
    if (bAStringCmdArgs) {
        LPSTR p;

        p = szCommandLine + dwCmdLineLen;
        // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
        hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
            sizeof(szCommandLine), lpszCmdArgs, fAStringPrependSpace);
        if (FAILED(hrResult))
            goto error;

        p += wsprintf(p, "\r\n"); // Append CRLF
        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END,
            szCommandLine, (DWORD) (p - szCommandLine));
        if (FAILED(hrResult))
            goto error;
    }
    else {
        if (dwCmdLineLen > 0) {
            hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, dwCmdLineLen);
            if (FAILED(hrResult))
                goto error;
        }

        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END | sclAPPEND_CRLF,
            lpszCmdArgs, lstrlen(lpszCmdArgs));
        if (FAILED(hrResult))
            goto error;
    }

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult)) {
        if (NULL != piciCommand)
            delete piciCommand;
    }

    return hrResult;
} // RangedCommand



//***************************************************************************
// Function TwoMailboxCommand
//
// Purpose:
//   This function is a wrapper function for TwoArgCommand. This function
// converts the two mailbox names to modified IMAP UTF-7 before submitting
// the two arguments to TwoArgCommand.
//
// Arguments:
//   Same as for TwoArgCommandm except for name/const change:
//   LPSTR lpszFirstMbox [in] - pointer to the first mailbox argument.
//   LPSTR lpszSecondMbox [in] - pointer to the second mailbox argument.
//
// Returns:
//   Same as TwoArgCommand.
//***************************************************************************
HRESULT CImap4Agent::TwoMailboxCommand(LPCSTR lpszCommandVerb,
                                       LPSTR lpszFirstMbox,
                                       LPSTR lpszSecondMbox,
                                       IMAP_COMMAND icCommandID,
                                       SERVERSTATE ssMinimumState,
                                       WPARAM wParam, LPARAM lParam,
                                       IIMAPCallback *pCBHandler)
{
    LPSTR pszUTF7FirstMbox, pszUTF7SecondMbox;
    HRESULT hrResult;

    // Initialize variables
    pszUTF7FirstMbox = NULL;
    pszUTF7SecondMbox = NULL;

    // Convert both mailbox names to UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszFirstMbox, &pszUTF7FirstMbox);
    if (FAILED(hrResult))
        goto exit;

    hrResult = _MultiByteToModifiedUTF7(lpszSecondMbox, &pszUTF7SecondMbox);
    if (FAILED(hrResult))
        goto exit;

    hrResult = TwoArgCommand(lpszCommandVerb, pszUTF7FirstMbox, pszUTF7SecondMbox,
        icCommandID, ssMinimumState, wParam, lParam, pCBHandler);

exit:
    if (NULL != pszUTF7FirstMbox)
        MemFree(pszUTF7FirstMbox);

    if (NULL != pszUTF7SecondMbox)
        MemFree(pszUTF7SecondMbox);

    return hrResult;
} // TwoMailboxCommand



//***************************************************************************
// Function: parseCapability
//
// Purpose:
//   The CAPABILITY response from the IMAP server consists of a list of
// capbilities, with each capability names separated by a space. This
// function takes a capability name (null-terminated) as its argument.
// If the name is recognized, we set the appropriate flags in
// m_dwCapabilityFlags. Otherwise, we do nothing.
// 
//
// Returns:
//   No return value. This function always succeeds.
//***************************************************************************
void CImap4Agent::parseCapability (LPSTR lpszCapabilityToken)
{
    DWORD dwCapabilityFlag;
    LPSTR p;
    int iResult;

    Assert(m_lRefCount > 0);

    p = lpszCapabilityToken;
    dwCapabilityFlag = 0;
    switch (*lpszCapabilityToken) {
        case 'I':
        case 'i': // Possible IMAP4, IMAP4rev1
            iResult = lstrcmpi(p, "IMAP4");
            if (0 == iResult) {
                dwCapabilityFlag = IMAP_CAPABILITY_IMAP4;
                break;
            }

            iResult = lstrcmpi(p, "IMAP4rev1");
            if (0 == iResult) {
                dwCapabilityFlag = IMAP_CAPABILITY_IMAP4rev1;
                break;
            }

            iResult = lstrcmpi(p, "IDLE");
            if (0 == iResult) {
                dwCapabilityFlag = IMAP_CAPABILITY_IDLE;
                break;
            }

            break; // case 'I' for possible IMAP4, IMAP4rev1, IDLE

        case 'A':
        case 'a': // Possible AUTH
            if (0 == StrCmpNI(p, "AUTH-", 5) ||
                0 == StrCmpNI(p, "AUTH=", 5)) {
                // Parse the authentication mechanism after the '-' or '='
                // I don't recognize any, at the moment
                p += 5;
                AddAuthMechanism(p);
            }

            break; // case 'A' for possible AUTH

        default:
            break; // Do nothing
    } // switch (*lpszCapabilityToken)

    m_dwCapabilityFlags |= dwCapabilityFlag;
} // parseCapability



//***************************************************************************
// Function: AddAuthMechanism
//
// Purpose:
//   This function adds an authentication token from the server (returned via
// CAPABILITY) to our internal list of authentication mechanisms supported
// by the server.
//
// Arguments:
//   LPSTR pszAuthMechanism [in] - a pointer to a null-terminated
//     authentication token from the server returned via CAPABILITY. For
//     instance, "KERBEROS_V4" is an example of an auth token.
//***************************************************************************
void CImap4Agent::AddAuthMechanism(LPSTR pszAuthMechanism)
{
    AssertSz(NULL == m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iNumAuthTokens],
        "Memory's a-leaking, and you've just lost an authentication mechanism.");

    if (NULL == pszAuthMechanism || '\0' == *pszAuthMechanism) {
        AssertSz(FALSE, "No authentication mechanism, here!");
        return;
    }

    m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iNumAuthTokens] =
        PszDupA(pszAuthMechanism);
    Assert(NULL != m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iNumAuthTokens]);

    m_asAuthStatus.iNumAuthTokens += 1;
} // AddAuthMechanism



//***************************************************************************
// Function: Capability
//
// Purpose:
//   The CImap4Agent class always asks for the server's CAPABILITIES after
// a connection is established. The result is saved in a register and
// is available by calling this function.
//
// Arguments:
//   DWORD *pdwCapabilityFlags [out] - a DWORD with bit-flags specifying
//      which capabilities this IMAP server supports is returned here.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Capability (DWORD *pdwCapabilityFlags)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pdwCapabilityFlags);

    if (m_ssServerState < ssNonAuthenticated) {
        AssertSz(FALSE, "Must be connected before I can return capabilities");
        *pdwCapabilityFlags = 0;
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }
    else {
        *pdwCapabilityFlags = m_dwCapabilityFlags;
        return S_OK;
    }
} // Capability



//***************************************************************************
// Function: Select
//
// Purpose:
//   This function issues a SELECT command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - pointer to IMAP-compliant mailbox name
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Select(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName)
{
    return OneArgCommand("SELECT", lpszMailboxName, icSELECT_COMMAND,
        wParam, lParam, pCBHandler);
    // Successful SELECT bumps server status to ssSelected
} // Select



//***************************************************************************
// Function: Examine
//
// Purpose:
//   This function issues an EXAMINE command to the IMAP server.
//
// Arguments:
//   Same as for the Select() function.
//
// Returns:
//   Same as for the Select() function.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Examine(WPARAM wParam, LPARAM lParam,
                                               IIMAPCallback *pCBHandler,
                                               LPSTR lpszMailboxName)
{
    return OneArgCommand("EXAMINE", lpszMailboxName, icEXAMINE_COMMAND,
        wParam, lParam, pCBHandler);
    // Successful EXAMINE bumps server status to ssSelected
} // Examine



//***************************************************************************
// Function: Create
//
// Purpose:
//   This function issues a CREATE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Create(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName)
{
    return OneArgCommand("CREATE", lpszMailboxName, icCREATE_COMMAND,
        wParam, lParam, pCBHandler);
} // Create



//***************************************************************************
// Function: Delete
//
// Purpose:
//   This function issues a DELETE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Delete(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName)
{
    return OneArgCommand("DELETE", lpszMailboxName, icDELETE_COMMAND,
        wParam, lParam, pCBHandler);
} // Delete



//***************************************************************************
// Function: Rename
//
// Purpose:
//   This function issues a RENAME command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - CURRENT IMAP-compliant name of the mailbox.
//   LPSTR lpszNewMailboxName - NEW IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Rename(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName,
                                              LPSTR lpszNewMailboxName)
{
    return TwoMailboxCommand("RENAME", lpszMailboxName, lpszNewMailboxName,
        icRENAME_COMMAND, ssAuthenticated, wParam, lParam, pCBHandler);
} // Rename



//***************************************************************************
// Function: Subscribe
//
// Purpose:
//   This function issues a SUBSCRIBE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Subscribe(WPARAM wParam, LPARAM lParam,
                                                 IIMAPCallback *pCBHandler,
                                                 LPSTR lpszMailboxName)
{
    return OneArgCommand("SUBSCRIBE", lpszMailboxName, icSUBSCRIBE_COMMAND,
        wParam, lParam, pCBHandler);
}  // Subscribe



//***************************************************************************
// Function: Unsubscribe
//
// Purpose:
//   This function issues an UNSUBSCRIBE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Unsubscribe(WPARAM wParam, LPARAM lParam,
                                                   IIMAPCallback *pCBHandler,
                                                   LPSTR lpszMailboxName)
{
    return OneArgCommand("UNSUBSCRIBE", lpszMailboxName, icUNSUBSCRIBE_COMMAND,
        wParam, lParam, pCBHandler);
} // Unsubscribe



//***************************************************************************
// Function: List
//
// Purpose:
//   This function issues a LIST command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxNameReference - IMAP-compliant reference for mbox name
//   LPSTR lpszMailboxNamePattern - IMAP-compliant pattern for mailbox name
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::List(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler,
                                            LPSTR lpszMailboxNameReference,
                                            LPSTR lpszMailboxNamePattern)
{
    return TwoMailboxCommand("LIST", lpszMailboxNameReference,
        lpszMailboxNamePattern, icLIST_COMMAND, ssAuthenticated, wParam,
        lParam, pCBHandler);
} // List



//***************************************************************************
// Function: Lsub
//
// Purpose:
//   This function issues a LSUB command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxNameReference - IMAP-compliant reference for mbox name
//   LPSTR lpszMailboxNamePattern - IMAP-compliant pattern for mailbox name.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Lsub(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler,
                                            LPSTR lpszMailboxNameReference,
                                            LPSTR lpszMailboxNamePattern)
{
    return TwoMailboxCommand("LSUB", lpszMailboxNameReference,
        lpszMailboxNamePattern, icLSUB_COMMAND, ssAuthenticated, wParam,
        lParam, pCBHandler);
} // Lsub



//***************************************************************************
// Function: Append
//
// Purpose:
//   This function issues an APPEND command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant mailbox name to append message to.
//   LPSTR lpszMessageFlags - IMAP-compliant list of msg flags to set for msg.
//     Set to NULL to set no message flags. (Avoid passing "()" due to old Cyrus
//     server bug). $REVIEW: This should be changed to IMAP_MSGFLAGS!!!
//   FILETIME ftMessageDateTime - date/time to associate with msg (GMT/UTC)
//   LPSTREAM lpstmMessageToSave - the message to save, in RFC822 format.
//     No need to rewind the stream, this is done by CConnection::SendStream.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Append(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName,
                                              LPSTR lpszMessageFlags,
                                              FILETIME ftMessageDateTime,
                                              LPSTREAM lpstmMessageToSave)
{
    // PARTYTIME!!
    const SYSTEMTIME stDefaultDateTime = {1999, 12, 5, 31, 23, 59, 59, 999};

    HRESULT hrResult;
    FILETIME ftLocalTime;
    SYSTEMTIME stMsgDateTime;
    DWORD dwTimeZoneId;
    LONG lTZBias, lTZHour, lTZMinute;
    TIME_ZONE_INFORMATION tzi;
    ULONG ulMessageSize;
    char szCommandLine[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    LPSTR p, pszUTF7MailboxName;

    char cTZSign;
    BOOL bResult;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszMailboxName);
    Assert(NULL != lpstmMessageToSave);

    // Verify proper server state
    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always TRUE in this case)
    if (ssAuthenticated > m_ssServerState && ssConnecting != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    // Initialize variables
    pszUTF7MailboxName = NULL;
    piciCommand = new CIMAPCmdInfo(this, icAPPEND_COMMAND, ssAuthenticated,
        wParam, lParam, pCBHandler);

    // Convert FILETIME to IMAP date/time spec
    bResult = FileTimeToLocalFileTime(&ftMessageDateTime, &ftLocalTime);
    if (bResult)
        bResult = FileTimeToSystemTime(&ftLocalTime, &stMsgDateTime);

    if (FALSE == bResult) {
        Assert(FALSE); // Conversion failed
        // If retail version, just substitute a default system time
        stMsgDateTime = stDefaultDateTime;
    }

    // Figure out time zone (stolen from MsgOut.cpp's HrEmitDateTime)
    dwTimeZoneId = GetTimeZoneInformation (&tzi);
    switch (dwTimeZoneId)
    {
    case TIME_ZONE_ID_STANDARD:
        lTZBias = tzi.Bias + tzi.StandardBias;
        break;

    case TIME_ZONE_ID_DAYLIGHT:
        lTZBias = tzi.Bias + tzi.DaylightBias;
        break;

    case TIME_ZONE_ID_UNKNOWN:
    default:
        lTZBias = 0 ;   // $$BUG:  what's supposed to happen here?
        break;
    }

    lTZHour   = lTZBias / 60;
    lTZMinute = lTZBias % 60;
    cTZSign     = (lTZHour < 0) ? '+' : '-';

    // Get size of message
    hrResult = HrGetStreamSize(lpstmMessageToSave, &ulMessageSize);
    if (FAILED(hrResult))
        goto error;

    // Send command to server
    // Format: tag APPEND mboxName msgFlags "dd-mmm-yyyy hh:mm:ss +/-hhmm" {msgSize}
    p = szCommandLine;
    p += wsprintf(szCommandLine, "%s APPEND", piciCommand->szTag);

    // Convert mailbox name to modified UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszMailboxName, &pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p, sizeof(szCommandLine),
        pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    if (NULL != lpszMessageFlags)
        p += wsprintf(p, " %.250s", lpszMessageFlags);

    // Limited potential for buffer overflow: mailbox names over 128 bytes are sent as
    // literals, so worst case buffer usage is 11+128+34+flags+literalNum=173+~20=~200
    p += wsprintf(p,
        " \"%2d-%.3s-%04d %02d:%02d:%02d %c%02d%02d\" {%lu}\r\n",
        stMsgDateTime.wDay, lpszMonthsOfTheYear[stMsgDateTime.wMonth],
        stMsgDateTime.wYear, stMsgDateTime.wHour, stMsgDateTime.wMinute,
        stMsgDateTime.wSecond,
        cTZSign, abs(lTZHour), abs(lTZMinute),
        ulMessageSize);
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, (DWORD) (p - szCommandLine));
    if (FAILED(hrResult))
        goto error;

    // Don't have to wait for response... message body will be queued
    hrResult = SendLiteral(piciCommand, lpstmMessageToSave, ulMessageSize);
    if (FAILED(hrResult))
        goto error;

    // Have to send CRLF to end command line (the literal's CRLF doesn't count)
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, c_szCRLF, lstrlen(c_szCRLF));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    if (NULL != pszUTF7MailboxName)
        MemFree(pszUTF7MailboxName);

    return hrResult;
} // Append



//***************************************************************************
// Function: Close
//
// Purpose:
//   This function issues a CLOSE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Close (WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler)
{
    return NoArgCommand("CLOSE", icCLOSE_COMMAND, ssSelected,
        wParam, lParam, pCBHandler);
} // Close



//***************************************************************************
// Function: Expunge
//
// Purpose:
//   This function issues an EXPUNGE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//
// Returns:
//   HRESULT indicating success or failure on send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Expunge (WPARAM wParam, LPARAM lParam,
                                                IIMAPCallback *pCBHandler)
{
    return NoArgCommand("EXPUNGE", icEXPUNGE_COMMAND, ssSelected,
        wParam, lParam, pCBHandler);
} // Expunge



//***************************************************************************
// Function: Search
//
// Purpose:
//   This function issues a SEARCH command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszSearchCriteria - IMAP-compliant list of search criteria
//   boolean bReturnUIDs - if TRUE, we prepend "UID" to command.
//   IRangeList *pMsgRange [in] - range of messages over which to operate
//     the search. This argument should be NULL to exclude the message
//     set from the search criteria.
//   boolean bUIDRangeList [in] - TRUE if pMsgRange refers to a UID range,
//     FALSE if pMsgRange refers to a message sequence number range. If
//     pMsgRange is NULL, this argument is ignored.
//
// Returns:
//   HRESULT indicating success or failure on send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Search(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszSearchCriteria,
                                              boolean bReturnUIDs, IRangeList *pMsgRange,
                                              boolean bUIDRangeList)
{
    return RangedCommand("SEARCH", bReturnUIDs, pMsgRange, bUIDRangeList,
        rcNOT_ASTRING_ARG, lpszSearchCriteria, icSEARCH_COMMAND, wParam,
        lParam, pCBHandler);
} // Search



//***************************************************************************
// Function: Fetch
//
// Purpose:
//   This function issues a FETCH command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   IRangeList *pMsgRange [in] - range of messages to fetch. The caller
//     should pass NULL if he is using UIDs and he wants to generate his
//     own message set (in lpszFetchArgs). If the caller is using msg
//     seq nums, this argument MUST be specified to allow this class to
//     resequence the msg nums as required.
//   boolean bUIDMsgRange [in] - if TRUE, prepends "UID" to FETCH command and
//     treats pMsgRange as a UID range.
//   LPSTR lpszFetchArgs - arguments to the FETCH command
//   
//
// Returns:
//   HRESULT indicating success or failure of the send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Fetch(WPARAM wParam, LPARAM lParam,
                                             IIMAPCallback *pCBHandler,
                                             IRangeList *pMsgRange,
                                             boolean bUIDMsgRange,
                                             LPSTR lpszFetchArgs)
{
    return RangedCommand("FETCH", bUIDMsgRange, pMsgRange, bUIDMsgRange,
        rcNOT_ASTRING_ARG, lpszFetchArgs, icFETCH_COMMAND, wParam, lParam,
        pCBHandler);
} // Fetch



//***************************************************************************
// Function: Store
//
// Purpose:
//   This function issues a STORE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   IRangeList *pMsgRange [in] - range of messages to store. The caller
//     should pass NULL if he is using UIDs and he wants to generate his
//     own message set (in lpszStoreArgs). If the caller is using msg
//     seq nums, this argument MUST be specified to allow this class to
//     resequence the msg nums as required.
//   boolean bUIDRangeList [in] - if TRUE, we prepend "UID" to the STORE command
//   LPSTR lpszStoreArgs - arguments for the STORE command.
//
// Returns:
//   HRESULT indicating success or failure of the send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Store(WPARAM wParam, LPARAM lParam,
                                             IIMAPCallback *pCBHandler,
                                             IRangeList *pMsgRange,
                                             boolean bUIDRangeList,
                                             LPSTR lpszStoreArgs)
{
    return RangedCommand("STORE", bUIDRangeList, pMsgRange, bUIDRangeList,
        rcNOT_ASTRING_ARG, lpszStoreArgs, icSTORE_COMMAND, wParam, lParam,
        pCBHandler);
} // Store



//***************************************************************************
// Function: Copy
//
// Purpose:
//   This function issues a COPY command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   IRangeList *pMsgRange [in] - the range of messages to copy. This
//     argument must be supplied.
//   boolean bUIDRangeList [in] - if TRUE, prepends "UID" to COPY command
//   LPSTR lpszMailboxName [in] - C String of mailbox name
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Copy(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler,
                                            IRangeList *pMsgRange,
                                            boolean bUIDRangeList,
                                            LPSTR lpszMailboxName)
{
    HRESULT hrResult;
    LPSTR pszUTF7MailboxName;
    DWORD dwNumCharsWritten;

    // Initialize variables
    pszUTF7MailboxName = NULL;

    // Convert the mailbox name to modified UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszMailboxName, &pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto exit;

    hrResult = RangedCommand("COPY", bUIDRangeList, pMsgRange, bUIDRangeList,
        rcASTRING_ARG, pszUTF7MailboxName, icCOPY_COMMAND, wParam, lParam,
        pCBHandler);

exit:
    if (NULL != pszUTF7MailboxName)
        MemFree(pszUTF7MailboxName);

    return hrResult;
} // Copy



//***************************************************************************
// Function: Status
//
// Purpose:
//   This function issues a STATUS command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR pszMailboxName [in] - the mailbox which you want to get the
//     STATUS of.
//   LPSTR pszStatusCmdArgs [in] - the arguments for the STATUS command,
//     eg, "(MESSAGES UNSEEN)".
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Status(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR pszMailboxName,
                                              LPSTR pszStatusCmdArgs)
{
    HRESULT hrResult;
    CIMAPCmdInfo *piciCommand;
    char szCommandLine[CMDLINE_BUFSIZE];
    LPSTR p, pszUTF7MailboxName;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != pszMailboxName);
    Assert(NULL != pszStatusCmdArgs);

    // Initialize variables
    pszUTF7MailboxName = NULL;

    // Verify proper server state
    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always TRUE in this case)
    if (ssAuthenticated > m_ssServerState && ssConnecting != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }
    
    piciCommand = new CIMAPCmdInfo(this, icSTATUS_COMMAND, ssAuthenticated,
        wParam, lParam, pCBHandler);

    // Send STATUS command to server, wait for response
    p = szCommandLine;
    p += wsprintf(szCommandLine, "%s %s", piciCommand->szTag, "STATUS");

    // Convert the mailbox name to modified UTF-7
    hrResult = _MultiByteToModifiedUTF7(pszMailboxName, &pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
        sizeof(szCommandLine), pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    // Limited overflow risk: since literal threshold is 128, max buffer usage is
    // 11+128+2+args = 141+~20 = 161
    p += wsprintf(p, " %.300s\r\n", pszStatusCmdArgs);
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, (DWORD) (p - szCommandLine));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (NULL != pszUTF7MailboxName)
        MemFree(pszUTF7MailboxName);

    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // Status



//***************************************************************************
// Function: Noop
//
// Purpose:
//   This function issues a NOOP command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Noop(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler)
{
    return NoArgCommand("NOOP", icNOOP_COMMAND, ssNonAuthenticated,
        wParam, lParam, pCBHandler);
} // Noop



//***************************************************************************
// Function: EnterIdleMode
//
// Purpose:
//   This function issues the IDLE command to the server, if the server
// supports this extension. It should be called when no commands are
// currently begin transmitted (or waiting to be transmitted) and no
// commands are expected back from the server. When the next IMAP command is
// issued, the send machine automatically leaves IDLE mode before issuing
// the IMAP command.
//***************************************************************************
void CImap4Agent::EnterIdleMode(void)
{
    CIMAPCmdInfo *piciIdleCmd;
    HRESULT hrResult;
    char sz[NUM_TAG_CHARS + 7 + 1];
    int i;

    // Check if this server supports IDLE
    if (0 == (m_dwCapabilityFlags & IMAP_CAPABILITY_IDLE))
        return; // Nothing to do here

    // Initialize variables
    hrResult = S_OK;
    piciIdleCmd = NULL;

    piciIdleCmd = new CIMAPCmdInfo(this, icIDLE_COMMAND, ssAuthenticated,
        0, 0, NULL);
    if (NULL == piciIdleCmd) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    i = wsprintf(sz, "%.4s IDLE\r\n", piciIdleCmd->szTag);
    Assert(11 == i);
    hrResult = SendCmdLine(piciIdleCmd, sclAPPEND_TO_END, sz, i);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SendPause(piciIdleCmd);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SendCmdLine(piciIdleCmd, sclAPPEND_TO_END, c_szDONE,
        sizeof(c_szDONE) - 1);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SendStop(piciIdleCmd);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SubmitIMAPCommand(piciIdleCmd);

exit:
    if (FAILED(hrResult)) {
        AssertSz(FALSE, "EnterIdleMode failure");
        if (NULL != piciIdleCmd)
            delete piciIdleCmd;
    }
} // EnterIdleMode



//***************************************************************************
// Function: GenerateMsgSet
//
// Purpose:
//   This function takes an array of message ID's (could be UIDs or Msg
// sequence numbers, this function doesn't care) and converts it to an IMAP
// set (see Formal Syntax in RFC1730). If the given array of message ID's is
// SORTED, this function can coalesce a run of numbers into a range. For
// unsorted arrays, it doesn't bother coalescing the numbers.
//
// Arguments:
//   LPSTR lpszDestination [out] - output buffer for IMAP set. NOTE that the
//    output string deposited here has a leading comma which must be 
//   DWORD dwSizeOfDestination [in] - size of output buffer.
//   DWORD *pMsgID [in] - pointer to an array of message ID's (UIDs or Msg
//     sequence numbers)
//   DWORD cMsgID [in] - the number of message ID's passed in the *pMsgID
//     array.
//
// Returns:
//   DWORD indicating the number of characters written. Adding this value
// to the value of lpszDestination will point to the null-terminator at
// the end of the output string.
//***************************************************************************
DWORD CImap4Agent::GenerateMsgSet(LPSTR lpszDestination,
                                  DWORD dwSizeOfDestination,
                                  DWORD *pMsgID,
                                  DWORD cMsgID)
{
    LPSTR p;
    DWORD dwNumMsgsCopied, idStartOfRange, idEndOfRange;
    DWORD dwNumMsgsInRun; // Used to detect if we are in a run of consecutive nums
    boolean bFirstRange; // TRUE if outputting first msg range in set
    
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszDestination);
    Assert(0 != dwSizeOfDestination);
    Assert(NULL != pMsgID);
    Assert(0 != cMsgID);
    
    // Construct the set of messages to copy
    p = lpszDestination;
    idStartOfRange = *pMsgID;
    dwNumMsgsInRun = 0;
    bFirstRange = TRUE; // Suppress leading comma for first message range in set
    for (dwNumMsgsCopied = 0; dwNumMsgsCopied < cMsgID; dwNumMsgsCopied++ ) {
        if (*pMsgID == idStartOfRange + dwNumMsgsInRun) {
            idEndOfRange = *pMsgID; // Construct a range out of consecutive numbers
            dwNumMsgsInRun += 1;
        }
        else {
            // No more consecutive numbers found, output the range
            AppendMsgRange(&p, idStartOfRange, idEndOfRange, bFirstRange);
            idStartOfRange = *pMsgID;
            idEndOfRange = *pMsgID;
            dwNumMsgsInRun = 1;
            bFirstRange = FALSE; // Turn on leading comma from this point on
        }
        pMsgID += 1;
    } // for    
    // Perform append for last msgID
    AppendMsgRange(&p, idStartOfRange, idEndOfRange, bFirstRange);

    // Check for buffer overflow
    Assert(p < lpszDestination + dwSizeOfDestination);
    //$REVIEW: Make this more ROBUST, so we never actually overflow
    // Pretty tough, with the wsprintf action going on in AppendMsgRange

    return (DWORD) (p - lpszDestination);
} // GenerateMsgSet

    

//***************************************************************************
// Function: AppendMsgRange
//
// Purpose:
//   This function appends a single message range to the given string
// pointer, either in the form ",seq num" or ",seq num:seq num" (NOTE the
// leading comma: this should be suppressed for the first message range in
// the set by setting bSuppressComma to TRUE).
//
// Arguments:
//   LPSTR *ppDest [in/out] - this pointer should always point to the end
//     of the string currently being constructed, although there need not be
//     a null-terminator present. After this function appends its message
//     range to the string, it advances *ppDest by the correct amount.
//     Note that it is the caller's responsibility to perform bounds checking.
//   const DWORD idStartOfRange [in] - the first msg number of the msg range.
//   const DWORD  idEndOfRange [in] - the last msg number of the msg range.
//   const boolean bSuppressComma [in] - TRUE if the leading comma should be
//     suppressed. This is generally TRUE only for the first message range
//     in the set.
//
// Returns:
//   Nothing. Given valid arguments, this function cannot fail.
//***************************************************************************
void CImap4Agent::AppendMsgRange(LPSTR *ppDest, const DWORD idStartOfRange,
                                 const DWORD idEndOfRange, boolean bSuppressComma)
{
    LPSTR lpszComma;
    int numCharsWritten;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppDest);
    Assert(NULL != *ppDest);
    Assert(0 != idStartOfRange); // MSGIDs are never zero in IMAP-land
    Assert(0 != idEndOfRange);


    if (TRUE == bSuppressComma)
        lpszComma = "";
    else
        lpszComma = ",";

    if (idStartOfRange == idEndOfRange)
        // Single message number
        numCharsWritten = wsprintf(*ppDest, "%s%lu", lpszComma, idStartOfRange);
    else
        // Range of consecutive message numbers
        numCharsWritten = wsprintf(*ppDest, "%s%lu:%lu", lpszComma,
            idStartOfRange, idEndOfRange);

    *ppDest += numCharsWritten;
} // AppendMsgRange



//***************************************************************************
// Function: EnqueueFragment
//
// Purpose:
//   This function takes an IMAP_LINE_FRAGMENT and appends it to the end of
// the given IMAP_LINEFRAG_QUEUE.
//
// Arguments:
//   IMAP_LINE_FRAGMENT *pilfSourceFragment [in] - a pointer to the line
//     fragment to enqueue in the given line fragment queue. This can be
//     a single line fragment (with the pilfNextFragment member set to NULL),
//     or a chain of line fragments.
//   IMAP_LINEFRAG_QUEUE *pilqLineFragQueue [in] - a pointer to the line
//     fragment queue which the given line fragment(s) should be appended to.
//
// Returns:
//   Nothing. Given valid arguments, this function cannot fail.
//***************************************************************************
void CImap4Agent::EnqueueFragment(IMAP_LINE_FRAGMENT *pilfSourceFragment,
                                  IMAP_LINEFRAG_QUEUE *pilqLineFragQueue)
{
    IMAP_LINE_FRAGMENT *pilfLast;

    Assert(m_lRefCount > 0);
    Assert(NULL != pilfSourceFragment);
    Assert(NULL != pilqLineFragQueue);

    // Check for empty queue
    pilfSourceFragment->pilfPrevFragment = pilqLineFragQueue->pilfLastFragment;
    if (NULL == pilqLineFragQueue->pilfLastFragment) {
        Assert(NULL == pilqLineFragQueue->pilfFirstFragment); // True test for emptiness
        pilqLineFragQueue->pilfFirstFragment = pilfSourceFragment;
    }
    else
        pilqLineFragQueue->pilfLastFragment->pilfNextFragment = pilfSourceFragment;
        

    // Find end of queue
    pilfLast = pilfSourceFragment;
    while (NULL != pilfLast->pilfNextFragment)
        pilfLast = pilfLast->pilfNextFragment;

    pilqLineFragQueue->pilfLastFragment = pilfLast;
} // EnqueueFragment



//***************************************************************************
// Function: InsertFragmentBeforePause
//
// Purpose:
//   This function inserts the given IMAP line fragment into the given
// linefrag queue, before the first iltPAUSE element that it finds. If no
// iltPAUSE fragment could be found, the line fragment is added to the end.
//
// Arguments:
//   IMAP_LINE_FRAGMENT *pilfSourceFragment [in] - a pointer to the line
//     fragment to insert before the iltPAUSE element in the given line
//     fragment queue. This can be a single line fragment (with the
//     pilfNextFragment member set to NULL), or a chain of line fragments.
//   IMAP_LINEFRAG_QUEUE *pilqLineFragQueue [in] - a pointer to the line
//     fragment queue which contains the iltPAUSE element.
//***************************************************************************
void CImap4Agent::InsertFragmentBeforePause(IMAP_LINE_FRAGMENT *pilfSourceFragment,
                                            IMAP_LINEFRAG_QUEUE *pilqLineFragQueue)
{
    IMAP_LINE_FRAGMENT *pilfInsertionPt, *pilfPause;

    Assert(m_lRefCount > 0);
    Assert(NULL != pilfSourceFragment);
    Assert(NULL != pilqLineFragQueue);

    // Look for the iltPAUSE fragment in the linefrag queue
    pilfInsertionPt = NULL;
    pilfPause = pilqLineFragQueue->pilfFirstFragment;
    while (NULL != pilfPause && iltPAUSE != pilfPause->iltFragmentType) {
        pilfInsertionPt = pilfPause;
        pilfPause = pilfPause->pilfNextFragment;
    }

    if (NULL == pilfPause) {
        // Didn't find iltPAUSE fragment, insert at tail of queue
        AssertSz(FALSE, "Didn't find iltPAUSE fragment! WHADDUP?");
        EnqueueFragment(pilfSourceFragment, pilqLineFragQueue);
    }
    else {
        IMAP_LINE_FRAGMENT *pilfLast;

        // Find the end of the source fragment
        pilfLast = pilfSourceFragment;
        while (NULL != pilfLast->pilfNextFragment)
            pilfLast = pilfLast->pilfNextFragment;

        // Found an iltPAUSE fragment. Insert the line fragment in front of it
        pilfLast->pilfNextFragment = pilfPause;
        Assert(pilfInsertionPt == pilfPause->pilfPrevFragment);
        pilfPause->pilfPrevFragment = pilfLast;
        if (NULL == pilfInsertionPt) {
            // Insert at the head of the linefrag queue
            Assert(pilfPause == pilqLineFragQueue->pilfFirstFragment);
            pilfSourceFragment->pilfPrevFragment = NULL;
            pilqLineFragQueue->pilfFirstFragment = pilfSourceFragment;
        }
        else {
            // Insert in middle of queue
            Assert(pilfPause == pilfInsertionPt->pilfNextFragment);
            pilfSourceFragment->pilfPrevFragment = pilfInsertionPt;
            pilfInsertionPt->pilfNextFragment = pilfSourceFragment;
        }
    }
} // InsertFragmentBeforePause



//***************************************************************************
// Function: DequeueFragment
//
// Purpose:
//   This function returns the next line fragment from the given line
// fragment queue, removing the returned element from the queue.
//
// Arguments:
//   IMAP_LINEFRAG_QUEUE *pilqLineFragQueue [in] - a pointer to the line
//     fragment queue to dequeue from.
//
// Returns:
//   A pointer to an IMAP_LINE_FRAGMENT. If none are available, NULL is
// returned.
//***************************************************************************
IMAP_LINE_FRAGMENT *CImap4Agent::DequeueFragment(IMAP_LINEFRAG_QUEUE *pilqLineFragQueue)
{
    IMAP_LINE_FRAGMENT *pilfResult;

    // Refcount can be 0 if we're destructing CImap4Agent while a cmd is in progress
    Assert(m_lRefCount >= 0);
    Assert(NULL != pilqLineFragQueue);

    // Return element at head of queue, including NULL if empty queue
    pilfResult = pilqLineFragQueue->pilfFirstFragment;

    if (NULL != pilfResult) {
        // Dequeue the element from list
        pilqLineFragQueue->pilfFirstFragment = pilfResult->pilfNextFragment;
        if (NULL == pilqLineFragQueue->pilfFirstFragment)
            // Queue is now empty, so reset ptr to last fragment
            pilqLineFragQueue->pilfLastFragment = NULL;
        else {
            Assert(pilfResult == pilqLineFragQueue->pilfFirstFragment->pilfPrevFragment);
            pilqLineFragQueue->pilfFirstFragment->pilfPrevFragment = NULL;
        }

        pilfResult->pilfNextFragment = NULL;
        pilfResult->pilfPrevFragment = NULL;
    }
    else {
        AssertSz(FALSE, "Someone just tried to dequeue an element from empty queue");
    }

    return pilfResult;
} // DequeueFragment



//***************************************************************************
// Function: FreeFragment
//
// Purpose:
//   This function frees the given IMAP line fragment and the string or
// stream data associated with it.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfFragment [in/out] - a pointer to the line
//     fragment to free. The pointer is set to NULL after the fragment
//     is freed.
//
// Returns:
//   Nothing. Given valid arguments, this function cannot fail.
//***************************************************************************
void CImap4Agent::FreeFragment(IMAP_LINE_FRAGMENT **ppilfFragment)
{
    // Refcount can be 0 if we're destructing CImap4Agent while a cmd is in progress
    Assert(m_lRefCount >= 0);
    Assert(NULL != ppilfFragment);
    Assert(NULL != *ppilfFragment);

    if (iltRANGELIST == (*ppilfFragment)->iltFragmentType) {
        (*ppilfFragment)->data.prlRangeList->Release();
    }
    else if (ilsSTREAM == (*ppilfFragment)->ilsLiteralStoreType) {
        Assert(iltLITERAL == (*ppilfFragment)->iltFragmentType);
        (*ppilfFragment)->data.pstmSource->Release();
    }
    else {
        Assert(ilsSTRING == (*ppilfFragment)->ilsLiteralStoreType);
        SafeMemFree((*ppilfFragment)->data.pszSource);
    }

    delete *ppilfFragment;
    *ppilfFragment = NULL;
} // FreeFragment



//***************************************************************************
// Function: SubmitIMAPCommand
//
// Purpose:
//   This function takes a completed CIMAPCmdInfo structure (with completed
// command line) and submits it for transmittal to the IMAP server.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - this is the completed CIMAPCmdInfo
//     structure to transmit to the IMAP server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SubmitIMAPCommand(CIMAPCmdInfo *piciCommand)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);

    // SubmitIMAPCommand is used to send all commands to the IMAP server.
    // This is a good time to clear m_szLastResponseText
    *m_szLastResponseText = '\0';

    // If currently transmitted command is a paused IDLE command, unpause us
    if (m_fIDLE && NULL != m_piciCmdInSending &&
        icIDLE_COMMAND == m_piciCmdInSending->icCommandID &&
        iltPAUSE == m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment->iltFragmentType)
        ProcessSendQueue(iseUNPAUSE);

    // Enqueue the command into the send queue
    EnterCriticalSection(&m_csSendQueue);
    if (NULL == m_piciSendQueue)
        // Insert command into empty queue
        m_piciSendQueue = piciCommand;
    else {
        CIMAPCmdInfo *pici;
    
        // Find the end of the send queue
        pici = m_piciSendQueue;
        while (NULL != pici->piciNextCommand)
            pici = pici->piciNextCommand;

        pici->piciNextCommand = piciCommand;
    }
    LeaveCriticalSection(&m_csSendQueue);

    // Command is queued: kickstart its send process
    ProcessSendQueue(iseSEND_COMMAND);

    return S_OK;
} // SubmitIMAPCommand



//***************************************************************************
// Function: DequeueCommand
//
// Purpose:
//   This function removes the command currently being sent from the send
// queue and returns a pointer to it.
//
// Returns:
//   Pointer to CIMAPCmdInfo object if successful, otherwise NULL.
//***************************************************************************
CIMAPCmdInfo *CImap4Agent::DequeueCommand(void)
{
    CIMAPCmdInfo *piciResult;

    Assert(m_lRefCount > 0);

    EnterCriticalSection(&m_csSendQueue);
    piciResult = m_piciCmdInSending;
    m_piciCmdInSending = NULL;
    if (NULL != piciResult) {
        CIMAPCmdInfo *piciCurrent, *piciPrev;

        // Find the command in sending in the send queue
        piciCurrent = m_piciSendQueue;
        piciPrev = NULL;
        while (NULL != piciCurrent) {
            if (piciCurrent == piciResult)
                break; // Found the current command in sending
            
            piciPrev = piciCurrent;
            piciCurrent = piciCurrent->piciNextCommand;
        }

        // Unlink the command from the send queue
        if (NULL == piciPrev)
            // Unlink command from the head of the send queue
            m_piciSendQueue = m_piciSendQueue->piciNextCommand;
        else if (NULL != piciCurrent)
            // Unlink command from the middle/end of the queue
            piciPrev->piciNextCommand = piciCurrent->piciNextCommand;
    }

    LeaveCriticalSection(&m_csSendQueue);
    return piciResult;
} // DequeueCommand



//***************************************************************************
// Function: AddPendingCommand
//
// Purpose:
//   This function adds the given CIMAPCmdInfo object to the list of commands
// pending server responses.
//
// Arguments:
//   CIMAPCmdInfo *piciNewCommand [in] - pointer to command to add to list.
//***************************************************************************
void CImap4Agent::AddPendingCommand(CIMAPCmdInfo *piciNewCommand)
{
    Assert(m_lRefCount > 0);
    
    // Just insert at the head of the list
    EnterCriticalSection(&m_csPendingList);
    piciNewCommand->piciNextCommand = m_piciPendingList;
    m_piciPendingList = piciNewCommand;
    LeaveCriticalSection(&m_csPendingList);
} // AddPendingCommand



//***************************************************************************
// Function: RemovePendingCommand
//
// Purpose:
//   This function looks for a command in the pending command list which
// matches the given tag. If found, it unlinks the CIMAPCmdInfo object from
// the list and returns a pointer to it.
//
// Arguments:
//   LPSTR pszTag [in] - the tag of the command which should be removed.
//
// Returns:
//   Pointer to CIMAPCmdInfo object if successful, otherwise NULL.
//***************************************************************************
CIMAPCmdInfo *CImap4Agent::RemovePendingCommand(LPSTR pszTag)
{
    CIMAPCmdInfo *piciPrev, *piciCurrent;
    boolean bFoundMatch;
    boolean fLeaveBusy = FALSE;

    Assert(m_lRefCount > 0);
    Assert(NULL != pszTag);

    EnterCriticalSection(&m_csPendingList);

    // Look for matching tag in pending command list
    bFoundMatch = FALSE;
    piciPrev = NULL;
    piciCurrent = m_piciPendingList;
    while (NULL != piciCurrent) {
        if (0 == lstrcmp(pszTag, piciCurrent->szTag)) {
            bFoundMatch = TRUE;
            break;
        }

        // Advance ptrs
        piciPrev = piciCurrent;
        piciCurrent = piciCurrent->piciNextCommand;
    }

    if (FALSE == bFoundMatch)
        goto exit;

    // OK, we found the matching command. Unlink it from list
    if (NULL == piciPrev)
        // Unlink first element in pending list
        m_piciPendingList = piciCurrent->piciNextCommand;
    else
        // Unlink element from middle/end of list
        piciPrev->piciNextCommand = piciCurrent->piciNextCommand;

    // If we have removed the last pending command and no commands are being
    // transmitted, it's time to leave the busy section
    if (NULL == m_piciPendingList && NULL == m_piciCmdInSending)
        fLeaveBusy = TRUE;

exit:
    LeaveCriticalSection(&m_csPendingList);

    // Now we're out of &m_csPendingList, call LeaveBusy (needs m_cs). Avoids deadlock.
    if (fLeaveBusy)
        LeaveBusy(); // Typically not needed, anymore

    if (NULL != piciCurrent)
        piciCurrent->piciNextCommand = NULL;

    return piciCurrent;
} // RemovePendingCommand



//***************************************************************************
// Function: GetTransactionID
//
// Purpose:
//   This function maps an IMAP_RESPONSE_ID to a transaction ID. This function
// takes the given IMAP_RESPONSE_ID and compares it with the IMAP command(s)
// currently pending a response. If the given response matches ONE (and only
// one) of the pending IMAP commands, then the transaction ID of that IMAP
// command is returned. If none or more than one match the given response,
// or if the response in general is unsolicited, then a value of 0 is
// returned.
//
// Arguments:
//   WPARAM *pwParam [out] - the wParam for the given response. If conflicts
//     could not be resolved, then a value of 0 is returned.
//   LPARAM *plParam [out] - the lParam for the given response. If conflicts
//     could not be resolved, then a value of 0 is returned.
//   IIMAPCallback **ppCBHandler [out] - the CB Handler for a given response.
//     If conflicts could not be resolved, or if a NULL CB Handler was
//     specified for the associated command, the default CB handler is returned.
//   IMAP_RESPONSE_ID irResponseType [in] - the response type for which the
//     wants a transaction ID.
//***************************************************************************
void CImap4Agent::GetTransactionID(WPARAM *pwParam, LPARAM *plParam,
                                   IIMAPCallback **ppCBHandler,
                                   IMAP_RESPONSE_ID irResponseType)
{
    WPARAM wParam;
    LPARAM lParam;
    IIMAPCallback *pCBHandler;

    Assert(m_lRefCount > 0);
    
    wParam = 0;
    lParam = 0;
    pCBHandler = m_pCBHandler;
    switch (irResponseType) { 
        // The following responses are ALWAYS expected, regardless of cmd
        case irOK_RESPONSE:
        case irNO_RESPONSE:
        case irBAD_RESPONSE:
        case irNONE: // Usually indicates parsing error (reported via ErrorNotification CB)
            FindTransactionID(&wParam, &lParam, &pCBHandler, icALL_COMMANDS);
            break; // Always treat as solicited, so caller can associate with cmd


        // The following responses are always unsolicited, either because
        // they really ARE always unsolicited, or we don't care, or we want
        // to encourage the client to expect a given response at all times
        case irALERT_RESPONSECODE:    // Clearly unsolicited
        case irPARSE_RESPONSECODE:    // Clearly unsolicited
        case irPREAUTH_RESPONSE:      // Clearly unsolicited
        case irEXPUNGE_RESPONSE:      // Client can get this any time, so get used to it
        case irCMD_CONTINUATION:      // No callback involved, don't care
        case irBYE_RESPONSE:          // Can happen at any time
        case irEXISTS_RESPONSE:       // Client can get this any time, so get used to it
        case irRECENT_RESPONSE:       // Client can get this any time, so get used to it
        case irUNSEEN_RESPONSECODE:   // Client can get this any time, so get used to it
        case irSTATUS_RESPONSE:
            break; // Always treated as unsolicited


        // The following response types are considered solicited only for
        // certain commands. Otherwise, they're unsolicited.
        case irFLAGS_RESPONSE:
        case irPERMANENTFLAGS_RESPONSECODE:
        case irREADWRITE_RESPONSECODE:
        case irREADONLY_RESPONSECODE:
        case irUIDVALIDITY_RESPONSECODE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icSELECT_COMMAND, icEXAMINE_COMMAND);
            break; // case irFLAGS_RESPONSE

        case irCAPABILITY_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icCAPABILITY_COMMAND);
            break; // case irCAPABILITY_RESPONSE

        case irLIST_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icLIST_COMMAND);
            break; // case irLIST_RESPONSE

        case irLSUB_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icLSUB_COMMAND);
            break; // case irLSUB_RESPONSE

        case irSEARCH_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icSEARCH_COMMAND);
            break; // case irSEARCH_RESPONSE
        
        case irFETCH_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icFETCH_COMMAND, icSTORE_COMMAND);
            break; // case irFETCH_RESPONSE

        case irTRYCREATE_RESPONSECODE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icAPPEND_COMMAND, icCOPY_COMMAND);
            break; // case irTRYCREATE_RESPONSECODE

            
        default:
            Assert(FALSE);
            break; // default case
    } // switch (irResponseType)

    *pwParam = wParam;
    *plParam = lParam;
    *ppCBHandler = pCBHandler;
} // GetTransactionID



//***************************************************************************
// Function: FindTransactionID
//
// Purpose:
//   This function traverses the pending command list searching for commands
// which match the command types specified in the arguments. If ONE (and only
// one) match is found, then its transaction ID is returne. If none or more
// than one match is found, then a transaction ID of 0 is returned.
//
// Arguments:
//   WPARAM *pwParam [out] - the wParam for the given commands. If conflicts
//     could not be resolved, then a value of 0 is returned. Pass NULL if
//     you are not interested in this value.
//   LPARAM *plParam [out] - the lParam for the given commands. If conflicts
//     could not be resolved, then a value of 0 is returned. Pass NULL if
//     you are not interested in this value.
//   IIMAPCallback **ppCBHandler [out] - the CB Handler for a given response.
//     If conflicts could not be resolved, or if a NULL CB Handler was
//     specified for the associated command, the default CB handler is returned.
//     Pass NULL if you are not interested in this value.
//   IMAP_COMMAND icTarget1 [in] - one of the commands we're looking for in
//     the pending command queue.
//   IMAP_COMMAND icTarget2 [in] - another command we're looking for in
//     the pending command queue.
//
// Returns:
//   0 if no matches were found
//   1 if exactly one match was found
//   2 if two matches was found. Note that there may be MORE than two matches
//     in the pending list. This function gives up after it finds two matches.
//***************************************************************************
WORD CImap4Agent::FindTransactionID (WPARAM *pwParam, LPARAM *plParam,
                                     IIMAPCallback **ppCBHandler,
                                     IMAP_COMMAND icTarget1, IMAP_COMMAND icTarget2)
{
    CIMAPCmdInfo *piciCurrentCmd;
    WPARAM wParam;
    LPARAM lParam;
    IIMAPCallback *pCBHandler;
    WORD wNumberOfMatches;
    boolean bMatchAllCmds;

    Assert(m_lRefCount > 0);

    if (icALL_COMMANDS == icTarget1 ||
        icALL_COMMANDS == icTarget2)
        bMatchAllCmds = TRUE;
    else
        bMatchAllCmds = FALSE;

    wNumberOfMatches = 0;
    wParam = 0;
    lParam = 0;
    pCBHandler = m_pCBHandler;
    EnterCriticalSection(&m_csPendingList);
    piciCurrentCmd = m_piciPendingList;
    while (NULL != piciCurrentCmd) {
        if (bMatchAllCmds ||
            icTarget1 == piciCurrentCmd->icCommandID ||
            icTarget2 == piciCurrentCmd->icCommandID) {
            wParam = piciCurrentCmd->wParam;
            lParam = piciCurrentCmd->lParam;
            pCBHandler = piciCurrentCmd->pCBHandler;

            wNumberOfMatches += 1;
        }

        if (wNumberOfMatches > 1) {
            wParam = 0;
            lParam = 0;
            pCBHandler = m_pCBHandler; // Found more than one match, can't resolve transaction ID
            break;
        }

        piciCurrentCmd = piciCurrentCmd->piciNextCommand;
    }

    LeaveCriticalSection(&m_csPendingList);
    if (NULL != pwParam)
        *pwParam = wParam;
    if (NULL != plParam)
        *plParam = lParam;
    if (NULL != ppCBHandler)
        *ppCBHandler = pCBHandler;

    return wNumberOfMatches;
} // FindTransactionID



//===========================================================================
// Message Sequence Number to UID Conversion Code
//===========================================================================
//***************************************************************************
// Function: NewIRangeList
//
// Purpose:
//   This function returns a pointer to an IRangeList. Its purpose is to
// allow full functionality from an IIMAPTransport pointer without needing
// to resort to CoCreateInstance to get an IRangeList.
//
// Arguments:
//   IRangeList **pprlNewRangeList [out] - if successful, the function
//      returns a pointer to the new IRangeList.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::NewIRangeList(IRangeList **pprlNewRangeList)
{
    if (NULL == pprlNewRangeList)
        return E_INVALIDARG;

    *pprlNewRangeList = (IRangeList *) new CRangeList;
    if (NULL == *pprlNewRangeList)
        return E_OUTOFMEMORY;

    return S_OK;
} // NewIRangeList



//***************************************************************************
// Function: OnIMAPError
//
// Purpose:
//   This function calls ITransportCallback::OnError with the given info.
//
// Arguments:
//   HRESULT hrResult [in] - the error code to use for IXPRESULT::hrResult.
//   LPSTR pszFailureText [in] - a text string describing the failure. This
//     is duplicated for IXPRESULT::pszProblem.
//   BOOL bIncludeLastResponse [in] - if TRUE, this function duplicates
//     the contents of m_szLastResponseText into IXPRESULT::pszResponse.
//     If FALSE, IXPRESULT::pszResponse is left blank. Generally,
//     m_szLastResponseText holds valid information only for errors which
//     occur during the receipt of an IMAP response. Transmit errors should
//     set this argument to FALSE.
//   LPSTR pszDetails [in] - if bIncludeLastResponse is FALSE, the caller
//     may pass a string to place into IXPRESULT::pszResponse here. If none
//     is desired, the user should pass NULL.
//***************************************************************************
void CImap4Agent::OnIMAPError(HRESULT hrResult, LPSTR pszFailureText,
                              BOOL bIncludeLastResponse, LPSTR pszDetails)
{
    IXPRESULT rIxpResult;

    if (NULL == m_pCallback)
        return; // We can't do a damned thing (this can happen due to HandsOffCallback)

	// Save current state
    rIxpResult.hrResult = hrResult;

    if (bIncludeLastResponse) {
        AssertSz(NULL == pszDetails, "Can't have it both ways, buddy!");
        rIxpResult.pszResponse = PszDupA(m_szLastResponseText);        
    }
    else
        rIxpResult.pszResponse = PszDupA(pszDetails);

    rIxpResult.uiServerError = 0;
    rIxpResult.hrServerError = S_OK;
    rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rIxpResult.pszProblem = PszDupA(pszFailureText);

    // Suspend watchdog during callback
    LeaveBusy();

    // Log it
    if (m_pLogFile) {
        int iLengthOfSz;
        char sz[64];
        LPSTR pszErrorText;
        CByteStream bstmErrLog;

        // wsprintf is limited to an output of 1024 bytes. Use a stream.
        bstmErrLog.Write("ERROR: \"", 8, NULL); // Ignore IStream::Write errors
        bstmErrLog.Write(pszFailureText, lstrlen(pszFailureText), NULL);
        if (bIncludeLastResponse || NULL == pszDetails)
            iLengthOfSz = wsprintf(sz, "\", hr=0x%lX", hrResult);
        else {
            bstmErrLog.Write("\" (", 3, NULL);
            bstmErrLog.Write(pszDetails, lstrlen(pszDetails), NULL);
            iLengthOfSz = wsprintf(sz, "), hr=0x%lX", hrResult);
        }
        bstmErrLog.Write(sz, iLengthOfSz, NULL);

        if (SUCCEEDED(bstmErrLog.HrAcquireStringA(NULL, &pszErrorText, ACQ_COPY)))
            m_pLogFile->WriteLog(LOGFILE_DB, pszErrorText);
    }

    // Give to callback
    m_pCallback->OnError(m_status, &rIxpResult, THIS_IInternetTransport);

    // Restore the watchdog if required
    if (FALSE == m_fBusy &&
        (NULL != m_piciPendingList || (NULL != m_piciCmdInSending &&
        icIDLE_COMMAND != m_piciCmdInSending->icCommandID))) {
        hrResult = HrEnterBusy();
        Assert(SUCCEEDED(hrResult));
    }

    // Free duplicated strings
    SafeMemFree(rIxpResult.pszResponse);
    SafeMemFree(rIxpResult.pszProblem);
} // OnIMAPError



//***************************************************************************
// Function: HandsOffCallback
//
// Purpose:
//   This function guarantees that the default callback handler will not be
// called from this point on, even if it has commands in the air. The pointer
// to the default CB handler is released and removed from all commands in
// the air and from the default CB handler module variable. NOTE that non-
// default CB handlers are not affected by this call.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::HandsOffCallback(void)
{
    CIMAPCmdInfo *pCurrentCmd;

    // Check current status
    if (NULL == m_pCBHandler) {
        Assert(NULL == m_pCallback);
        return S_OK; // We're already done
    }

    // Remove default CB handler from all cmds in send queue
    // NB: No need to deal with m_piciCmdInSending, since it points into this queue
    pCurrentCmd = m_piciSendQueue;
    while (NULL != pCurrentCmd) {
        if (pCurrentCmd->pCBHandler == m_pCBHandler) {
            pCurrentCmd->pCBHandler->Release();
            pCurrentCmd->pCBHandler = NULL;
        }

        pCurrentCmd = pCurrentCmd->piciNextCommand;
    }

    // Remove default CB handler from all cmds in pending command queue
    pCurrentCmd = m_piciPendingList;
    while (NULL != pCurrentCmd) {
        if (pCurrentCmd->pCBHandler == m_pCBHandler) {
            pCurrentCmd->pCBHandler->Release();
            pCurrentCmd->pCBHandler = NULL;
        }

        pCurrentCmd = pCurrentCmd->piciNextCommand;
    }

    // Remove default CB handler from CImap4Agent and CIxpBase module vars
    m_pCBHandler->Release();
    m_pCBHandler = NULL;

    m_pCallback->Release();
    m_pCallback = NULL;
    return S_OK;
} // HandsOffCallback



//***************************************************************************
// Function: FreeAllData
//
// Purpose:
//   This function deallocates the send and receive queues, the
// MsgSeqNumToUID table, and the authentication mechanism list.
//
// Arguments:
//   HRESULT hrTerminatedCmdResult [in] - if a command is found in the send
//     or pending queue, we must issue a cmd completion notification. This
//     argument tells us what hrResult to return. It must indicate FAILURE.
//***************************************************************************
void CImap4Agent::FreeAllData(HRESULT hrTerminatedCmdResult)
{
    Assert(FAILED(hrTerminatedCmdResult)); // If cmds pending, we FAILED
    char szBuf[MAX_RESOURCESTRING];

    FreeAuthStatus();

    // Clean up the receive queue
    if (NULL != m_ilqRecvQueue.pilfFirstFragment) {
        DWORD dwMsgSeqNum;

        // If receive queue holds a FETCH response, and if the client has stored
        // non-NULL cookies in m_fbpFetchBodyPartInProgress, notify caller that it's over
        if (isFetchResponse(&m_ilqRecvQueue, &dwMsgSeqNum) &&
            (NULL != m_fbpFetchBodyPartInProgress.lpFetchCookie1 ||
             NULL != m_fbpFetchBodyPartInProgress.lpFetchCookie2)) {
            FETCH_CMD_RESULTS_EX fetchResults;
            IMAP_RESPONSE irIMAPResponse;

            ZeroMemory(&fetchResults, sizeof(fetchResults));
            fetchResults.dwMsgSeqNum = dwMsgSeqNum;
            fetchResults.lpFetchCookie1 = m_fbpFetchBodyPartInProgress.lpFetchCookie1;
            fetchResults.lpFetchCookie2 = m_fbpFetchBodyPartInProgress.lpFetchCookie2;

            irIMAPResponse.wParam = 0;
            irIMAPResponse.lParam = 0;    
            irIMAPResponse.hrResult = hrTerminatedCmdResult;
            irIMAPResponse.lpszResponseText = NULL; // Not relevant

            if (IMAP_FETCHEX_ENABLE & m_dwFetchFlags)
            {
                irIMAPResponse.irtResponseType = irtUPDATE_MSG_EX;
                irIMAPResponse.irdResponseData.pFetchResultsEx = &fetchResults;
            }
            else
            {
                FETCH_CMD_RESULTS   fcrOldFetchStruct;

                DowngradeFetchResponse(&fcrOldFetchStruct, &fetchResults);
                irIMAPResponse.irtResponseType = irtUPDATE_MSG;
                irIMAPResponse.irdResponseData.pFetchResults = &fcrOldFetchStruct;
            }
            OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
        }

        while (NULL != m_ilqRecvQueue.pilfFirstFragment) {
            IMAP_LINE_FRAGMENT *pilf;

            pilf = DequeueFragment(&m_ilqRecvQueue);
            FreeFragment(&pilf);
        } // while
    } // if (receive queue not empty)

    // To avoid deadlock, whenever we need to enter more than one CS, we must request
    // them in the order specified in the CImap4Agent class definition. Any calls to
    // OnIMAPResponse will require CIxpBase::m_cs, so enter that CS now.
    EnterCriticalSection(&m_cs);

    // Clean up the send queue
    EnterCriticalSection(&m_csSendQueue);
    m_piciCmdInSending = NULL; // No need to delete obj, it points into m_piciSendQueue
    while (NULL != m_piciSendQueue) {
        CIMAPCmdInfo *piciDeletedCmd;

        // Dequeue next command in send queue
        piciDeletedCmd = m_piciSendQueue;
        m_piciSendQueue = piciDeletedCmd->piciNextCommand;

        // Send notification except for non-user-initiated IMAP commands
        if (icIDLE_COMMAND != piciDeletedCmd->icCommandID &&
            icCAPABILITY_COMMAND != piciDeletedCmd->icCommandID &&
            icLOGIN_COMMAND != piciDeletedCmd->icCommandID &&
            icAUTHENTICATE_COMMAND != piciDeletedCmd->icCommandID) {
            IMAP_RESPONSE irIMAPResponse;

            // Notify caller that his command could not be completed
            LoadString(g_hLocRes, idsIMAPCmdNotSent, szBuf, ARRAYSIZE(szBuf));
            irIMAPResponse.wParam = piciDeletedCmd->wParam;
            irIMAPResponse.lParam = piciDeletedCmd->lParam;
            irIMAPResponse.hrResult = hrTerminatedCmdResult;
            irIMAPResponse.lpszResponseText = szBuf;
            irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
            OnIMAPResponse(piciDeletedCmd->pCBHandler, &irIMAPResponse);
        }
        
        delete piciDeletedCmd;
    } // while (NULL != m_piciSendQueue)
    LeaveCriticalSection(&m_csSendQueue);

    // Clean up the pending command queue
    EnterCriticalSection(&m_csPendingList);
    while (NULL != m_piciPendingList) {
        CIMAPCmdInfo *piciDeletedCmd;
        IMAP_RESPONSE irIMAPResponse;

        piciDeletedCmd = m_piciPendingList;
        m_piciPendingList = piciDeletedCmd->piciNextCommand;

        // Send notification except for non-user-initiated IMAP commands
        if (icIDLE_COMMAND != piciDeletedCmd->icCommandID &&
            icCAPABILITY_COMMAND != piciDeletedCmd->icCommandID &&
            icLOGIN_COMMAND != piciDeletedCmd->icCommandID &&
            icAUTHENTICATE_COMMAND != piciDeletedCmd->icCommandID) {
            IMAP_RESPONSE irIMAPResponse;

            // Notify caller that his command could not be completed
            LoadString(g_hLocRes, idsIMAPCmdStillPending, szBuf, ARRAYSIZE(szBuf));
            irIMAPResponse.wParam = piciDeletedCmd->wParam;
            irIMAPResponse.lParam = piciDeletedCmd->lParam;
            irIMAPResponse.hrResult = hrTerminatedCmdResult;
            irIMAPResponse.lpszResponseText = szBuf;
            irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
            OnIMAPResponse(piciDeletedCmd->pCBHandler, &irIMAPResponse);
        }

        delete piciDeletedCmd;
    } // while (NULL != m_piciPendingList)
    LeaveCriticalSection(&m_csPendingList);

    LeaveCriticalSection(&m_cs);

    // Any literals in progress?
    if (NULL != m_pilfLiteralInProgress) {
        m_dwLiteralInProgressBytesLeft = 0;
        FreeFragment(&m_pilfLiteralInProgress);
    }

    // Any fetch body parts in progress?
    if (NULL != m_fbpFetchBodyPartInProgress.pszBodyTag)
        MemFree(m_fbpFetchBodyPartInProgress.pszBodyTag);

    m_fbpFetchBodyPartInProgress = FetchBodyPart_INIT; // So we don't try to free pszBodyTag twice

    // Free MsgSeqNumToUID table
    ResetMsgSeqNumToUID();
} // FreeAllData



//***************************************************************************
// Function: FreeAuthStatus
//
// Purpose:
//   This function frees the data allocated during the course of an
// authentication (all of which is stored in m_asAuthStatus).
//***************************************************************************
void CImap4Agent::FreeAuthStatus(void)
{
    int i;
    
    // Drop the authentication mechanism list
    for (i=0; i < m_asAuthStatus.iNumAuthTokens; i++) {
        if (NULL != m_asAuthStatus.rgpszAuthTokens[i]) {
            MemFree(m_asAuthStatus.rgpszAuthTokens[i]);
            m_asAuthStatus.rgpszAuthTokens[i] = NULL;
        }
    }
    m_asAuthStatus.iNumAuthTokens = 0;

    // Free up Sicily stuff
    SSPIFreeContext(&m_asAuthStatus.rSicInfo);
    if (NULL != m_asAuthStatus.pPackages && 0 != m_asAuthStatus.cPackages)
        SSPIFreePackages(&m_asAuthStatus.pPackages, m_asAuthStatus.cPackages);

    m_asAuthStatus = AuthStatus_INIT;
} // FreeAuthStatus



//===========================================================================
// CIMAPCmdInfo Class
//===========================================================================
// This class contains information about an IMAP command, such as a queue
// of line fragments which constitute the actual command, the tag of the
// command, and the transaction ID used to identify the command to the
// CImap4Agent user.

//***************************************************************************
// Function: CIMAPCmdInfo (Constructor)
//    NOTE that this function deviates from convention in that its public
// module variables are NOT prefixed with a "m_". This was done to make
// access to its public module variables more readable.
//***************************************************************************
CIMAPCmdInfo::CIMAPCmdInfo(CImap4Agent *pImap4Agent,
                           IMAP_COMMAND icCmd, SERVERSTATE ssMinimumStateArg,
                           WPARAM wParamArg, LPARAM lParamArg,
                           IIMAPCallback *pCBHandlerArg)
{
    Assert(NULL != pImap4Agent);
    Assert(icNO_COMMAND != icCmd);

    // Set module (that's right, module) variables
    icCommandID = icCmd;
    ssMinimumState = ssMinimumStateArg;
    wParam = wParamArg;
    lParam = lParamArg;

    // Set ptr to CB Handler - if argument is NULL, substitute default CB handler
    if (NULL != pCBHandlerArg)
        pCBHandler = pCBHandlerArg;
    else
        pCBHandler = pImap4Agent->m_pCBHandler;

    Assert(NULL != pCBHandler)
    if (NULL != pCBHandler)
        pCBHandler->AddRef();

    // No AddRef() necessary, since CImap4Agent is our sole user. When they
    // go, we go, and so does our pointer.
    m_pImap4Agent = pImap4Agent;

    pImap4Agent->GenerateCommandTag(szTag);
    pilqCmdLineQueue = new IMAP_LINEFRAG_QUEUE;
    *pilqCmdLineQueue = ImapLinefragQueue_INIT;

    fUIDRangeList = FALSE;
    piciNextCommand = NULL;
} // CIMAPCmdInfo



//***************************************************************************
// Function: ~CIMAPCmdInfo (Destructor)
//***************************************************************************
CIMAPCmdInfo::~CIMAPCmdInfo(void)
{
    // Flush any unsent items from the command line queue
    while (NULL != pilqCmdLineQueue->pilfFirstFragment) {
        IMAP_LINE_FRAGMENT *pilf;

        pilf = m_pImap4Agent->DequeueFragment(pilqCmdLineQueue);
        m_pImap4Agent->FreeFragment(&pilf);
    }
    delete pilqCmdLineQueue;

    if (NULL != pCBHandler)
        pCBHandler->Release();
} // ~CIMAPCmdInfo



//===========================================================================
// Message Sequence Number to UID Conversion Code
//===========================================================================
//***************************************************************************
// Function: ResizeMsgSeqNumTable
//
// Purpose:
//   This function is called whenever we receive an EXISTS response. It
// resizes the MsgSeqNumToUID table to match the current size of the mailbox.
//
// Arguments:
//   DWORD dwSizeOfMbox [in] - the number returned via the EXISTS response.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ResizeMsgSeqNumTable(DWORD dwSizeOfMbox)
{
    BOOL bResult;

    Assert(m_lRefCount > 0);

    if (dwSizeOfMbox == m_dwSizeOfMsgSeqNumToUID)
        return S_OK; // Nothing to do, table is already of correct size

    // Check for the case where EXISTS reports new mailbox size before we
    // receive the EXPUNGE cmds to notify us of deletions
    if (dwSizeOfMbox < m_dwHighestMsgSeqNum) {
        // Bad, bad server! (Although not strictly prohibited)
        AssertSz(FALSE, "Received EXISTS before EXPUNGE commands! Check your server.");
        return S_OK; // We only resize after all EXPUNGE responses have been received,
                     // since we don't know who to delete and since the svr expects us to
                     // use OLD msg seq nums until it can update us with EXPUNGE responses
                     // Return S_OK since this is non-fatal.
    }

    // Check for the case where the mailbox has become empty (MemRealloc's not as flex as realloc)
    if (0 == dwSizeOfMbox) {
        ResetMsgSeqNumToUID();
        return S_OK;
    }

    // Resize the table
    bResult = MemRealloc((void **)&m_pdwMsgSeqNumToUID, dwSizeOfMbox * sizeof(DWORD));
    if (FALSE == bResult) {
        char szTemp[MAX_RESOURCESTRING];

        // Report out-of-memory error
        LoadString(g_hLocRes, idsMemory, szTemp, sizeof(szTemp));
        OnIMAPError(E_OUTOFMEMORY, szTemp, DONT_USE_LAST_RESPONSE);
        ResetMsgSeqNumToUID();
        return E_OUTOFMEMORY;
    }
    else {
        LONG lSizeOfUninitMemory;

        // Zero any memory above m_dwHighestMsgSeqNum element to end of array
        lSizeOfUninitMemory = (dwSizeOfMbox - m_dwHighestMsgSeqNum) * sizeof(DWORD);
        if (0 < lSizeOfUninitMemory)
            ZeroMemory(m_pdwMsgSeqNumToUID + m_dwHighestMsgSeqNum, lSizeOfUninitMemory);

        m_dwSizeOfMsgSeqNumToUID = dwSizeOfMbox;
    }

    // Make sure we never shrink the table smaller than highest msg seq num
    Assert(m_dwHighestMsgSeqNum <= m_dwSizeOfMsgSeqNumToUID);
    return S_OK;
} // ResizeMsgSeqNumTable



//***************************************************************************
// Function: UpdateSeqNumToUID
//
// Purpose:
//   This function is called whenever we receive a FETCH response which has
// both a message sequence number and a UID number. It updates the
// MsgSeqNumToUID table so that given msg seq number maps to the given UID.
//
// Arguments:
//   DWORD dwMsgSeqNum [in] - the message sequence number of the FETCH
//     response.
//   DWORD dwUID [in] - the UID of the given message sequence number.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::UpdateSeqNumToUID(DWORD dwMsgSeqNum, DWORD dwUID)
{
    Assert(m_lRefCount > 0);

    // Check args
    if (0 == dwMsgSeqNum || 0 == dwUID) {
        AssertSz(FALSE, "Zero is not an acceptable number for a msg seq num or UID.");
        return E_INVALIDARG;
    }

    // Check if we have a table
    if (NULL == m_pdwMsgSeqNumToUID) {
        // This could mean programmer error, or server never gave us EXISTS
        DOUT("You're trying to update a non-existent MsgSeqNumToUID table.");
    }

    // We cannot check against m_dwHighestMsgSeqNum, because we update that
    // variable at the end of this function! The second-best thing to do is
    // to verify that we lie within m_dwSizeOfMsgSeqNum.
    if (dwMsgSeqNum > m_dwSizeOfMsgSeqNumToUID || NULL == m_pdwMsgSeqNumToUID) {
        HRESULT hrResult;

        DOUT("Msg seq num out of range! Could be server bug, or out of memory.");
        hrResult = ResizeMsgSeqNumTable(dwMsgSeqNum); // Do the robust thing: resize our table
        if(FAILED(hrResult))
            return hrResult;
    }

    // Check for screwups
    // First check if a UID has been changed
    if (0 != m_pdwMsgSeqNumToUID[dwMsgSeqNum-1] &&
        m_pdwMsgSeqNumToUID[dwMsgSeqNum-1] != dwUID) {
        char szTemp[MAX_RESOURCESTRING];
        char szDetails[MAX_RESOURCESTRING];

        wsprintf(szDetails, "MsgSeqNum %lu: Previous UID: %lu, New UID: %lu.",
            dwMsgSeqNum, m_pdwMsgSeqNumToUID[dwMsgSeqNum-1], dwUID);
        LoadString(g_hLocRes, idsIMAPUIDChanged, szTemp, sizeof(szTemp));
        OnIMAPError(IXP_E_IMAP_CHANGEDUID, szTemp, DONT_USE_LAST_RESPONSE, szDetails);
        // In this case, we'll still return S_OK, but user will know of problem
    }

    // Next, verify that this UID is strictly ascending: this UID should be
    // strictly greater than previous UID, and stricly less than succeeding UID
    // Succeeding UID can be 0 (indicates it's uninitialized)
    if (1 != dwMsgSeqNum && m_pdwMsgSeqNumToUID[dwMsgSeqNum-2] >= dwUID || // Check UID below
        dwMsgSeqNum < m_dwSizeOfMsgSeqNumToUID &&                         // Check UID above
        0 != m_pdwMsgSeqNumToUID[dwMsgSeqNum] &&
        m_pdwMsgSeqNumToUID[dwMsgSeqNum] <= dwUID) {
        char szTemp[MAX_RESOURCESTRING];
        char szDetails[MAX_RESOURCESTRING];

        wsprintf(szDetails, "MsgSeqNum %lu, New UID %lu. Prev UID: %lu, Next UID: %lu.",
            dwMsgSeqNum, dwUID, 1 == dwMsgSeqNum ? 0 : m_pdwMsgSeqNumToUID[dwMsgSeqNum-2],
            dwMsgSeqNum >= m_dwSizeOfMsgSeqNumToUID ? 0 : m_pdwMsgSeqNumToUID[dwMsgSeqNum]);
        LoadString(g_hLocRes, idsIMAPUIDOrder, szTemp, sizeof(szTemp));
        OnIMAPError(IXP_E_IMAP_UIDORDER, szTemp, DONT_USE_LAST_RESPONSE, szDetails);
        // In this case, we'll still return S_OK, but user will know of problem
    }

    // Record the given UID under the given msg seq number
    m_pdwMsgSeqNumToUID[dwMsgSeqNum-1] = dwUID;
    if (dwMsgSeqNum > m_dwHighestMsgSeqNum)
        m_dwHighestMsgSeqNum = dwMsgSeqNum;

    return S_OK;
} // UpdateSeqNumToUID



//***************************************************************************
// Function: RemoveSequenceNum
//
// Purpose:
//   This function is called whenever we receive an EXPUNGE response. It
// removes the given message sequence number from the MsgSeqNumToUID table,
// and compacts the table so that all message sequence numbers following
// the deleted one are re-sequenced.
//
// Arguments:
//   DWORD dwDeletedMsgSeqNum [in] - message sequence number of deleted msg.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::RemoveSequenceNum(DWORD dwDeletedMsgSeqNum)
{
    DWORD *pdwDest, *pdwSrc;
    LONG lSizeOfBlock;

    Assert(m_lRefCount > 0);

    // Check arguments
    if (dwDeletedMsgSeqNum > m_dwHighestMsgSeqNum || 0 == dwDeletedMsgSeqNum) {
        AssertSz(FALSE, "Msg seq num out of range! Could be server bug, or out of memory.");
        return E_FAIL;
    }

    // Check if we have a table
    if (NULL == m_pdwMsgSeqNumToUID) {
        // This could mean programmer error, or server never gave us EXISTS
        AssertSz(FALSE, "You're trying to update a non-existent MsgSeqNumToUID table.");
        return E_FAIL;
    }

    // Compact the array
    pdwDest = &m_pdwMsgSeqNumToUID[dwDeletedMsgSeqNum-1];
    pdwSrc = pdwDest + 1;
    lSizeOfBlock = (m_dwHighestMsgSeqNum - dwDeletedMsgSeqNum) * sizeof(DWORD);
    if (0 < lSizeOfBlock)
        MoveMemory(pdwDest, pdwSrc, lSizeOfBlock);

    m_dwHighestMsgSeqNum -= 1;

    // Initialize the empty element at top of array to prevent confusion
    ZeroMemory(m_pdwMsgSeqNumToUID + m_dwHighestMsgSeqNum, sizeof(DWORD));
    return S_OK;
} // RemoveSequenceNum



//***************************************************************************
// Function: MsgSeqNumToUID
//
// Purpose:
//   This function takes a message sequence number and converts it to a UID
// based on the MsgSeqNumToUID table.
//
// Arguments:
//   DWORD dwMsgSeqNum [in] - the sequence number for which the caller wants
//     to know the UID.
//   DWORD *pdwUID [out] - the UID associated with the given sequence number
//     is returned here. If none could be found, this function returns 0.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::MsgSeqNumToUID(DWORD dwMsgSeqNum,
                                                      DWORD *pdwUID)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pdwUID);

    // Check arguments
    if (dwMsgSeqNum > m_dwHighestMsgSeqNum || 0 == dwMsgSeqNum) {
        AssertSz(FALSE, "Msg seq num out of range! Could be server bug, or out of memory.");
        *pdwUID = 0;
        return E_FAIL;
    }

    // Check if we have a table
    if (NULL == m_pdwMsgSeqNumToUID) {
        // This could mean programmer error, or server never gave us EXISTS
        AssertSz(FALSE, "You're trying to update a non-existent MsgSeqNumToUID table.");
        *pdwUID = 0;
        return E_FAIL;
    }

    // IE5 Bug #44956: It's OK for a MsgSeqNumToUID mapping to result in a UID of 0. Sometimes an IMAP
    // server can skip a range of messages. In such cases we will return a failure result.
    *pdwUID = m_pdwMsgSeqNumToUID[dwMsgSeqNum-1];
    if (0 == *pdwUID)
        return OLE_E_BLANK;
    else
        return S_OK;
} // MsgSeqNumToUID



//***************************************************************************
// Function: GetMsgSeqNumToUIDArray
//
// Purpose:
//   This function returns a copy of the MsgSeqNumToUID array. The caller
// will want to do this to delete messages from the cache which no longer
// exist on the server, for example.
//
// Arguments:
//   DWORD **ppdwMsgSeqNumToUIDArray [out] - the function returns a pointer
//     to the copy of the MsgSeqNumToUID array in this argument. Note that
//     it is the caller's responsibility to MemFree the array. If no array
//     is available, or it is empty, the returned pointer value is NULL.
//   DWORD *pdwNumberOfElements [out] - the function returns the size of
//     the MsgSeqNumToUID array.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetMsgSeqNumToUIDArray(DWORD **ppdwMsgSeqNumToUIDArray,
                                                              DWORD *pdwNumberOfElements)
{
    BOOL bResult;
    DWORD dwSizeOfArray;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppdwMsgSeqNumToUIDArray);
    Assert(NULL != pdwNumberOfElements);

    // Check if our table is empty. If so, return success, but no array
    if (NULL == m_pdwMsgSeqNumToUID || 0 == m_dwHighestMsgSeqNum) {
        *ppdwMsgSeqNumToUIDArray = NULL;
        *pdwNumberOfElements = 0;
        return S_OK;
    }

    // We have a non-zero-size array to return. Make a copy of our table
    dwSizeOfArray = m_dwHighestMsgSeqNum * sizeof(DWORD);
    bResult = MemAlloc((void **)ppdwMsgSeqNumToUIDArray, dwSizeOfArray);
    if (FALSE == bResult)
        return E_OUTOFMEMORY;

    CopyMemory(*ppdwMsgSeqNumToUIDArray, m_pdwMsgSeqNumToUID, dwSizeOfArray);
    *pdwNumberOfElements = m_dwHighestMsgSeqNum;
    return S_OK;
} // GetMsgSeqNumToUIDArray



//***************************************************************************
// Function: GetHighestMsgSeqNum
//
// Purpose:
//   This function returns the highest message sequence number reported in
// the MsgSeqNumToUID array.
//
// Arguments:
//   DWORD *pdwHighestMSN [out] - the highest message sequence number in the
//     table is returned here.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetHighestMsgSeqNum(DWORD *pdwHighestMSN)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pdwHighestMSN);

    *pdwHighestMSN = m_dwHighestMsgSeqNum;
    return S_OK;
} // GetHighestMsgSeqNum



//***************************************************************************
// Function: ResetMsgSeqNumToUID
//
// Purpose:
//   This function resets the variables used to maintain the MsgSeqNumToUID
// table. This function is called whenever the MsgSeqNumToUID table becomes
// invalid (say, when a new mailbox is selected, or we are disconnected).
//
// Returns:
//   S_OK. This function cannot fail.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ResetMsgSeqNumToUID(void)
{
    if (NULL != m_pdwMsgSeqNumToUID) {
        MemFree(m_pdwMsgSeqNumToUID);
        m_pdwMsgSeqNumToUID = NULL;
    }

    m_dwSizeOfMsgSeqNumToUID = 0;
    m_dwHighestMsgSeqNum = 0;

    return S_OK;
} // ResetMsgSeqNumToUID



//***************************************************************************
// Function: isPrintableUSASCII
//
// Purpose:
//   This function determines whether the given character is directly
// encodable, or whether the character must be encoded in modified IMAP UTF7,
// as outlined in RFC2060.
//
// Arguments:
//   BOOL fUnicode [in] - TRUE if input string is Unicode, otherwise FALSE.
//   LPCSTR pszIn [in] - pointer to char we want to verify.
//
// Returns:
//   TRUE if the given character may be directly encoded. FALSE if the
// character must be encoded in UTF-7.
//***************************************************************************
inline boolean CImap4Agent::isPrintableUSASCII(BOOL fUnicode, LPCSTR pszIn)
{
    WCHAR wc;

    if (fUnicode)
        wc = *((LPWSTR)pszIn);
    else
        wc = (*pszIn & 0x00FF);

    if (wc >= 0x0020 && wc <= 0x0025 ||
        wc >= 0x0027 && wc <= 0x007e)
        return TRUE;
    else
        return FALSE;
} // isPrintableUSASCII



//***************************************************************************
// Function: isIMAPModifiedBase64
//
// Purpose:
//   This function determines whether the given character is in the modified
// IMAP Base64 set as defined by RFC1521, RFC1642 and RFC2060. This modified
// IMAP Base64 set is used in IMAP-modified UTF-7 encoding of mailbox names.
//
// Arguments:
//   char c [in] - character to be classified.
//
// Returns:
//   TRUE if given character is in the modified IMAP Base64 set, otherwise
// FALSE.
//***************************************************************************
inline boolean CImap4Agent::isIMAPModifiedBase64(const char c)
{
    if (c >= 'A' && c <= 'Z' ||
        c >= 'a' && c <= 'z' ||
        c >= '0' && c <= '9' ||
        '+' == c || ',' == c)
        return TRUE;
    else
        return FALSE;
} // isIMAPModifiedBase64



//***************************************************************************
// Function: isEqualUSASCII
//
// Purpose:
//   This function determines whether the given pointer points to the given
// USASCII character, based on whether we are in Unicode mode or not.
//
// Arguments:
//   BOOL fUnicode [in] - TRUE if input string is Unicode, otherwise FALSE.
//   LPSTR pszIn [in] - pointer to char we want to verify.
//   char c [in] - the USASCII character we want to detect.
//
// Returns:
//   TRUE if given character is the null terminator, otherwise, FALSE.
//***************************************************************************
inline boolean CImap4Agent::isEqualUSASCII(BOOL fUnicode, LPCSTR pszIn, const char c)
{
    if (fUnicode) {
        WCHAR wc = c & 0x00FF;

        if (wc == *((LPWSTR)pszIn))
            return TRUE;
        else
            return FALSE;
    }
    else {
        if (c == *pszIn)
            return TRUE;
        else
            return FALSE;
    }
}



//***************************************************************************
// Function: SetUSASCIIChar
//
// Purpose:
//   This function writes a USASCII character to the given string pointer.
// The purpose of this function is to allow the caller to ignore whether
// he is writing to a Unicode output or not.
//
// Arguments:
//   BOOL fUnicode [in] - TRUE if target is Unicode, else FALSE.
//   LPSTR pszOut [in] - pointer to character's destination. If fUnicode is
//     TRUE, then two bytes will be written to this location.
//   char cUSASCII [in] - the character to be written to pszOut.
//***************************************************************************
inline void CImap4Agent::SetUSASCIIChar(BOOL fUnicode, LPSTR pszOut, char cUSASCII)
{
    Assert(0 == (cUSASCII & 0x80));

    if (fUnicode)
    {
        *((LPWSTR) pszOut) = cUSASCII;
        Assert(0 == (*((LPWSTR) pszOut) & 0xFF80));
    }
    else
        *pszOut = cUSASCII;
} // SetUSASCIIChar



//***************************************************************************
// Function: MultiByteToModifiedUTF7
//
// Purpose:
//   This function takes a MultiByte string and converts it to modified IMAP
// UTF7, which is described in RFC2060.
//
// Arguments:
//   LPCSTR pszSource [in] - pointer to the MultiByte string to convert to UTF7.
//   LPSTR *ppszDestination [out] - a pointer to a string buffer containing
//     the UTF7 equivalent of pszSource is returned here. It is the caller's
//     responsibility to MemFree this string.
//   UINT uiSourceCP [in] - indicates the codepage for pszSource.
//   DWORD dwFlags [in] - Reserved. Leave as 0.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::MultiByteToModifiedUTF7(LPCSTR pszSource,
                                                               LPSTR *ppszDestination,
                                                               UINT uiSourceCP,
                                                               DWORD dwFlags)
{
    int iResult;
    HRESULT hrResult;
    BOOL fPassThrough, fSkipByte;
    LPCSTR pszIn, pszStartOfLastRun;
    CByteStream bstmDestination;
    BOOL fUnicode;

    Assert(m_lRefCount > 0);
    Assert(NULL != pszSource);
    Assert(NULL != ppszDestination);
    Assert(NULL != m_pInternational);

    // Initialize variables
    hrResult = S_OK;
    fPassThrough = TRUE;
    fSkipByte = FALSE;
    pszIn = pszSource;
    pszStartOfLastRun = pszSource;
    fUnicode = (CP_UNICODE == uiSourceCP);

    *ppszDestination = NULL;

    // Loop through the entire input str either in one of two modes:
    // Passthrough, or non-US string collection (where we determine
    // the length of a string which must be encoded in UTF-7).
    while (1) {

        // Skip over the trail bytes
        if (fSkipByte) {
            AssertSz(FALSE == fUnicode, "Unicode has no trail bytes");
            fSkipByte = FALSE;
            if ('\0' != *pszIn)
                pszIn += 1;
            continue;
        }

        if (fPassThrough) {
            if (isEqualUSASCII(fUnicode, pszIn, '&') || isEqualUSASCII(fUnicode, pszIn, '\0') ||
                FALSE == isPrintableUSASCII(fUnicode, pszIn)) {
                // Flush USASCII characters collected until now (if any)
                if (pszIn - pszStartOfLastRun > 0) {
                    LPSTR  pszFreeMe = NULL;
                    LPCSTR pszUSASCII;
                    DWORD dwUSASCIILen = 0;

                    if (fUnicode) {
                        hrResult = UnicodeToUSASCII(&pszFreeMe, (LPCWSTR) pszStartOfLastRun,
                            (DWORD) (pszIn - pszStartOfLastRun), &dwUSASCIILen);
                        if (FAILED(hrResult))
                            goto exit;

                        pszUSASCII = pszFreeMe;
                    }
                    else {
                        pszUSASCII = pszStartOfLastRun;
                        dwUSASCIILen = (DWORD) (pszIn - pszStartOfLastRun);
                    }

                    hrResult = bstmDestination.Write(pszUSASCII, dwUSASCIILen, NULL);
                    if (NULL != pszFreeMe)
                        MemFree(pszFreeMe);

                    if (FAILED(hrResult))
                        goto exit;
                }

                // Special-case the '&' character: it is converted to "&-"
                if (isEqualUSASCII(fUnicode, pszIn, '&')) {
                    // Write "&-" to stream (always in USASCII)
                    hrResult = bstmDestination.Write("&-", sizeof("&-") - 1, NULL);
                    if (FAILED(hrResult))
                        goto exit;

                    // Reset pointers
                    pszStartOfLastRun = pszIn + (fUnicode ? 2 : 1); // Point past "&"
                } // if ('&' == cCurrent)
                else if (FALSE == isEqualUSASCII(fUnicode, pszIn, '\0')) {
                    Assert(FALSE == isPrintableUSASCII(fUnicode, pszIn));

                    // State transition: time for some UTF-7 encoding
                    fPassThrough = FALSE;
                    pszStartOfLastRun = pszIn;
                    if (FALSE == fUnicode && IsDBCSLeadByteEx(uiSourceCP, *pszIn))
                        fSkipByte = TRUE;
                } // else if ('\0' != cCurrent): shortcut calc for non-printable USASCII
            } // if ('&' == cCurrent || '\0' == cCurrent || FALSE == isPrintableUSASCII(cCurrent))

            // Otherwise do nothing, we're collecting a run of USASCII chars

        } // if (fPassThrough)
        else {
            // Non-US String Collection: Keep advancing through input str until
            // we find a char which does not need to be encoded in UTF-7 (incl. NULL)
            if (isPrintableUSASCII(fUnicode, pszIn) || isEqualUSASCII(fUnicode, pszIn, '&') ||
                isEqualUSASCII(fUnicode, pszIn, '\0')) {
                LPSTR pszOut = NULL;
                int iNumCharsWritten;

                // State transition: back to passthrough mode
                fPassThrough = TRUE;
                
                // Convert non-US string to UTF-7
                hrResult = NonUSStringToModifiedUTF7(uiSourceCP, pszStartOfLastRun,
                    (DWORD) (pszIn - pszStartOfLastRun), &pszOut, &iNumCharsWritten);
                if (FAILED(hrResult))
                    goto exit;

                // Write modified UTF-7 string to stream
                hrResult = bstmDestination.Write(pszOut, iNumCharsWritten, NULL);
                MemFree(pszOut);
                if (FAILED(hrResult))
                    goto exit;

                pszStartOfLastRun = pszIn; // Reset for USASCII collection process
                continue; // Do not advance ptr: we want current char to pass through
            }
            else if (FALSE == fUnicode && IsDBCSLeadByteEx(uiSourceCP, *pszIn))
                fSkipByte = TRUE;
        } // else-NOT-fPassThrough

        // Check for end-of-input
        if (isEqualUSASCII(fUnicode, pszIn, '\0'))
            break; // We're done here

        // Advance pointer to next character
        pszIn += (fUnicode ? 2 : 1);
    } // while

exit:
    if (SUCCEEDED(hrResult)) {
        hrResult = bstmDestination.HrAcquireStringA(NULL, ppszDestination,
            ACQ_DISPLACE);
        if (SUCCEEDED(hrResult))
            hrResult = S_OK;
    }

    if (NULL == *ppszDestination && SUCCEEDED(hrResult))
        hrResult = E_OUTOFMEMORY;

    return hrResult;
} // MultiByteToModifiedUTF7



//***************************************************************************
// Function: NonUSStringToModifiedUTF7
//
// Purpose:
//   This function takes a string consisting of non-US-ASCII characters, and
// converts them to modified IMAP UTF-7 (described in RFC2060).
//
// Arguments:
//   UINT uiCurrentACP [in] - codepage used to interpret pszStartOfNonUSASCII
//   LPCSTR pszStartOfNonUSASCII [in] - string to convert to modified IMAP
//     UTF-7.
//   int iLengthOfNonUSASCII [in] - the number of characters in
//     pszStartofNonUSASCII.
//   LPSTR *ppszOut [out] - the destination for the modified IMAP UTF-7 version
//     of pszStartOfNonUSASCII. This function appends a null-terminator. It is
//     the caller's responsibility to call MemFree when finished with the buffer.
//   LPINT piNumCharsWritten [out] - This function returns the number
//     of characters written (excluding null-terminator) to *ppszOut.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::NonUSStringToModifiedUTF7(UINT uiCurrentACP,
                                               LPCSTR pszStartOfNonUSASCII,
                                               int iLengthOfNonUSASCII,
                                               LPSTR *ppszOut,
                                               LPINT piNumCharsWritten)
{
    HRESULT hrResult;
    int iNumCharsWritten, i;
    LPSTR p;
    BOOL fResult;

    Assert(NULL != ppszOut);

    // Initialize return values
    *ppszOut = NULL;
    *piNumCharsWritten = 0;

    // First, convert the non-US string to standard UTF-7 (alloc 1 extra char: leave room for '-')
    iNumCharsWritten = 0; // Tell ConvertString to find proper output buffer size
    hrResult = ConvertString(uiCurrentACP, CP_UTF7, pszStartOfNonUSASCII,
        &iLengthOfNonUSASCII, ppszOut, &iNumCharsWritten, sizeof(char));
    if (FAILED(hrResult))
        goto exit;

    // Now, convert standard UTF-7 to IMAP4 modified UTF-7
    // Replace leading '+' with '&'. Since under IMAP UTF-7 '+' is never
    // encoded, we never expect "+-" as the result. Remember output is always USASCII
    if (iNumCharsWritten > 0 && '+' == **ppszOut)
        **ppszOut = '&';
    else {
        AssertSz(FALSE, "MLANG crapped out on me.");
        hrResult = E_FAIL;
        goto exit;
    }

    // Replace all occurrances of '/' with ','
    p = *ppszOut;
    for (i = 0; i < iNumCharsWritten; i++) {
        if ('/' == *p)
            *p = ',';

        p += 1;
    }

    // p now points to where null-terminator should go.
    // Ensure that the UTF-7 string ends with '-'. Otherwise, put one there
    // (we allocated enough room for one more char plus null-term).
    if ('-' != *(p-1)) {
        *p = '-';
        p += 1;
        iNumCharsWritten += 1;
    }

    // Null-terminate output string, and return values
    *p = '\0';
    *piNumCharsWritten = iNumCharsWritten;

exit:
    if (FAILED(hrResult) && NULL != *ppszOut) {
        MemFree(*ppszOut);
        *ppszOut = NULL;
    }

    return hrResult;
} // NonUSStringToModifiedUTF7



//***************************************************************************
// Function: ModifiedUTF7ToMultiByte
//
// Purpose:
//   This function takes a modified IMAP UTF-7 string (as defined in RFC2060)
// and converts it to a multi-byte string.
//
// Arguments:
//   LPCSTR pszSource [in] - a null-terminated string containing the modified
//     IMAP UTF-7 string to convert to multibyte.
//   LPSTR *ppszDestination [out] - this function returns a pointer to the
//     null-terminated multibyte string (in the system codepage) obtained
//     from pszSource. It is the caller's responsiblity to MemFree this
//     string when it is done with it.
//   UINT uiDestintationCP [in] - indicates the desired codepage for the
//     destination string.
//   DWORD dwFlags [in] - Reserved. Leave as 0.
//
// Returns:
//   HRESULT indicating success or failure. Success result codes include:
//     S_OK - pszSource successfully converted to modified UTF-7
//     IXP_S_IMAP_VERBATIM_MBOX - pszSource could not be converted to multibyte,
//        so ppszDestination contains a duplicate of pszSource. If target CP
//        is Unicode, pszSource is converted to Unicode with the assumption
//        that it is USASCII. IMAP_MBOXXLATE_VERBATIMOK must have been set via
//        SetDefaultCP in order to get this behaviour.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ModifiedUTF7ToMultiByte(LPCSTR pszSource,
                                                               LPSTR *ppszDestination,
                                                               UINT uiDestinationCP,
                                                               DWORD dwFlags)
{
    HRESULT hrResult;
    BOOL fPassThrough, fTrailByte;
    LPCSTR pszIn, pszStartOfLastRun;
    CByteStream bstmDestination;
    BOOL fUnicode;

    // Initialize variables
    hrResult = S_OK;
    fPassThrough = TRUE;
    fTrailByte = FALSE;
    pszIn = pszSource;
    pszStartOfLastRun = pszSource;
    fUnicode = (CP_UNICODE == uiDestinationCP);

    *ppszDestination = NULL;

    // Loop through the entire input str either in one of two modes:
    // Passthrough, or UTF-7 string collection (where we determine
    // the length of a string which was encoded in UTF-7).
    while (1) {
        char cCurrent;

        cCurrent = *pszIn;
        if (fPassThrough) {
            if ((FALSE == fTrailByte && '&' == cCurrent) || '\0' == cCurrent) {
                // State transition: flush collected non-UTF7
                BOOL    fResult;
                LPSTR   pszFreeMe = NULL;
                LPCSTR  pszNonUTF7;
                int     iNonUTF7Len;
                int     iSrcLen;

                if (fUnicode) {
                    // Convert non-UTF7 to Unicode
                    // Convert system codepage to CP_UNICODE. We KNOW source should be strictly
                    // USASCII, but can't assume it because some IMAP servers don't strictly
                    // prohibit 8-bit mailbox names. SCARY.
                    iSrcLen = (int) (pszIn - pszStartOfLastRun); // Pass in size of input and output buffer
                    iNonUTF7Len = iSrcLen * sizeof(WCHAR) / sizeof(char); // We know max output buffer size
                    hrResult = ConvertString(GetACP(), uiDestinationCP, pszStartOfLastRun,
                        &iSrcLen, &pszFreeMe, &iNonUTF7Len, 0);
                    if (FAILED(hrResult))
                        goto exit;

                    pszNonUTF7 = pszFreeMe;
                }
                else {
                    pszNonUTF7 = pszStartOfLastRun;
                    iNonUTF7Len = (int) (pszIn - pszStartOfLastRun);
                }

                hrResult = bstmDestination.Write(pszNonUTF7, iNonUTF7Len, NULL);
                if (NULL != pszFreeMe)
                    MemFree(pszFreeMe);

                if (FAILED(hrResult))
                    goto exit;

                // Start collecting UTF-7. Loop until we hit '-'
                fPassThrough = FALSE;
                pszStartOfLastRun = pszIn;
            }
            else {
                // Non-UTF7 stuff is copied verbatim to the output: collect it. Assume
                // source is in m_uiDefaultCP codepage. We SHOULD be able to assume
                // source is USASCII only but some svrs are not strict about disallowing 8-bit
                if (FALSE == fTrailByte && IsDBCSLeadByteEx(m_uiDefaultCP, cCurrent))
                    fTrailByte = TRUE;
                else
                    fTrailByte = FALSE;
            }
        }
        else {
            // UTF-7 collection mode: Keep going until we hit non-UTF7 char
            if (FALSE == isIMAPModifiedBase64(cCurrent)) {
                int iLengthOfUTF7, iNumBytesWritten, iOutputBufSize;
                LPSTR pszSrc, pszDest, p;
                BOOL fResult;

                // State transition, time to convert some modified UTF-7
                fPassThrough = TRUE;
                Assert(FALSE == fTrailByte);

                // If current character is '-', absorb it (don't process it)
                if ('-' == cCurrent)
                    pszIn += 1;

                // Check for "&-" or "&(end of buffer/nonBase64)" sequence
                iLengthOfUTF7 = (int) (pszIn - pszStartOfLastRun);
                if (2 == iLengthOfUTF7 && '-' == cCurrent ||
                    1 == iLengthOfUTF7) {
                    LPSTR psz;
                    DWORD dwLen;

                    Assert('&' == *pszStartOfLastRun);

                    if (fUnicode) {
                        psz = (LPSTR) L"&";
                        dwLen = 2;
                    }
                    else {
                        psz = "&";
                        dwLen = 1;
                    }

                    hrResult = bstmDestination.Write(psz, dwLen, NULL);
                    if (FAILED(hrResult))
                        goto exit;

                    pszStartOfLastRun = pszIn; // Set us up for non-UTF7 collection
                    continue; // Process next character normally
                }

                // Copy the UTF-7 sequence to a temp buffer, and
                // convert modified IMAP UTF-7 to standard UTF-7
                // First, duplicate the IMAP UTF-7 string so we can modify it
                fResult = MemAlloc((void **)&pszSrc, iLengthOfUTF7 + 1); // Room for null-term
                if (FALSE == fResult) {
                    hrResult = E_OUTOFMEMORY;
                    goto exit;
                }
                CopyMemory(pszSrc, pszStartOfLastRun, iLengthOfUTF7);
				pszSrc[iLengthOfUTF7] = '\0';

                // Next, replace leading '&' with '+'
                Assert('&' == *pszSrc);
                pszSrc[0] = '+';

                // Next, replace all ',' with '/'
                p = pszSrc + 1;
                for (iNumBytesWritten = 1; iNumBytesWritten < iLengthOfUTF7;
                     iNumBytesWritten++) {
                    if (',' == *p)
                        *p = '/';

                    p += 1;
                }

                // Now convert the UTF-7 to target codepage
                iNumBytesWritten = 0; // Tell ConvertString to find proper output buffer size
                hrResult = ConvertString(CP_UTF7, uiDestinationCP, pszSrc, &iLengthOfUTF7,
                    &pszDest, &iNumBytesWritten, 0);
                MemFree(pszSrc);
                if (FAILED(hrResult))
                    goto exit;

                // Now write the decoded string to the stream
                hrResult = bstmDestination.Write(pszDest, iNumBytesWritten, NULL);
                MemFree(pszDest);
                if (FAILED(hrResult))
                    goto exit;

                pszStartOfLastRun = pszIn; // Set us up for non-UTF7 collection
                continue; // Do not advance pointer, we want to process current char
            } // if end-of-modified-UTF7 run
        } // else

        // Check for end-of-input
        if ('\0' == cCurrent)
            break; // We're done here

        // Advance input pointer to next character
        pszIn += 1;
    } // while

exit:
    if (SUCCEEDED(hrResult)) {
        hrResult = bstmDestination.HrAcquireStringA(NULL, ppszDestination,
            ACQ_DISPLACE);
        if (SUCCEEDED(hrResult))
            hrResult = S_OK;
    }
    else if (IMAP_MBOXXLATE_VERBATIMOK & m_dwTranslateMboxFlags) {
        // Could not convert UTF-7 to multibyte str. Provide verbatim copy of src
        hrResult = HandleFailedTranslation(fUnicode, FALSE, pszSource, ppszDestination);
        if (SUCCEEDED(hrResult))
            hrResult = IXP_S_IMAP_VERBATIM_MBOX;
    }

    if (NULL == *ppszDestination && SUCCEEDED(hrResult))
        hrResult = E_OUTOFMEMORY;

    return hrResult;
} // ModifiedUTF7ToMultiByte



//***************************************************************************
// Function: UnicodeToUSASCII
//
// Purpose:
//   This function converts a Unicode string to USASCII, allocates a buffer
// to hold the result and returns the buffer to the caller.
//
// Arguments:
//   LPSTR *ppszUSASCII [out] - a pointer to a null-terminated USASCII string
//     is returned here if the function is successful. It is the caller's
//     responsibility to MemFree this buffer.
//   LPCWSTR pwszUnicode [in] - a pointer to the Unicode string to convert.
//   DWORD dwSrcLenInBytes [in] - the length of pwszUnicode in BYTES (NOT in
//     wide chars!).
//   LPDWORD pdwUSASCIILen [out] - the length of ppszUSASCII is returned here.
//
// Returns:
//  HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::UnicodeToUSASCII(LPSTR *ppszUSASCII, LPCWSTR pwszUnicode,
                                      DWORD dwSrcLenInBytes, LPDWORD pdwUSASCIILen)
{
    LPSTR   pszOutput = NULL;
    BOOL    fResult;
    HRESULT hrResult = S_OK;
    LPCWSTR pwszIn;
    LPSTR   pszOut;
    int     iOutputBufSize;
    DWORD   dw;

    if (NULL == pwszUnicode || NULL == ppszUSASCII) {
        Assert(FALSE);
        return E_INVALIDARG;
    }

    // Allocate the output buffer
    *ppszUSASCII = NULL;
    if (NULL != pdwUSASCIILen)
        *pdwUSASCIILen = 0;

    iOutputBufSize = (dwSrcLenInBytes/2) + 1;
    fResult = MemAlloc((void **) &pszOutput, iOutputBufSize);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Convert Unicode to ASCII
    pwszIn = pwszUnicode;
    pszOut = pszOutput;
    for (dw = 0; dw < dwSrcLenInBytes; dw += 2) {
        Assert(0 == (*pwszIn & 0xFF80));
        *pszOut = (*pwszIn & 0x00FF);

        pwszIn += 1;
        pszOut += 1;
    }

    // Null-terminate the output
    *pszOut = '\0';
    Assert(pszOut - pszOutput + 1 == iOutputBufSize);

exit:
    if (SUCCEEDED(hrResult)) {
        *ppszUSASCII = pszOutput;
        if (NULL != pdwUSASCIILen)
            *pdwUSASCIILen = (DWORD) (pszOut - pszOutput);
    }

    return hrResult;
} // UnicodeToUSASCII



//***************************************************************************
// Function: ASCIIToUnicode
//
// Purpose:
//   This function converts an ASCII string to Unicode, allocates a buffer
// to hold the result and returns the buffer to the caller.
//
// Arguments:
//   LPWSTR *ppwszUnicode [out] - a pointer to a null-terminated Unicode string
//     is returned here if the function is successful. It is the caller's
//     responsibility to MemFree this buffer.
//   LPCSTR pszASCII [in] - a pointer to the ASCII string to convert.
//   DWORD dwSrcLen [in] - the length of pszASCII.
//
// Returns:
//  HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ASCIIToUnicode(LPWSTR *ppwszUnicode, LPCSTR pszASCII,
                                      DWORD dwSrcLen)
{
    LPWSTR  pwszOutput = NULL;
    BOOL    fResult;
    HRESULT hrResult = S_OK;
    LPCSTR  pszIn;
    LPWSTR  pwszOut;
    int     iOutputBufSize;
    DWORD   dw;

    if (NULL == ppwszUnicode || NULL == pszASCII) {
        Assert(FALSE);
        return E_INVALIDARG;
    }

    // Allocate the output buffer
    *ppwszUnicode = NULL;
    iOutputBufSize = (dwSrcLen + 1) * sizeof(WCHAR);
    fResult = MemAlloc((void **) &pwszOutput, iOutputBufSize);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Convert USASCII to Unicode
    pszIn = pszASCII;
    pwszOut = pwszOutput;
    for (dw = 0; dw < dwSrcLen; dw++) {
        *pwszOut = (WCHAR)*pszIn & 0x00FF;

        pszIn += 1;
        pwszOut += 1;
    }

    // Null-terminate the output
    *pwszOut = L'\0';
    Assert(pwszOut - pwszOutput + (int)sizeof(WCHAR) == iOutputBufSize);

exit:
    if (SUCCEEDED(hrResult))
        *ppwszUnicode = pwszOutput;

    return hrResult;
} // ASCIIToUnicode



//***************************************************************************
// Function: _MultiByteToModifiedUTF7
//
// Purpose:
//   Internal form of MultiByteToModifiedUTF7. Checks m_dwTranslateMboxFlags
// and uses m_uiDefaultCP. All other aspects are identical to
// MultiByteToModifiedUTF7.
//***************************************************************************
HRESULT CImap4Agent::_MultiByteToModifiedUTF7(LPCSTR pszSource, LPSTR *ppszDestination)
{
    HRESULT hrResult;

    // Check if we're doing translations
    if (ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLE) ||
        ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLEIMAP4) &&
            ISFLAGCLEAR(m_dwCapabilityFlags, IMAP_CAPABILITY_IMAP4rev1)) {

        // No translations! Just copy mailbox name VERBATIM
        if (CP_UNICODE == m_uiDefaultCP)
            *ppszDestination = (LPSTR) PszDupW((LPWSTR)pszSource);
        else
            *ppszDestination = PszDupA(pszSource);

        if (NULL == *ppszDestination)
            hrResult = E_OUTOFMEMORY;
        else
            hrResult = S_OK;

        goto exit;
    }

    hrResult = MultiByteToModifiedUTF7(pszSource, ppszDestination, m_uiDefaultCP, 0);

exit:
    return hrResult;
} // _MultiByteToModifiedUTF7


//***************************************************************************
// Function: _ModifiedUTF7ToMultiByte
//
// Purpose:
//   Internal form of ModifiedUTF7ToMultiByte. Checks m_dwTranslateMboxFlags
// and uses m_uiDefaultCP. All other aspects are identical to
// ModifiedUTF7ToMultiByte.
//***************************************************************************
HRESULT CImap4Agent::_ModifiedUTF7ToMultiByte(LPCSTR pszSource, LPSTR *ppszDestination)
{
    HRESULT hrResult = S_OK;

    // Check if we're doing translations
    if (ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLE) ||
        ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLEIMAP4) &&
            ISFLAGCLEAR(m_dwCapabilityFlags, IMAP_CAPABILITY_IMAP4rev1)) {

        // No translations! Just copy mailbox name VERBATIM
        if (CP_UNICODE == m_uiDefaultCP) {
            hrResult = ASCIIToUnicode((LPWSTR *)ppszDestination, pszSource, lstrlenA(pszSource));
            if (FAILED(hrResult))
                goto exit;
        }
        else {
            *ppszDestination = PszDupA(pszSource);
            if (NULL == *ppszDestination) {
                hrResult = E_OUTOFMEMORY;
                goto exit;
            }
        }

        // If we reached this point, we succeeded. Return IXP_S_IMAP_VERBATIM_MBOX for
        // verbatim-capable clients so client can mark mailbox with appropriate attributes
        Assert(S_OK == hrResult); // If not S_OK, old IIMAPTransport clients better be able to deal with it
        if (ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_VERBATIMOK))
            hrResult = IXP_S_IMAP_VERBATIM_MBOX;

        goto exit;
    }

    hrResult = ModifiedUTF7ToMultiByte(pszSource, ppszDestination, m_uiDefaultCP, 0);

exit:
    return hrResult;
} // _ModifiedUTF7ToMultiByte



//***************************************************************************
// Function: ConvertString
//
// Purpose:
//   This function allocates a buffer and converts the source string to
// the target codepage, returning the output buffer. This function also
// checks to see if the conversion is round-trippable. If not, then a failure
// result is returned.
//
// Arguments:
//   UINT uiSourceCP [in] - codepage of pszSource.
//   UINT uiDestCP [in] - desired codepage of *ppszDest.
//   LPCSTR pszSource [in] - source string to convert to target codepage.
//   int *piSrcLen [in] - caller passes in length of pszSource.
//   LPSTR *ppszDest [out] - if successful, this function returns a pointer
//     to an output buffer containing pszSource translated to uiDestCP.
//     It is the caller's responsibility to MemFree this buffer.
//   int *piDestLen [in/out] - caller passes in maximum expected size of
//     *ppszDest. If caller passes in 0, this function determines the proper
//     size buffer to allocate. If successful, this function returns the
//     length of the output string (which is not necessarily the size of
//     the output buffer).
//   int iOutputExtra [in] - number of extra bytes to allocate in the output
//     buffer. This is useful if the caller wants to append something to
//     the output string.
//
// Returns:
//   HRESULT indicating success or failure. Success means that the conversion
// was roundtrippable, meaning that if you call this function again with
// *ppszDest as the source, the output will be identical to previous pszSource.
//***************************************************************************
HRESULT CImap4Agent::ConvertString(UINT uiSourceCP, UINT uiDestCP,
                                   LPCSTR pszSource, int *piSrcLen,
                                   LPSTR *ppszDest, int *piDestLen,
                                   int iOutputExtra)
{
    HRESULT hrResult;
    BOOL    fResult;
    int     iOutputLen;
    LPSTR   pszOutput = NULL;

    Assert(NULL != pszSource);
    Assert(NULL != piSrcLen);
    Assert(NULL != ppszDest);
    Assert(NULL != piDestLen);

    // Initialize return values
    *ppszDest = NULL;
    *piDestLen = 0;

    hrResult = m_pInternational->MLANG_ConvertInetReset();
    if (FAILED(hrResult))
        goto exit;

    // Find out how big an output buffer is required, if user doesn't supply a size
    if (*piDestLen == 0) {
        hrResult = m_pInternational->MLANG_ConvertInetString(uiSourceCP, uiDestCP,
            pszSource, piSrcLen, NULL, &iOutputLen);
        if (S_OK != hrResult)
            goto exit;
    }
    else
        iOutputLen = *piDestLen;

    // Allocate the output buffer. Leave room for wide null-term, too
    fResult = MemAlloc((void **)&pszOutput, iOutputLen + iOutputExtra + 2);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Now perform the conversion
    hrResult = m_pInternational->MLANG_ConvertInetString(uiSourceCP, uiDestCP,
        pszSource, piSrcLen, pszOutput, &iOutputLen);
    if (S_OK != hrResult)
        goto exit;

    // ========================================================*** TAKE OUT after MLANG gets better ***
    // Try the round-trip conversion
    LPSTR pszRoundtrip;
    fResult = MemAlloc((void **)&pszRoundtrip, *piSrcLen + 2);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    hrResult = m_pInternational->MLANG_ConvertInetReset();
    if (FAILED(hrResult))
        goto exit;

    int iRoundtripSrc; 
    int iRoundtripDest;

    iRoundtripSrc = iOutputLen;
    iRoundtripDest = *piSrcLen;
    hrResult = m_pInternational->MLANG_ConvertInetString(uiDestCP, uiSourceCP,
        pszOutput, &iRoundtripSrc, pszRoundtrip, &iRoundtripDest);
    if (FAILED(hrResult))
        goto exit;

    if (iRoundtripDest != *piSrcLen) {
        MemFree(pszRoundtrip);
        hrResult = S_FALSE;
        goto exit;
    }

    int iRoundtripResult;
    Assert(iRoundtripDest == *piSrcLen);
    if (CP_UNICODE != uiSourceCP)
        iRoundtripResult = StrCmpNA(pszRoundtrip, pszSource, iRoundtripDest);
    else
        iRoundtripResult = StrCmpNW((LPWSTR)pszRoundtrip, (LPCWSTR)pszSource, iRoundtripDest);

    MemFree(pszRoundtrip);
    if (0 != iRoundtripResult)
        hrResult = S_FALSE;
    else
        Assert(S_OK == hrResult);

    // ========================================================*** TAKE OUT after MLANG gets better ***

exit:
    if (S_OK == hrResult) {
        *ppszDest = pszOutput;
        *piDestLen = iOutputLen;
    }
    else {
        if (SUCCEEDED(hrResult))
            // One or more chars not convertable. We're not round-trippable so we must fail
            hrResult = E_FAIL;

        if (NULL != pszOutput)
            MemFree(pszOutput);
    }

    return hrResult;
} // ConvertString



//***************************************************************************
// Function: HandleFailedTranslation
//
// Purpose:
//   In case we cannot translate a mailbox name from modified UTF-7 to
// the desired codepage (we may not have the codepage, for instance), we
// provide a duplicate of the modified UTF-7 mailbox name. This function
// allows the caller to ignore whether target codepage is Unicode or not.
//
// Arguments:
//   BOOL fUnicode [in] - If fToUTF7 is TRUE, then this argument indicates
//     whether pszSource points to a Unicode string or not. If fToUTF7 is
//     FALSE, this arg indicates whether *ppszDest should be in Unicode or not.
//   BOOL fToUTF7 [in] - TRUE if we are converting to UTF7, FALSE if we are
//     converting from UTF7.
//   LPCSTR pszSource [in] - pointer to source string.
//   LPSTR *ppszDest [in] - if sucessful, this function returns a pointer
//     to an output buffer containing a duplicate of pszSource (converted
//     to/from Unicode where necessary). It is the caller's responsibility
//     to MemFree this buffer.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::HandleFailedTranslation(BOOL fUnicode, BOOL fToUTF7,
                                             LPCSTR pszSource, LPSTR *ppszDest)
{
    int     i;
    int     iOutputStep;
    int     iInputStep;
    int     iSourceLen;
    int     iOutputBufSize;
    BOOL    fResult;
    LPSTR   pszOutput = NULL;
    HRESULT hrResult = S_OK;
    LPCSTR  pszIn;
    LPSTR   pszOut;

    Assert(m_lRefCount > 0);
    Assert(ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_VERBATIMOK));

    // Calculate length of source, size of output buffer
    if (fToUTF7) {
        // Going to UTF7, so output is USASCII
        if (fUnicode) {
            iInputStep = sizeof(WCHAR);
            iSourceLen = lstrlenW((LPCWSTR)pszSource);
        }
        else {
            iInputStep = sizeof(char);
            iSourceLen = lstrlenA(pszSource);
        }

        iOutputStep = sizeof(char);
        iOutputBufSize = iSourceLen + sizeof(char); // Room for null-term
    }
    else {
        // Coming from UTF7, so input is USASCII
        iSourceLen = lstrlenA(pszSource);
        iInputStep = sizeof(char);
        if (fUnicode) {
            iOutputStep = sizeof(WCHAR);
            iOutputBufSize = (iSourceLen + 1) * sizeof(WCHAR); // Room for wide null-term
        }
        else {
            iOutputStep = sizeof(char);
            iOutputBufSize = iSourceLen + sizeof(char); // Room for null-term
        }
    }

    // Allocate output buffer
    fResult = MemAlloc((void **)&pszOutput, iOutputBufSize);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy input to output
    pszIn = pszSource;
    pszOut = pszOutput;
    for (i = 0; i < iSourceLen; i++) {
        char c;

        // Convert input character to USASCII
        if (FALSE == fUnicode || FALSE == fToUTF7)
            c = *pszIn; // Input is already USASCII
        else
            c = *((LPWSTR)pszIn) & 0x00FF; // Convert Unicode to USASCII (too bad if it isn't)

        // Write character to output
        SetUSASCIIChar(FALSE == fToUTF7 && fUnicode, pszOut, c);

        // Advance pointers
        pszIn += iInputStep;
        pszOut += iOutputStep;
    }

    // Null-terminate the output
    SetUSASCIIChar(FALSE == fToUTF7 && fUnicode, pszOut, '\0');

exit:
    if (SUCCEEDED(hrResult))
        *ppszDest = pszOutput;
    else if (NULL != pszOutput)
        MemFree(pszOutput);

    return hrResult;
} // HandleFailedTranslation



//***************************************************************************
// Function: OnIMAPResponse
//
// Purpose:
//   This function dispatches a IIMAPCallback::OnResponse call. The reason
// to use this function instead of calling directly is watchdog timers: the
// watchdog timers should be disabled before the call in case the callback
// puts up some UI, and the watchdog timers should be restarted if they're
// needed after the callback function returns.
//
// Arguments:
//   IIMAPCallback *pCBHandler [in] - a pointer to the IIMAPCallback
//     interface whose OnResponse we should call.
//   IMAP_RESPONSE *pirIMAPResponse [in] - a pointer to the IMAP_RESPONSE
//     structure to send with the IIMAPCallback::OnResponse call.
//***************************************************************************
void CImap4Agent::OnIMAPResponse(IIMAPCallback *pCBHandler,
                                 IMAP_RESPONSE *pirIMAPResponse)
{
    Assert(NULL != pirIMAPResponse);

    if (NULL == pCBHandler)
        return; // We can't do a damned thing (this can happen due to HandsOffCallback)

    // Suspend watchdog for the duration of this callback
    LeaveBusy();

    pCBHandler->OnResponse(pirIMAPResponse);

    // Re-awaken the watchdog only if we need him
    if (FALSE == m_fBusy &&
        (NULL != m_piciPendingList || (NULL != m_piciCmdInSending &&
        icIDLE_COMMAND != m_piciCmdInSending->icCommandID))) {
        HRESULT hrResult;

        hrResult = HrEnterBusy();
        Assert(SUCCEEDED(hrResult));
    }
} // OnIMAPResponse



//***************************************************************************
// Function: FreeFetchResponse
//
// Purpose:
//   This function frees all the allocated data found in a
// FETCH_CMD_RESULTS_EX structure.
//
// Arguments:
//   FETCH_CMD_RESULTS_EX *pcreFreeMe [in] - pointer to the structure to
//     free.
//***************************************************************************
void CImap4Agent::FreeFetchResponse(FETCH_CMD_RESULTS_EX *pcreFreeMe)
{
    SafeMemFree(pcreFreeMe->pszENVSubject);
    FreeIMAPAddresses(pcreFreeMe->piaENVFrom);
    FreeIMAPAddresses(pcreFreeMe->piaENVSender);
    FreeIMAPAddresses(pcreFreeMe->piaENVReplyTo);
    FreeIMAPAddresses(pcreFreeMe->piaENVTo);
    FreeIMAPAddresses(pcreFreeMe->piaENVCc);
    FreeIMAPAddresses(pcreFreeMe->piaENVBcc);
    SafeMemFree(pcreFreeMe->pszENVInReplyTo);
    SafeMemFree(pcreFreeMe->pszENVMessageID);
} // FreeFetchResponse



//***************************************************************************
// Function: FreeIMAPAddresses
//
// Purpose:
//   This function frees all the allocated data found in a chain of IMAPADDR
// structures.
//
// Arguments:
//   IMAPADDR *piaFreeMe [in] - pointer to the chain of IMAP addresses to free.
//***************************************************************************
void CImap4Agent::FreeIMAPAddresses(IMAPADDR *piaFreeMe)
{
    while (NULL != piaFreeMe)
    {
        IMAPADDR *piaFreeMeToo;

        SafeMemFree(piaFreeMe->pszName);
        SafeMemFree(piaFreeMe->pszADL);
        SafeMemFree(piaFreeMe->pszMailbox);
        SafeMemFree(piaFreeMe->pszHost);

        // Advance pointer, free structure
        piaFreeMeToo = piaFreeMe;
        piaFreeMe = piaFreeMe->pNext;
        MemFree(piaFreeMeToo);
    }
} // FreeIMAPAddresses



//===========================================================================
// IInternetTransport Abstract Functions
//===========================================================================

//***************************************************************************
// Function: GetServerInfo
//
// Purpose:
//   This function copies the module's INETSERVER structure into the given
// output buffer.
//
// Arguments:
//   LPINETSERVER pInetServer [out] - if successful, the function copies
//     the module's INETSERVER structure here.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetServerInfo(LPINETSERVER pInetServer)
{
    return CIxpBase::GetServerInfo(pInetServer);
} // GetServerInfo



//***************************************************************************
// Function: GetIXPType
//
// Purpose:
//   This function identifies what type of transport this is.
//
// Returns:
//   IXP_IMAP for this class.
//***************************************************************************
IXPTYPE STDMETHODCALLTYPE CImap4Agent::GetIXPType(void)
{
    return CIxpBase::GetIXPType();
} // GetIXPType



//***************************************************************************
// Function: IsState
//
// Purpose:
//   This function allows a caller to query about the state of the transport
// interface.
//
// Arguments:
//   IXPISSTATE isstate [in] - one of the specified queries defined in
//     imnxport.idl/imnxport.h (eg, IXP_IS_CONNECTED).
//
// Returns:
//   HRESULT indicating success or failure. If successful, this function
// returns S_OK to indicate that the transport is in the specified state,
// and S_FALSE to indicate that the transport is not in the given state.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::IsState(IXPISSTATE isstate)
{
    return CIxpBase::IsState(isstate);
} // IsState



//***************************************************************************
// Function: InetServerFromAccount
//
// Purpose:
//   This function fills the given INETSERVER structure using the given
// IImnAccount interface.
//
// Arguments:
//   IImnAccount *pAccount [in] - pointer to an IImnAccount interface which
//     the user would like to retrieve information for.
//   LPINETSERVER pInetServer [out] - if successful, the function fills the
//     given INETSERVER structure with information from pAccount.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::InetServerFromAccount(IImnAccount *pAccount,
                                                             LPINETSERVER pInetServer)
{
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
} // InetServerFromAccount



//***************************************************************************
// Function: GetStatus
//
// Purpose:
//   This function returns the current status of the transport.
//
// Arguments:
//   IXPSTATUS *pCurrentStatus [out] - returns current status of transport.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetStatus(IXPSTATUS *pCurrentStatus)
{
    return CIxpBase::GetStatus(pCurrentStatus);
} // GetStatus



//***************************************************************************
// Function: SetDefaultCP
//
// Purpose:
//   This function allows the caller to tell IIMAPTransport what codepage to
// use for IMAP mailbox names. After calling this function, all mailbox names
// submitted to IIMAPTransport will be translated from the default codepage,
// and all mailbox names returned from the server will be translated to
// the default codepage before being returned via IIMAPCallback.
//
// Arguments:
//   DWORD dwTranslateFlags [in] - enables/disables automatic translation to
//     and from default codepage and IMAP-modified UTF-7. If disabled, caller
//     wishes all mailbox names to be passed verbatim to/from IMAP server.
//     Note that by default we translate for IMAP4 servers, even with its
//     round-trippability problems, because this is how we used to do it
//     in the past.
//   UINT uiCodePage [in] - the default codepage to use for translations.
//     By default this value is the CP returned by GetACP().
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetDefaultCP(DWORD dwTranslateFlags,
                                                    UINT uiCodePage)
{
    Assert(m_lRefCount > 0);

    if (ISFLAGCLEAR(dwTranslateFlags, IMAP_MBOXXLATE_RETAINCP))
        m_uiDefaultCP = uiCodePage;

    dwTranslateFlags &= ~(IMAP_MBOXXLATE_RETAINCP);
    m_dwTranslateMboxFlags = dwTranslateFlags;

    return S_OK;
} // SetDefaultCP



//***************************************************************************
// Function: SetIdleMode
//
// Purpose:
//   The IMAP IDLE extension allows the server to unilaterally report changes
// to the currently selected mailbox: new email, flag updates, and message
// expunges. IIMAPTransport always enters IDLE mode when no IMAP commands
// are pending, but it turns out that this can result in unnecessary
// entry and exit of IDLE mode when the caller tries to sequence IMAP commands.
// This function allows the caller to disable the use of the IDLE extension.
//
// Arguments:
//   DWORD dwIdleFlags [in] - enables or disables the use of the IDLE extension.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetIdleMode(DWORD dwIdleFlags)
{
    Assert(m_lRefCount > 0);
    return E_NOTIMPL;
} // SetIdleMode



//***************************************************************************
// Function: EnableFetchEx
//
// Purpose:
//   IIMAPTransport only understood a subset of FETCH response tags. Notable
// omissions included ENVELOPE and BODYSTRUCTURE. Calling this function
// changes the behaviour of IIMAPTransport::Fetch. Instead of returning
// FETCH responses via IIMAPCallback::OnResponse(irtUPDATE_MESSAGE),
// the FETCH response is returned via OnResponse(irtUPDATE_MESSAGE_EX).
// Other FETCH-related responses remain unaffected (eg, irtFETCH_BODY).
//
// Arguments:
//   DWORD dwFetchExFlags [in] - enables or disables FETCH extensions.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::EnableFetchEx(DWORD dwFetchExFlags)
{
    Assert(m_lRefCount > 0);

    m_dwFetchFlags = dwFetchExFlags;
    return S_OK;
} // EnableFetchEx



//===========================================================================
// CIxpBase Abstract Functions
//===========================================================================

//***************************************************************************
// Function: OnDisconnected
//
// Purpose:
//   This function calls FreeAllData to deallocate the structures which are
// no longer needed when we are disconnected. It then calls
// CIxpBase::OnDisconnected which updates the user's status.
//***************************************************************************
void CImap4Agent::OnDisconnected(void)
{
    FreeAllData(IXP_E_CONNECTION_DROPPED);
    CIxpBase::OnDisconnected();
} // OnDisconnected



//***************************************************************************
// Function: ResetBase
//
// Purpose:
//   This function resets the class to a non-connected state by deallocating
// the send and receive queues, and the MsgSeqNumToUID table.
//***************************************************************************
void CImap4Agent::ResetBase(void)
{
    FreeAllData(IXP_E_NOT_CONNECTED);
} // ResetBase



//***************************************************************************
// Function: DoQuit
//
// Purpose:
//   This function sends a "LOGOUT" command to the IMAP server.
//***************************************************************************
void CImap4Agent::DoQuit(void)
{
    HRESULT hrResult;

    hrResult = NoArgCommand("LOGOUT", icLOGOUT_COMMAND, ssNonAuthenticated, 0, 0,
        DEFAULT_CBHANDLER);
    Assert(SUCCEEDED(hrResult));
} // DoQuit



//***************************************************************************
// Function: OnEnterBusy
//
// Purpose:
//   This function does nothing at the current time.
//***************************************************************************
void CImap4Agent::OnEnterBusy(void)
{
    // Do nothing
} // OnEnterBusy



//***************************************************************************
// Function: OnLeaveBusy
//
// Purpose:
//   This function does nothing at the current time.
//***************************************************************************
void CImap4Agent::OnLeaveBusy(void)
{
    // Do nothing
} // OnLeaveBusy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpnntp.cpp ===
// --------------------------------------------------------------------------------
// Ixpnntp.cpp
// Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved
//
// Eric Andrews
// Steve Serdy
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include <stdio.h>
#include "ixpnntp.h"
#include "asynconn.h"
#include "ixputil.h"
#include "strconst.h"
#include "resource.h"
#include <shlwapi.h>
#include "demand.h"

// --------------------------------------------------------------------------------
// Some handle macros for simple pointer casting
// --------------------------------------------------------------------------------
#define NNTPTHISIXP         ((INNTPTransport *)(CIxpBase *) this)

#define NUM_HEADERS         100

CNNTPTransport::CNNTPTransport(void) : CIxpBase(IXP_NNTP)
    {
    ZeroMemory(&m_rMessage, sizeof(m_rMessage));
    ZeroMemory(&m_sicinfo, sizeof(SSPICONTEXT));

    DllAddRef();

    m_substate = NS_RESP;
    }

CNNTPTransport::~CNNTPTransport(void)
    {
    SafeRelease(m_rMessage.pstmMsg);
    DllRelease();
    }


// --------------------------------------------------------------------------------
// CNNTPTransport::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
        {
        hr = TrapError(E_INVALIDARG);
        goto exit;
        }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(INNTPTransport *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)(CIxpBase *)this);

    // IID_INNTPTransport
    else if (IID_INNTPTransport == riid)
        *ppv = (INNTPTransport *)this;

    // IID_INNTPTransport2
    else if (IID_INNTPTransport2 == riid)
        *ppv = (INNTPTransport2 *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
        }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::AddRef
// --------------------------------------------------------------------------------
ULONG CNNTPTransport::AddRef(void) 
    {
    return ++m_cRef;
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::Release
// --------------------------------------------------------------------------------
ULONG CNNTPTransport::Release(void) 
    {
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
    }   

//
//  FUNCTION:   CNNTPTransport::OnNotify()
//
//  PURPOSE:    This function get's called whenever the CAsyncConn class 
//              sends or receives data.
//
//  PARAMETERS:
//      asOld   - State of the connection before this event
//      asNew   - State of the connection after this event
//      ae      - Identifies the event that has occured
//
void CNNTPTransport::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
    {
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Handle Event
    switch(ae)
        {
        case AE_RECV:
            OnSocketReceive();
            break;

        case AE_SENDDONE:
            if (m_substate == NS_SEND_ENDPOST)
                {
                HrSendCommand((LPSTR) NNTP_ENDPOST, NULL, FALSE);
                m_substate = NS_ENDPOST_RESP;
                }
            break;

        case AE_LOOKUPDONE:
            if (AS_DISCONNECTED == asNew)
            {
                DispatchResponse(IXP_E_CANT_FIND_HOST, TRUE);
                OnDisconnected();
            }
            else
                OnStatus(IXP_CONNECTING);
            break;

        // --------------------------------------------------------------------------------
        case AE_CONNECTDONE:
            if (AS_DISCONNECTED == asNew)
            {
                DispatchResponse(IXP_E_FAILED_TO_CONNECT, TRUE);
                OnDisconnected();
            }
            else if (AS_HANDSHAKING == asNew)
            {
                OnStatus(IXP_SECURING);
            }
            else
                OnConnected();
            break;

        // --------------------------------------------------------------------------------
        case AE_CLOSE:
            if (AS_RECONNECTING != asNew && IXP_AUTHRETRY != m_status)
            {
                if (IXP_DISCONNECTING != m_status && IXP_DISCONNECTED  != m_status)
                {
                    if (AS_HANDSHAKING == asOld)
                        DispatchResponse(IXP_E_SECURE_CONNECT_FAILED, TRUE);
                    else
                        DispatchResponse(IXP_E_CONNECTION_DROPPED, TRUE);
                }
                OnDisconnected();
            }
            break;

        default:
            CIxpBase::OnNotify(asOld, asNew, ae);
            break;
        }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
    }


//
//  FUNCTION:   CNNTPTransport::InitNew()
//
//  PURPOSE:    The client calls this to specify a callback interface and a log
//              file path if desired.
//
//  PARAMETERS:
//      pszLogFilePath - Path to the file to write logging info to.
//      pCallback      - Pointer to the callback interface to send results etc
//                       to.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CNNTPTransport::InitNew(LPSTR pszLogFilePath, INNTPCallback *pCallback)
    {
    // Let the base class handle the rest
    return (CIxpBase::OnInitNew("NNTP", pszLogFilePath, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (ITransportCallback *) pCallback));
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPTransport::HandsOffCallback(void)
    {
    return CIxpBase::HandsOffCallback();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPTransport::GetStatus(IXPSTATUS *pCurrentStatus)
    {
    return CIxpBase::GetStatus(pCurrentStatus);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
    {
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::Connect
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, 
                                boolean fCommandLogging)
    {
    // Does user want us to always prompt for his password? Prompt him here to avoid
    // inactivity timeouts while the prompt is up, unless a password was supplied
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pInetServer->szPassword[0])
        {
        HRESULT hr;

        if (NULL != m_pCallback)
            hr = m_pCallback->OnLogonPrompt(pInetServer, NNTPTHISIXP);

        if (NULL == m_pCallback || S_OK != hr)
            return IXP_E_USER_CANCEL;
        }

    return CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::DropConnection
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::DropConnection(void)
    {
    return CIxpBase::DropConnection();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::Disconnect
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::Disconnect(void)
    {
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr = CIxpBase::Disconnect()))
        {
        m_state = NS_DISCONNECTED;
        m_pSocket->Close();
        }

    return (hr);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::IsState
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::IsState(IXPISSTATE isstate)
    {
    return CIxpBase::IsState(isstate);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::GetServerInfo
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::GetServerInfo(LPINETSERVER pInetServer)
    {
    return CIxpBase::GetServerInfo(pInetServer);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::GetIXPType
// --------------------------------------------------------------------------------
IXPTYPE CNNTPTransport::GetIXPType(void)
    {
    return IXP_NNTP;
    }


// --------------------------------------------------------------------------------
// CNNTPTransport::ResetBase
// --------------------------------------------------------------------------------
void CNNTPTransport::ResetBase(void)
    {
    EnterCriticalSection(&m_cs);
    
    if (m_substate != NS_RECONNECTING)
        {
        m_state = NS_DISCONNECTED;
        m_substate = NS_RESP;
        m_fSupportsXRef = FALSE;
        m_rgHeaders = 0;
        m_pMemInfo = 0;

        if (m_sicinfo.pCallback)
            SSPIFreeContext(&m_sicinfo);

        ZeroMemory(&m_sicinfo, sizeof(m_sicinfo));
        m_cSecPkg = -1;                 // number of sec pkgs to try, -1 if not inited
        m_iSecPkg = -1;                 // current sec pkg being tried
        m_iAuthType = AUTHINFO_NONE;
        ZeroMemory(m_rgszSecPkg, sizeof(m_rgszSecPkg)); // array of pointers into m_szSecPkgs
        m_szSecPkgs = NULL;             // string returned by "AUTHINFO TRANSACT TWINKIE"
        m_fRetryPkg = FALSE;
        m_pAuthInfo = NULL;
        m_fNoXover = FALSE;
        }
    
    LeaveCriticalSection(&m_cs);
    }

// ------------------------------------------------------------------------------------
// CNNTPTransport::DoQuit
// ------------------------------------------------------------------------------------
void CNNTPTransport::DoQuit(void)
    {
    CommandQUIT();
    }


// --------------------------------------------------------------------------------
// CNNTPTransport::OnConnected
// --------------------------------------------------------------------------------
void CNNTPTransport::OnConnected(void)
    {
    m_state = NS_CONNECT;
    m_substate = NS_CONNECT_RESP;
    CIxpBase::OnConnected();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::OnDisconnect
// --------------------------------------------------------------------------------
void CNNTPTransport::OnDisconnected(void)
    {
    ResetBase();
    CIxpBase::OnDisconnected();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::OnEnterBusy
// --------------------------------------------------------------------------------
void CNNTPTransport::OnEnterBusy(void)
    {
    IxpAssert(m_state == NS_IDLE);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::OnLeaveBusy
// --------------------------------------------------------------------------------
void CNNTPTransport::OnLeaveBusy(void)
    {
    m_state = NS_IDLE;
    }


//
//  FUNCTION:   CNNTPTransport::OnSocketReceive()
//
//  PURPOSE:    This function reads the data off the socket and parses that 
//              information based on the current state of the transport.
//
void CNNTPTransport::OnSocketReceive(void)
    {
    HRESULT hr;
    UINT    uiResp;

    EnterCriticalSection(&m_cs);

    // Handle the current NNTP State
    switch (m_state)
        {
        case NS_CONNECT:
            {
            HandleConnectResponse();
            break;
            }

        case NS_AUTHINFO:
            {
            HandleConnectResponse();
            break;
            }

        case NS_NEWGROUPS:
            {
            // If we're waiting for the original response line then get it and
            // parse it here
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;
                
                // If the command failed, inform the user and exit
                if (IXP_NNTP_NEWNEWSGROUPS_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_NEWGROUPS_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                // Advance the substate to data receive
                m_substate = NS_DATA;
                }

            // Process the returned data
            ProcessListData();
            break;
            }

        case NS_LIST:
            {
            // If we're waiting for the original response line then get it and
            // parse it here.
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                // If the command failed, inform the user and exit
                if (IXP_NNTP_LIST_DATA_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_LIST_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                // Advance the substate to data recieve
                m_substate = NS_DATA;
                }

            // Start processing the data retrieved from the command
            ProcessListData();
            break;
            }

        case NS_LISTGROUP:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (IXP_NNTP_GROUP_SELECTED != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_LISTGROUP_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessListGroupData();
            break;
            }

        case NS_GROUP:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessGroupResponse();
            break;

        case NS_ARTICLE:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;
                
                if (IXP_NNTP_ARTICLE_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_ARTICLE_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessArticleData();
            break;
            }

        case NS_HEAD:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (IXP_NNTP_HEAD_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_HEAD_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessArticleData();
            break;
            }

        case NS_BODY:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (IXP_NNTP_BODY_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_BODY_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessArticleData();
            break;
            }

        case NS_POST:
            if (NS_RESP == m_substate)
                {
                // Get the response to our post command
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                // If the response wasn't 340, then we can't post and might
                // as well bail.
                if (IXP_NNTP_SEND_ARTICLE_TO_POST != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_POST_FAILED;
                    // Make sure we free up the stream
                    SafeRelease(m_rMessage.pstmMsg);
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                // Send the message
                if (SUCCEEDED(hr = HrPostMessage()))
                    {
                    HrSendCommand((LPSTR) NNTP_ENDPOST, 0, FALSE);
                    m_substate = NS_ENDPOST_RESP;
                    }
                else if (IXP_E_WOULD_BLOCK == hr)
                    {
                    // We will send the crlf . crlf when we get the AE_SENDDONE
                    // notification.  This is handled in OnNotify().
                    m_substate = NS_SEND_ENDPOST;
                    }
                else
                    {
                    // Some unhandled error occured.
                    hr = IXP_E_NNTP_POST_FAILED;
                    DispatchResponse(hr, TRUE);
                    }
                }
            else if (NS_ENDPOST_RESP == m_substate)
                {
                // Here's the response from the server regarding the post.  Send
                // it off to the user.
                hr = HrGetResponse();

                if (IXP_NNTP_ARTICLE_POSTED_OK != m_uiResponse)
                    hr = IXP_E_NNTP_POST_FAILED;

                DispatchResponse(hr, TRUE);
                }            
            break;

        case NS_IDLE:
            break;

        case NS_DISCONNECTED:
            break;

        case NS_QUIT:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            DispatchResponse(S_OK, TRUE);

            // Make sure the socket closes if the server doesn't drop the 
            // connection itself.
            m_pSocket->Close();
            break;

        case NS_LAST:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessNextResponse();
            break;

        case NS_NEXT:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessNextResponse();
            break;

        case NS_STAT:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessNextResponse();
            break;

        case NS_MODE:
            // Very little to do with this response other than return it to 
            // the caller.
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            DispatchResponse(S_OK);
            break;

        case NS_DATE:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessDateResponse();
            break;

        case NS_HEADERS:
            if (NS_RESP == m_substate)
                {
                // Get the response string from the socket
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                // There's a couple of things that can happen here.  First, if
                // the response is IXP_NNTP_OVERVIEW_FOLLOWS, then everything is
                // great and we can party on.  If the response is > 500, then
                // XOVER isn't supported on this server and we have to try using
                // XHDR to retrieve the headers.
                if (m_uiResponse >= 500 && m_gethdr == GETHDR_XOVER)
                    {
                    hr = BuildHeadersFromXhdr(TRUE);
                    if (FAILED(hr))
                        DispatchResponse(hr, TRUE);

                    break;
                    }
                else if (2 != (m_uiResponse / 100))
                    {
                    hr = IXP_E_NNTP_HEADERS_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            // Parse the returned data strings
            if (m_gethdr == GETHDR_XOVER)
                ProcessXoverData();
            else
                BuildHeadersFromXhdr(FALSE);
            break;

        case NS_XHDR:
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (2 != (m_uiResponse / 100))
                    {
                    hr = IXP_E_NNTP_XHDR_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessXhdrData();
            break;

        default:
            IxpAssert(FALSE);
            break;
        }

exit:
    LeaveCriticalSection(&m_cs);
    }

HRESULT CNNTPTransport::HandleConnectResponse(void)
    {
    HRESULT hr = E_FAIL;

    IxpAssert(m_substate >= NS_CONNECT_RESP);

    switch (m_substate)
        {
        // Parse the banner and make sure we got a valid response.  If so,
        // then issue a "MODE READER" command to inform the server that we
        // are a client and not another server.
        case NS_CONNECT_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // Make sure we got a valid response from the server
                if (IXP_NNTP_POST_ALLOWED != m_uiResponse && 
                    IXP_NNTP_POST_NOTALLOWED != m_uiResponse)
                    {
                    // If we didn't get a valid response, disconnect and inform
                    // the client that the connect failed.
                    Disconnect();
                    m_state = NS_DISCONNECTED;
                    DispatchResponse(IXP_E_NNTP_RESPONSE_ERROR, TRUE);
                    }
                else
                    {
                    // Stash the response code so if we finally connect we can
                    // return whether or not posting is allowed
                    m_hrPostingAllowed = 
                        (m_uiResponse == IXP_NNTP_POST_ALLOWED) ? S_OK : S_FALSE;

                    // Move to the next state where we issue the "MODE READER"
                    hr = HrSendCommand((LPSTR) NNTP_MODE_READER_CRLF, NULL, FALSE);
                    if (SUCCEEDED(hr))
                        {
                        m_state = NS_CONNECT;
                        m_substate = NS_MODE_READER_RESP;
                        }
                    }
                }
            break;

        // Read the response from the "MODE READER" command off the socket.  If
        // the user wants us to handle authentication, then start that.
        // Otherwise, we're done and can consider this a terminal state.
        case NS_MODE_READER_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_fConnectAuth) 
                    // This is TRUE if the user specified in the Connect() call
                    // that we should automatically logon for them.
                    StartLogon();
                else
                    {
                    // Otherwise consider ourselves ready to accept commands
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }
                }
            break;

        // We issued an empty AUTHINFO GENERIC command to get a list of security
        // packages supported by the server.  We parse that list and continue with
        // sicily authentication.
        case NS_GENERIC_TEST:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_uiResponse == IXP_NNTP_AUTH_OK)
                    {
                    m_substate = NS_GENERIC_PKG_DATA;
                    hr = ProcessGenericTestResponse();
                    }
                else
                    {
                    // could be an old MSN server, so try AUTHINFO TRANSACT TWINKIE
                    hr = HrSendCommand((LPSTR) NNTP_TRANSACTTEST_CRLF, NULL, FALSE);
                    m_substate = NS_TRANSACT_TEST;
                    }
                }
            break;

        // We issued an empty AUTHINFO GENERIC command to get a list of security
        // packages supported by the server.  We parse that list and continue with
        // sicily authentication.
        case NS_GENERIC_PKG_DATA:
            hr = ProcessGenericTestResponse();
            break;

        // We issued a invalid AUTHINFO TRANSACT command to get a list of security
        // packages supported by the server.  We parse that list and continue with
        // sicily authentication.
        case NS_TRANSACT_TEST:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                ProcessTransactTestResponse();
                }
            break;

        // We issued a AUTHINFO {TRANSACT|GENERIC} <package name> to the server.  Parse this
        // response to see if the server understands the package.  If so, then send
        // the negotiation information, otherwise try a different security package.
        case NS_TRANSACT_PACKAGE:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_uiResponse == IXP_NNTP_PASSWORD_REQUIRED)
                    {
                    Assert(m_iAuthType != AUTHINFO_NONE);
                    if (m_iAuthType == AUTHINFO_GENERIC)
                        HrSendCommand((LPSTR) NNTP_GENERICCMD, m_sicmsg.szBuffer, FALSE);
                    else
                        HrSendCommand((LPSTR) NNTP_TRANSACTCMD, m_sicmsg.szBuffer, FALSE);
                    m_substate = NS_TRANSACT_NEGO;
                    }
                else
                    {
                    TryNextSecPkg();
                    }
                }
            break;

        // We received a response to our negotiation command.  If the response 
        // is 381, then generate a response to the server's challange.  Otherwise,
        // we disconnect and try to reconnect with the next security package.
        case NS_TRANSACT_NEGO:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_uiResponse == IXP_NNTP_PASSWORD_REQUIRED)
                    {
                    SSPIBUFFER Challenge, Response;

                    // Skip over the "381 "
                    SSPISetBuffer(m_pszResponse + 4, SSPI_STRING, 0, &Challenge);

                    // Generate a response from the server's challange
                    if (SUCCEEDED(hr = SSPIResponseFromChallenge(&m_sicinfo, &Challenge, &Response)))
                        {
                        Assert(m_iAuthType != AUTHINFO_NONE);
                        if (m_iAuthType == AUTHINFO_GENERIC)
                            HrSendCommand((LPSTR) NNTP_GENERICCMD, Response.szBuffer, FALSE);
                        else
                            HrSendCommand((LPSTR) NNTP_TRANSACTCMD, Response.szBuffer, FALSE);
                        // if a continue is required, stay in this state
                        if (!Response.fContinue)
                            m_substate = NS_TRANSACT_RESP;
                        break;
                        }
                    else
                        {
                        Disconnect();
                        DispatchResponse(IXP_E_SICILY_LOGON_FAILED, TRUE);
                        break;
                        }
                    }
                else
                    m_fRetryPkg = TRUE;

                // We need to reset the connection if we get here
                m_substate = NS_RECONNECTING;
                OnStatus(IXP_AUTHRETRY);
                m_pSocket->Close();
                m_pSocket->Connect();
                }
            break;

        // This is the final response to our sicily negotiation.  This should
        // be either that we succeeded or didn't.  If we succeeded, then we've
        // reached a terminal state and can inform the user that we're ready
        // to accept commands.  Otherwise, we reconnect and try the next
        // security package.
        case NS_TRANSACT_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (IXP_NNTP_AUTH_OK == m_uiResponse)
                    {
                    OnStatus(IXP_AUTHORIZED);
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }
                else
                    {
                    // We need to reset the connection
                    OnStatus(IXP_AUTHRETRY);
                    m_substate = NS_RECONNECTING;
                    m_fRetryPkg = TRUE;
                    m_pSocket->Close();
                    m_pSocket->Connect();
                    }
                }
            break;

        // We issued an AUTHINFO USER <username> and this is the server's 
        // response.  We're expecting either that a password is required or 
        // that we've succeesfully authenticated.
        case NS_AUTHINFO_USER_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // If the server requires a password to go along with the username
                // then send it now.
                if (IXP_NNTP_PASSWORD_REQUIRED == m_uiResponse)
                    {
                    LPSTR pszPassword;

                    // Choose the password based on if we were called from 
                    // Connect() or CommandAUTHINFO().
                    if (m_state == NS_AUTHINFO)
                        pszPassword = m_pAuthInfo->pszPass;
                    else
                        pszPassword = m_rServer.szPassword;

                    HrSendCommand((LPSTR) NNTP_AUTHINFOPASS, pszPassword, FALSE);
                    m_substate = NS_AUTHINFO_PASS_RESP;
                    }

                // Otherwise, consider ourselves connected and in a state to accept
                // commands
                else
                    {
                    OnStatus(IXP_AUTHORIZED);
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }
                }
            break;

        // We sent a AUTHINFO PASS <password> command to complement the AUTHINFO 
        // USER command.  This response will tell us whether we're authenticated
        // or not.  Either way this is a terminal state.
        case NS_AUTHINFO_PASS_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // If the password was accepted, consider ourselves connected 
                // and in a state to accept commands.
                if (IXP_NNTP_AUTH_OK >= m_uiResponse)
                    {
                    OnStatus(IXP_AUTHORIZED);
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }

                // If the password was rejected, then use the callback to prompt
                // the user for new credentials.
                else
                    {
                    // Need to disconnect and reconnect to make sure we're in a
                    // known, stable state with the server.
                    m_substate = NS_RECONNECTING;

                    if (FAILED(LogonRetry(IXP_E_NNTP_INVALID_USERPASS)))
                        {
                        DispatchResponse(IXP_E_USER_CANCEL, TRUE);
                        }
                    }
                }
            break;

        // We sent a AUTHINFO SIMPLE command to the server to see if the command
        // is supported.  If the server returns 350, then we should send the
        // username and password
        case NS_AUTHINFO_SIMPLE_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // If we got a response to continue, then send the user name and
                // password
                if (IXP_NNTP_CONTINUE_AUTHORIZATION == m_uiResponse)
                    {
                    IxpAssert(m_pAuthInfo);

                    if (SUCCEEDED(hr = HrSendCommand(m_pAuthInfo->pszUser, 
                                                     m_pAuthInfo->pszPass, FALSE)))
                        m_substate = NS_AUTHINFO_SIMPLE_USERPASS_RESP;
                    else
                        DispatchResponse(hr, TRUE);
                    }
                else
                    {
                    // Otherwise fail and inform the user.
                    DispatchResponse(hr, TRUE);
                    }
                }
            break;

        // This is the final response from the AUTHINFO SIMPLE command.  All 
        // we need to do is inform the user.
        case NS_AUTHINFO_SIMPLE_USERPASS_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                DispatchResponse(hr, TRUE);
                }
            break;

        }

    return (hr);
    }


//
//  FUNCTION:   CNNTPTransport::DispatchResponse()
//
//  PURPOSE:    Takes the server response string, packages it up into a
//              NNTPRESPONSE structure, and returns it to the callback 
//              interface.
//
//  PARAMETERS:
//      hrResult  - The result code to send to the callback.
//      fDone     - True if the command has completed.
//      pResponse - If the command is returning data, then this should
//                  be filled in with the data to be returned.
//
void CNNTPTransport::DispatchResponse(HRESULT hrResult, BOOL fDone, 
                                      LPNNTPRESPONSE pResponse)
{
    // Locals
    NNTPRESPONSE rResponse;

    // If a response was passed in, use it...
    if (pResponse)
        CopyMemory(&rResponse, pResponse, sizeof(NNTPRESPONSE));
    else
        ZeroMemory(&rResponse, sizeof(NNTPRESPONSE));

    rResponse.fDone = fDone;

    // Set up the return structure
    rResponse.state = m_state;
    rResponse.rIxpResult.hrResult = hrResult;
    rResponse.rIxpResult.pszResponse = PszDupA(m_pszResponse);
    rResponse.rIxpResult.uiServerError = m_uiResponse;
    rResponse.rIxpResult.hrServerError = m_hrResponse;
    rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rResponse.rIxpResult.pszProblem = NULL;
    rResponse.pTransport = this;

    // If Done...
    if (fDone)
    {
        // No current command
        m_state = NS_IDLE;
        m_substate = NS_RESP;

        // Reset Last Response
        SafeMemFree(m_pszResponse);
        m_hrResponse = S_OK;
        m_uiResponse = 0;

        // If we have user/pass info cached, free it
        if (m_pAuthInfo)
            {
            SafeMemFree(m_pAuthInfo->pszUser);
            SafeMemFree(m_pAuthInfo->pszPass);
            SafeMemFree(m_pAuthInfo);
            }

        // Leave Busy State
        LeaveBusy();
    }

    // Give the Response to the client
    if (m_pCallback)
        ((INNTPCallback *) m_pCallback)->OnResponse(&rResponse);
    SafeMemFree(rResponse.rIxpResult.pszResponse);
}


//
//  FUNCTION:   CNNTPTransport::HrGetResponse()
//
//  PURPOSE:    Reads the server response string off the socket and stores
//              the response info in local members.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CNNTPTransport::HrGetResponse(void)
    {
    HRESULT hr = S_OK;
    int     cbLine;

    // Clear response
    if (m_pszResponse != NULL)
        SafeMemFree(m_pszResponse);

    // Read the line from the socket
    hr = m_pSocket->ReadLine(&m_pszResponse, &cbLine);

    // Handle incomplete lines
    if (hr == IXP_E_INCOMPLETE)
        goto exit;
    
    // Socket error
    if (FAILED(hr))
        {
        hr = TrapError(IXP_E_SOCKET_READ_ERROR);
        goto exit;
        }

    // Strip the trailing CRLF
    StripCRLF(m_pszResponse, (ULONG *) &cbLine);

    // Log it
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_RX, m_pszResponse);

    // Get the response code from the beginning of the string
    m_uiResponse = StrToInt(m_pszResponse);

    // Tell the client about the server response
    if (m_pCallback)
        m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, NNTPTHISIXP);

exit:
    return (hr);
    }


//
//  FUNCTION:   CNNTPTransport::StartLogon()
//
//  PURPOSE:    Starts the login process with the server based on information
//              provided by the user in Connect().
//
void CNNTPTransport::StartLogon(void)
    {
    HRESULT hr;

    // If not using sicily or it's not installed, try simple USER/PASS authentication
    if (m_rServer.fTrySicily)
        {
        // If sicily is installed
        if (FIsSicilyInstalled())
            {
            // Status
            OnStatus(IXP_AUTHORIZING);

            // If we haven't enumerated the security packages yet, do so
            if (m_cSecPkg == -1)
                {
                hr = HrSendCommand((LPSTR) NNTP_GENERICTEST_CRLF, NULL, FALSE);
                m_substate = NS_GENERIC_TEST;
                }
            else
                {
                // We've reconnected, try the next security package
                TryNextSecPkg();
                }
            }
        else
            {
            Disconnect();
            DispatchResponse(IXP_E_LOAD_SICILY_FAILED, TRUE);
            }
        }
    else
        {
        hr = MaybeTryAuthinfo();
        if (FAILED(hr))
            {
            OnError(hr);
            DropConnection();
            DispatchResponse(hr, TRUE);
            }
        }
    }

HRESULT CNNTPTransport::LogonRetry(HRESULT hrLogon)
    {
    HRESULT hr = S_OK;

    // Let the user know that the logon failed
    OnError(hrLogon);

    // Update the transport status
    OnStatus(IXP_AUTHRETRY);

    // Enter Auth Retry State
    m_pSocket->Close();

    // Turn off the watchdog timer
    m_pSocket->StopWatchDog();

    // Ask the user to provide credetials
    if (NULL == m_pCallback || S_FALSE == m_pCallback->OnLogonPrompt(&m_rServer, NNTPTHISIXP))
        {
        OnDisconnected();
        return (E_FAIL);
        }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        OnError(TrapError(IXP_E_SOCKET_CONNECT_ERROR));
        OnDisconnected();
        return hr;
    }

    // Start WatchDog
    m_pSocket->StartWatchDog();
    return (S_OK);
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::ProcessGenericTestResponse
//
//   processes AUTHINFO GENERIC response
//
HRESULT CNNTPTransport::ProcessGenericTestResponse()
    {
    HRESULT     hr;
    LPSTR       pszLines = NULL;
    int         iRead, iLines;
      
    m_cSecPkg = 0;
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        LPSTR pszT = pszLines, pszPkg;

        while (*pszT && m_cSecPkg < MAX_SEC_PKGS)
            {
            // check for end of list condition
            if ((pszT[0] == '.') && ((pszT[1] == '\r' && pszT[2] == '\n') || (pszT[1] == '\n')))
                break;
            pszPkg = pszT;
            // look for an LF or CRLF to end the line
            while (*pszT && !(pszT[0] == '\n' || (pszT[0] == '\r' && pszT[1] == '\n')))
                pszT++;
            // strip the LF or CRLF
            while (*pszT == '\r' || *pszT == '\n')
                *pszT++ = 0;
            m_rgszSecPkg[m_cSecPkg++] = PszDupA(pszPkg);
            }

        // we've reached the end of the list, otherwise there is more data expected
        if (pszT[0] == '.')
            {
            Assert(pszT[1] == '\r' && pszT[2] == '\n');
            m_iAuthType = AUTHINFO_GENERIC;
            hr = TryNextSecPkg();
            }

        MemFree(pszLines);
        }
    return hr;
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::ProcessTransactTestResponse
//
//   processes AUTHINFO TRANSACT TWINKIE response
//
HRESULT CNNTPTransport::ProcessTransactTestResponse()
    {
    HRESULT hr = NOERROR;

    m_cSecPkg = 0;
    if (m_uiResponse == IXP_NNTP_PROTOCOLS_SUPPORTED)
        {
        LPSTR pszT;

        pszT = m_szSecPkgs = PszDupA(m_pszResponse + 3); // skip over 485
        while (*pszT && IsSpace(pszT))
            pszT++;
        while (*pszT && m_cSecPkg < MAX_SEC_PKGS)
            {
            m_rgszSecPkg[m_cSecPkg++] = pszT;
            while (*pszT && !IsSpace(pszT))
                pszT++;
            while (*pszT && IsSpace(pszT))
                *pszT++ = 0;
            }
        m_iAuthType = AUTHINFO_TRANSACT;
        return TryNextSecPkg();                        
        }
    else
        {
        Disconnect();
        DispatchResponse(IXP_E_SICILY_LOGON_FAILED, TRUE);
        return NOERROR;
        }
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::TryNextSecPkg
//
//   tries the next security package, or reverts to basic if necessary
//
HRESULT CNNTPTransport::TryNextSecPkg()
    {
    HRESULT hr;

    Assert(m_cSecPkg != -1);
    Assert(m_iAuthType != AUTHINFO_NONE);    

TryNext:

    if (!m_fRetryPkg)
        m_iSecPkg++;

    if (m_iSecPkg < m_cSecPkg)
        {
        Assert(m_cSecPkg);
        SSPIFreeContext(&m_sicinfo);
        if (!lstrcmpi(m_rgszSecPkg[m_iSecPkg], NNTP_BASIC))
            return MaybeTryAuthinfo();

        // In case the Sicily function brings up UI, we need to turn off the 
        // watchdog so we don't time out waiting for the user
        m_pSocket->StopWatchDog();

        if (SUCCEEDED(hr = SSPILogon(&m_sicinfo, m_fRetryPkg, SSPI_BASE64, m_rgszSecPkg[m_iSecPkg], &m_rServer, m_pCallback)))
            {
            if (m_fRetryPkg)
                {
                m_fRetryPkg = FALSE;
                }
            if (SUCCEEDED(hr = SSPIGetNegotiate(&m_sicinfo, &m_sicmsg)))
                {
                DOUTL(2, "Trying to connect using %s security...", m_rgszSecPkg[m_iSecPkg]);
                if (m_iAuthType == AUTHINFO_GENERIC)
                    hr = HrSendCommand((LPSTR) NNTP_GENERICCMD, m_rgszSecPkg[m_iSecPkg], FALSE);
                else
                    hr = HrSendCommand((LPSTR) NNTP_TRANSACTCMD, m_rgszSecPkg[m_iSecPkg], FALSE);

                // Restart the watchdog timer now that we've issued our next command to the server.
                m_pSocket->StartWatchDog();

                m_substate = NS_TRANSACT_PACKAGE;
                }
            else
                {
                hr = IXP_E_SICILY_LOGON_FAILED;
                goto TryNext;
                }
            }
        else
            {
            m_fRetryPkg = FALSE;
            goto TryNext;
            }
        }
    else
        {
        OnError(IXP_E_SICILY_LOGON_FAILED);

        DropConnection();
        DispatchResponse(IXP_E_SICILY_LOGON_FAILED, TRUE);
        hr = NOERROR;
        }
    return hr;
    }


/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::MaybeTryAuthinfo
//
//   tries basic authinfo if necessary, else moves to connected state
//
HRESULT CNNTPTransport::MaybeTryAuthinfo()
    {
    HRESULT hr;

    if (*m_rServer.szUserName)
        {
        OnStatus(IXP_AUTHORIZING);
        hr = HrSendCommand((LPSTR) NNTP_AUTHINFOUSER, m_rServer.szUserName, FALSE);
        m_substate = NS_AUTHINFO_USER_RESP;
        }
    else
        {
        // Logon not needed for this news server (or so we'll have to assume)
        OnStatus(IXP_AUTHORIZED);
        DispatchResponse(S_OK, TRUE);
        hr = NOERROR;
        }
    return hr;
    }

#define Whitespace(_ch) (((_ch) == ' ') || ((_ch) == '\t') || ((_ch) == '\n'))

BOOL ScanNum(LPSTR *ppsz, BOOL fEnd, DWORD *pdw)
    {
    DWORD n = 0;
    LPSTR psz;

    Assert(ppsz != NULL);
    Assert(pdw != NULL);

    psz = *ppsz;
    if (*psz == 0 || Whitespace(*psz))
        return(FALSE);

    while (*psz != 0 && !Whitespace(*psz))
        {
        if (*psz >= '0' && *psz <= '9')
            {
            n *= 10;
            n += *psz - '0';
            psz++;
            }
        else
            {
            return(FALSE);
            }
        }

    if (Whitespace(*psz))
        {
        if (fEnd)
            return(FALSE);
        while (*psz != 0 && Whitespace(*psz))
            psz++;
        }
    else
        {
        Assert(*psz == 0);
        if (!fEnd)
            return(FALSE);
        }

    *ppsz = psz;
    *pdw = n;

    return(TRUE);
    }

BOOL ScanWord(LPCSTR psz, LPSTR pszDest)
    {
    Assert(psz != NULL);
    Assert(pszDest != NULL);

    if (*psz == 0 || Whitespace(*psz))
        return(FALSE);

    while (*psz != 0 && !Whitespace(*psz))
        {
        *pszDest = *psz;
        psz++;
        pszDest++;
        }

    *pszDest = 0;

    return(TRUE);
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::ProcessGroupResponse
//
//   processes the GROUP response
//
HRESULT CNNTPTransport::ProcessGroupResponse(void)
{
    NNTPGROUP       rGroup;
    DWORD           dwResp;
    NNTPRESPONSE    rResp;
    LPSTR           psz;
    LPSTR           pszGroup = 0;

    ZeroMemory(&rGroup, sizeof(NNTPGROUP));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));
    
    if (m_uiResponse == IXP_NNTP_GROUP_SELECTED)
    {
        rResp.fMustRelease = TRUE;
        pszGroup = PszDupA(m_pszResponse);
        psz = m_pszResponse;
        if (!ScanNum(&psz, FALSE, &dwResp) ||
            !ScanNum(&psz, FALSE, &rGroup.dwCount) ||
            !ScanNum(&psz, FALSE, &rGroup.dwFirst) ||
            !ScanNum(&psz, FALSE, &rGroup.dwLast) ||
            !ScanWord(psz, pszGroup))
        {
            m_hrResponse = IXP_E_NNTP_RESPONSE_ERROR;
        }
        else
        {
            if (pszGroup)
            {
                rGroup.pszGroup = PszDupA(pszGroup);
            }
            rResp.rGroup = rGroup;
        }
    }
    else if (m_uiResponse == IXP_NNTP_NO_SUCH_NEWSGROUP)
        m_hrResponse = IXP_E_NNTP_GROUP_NOTFOUND;
    else
        m_hrResponse = IXP_E_NNTP_GROUP_FAILED;

    DispatchResponse(m_hrResponse, TRUE, &rResp);

    SafeMemFree(pszGroup);
    return (m_hrResponse);
}

HRESULT CNNTPTransport::ProcessNextResponse(void)
    {
    LPSTR           psz;
    NNTPNEXT        rNext;
    DWORD           dwResp;
    NNTPRESPONSE    rResp;

    ZeroMemory(&rNext, sizeof(NNTPNEXT));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // If success was returned, then parse the response
    if (m_uiResponse == IXP_NNTP_ARTICLE_RETRIEVED)
        {
        rResp.fMustRelease = TRUE;

        // Allocate a buffer for the message id
        rNext.pszMessageId = PszAllocA(lstrlen(m_pszResponse));
        if (NULL != rNext.pszMessageId)
            {
            psz = m_pszResponse;
            if (!ScanNum(&psz, FALSE, &dwResp) ||
                !ScanNum(&psz, FALSE, &rNext.dwArticleNum) ||
                !ScanWord(psz, rNext.pszMessageId))
                {
                m_hrResponse = IXP_E_NNTP_RESPONSE_ERROR;
                }
            else
                {
                m_hrResponse = S_OK;

                // Since this is just a union, a little sleeze and we wouldn't
                // actually need to to this...
                if (m_state == NS_NEXT)
                    rResp.rNext = rNext;
                else if (m_state == NS_LAST)
                    rResp.rLast = rNext;
                else
                    rResp.rStat = rNext;
                }
            }
        else
            {
            m_hrResponse = TrapError(E_OUTOFMEMORY);
            }
        }
    else if ((m_state == NS_NEXT && m_uiResponse == IXP_NNTP_NO_NEXT_ARTICLE) ||
             (m_state == NS_LAST && m_uiResponse == IXP_NNTP_NO_PREV_ARTICLE) ||
             (m_state == NS_STAT && m_uiResponse == IXP_NNTP_NO_SUCH_ARTICLE_NUM))
        {
        m_hrResponse = IXP_E_NNTP_NEXT_FAILED;
        }
    else
        m_hrResponse = S_OK;

    DispatchResponse(m_hrResponse, TRUE, &rResp);
    return (m_hrResponse);
    }


HRESULT CNNTPTransport::ProcessListData(void)
    {
    HRESULT         hr = S_OK;
    LPSTR           pszLines = NULL;
    DWORD           dwRead, dwLines;
    NNTPLIST        rList;
    LPSTR           pszT;
    NNTPRESPONSE    rResponse;

    ZeroMemory(&rList, sizeof(NNTPLIST));
    ZeroMemory(&rResponse, sizeof(NNTPRESPONSE));

    // Get the remaining data off the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, (int *)&dwRead, (int *)&dwLines)))
        {
        // Allocate and array to hold the lines
        if (!MemAlloc((LPVOID*) &rList.rgszLines, dwLines * sizeof(LPSTR)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        ZeroMemory(rList.rgszLines, sizeof(LPSTR) * dwLines);

        // Parse the buffer returned from the protocol.  We need to find the 
        // end of the list.
        pszT = pszLines;
        while (*pszT)
            {
            // Check for the end of list condition
            if ((pszT[0] == '.') && ((pszT[1] == '\r' && pszT[2] == '\n') || (pszT[1] == '\n')))
                break;

            // Save the line
            rList.rgszLines[rList.cLines++] = pszT;

            // Find the LF or CRLF at the end of the line
            while (*pszT && !(pszT[0] == '\n' || (pszT[0] == '\r' && pszT[1] == '\n')))
                pszT++;

            // Strip off the LF or CRLF and add a terminator
            while (*pszT == '\r' || *pszT == '\n')
                *pszT++ = 0;
            }

        // If we parsed more lines off of the buffer than was returned to us, 
        // then either we have a parsing bug, or the socket class has a counting 
        // bug.
        IxpAssert(rList.cLines <= dwLines);

        // We've readed the end of the list, otherwise there is more data expected
        if (pszT[0] == '.')
            {
            // Double check that this dot is followed by a CRLF
            IxpAssert(pszT[1] == '\r' && pszT[2] == '\n');
            rResponse.fDone = TRUE;
            }

        rResponse.rList = rList;
        rResponse.fMustRelease = TRUE;
        DispatchResponse(S_OK, rResponse.fDone, &rResponse);
        }

    return (hr);

error:
    SafeMemFree(pszLines);
    return (hr);
    }

HRESULT CNNTPTransport::ProcessListGroupData(void)
    {
    HRESULT         hr = S_OK;
    LPSTR           pszLines = NULL;
    LPSTR           pszBeginLine = NULL;
    DWORD           dwRead, dwLines;
    NNTPLISTGROUP   rListGroup;
    LPSTR           pszT;
    NNTPRESPONSE    rResp;

    ZeroMemory(&rListGroup, sizeof(NNTPLIST));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Get the remaining data off the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, (int *)&dwRead, (int *)&dwLines)))
        {
        // Allocate and array to hold the lines
        if (!MemAlloc((LPVOID*) &rListGroup.rgArticles, dwLines * sizeof(DWORD)))
            {
            hr = E_OUTOFMEMORY;
            OnError(E_OUTOFMEMORY);
            goto error;
            }

        // Parse the buffer returned from the protocol.  We need to find the 
        // end of the list.
        pszT = pszLines;
        rListGroup.cArticles = 0;
        while (*pszT)
            {
            // Check for the end of list condition
            if ((pszT[0] == '.') && ((pszT[1] == '\r' && pszT[2] == '\n') || (pszT[1] == '\n')))
                break;

            // Save the beginning of the line
            pszBeginLine = pszT;

            // Find the LF or CRLF at the end of the line
            while (*pszT && !(pszT[0] == '\n' || (pszT[0] == '\r' && pszT[1] == '\n')))
                pszT++;

            // Strip off the LF or CRLF and add a terminator
            while (*pszT == '\r' || *pszT == '\n')
                *pszT++ = 0;

            // Convert the line to a number and add it to the array
            rListGroup.rgArticles[rListGroup.cArticles] = StrToInt(pszBeginLine);
            if (rListGroup.rgArticles[rListGroup.cArticles])
                rListGroup.cArticles++;
            }

        // If we parsed more lines off of the buffer than was returned to us, 
        // then either we have a parsing bug, or the socket class has a counting 
        // bug.
        IxpAssert(rListGroup.cArticles <= dwLines);

        // We've readed the end of the list, otherwise there is more data expected
        if (pszT[0] == '.')
            {
            // Double check that this dot is followed by a CRLF
            IxpAssert(pszT[1] == '\r' && pszT[2] == '\n');
            rResp.fDone = TRUE;
            }

        rResp.rListGroup = rListGroup;
        rResp.fMustRelease = TRUE;
        DispatchResponse(S_OK, rResp.fDone, &rResp);
        }

error:
    SafeMemFree(pszLines);
    return (hr);
    }

BOOL CharsToNum(LPCSTR psz, int cch, WORD *pw)
    {
    int i;
    WORD w = 0;

    Assert(psz != NULL);
    Assert(pw != NULL);

    for (i = 0; i < cch; i++)
        {
        if (*psz >= '0' && *psz <= '9')
            {
            w *= 10;
            w += *psz - '0';
            psz++;
            }
        else
            {
            return(FALSE);
            }
        }

    *pw = w;

    return(TRUE);
    }

HRESULT CNNTPTransport::ProcessDateResponse(void)
    {
    HRESULT      hr = S_OK;
    SYSTEMTIME   st;
    NNTPRESPONSE rResp;
    DWORD        dwResp;
    LPSTR        psz;

    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // This information is returned in the format YYYYMMDDhhmmss
    if (m_uiResponse == IXP_NNTP_DATE_RESPONSE)
        {
        ZeroMemory(&st, sizeof(SYSTEMTIME));

        psz = StrChr(m_pszResponse, ' ');
        if (psz == NULL ||
            !CharsToNum(++psz, 4, &st.wYear) ||
            !CharsToNum(&psz[4], 2, &st.wMonth) ||
            !CharsToNum(&psz[6], 2, &st.wDay) ||
            !CharsToNum(&psz[8], 2, &st.wHour) ||
            !CharsToNum(&psz[10], 2, &st.wMinute) ||
            !CharsToNum(&psz[12], 2, &st.wSecond))
            {
            m_hrResponse = IXP_E_NNTP_RESPONSE_ERROR;
            }
        else
            {
            rResp.rDate = st;
            m_hrResponse = S_OK;
            }
        }
    else
        m_hrResponse = IXP_E_NNTP_DATE_FAILED;

    DispatchResponse(m_hrResponse, TRUE, &rResp);
    return (hr);
    }


HRESULT CNNTPTransport::ProcessArticleData(void)
    {
    HRESULT     hr;
    DWORD       dwRead, dwLines;
    LPSTR       psz;
    DWORD       cbSubtract;
    NNTPARTICLE rArticle;
    NNTPRESPONSE rResp;

    ZeroMemory(&rArticle, sizeof(NNTPARTICLE));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Bug #25073 - Get the article number from the response string
    DWORD dwT;
    psz = m_pszResponse;
    ScanNum(&psz, FALSE, &dwT);
    ScanNum(&psz, TRUE, &rArticle.dwArticleNum);

    // Read the waiting data off the socket
    hr = m_pSocket->ReadLines(&rArticle.pszLines, (int*) &dwRead, (int*) &dwLines);
    if (hr == IXP_E_INCOMPLETE)
        return (hr);

    // Check forfailure
    if (FAILED(hr))
        {
        DispatchResponse(hr);
        return (hr);
        }

    // See if this is the end of the response
    if (FEndRetrRecvBodyNews(rArticle.pszLines, dwRead, &cbSubtract))
        {
        // Remove the trailing dot from the buffer
        dwRead -= cbSubtract;
        rArticle.pszLines[dwRead] = 0;
        rResp.fDone = TRUE;
        }

    // Unstuff the dots
    UnStuffDotsFromLines(rArticle.pszLines, (int *)&dwRead);
    rArticle.pszLines[dwRead] ='\0';

    // Fill out the response
    rResp.rArticle = rArticle;
    rResp.rArticle.cbLines = dwRead;
    rResp.rArticle.cLines = dwLines;
    rResp.fMustRelease = TRUE;

    DispatchResponse(hr, rResp.fDone, &rResp);

    return hr;
    }

HRESULT CNNTPTransport::ProcessXoverData(void)
    {
    HRESULT             hr;
    LPSTR               pszLines = NULL;
    LPSTR               pszNextLine = NULL;
    LPSTR               pszField = NULL;
    LPSTR               pszNextField = NULL;
    int                 iRead, iLines;
    NNTPHEADERRESP      rHdrResp;
    NNTPRESPONSE        rResp;
    NNTPHEADER         *rgHdr;
    PMEMORYINFO         pMemInfo = 0;

    ZeroMemory(&rHdrResp, sizeof(NNTPHEADERRESP));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Read the data that is waiting on the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        // Allocate the MEMORYINFO struct we use to stash the pointers
        if (!MemAlloc((LPVOID*) &pMemInfo, sizeof(MEMORYINFO)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        pMemInfo->cPointers = 1;
        pMemInfo->rgPointers[0] = pszLines;
        rHdrResp.dwReserved = (DWORD_PTR) pMemInfo;

        // Allocate the array of headers
        Assert(iLines);
        if (!MemAlloc((LPVOID*) &(rHdrResp.rgHeaders), iLines * sizeof(NNTPHEADER)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        rgHdr = rHdrResp.rgHeaders;

        // Loop until we either run out of lines or we find a line that begins 
        // with "."
        pszNextLine = pszLines;
        while (*pszNextLine && *pszNextLine != '.')
            {
            pszField = pszNextLine;

            // Look ahead to find the beginning of the next line
            while (*pszNextLine)
                {
                if (*pszNextLine == '\n')
                    {
                    // NULL out a CR followed by a LF
                    if (pszNextLine > pszField && *(pszNextLine - 1) == '\r')
                        *(pszNextLine - 1) = 0;

                    // NULL out and skip over the LF
                    *pszNextLine++ = 0;
                    break;
                    }
                pszNextLine++;
                }

            // At this point, pszField points to the beginning of this XOVER
            // line, and pszNextLine points to the next.

            // Parse the article number field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].dwArticleNum = StrToInt(pszField);
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the Subject: field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszSubject = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the From: field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszFrom = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the Date: field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszDate = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the Message-ID field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszMessageId = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            rgHdr[rHdrResp.cHeaders].pszReferences = pszField;
            pszField = GetNextField(pszField);

            // Parse the bytes field (we can live without this)
            if (pszField)
                {
                rgHdr[rHdrResp.cHeaders].dwBytes = StrToInt(pszField);
                pszField = GetNextField(pszField);
                }
            else
                {
                rgHdr[rHdrResp.cHeaders].dwBytes = 0;
                }

            // Parse the article size in lines (we can live without this also)
            if (pszField)
                {
                rgHdr[rHdrResp.cHeaders].dwLines = StrToInt(pszField);
                pszField = GetNextField(pszField);
                }
            else
                {
                rgHdr[rHdrResp.cHeaders].dwLines = 0;
                }

            // NOTE: The XRef: field in the XOver record is an optional field 
            // that a server may or may not support.  Also, if the message is  
            // not crossposted, then the XRef: field won't be present either.  
            // Therefore just cause we don't find any XRef: fields doesn't mean
            // it isn't supported.

            // Look for aditional fields that might contain XRef
            rgHdr[rHdrResp.cHeaders].pszXref = 0;
            while (pszField)
                {
                if (!StrCmpNI(pszField, c_szXrefColon, 5))
                    {
                    // We found at least one case where the xref: was supplied.
                    // We now know for sure that this server supports the xref:
                    // field in it's XOver records.
                    m_fSupportsXRef = TRUE;    
                    rgHdr[rHdrResp.cHeaders].pszXref = pszField + 6;
                    break;
                    }

                pszField = GetNextField(pszField);
                }

            rHdrResp.cHeaders++;

            // If we've found a bad record, then we just skip right over it 
            // and move on to the next.
badrecord:
            ;
            }

        // We've reached the end of the list, otherwise there is more data
        // expected.
        rResp.fDone = (*pszNextLine == '.');
        rHdrResp.fSupportsXRef = m_fSupportsXRef;

        // Return what we've retrieved
        rResp.fMustRelease = TRUE;
        rResp.rHeaders = rHdrResp;

        DispatchResponse(hr, rResp.fDone, &rResp);
        return (S_OK);
        }
    return (hr);

error:
    // Free anything we've allocated
    SafeMemFree(rHdrResp.rgHeaders);
    SafeMemFree(pMemInfo);
    SafeMemFree(pszLines);
    DispatchResponse(hr, TRUE);
    return (hr);
    }


// Data comes in the form "<article number> <header>"
HRESULT CNNTPTransport::ProcessXhdrData(void)
    {
    HRESULT hr;
    LPSTR               pszLines = NULL;
    LPSTR               pszNextLine = NULL;
    LPSTR               pszField = NULL;
    LPSTR               pszNextField = NULL;
    int                 iRead, iLines;
    NNTPXHDRRESP        rXhdr;
    NNTPRESPONSE        rResp;
    NNTPXHDR           *rgHdr = 0;
    PMEMORYINFO         pMemInfo = 0;

    ZeroMemory(&rXhdr, sizeof(NNTPXHDRRESP));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Read the data that is waiting on the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        // Allocate the MEMORYINFO struct we use to stash the pointers
        if (!MemAlloc((LPVOID*) &pMemInfo, sizeof(MEMORYINFO)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        pMemInfo->cPointers = 1;
        pMemInfo->rgPointers[0] = pszLines;
        rXhdr.dwReserved = (DWORD_PTR) pMemInfo;

        // Allocate the array of XHDRs
        Assert(iLines);
        if (!MemAlloc((LPVOID*) &(rXhdr.rgHeaders), iLines * sizeof(NNTPXHDR)))
            {
            // This is _very_ broken.  We leave a whole bunch of data on the
            // socket.  What should we do?
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        rgHdr = rXhdr.rgHeaders;

        // Loop until we either run out of lines or we find a line that begins 
        // with "."
        pszNextLine = pszLines;
        while (*pszNextLine && *pszNextLine != '.')
            {
            pszField = pszNextLine;

            // Scan ahead and find the end of the line
            while (*pszNextLine)
                {
                if (*pszNextLine == '\n')
                    {
                    // NULL out a CR followed by a LF
                    if (pszNextLine > pszField && *(pszNextLine - 1) == '\r')
                        *(pszNextLine - 1) = 0;

                    // NULL out and skip over the LF
                    *pszNextLine++ = 0;
                    break;
                    }
                pszNextLine++;
                }

            // Parse the article number
            rgHdr[rXhdr.cHeaders].dwArticleNum = StrToInt(pszField);

            // Find the seperating space
            rgHdr[rXhdr.cHeaders].pszHeader = 0;
            while (*pszField && *pszField != ' ')
                pszField++;

            // Make the beginning of the header point to the first character
            // after the space.
            if (*(pszField + 1))
                rgHdr[rXhdr.cHeaders].pszHeader = (pszField + 1);

            if (rgHdr[rXhdr.cHeaders].dwArticleNum && rgHdr[rXhdr.cHeaders].pszHeader)
                rXhdr.cHeaders++;
            }

        // We've reached the end of the list, otherwise there is more data
        // expected.
        rResp.fDone = (*pszNextLine == '.');

        // Return what we've retrieved
        rResp.rXhdr = rXhdr;
        rResp.fMustRelease = TRUE;

        DispatchResponse(hr, rResp.fDone, &rResp);
        return (S_OK);
        }

error:
    SafeMemFree(rgHdr);
    SafeMemFree(pMemInfo);
    SafeMemFree(pszLines);
    return (hr);
    }



LPSTR CNNTPTransport::GetNextField(LPSTR pszField)
    {
    while (*pszField && *pszField != '\t')
        pszField++;

    if (*pszField == '\t')
        {
        *pszField++ = 0;
        return pszField;
        }

    return NULL;
    }

HRESULT CNNTPTransport::CommandAUTHINFO(LPNNTPAUTHINFO pAuthInfo)
    {
    HRESULT     hr;
    
    if (!pAuthInfo)
        return (E_INVALIDARG);

    // Make a copy of this struct so we can use the info during the callback
    // if necessary
    if (pAuthInfo->authtype == AUTHTYPE_USERPASS ||
        pAuthInfo->authtype == AUTHTYPE_SIMPLE)
        {
        if (!MemAlloc((LPVOID*) &m_pAuthInfo, sizeof(NNTPAUTHINFO)))
            {
            OnError(E_OUTOFMEMORY);
            return (E_OUTOFMEMORY);
            }
        ZeroMemory(m_pAuthInfo, sizeof(NNTPAUTHINFO));

        m_pAuthInfo->pszUser = PszDupA(pAuthInfo->pszUser);
        m_pAuthInfo->pszPass = PszDupA(pAuthInfo->pszUser);
        }

    EnterCriticalSection(&m_cs);

    // Issue the command as appropriate
    switch (pAuthInfo->authtype)
        {
        case AUTHTYPE_USERPASS:
            hr = HrSendCommand((LPSTR) NNTP_AUTHINFOUSER, pAuthInfo->pszUser);
            if (SUCCEEDED(hr))
                m_substate = NS_AUTHINFO_USER_RESP;
            break;

        case AUTHTYPE_SIMPLE:
            hr = HrSendCommand((LPSTR) NNTP_AUTHINFOSIMPLE_CRLF, NULL);
            if (SUCCEEDED(hr))
                m_substate = NS_AUTHINFO_SIMPLE_RESP;
            break;

        case AUTHTYPE_SASL:
            // If we haven't enumerated the security packages yet, do so
            if (m_cSecPkg == -1)
                {
                hr = HrSendCommand((LPSTR) NNTP_GENERICTEST_CRLF, NULL, FALSE);
                if (SUCCEEDED(hr))
                    m_substate = NS_GENERIC_TEST;
                }
            else
                {
                // We've reconnected, try the next security package
                TryNextSecPkg();
                }
            break;
        }

    if (SUCCEEDED(hr))
        m_state = NS_AUTHINFO;

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CNNTPTransport::CommandGROUP(LPSTR pszGroup)
    {
    HRESULT hr;

    if (!pszGroup)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_GROUP, pszGroup);
    if (SUCCEEDED(hr))
        m_state = NS_GROUP;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandLAST(void)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_LAST_CRLF, NULL);
    if (SUCCEEDED(hr))
        m_state = NS_LAST;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandNEXT(void)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_NEXT_CRLF, NULL);
    if (SUCCEEDED(hr))
        m_state = NS_NEXT;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandSTAT(LPARTICLEID pArticleId)    
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // If we were given a message id, then use that
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_STAT, pArticleId->pszMessageId);
        else
            {
            // Convert the article number to a string and send the command
            wsprintf(szTemp, "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_STAT, szTemp);
            }
        }
    else
        {
        // No number or id, so just send the command
        hr = HrSendCommand((LPSTR) NNTP_STAT, (LPSTR) c_szCRLF);
        }

    if (SUCCEEDED(hr))
        {
        m_state = NS_STAT;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }

HRESULT CNNTPTransport::CommandARTICLE(LPARTICLEID pArticleId)
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // Send the command appropriate to what type of article id was given
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_ARTICLE, pArticleId->pszMessageId);
        else
            {
            // convert the article number to a string and send the command
            wsprintf(szTemp, "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_ARTICLE, szTemp);
            }
        }
    else
        {
        hr = HrSendCommand((LPSTR) NNTP_ARTICLE, (LPSTR) c_szCRLF);
        }

    if (SUCCEEDED(hr))
        {
        m_state = NS_ARTICLE;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandHEAD(LPARTICLEID pArticleId)
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // Send the command appropriate to what type of article id was given
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_HEAD, pArticleId->pszMessageId);
        else
            {
            // convert the article number to a string and send the command
            wsprintf(szTemp, "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_HEAD, szTemp);
            }
        }
    else
        {
        hr = HrSendCommand((LPSTR) NNTP_HEAD, (LPSTR) c_szCRLF);
        }


    if (SUCCEEDED(hr))
        {
        m_state = NS_HEAD;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandBODY(LPARTICLEID pArticleId)
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // Send the command appropriate to what type of article id was given
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_BODY, pArticleId->pszMessageId);
        else
            {
            // conve